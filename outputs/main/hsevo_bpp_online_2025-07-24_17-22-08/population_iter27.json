[
  {
    "stdout_filepath": "problem_iter26_response0.txt_stdout.txt",
    "code_path": "problem_iter26_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a refined balancing term and penalty for large remaining capacity.\n    Encourages tight fits while considering future capacity.\n    \"\"\"\n    # Identify valid bins and calculate remaining capacity after adding the item\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Non-linear prioritization with a balancing term and a penalty for large remaining capacity\n    priority = np.where(valid_bins == 1, \n                         # Use exp to prioritize bins that are just enough for the item\n                         np.exp(-remain_cap_after_add / item) * \n                         # Encourage tighter fits by penalizing bins with large remaining capacity\n                         (1 - remain_cap_after_add / bins_remain_cap), \n                         -np.inf)\n    \n    return priority",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 129.65784284662087,
    "mi": 92.97433782653759,
    "token_count": 114.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter26_response1.txt_stdout.txt",
    "code_path": "problem_iter26_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a refined balancing term for optimal bin selection.\n    \"\"\"\n    # Calculate remaining capacity after adding the item\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Non-linear prioritization with a penalty for large remaining capacity and a balancing term\n    priority = np.where(bins_remain_cap >= item, \n                         np.exp(-remain_cap_after_add / item) * (1 - remain_cap_after_add / bins_remain_cap), \n                         -np.inf)\n    \n    return priority",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 129.65784284662087,
    "mi": 92.97433782653759,
    "token_count": 114.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter26_response2.txt_stdout.txt",
    "code_path": "problem_iter26_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a refined penalty term for large remaining capacities.\n    Uses np.exp for non-linear prioritization and a balancing term to encourage tighter fits.\n    \"\"\"\n    # Identify valid bins and calculate remaining capacity after adding the item\n    valid_bins = (bins_remain_cap >= item)\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Non-linear prioritization with a penalty term for large remaining capacities\n    priority = np.where(valid_bins, \n                         np.exp(-remain_cap_after_add / item) * (1 / (1 + np.exp((remain_cap_after_add - item/2) / item))), \n                         -np.inf)\n    \n    return priority",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 129.65784284662087,
    "mi": 92.97433782653759,
    "token_count": 114.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter26_response3.txt_stdout.txt",
    "code_path": "problem_iter26_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a refined penalty term for large remaining capacities.\n    Uses np.exp(-(bins_remain_cap - item)) and a balancing term to encourage tighter fits and future capacity.\n    \"\"\"\n    # Non-linear prioritization for valid bins\n    priority = np.where(bins_remain_cap >= item, np.exp(-(bins_remain_cap - item)), -np.inf)\n    \n    # Refine penalty term to balance tight fitting and future capacity\n    valid_bins = priority != -np.inf\n    if np.any(valid_bins):\n        # Combine the benefits of both v0 and v1 by using a term that considers both remaining capacity and item size\n        penalty_term = (bins_remain_cap[valid_bins] - item) / bins_remain_cap[valid_bins]\n        balancing_term = 1 / (1 + np.exp((bins_remain_cap[valid_bins] - item) / item))\n        priority[valid_bins] *= penalty_term * balancing_term\n        \n    return priority",
    "response_id": 3,
    "tryHS": false,
    "obj": 5.195452732349436,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 129.65784284662087,
    "mi": 92.97433782653759,
    "token_count": 114.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter26_response4.txt_stdout.txt",
    "code_path": "problem_iter26_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for each bin based on remaining capacity and item size.\n    Combines non-linear prioritization with a refined penalty term for better bin selection.\n    \"\"\"\n    # Non-linear prioritization for bins with sufficient capacity\n    priority = np.where(bins_remain_cap >= item, 1 / (1 + np.abs(bins_remain_cap - item)), -np.inf)\n    \n    # Refined penalty term to balance tight fitting and future capacity\n    penalty_term = np.where(bins_remain_cap >= item, -((bins_remain_cap - item) / bins_remain_cap) + (item / bins_remain_cap), 0)\n    priority *= penalty_term\n    \n    return priority",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 129.65784284662087,
    "mi": 92.97433782653759,
    "token_count": 114.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter26_response5.txt_stdout.txt",
    "code_path": "problem_iter26_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for each bin based on non-linear prioritization and a refined penalty term.\n    \"\"\"\n    # Non-linear prioritization for bins with enough capacity\n    priority = np.where(bins_remain_cap >= item, np.exp(-(bins_remain_cap - item)), -np.inf)\n    # Refined penalty term to balance tight fitting and future capacity\n    priority = np.where(bins_remain_cap >= item, priority * ((bins_remain_cap - item) / bins_remain_cap), priority)\n    return priority",
    "response_id": 5,
    "tryHS": false,
    "obj": 5.195452732349436,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 129.65784284662087,
    "mi": 92.97433782653759,
    "token_count": 114.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter26_response6.txt_stdout.txt",
    "code_path": "problem_iter26_code6.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a refined balancing term for tight fitting and future capacity.\n    Uses np.exp for prioritization and a ratio for balancing.\n    \"\"\"\n    # Non-linear prioritization for valid bins\n    priority = np.where(bins_remain_cap >= item, np.exp(-(bins_remain_cap - item)), -np.inf)\n    \n    # Refined balancing term to encourage using bins that are not too full\n    valid_bins = priority != -np.inf\n    if np.any(valid_bins):\n        remaining_cap_after_addition = bins_remain_cap[valid_bins] - item\n        # Balance between tight fitting and future capacity\n        priority[valid_bins] *= (remaining_cap_after_addition / bins_remain_cap[valid_bins]) ** 0.5 * (1 - (remaining_cap_after_addition / bins_remain_cap[valid_bins]))\n        \n    return priority",
    "response_id": 6,
    "tryHS": false,
    "obj": 5.195452732349436,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 129.65784284662087,
    "mi": 92.97433782653759,
    "token_count": 114.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter26_response7.txt_stdout.txt",
    "code_path": "problem_iter26_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a refined penalty term for balance.\n    Encourages tight fits while leaving capacity for future items.\n    \"\"\"\n    # Calculate remaining capacity after adding the item\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Non-linear prioritization with a refined penalty for large remaining capacity\n    priority = np.where(bins_remain_cap >= item, \n                         np.exp(-remain_cap_after_add / item) * (remain_cap_after_add / bins_remain_cap), \n                         -np.inf)\n    \n    return priority",
    "response_id": 7,
    "tryHS": false,
    "obj": 16.513761467889925,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 129.65784284662087,
    "mi": 92.97433782653759,
    "token_count": 114.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter26_response8.txt_stdout.txt",
    "code_path": "problem_iter26_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a refined penalty term for tighter fits and future capacity.\n    \"\"\"\n    # Non-linear prioritization for bins that can fit the item\n    priority = np.where(bins_remain_cap >= item, np.exp(-(bins_remain_cap - item)), -np.inf)\n    # Refined penalty term to balance tight fitting and future capacity\n    penalty_term = np.where(bins_remain_cap - item > 0, (bins_remain_cap - item) / bins_remain_cap, 0)\n    priority *= penalty_term\n    # Normalize priority scores for better adaptability\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:\n        priority = priority / max_priority\n    \n    return priority",
    "response_id": 8,
    "tryHS": false,
    "obj": 5.195452732349436,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 129.65784284662087,
    "mi": 92.97433782653759,
    "token_count": 114.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter26_response9.txt_stdout.txt",
    "code_path": "problem_iter26_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a refined penalty term for tighter fits and future capacity.\n    \"\"\"\n    # Identify valid bins and calculate remaining capacity after adding the item\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Non-linear prioritization with a penalty for large remaining capacity\n    priority = np.where(valid_bins == 1, \n                         np.exp(-remain_cap_after_add / item) - 0.01 * remain_cap_after_add,  # Balance tight fit and future capacity\n                         -np.inf)\n    \n    # Normalize priority scores for better adaptability\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:\n        priority = priority / max_priority\n    \n    return priority",
    "response_id": 9,
    "tryHS": false,
    "obj": 3.8990825688073536,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 129.65784284662087,
    "mi": 92.97433782653759,
    "token_count": 114.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter27_response0.txt_stdout.txt",
    "code_path": "problem_iter27_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Enhances the priority function with a more refined balance between tight fitting and future capacity,\n    incorporating a dynamic penalty term based on the item size relative to the bin capacity.\n    \"\"\"\n    # Identify valid bins\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    \n    # Calculate the remaining capacity after adding the item and its relative size\n    remain_cap_after_add = bins_remain_cap - item\n    relative_item_size = item / bins_remain_cap\n    \n    # Non-linear prioritization with a dynamic penalty term for balancing tight fit and future capacity\n    priority = np.where(valid_bins == 1, \n                         np.exp(-remain_cap_after_add / (item + 1e-6)) * (1 - relative_item_size),  # Dynamic balancing\n                         -np.inf)\n    \n    # Directly return priority scores without normalization to maintain the dynamic range\n    return priority",
    "response_id": 0,
    "tryHS": false,
    "obj": 16.513761467889925,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 131.76952268336282,
    "mi": 88.86121093032479,
    "token_count": 102.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter27_response1.txt_stdout.txt",
    "code_path": "problem_iter27_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Enhances non-linear prioritization with a dynamic penalty term that adapts to the remaining capacity and item size.\n    \"\"\"\n    # Calculate valid bins and remaining capacity after adding the item\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Dynamic non-linear prioritization balancing tight fit and future capacity\n    tight_fit_score = np.exp(-remain_cap_after_add / (item + 1e-6))  # Avoid division by zero\n    future_capacity_score = 1 - (remain_cap_after_add / bins_remain_cap) ** 2  # Penalize bins that are too full or too empty relative to their original capacity\n    \n    # Combine scores with a weighted average for better adaptability\n    priority = np.where(valid_bins == 1, \n                         0.7 * tight_fit_score + 0.3 * future_capacity_score,  # Balance between tight fit and future capacity\n                         -np.inf)\n    \n    # Normalize priority scores for enhanced adaptability across different item sizes\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:\n        priority = priority / max_priority\n    \n    return priority",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 131.76952268336282,
    "mi": 88.86121093032479,
    "token_count": 102.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter27_response2.txt_stdout.txt",
    "code_path": "problem_iter27_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Simplifies and refines the non-linear prioritization with a focus on balancing tight fits and future capacity.\n    \"\"\"\n    # Identify valid bins\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    \n    # Calculate the remaining capacity after adding the item\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Simplified non-linear prioritization focusing on tight fit and future capacity\n    priority = np.where(valid_bins == 1, \n                         np.exp(-remain_cap_after_add / (item + 1e-6)) + 0.1 * (remain_cap_after_add / (bins_remain_cap + 1e-6)),  \n                         -np.inf)\n    \n    # Directly return priority scores without normalization to maintain distinction between tight and loose fits\n    return priority",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.058635819704831,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 131.76952268336282,
    "mi": 88.86121093032479,
    "token_count": 102.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter27_response3.txt_stdout.txt",
    "code_path": "problem_iter27_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Enhances the priority function with a more refined non-linear prioritization that effectively balances \n    tight fitting and future capacity, while maintaining simplicity and avoiding unnecessary complexity.\n    \"\"\"\n    # Calculate valid bins and remaining capacity after adding the item\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Refined non-linear prioritization focusing on a balance between tight fit and future capacity\n    priority = np.where(valid_bins == 1, \n                         np.exp(-remain_cap_after_add / (item + 1e-6)) * (1 - 0.1 * (remain_cap_after_add / bins_remain_cap)),  \n                         -np.inf)\n    \n    # Simplified normalization to enhance adaptability without unnecessary complexity\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:\n        priority = priority / max_priority\n    \n    return priority",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 131.76952268336282,
    "mi": 88.86121093032479,
    "token_count": 102.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter27_response4.txt_stdout.txt",
    "code_path": "problem_iter27_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Enhances the priority function by introducing a more nuanced non-linear prioritization \n    that effectively balances tight fitting and future capacity, while maintaining simplicity.\n    \"\"\"\n    # Identify valid bins\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    \n    # Calculate a more nuanced priority score that balances tight fit and future capacity\n    remain_cap_after_add = bins_remain_cap - item\n    priority = np.where(valid_bins == 1, \n                         np.exp(-remain_cap_after_add / (item + 1e-6)) + 0.1 * np.exp(-remain_cap_after_add / bins_remain_cap),  \n                         -np.inf)\n    \n    # Simplify the normalization process by directly returning the priority scores\n    # Since the scores are already comparable and the highest score will be selected, \n    # further normalization is not necessary unless dealing with very large numbers.\n    return priority",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 131.76952268336282,
    "mi": 88.86121093032479,
    "token_count": 102.0,
    "exec_success": true
  }
]