[
  {
    "stdout_filepath": "problem_iter29_response0.txt_stdout.txt",
    "code_path": "problem_iter29_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a refined penalty term for tighter fits and future capacity.\n    Balances tight fit and future capacity using a simple yet effective formulation.\n    \"\"\"\n    # Identify valid bins and calculate remaining capacity after adding the item\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Non-linear prioritization with a penalty for large remaining capacity\n    priority = np.where(valid_bins == 1, \n                         np.exp(-remain_cap_after_add / item) * (1 / (1 + np.exp((remain_cap_after_add - item/2) / item))),  \n                         -np.inf)\n    \n    # Normalize priority scores for better adaptability\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:\n        priority = priority / max_priority\n    \n    return priority",
    "response_id": 0,
    "tryHS": true,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 92.5109929535273,
    "mi": 92.32765976990409,
    "token_count": 86.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter29_response1.txt_stdout.txt",
    "code_path": "problem_iter29_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a refined penalty term for better bin selection.\n    Balances tight fitting and future capacity using a simple yet effective formulation.\n    \"\"\"\n    # Non-linear prioritization for bins with sufficient capacity\n    priority = np.where(bins_remain_cap >= item, np.exp(-(bins_remain_cap - item)), -np.inf)\n    \n    # Refined penalty term to balance tight fitting and future capacity\n    valid_bins = priority != -np.inf\n    if np.any(valid_bins):\n        # Use a term that considers both remaining capacity and item size\n        balancing_term = 1 / (1 + np.abs(bins_remain_cap[valid_bins] - item))\n        priority[valid_bins] *= balancing_term\n        \n    return priority",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 92.5109929535273,
    "mi": 92.32765976990409,
    "token_count": 86.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter29_response2.txt_stdout.txt",
    "code_path": "problem_iter29_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a refined balancing term for optimal bin selection.\n    \"\"\"\n    # Calculate remaining capacity after adding the item\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Non-linear prioritization with a penalty for large remaining capacity and a balancing term\n    priority = np.where(bins_remain_cap >= item, \n                         np.exp(-remain_cap_after_add / (item * 3.2571208170312453)) * (1 - remain_cap_after_add / bins_remain_cap), \n                         -np.inf)\n    \n    return priority",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 92.5109929535273,
    "mi": 92.32765976990409,
    "token_count": 86.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter29_response3.txt_stdout.txt",
    "code_path": "problem_iter29_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a dynamic penalty term, balancing tight fit and future capacity.\n    \"\"\"\n    # Calculate valid bins and remaining capacity after adding the item\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Non-linear prioritization focusing on tight fit\n    tight_fit_score = np.exp(-remain_cap_after_add / (item + 1e-6))\n    \n    # Dynamic penalty term for future capacity\n    future_capacity_score = remain_cap_after_add / (bins_remain_cap + 1e-6)\n    \n    # Combine scores with a weighted average for better adaptability\n    priority = np.where(valid_bins == 1, \n                         0.7 * tight_fit_score + 0.3 * future_capacity_score, \n                         -np.inf)\n    \n    # Normalize priority scores for enhanced adaptability\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:\n        priority = priority / max_priority\n    \n    return priority",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.068607897885915,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 92.5109929535273,
    "mi": 92.32765976990409,
    "token_count": 86.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter29_response4.txt_stdout.txt",
    "code_path": "problem_iter29_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a refined penalty term for better bin selection.\n    Balances tight fitting and future capacity using a simple yet effective approach.\n    \"\"\"\n    # Non-linear prioritization for bins with sufficient capacity\n    priority = np.where(bins_remain_cap >= item, np.exp(-(bins_remain_cap - item)), -np.inf)\n    \n    # Refined penalty term to balance tight fitting and future capacity\n    penalty_term = 1 / (1 + np.abs(bins_remain_cap - item))  # Simple and effective term\n    \n    # Combine prioritization and penalty term\n    priority = np.where(bins_remain_cap >= item, priority * penalty_term, priority)\n    \n    return priority",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 92.5109929535273,
    "mi": 92.32765976990409,
    "token_count": 86.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter29_response5.txt_stdout.txt",
    "code_path": "problem_iter29_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a refined penalty term for tighter fits and future capacity.\n    Uses np.exp for non-linear prioritization and a balancing term to encourage tighter fits.\n    \"\"\"\n    # Identify valid bins and calculate remaining capacity after adding the item\n    valid_bins = (bins_remain_cap >= item)\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Non-linear prioritization with a penalty term for large remaining capacities\n    priority = np.where(valid_bins, \n                         np.exp(-remain_cap_after_add / item),  # Non-linear prioritization\n                         -np.inf)\n    \n    # Refined penalty term to balance tight fitting and future capacity\n    penalty_term = np.where(remain_cap_after_add > 0, 1 / (1 + np.exp((remain_cap_after_add - item/2) / item)), 1)\n    priority *= penalty_term\n    \n    return priority",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 92.5109929535273,
    "mi": 92.32765976990409,
    "token_count": 86.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter29_response6.txt_stdout.txt",
    "code_path": "problem_iter29_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a refined penalty term for large remaining capacities.\n    Balances tight fitting and future capacity using a simple yet effective formula.\n    \"\"\"\n    # Identify valid bins and calculate remaining capacity after adding the item\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Non-linear prioritization for valid bins, balancing tight fit and future capacity\n    priority = np.where(valid_bins == 1, \n                         np.exp(-remain_cap_after_add / (item + 1e-6)),  # Encourage tight fits\n                         -np.inf)\n    \n    # Refine priority with a balancing term for valid bins to consider future capacity\n    valid_bin_indices = np.where(valid_bins == 1)[0]\n    if len(valid_bin_indices) > 0:\n        balancing_term = 1 / (1 + np.exp((bins_remain_cap[valid_bin_indices] - item) / item))\n        priority[valid_bin_indices] *= balancing_term\n        \n    return priority",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 92.5109929535273,
    "mi": 92.32765976990409,
    "token_count": 86.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter29_response7.txt_stdout.txt",
    "code_path": "problem_iter29_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a refined penalty term for tighter fits and future capacity.\n    Balances tight fitting and future capacity using a simple yet effective formula.\n    \"\"\"\n    # Identify valid bins and calculate remaining capacity after adding the item\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Non-linear prioritization with a penalty for large remaining capacity\n    priority = np.where(valid_bins == 1, \n                         np.exp(-remain_cap_after_add / item),  # Encourage tight fits\n                         -np.inf)\n    \n    # Refine priority with a balancing term to consider future capacity\n    valid_bins_idx = priority != -np.inf\n    if np.any(valid_bins_idx):\n        balancing_term = 1 / (1 + np.exp(remain_cap_after_add[valid_bins_idx] / item))\n        priority[valid_bins_idx] *= balancing_term\n    \n    # Normalize priority scores for better adaptability\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:\n        priority = priority / max_priority\n    \n    return priority",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 92.5109929535273,
    "mi": 92.32765976990409,
    "token_count": 86.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter29_response8.txt_stdout.txt",
    "code_path": "problem_iter29_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a refined penalty term for better bin selection.\n    Balances tight fitting and future capacity.\n    \"\"\"\n    # Non-linear prioritization for bins with sufficient capacity\n    priority = np.where(bins_remain_cap >= item, 1 / (1 + np.abs(bins_remain_cap - item)), -np.inf)\n    \n    # Refined penalty term to encourage tight fits and leave capacity for future items\n    remain_cap_after_add = bins_remain_cap - item\n    penalty_term = np.exp(-remain_cap_after_add / item) * (remain_cap_after_add / bins_remain_cap)\n    priority *= penalty_term\n    \n    return priority",
    "response_id": 8,
    "tryHS": false,
    "obj": 6.102911846828884,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 92.5109929535273,
    "mi": 92.32765976990409,
    "token_count": 86.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter29_response9.txt_stdout.txt",
    "code_path": "problem_iter29_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a refined penalty term for tighter fits and future capacity.\n    \"\"\"\n    # Non-linear prioritization for bins with enough capacity\n    priority = np.where(bins_remain_cap >= item, np.exp(-(bins_remain_cap - item) / item), -np.inf)\n    # Refined penalty term to balance tight fitting and future capacity\n    priority = np.where(bins_remain_cap >= item, priority * ((bins_remain_cap - item) / bins_remain_cap), priority)\n    return priority",
    "response_id": 9,
    "tryHS": false,
    "obj": 16.513761467889925,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 92.5109929535273,
    "mi": 92.32765976990409,
    "token_count": 86.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter30_response0.txt_stdout.txt",
    "code_path": "problem_iter30_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    A mutated priority function that simplifies the calculation while maintaining a balance between tight fitting and future capacity.\n    \"\"\"\n    # Identify valid bins\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    \n    # Calculate the remaining capacity after adding the item\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Simplified non-linear prioritization focusing on tight fit with a consideration for future capacity\n    priority = np.where(valid_bins == 1, \n                         np.exp(-remain_cap_after_add / (item + 1e-6)) + 0.1 * (remain_cap_after_add / (bins_remain_cap + 1e-6)),  \n                         -np.inf)\n    \n    return priority",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.058635819704831,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 136.16184010614157,
    "mi": 95.43951350265182,
    "token_count": 99.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter30_response1.txt_stdout.txt",
    "code_path": "problem_iter30_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Improved non-linear prioritization function that balances tight fitting and future capacity.\n    \"\"\"\n    # Identify valid bins\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    \n    # Calculate the remaining capacity after adding the item\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Simple yet effective non-linear prioritization\n    priority = np.where(valid_bins == 1, \n                         np.exp(-remain_cap_after_add / (item + 1e-6)) * (1 - 0.1 * (remain_cap_after_add / bins_remain_cap)),  \n                         -np.inf)\n    \n    return priority",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 136.16184010614157,
    "mi": 95.43951350265182,
    "token_count": 99.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter30_response2.txt_stdout.txt",
    "code_path": "problem_iter30_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Simplifies the prioritization function by directly using the ratio of item size to bin remaining capacity,\n    enhancing the balance between tight fit and future capacity without unnecessary complexity.\n    \"\"\"\n    # Identify valid bins\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    \n    # Calculate the ratio of item size to the remaining capacity of bins\n    # A higher ratio indicates a tighter fit\n    fit_ratio = item / bins_remain_cap\n    \n    # Prioritize bins based on the fit ratio, ensuring valid bins have higher priority\n    priority = np.where(valid_bins == 1, fit_ratio, -np.inf)\n    \n    return priority",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 136.16184010614157,
    "mi": 95.43951350265182,
    "token_count": 99.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter30_response3.txt_stdout.txt",
    "code_path": "problem_iter30_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Improved priority function that balances tight fitting and future capacity with a simpler, more effective non-linear prioritization.\n    \"\"\"\n    # Identify valid bins\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    \n    # Calculate the remaining capacity after adding the item\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Simple and effective non-linear prioritization that focuses on tight fits while considering future capacity\n    priority = np.where(valid_bins == 1, \n                         np.exp(-remain_cap_after_add / (item + 1e-6)) + 0.1 * (remain_cap_after_add <= item / 2),  \n                         -np.inf)\n    \n    return priority",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 136.16184010614157,
    "mi": 95.43951350265182,
    "token_count": 99.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter30_response4.txt_stdout.txt",
    "code_path": "problem_iter30_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Improved priority function with simplified non-linear prioritization and a focus on balancing tight fitting and future capacity.\n    \"\"\"\n    # Identify valid bins\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    \n    # Calculate the remaining capacity after adding the item\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Simplified non-linear prioritization with a balance between tight fit and future capacity\n    priority = np.where(valid_bins == 1, \n                         np.exp(-remain_cap_after_add / (item + 1e-6)) + 0.1 * (remain_cap_after_add / (bins_remain_cap + 1e-6)),  \n                         -np.inf)\n    \n    return priority",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.058635819704831,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 136.16184010614157,
    "mi": 95.43951350265182,
    "token_count": 99.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter31_response0.txt_stdout.txt",
    "code_path": "problem_iter31_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, \n                penalty_scale: float = 7.491431721943758, \n                tight_fit_threshold: float = 0.6635994660879023, \n                large_capacity_penalty_scale: float = 2.2073480708414484) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a refined penalty term for tighter fits and future capacity.\n    Balances tight fit and future capacity using a simple yet effective formulation.\n    \"\"\"\n    # Identify valid bins and calculate remaining capacity after adding the item\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Non-linear prioritization with a penalty for large remaining capacity\n    priority = np.where(valid_bins == 1, \n                         np.exp(-remain_cap_after_add / (item * penalty_scale)) * (1 / (1 + np.exp((remain_cap_after_add - item*tight_fit_threshold) / (item*large_capacity_penalty_scale)))),  \n                         -np.inf)\n    \n    # Normalize priority scores for better adaptability\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:\n        priority = priority / max_priority\n    \n    return priority",
    "response_id": 0,
    "tryHS": true,
    "obj": 4.048663741523748,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 233.1830877661235,
    "mi": 91.5393115248339,
    "token_count": 161.0,
    "exec_success": true
  }
]