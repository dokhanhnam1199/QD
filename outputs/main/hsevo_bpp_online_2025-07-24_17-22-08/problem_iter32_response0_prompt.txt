{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Combines non-linear prioritization with a refined penalty term for better bin selection.\n    Balances tight fitting and future capacity using a simple yet effective formulation.\n    \"\"\"\n    # Non-linear prioritization for bins with sufficient capacity\n    priority = np.where(bins_remain_cap >= item, np.exp(-(bins_remain_cap - item)), -np.inf)\n    \n    # Refined penalty term to balance tight fitting and future capacity\n    valid_bins = priority != -np.inf\n    if np.any(valid_bins):\n        # Use a term that considers both remaining capacity and item size\n        balancing_term = 1 / (1 + np.abs(bins_remain_cap[valid_bins] - item))\n        priority[valid_bins] *= balancing_term\n        \n    return priority\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Combines non-linear prioritization with a dynamic penalty term, balancing tight fit and future capacity.\n    \"\"\"\n    # Calculate valid bins and remaining capacity after adding the item\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Non-linear prioritization focusing on tight fit\n    tight_fit_score = np.exp(-remain_cap_after_add / (item + 1e-6))\n    \n    # Dynamic penalty term for future capacity\n    future_capacity_score = remain_cap_after_add / (bins_remain_cap + 1e-6)\n    \n    # Combine scores with a weighted average for better adaptability\n    priority = np.where(valid_bins == 1, \n                         0.7 * tight_fit_score + 0.3 * future_capacity_score, \n                         -np.inf)\n    \n    # Normalize priority scores for enhanced adaptability\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:\n        priority = priority / max_priority\n    \n    return priority\n\n### Analyze & experience\n- Comparing the top-ranked heuristics with the lower-ranked ones, we observe that the top heuristics tend to use a combination of non-linear prioritization and refined penalty terms to balance tight fitting and future capacity. For example, Heuristics 1st and 2nd use `np.exp` for non-linear prioritization and incorporate terms that consider both remaining capacity and item size. In contrast, lower-ranked heuristics like 19th and 20th, although similar in structure, lack the nuanced balancing terms seen in the top heuristics. Comparing (1st) vs (2nd), we see that both use non-linear prioritization but differ in their penalty terms; the 1st heuristic incorporates a more complex balancing term. (3rd) vs (4th) shows a similar pattern, with the 3rd using a simpler yet effective non-linear prioritization. Overall, the top heuristics strike a balance between complexity and effectiveness in their prioritization and penalty terms.\n- \nTo design better heuristics, let's analyze the given information. \n\n* **Keywords**: Non-linear prioritization, nuanced penalty terms, balancing tight fitting and future capacity.\n* **Advice**: Combine non-linear prioritization with refined penalty terms, and consider trade-offs between complexity and effectiveness.\n* **Avoid**: Unnecessary complexity, redundant code, and overly simplistic approaches that don't balance competing objectives.\n* **Explanation**: The goal is to create heuristics that effectively balance competing demands, such as tight fitting and future capacity, using non-linear prioritization and thoughtful penalty terms, while avoiding unnecessary complexity.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}