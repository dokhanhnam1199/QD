[
  {
    "stdout_filepath": "problem_iter1_response0.txt_stdout.txt",
    "code_path": "problem_iter1_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    The priority is calculated based on the remaining capacity of each bin. \n    The bin with the least remaining capacity that can still fit the item gets the highest priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin\n    # The bin with remaining capacity closest to the item size gets the highest priority\n    priority = np.where(bins_remain_cap >= item, bins_remain_cap.max() - bins_remain_cap, bins_remain_cap.max() + 1)\n    \n    # Normalize the priority scores to be between 0 and 1\n    priority = np.maximum(0, 1 - (priority - priority.min()) / (priority.max() - priority.min() + 1e-9))\n    \n    return priority",
    "response_id": 0,
    "tryHS": false,
    "obj": 149.30195452732352,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 30.0,
    "mi": 92.0002863045658,
    "token_count": 66.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response1.txt_stdout.txt",
    "code_path": "problem_iter1_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is based on the remaining capacity of the bin and the size of the item.\n    A bin with a remaining capacity that is just enough for the item will have the highest priority.\n    A bin that is too small for the item will have a priority of negative infinity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # First, we identify bins that are too small for the item and give them a very low priority\n    priority = np.where(bins_remain_cap >= item, bins_remain_cap - item, -np.inf)\n    \n    # Then, we normalize the priority scores so that the bin with the smallest remaining capacity \n    # that is still enough for the item gets the highest priority\n    priority = -priority\n    \n    # Return the priority scores\n    return priority",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 30.0,
    "mi": 92.0002863045658,
    "token_count": 66.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response2.txt_stdout.txt",
    "code_path": "problem_iter1_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin based on \n    the remaining capacity and a penalty for exceeding the capacity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Assign a very low priority (negative infinity) if the item doesn't fit\n    priority = np.where(remaining_after_addition >= 0, remaining_after_addition, -np.inf)\n    \n    # Normalize the priority to be between 0 and 1 for valid bins\n    max_remaining = np.max(remaining_after_addition[remaining_after_addition != -np.inf])\n    min_remaining = np.min(remaining_after_addition[remaining_after_addition != -np.inf])\n    \n    if max_remaining == min_remaining:  # Avoid division by zero\n        normalized_priority = np.where(remaining_after_addition != -np.inf, 1, -np.inf)\n    else:\n        normalized_priority = np.where(remaining_after_addition != -np.inf, \n                                       (max_remaining - remaining_after_addition) / (max_remaining - min_remaining), \n                                       -np.inf)\n    \n    # Invert the normalized priority so that the bin with the most remaining capacity has the highest priority\n    priority = 1 - normalized_priority\n    \n    return priority",
    "response_id": 2,
    "tryHS": false,
    "obj": 149.30195452732352,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 30.0,
    "mi": 92.0002863045658,
    "token_count": 66.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response3.txt_stdout.txt",
    "code_path": "problem_iter1_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    \n    The priority is calculated based on the remaining capacity of each bin. \n    Bins with remaining capacity closer to the item size will have higher priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that cannot hold the item will have negative remaining capacity\n    # Assign a very low priority to such bins\n    priority = np.where(remaining_after_addition >= 0, -remaining_after_addition, -np.inf)\n    \n    # Normalize the priority scores to be between 0 and 1\n    # This is not necessary but can be helpful for some applications\n    # max_priority = np.max(priority)\n    # if max_priority != -np.inf:\n    #     priority = priority / max_priority\n    \n    return priority",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 30.0,
    "mi": 92.0002863045658,
    "token_count": 66.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response4.txt_stdout.txt",
    "code_path": "problem_iter1_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    \n    The priority is calculated based on the remaining capacity of each bin.\n    A bin with a remaining capacity closest to the item size gets the highest priority.\n    If a bin cannot fit the item, its priority is set to negative infinity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin\n    # A bin with remaining capacity closest to the item size gets the highest priority\n    priority = np.where(bins_remain_cap >= item, \n                        -np.abs(bins_remain_cap - item), \n                        -np.inf)\n    \n    return priority",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 30.0,
    "mi": 92.0002863045658,
    "token_count": 66.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response5.txt_stdout.txt",
    "code_path": "problem_iter1_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is calculated based on the remaining capacity of each bin.\n    A bin with remaining capacity closest to the item size gets the highest priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the absolute difference between the item size and the remaining capacity of each bin\n    diff = np.abs(bins_remain_cap - item)\n    \n    # Calculate the priority score as the negative of the difference (lower difference means higher priority)\n    # Add a small value to avoid division by zero when bins_remain_cap equals item\n    priority = -diff + 1e-6\n    \n    # Set the priority score to negative infinity for bins that cannot accommodate the item\n    priority[bins_remain_cap < item] = -np.inf\n    \n    return priority",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 30.0,
    "mi": 92.0002863045658,
    "token_count": 66.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response6.txt_stdout.txt",
    "code_path": "problem_iter1_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    \n    The priority is determined by the remaining capacity of the bin after \n    adding the item. We prefer bins that will have the least remaining capacity \n    after adding the item, as long as the item fits in the bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_capacity_after_addition = bins_remain_cap - item\n    \n    # Set the priority to negative infinity for bins that are too small\n    # to hold the item (i.e., remaining capacity after addition is negative)\n    priority = np.where(remaining_capacity_after_addition >= 0, \n                        -remaining_capacity_after_addition, \n                        -np.inf)\n    \n    return priority",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 30.0,
    "mi": 92.0002863045658,
    "token_count": 66.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response7.txt_stdout.txt",
    "code_path": "problem_iter1_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    \n    The priority is calculated based on the remaining capacity of each bin. \n    The bin with the least remaining capacity that can still fit the item gets the highest priority.\n    \n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priority scores as negative infinity for bins that cannot fit the item\n    priority = np.where(bins_remain_cap >= item, bins_remain_cap, -np.inf)\n    \n    # Calculate the priority score as the negative of the remaining capacity after adding the item\n    # This gives higher priority to bins that are more full\n    priority = np.where(priority > -np.inf, -(priority - item), priority)\n    \n    return priority",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 30.0,
    "mi": 92.0002863045658,
    "token_count": 66.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response8.txt_stdout.txt",
    "code_path": "problem_iter1_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot accommodate the item\n    priority = np.where(remaining_cap_after_addition >= 0, remaining_cap_after_addition, -1e10)\n    \n    # Give higher priority to bins with less remaining capacity after addition (i.e., more full)\n    # To achieve this, we subtract the remaining capacity from a large constant (max possible remaining capacity)\n    # Here, we assume the maximum possible remaining capacity is 1 (since bins_remain_cap is normalized)\n    # You can adjust this based on your actual bin capacity\n    priority = np.where(remaining_cap_after_addition >= 0, 1 - remaining_cap_after_addition, priority)\n    \n    return priority",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 30.0,
    "mi": 92.0002863045658,
    "token_count": 66.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response9.txt_stdout.txt",
    "code_path": "problem_iter1_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is calculated based on the remaining capacity of each bin.\n    The bin with the least remaining capacity that can still fit the item gets the highest priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Check if the item can fit into the bin\n    valid_bins = bins_remain_cap >= item\n    \n    # Initialize priority scores with -inf for bins that cannot fit the item\n    priority_scores = np.where(valid_bins, bins_remain_cap, -np.inf)\n    \n    # Calculate the priority score as the negative of the remaining capacity\n    # so that the bin with the least remaining capacity gets the highest priority\n    priority_scores = np.where(valid_bins, -priority_scores, priority_scores)\n    \n    # Normalize the priority scores to be between 0 and 1\n    max_score = np.max(priority_scores)\n    if max_score == -np.inf:  # No valid bins\n        return np.zeros_like(bins_remain_cap)\n    priority_scores = np.where(valid_bins, (priority_scores - np.min(priority_scores[valid_bins])) / (max_score - np.min(priority_scores[valid_bins])), 0)\n    \n    return priority_scores",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 30.0,
    "mi": 92.0002863045658,
    "token_count": 66.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response10.txt_stdout.txt",
    "code_path": "problem_iter1_code10.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    The priority is higher for bins that have enough capacity and are most full.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the capacity remaining after adding the item to each bin\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that do not have enough capacity for the item get a priority of -inf\n    # So they will not be chosen unless there are no other options\n    priority = np.where(remaining_after_addition >= 0, -remaining_after_addition, -np.inf)\n    \n    return priority",
    "response_id": 10,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 30.0,
    "mi": 92.0002863045658,
    "token_count": 66.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response11.txt_stdout.txt",
    "code_path": "problem_iter1_code11.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    The priority is calculated based on the remaining capacity of the bin and the size of the item.\n    A higher priority is given to bins that have just enough remaining capacity to hold the item.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin based on the remaining capacity and item size\n    # A bin with remaining capacity closer to the item size gets higher priority\n    priority_scores = np.where(bins_remain_cap >= item, np.exp(-(bins_remain_cap - item)), 0)\n    \n    return priority_scores",
    "response_id": 11,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 30.0,
    "mi": 92.0002863045658,
    "token_count": 66.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response12.txt_stdout.txt",
    "code_path": "problem_iter1_code12.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_capacity_after_addition = bins_remain_cap - item\n    \n    # We want to prioritize bins that have enough capacity for the item\n    # and have the least remaining capacity after adding the item\n    # to minimize waste\n    priority = np.where(\n        remaining_capacity_after_addition >= 0, \n        -remaining_capacity_after_addition,  # Lower remaining capacity is better\n        -np.inf  # Bins that cannot hold the item get -inf priority\n    )\n    \n    return priority",
    "response_id": 12,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 30.0,
    "mi": 92.0002863045658,
    "token_count": 66.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response13.txt_stdout.txt",
    "code_path": "problem_iter1_code13.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is calculated based on the remaining capacity of each bin.\n    The bin with the least remaining capacity that can still fit the item gets the highest priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Create a mask to identify bins that have enough capacity for the item\n    valid_bins = bins_remain_cap >= item\n    \n    # Initialize priority scores with negative infinity for bins that can't fit the item\n    priority = np.where(valid_bins, bins_remain_cap, -np.inf)\n    \n    # Calculate the priority score as the negative of the remaining capacity\n    # This way, the bin with the least remaining capacity gets the highest priority\n    priority = np.where(valid_bins, -priority, priority)\n    \n    return priority",
    "response_id": 13,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 30.0,
    "mi": 92.0002863045658,
    "token_count": 66.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response14.txt_stdout.txt",
    "code_path": "problem_iter1_code14.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prefers bins that have just enough capacity for the item.\n    It uses a negative exponential function to assign higher priority to bins \n    with remaining capacity close to the item size.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the absolute difference between the item size and the remaining capacity of each bin\n    diff = np.abs(bins_remain_cap - item)\n    \n    # Assign a very low priority to bins that cannot accommodate the item\n    priority = np.where(bins_remain_cap >= item, np.exp(-diff), -1e9)\n    \n    return priority",
    "response_id": 14,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 30.0,
    "mi": 92.0002863045658,
    "token_count": 66.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response15.txt_stdout.txt",
    "code_path": "problem_iter1_code15.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Prioritize bins that have just enough capacity for the item\n    # Higher priority for bins where the item fits and leaves less remaining capacity\n    priority = np.where(bins_remain_cap >= item, bins_remain_cap - item, np.inf)\n    # Convert to a maximization problem by taking the negative\n    priority = -priority\n    # Normalize to avoid potential overflow when taking exp\n    priority = priority - np.max(priority)\n    # Apply softmax to convert to a probability distribution\n    priority = np.exp(priority) / np.sum(np.exp(priority))\n    return priority",
    "response_id": 15,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 30.0,
    "mi": 92.0002863045658,
    "token_count": 66.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response16.txt_stdout.txt",
    "code_path": "problem_iter1_code16.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # For each bin, calculate the remaining capacity if the item is added\n    remaining_cap_if_added = bins_remain_cap - item\n    \n    # Assign a very low priority (negative infinity) to bins that cannot hold the item\n    priority = np.where(remaining_cap_if_added >= 0, -remaining_cap_if_added, -np.inf)\n    \n    # Normalize the priority scores so that the bin with the least remaining capacity (if the item is added) gets the highest priority\n    return priority",
    "response_id": 16,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 30.0,
    "mi": 92.0002863045658,
    "token_count": 66.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response17.txt_stdout.txt",
    "code_path": "problem_iter1_code17.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    \n    The priority is higher for bins that have just enough capacity to hold the item.\n    If a bin doesn't have enough capacity, its priority is set to negative infinity.\n    \n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin\n    # The score is higher when the remaining capacity is just enough to hold the item\n    priority = np.where(bins_remain_cap >= item, -np.abs(bins_remain_cap - item), -np.inf)\n    \n    return priority",
    "response_id": 17,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 30.0,
    "mi": 92.0002863045658,
    "token_count": 66.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response18.txt_stdout.txt",
    "code_path": "problem_iter1_code18.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is calculated based on the remaining capacity of each bin.\n    The bin with the least remaining capacity that can still fit the item gets the highest priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin\n    # If the item can fit in the bin, the priority score is the negative of the remaining capacity\n    # If the item cannot fit in the bin, the priority score is negative infinity\n    priority_scores = np.where(bins_remain_cap >= item, -bins_remain_cap, -np.inf)\n    \n    return priority_scores",
    "response_id": 18,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 30.0,
    "mi": 92.0002863045658,
    "token_count": 66.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response19.txt_stdout.txt",
    "code_path": "problem_iter1_code19.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    \n    This function implements the First-Fit decreasing heuristic. \n    The bin with the highest remaining capacity that can fit the item is given the highest priority.\n    If no bin can fit the item, the priority is 0 for all bins.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Check if the item can fit in each bin\n    valid_bins = bins_remain_cap >= item\n    \n    # Initialize priority scores to negative infinity for bins that can't fit the item\n    priority_scores = np.where(valid_bins, bins_remain_cap, -np.inf)\n    \n    # Normalize the priority scores to be between 0 and 1\n    max_cap = np.max(priority_scores)\n    if max_cap == -np.inf:  # No bin can fit the item\n        return np.zeros_like(bins_remain_cap)\n    else:\n        priority_scores = np.where(valid_bins, (priority_scores - np.min(priority_scores[valid_bins])) / (max_cap - np.min(priority_scores[valid_bins])), 0)\n        \n    return priority_scores",
    "response_id": 19,
    "tryHS": false,
    "obj": 149.30195452732352,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 30.0,
    "mi": 92.0002863045658,
    "token_count": 66.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response20.txt_stdout.txt",
    "code_path": "problem_iter1_code20.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    \n    The priority is calculated based on the remaining capacity of each bin.\n    A bin with remaining capacity closest to the item size gets the highest priority.\n    If a bin does not have enough capacity, its priority is set to negative infinity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Check if the item can fit in the bin\n    valid_bins = bins_remain_cap >= item\n    \n    # Calculate the priority for valid bins\n    priority = np.where(valid_bins, -np.abs(bins_remain_cap - item), -np.inf)\n    \n    return priority",
    "response_id": 20,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 30.0,
    "mi": 92.0002863045658,
    "token_count": 66.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response21.txt_stdout.txt",
    "code_path": "problem_iter1_code21.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is determined by the remaining capacity of the bin. \n    We prefer bins that have just enough capacity for the item.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin\n    # The score is high when the bin's remaining capacity is close to the item size\n    # and the bin has enough capacity for the item\n    priority_scores = np.where(bins_remain_cap >= item, \n                               1 - np.abs(bins_remain_cap - item) / item, \n                               -1.0)  # Assign a low score if the bin can't hold the item\n    \n    return priority_scores",
    "response_id": 21,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 30.0,
    "mi": 92.0002863045658,
    "token_count": 66.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response22.txt_stdout.txt",
    "code_path": "problem_iter1_code22.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin based on \n    the remaining capacity and the item size.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin\n    # The priority score is high when the remaining capacity is just enough for the item\n    priority = np.where(bins_remain_cap >= item, 1 - (bins_remain_cap - item) / bins_remain_cap, -1)\n    \n    # Return the priority scores\n    return priority",
    "response_id": 22,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 30.0,
    "mi": 92.0002863045658,
    "token_count": 66.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response23.txt_stdout.txt",
    "code_path": "problem_iter1_code23.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is higher for bins that have enough capacity to hold the item and \n    have less remaining capacity, indicating a tighter fit.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin\n    # The score is high if the bin has enough capacity and the remaining capacity is small\n    priority_scores = np.where(bins_remain_cap >= item, 1 / (bins_remain_cap + 1e-6), -1.0)\n    \n    return priority_scores",
    "response_id": 23,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 30.0,
    "mi": 92.0002863045658,
    "token_count": 66.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response24.txt_stdout.txt",
    "code_path": "problem_iter1_code24.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    \n    The priority is calculated based on the remaining capacity of each bin.\n    The bin with the least remaining capacity that can still hold the item gets the highest priority.\n    \n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin\n    # The bin with remaining capacity closest to the item size gets the highest priority\n    priority = np.where(bins_remain_cap >= item, 1 - (bins_remain_cap - item) / bins_remain_cap, -1)\n    \n    # Return the priority score for each bin\n    return priority",
    "response_id": 24,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 30.0,
    "mi": 92.0002863045658,
    "token_count": 66.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response25.txt_stdout.txt",
    "code_path": "problem_iter1_code25.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Check if the item can fit in the bin\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    \n    # Prioritize bins that have just enough capacity for the item\n    # The closer the remaining capacity to the item size, the higher the priority\n    priority = np.where(valid_bins == 1, bins_remain_cap - item, -np.inf)\n    \n    # To avoid division by zero, we add a small epsilon to the denominator\n    epsilon = 1e-6\n    priority = - (priority + epsilon) ** -1\n    \n    # Normalize the priority scores to be between 0 and 1\n    max_priority = np.max(priority)\n    min_priority = np.min(priority)\n    if max_priority != min_priority:\n        priority = (priority - min_priority) / (max_priority - min_priority)\n    else:\n        priority = np.ones_like(priority)\n    \n    # Set priority to zero for bins that cannot hold the item\n    priority = np.where(valid_bins == 1, priority, 0)\n    \n    return priority",
    "response_id": 25,
    "tryHS": false,
    "obj": 149.30195452732352,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 30.0,
    "mi": 92.0002863045658,
    "token_count": 66.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response26.txt_stdout.txt",
    "code_path": "problem_iter1_code26.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    \n    The priority is calculated based on the remaining capacity of each bin. \n    The bin with the least remaining capacity that can still fit the item gets the highest priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin\n    # A bin gets a high priority score if it has just enough capacity to fit the item\n    priority_scores = np.where(bins_remain_cap >= item, 1 - (bins_remain_cap - item) / bins_remain_cap, -1)\n    \n    # To avoid division by zero, set the priority score to -1 for bins with zero remaining capacity\n    priority_scores[bins_remain_cap == 0] = -1\n    \n    return priority_scores",
    "response_id": 26,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 30.0,
    "mi": 92.0002863045658,
    "token_count": 66.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response27.txt_stdout.txt",
    "code_path": "problem_iter1_code27.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is calculated based on the remaining capacity of each bin.\n    A bin with a remaining capacity closest to the item size gets the highest priority.\n    If a bin cannot fit the item, its priority is set to negative infinity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin\n    # The score is high when the remaining capacity is just enough to fit the item\n    priority = -np.abs(bins_remain_cap - item)\n    \n    # Set the priority to negative infinity for bins that cannot fit the item\n    priority[bins_remain_cap < item] = -np.inf\n    \n    return priority",
    "response_id": 27,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 30.0,
    "mi": 92.0002863045658,
    "token_count": 66.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response28.txt_stdout.txt",
    "code_path": "problem_iter1_code28.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    The priority is based on how well the item fits into the bin. \n    If the item fits perfectly into the bin, the priority is highest. \n    If the item is too large for the bin, the priority is lowest.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # For each bin, check if the item can fit into it\n    can_fit = bins_remain_cap >= item\n    \n    # Calculate the remaining capacity after adding the item\n    remaining_cap_after_add = bins_remain_cap - item\n    \n    # The priority is inversely proportional to the remaining capacity after adding the item\n    # and is 0 if the item cannot fit into the bin\n    priority = np.where(can_fit, 1 / (1 + remaining_cap_after_add), -1)\n    \n    return priority",
    "response_id": 28,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 30.0,
    "mi": 92.0002863045658,
    "token_count": 66.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response29.txt_stdout.txt",
    "code_path": "problem_iter1_code29.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_capacity_after_addition = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot accommodate the item\n    priority = np.where(remaining_capacity_after_addition >= 0, \n                        # For bins that can accommodate the item, \n                        # prioritize those with the least remaining capacity\n                        -remaining_capacity_after_addition, \n                        # For bins that cannot accommodate the item, assign a very low priority\n                        -np.inf)\n    \n    return priority",
    "response_id": 29,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 30.0,
    "mi": 92.0002863045658,
    "token_count": 66.0,
    "exec_success": true
  }
]