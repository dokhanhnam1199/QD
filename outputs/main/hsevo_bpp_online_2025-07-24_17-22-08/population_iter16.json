[
  {
    "stdout_filepath": "problem_iter14_response0.txt_stdout.txt",
    "code_path": "problem_iter14_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a balancing term for tight fitting and future capacity.\n    Uses a simple, intuitive logic to prioritize bins based on remaining capacity and item size.\n    \"\"\"\n    # Check if item fits and calculate remaining capacity after addition\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Non-linear priority with a balancing term for tight fitting and future capacity\n    priority = np.where(valid_bins == 1, \n                        # Use a non-linear function to prioritize bins based on remaining capacity and item size\n                        np.exp(-remaining_cap_after_addition / (bins_remain_cap + 1e-6)), \n                        0)\n    \n    # Apply an additional balancing term to prioritize bins that are not too full\n    valid_bins = priority != 0\n    if np.any(valid_bins):\n        # Directly apply the balancing term without normalization\n        priority[valid_bins] *= (1 - item / bins_remain_cap[valid_bins])\n        \n    return priority",
    "response_id": 0,
    "tryHS": false,
    "obj": 149.30195452732352,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 116.69205856195879,
    "mi": 93.63809682641774,
    "token_count": 112.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response1.txt_stdout.txt",
    "code_path": "problem_iter14_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with normalization for better distribution, \n    balancing tight fitting and future capacity effectively.\n    \"\"\"\n    # Calculate priority using a non-linear function\n    priority = np.where(bins_remain_cap >= item, np.exp(-(bins_remain_cap - item) / item), -np.inf)\n    \n    # Normalize valid priority scores\n    valid_bins = priority != -np.inf\n    if np.any(valid_bins):\n        max_score = np.max(priority[valid_bins])\n        min_score = np.min(priority[valid_bins])\n        # Normalize to [0, 1] range for better distribution\n        priority[valid_bins] = (priority[valid_bins] - min_score) / (max_score - min_score + 1e-6)\n        \n    return priority",
    "response_id": 1,
    "tryHS": true,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 116.69205856195879,
    "mi": 93.63809682641774,
    "token_count": 112.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response2.txt_stdout.txt",
    "code_path": "problem_iter14_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a simple penalty for large remaining capacity.\n    Balances tight fitting and future capacity using np.exp(-(bins_remain_cap - item) / item) and a bonus for larger bins_remain_cap.\n    \"\"\"\n    # Calculate priority score using a non-linear function for valid bins\n    priority = np.where(bins_remain_cap >= item, np.exp(-(bins_remain_cap - item) / item), -np.inf)\n    \n    # Apply a bonus to prioritize bins with more remaining capacity among valid bins\n    valid_bins = priority != -np.inf\n    if np.any(valid_bins):\n        priority[valid_bins] += 1e-6 * bins_remain_cap[valid_bins]\n        \n    return priority",
    "response_id": 2,
    "tryHS": true,
    "obj": 4.058635819704831,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 116.69205856195879,
    "mi": 93.63809682641774,
    "token_count": 112.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response3.txt_stdout.txt",
    "code_path": "problem_iter14_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a balance between tight fitting and future capacity.\n    Uses np.exp(-(bins_remain_cap - item) / item) and a bonus for bins with more remaining capacity.\n    \"\"\"\n    # Calculate priority score using a non-linear function for valid bins\n    priority = np.where(bins_remain_cap >= item, np.exp(-(bins_remain_cap - item) / item), -np.inf)\n    \n    # Apply a bonus to valid bins to balance tight fitting and future capacity\n    valid_bins = priority != -np.inf\n    if np.any(valid_bins):\n        # Add a small bonus to prioritize bins with more remaining capacity\n        priority[valid_bins] += 1e-6 * bins_remain_cap[valid_bins]\n        \n    return priority",
    "response_id": 3,
    "tryHS": true,
    "obj": 4.058635819704831,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 116.69205856195879,
    "mi": 93.63809682641774,
    "token_count": 112.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response4.txt_stdout.txt",
    "code_path": "problem_iter14_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a penalty for large remaining capacity.\n    Balances tight fitting and future capacity using exp function and item size.\n    \"\"\"\n    # Identify bins that are too small for the item and give them a very low priority\n    priority = np.where(bins_remain_cap >= item, np.exp(-(bins_remain_cap - item) / item), -np.inf)\n    \n    # Weigh the priority scores by a factor that considers the remaining capacity\n    valid_bins = priority != -np.inf\n    if np.any(valid_bins):\n        # Use a non-linear function to further balance between tight fitting and future capacity\n        # Removed normalization and tanh to simplify the logic\n        priority[valid_bins] *= np.exp(-bins_remain_cap[valid_bins] / np.max(bins_remain_cap[valid_bins]))\n    \n    return priority",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 116.69205856195879,
    "mi": 93.63809682641774,
    "token_count": 112.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response5.txt_stdout.txt",
    "code_path": "problem_iter14_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for each bin based on a non-linear function that \n    balances tight fitting and future capacity.\n    \"\"\"\n    # Calculate remaining capacity after adding the item\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Use non-linear prioritization with a penalty for large remaining capacity\n    priority = np.where(bins_remain_cap >= item, np.exp(-remain_cap_after_add / item) - 0.1 * remain_cap_after_add / bins_remain_cap, -np.inf)\n    \n    return priority",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 116.69205856195879,
    "mi": 93.63809682641774,
    "token_count": 112.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response6.txt_stdout.txt",
    "code_path": "problem_iter14_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a balance between tight fitting and future capacity.\n    Uses exp function to prioritize bins with remaining capacity close to the item size.\n    \"\"\"\n    # Identify bins that are too small for the item and give them a very low priority\n    priority = np.where(bins_remain_cap >= item, np.exp(-(bins_remain_cap - item) / item), -np.inf)\n    \n    # Balance between tight fitting and future capacity by considering remaining capacity\n    valid_bins = priority != -np.inf\n    if np.any(valid_bins):\n        # Use a simple non-linear function to further balance\n        priority[valid_bins] *= 1 / (1 + bins_remain_cap[valid_bins] - item)\n    \n    return priority",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 116.69205856195879,
    "mi": 93.63809682641774,
    "token_count": 112.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response7.txt_stdout.txt",
    "code_path": "problem_iter14_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a simple ratio to balance tight fitting and future capacity.\n    \"\"\"\n    # Check if item fits and calculate remaining capacity after addition\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Non-linear priority with a simple ratio for balancing\n    priority = np.where(valid_bins == 1, np.exp(-remaining_cap_after_addition / item) * (remaining_cap_after_addition / bins_remain_cap), 0)\n    \n    return priority",
    "response_id": 7,
    "tryHS": false,
    "obj": 16.513761467889925,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 116.69205856195879,
    "mi": 93.63809682641774,
    "token_count": 112.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response8.txt_stdout.txt",
    "code_path": "problem_iter14_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a balancing term for tight fitting and future capacity.\n    Uses exp function to balance between tightness and remaining capacity.\n    \"\"\"\n    # Identify bins that are too small and assign them a very low priority\n    priority = np.where(bins_remain_cap >= item, \n                        # Use a non-linear function to prioritize bins based on remaining capacity and item size\n                        np.exp(-(bins_remain_cap - item) / item), \n                        -np.inf)\n    \n    # Apply an additional balancing term to prioritize bins that are not too full\n    valid_bins = priority != -np.inf\n    if np.any(valid_bins):\n        # Use a non-linear function to further balance between tight fitting and future capacity\n        priority[valid_bins] *= (1 - item / bins_remain_cap[valid_bins])\n        \n    return priority",
    "response_id": 8,
    "tryHS": false,
    "obj": 16.513761467889925,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 116.69205856195879,
    "mi": 93.63809682641774,
    "token_count": 112.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response9.txt_stdout.txt",
    "code_path": "problem_iter14_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a balancing term for tight fitting and future capacity.\n    Prioritizes bins with enough capacity and a good balance between tightness and remaining capacity.\n    \"\"\"\n    # Identify bins that are too small and assign them a very low priority\n    remaining_cap_after_addition = bins_remain_cap - item\n    priority = np.where(bins_remain_cap >= item, \n                        # Use a non-linear function to prioritize bins based on remaining capacity after addition\n                        np.exp(-remaining_cap_after_addition / (bins_remain_cap + 1e-6)), \n                        -np.inf)\n    \n    # Apply a balancing term to prioritize bins that are not too full\n    valid_bins = priority != -np.inf\n    if np.any(valid_bins):\n        # Apply the balancing term directly without normalization\n        priority[valid_bins] *= (remaining_cap_after_addition[valid_bins] / bins_remain_cap[valid_bins])\n        \n    return priority",
    "response_id": 9,
    "tryHS": false,
    "obj": 149.30195452732352,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 116.69205856195879,
    "mi": 93.63809682641774,
    "token_count": 112.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter15_response0.txt_stdout.txt",
    "code_path": "problem_iter15_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is based on a non-linear function that balances tight fitting and future capacity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Identify bins that are too small for the item and give them a very low priority\n    priority = np.where(bins_remain_cap >= item, np.exp(-(bins_remain_cap - item)), -np.inf)\n    \n    # Return the priority scores\n    return priority",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 3.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 41.20902501875006,
    "mi": 53.923455849463195,
    "token_count": 63.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter15_response1.txt_stdout.txt",
    "code_path": "problem_iter15_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is based on a non-linear function that balances tight fitting and future capacity.\n    A bin with a remaining capacity that is just enough for the item will have a relatively high priority.\n    A bin that is too small for the item will have a priority of negative infinity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    \n    # First, we identify bins that are too small for the item and give them a very low priority\n    priority = np.where(bins_remain_cap >= item, np.exp(-(bins_remain_cap - item)), -np.inf)\n    \n    # Return the priority scores\n    return priority",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 3.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 41.20902501875006,
    "mi": 53.923455849463195,
    "token_count": 63.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter15_response2.txt_stdout.txt",
    "code_path": "problem_iter15_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is based on the remaining capacity of the bin and the size of the item.\n    A bin with a remaining capacity that is just enough for the item will have a relatively high priority.\n    A bin that is too small for the item will have a priority of negative infinity.\n    The priority is calculated using a non-linear function that balances tight fitting and future capacity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    \n    # Identify bins that are too small for the item and give them a very low priority\n    priority = np.where(bins_remain_cap >= item, np.exp(-(bins_remain_cap - item) / item), -np.inf)\n    \n    # Return the priority scores\n    return priority",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 3.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 41.20902501875006,
    "mi": 53.923455849463195,
    "token_count": 63.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter15_response3.txt_stdout.txt",
    "code_path": "problem_iter15_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is based on a non-linear function of the remaining capacity of the bin and the size of the item.\n    A bin with a remaining capacity that is just enough for the item will have the highest priority.\n    A bin that is too small for the item will have a priority of negative infinity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # First, we identify bins that are too small for the item and give them a very low priority\n    priority = np.where(bins_remain_cap >= item, np.exp(-(bins_remain_cap - item)), -np.inf)\n    \n    # Return the priority scores\n    return priority",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 3.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 41.20902501875006,
    "mi": 53.923455849463195,
    "token_count": 63.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter15_response4.txt_stdout.txt",
    "code_path": "problem_iter15_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is based on a non-linear function that balances tight fitting and future capacity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Identify bins that are too small for the item and give them a very low priority\n    priority = np.where(bins_remain_cap >= item, np.exp(-(bins_remain_cap - item) / item), -np.inf)\n    \n    # Return the priority scores\n    return priority",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 3.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 41.20902501875006,
    "mi": 53.923455849463195,
    "token_count": 63.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter16_response0.txt_stdout.txt",
    "code_path": "problem_iter16_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, \n                penalty_for_invalid= 694667349145.3547, \n                scale_factor_for_bonus= 0.00022850634556432884) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a simple penalty for large remaining capacity.\n    Balances tight fitting and future capacity using np.exp(-(bins_remain_cap - item) / item) and a bonus for larger bins_remain_cap.\n    \"\"\"\n    # Calculate priority score using a non-linear function for valid bins\n    priority = np.where(bins_remain_cap >= item, np.exp(-(bins_remain_cap - item) / item), -penalty_for_invalid)\n    \n    # Apply a bonus to prioritize bins with more remaining capacity among valid bins\n    valid_bins = priority != -penalty_for_invalid\n    if np.any(valid_bins):\n        priority[valid_bins] += scale_factor_for_bonus * bins_remain_cap[valid_bins]\n        \n    return priority",
    "response_id": 0,
    "tryHS": true,
    "obj": 4.058635819704831,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 100.07820003461549,
    "mi": 95.80101363877341,
    "token_count": 101.0,
    "exec_success": true
  }
]