{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Enhances non-linear prioritization with a dynamic penalty term that adapts to the remaining capacity and item size.\n    \"\"\"\n    # Calculate valid bins and remaining capacity after adding the item\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Dynamic non-linear prioritization balancing tight fit and future capacity\n    tight_fit_score = np.exp(-remain_cap_after_add / (item + 1e-6))  # Avoid division by zero\n    future_capacity_score = 1 - (remain_cap_after_add / bins_remain_cap) ** 2  # Penalize bins that are too full or too empty relative to their original capacity\n    \n    # Combine scores with a weighted average for better adaptability\n    priority = np.where(valid_bins == 1, \n                         0.7 * tight_fit_score + 0.3 * future_capacity_score,  # Balance between tight fit and future capacity\n                         -np.inf)\n    \n    # Normalize priority scores for enhanced adaptability across different item sizes\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:\n        priority = priority / max_priority\n    \n    return priority\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Simplifies and refines the non-linear prioritization with a focus on balancing tight fits and future capacity.\n    \"\"\"\n    # Identify valid bins\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    \n    # Calculate the remaining capacity after adding the item\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Simplified non-linear prioritization focusing on tight fit and future capacity\n    priority = np.where(valid_bins == 1, \n                         np.exp(-remain_cap_after_add / (item + 1e-6)) + 0.1 * (remain_cap_after_add / (bins_remain_cap + 1e-6)),  \n                         -np.inf)\n    \n    # Directly return priority scores without normalization to maintain distinction between tight and loose fits\n    return priority\n\n### Analyze & experience\n- Comparing the best heuristics (1st and 2nd) with the worst (19th and 20th), we see they share a similar structure but differ in parameter tuning and normalization. The top heuristics use a fixed penalty weight and scale factor, whereas the worst ones use tuned parameters. Comparing (1st) vs (2nd), we see identical implementations, suggesting a potential tie for the top spot. (3rd) vs (4th) shows a difference in penalty term formulation. Overall, top heuristics balance tight fits and future capacity using non-linear prioritization and refined penalty terms.\n- \nTo design better heuristics, let's analyze the given information.\n\n* **Keywords**: non-linear prioritization, balancing terms, tight fitting, future capacity, simplicity.\n* **Advice**: Focus on creating simple yet effective non-linear prioritization functions that balance tight fitting and future capacity, and consider thoughtful balancing terms.\n* **Avoid**: Unnecessary complexity, redundant code, unnecessary normalization, and ineffective penalty terms.\n* **Explanation**: By avoiding unnecessary complexity and focusing on simple, effective non-linear prioritization, we can create better heuristics that balance competing objectives like tight fitting and future capacity.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}