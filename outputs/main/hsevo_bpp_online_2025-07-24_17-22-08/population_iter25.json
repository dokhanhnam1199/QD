[
  {
    "stdout_filepath": "problem_iter23_response0.txt_stdout.txt",
    "code_path": "problem_iter23_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines simple non-linear prioritization with a refined balancing term.\n    Uses exp function and a penalty for large remaining capacity.\n    \"\"\"\n    # Non-linear prioritization for valid bins\n    priority = np.where(bins_remain_cap >= item, np.exp(-(bins_remain_cap - item)), -np.inf)\n    \n    # Refined balancing term\n    valid_bins = priority != -np.inf\n    if np.any(valid_bins):\n        # Normalize priority scores\n        max_priority = np.max(priority[valid_bins])\n        priority[valid_bins] /= max_priority\n        \n        # Apply penalty for large remaining capacity\n        remaining_cap_after_addition = bins_remain_cap[valid_bins] - item\n        priority[valid_bins] *= 1 / (1 + remaining_cap_after_addition)\n        \n    return priority",
    "response_id": 0,
    "tryHS": true,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 129.65784284662087,
    "mi": 92.14452263777774,
    "token_count": 110.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter23_response1.txt_stdout.txt",
    "code_path": "problem_iter23_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a refined penalty term for balance.\n    \"\"\"\n    # Calculate remaining capacity after adding the item\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Non-linear prioritization with a refined penalty for large remaining capacity\n    priority = np.where(bins_remain_cap >= item, \n                         np.exp(-remain_cap_after_add / item) / (1 + remain_cap_after_add), \n                         -np.inf)\n    \n    return priority",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 129.65784284662087,
    "mi": 92.14452263777774,
    "token_count": 110.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter23_response2.txt_stdout.txt",
    "code_path": "problem_iter23_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a penalty term for large remaining capacities.\n    Uses np.exp(-(bins_remain_cap - item)) and a sigmoid-like penalty for valid bins.\n    \"\"\"\n    # Non-linear prioritization for valid bins\n    priority = np.where(bins_remain_cap >= item, np.exp(-(bins_remain_cap - item)), -np.inf)\n    \n    # Apply a sigmoid-like penalty to valid bins to avoid wasting space\n    valid_bins = priority != -np.inf\n    if np.any(valid_bins):\n        priority[valid_bins] *= (1 / (1 + np.exp((bins_remain_cap[valid_bins] - item) / item)))\n        \n    return priority",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 129.65784284662087,
    "mi": 92.14452263777774,
    "token_count": 110.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter23_response3.txt_stdout.txt",
    "code_path": "problem_iter23_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for each bin based on a balanced non-linear function.\n    Combines simplicity with a penalty term for better performance.\n    \"\"\"\n    # Calculate priority using a simple non-linear function with a penalty term\n    priority = np.where(bins_remain_cap >= item, \n                        np.exp(-(bins_remain_cap - item)),  # Simple non-linear prioritization\n                        -np.inf)\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:\n        # Normalize the priority scores for better adaptability\n        priority = priority / max_priority\n    \n    return priority",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 129.65784284662087,
    "mi": 92.14452263777774,
    "token_count": 110.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter23_response4.txt_stdout.txt",
    "code_path": "problem_iter23_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a refined balancing term for tight fitting and future capacity.\n    Uses np.exp for prioritization and a simple ratio for balancing.\n    \"\"\"\n    # Non-linear prioritization for valid bins\n    priority = np.where(bins_remain_cap >= item, np.exp(-(bins_remain_cap - item) / (bins_remain_cap + 1e-6)), -np.inf)\n    \n    # Refined balancing term: prioritize bins that are not too full\n    valid_bins = priority != -np.inf\n    if np.any(valid_bins):\n        # Balance between tight fitting and future capacity using a simple ratio\n        remaining_cap_after_addition = bins_remain_cap[valid_bins] - item\n        priority[valid_bins] *= (1 - (remaining_cap_after_addition / bins_remain_cap[valid_bins]))\n        \n    return priority",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 129.65784284662087,
    "mi": 92.14452263777774,
    "token_count": 110.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter23_response5.txt_stdout.txt",
    "code_path": "problem_iter23_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a balancing term for tight fitting and future capacity.\n    Uses np.exp(-(bins_remain_cap - item)) and a balancing term (bins_remain_cap - item) / bins_remain_cap for valid bins.\n    \"\"\"\n    # Calculate non-linear priority for valid bins and assign -inf to invalid bins\n    valid_bins = (bins_remain_cap >= item)\n    priority = np.where(valid_bins, np.exp(-(bins_remain_cap - item)) * ((bins_remain_cap - item) / bins_remain_cap), -np.inf)\n    \n    # Return the priority scores\n    return priority",
    "response_id": 5,
    "tryHS": false,
    "obj": 5.195452732349436,
    "SLOC": 6.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 129.65784284662087,
    "mi": 92.14452263777774,
    "token_count": 110.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter23_response6.txt_stdout.txt",
    "code_path": "problem_iter23_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a refined penalty term for balance.\n    \"\"\"\n    # Calculate remaining capacity after adding the item\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Non-linear prioritization with a penalty for large remaining capacity\n    priority = np.where(bins_remain_cap >= item, \n                         np.exp(-remain_cap_after_add / item) / (1 + remain_cap_after_add), \n                         -np.inf)\n    \n    return priority",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 129.65784284662087,
    "mi": 92.14452263777774,
    "token_count": 110.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter23_response7.txt_stdout.txt",
    "code_path": "problem_iter23_code7.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a refined balancing term.\n    Uses np.exp for prioritization and a ratio for balancing, with a penalty for large remaining capacity.\n    \"\"\"\n    # Identify valid bins\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    \n    # Calculate remaining capacity after adding the item\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Non-linear prioritization with a balancing term and a penalty for large remaining capacity\n    priority = np.where(valid_bins == 1, \n                         np.exp(-remain_cap_after_add / item) * (remain_cap_after_add / bins_remain_cap) - 0.01 * remain_cap_after_add, \n                         -np.inf)\n    \n    return priority",
    "response_id": 7,
    "tryHS": false,
    "obj": 7.319505384922227,
    "SLOC": 6.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 129.65784284662087,
    "mi": 92.14452263777774,
    "token_count": 110.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter23_response8.txt_stdout.txt",
    "code_path": "problem_iter23_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a refined balancing term for tight fitting and future capacity.\n    Utilizes np.exp for prioritization and a simple ratio for balancing.\n    \"\"\"\n    # Non-linear prioritization for valid bins\n    priority = np.where(bins_remain_cap >= item, np.exp(-(bins_remain_cap - item) / item), -np.inf)\n    \n    # Refined balancing term: prioritize bins that are not too full\n    valid_bins = priority != -np.inf\n    if np.any(valid_bins):\n        remaining_cap_after_addition = bins_remain_cap[valid_bins] - item\n        # Balance between tight fitting and future capacity using a simple ratio and add a small bonus for remaining capacity\n        priority[valid_bins] *= (1 - (remaining_cap_after_addition / bins_remain_cap[valid_bins])) + 1e-6 * remaining_cap_after_addition\n        \n    return priority",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 129.65784284662087,
    "mi": 92.14452263777774,
    "token_count": 110.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter23_response9.txt_stdout.txt",
    "code_path": "problem_iter23_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a penalty term for large remaining capacities.\n    Uses np.exp for non-linear prioritization and a sigmoid-like function to penalize large capacities.\n    \"\"\"\n    # Non-linear prioritization for valid bins\n    priority = np.where(bins_remain_cap >= item, np.exp(-(bins_remain_cap - item)), -np.inf)\n    \n    # Apply a penalty to bins that are too large for the item\n    valid_bins = priority != -np.inf\n    if np.any(valid_bins):\n        priority[valid_bins] *= (1 / (1 + np.exp((bins_remain_cap[valid_bins] - item) / item)))\n        \n    return priority",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 129.65784284662087,
    "mi": 92.14452263777774,
    "token_count": 110.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter24_response0.txt_stdout.txt",
    "code_path": "problem_iter24_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is based on a non-linear function of the remaining capacity of the bin and the size of the item.\n    A bin with a remaining capacity that is just enough for the item will have the highest priority.\n    A bin that is too small for the item will have a priority of negative infinity.\n    The function also considers the future capacity of the bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # First, we identify bins that are too small for the item and give them a very low priority\n    priority = np.where(bins_remain_cap >= item, np.exp(-(bins_remain_cap - item)), -np.inf)\n    \n    # Then, we apply a balancing term to encourage using bins that are not too full or too empty\n    # This term is based on the ratio of the remaining capacity to the total capacity (assuming it's 1)\n    balancing_term = np.where(bins_remain_cap >= item, (bins_remain_cap - item) / bins_remain_cap, 0)\n    priority *= balancing_term\n    \n    # Return the priority scores\n    return priority",
    "response_id": 0,
    "tryHS": false,
    "obj": 5.195452732349436,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 120.92782504182705,
    "mi": 52.65228261602394,
    "token_count": 96.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter24_response1.txt_stdout.txt",
    "code_path": "problem_iter24_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is based on a combination of the remaining capacity of the bin and the size of the item,\n    incorporating a non-linear prioritization that balances tight fitting and future capacity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Identify bins that are too small for the item and give them a very low priority\n    priority = np.where(bins_remain_cap >= item, 1 / (1 + np.abs(bins_remain_cap - item)), -np.inf)\n    \n    # Introduce a penalty term for bins that are too large compared to the item, to encourage tighter packing\n    priority = np.where(bins_remain_cap >= item, priority - 0.1 * (bins_remain_cap - item) / bins_remain_cap.max(), priority)\n    \n    # Return the priority scores\n    return priority",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 120.92782504182705,
    "mi": 52.65228261602394,
    "token_count": 96.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter24_response2.txt_stdout.txt",
    "code_path": "problem_iter24_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is based on the remaining capacity of the bin and the size of the item.\n    A bin with a remaining capacity that is just enough for the item will have the highest priority.\n    A bin that is too small for the item will have a priority of negative infinity.\n    The priority is also influenced by the proportion of the remaining capacity that will be used.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # First, we identify bins that are too small for the item and give them a very low priority\n    priority = np.where(bins_remain_cap >= item, \n                        # Calculate a score that balances between having just enough capacity and leaving enough remaining capacity\n                        -((bins_remain_cap - item) / bins_remain_cap) + (item / bins_remain_cap), \n                        -np.inf)\n    \n    # Return the priority scores\n    return priority",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 120.92782504182705,
    "mi": 52.65228261602394,
    "token_count": 96.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter24_response3.txt_stdout.txt",
    "code_path": "problem_iter24_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is based on a non-linear function of the remaining capacity of the bin and the size of the item.\n    A bin with a remaining capacity that is just enough for the item will have the highest priority.\n    A bin that is too small for the item will have a priority of negative infinity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # First, we identify bins that are too small for the item and give them a very low priority\n    priority = np.where(bins_remain_cap >= item, np.exp(-(bins_remain_cap - item)), -np.inf)\n    \n    # Then, we apply a penalty term to bins that are too large for the item, to encourage tighter fits\n    # This is done by multiplying the priority by a term that decreases as the remaining capacity increases\n    priority = np.where(bins_remain_cap >= item, priority * (1 - (bins_remain_cap - item) / bins_remain_cap), priority)\n    \n    # Return the priority scores\n    return priority",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 120.92782504182705,
    "mi": 52.65228261602394,
    "token_count": 96.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter24_response4.txt_stdout.txt",
    "code_path": "problem_iter24_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is based on the remaining capacity of the bin and the size of the item.\n    A bin with a remaining capacity that is just enough for the item will have the highest priority.\n    A bin that is too small for the item will have a priority of negative infinity.\n    The priority also considers the future capacity of the bin after packing the item.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # First, we identify bins that are too small for the item and give them a very low priority\n    priority = np.where(bins_remain_cap >= item, 1 / (1 + np.abs(bins_remain_cap - item)), -np.inf)\n    \n    # Then, we apply a penalty term to bins that will be too full after packing the item\n    # This term encourages leaving some capacity for future items\n    penalty_term = np.where(bins_remain_cap - item > 0, (bins_remain_cap - item) / bins_remain_cap, 0)\n    priority *= penalty_term\n    \n    # Return the priority scores\n    return priority",
    "response_id": 4,
    "tryHS": false,
    "obj": 7.209812524930191,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 120.92782504182705,
    "mi": 52.65228261602394,
    "token_count": 96.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter25_response0.txt_stdout.txt",
    "code_path": "problem_iter25_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, \n                penalty_threshold: float = 6.9704939513037525, \n                priority_scale: float = 7.530712199029883, \n                exp_base: float = 3.4892108663866948) -> np.ndarray:\n    \"\"\"\n    Combines simple non-linear prioritization with a refined balancing term.\n    Uses exp function and a penalty for large remaining capacity.\n    \"\"\"\n    # Non-linear prioritization for valid bins\n    priority = np.where(bins_remain_cap >= item, np.exp(-(bins_remain_cap - item) / priority_scale), -np.inf)\n    \n    # Refined balancing term\n    valid_bins = priority != -np.inf\n    if np.any(valid_bins):\n        # Normalize priority scores\n        max_priority = np.max(priority[valid_bins])\n        priority[valid_bins] /= max_priority\n        \n        # Apply penalty for large remaining capacity\n        remaining_cap_after_addition = bins_remain_cap[valid_bins] - item\n        priority[valid_bins] *= 1 / (1 + np.maximum(remaining_cap_after_addition, penalty_threshold))\n        \n    return priority",
    "response_id": 0,
    "tryHS": true,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 149.27754454988144,
    "mi": 91.720497255136,
    "token_count": 157.0,
    "exec_success": true
  }
]