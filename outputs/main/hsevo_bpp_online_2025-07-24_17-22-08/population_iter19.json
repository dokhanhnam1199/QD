[
  {
    "stdout_filepath": "problem_iter17_response0.txt_stdout.txt",
    "code_path": "problem_iter17_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a balancing term for tight fitting and future capacity.\n    Balances between tightness and remaining capacity using exp function and a simple ratio.\n    \"\"\"\n    # Identify bins that are too small and assign them a very low priority\n    priority = np.where(bins_remain_cap >= item, \n                        # Use a non-linear function to prioritize bins based on remaining capacity and item size\n                        np.exp(-(bins_remain_cap - item) / item), \n                        -np.inf)\n    \n    # Apply a balancing term to prioritize bins that are not too full\n    valid_bins = priority != -np.inf\n    if np.any(valid_bins):\n        remaining_cap_after_addition = bins_remain_cap[valid_bins] - item\n        # Use a simple ratio to balance between tight fitting and future capacity\n        priority[valid_bins] *= (remaining_cap_after_addition / bins_remain_cap[valid_bins])\n        \n    return priority",
    "response_id": 0,
    "tryHS": false,
    "obj": 16.513761467889925,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 83.76180828526728,
    "mi": 96.23461217471804,
    "token_count": 74.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter17_response1.txt_stdout.txt",
    "code_path": "problem_iter17_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a penalty for large remaining capacity, \n    balancing tight fitting and future capacity effectively.\n    \"\"\"\n    # Calculate remaining capacity after adding the item\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Non-linear prioritization with a penalty for large remaining capacity\n    priority = np.where(bins_remain_cap >= item, \n                         np.exp(-remain_cap_after_add / item) - 0.01 * bins_remain_cap, \n                         -np.inf)\n    \n    return priority",
    "response_id": 1,
    "tryHS": true,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 83.76180828526728,
    "mi": 96.23461217471804,
    "token_count": 74.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter17_response2.txt_stdout.txt",
    "code_path": "problem_iter17_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a balance between tight fitting and future capacity.\n    Uses a non-linear function and prioritizes bins with remaining capacity just enough for the item.\n    \"\"\"\n    # Calculate priority score using a non-linear function for valid bins\n    priority = np.where(bins_remain_cap >= item, np.exp(-(bins_remain_cap - item)), -np.inf)\n    \n    # Apply a small bonus to valid bins to balance tight fitting and future capacity\n    valid_bins = priority != -np.inf\n    if np.any(valid_bins):\n        priority[valid_bins] += 1e-6 * bins_remain_cap[valid_bins]  # Bonus for more remaining capacity\n        \n    return priority",
    "response_id": 2,
    "tryHS": false,
    "obj": 66.094934184284,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 83.76180828526728,
    "mi": 96.23461217471804,
    "token_count": 74.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter17_response3.txt_stdout.txt",
    "code_path": "problem_iter17_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a balancing term for tight fitting and future capacity.\n    Uses np.exp(-(bins_remain_cap - item) / item) and a bonus for remaining capacity after addition.\n    \"\"\"\n    # Calculate priority score using a non-linear function for valid bins\n    remaining_cap_after_addition = bins_remain_cap - item\n    priority = np.where(bins_remain_cap >= item, np.exp(-remaining_cap_after_addition / item), -np.inf)\n    \n    # Apply a bonus to prioritize bins based on remaining capacity after addition\n    valid_bins = priority != -np.inf\n    if np.any(valid_bins):\n        # Add a small bonus based on the remaining capacity after addition to balance tightness and future capacity\n        priority[valid_bins] += 1e-6 * remaining_cap_after_addition[valid_bins]\n        \n    return priority",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.058635819704831,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 83.76180828526728,
    "mi": 96.23461217471804,
    "token_count": 74.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter17_response4.txt_stdout.txt",
    "code_path": "problem_iter17_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a balance between tight fitting and future capacity.\n    Uses exp function and considers remaining capacity after addition for balancing.\n    \"\"\"\n    # Identify bins that are too small for the item and give them a very low priority\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Non-linear priority with a balance term for valid bins\n    priority = np.where(valid_bins == 1, np.exp(-remaining_cap_after_addition / item) * (1 / (1 + remaining_cap_after_addition)), -np.inf)\n    \n    return priority",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 83.76180828526728,
    "mi": 96.23461217471804,
    "token_count": 74.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter17_response5.txt_stdout.txt",
    "code_path": "problem_iter17_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a penalty for large remaining capacity.\n    Balances tight fitting and future capacity using a non-linear function.\n    \"\"\"\n    # Non-linear prioritization for valid bins\n    priority = np.where(bins_remain_cap >= item, np.exp(-(bins_remain_cap - item) / item), -np.inf)\n    # Normalize priority scores so that the bin with the smallest remaining capacity gets the highest priority\n    valid_bins = priority != -np.inf\n    if np.any(valid_bins):\n        priority[valid_bins] = - (bins_remain_cap[valid_bins] - item)\n        \n    return priority",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 83.76180828526728,
    "mi": 96.23461217471804,
    "token_count": 74.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter17_response6.txt_stdout.txt",
    "code_path": "problem_iter17_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a balance term for tight fitting and future capacity.\n    Uses np.exp(-(bins_remain_cap - item) / item) and a balancing term for valid bins.\n    \"\"\"\n    # Calculate priority score using a non-linear function for valid bins\n    priority = np.where(bins_remain_cap >= item, np.exp(-(bins_remain_cap - item) / item), -np.inf)\n    \n    # Apply a balancing term to valid bins to prioritize bins that are not too full\n    valid_bins = priority != -np.inf\n    if np.any(valid_bins):\n        remaining_cap_after_addition = bins_remain_cap[valid_bins] - item\n        # Balance between tight fitting and future capacity\n        priority[valid_bins] *= (remaining_cap_after_addition / bins_remain_cap[valid_bins])\n        \n    return priority",
    "response_id": 6,
    "tryHS": false,
    "obj": 16.513761467889925,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 83.76180828526728,
    "mi": 96.23461217471804,
    "token_count": 74.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter17_response7.txt_stdout.txt",
    "code_path": "problem_iter17_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a penalty for large remaining capacity.\n    Balances tight fitting and future capacity effectively.\n    \"\"\"\n    # Identify bins that are too small for the item and give them a very low priority\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    \n    # Non-linear priority with a penalty for large remaining capacity\n    priority = np.where(valid_bins == 1, np.exp(-(bins_remain_cap - item)), -np.inf)\n    \n    # Adjust priority to balance between tight fitting and future capacity\n    priority = np.where(valid_bins == 1, priority * (bins_remain_cap - item) / bins_remain_cap, priority)\n    \n    return priority",
    "response_id": 7,
    "tryHS": false,
    "obj": 5.195452732349436,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 83.76180828526728,
    "mi": 96.23461217471804,
    "token_count": 74.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter17_response8.txt_stdout.txt",
    "code_path": "problem_iter17_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a balance between tight fitting and future capacity.\n    Uses exp function and a penalty for large remaining capacity.\n    \"\"\"\n    # Identify bins that are too small for the item and give them a very low priority\n    priority = np.where(bins_remain_cap >= item, np.exp(-(bins_remain_cap - item) / item), -np.inf)\n    \n    # Balance between tight fitting and future capacity by considering remaining capacity\n    valid_bins = priority != -np.inf\n    if np.any(valid_bins):\n        # Apply a bonus to prioritize bins with more remaining capacity among valid bins\n        # but use a non-linear function to avoid overly favoring large remaining capacity\n        priority[valid_bins] *= 1 / (1 + bins_remain_cap[valid_bins] - item)\n        \n    return priority",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 83.76180828526728,
    "mi": 96.23461217471804,
    "token_count": 74.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter17_response9.txt_stdout.txt",
    "code_path": "problem_iter17_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a balancing term for tight fitting and future capacity.\n    Prioritizes bins based on remaining capacity and item size using a non-linear function.\n    \"\"\"\n    # Identify bins that are too small for the item and give them a very low priority\n    priority = np.where(bins_remain_cap >= item, \n                        # Non-linear priority with a balancing term\n                        np.exp(-(bins_remain_cap - item) / item) * (1 - item / bins_remain_cap), \n                        -np.inf)\n    \n    # Return the priority scores\n    return priority",
    "response_id": 9,
    "tryHS": false,
    "obj": 16.513761467889925,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 83.76180828526728,
    "mi": 96.23461217471804,
    "token_count": 74.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter18_response0.txt_stdout.txt",
    "code_path": "problem_iter18_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is based on a non-linear function of the remaining capacity of the bin and the size of the item.\n    A bin with a remaining capacity that is just enough for the item will have a relatively high priority.\n    A bin that is too small for the item will have a priority of negative infinity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Identify bins that are too small for the item and give them a very low priority\n    priority = np.where(bins_remain_cap >= item, \n                        # Use a non-linear function to balance between tight fitting and leaving room for future items\n                        -((bins_remain_cap - item) / (bins_remain_cap + 1e-6))**2 + np.log(bins_remain_cap - item + 1), \n                        -np.inf)\n    \n    # Return the priority scores\n    return priority",
    "response_id": 0,
    "tryHS": false,
    "obj": 149.30195452732352,
    "SLOC": 3.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 28.07354922057604,
    "mi": 55.09065655282138,
    "token_count": 61.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter18_response1.txt_stdout.txt",
    "code_path": "problem_iter18_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is based on a non-linear function of the remaining capacity of the bin and the size of the item.\n    It balances between tight fitting and leaving room for future items.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # First, we identify bins that are too small for the item and give them a very low priority\n    priority = np.where(bins_remain_cap >= item, np.exp(-(bins_remain_cap - item)), -np.inf)\n    \n    # Return the priority scores\n    return priority",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 3.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 28.07354922057604,
    "mi": 55.09065655282138,
    "token_count": 61.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter18_response2.txt_stdout.txt",
    "code_path": "problem_iter18_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is based on a non-linear function of the remaining capacity of the bin and the size of the item.\n    It aims to strike a balance between tight fitting and leaving room for future items.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # First, we identify bins that are too small for the item and give them a very low priority\n    priority = np.where(bins_remain_cap >= item, \n                        # A non-linear function that prioritizes bins with remaining capacity slightly larger than the item\n                        -(bins_remain_cap - item) ** 2 / (bins_remain_cap + 1e-6), \n                        -np.inf)\n    \n    # Return the priority scores\n    return priority",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 3.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 28.07354922057604,
    "mi": 55.09065655282138,
    "token_count": 61.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter18_response3.txt_stdout.txt",
    "code_path": "problem_iter18_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is based on a non-linear function of the remaining capacity of the bin and the size of the item.\n    A bin with a remaining capacity that is just enough for the item will have a relatively high priority.\n    A bin that is too small for the item will have a priority of negative infinity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # First, we identify bins that are too small for the item and give them a very low priority\n    priority = np.where(bins_remain_cap >= item, np.exp(-(bins_remain_cap - item)), -np.inf)\n    \n    # Return the priority scores\n    return priority",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 3.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 28.07354922057604,
    "mi": 55.09065655282138,
    "token_count": 61.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter18_response4.txt_stdout.txt",
    "code_path": "problem_iter18_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is based on a non-linear function that balances between tight fitting and leaving room for future items.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # First, we identify bins that are too small for the item and give them a very low priority\n    priority = np.where(bins_remain_cap >= item, np.exp(-(bins_remain_cap - item)), -np.inf)\n    \n    # Return the priority scores\n    return priority",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 3.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 28.07354922057604,
    "mi": 55.09065655282138,
    "token_count": 61.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter19_response0.txt_stdout.txt",
    "code_path": "problem_iter19_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, penalty_weight: float = 0.18707510875955213) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a penalty for large remaining capacity, \n    balancing tight fitting and future capacity effectively.\n    \"\"\"\n    # Calculate remaining capacity after adding the item\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Non-linear prioritization with a penalty for large remaining capacity\n    priority = np.where(bins_remain_cap >= item, \n                         np.exp(-remain_cap_after_add / item) - penalty_weight * bins_remain_cap, \n                         -np.inf)\n    \n    return priority",
    "response_id": 0,
    "tryHS": true,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 70.30835464468075,
    "mi": 97.32773535558414,
    "token_count": 77.0,
    "exec_success": true
  }
]