{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is based on the remaining capacity of the bin and the size of the item.\n    A bin with a remaining capacity that is just enough for the item will have the highest priority.\n    A bin that is too small for the item will have a priority of negative infinity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # First, we identify bins that are too small for the item and give them a very low priority\n    priority = np.where(bins_remain_cap >= item, bins_remain_cap - item, -np.inf)\n    \n    # Then, we normalize the priority scores so that the bin with the smallest remaining capacity \n    # that is still enough for the item gets the highest priority\n    priority = -priority\n    \n    # Return the priority scores\n    return priority\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines elements of minimizing remaining capacity and using a non-linear function.\n    Prioritizes bins with remaining capacity closer to the item size using a reciprocal function.\n    \"\"\"\n    # Calculate priority score using a reciprocal function for valid bins\n    priority = np.where(bins_remain_cap >= item, 1 / (bins_remain_cap - item + 1), -np.inf)\n    \n    # Normalize the priority scores to be between 0 and 1 for valid bins\n    valid_bins = priority > -np.inf\n    if np.any(valid_bins):\n        min_priority = np.min(priority[valid_bins])\n        max_priority = np.max(priority[valid_bins])\n        priority = np.where(valid_bins, (priority - min_priority) / (max_priority - min_priority), 0)\n    \n    return priority\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority score for each bin. \n    Combines the benefits of both best-fit and tight-fitting heuristics.\n    \"\"\"\n    # Identify bins that are too small for the item and give them a very low priority\n    # Use a non-linear function (1 / (1 + abs)) to prioritize bins with remaining capacity closest to the item size\n    priority = np.where(bins_remain_cap >= item, 1 / (1 + np.abs(bins_remain_cap - item)), -np.inf)\n    \n    # Normalize the priority scores by the remaining capacity to encourage tight-fitting\n    valid_bins = priority != -np.inf\n    if np.any(valid_bins):\n        # Weigh the priority scores by the remaining capacity after addition\n        priority[valid_bins] *= (1 - (bins_remain_cap[valid_bins] - item) / bins_remain_cap[valid_bins])\n    \n    return priority\n\n[Heuristics 4th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is based on a trade-off between the remaining capacity of the bin and the size of the item.\n    A non-linear function is used to prioritize bins that have a remaining capacity that is just enough for the item,\n    while also considering the potential for future items.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # First, we identify bins that are too small for the item and give them a very low priority\n    priority = np.where(bins_remain_cap >= item, np.exp(-(bins_remain_cap - item)), -np.inf)\n    \n    # Then, we add a term that prioritizes bins that are not too empty, to leave room for future items\n    priority *= (1 + np.tanh(bins_remain_cap - item / 2))\n    \n    # Return the priority scores\n    return priority\n\n[Heuristics 5th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines elements of minimizing remaining capacity and using a non-linear function.\n    Prioritizes bins with remaining capacity closer to the item size using a reciprocal function.\n    \"\"\"\n    # Calculate priority score using a reciprocal function for valid bins\n    priority = np.where(bins_remain_cap >= item, 1 / (bins_remain_cap - item + 1), -np.inf)\n    \n    # Normalize the priority scores to be between 0 and 1 for valid bins\n    valid_bins = priority > -np.inf\n    if np.any(valid_bins):\n        min_priority = np.min(priority[valid_bins])\n        max_priority = np.max(priority[valid_bins])\n        priority = np.where(valid_bins, (priority - min_priority) / (max_priority - min_priority), 0)\n    \n    return priority\n\n[Heuristics 6th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a trade-off between tight fit and future capacity.\n    Prioritizes bins with enough capacity and smaller remaining capacity after addition.\n    \"\"\"\n    # Calculate priority scores using a non-linear function that balances tight fit and remaining capacity\n    priority_scores = np.where(bins_remain_cap >= item, 1 / (bins_remain_cap - item + 1e-6), -1.0)\n    \n    # Normalize priority scores to ensure a better distribution\n    valid_bins = priority_scores != -1.0\n    if np.any(valid_bins):\n        max_score = np.max(priority_scores[valid_bins])\n        min_score = np.min(priority_scores[valid_bins])\n        priority_scores[valid_bins] = (priority_scores[valid_bins] - min_score) / (max_score - min_score + 1e-6)\n        \n    return priority_scores\n\n[Heuristics 7th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a trade-off between tight fit and future capacity.\n    Prioritizes bins with enough capacity and smaller remaining capacity after addition.\n    \"\"\"\n    # Calculate priority scores using a non-linear function that balances tight fit and remaining capacity\n    priority_scores = np.where(bins_remain_cap >= item, 1 / (bins_remain_cap - item + 1e-6), -1.0)\n    \n    # Normalize priority scores to ensure a better distribution\n    valid_bins = priority_scores != -1.0\n    if np.any(valid_bins):\n        max_score = np.max(priority_scores[valid_bins])\n        min_score = np.min(priority_scores[valid_bins])\n        priority_scores[valid_bins] = (priority_scores[valid_bins] - min_score) / (max_score - min_score + 1e-6)\n        \n    return priority_scores\n\n[Heuristics 8th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority score for each bin. \n    Combines the benefits of both best-fit and tight-fitting heuristics.\n    \"\"\"\n    # Identify bins that are too small for the item and give them a very low priority\n    # Use a non-linear function (1 / (1 + abs)) to prioritize bins with remaining capacity closest to the item size\n    priority = np.where(bins_remain_cap >= item, 1 / (1 + np.abs(bins_remain_cap - item)), -np.inf)\n    \n    # Normalize the priority scores by the remaining capacity to encourage tight-fitting\n    valid_bins = priority != -np.inf\n    if np.any(valid_bins):\n        # Weigh the priority scores by the remaining capacity after addition\n        priority[valid_bins] *= (1 - (bins_remain_cap[valid_bins] - item) / bins_remain_cap[valid_bins])\n    \n    return priority\n\n[Heuristics 9th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Priority score for each bin based on a non-linear function of remaining capacity after adding the item.\n    Combines elements of priority_v0 and avoids unnecessary normalization.\n    \"\"\"\n    # Check if item fits and calculate remaining capacity after addition\n    valid_bins = (bins_remain_cap >= item).astype(float)  \n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Use a non-linear function to prioritize bins with remaining capacity closest to zero\n    priority = np.where(valid_bins == 1, np.exp(-remaining_cap_after_addition / bins_remain_cap), 0)\n    \n    return priority\n\n[Heuristics 10th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority score for each bin. \n    Combines the benefits of both best-fit and tight-fitting heuristics.\n    \"\"\"\n    # Identify bins that are too small for the item and give them a very low priority\n    # Use a non-linear function (1 / (1 + abs)) to prioritize bins with remaining capacity closest to the item size\n    priority = np.where(bins_remain_cap >= item, 1 / (1 + np.abs(bins_remain_cap - item)), -np.inf)\n    \n    # Normalize the priority scores by the remaining capacity to encourage tight-fitting\n    valid_bins = priority != -np.inf\n    if np.any(valid_bins):\n        # Weigh the priority scores by the remaining capacity after addition\n        priority[valid_bins] *= (1 - (bins_remain_cap[valid_bins] - item) / bins_remain_cap[valid_bins])\n    \n    return priority\n\n[Heuristics 11th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Priority score based on negative remaining capacity after adding item and \n    a bonus for bins with more remaining capacity to balance tight fit and future capacity.\n    \"\"\"\n    # Calculate priority score as negative of remaining capacity after adding item\n    priority = np.where(bins_remain_cap >= item, -(bins_remain_cap - item), -np.inf)\n    \n    # Add a bonus to bins with more remaining capacity to balance tight fit and future capacity\n    priority = np.where(priority > -np.inf, priority + 1e-3 * np.exp(bins_remain_cap / (item + 1e-6)), priority)\n    \n    return priority\n\n[Heuristics 12th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is based on a non-linear function of the remaining capacity of the bin and the size of the item.\n    It balances the trade-off between packing items tightly and leaving room for future items.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Identify bins that are too small for the item and give them a very low priority\n    priority = np.where(bins_remain_cap >= item, \n                        # Use a non-linear function to balance tight packing and room for future items\n                        -((bins_remain_cap - item) / bins_remain_cap) ** 2 + (1 - item / bins_remain_cap), \n                        -np.inf)\n    \n    # Return the priority scores\n    return priority\n\n[Heuristics 13th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is based on a non-linear function of the remaining capacity of the bin and the size of the item.\n    It balances the trade-off between packing items tightly and leaving room for future items.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Identify bins that are too small for the item and give them a very low priority\n    priority = np.where(bins_remain_cap >= item, \n                        # Use a non-linear function to balance tight packing and room for future items\n                        -((bins_remain_cap - item) / bins_remain_cap) ** 2 + (1 - item / bins_remain_cap), \n                        -np.inf)\n    \n    # Return the priority scores\n    return priority\n\n[Heuristics 14th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is based on a non-linear function of the remaining capacity of the bin and the size of the item.\n    It balances the trade-off between packing items tightly and leaving room for future items.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Identify bins that are too small for the item and give them a very low priority\n    priority = np.where(bins_remain_cap >= item, \n                        # Use a non-linear function to balance tight packing and room for future items\n                        -((bins_remain_cap - item) / bins_remain_cap) ** 2 + (1 - item / bins_remain_cap), \n                        -np.inf)\n    \n    # Return the priority scores\n    return priority\n\n[Heuristics 15th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is based on a non-linear function of the remaining capacity of the bin and the size of the item.\n    It balances the trade-off between packing items tightly and leaving room for future items.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Identify bins that are too small for the item and give them a very low priority\n    priority = np.where(bins_remain_cap >= item, \n                        # Use a non-linear function to balance tight packing and room for future items\n                        -((bins_remain_cap - item) / bins_remain_cap) ** 2 + (1 - item / bins_remain_cap), \n                        -np.inf)\n    \n    # Return the priority scores\n    return priority\n\n[Heuristics 16th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is based on a non-linear function of the remaining capacity of the bin and the size of the item.\n    A bin with a remaining capacity that is just enough for the item and leaves a reasonable room for future items will have the highest priority.\n    A bin that is too small for the item will have a priority of negative infinity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # First, we identify bins that are too small for the item and give them a very low priority\n    priority = np.where(bins_remain_cap >= item, np.exp(-(bins_remain_cap - item)), -np.inf)\n    \n    # Then, we consider the trade-off between fitting items tightly and leaving room for future items\n    # by adding a term that rewards bins with a reasonable remaining capacity\n    avg_remain_cap = np.mean(bins_remain_cap[bins_remain_cap >= item])\n    priority = np.where(bins_remain_cap >= item, priority * (1 + np.tanh(bins_remain_cap - avg_remain_cap)), priority)\n    \n    # Return the priority scores\n    return priority\n\n[Heuristics 17th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is based on a non-linear function of the remaining capacity of the bin and the size of the item.\n    A bin with a remaining capacity that is just enough for the item and leaves a reasonable room for future items will have the highest priority.\n    A bin that is too small for the item will have a priority of negative infinity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # First, we identify bins that are too small for the item and give them a very low priority\n    priority = np.where(bins_remain_cap >= item, np.exp(-(bins_remain_cap - item)), -np.inf)\n    \n    # Then, we consider the trade-off between fitting items tightly and leaving room for future items\n    # by adding a term that rewards bins with a reasonable remaining capacity\n    avg_remain_cap = np.mean(bins_remain_cap[bins_remain_cap >= item])\n    priority = np.where(bins_remain_cap >= item, priority * (1 + np.tanh(bins_remain_cap - avg_remain_cap)), priority)\n    \n    # Return the priority scores\n    return priority\n\n[Heuristics 18th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is based on a non-linear function of the remaining capacity of the bin and the size of the item.\n    A bin with a remaining capacity that is just enough for the item and leaves some room for future items will have the highest priority.\n    A bin that is too small for the item will have a priority of negative infinity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # First, we identify bins that are too small for the item and give them a very low priority\n    priority = np.where(bins_remain_cap >= item, np.log(bins_remain_cap - item + 1), -np.inf)\n    \n    # Then, we add a penalty term to bins with very large remaining capacity to encourage tighter packing\n    priority = np.where(bins_remain_cap >= item, priority - 0.1 * (bins_remain_cap - item) / (bins_remain_cap + 1e-6), priority)\n    \n    # Return the priority scores\n    return priority\n\n[Heuristics 19th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is based on a non-linear function of the remaining capacity of the bin and the size of the item.\n    A bin with a remaining capacity that is just enough for the item and leaves some room for future items will have the highest priority.\n    A bin that is too small for the item will have a priority of negative infinity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # First, we identify bins that are too small for the item and give them a very low priority\n    priority = np.where(bins_remain_cap >= item, np.log(bins_remain_cap - item + 1), -np.inf)\n    \n    # Then, we add a penalty term to bins with very large remaining capacity to encourage tighter packing\n    priority = np.where(bins_remain_cap >= item, priority - 0.1 * (bins_remain_cap - item) / (bins_remain_cap + 1e-6), priority)\n    \n    # Return the priority scores\n    return priority\n\n[Heuristics 20th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is based on a non-linear function of the remaining capacity of the bin and the size of the item.\n    A bin with a remaining capacity that is just enough for the item and leaves some room for future items will have the highest priority.\n    A bin that is too small for the item will have a priority of negative infinity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # First, we identify bins that are too small for the item and give them a very low priority\n    priority = np.where(bins_remain_cap >= item, np.log(bins_remain_cap - item + 1), -np.inf)\n    \n    # Then, we add a penalty term to bins with very large remaining capacity to encourage tighter packing\n    priority = np.where(bins_remain_cap >= item, priority - 0.1 * (bins_remain_cap - item) / (bins_remain_cap + 1e-6), priority)\n    \n    # Return the priority scores\n    return priority\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}