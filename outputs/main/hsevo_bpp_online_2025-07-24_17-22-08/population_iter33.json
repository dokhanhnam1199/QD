[
  {
    "stdout_filepath": "problem_iter32_response0.txt_stdout.txt",
    "code_path": "problem_iter32_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with dynamic penalty term for balanced bin selection.\n    Balances tight fitting and future capacity using a nuanced formulation.\n    \"\"\"\n    # Non-linear prioritization for bins with sufficient capacity\n    priority = np.where(bins_remain_cap >= item, np.exp(-(bins_remain_cap - item)), -np.inf)\n    \n    # Refined penalty term to balance tight fitting and future capacity\n    valid_bins = priority != -np.inf\n    if np.any(valid_bins):\n        remain_cap_after_add = bins_remain_cap[valid_bins] - item\n        # Dynamic penalty term considering both remaining capacity and item size\n        balancing_term = 0.7 * np.exp(-remain_cap_after_add / (item + 1e-6)) + 0.3 * (remain_cap_after_add / (bins_remain_cap[valid_bins] + 1e-6))\n        priority[valid_bins] *= balancing_term\n        \n    # Normalize priority scores for enhanced adaptability\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:\n        priority = priority / max_priority\n    \n    return priority",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 85.95159310338741,
    "mi": 90.85451115409887,
    "token_count": 88.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter32_response1.txt_stdout.txt",
    "code_path": "problem_iter32_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with nuanced penalty terms to balance tight fitting and future capacity.\n    \"\"\"\n    # Identify valid bins\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    \n    # Calculate the remaining capacity after adding the item\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Combine non-linear prioritization with a nuanced penalty term for tight fitting and future capacity\n    priority = np.where(valid_bins == 1, \n                         np.exp(-remain_cap_after_add / (item + 1e-6)) +  # Non-linear prioritization for tight fit\n                         0.1 * ((remain_cap_after_add <= item / 2) + (remain_cap_after_add / (bins_remain_cap + 1e-6))),  # Nuanced penalty term\n                         -np.inf)\n    \n    return priority",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.058635819704831,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 85.95159310338741,
    "mi": 90.85451115409887,
    "token_count": 88.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter32_response2.txt_stdout.txt",
    "code_path": "problem_iter32_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a refined penalty term, balancing tight fit and future capacity.\n    \"\"\"\n    # Calculate valid bins and remaining capacity after adding the item\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Non-linear prioritization focusing on tight fit and future capacity\n    tight_fit_score = np.exp(-remain_cap_after_add / (item + 1e-6))\n    future_capacity_score = remain_cap_after_add / (bins_remain_cap + 1e-6)\n    \n    # Combine scores with a weighted average and apply a refined penalty term\n    priority = np.where(valid_bins == 1, \n                         0.7 * tight_fit_score + 0.3 * future_capacity_score, \n                         -np.inf)\n    penalty_term = np.exp(-remain_cap_after_add / item)\n    priority *= np.where(valid_bins == 1, penalty_term, 1)\n    \n    # Normalize priority scores for enhanced adaptability\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:\n        priority = priority / max_priority\n    \n    return priority",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 85.95159310338741,
    "mi": 90.85451115409887,
    "token_count": 88.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter32_response3.txt_stdout.txt",
    "code_path": "problem_iter32_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a refined penalty term for better bin selection.\n    Balances tight fitting and future capacity using a nuanced formulation.\n    \"\"\"\n    # Non-linear prioritization for bins with sufficient capacity, normalized by item size\n    priority = np.where(bins_remain_cap >= item, np.exp(-(bins_remain_cap - item) / item), -np.inf)\n    \n    # Refined penalty term to balance tight fitting and future capacity\n    valid_bins = priority != -np.inf\n    if np.any(valid_bins):\n        # Use a term that considers both remaining capacity and item size\n        balancing_term = 1 / (1 + np.abs(bins_remain_cap[valid_bins] - item))\n        priority[valid_bins] *= balancing_term * ((bins_remain_cap[valid_bins] - item) / bins_remain_cap[valid_bins])\n        \n    return priority",
    "response_id": 3,
    "tryHS": false,
    "obj": 6.102911846828884,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 85.95159310338741,
    "mi": 90.85451115409887,
    "token_count": 88.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter32_response4.txt_stdout.txt",
    "code_path": "problem_iter32_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a nuanced penalty term, \n    balancing tight fit and future capacity effectively.\n    \"\"\"\n    # Identify valid bins and calculate remaining capacity after adding the item\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Non-linear prioritization focusing on tight fit\n    tight_fit_score = np.exp(-remain_cap_after_add / (item + 1e-6))\n    \n    # Refined penalty term for future capacity and balancing\n    future_capacity_penalty = (1 / (1 + np.exp((remain_cap_after_add - item/2) / item)))\n    \n    # Combine scores for better adaptability\n    priority = np.where(valid_bins == 1, \n                         0.7 * tight_fit_score + 0.3 * future_capacity_penalty, \n                         -np.inf)\n    \n    # Normalize priority scores\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:\n        priority = priority / max_priority\n    \n    return priority",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 85.95159310338741,
    "mi": 90.85451115409887,
    "token_count": 88.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter32_response5.txt_stdout.txt",
    "code_path": "problem_iter32_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a refined penalty term, \n    balancing tight fit and future capacity using a weighted average.\n    \"\"\"\n    # Identify valid bins and calculate remaining capacity after adding the item\n    valid_bins = (bins_remain_cap >= item)\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Non-linear prioritization focusing on tight fit\n    tight_fit_score = np.exp(-remain_cap_after_add / item)\n    \n    # Refined penalty term to balance tight fitting and future capacity\n    penalty_term = np.where(remain_cap_after_add > 0, 1 / (1 + np.exp((remain_cap_after_add - item/2) / item)), 1)\n    \n    # Combine scores with a weighted average for better adaptability\n    priority = np.where(valid_bins, \n                         0.7 * tight_fit_score + 0.3 * penalty_term, \n                         -np.inf)\n    \n    # Normalize priority scores for enhanced adaptability\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:\n        priority = priority / max_priority\n    \n    return priority",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 85.95159310338741,
    "mi": 90.85451115409887,
    "token_count": 88.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter32_response6.txt_stdout.txt",
    "code_path": "problem_iter32_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with refined penalty terms for balancing tight fits and future capacity.\n    \"\"\"\n    # Calculate valid bins and remaining capacity after adding the item\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Non-linear prioritization focusing on tight fit\n    tight_fit_score = np.exp(-remain_cap_after_add / (item + 1e-6))\n    \n    # Refined penalty term to balance tight fitting and future capacity\n    future_capacity_score = remain_cap_after_add / (bins_remain_cap + 1e-6)\n    penalty_term = np.where(valid_bins == 1, future_capacity_score, 1)\n    \n    # Combine scores with a weighted product for better adaptability\n    priority = np.where(valid_bins == 1, tight_fit_score * penalty_term, -np.inf)\n    \n    # Normalize priority scores for enhanced adaptability\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:\n        priority = priority / max_priority\n    \n    return priority",
    "response_id": 6,
    "tryHS": false,
    "obj": 16.513761467889925,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 85.95159310338741,
    "mi": 90.85451115409887,
    "token_count": 88.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter32_response7.txt_stdout.txt",
    "code_path": "problem_iter32_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a refined penalty term for better bin selection.\n    Balances tight fitting and future capacity using a ratio-based penalty.\n    \"\"\"\n    # Identify valid bins and calculate the ratio of item size to remaining capacity\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    fit_ratio = item / bins_remain_cap\n    \n    # Non-linear prioritization for valid bins\n    priority = np.where(valid_bins == 1, 1 / (1 + np.abs(bins_remain_cap - item)), -np.inf)\n    \n    # Refined penalty term to encourage tight fits and leave capacity for future items\n    penalty_term = np.exp(-fit_ratio)  # Using fit_ratio for a simpler yet effective penalty\n    \n    # Combine prioritization and penalty term\n    priority *= penalty_term\n    \n    return priority",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 85.95159310338741,
    "mi": 90.85451115409887,
    "token_count": 88.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter32_response8.txt_stdout.txt",
    "code_path": "problem_iter32_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a refined penalty term for tighter fits and future capacity.\n    Balances complexity and effectiveness by normalizing priority scores.\n    \"\"\"\n    # Identify valid bins and calculate remaining capacity after adding the item\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Non-linear prioritization with a penalty for large remaining capacity\n    priority = np.where(valid_bins == 1, \n                         np.exp(-remain_cap_after_add / item),  # Non-linear prioritization\n                         -np.inf)\n    \n    # Refined penalty term to balance tight fitting and future capacity\n    penalty_term = np.where(remain_cap_after_add > 0, 1 / (1 + np.exp((remain_cap_after_add - item/2) / item)), 1)\n    priority *= penalty_term\n    \n    # Normalize priority scores for better adaptability\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:\n        priority = priority / max_priority\n    else:\n        priority = valid_bins - 1  # Assign a default priority when all bins are invalid\n    \n    return priority",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 85.95159310338741,
    "mi": 90.85451115409887,
    "token_count": 88.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter32_response9.txt_stdout.txt",
    "code_path": "problem_iter32_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a refined penalty term for tighter fits and future capacity.\n    \"\"\"\n    # Non-linear prioritization for valid bins and a refined penalty term to balance tight fitting and future capacity\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    fit_ratio = item / bins_remain_cap  # Higher ratio indicates tighter fit\n    penalty_term = np.exp(-(bins_remain_cap - item) / item)  # Non-linear prioritization\n    priority = np.where(valid_bins == 1, fit_ratio * penalty_term, -np.inf)  # Combine fit ratio and penalty term\n    \n    return priority",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 85.95159310338741,
    "mi": 90.85451115409887,
    "token_count": 88.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter33_response0.txt_stdout.txt",
    "code_path": "problem_iter33_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Enhanced priority function that combines non-linear prioritization with a dynamic penalty term,\n    adapting to both tight fits and future capacity needs, while introducing a 'look-ahead' aspect.\n    \"\"\"\n    # Identify valid bins and calculate remaining capacity after adding the item\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Non-linear prioritization with a refined penalty term for balancing tight fit and future capacity\n    # Introducing a dynamic penalty that adjusts based on the item size relative to the bin capacity\n    priority = np.where(valid_bins == 1, \n                         np.exp(-remain_cap_after_add / (item + 1e-6)) - 0.05 * (remain_cap_after_add / (bins_remain_cap + 1e-6)),  \n                         -np.inf)\n    \n    # Enhance differentiation among valid bins by applying a non-linear scaling\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:\n        priority = np.where(priority != -np.inf, (priority / max_priority) ** 2, -np.inf)  # Squaring to enhance differentiation\n    \n    return priority",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.068607897885915,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 195.04195997053841,
    "mi": 90.00438992755836,
    "token_count": 151.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter33_response1.txt_stdout.txt",
    "code_path": "problem_iter33_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Enhances the priority function by introducing a more nuanced non-linear prioritization \n    and a dynamic penalty term that adapts based on the item size and bin capacity.\n    \"\"\"\n    # Identify valid bins\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    \n    # Calculate remaining capacity after adding the item and its proportion to the item size\n    remain_cap_after_add = bins_remain_cap - item\n    proportion_remain = remain_cap_after_add / item\n    \n    # Non-linear prioritization with a dynamic penalty term that considers the relative remaining capacity\n    priority = np.where(valid_bins == 1, \n                         np.exp(-proportion_remain) - 0.05 * (proportion_remain ** 2),  # More nuanced penalty for larger remaining capacity relative to item size\n                         -np.inf)\n    \n    # Apply a bonus for bins with very tight fits to encourage efficient packing\n    tight_fit_bonus = np.where((remain_cap_after_add > 0) & (remain_cap_after_add < 0.1 * item), 0.1, 0)\n    priority += tight_fit_bonus\n    \n    # Normalize priority scores for adaptability, handling the case where all priorities are -inf\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:\n        priority = priority / max_priority\n    else:\n        priority = valid_bins - 1  # When all bins are invalid, return -1 for invalid bins\n    \n    return priority",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.3777423214998095,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 195.04195997053841,
    "mi": 90.00438992755836,
    "token_count": 151.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter33_response2.txt_stdout.txt",
    "code_path": "problem_iter33_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Enhances the priority function by introducing a dynamic penalty term that adjusts based on the item size relative to the bin capacity,\n    and incorporates a more nuanced non-linear prioritization that considers both the tightness of fit and the remaining capacity.\n    \"\"\"\n    # Calculate valid bins and remaining capacity after adding the item\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Dynamic penalty term based on item size relative to bin capacity\n    penalty_term = np.where(valid_bins == 1, \n                            1 - (item / bins_remain_cap),  # Encourages bins that are filled to a larger proportion\n                            -np.inf)\n    \n    # Enhanced non-linear prioritization with adjusted penalty for balancing tight fit and future capacity\n    priority = np.where(valid_bins == 1, \n                         np.exp(-remain_cap_after_add / (item + 1e-6)) * penalty_term,  # Adds a small value to avoid division by zero\n                         -np.inf)\n    \n    # Normalize priority scores for better adaptability and to ensure scores are within a comparable range\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:\n        priority = priority / max_priority\n    \n    return priority",
    "response_id": 2,
    "tryHS": false,
    "obj": 16.513761467889925,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 195.04195997053841,
    "mi": 90.00438992755836,
    "token_count": 151.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter33_response3.txt_stdout.txt",
    "code_path": "problem_iter33_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Enhances the priority function by introducing a more nuanced penalty term \n    that considers both the tightness of the fit and the remaining capacity in a non-linear fashion.\n    \"\"\"\n    # Identify valid bins\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    \n    # Calculate remaining capacity after adding the item and its proportion to the item size\n    remain_cap_after_add = bins_remain_cap - item\n    proportion_remain = remain_cap_after_add / item\n    \n    # Introduce a non-linear penalty term that decreases as the remaining capacity approaches zero\n    # and increases as the remaining capacity becomes larger, but with diminishing returns\n    penalty_term = -np.log1p(proportion_remain)  # Using log1p to avoid division by zero and to introduce non-linearity\n    \n    # Assign -inf priority to invalid bins\n    priority = np.where(valid_bins == 1, penalty_term, -np.inf)\n    \n    # Normalize priority scores to ensure they are within a comparable range\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:\n        priority = priority / max_priority\n    \n    return priority",
    "response_id": 3,
    "tryHS": false,
    "obj": 86.58755484643,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 195.04195997053841,
    "mi": 90.00438992755836,
    "token_count": 151.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter33_response4.txt_stdout.txt",
    "code_path": "problem_iter33_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Enhanced priority function that balances tight fit, future capacity, and bin utilization.\n    \"\"\"\n    # Identify valid bins and calculate remaining capacity after adding the item\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Calculate the ratio of item size to bin remaining capacity for a tight fit measure\n    tight_fit_measure = item / bins_remain_cap\n    \n    # Non-linear prioritization with a refined penalty term for balancing tight fit and future capacity\n    priority = np.where(valid_bins == 1, \n                         np.exp(-remain_cap_after_add / item) * (1 + tight_fit_measure) - 0.01 * remain_cap_after_add,  \n                         -np.inf)\n    \n    # Normalize priority scores for better adaptability and robustness\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:\n        priority = priority / max_priority\n    \n    # Introduce a slight perturbation to avoid identical priorities for different bins\n    priority += np.random.uniform(0, 1e-6, size=len(priority))\n    \n    return priority",
    "response_id": 4,
    "tryHS": false,
    "obj": 3.9090546469884373,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 195.04195997053841,
    "mi": 90.00438992755836,
    "token_count": 151.0,
    "exec_success": true
  }
]