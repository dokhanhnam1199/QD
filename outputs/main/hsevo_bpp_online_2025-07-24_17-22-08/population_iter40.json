[
  {
    "stdout_filepath": "problem_iter38_response0.txt_stdout.txt",
    "code_path": "problem_iter38_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, \n                alpha: float = 0.7, beta: float = 0.3, \n                penalty_weight: float = 0.015962034932029284, \n                perturbation_max: float = 8.082068759055226e-06) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with adaptive penalty terms and \n    nuanced balancing of tight fit and future capacity for online bin packing.\n    \"\"\"\n    # Identify valid bins and calculate remaining capacity after adding the item\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Non-linear prioritization focusing on tight fit and future capacity\n    tight_fit_score = np.exp(-remain_cap_after_add / (item + 1e-6))\n    tight_fit_measure = item / bins_remain_cap\n    \n    # Combine scores with adaptive weighting and apply a refined penalty term\n    priority = np.where(valid_bins == 1, \n                         alpha * tight_fit_score + beta * tight_fit_measure - penalty_weight * remain_cap_after_add, \n                         -np.inf)\n    \n    # Normalize priority scores for better adaptability and robustness\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:\n        priority = priority / max_priority\n    \n    # Introduce a slight perturbation to avoid identical priorities for different bins\n    priority += np.random.uniform(0, perturbation_max, size=len(priority))\n    \n    return priority",
    "response_id": 0,
    "tryHS": false,
    "obj": 3.8990825688073536,
    "SLOC": 19.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 328.19556203462383,
    "mi": 85.08564089613361,
    "token_count": 208.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter38_response1.txt_stdout.txt",
    "code_path": "problem_iter38_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a dynamic penalty term and slight perturbation,\n    balancing tight fit and future capacity effectively.\n    \"\"\"\n    # Identify valid bins and calculate remaining capacity after adding the item\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Non-linear prioritization focusing on tight fit\n    tight_fit_score = np.exp(-remain_cap_after_add / (item + 1e-6))\n    \n    # Dynamic penalty term for future capacity\n    future_capacity_penalty = 1 - (remain_cap_after_add / (bins_remain_cap + 1e-6))\n    \n    # Combine scores for better adaptability\n    priority = np.where(valid_bins == 1, \n                         0.7 * tight_fit_score + 0.3 * future_capacity_penalty, \n                         -np.inf)\n    \n    # Enhance differentiation among valid bins by applying a non-linear scaling\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:\n        priority = np.where(priority != -np.inf, (priority / max_priority) ** 1.5, -np.inf)\n    \n    # Introduce slight perturbation to avoid identical priorities\n    priority += np.random.uniform(0, 1e-5, size=len(priority))\n    \n    return priority",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 19.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 328.19556203462383,
    "mi": 85.08564089613361,
    "token_count": 208.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter38_response2.txt_stdout.txt",
    "code_path": "problem_iter38_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, \n                penalty_weight: float = 0.015962034932029284, \n                perturbation_max: float = 8.082068759055226e-06) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with nuanced penalty terms and effective balancing,\n    enhancing adaptability and robustness for online bin packing.\n    \"\"\"\n    # Identify valid bins and calculate remaining capacity after adding the item\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Non-linear prioritization focusing on tight fit\n    tight_fit_score = np.exp(-remain_cap_after_add / (item + 1e-6))\n    tight_fit_measure = item / bins_remain_cap\n    \n    # Refined penalty term for future capacity and balancing\n    future_capacity_penalty = (1 / (1 + np.exp((remain_cap_after_add - item/2) / item)))\n    \n    # Combine scores with a weighted average, refined penalty term, \n    # and tight fit measure for enhanced prioritization and robustness\n    priority = np.where(valid_bins == 1, \n                         0.7 * tight_fit_score * (1 + tight_fit_measure) + 0.3 * future_capacity_penalty - penalty_weight * remain_cap_after_add, \n                         -np.inf)\n    \n    # Normalize priority scores for better adaptability\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:\n        priority = priority / max_priority\n    \n    # Introduce a slight perturbation to avoid identical priorities for different bins\n    priority += np.random.uniform(0, perturbation_max, size=len(priority))\n    \n    return priority",
    "response_id": 2,
    "tryHS": true,
    "obj": 3.8591942560829726,
    "SLOC": 19.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 328.19556203462383,
    "mi": 85.08564089613361,
    "token_count": 208.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter38_response3.txt_stdout.txt",
    "code_path": "problem_iter38_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a dynamic penalty term and refined future capacity score.\n    Balances tight fitting and future capacity effectively.\n    \"\"\"\n    # Identify valid bins and calculate remaining capacity after adding the item\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Non-linear prioritization for valid bins with a penalty term for tight fits\n    tight_fit_score = np.exp(-remain_cap_after_add / (item + 1e-6))\n    \n    # Refined penalty term for future capacity\n    future_capacity_score = remain_cap_after_add / (bins_remain_cap + 1e-6)\n    penalty_term = np.where(valid_bins == 1, future_capacity_score, 1)\n    \n    # Combine prioritization and penalty term with balancing\n    priority = np.where(valid_bins == 1, \n                         0.6 * tight_fit_score * penalty_term + 0.4 * (1 / (1 + np.abs(bins_remain_cap - item))), \n                         -np.inf)\n    \n    # Normalize priority scores\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:\n        priority = priority / max_priority\n    \n    return priority",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.307937774232155,
    "SLOC": 19.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 328.19556203462383,
    "mi": 85.08564089613361,
    "token_count": 208.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter38_response4.txt_stdout.txt",
    "code_path": "problem_iter38_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a dynamic penalty term, \n    balancing tight fit and future capacity effectively with slight perturbation.\n    \"\"\"\n    # Identify valid bins\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    \n    # Non-linear prioritization focusing on tight fit\n    tight_fit_score = np.exp(-(bins_remain_cap - item) / (item + 1e-6))\n    \n    # Dynamic penalty term for future capacity\n    future_capacity_penalty = np.where(bins_remain_cap - item > 0, \n                                       (bins_remain_cap - item) / bins_remain_cap, \n                                       0)\n    \n    # Combine scores for better adaptability with refined penalty term\n    priority = np.where(valid_bins == 1, \n                         0.7 * tight_fit_score + 0.3 * (1 - future_capacity_penalty) - 0.01 * (bins_remain_cap - item), \n                         -np.inf)\n    \n    # Enhance differentiation among valid bins by normalization\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:\n        priority = priority / max_priority\n    \n    # Introduce slight perturbation for better exploration\n    priority += np.random.uniform(0, 1e-5, size=len(priority))\n    \n    return priority",
    "response_id": 4,
    "tryHS": false,
    "obj": 3.9688871160749857,
    "SLOC": 19.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 328.19556203462383,
    "mi": 85.08564089613361,
    "token_count": 208.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter38_response5.txt_stdout.txt",
    "code_path": "problem_iter38_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with adaptive penalty terms and slight perturbation for effective bin selection.\n    Balances tight fit and future capacity using a ratio-based penalty and exponential decay.\n    \"\"\"\n    # Identify valid bins and calculate remaining capacity after adding the item\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Non-linear prioritization for valid bins with a penalty term for tight fits\n    tight_fit_measure = np.exp(-(bins_remain_cap - item) / item)\n    priority = np.where(valid_bins == 1, tight_fit_measure, -np.inf)\n    \n    # Dynamic penalty term based on the proportion of remaining capacity\n    penalty_term = np.exp(-remain_cap_after_add / (item + 1e-6))  # Avoids division by zero\n    \n    # Combine prioritization and penalty term with adaptive weighting\n    alpha = 0.7  # Weight for tight fit measure\n    beta = 0.3   # Weight for penalty term\n    priority = np.where(valid_bins == 1, alpha * priority - beta * (1 - penalty_term), -np.inf)\n    \n    # Normalize priority scores for better adaptability\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:\n        priority = priority / max_priority\n    \n    # Introduce a slight perturbation to break ties\n    perturbation_max = 1e-5\n    priority += np.random.uniform(0, perturbation_max, size=len(priority))\n    \n    return priority",
    "response_id": 5,
    "tryHS": false,
    "obj": 3.948942959712818,
    "SLOC": 19.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 328.19556203462383,
    "mi": 85.08564089613361,
    "token_count": 208.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter38_response6.txt_stdout.txt",
    "code_path": "problem_iter38_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, \n                alpha: float = 0.7, beta: float = 0.3, \n                penalty_weight: float = 0.01, \n                perturbation_max: float = 1e-5) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with nuanced penalty terms and adaptive balancing.\n    \"\"\"\n    # Identify valid bins and calculate remaining capacity after adding the item\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Calculate tight fit measure and future capacity penalty\n    tight_fit_measure = np.exp(-remain_cap_after_add / item)\n    future_capacity_penalty = np.where(remain_cap_after_add > 0, \n                                       remain_cap_after_add / bins_remain_cap, \n                                       0)\n    # Non-linear penalty term inspired by priority_v1\n    penalty_term = -np.log1p(remain_cap_after_add / item)\n    \n    # Combine non-linear prioritization with nuanced penalty terms and adaptive balancing\n    priority = np.where(valid_bins == 1, \n                         alpha * tight_fit_measure + beta * (1 - future_capacity_penalty) + penalty_weight * penalty_term, \n                         -np.inf)\n    \n    # Normalize priority scores for adaptability\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:\n        priority = priority / max_priority\n    \n    # Introduce slight perturbation\n    priority += np.random.uniform(0, perturbation_max, size=len(priority))\n    \n    return priority",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 19.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 328.19556203462383,
    "mi": 85.08564089613361,
    "token_count": 208.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter38_response7.txt_stdout.txt",
    "code_path": "problem_iter38_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a refined penalty term and a balancing term.\n    Balances tight fitting and future capacity for effective bin packing.\n    \"\"\"\n    # Identify valid bins and calculate remaining capacity after adding the item\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Non-linear prioritization with a dynamic penalty term\n    proportion_remain = remain_cap_after_add / item\n    priority = np.where(valid_bins == 1, np.exp(-proportion_remain), -np.inf)\n    \n    # Refined penalty term to balance tight fitting and future capacity\n    valid_bins_idx = np.where(valid_bins == 1)[0]\n    if len(valid_bins_idx) > 0:\n        balancing_term = 1 / (1 + np.abs(bins_remain_cap[valid_bins_idx] - item))\n        priority[valid_bins_idx] *= balancing_term\n    \n    # Normalize priority scores for adaptability\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:\n        priority = priority / max_priority\n    \n    # Introduce slight perturbation based on future capacity penalty\n    future_capacity_penalty = np.where(bins_remain_cap - item > 0, \n                                        (bins_remain_cap - item) / bins_remain_cap, \n                                        1)\n    perturbation = 0.01 * (1 - future_capacity_penalty)  # Scaled perturbation\n    priority += perturbation\n    \n    return priority",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 19.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 328.19556203462383,
    "mi": 85.08564089613361,
    "token_count": 208.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter38_response8.txt_stdout.txt",
    "code_path": "problem_iter38_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with nuanced penalty terms and a tight fit bonus.\n    Balances tight fitting and future capacity for effective bin packing.\n    \"\"\"\n    # Identify valid bins and calculate remaining capacity after adding the item\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Non-linear prioritization with a dynamic penalty term\n    proportion_remain = remain_cap_after_add / item\n    tight_fit_measure = item / bins_remain_cap\n    priority = np.where(valid_bins == 1, np.exp(-proportion_remain) * (1 + tight_fit_measure), -np.inf)\n    \n    # Refined penalty term to balance tight fitting and future capacity\n    valid_bins_idx = np.where(valid_bins == 1)[0]\n    if len(valid_bins_idx) > 0:\n        balancing_term = 1 / (1 + np.abs(bins_remain_cap[valid_bins_idx] - item))\n        priority[valid_bins_idx] *= balancing_term\n        \n    # Apply a bonus for bins with very tight fits to encourage efficient packing\n    tight_fit_bonus = np.where((remain_cap_after_add > 0) & (remain_cap_after_add < 0.1 * item), 0.1, 0)\n    priority += tight_fit_bonus\n    \n    # Normalize priority scores and introduce slight perturbation\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:\n        priority = priority / max_priority\n    priority += np.random.uniform(0, 1e-5, size=len(priority))\n    \n    return priority",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 19.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 328.19556203462383,
    "mi": 85.08564089613361,
    "token_count": 208.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter38_response9.txt_stdout.txt",
    "code_path": "problem_iter38_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a refined penalty term and \n    tight fit measure for enhanced online bin packing.\n    \"\"\"\n    # Calculate valid bins and remaining capacity after adding the item\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Non-linear prioritization focusing on tight fit and future capacity\n    tight_fit_score = np.exp(-remain_cap_after_add / (item + 1e-6))\n    tight_fit_measure = item / bins_remain_cap\n    future_capacity_penalty = np.where(remain_cap_after_add > 0, \n                                        remain_cap_after_add / bins_remain_cap, \n                                        1)\n    \n    # Combine scores with a weighted average and apply a refined penalty term\n    alpha, beta, gamma = 0.6, 0.2, 0.2  # weights for tight_fit_score, tight_fit_measure, and future_capacity_penalty\n    penalty_weight = 0.015  # penalty weight for remaining capacity\n    priority = np.where(valid_bins == 1, \n                         alpha * tight_fit_score + beta * tight_fit_measure + gamma * (1 - future_capacity_penalty) - penalty_weight * remain_cap_after_add, \n                         -np.inf)\n    \n    # Normalize priority scores for better adaptability\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:\n        priority = priority / max_priority\n    \n    # Introduce a slight perturbation to avoid identical priorities\n    perturbation_max = 1e-5\n    priority += np.random.uniform(0, perturbation_max, size=len(priority))\n    \n    return priority",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.427602712405275,
    "SLOC": 19.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 328.19556203462383,
    "mi": 85.08564089613361,
    "token_count": 208.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter39_response0.txt_stdout.txt",
    "code_path": "problem_iter39_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, \n                tight_fit_weight: float = 0.7, \n                capacity_utilization_weight: float = 0.3, \n                valid_bin_threshold: float = 0.0, \n                epsilon: float = 1e-6) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization focusing on tight fit and capacity utilization, \n    with a refined penalty term for better adaptability and robustness.\n    \"\"\"\n    # Identify valid bins\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    \n    # Calculate remaining capacity after adding the item\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Non-linear prioritization focusing on tight fit\n    tight_fit_score = np.exp(-remain_cap_after_add / (item + epsilon))\n    \n    # Capacity utilization score\n    capacity_utilization_score = bins_remain_cap / (bins_remain_cap - remain_cap_after_add + epsilon)\n    \n    # Combine scores with weights\n    priority = np.where(valid_bins == 1, \n                         tight_fit_weight * tight_fit_score + capacity_utilization_weight * capacity_utilization_score, \n                         -np.inf)\n    \n    # Introduce a slight perturbation to avoid identical priorities for different bins\n    priority += np.random.uniform(0, 1e-6, size=len(priority))\n    \n    return priority",
    "response_id": 0,
    "tryHS": false,
    "obj": 49.391703230953325,
    "SLOC": 17.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 216.33097149259217,
    "mi": 88.75345790849913,
    "token_count": 187.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter39_response1.txt_stdout.txt",
    "code_path": "problem_iter39_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, \n                tight_fit_weight: float = 0.7, \n                future_capacity_weight: float = 0.3, \n                valid_bin_threshold: float = 0.0, \n                epsilon: float = 1e-6) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with nuanced penalty terms, \n    focusing on tight fit and future capacity with simplified and effective balancing.\n    \"\"\"\n    # Identify valid bins\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    \n    # Calculate remaining capacity after adding the item\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Tight fit score with non-linear prioritization\n    tight_fit_score = np.exp(-remain_cap_after_add / (item + epsilon))\n    \n    # Future capacity penalty term\n    future_capacity_penalty = 1 / (1 + np.exp(remain_cap_after_add / (item + epsilon)))\n    \n    # Combine scores with effective balancing\n    priority = np.where(valid_bins == 1, \n                         tight_fit_weight * tight_fit_score + future_capacity_weight * future_capacity_penalty, \n                         -np.inf)\n    \n    # Introduce a slight perturbation to avoid identical priorities for different bins\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:\n        priority = priority / max_priority\n        priority += np.random.uniform(0, 1e-6, size=len(priority))\n    \n    return priority",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 17.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 216.33097149259217,
    "mi": 88.75345790849913,
    "token_count": 187.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter39_response2.txt_stdout.txt",
    "code_path": "problem_iter39_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, \n                tight_fit_weight: float = 0.75, \n                future_capacity_weight: float = 0.25, \n                valid_bin_threshold: float = 0.1,\n                epsilon: float = 1e-6) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with nuanced penalty terms, \n    focusing on tight fit and future capacity with simplified and effective balancing.\n    \"\"\"\n    # Identify valid bins\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    \n    # Calculate remaining capacity after adding the item\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Tight fit score with non-linear prioritization\n    tight_fit_score = np.exp(-remain_cap_after_add / (item + epsilon))\n    \n    # Future capacity penalty term\n    future_capacity_penalty = 1 / (1 + np.exp(remain_cap_after_add / (item + epsilon)))\n    \n    # Combine scores with effective balancing\n    priority = np.where(valid_bins == 1, \n                         tight_fit_weight * tight_fit_score + future_capacity_weight * future_capacity_penalty, \n                         -np.inf)\n    \n    # Introduce a slight perturbation to avoid identical priorities for different bins\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:\n        priority = priority / max_priority\n        priority += np.random.uniform(0, 1e-6, size=len(priority))\n    \n    return priority",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 17.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 216.33097149259217,
    "mi": 88.75345790849913,
    "token_count": 187.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter39_response3.txt_stdout.txt",
    "code_path": "problem_iter39_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, \n                tight_fit_weight: float = 0.8, \n                future_capacity_weight: float = 0.2, \n                valid_bin_threshold: float = 0.0, \n                epsilon: float = 1e-6) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with refined penalty terms, \n    focusing on tight fit and future capacity with simplified and effective balancing.\n    \"\"\"\n    # Identify valid bins\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    \n    # Calculate remaining capacity after adding the item\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Non-linear prioritization focusing on tight fit\n    tight_fit_score = np.exp(-remain_cap_after_add / (item + epsilon))\n    \n    # Refined penalty term for future capacity\n    future_capacity_penalty = 1 / (1 + remain_cap_after_add / (bins_remain_cap + epsilon))\n    \n    # Combine scores with effective balancing\n    priority = np.where(valid_bins == 1, \n                         tight_fit_weight * tight_fit_score + future_capacity_weight * future_capacity_penalty, \n                         -np.inf)\n    \n    # Introduce a slight perturbation to avoid identical priorities for different bins\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:\n        priority = priority / max_priority\n        priority += np.random.uniform(0, 1e-6, size=len(priority))\n    \n    return priority",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 17.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 216.33097149259217,
    "mi": 88.75345790849913,
    "token_count": 187.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter39_response4.txt_stdout.txt",
    "code_path": "problem_iter39_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, \n                tight_fit_weight: float = 0.7, \n                capacity_utilization_weight: float = 0.3, \n                valid_bin_threshold: float = 0.0, \n                epsilon: float = 1e-6) -> np.ndarray:\n    \"\"\"\n    Combines tight fit and capacity utilization scores with a simple yet effective prioritization strategy.\n    \"\"\"\n    # Identify valid bins\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    \n    # Calculate tight fit score\n    remain_cap_after_add = bins_remain_cap - item\n    tight_fit_score = np.exp(-remain_cap_after_add / (item + epsilon))\n    \n    # Calculate capacity utilization score\n    capacity_utilization_score = (bins_remain_cap - remain_cap_after_add) / bins_remain_cap\n    \n    # Combine scores\n    priority = np.where(valid_bins == 1, \n                         tight_fit_weight * tight_fit_score + capacity_utilization_weight * capacity_utilization_score, \n                         -np.inf)\n    \n    # Introduce a slight perturbation to avoid identical priorities for different bins\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:\n        priority = priority / max_priority\n    priority += np.random.uniform(0, 1e-6, size=len(priority))\n    \n    return priority",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 17.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 216.33097149259217,
    "mi": 88.75345790849913,
    "token_count": 187.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter40_response4.txt_stdout.txt",
    "code_path": "problem_iter40_code4.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, \n                penalty_weight: float = 0.027163347269421368, \n                perturbation_max: float = 5.5517955017442356e-05,\n                tight_fit_weight: float = 0.8982553269399638,\n                future_capacity_weight: float = 0.2999513969921509,\n                tight_fit_measure_scale: float = 1.8076179606943756,\n                future_capacity_penalty_shift: float = 0.3035068248124924,\n                epsilon: float = 4.339477087485159e-05) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with nuanced penalty terms and effective balancing,\n    enhancing adaptability and robustness for online bin packing.\n    \"\"\"\n    # Identify valid bins and calculate remaining capacity after adding the item\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Non-linear prioritization focusing on tight fit\n    tight_fit_score = np.exp(-remain_cap_after_add / (item + epsilon))\n    tight_fit_measure = item / bins_remain_cap\n    \n    # Refined penalty term for future capacity and balancing\n    future_capacity_penalty = (1 / (1 + np.exp((remain_cap_after_add - item*future_capacity_penalty_shift) / item)))\n    \n    # Combine scores with a weighted average, refined penalty term, \n    # and tight fit measure for enhanced prioritization and robustness\n    priority = np.where(valid_bins == 1, \n                         tight_fit_weight * tight_fit_score * (1 + tight_fit_measure*tight_fit_measure_scale) + future_capacity_weight * future_capacity_penalty - penalty_weight * remain_cap_after_add, \n                         -np.inf)\n    \n    # Normalize priority scores for better adaptability\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:\n        priority = priority / max_priority\n    \n    # Introduce a slight perturbation to avoid identical priorities for different bins\n    priority += np.random.uniform(0, perturbation_max, size=len(priority))\n    \n    return priority",
    "response_id": 4,
    "tryHS": true,
    "obj": 3.8591942560829726,
    "SLOC": 21.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 383.1788228318901,
    "mi": 86.50827871114633,
    "token_count": 246.0,
    "exec_success": true
  }
]