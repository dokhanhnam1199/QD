{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Combines non-linear prioritization with a trade-off between tight fit and future capacity.\n    Prioritizes bins with enough capacity and smaller remaining capacity after addition.\n    \"\"\"\n    # Calculate priority scores using a non-linear function that balances tight fit and remaining capacity\n    priority_scores = np.where(bins_remain_cap >= item, 1 / (bins_remain_cap - item + 1e-6), -1.0)\n    \n    # Normalize priority scores to ensure a better distribution\n    valid_bins = priority_scores != -1.0\n    if np.any(valid_bins):\n        max_score = np.max(priority_scores[valid_bins])\n        min_score = np.min(priority_scores[valid_bins])\n        priority_scores[valid_bins] = (priority_scores[valid_bins] - min_score) / (max_score - min_score + 1e-6)\n        \n    return priority_scores\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is based on a non-linear function of the remaining capacity of the bin and the size of the item.\n    A bin with a remaining capacity that is just enough for the item and leaves some room for future items will have the highest priority.\n    A bin that is too small for the item will have a priority of negative infinity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # First, we identify bins that are too small for the item and give them a very low priority\n    priority = np.where(bins_remain_cap >= item, np.log(bins_remain_cap - item + 1), -np.inf)\n    \n    # Then, we add a penalty term to bins with very large remaining capacity to encourage tighter packing\n    priority = np.where(bins_remain_cap >= item, priority - 0.1 * (bins_remain_cap - item) / (bins_remain_cap + 1e-6), priority)\n    \n    # Return the priority scores\n    return priority\n\n### Analyze & experience\n- Comparing the best heuristic (1st) with the worst (20th), we see that the top heuristic uses a simple, normalized priority score based on the remaining capacity, while the worst uses a logarithmic function with a penalty term. \nComparing (1st) vs (2nd), we see that both use non-linear functions, but the 1st normalizes the priority scores directly, whereas the 2nd normalizes after applying a reciprocal function. \n(3rd) vs (4th) shows that both combine elements of best-fit and tight-fitting heuristics, but the 3rd weighs priority scores by remaining capacity, whereas the 4th uses a non-linear function with an additional term for future items. \nComparing (second worst) vs (worst), we see that they are almost identical, using a logarithmic function with a penalty term. \nOverall, top heuristics tend to use simpler, more direct normalization and non-linear functions, while worse heuristics often introduce additional complexity or penalty terms.\n- \nTo redesign 'Current self-reflection' and come up with ideas to design better heuristics while avoiding 'Ineffective self-reflection', let's first analyze the given inputs.\n\n### Analysis\n\n- **Current self-reflection** suggests focusing on simple, normalized priority scores and non-linear functions that balance between tight fitting and future capacity, avoiding unnecessary complexity and penalty terms.\n- **Ineffective self-reflection** advises using simple, intuitive logic targeting the problem's objective directly, like minimizing waste. It suggests using non-linear functions to prioritize bins based on remaining capacity and considering the trade-off between tight fitting and future capacity, avoiding unnecessary normalization.\n\n### Redefining 'Current self-reflection'\n\nBy synthesizing insights from both, we can redefine 'Current self-reflection' to be more effective.\n\n### Response\n\nHere are the key points in 4 bullet points (<100 words):\n* **Keywords**: Simple logic, non-linear functions, balance, intuitive.\n* **Advice**: Use non-linear functions to balance tight fitting and future capacity; directly target the problem's objective.\n* **Avoid**: Unnecessary complexity, penalty terms, and normalization unless significantly impactful.\n* **Explanation**: By combining simplicity with non-linear prioritization, heuristics can effectively minimize waste and optimize bin usage, directly addressing the problem's objectives without unnecessary complications.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}