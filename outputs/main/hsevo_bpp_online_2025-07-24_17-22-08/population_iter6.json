[
  {
    "stdout_filepath": "problem_iter5_response0.txt_stdout.txt",
    "code_path": "problem_iter5_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines elements of priority_v0 and priority_v1. \n    Prioritizes bins that have just enough remaining capacity to hold the item using a non-linear function.\n    \"\"\"\n    # Check if the item can fit in each bin\n    valid_bins = bins_remain_cap >= item\n    \n    # Calculate the remaining capacity after adding the item for valid bins\n    remaining_capacity_after_addition = bins_remain_cap - item\n    \n    # Prioritize bins based on remaining capacity after addition using a non-linear function\n    priority_scores = np.where(valid_bins, np.exp(-remaining_capacity_after_addition), 0)\n    \n    return priority_scores",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 20.67970000576925,
    "mi": 86.80643539003533,
    "token_count": 67.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response1.txt_stdout.txt",
    "code_path": "problem_iter5_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Priority score for each bin based on a non-linear function of remaining capacity after adding the item.\n    Combines elements of priority_v0 and avoids unnecessary normalization.\n    \"\"\"\n    # Check if item fits and calculate remaining capacity after addition\n    valid_bins = (bins_remain_cap >= item).astype(float)  \n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Use a non-linear function to prioritize bins with remaining capacity closest to zero\n    priority = np.where(valid_bins == 1, np.exp(-remaining_cap_after_addition / bins_remain_cap), 0)\n    \n    return priority",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 20.67970000576925,
    "mi": 86.80643539003533,
    "token_count": 67.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response2.txt_stdout.txt",
    "code_path": "problem_iter5_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority score for each bin. \n    Combines the benefits of both best-fit and tight-fitting heuristics.\n    \"\"\"\n    # Identify bins that are too small for the item and give them a very low priority\n    # Use a non-linear function (1 / (1 + abs)) to prioritize bins with remaining capacity closest to the item size\n    priority = np.where(bins_remain_cap >= item, 1 / (1 + np.abs(bins_remain_cap - item)), -np.inf)\n    \n    # Normalize the priority scores by the remaining capacity to encourage tight-fitting\n    valid_bins = priority != -np.inf\n    if np.any(valid_bins):\n        # Weigh the priority scores by the remaining capacity after addition\n        priority[valid_bins] *= (1 - (bins_remain_cap[valid_bins] - item) / bins_remain_cap[valid_bins])\n    \n    return priority",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 20.67970000576925,
    "mi": 86.80643539003533,
    "token_count": 67.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response3.txt_stdout.txt",
    "code_path": "problem_iter5_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority score for each bin. \n    Prioritizes bins with remaining capacity closest to the item size using a non-linear function.\n    \"\"\"\n    # Identify bins that are too small for the item and give them a very low priority\n    priority = np.where(bins_remain_cap >= item, np.exp(-(bins_remain_cap - item)), -np.inf)\n    \n    # Return the priority scores\n    return priority",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 20.67970000576925,
    "mi": 86.80643539003533,
    "token_count": 67.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response4.txt_stdout.txt",
    "code_path": "problem_iter5_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Priority score based on negative remaining capacity after adding item and \n    a bonus for bins with more remaining capacity to balance tight fit and future capacity.\n    \"\"\"\n    # Calculate priority score as negative of remaining capacity after adding item\n    priority = np.where(bins_remain_cap >= item, -(bins_remain_cap - item), -np.inf)\n    \n    # Add a bonus to bins with more remaining capacity to balance tight fit and future capacity\n    priority = np.where(priority > -np.inf, priority + 1e-3 * np.exp(bins_remain_cap / (item + 1e-6)), priority)\n    \n    return priority",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.238133226964499,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 20.67970000576925,
    "mi": 86.80643539003533,
    "token_count": 67.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response5.txt_stdout.txt",
    "code_path": "problem_iter5_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority score for each bin. \n    Combines reciprocal function with remaining capacity check for effective bin prioritization.\n    \"\"\"\n    # Check if item can fit into each bin\n    can_fit = bins_remain_cap >= item\n    \n    # Calculate remaining capacity after adding the item\n    remaining_cap_after_add = bins_remain_cap - item\n    \n    # Priority is a combination of reciprocal function and remaining capacity check\n    epsilon = 1e-6\n    priority = np.where(can_fit, 1 / (epsilon + remaining_cap_after_add), -1)\n    \n    # Introduce a non-linear component to prioritize bins with remaining capacity closer to zero\n    priority[can_fit] = np.exp(-remaining_cap_after_add[can_fit]) * priority[can_fit]\n    \n    # Normalize priority scores to be between 0 and 1 for bins that can hold the item\n    valid_priority = priority[can_fit]\n    if len(valid_priority) > 0:\n        max_priority = np.max(valid_priority)\n        min_priority = np.min(valid_priority)\n        if max_priority != min_priority:\n            valid_priority = (valid_priority - min_priority) / (max_priority - min_priority)\n        else:\n            valid_priority = np.ones_like(valid_priority)\n        priority[can_fit] = valid_priority\n    \n    return priority",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 20.67970000576925,
    "mi": 86.80643539003533,
    "token_count": 67.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response6.txt_stdout.txt",
    "code_path": "problem_iter5_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines elements of minimizing remaining capacity and using a non-linear function.\n    Prioritizes bins with remaining capacity closer to the item size using a reciprocal function.\n    \"\"\"\n    # Calculate priority score as the reciprocal of the remaining capacity after adding the item\n    priority = np.where(bins_remain_cap >= item, 1 / (bins_remain_cap - item + 1), 0)\n    \n    return priority",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 20.67970000576925,
    "mi": 86.80643539003533,
    "token_count": 67.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response7.txt_stdout.txt",
    "code_path": "problem_iter5_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines elements of minimizing remaining capacity and using a non-linear function.\n    Prioritizes bins with remaining capacity closer to the item size using a reciprocal function.\n    \"\"\"\n    # Calculate priority score using a reciprocal function for valid bins\n    priority = np.where(bins_remain_cap >= item, 1 / (bins_remain_cap - item + 1), -np.inf)\n    \n    # Normalize the priority scores to be between 0 and 1 for valid bins\n    valid_bins = priority > -np.inf\n    if np.any(valid_bins):\n        min_priority = np.min(priority[valid_bins])\n        max_priority = np.max(priority[valid_bins])\n        priority = np.where(valid_bins, (priority - min_priority) / (max_priority - min_priority), 0)\n    \n    return priority",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 20.67970000576925,
    "mi": 86.80643539003533,
    "token_count": 67.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response8.txt_stdout.txt",
    "code_path": "problem_iter5_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a trade-off between tight fit and future capacity.\n    Prioritizes bins with enough capacity and smaller remaining capacity after addition.\n    \"\"\"\n    # Calculate priority scores using a non-linear function that balances tight fit and remaining capacity\n    priority_scores = np.where(bins_remain_cap >= item, 1 / (bins_remain_cap - item + 1e-6), -1.0)\n    \n    # Normalize priority scores to ensure a better distribution\n    valid_bins = priority_scores != -1.0\n    if np.any(valid_bins):\n        max_score = np.max(priority_scores[valid_bins])\n        min_score = np.min(priority_scores[valid_bins])\n        priority_scores[valid_bins] = (priority_scores[valid_bins] - min_score) / (max_score - min_score + 1e-6)\n        \n    return priority_scores",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 20.67970000576925,
    "mi": 86.80643539003533,
    "token_count": 67.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response9.txt_stdout.txt",
    "code_path": "problem_iter5_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority score for each bin. \n    Prioritizes bins with remaining capacity closest to the item size using a non-linear function.\n    \"\"\"\n    # Check if the item can fit in each bin\n    valid_bins = bins_remain_cap >= item  \n    \n    # Calculate the priority score for each valid bin based on the remaining capacity and item size\n    # Using a non-linear function (exponential) to prioritize bins with remaining capacity closer to the item size\n    priority_scores = np.where(valid_bins, np.exp(-np.abs(bins_remain_cap - item)), 0)\n    \n    return priority_scores",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 20.67970000576925,
    "mi": 86.80643539003533,
    "token_count": 67.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response0.txt_stdout.txt",
    "code_path": "problem_iter6_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is based on a non-linear function of the remaining capacity of the bin and the size of the item.\n    It balances the trade-off between packing items tightly and leaving room for future items.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Identify bins that are too small for the item and give them a very low priority\n    priority = np.where(bins_remain_cap >= item, \n                        # Use a non-linear function to balance tight packing and room for future items\n                        -((bins_remain_cap - item) / bins_remain_cap) ** 2 + (1 - item / bins_remain_cap), \n                        -np.inf)\n    \n    # Return the priority scores\n    return priority",
    "response_id": 0,
    "tryHS": false,
    "obj": 42.79018747506982,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 120.92782504182705,
    "mi": 50.43042142949787,
    "token_count": 92.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response1.txt_stdout.txt",
    "code_path": "problem_iter6_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is based on a non-linear function of the remaining capacity of the bin and the size of the item.\n    A bin with a remaining capacity that is just enough for the item and leaves a reasonable room for future items will have the highest priority.\n    A bin that is too small for the item will have a priority of negative infinity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # First, we identify bins that are too small for the item and give them a very low priority\n    priority = np.where(bins_remain_cap >= item, np.exp(-(bins_remain_cap - item)), -np.inf)\n    \n    # Then, we consider the trade-off between fitting items tightly and leaving room for future items\n    # by adding a term that rewards bins with a reasonable remaining capacity\n    avg_remain_cap = np.mean(bins_remain_cap[bins_remain_cap >= item])\n    priority = np.where(bins_remain_cap >= item, priority * (1 + np.tanh(bins_remain_cap - avg_remain_cap)), priority)\n    \n    # Return the priority scores\n    return priority",
    "response_id": 1,
    "tryHS": false,
    "obj": 64.19026725169526,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 120.92782504182705,
    "mi": 50.43042142949787,
    "token_count": 92.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response2.txt_stdout.txt",
    "code_path": "problem_iter6_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is based on a non-linear function of the remaining capacity of the bin and the size of the item.\n    It considers a trade-off between fitting the item tightly and leaving room for future items.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Identify bins that are too small for the item and give them a very low priority\n    too_small = bins_remain_cap < item\n    \n    # Calculate a non-linear priority score based on the remaining capacity and the item size\n    # The score is high when the remaining capacity is just enough for the item, and also when there's a good balance between tight fit and room for future items\n    priority = np.where(~too_small, np.exp(-(bins_remain_cap - item) / item) * (bins_remain_cap - item), -np.inf)\n    \n    # Add a small random noise to the priority scores to avoid ties and encourage exploration\n    priority += np.random.uniform(0, 1e-6, size=len(bins_remain_cap))\n    \n    # Return the priority scores\n    return priority",
    "response_id": 2,
    "tryHS": false,
    "obj": 40.01794974072597,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 120.92782504182705,
    "mi": 50.43042142949787,
    "token_count": 92.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response3.txt_stdout.txt",
    "code_path": "problem_iter6_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is based on a trade-off between the remaining capacity of the bin and the size of the item.\n    A non-linear function is used to prioritize bins that have a remaining capacity that is just enough for the item,\n    while also considering the potential for future items.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # First, we identify bins that are too small for the item and give them a very low priority\n    priority = np.where(bins_remain_cap >= item, np.exp(-(bins_remain_cap - item)), -np.inf)\n    \n    # Then, we add a term that prioritizes bins that are not too empty, to leave room for future items\n    priority *= (1 + np.tanh(bins_remain_cap - item / 2))\n    \n    # Return the priority scores\n    return priority",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 120.92782504182705,
    "mi": 50.43042142949787,
    "token_count": 92.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response4.txt_stdout.txt",
    "code_path": "problem_iter6_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is based on a non-linear function of the remaining capacity of the bin and the size of the item.\n    A bin with a remaining capacity that is just enough for the item and leaves some room for future items will have the highest priority.\n    A bin that is too small for the item will have a priority of negative infinity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # First, we identify bins that are too small for the item and give them a very low priority\n    priority = np.where(bins_remain_cap >= item, np.log(bins_remain_cap - item + 1), -np.inf)\n    \n    # Then, we add a penalty term to bins with very large remaining capacity to encourage tighter packing\n    priority = np.where(bins_remain_cap >= item, priority - 0.1 * (bins_remain_cap - item) / (bins_remain_cap + 1e-6), priority)\n    \n    # Return the priority scores\n    return priority",
    "response_id": 4,
    "tryHS": false,
    "obj": 149.30195452732352,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 120.92782504182705,
    "mi": 50.43042142949787,
    "token_count": 92.0,
    "exec_success": true
  }
]