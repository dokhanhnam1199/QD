{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, \n                penalty_weight: float = 0.015962034932029284, \n                perturbation_max: float = 8.082068759055226e-06) -> np.ndarray:\n    \"\"\"\n    Enhanced priority function that balances tight fit, future capacity, and bin utilization.\n    \"\"\"\n    # Identify valid bins and calculate remaining capacity after adding the item\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Calculate the ratio of item size to bin remaining capacity for a tight fit measure\n    tight_fit_measure = item / bins_remain_cap\n    \n    # Non-linear prioritization with a refined penalty term for balancing tight fit and future capacity\n    priority = np.where(valid_bins == 1, \n                         np.exp(-remain_cap_after_add / item) * (1 + tight_fit_measure) - penalty_weight * remain_cap_after_add,  \n                         -np.inf)\n    \n    # Normalize priority scores for better adaptability and robustness\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:\n        priority = priority / max_priority\n    \n    # Introduce a slight perturbation to avoid identical priorities for different bins\n    priority += np.random.uniform(0, perturbation_max, size=len(priority))\n    \n    return priority\n\n[Heuristics 2nd]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, \n                penalty_weight: float = 0.015962034932029284, \n                perturbation_max: float = 8.082068759055226e-06) -> np.ndarray:\n    \"\"\"\n    Enhanced priority function that balances tight fit, future capacity, and bin utilization.\n    \"\"\"\n    # Identify valid bins and calculate remaining capacity after adding the item\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Calculate the ratio of item size to bin remaining capacity for a tight fit measure\n    tight_fit_measure = item / bins_remain_cap\n    \n    # Non-linear prioritization with a refined penalty term for balancing tight fit and future capacity\n    priority = np.where(valid_bins == 1, \n                         np.exp(-remain_cap_after_add / item) * (1 + tight_fit_measure) - penalty_weight * remain_cap_after_add,  \n                         -np.inf)\n    \n    # Normalize priority scores for better adaptability and robustness\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:\n        priority = priority / max_priority\n    \n    # Introduce a slight perturbation to avoid identical priorities for different bins\n    priority += np.random.uniform(0, perturbation_max, size=len(priority))\n    \n    return priority\n\n[Heuristics 3rd]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, \n                penalty_weight: float = 0.015962034932029284, \n                perturbation_max: float = 8.082068759055226e-06) -> np.ndarray:\n    \"\"\"\n    Enhanced priority function that balances tight fit, future capacity, and bin utilization.\n    \"\"\"\n    # Identify valid bins and calculate remaining capacity after adding the item\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Calculate the ratio of item size to bin remaining capacity for a tight fit measure\n    tight_fit_measure = item / bins_remain_cap\n    \n    # Non-linear prioritization with a refined penalty term for balancing tight fit and future capacity\n    priority = np.where(valid_bins == 1, \n                         np.exp(-remain_cap_after_add / item) * (1 + tight_fit_measure) - penalty_weight * remain_cap_after_add,  \n                         -np.inf)\n    \n    # Normalize priority scores for better adaptability and robustness\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:\n        priority = priority / max_priority\n    \n    # Introduce a slight perturbation to avoid identical priorities for different bins\n    priority += np.random.uniform(0, perturbation_max, size=len(priority))\n    \n    return priority\n\n[Heuristics 4th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, \n                penalty_weight: float = 0.015962034932029284, \n                perturbation_max: float = 8.082068759055226e-06) -> np.ndarray:\n    \"\"\"\n    Enhanced priority function that balances tight fit, future capacity, and bin utilization.\n    \"\"\"\n    # Identify valid bins and calculate remaining capacity after adding the item\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Calculate the ratio of item size to bin remaining capacity for a tight fit measure\n    tight_fit_measure = item / bins_remain_cap\n    \n    # Non-linear prioritization with a refined penalty term for balancing tight fit and future capacity\n    priority = np.where(valid_bins == 1, \n                         np.exp(-remain_cap_after_add / item) * (1 + tight_fit_measure) - penalty_weight * remain_cap_after_add,  \n                         -np.inf)\n    \n    # Normalize priority scores for better adaptability and robustness\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:\n        priority = priority / max_priority\n    \n    # Introduce a slight perturbation to avoid identical priorities for different bins\n    priority += np.random.uniform(0, perturbation_max, size=len(priority))\n    \n    return priority\n\n[Heuristics 5th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, \n                penalty_weight: float = 0.015962034932029284, \n                perturbation_max: float = 8.082068759055226e-06) -> np.ndarray:\n    \"\"\"\n    Enhanced priority function that balances tight fit, future capacity, and bin utilization.\n    \"\"\"\n    # Identify valid bins and calculate remaining capacity after adding the item\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Calculate the ratio of item size to bin remaining capacity for a tight fit measure\n    tight_fit_measure = item / bins_remain_cap\n    \n    # Non-linear prioritization with a refined penalty term for balancing tight fit and future capacity\n    priority = np.where(valid_bins == 1, \n                         np.exp(-remain_cap_after_add / item) * (1 + tight_fit_measure) - penalty_weight * remain_cap_after_add,  \n                         -np.inf)\n    \n    # Normalize priority scores for better adaptability and robustness\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:\n        priority = priority / max_priority\n    \n    # Introduce a slight perturbation to avoid identical priorities for different bins\n    priority += np.random.uniform(0, perturbation_max, size=len(priority))\n    \n    return priority\n\n[Heuristics 6th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Enhanced priority function that balances tight fit, future capacity, and bin utilization.\n    \"\"\"\n    # Identify valid bins and calculate remaining capacity after adding the item\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Calculate the ratio of item size to bin remaining capacity for a tight fit measure\n    tight_fit_measure = item / bins_remain_cap\n    \n    # Non-linear prioritization with a refined penalty term for balancing tight fit and future capacity\n    priority = np.where(valid_bins == 1, \n                         np.exp(-remain_cap_after_add / item) * (1 + tight_fit_measure) - 0.01 * remain_cap_after_add,  \n                         -np.inf)\n    \n    # Normalize priority scores for better adaptability and robustness\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:\n        priority = priority / max_priority\n    \n    # Introduce a slight perturbation to avoid identical priorities for different bins\n    priority += np.random.uniform(0, 1e-6, size=len(priority))\n    \n    return priority\n\n[Heuristics 7th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a refined penalty term for tighter fits and future capacity.\n    \"\"\"\n    # Non-linear prioritization for valid bins and a refined penalty term to balance tight fitting and future capacity\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    fit_ratio = item / bins_remain_cap  # Higher ratio indicates tighter fit\n    penalty_term = np.exp(-(bins_remain_cap - item) / item)  # Non-linear prioritization\n    priority = np.where(valid_bins == 1, fit_ratio * penalty_term, -np.inf)  # Combine fit ratio and penalty term\n    \n    return priority\n\n[Heuristics 8th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a refined penalty term, balancing tight fit and future capacity.\n    \"\"\"\n    # Calculate valid bins and remaining capacity after adding the item\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Non-linear prioritization focusing on tight fit and future capacity\n    tight_fit_score = np.exp(-remain_cap_after_add / (item + 1e-6))\n    future_capacity_score = remain_cap_after_add / (bins_remain_cap + 1e-6)\n    \n    # Combine scores with a weighted average and apply a refined penalty term\n    priority = np.where(valid_bins == 1, \n                         0.7 * tight_fit_score + 0.3 * future_capacity_score, \n                         -np.inf)\n    penalty_term = np.exp(-remain_cap_after_add / item)\n    priority *= np.where(valid_bins == 1, penalty_term, 1)\n    \n    # Normalize priority scores for enhanced adaptability\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:\n        priority = priority / max_priority\n    \n    return priority\n\n[Heuristics 9th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a nuanced penalty term, \n    balancing tight fit and future capacity effectively.\n    \"\"\"\n    # Identify valid bins and calculate remaining capacity after adding the item\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Non-linear prioritization focusing on tight fit\n    tight_fit_score = np.exp(-remain_cap_after_add / (item + 1e-6))\n    \n    # Refined penalty term for future capacity and balancing\n    future_capacity_penalty = (1 / (1 + np.exp((remain_cap_after_add - item/2) / item)))\n    \n    # Combine scores for better adaptability\n    priority = np.where(valid_bins == 1, \n                         0.7 * tight_fit_score + 0.3 * future_capacity_penalty, \n                         -np.inf)\n    \n    # Normalize priority scores\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:\n        priority = priority / max_priority\n    \n    return priority\n\n[Heuristics 10th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a refined penalty term for tighter fits and future capacity.\n    \"\"\"\n    # Non-linear prioritization for valid bins and a refined penalty term to balance tight fitting and future capacity\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    fit_ratio = item / bins_remain_cap  # Higher ratio indicates tighter fit\n    penalty_term = np.exp(-(bins_remain_cap - item) / item)  # Non-linear prioritization\n    priority = np.where(valid_bins == 1, fit_ratio * penalty_term, -np.inf)  # Combine fit ratio and penalty term\n    \n    return priority\n\n[Heuristics 11th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a nuanced penalty term, \n    balancing tight fit and future capacity effectively.\n    \"\"\"\n    # Identify valid bins and calculate remaining capacity after adding the item\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Non-linear prioritization focusing on tight fit\n    tight_fit_score = np.exp(-remain_cap_after_add / (item + 1e-6))\n    \n    # Refined penalty term for future capacity and balancing\n    future_capacity_penalty = (1 / (1 + np.exp((remain_cap_after_add - item/2) / item)))\n    \n    # Combine scores for better adaptability\n    priority = np.where(valid_bins == 1, \n                         0.7 * tight_fit_score + 0.3 * future_capacity_penalty, \n                         -np.inf)\n    \n    # Normalize priority scores\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:\n        priority = priority / max_priority\n    \n    return priority\n\n[Heuristics 12th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a refined penalty term for better bin selection.\n    Balances tight fitting and future capacity using a ratio-based penalty.\n    \"\"\"\n    # Identify valid bins and calculate the ratio of item size to remaining capacity\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    fit_ratio = item / bins_remain_cap\n    \n    # Non-linear prioritization for valid bins\n    priority = np.where(valid_bins == 1, 1 / (1 + np.abs(bins_remain_cap - item)), -np.inf)\n    \n    # Refined penalty term to encourage tight fits and leave capacity for future items\n    penalty_term = np.exp(-fit_ratio)  # Using fit_ratio for a simpler yet effective penalty\n    \n    # Combine prioritization and penalty term\n    priority *= penalty_term\n    \n    return priority\n\n[Heuristics 13th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a nuanced penalty term, \n    balancing tight fit and future capacity effectively.\n    \"\"\"\n    # Identify valid bins and calculate remaining capacity after adding the item\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Non-linear prioritization focusing on tight fit\n    tight_fit_score = np.exp(-remain_cap_after_add / (item + 1e-6))\n    \n    # Refined penalty term for future capacity and balancing\n    future_capacity_penalty = (1 / (1 + np.exp((remain_cap_after_add - item/2) / item)))\n    \n    # Combine scores for better adaptability\n    priority = np.where(valid_bins == 1, \n                         0.7 * tight_fit_score + 0.3 * future_capacity_penalty, \n                         -np.inf)\n    \n    # Normalize priority scores\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:\n        priority = priority / max_priority\n    \n    return priority\n\n[Heuristics 14th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Enhanced priority function that combines non-linear prioritization with a dynamic penalty term,\n    adapting to both tight fits and future capacity needs, while introducing a 'look-ahead' aspect.\n    \"\"\"\n    # Identify valid bins and calculate remaining capacity after adding the item\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Non-linear prioritization with a refined penalty term for balancing tight fit and future capacity\n    # Introducing a dynamic penalty that adjusts based on the item size relative to the bin capacity\n    priority = np.where(valid_bins == 1, \n                         np.exp(-remain_cap_after_add / (item + 1e-6)) - 0.05 * (remain_cap_after_add / (bins_remain_cap + 1e-6)),  \n                         -np.inf)\n    \n    # Enhance differentiation among valid bins by applying a non-linear scaling\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:\n        priority = np.where(priority != -np.inf, (priority / max_priority) ** 2, -np.inf)  # Squaring to enhance differentiation\n    \n    return priority\n\n[Heuristics 15th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Enhances the priority function by introducing a more nuanced non-linear prioritization \n    and a dynamic penalty term that adapts based on the item size and bin capacity.\n    \"\"\"\n    # Identify valid bins\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    \n    # Calculate remaining capacity after adding the item and its proportion to the item size\n    remain_cap_after_add = bins_remain_cap - item\n    proportion_remain = remain_cap_after_add / item\n    \n    # Non-linear prioritization with a dynamic penalty term that considers the relative remaining capacity\n    priority = np.where(valid_bins == 1, \n                         np.exp(-proportion_remain) - 0.05 * (proportion_remain ** 2),  # More nuanced penalty for larger remaining capacity relative to item size\n                         -np.inf)\n    \n    # Apply a bonus for bins with very tight fits to encourage efficient packing\n    tight_fit_bonus = np.where((remain_cap_after_add > 0) & (remain_cap_after_add < 0.1 * item), 0.1, 0)\n    priority += tight_fit_bonus\n    \n    # Normalize priority scores for adaptability, handling the case where all priorities are -inf\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:\n        priority = priority / max_priority\n    else:\n        priority = valid_bins - 1  # When all bins are invalid, return -1 for invalid bins\n    \n    return priority\n\n[Heuristics 16th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a refined penalty term for better bin selection.\n    Balances tight fitting and future capacity using a nuanced formulation.\n    \"\"\"\n    # Non-linear prioritization for bins with sufficient capacity, normalized by item size\n    priority = np.where(bins_remain_cap >= item, np.exp(-(bins_remain_cap - item) / item), -np.inf)\n    \n    # Refined penalty term to balance tight fitting and future capacity\n    valid_bins = priority != -np.inf\n    if np.any(valid_bins):\n        # Use a term that considers both remaining capacity and item size\n        balancing_term = 1 / (1 + np.abs(bins_remain_cap[valid_bins] - item))\n        priority[valid_bins] *= balancing_term * ((bins_remain_cap[valid_bins] - item) / bins_remain_cap[valid_bins])\n        \n    return priority\n\n[Heuristics 17th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with refined penalty terms for balancing tight fits and future capacity.\n    \"\"\"\n    # Calculate valid bins and remaining capacity after adding the item\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Non-linear prioritization focusing on tight fit\n    tight_fit_score = np.exp(-remain_cap_after_add / (item + 1e-6))\n    \n    # Refined penalty term to balance tight fitting and future capacity\n    future_capacity_score = remain_cap_after_add / (bins_remain_cap + 1e-6)\n    penalty_term = np.where(valid_bins == 1, future_capacity_score, 1)\n    \n    # Combine scores with a weighted product for better adaptability\n    priority = np.where(valid_bins == 1, tight_fit_score * penalty_term, -np.inf)\n    \n    # Normalize priority scores for enhanced adaptability\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:\n        priority = priority / max_priority\n    \n    return priority\n\n[Heuristics 18th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Enhances the priority function by introducing a dynamic penalty term that adjusts based on the item size relative to the bin capacity,\n    and incorporates a more nuanced non-linear prioritization that considers both the tightness of fit and the remaining capacity.\n    \"\"\"\n    # Calculate valid bins and remaining capacity after adding the item\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Dynamic penalty term based on item size relative to bin capacity\n    penalty_term = np.where(valid_bins == 1, \n                            1 - (item / bins_remain_cap),  # Encourages bins that are filled to a larger proportion\n                            -np.inf)\n    \n    # Enhanced non-linear prioritization with adjusted penalty for balancing tight fit and future capacity\n    priority = np.where(valid_bins == 1, \n                         np.exp(-remain_cap_after_add / (item + 1e-6)) * penalty_term,  # Adds a small value to avoid division by zero\n                         -np.inf)\n    \n    # Normalize priority scores for better adaptability and to ensure scores are within a comparable range\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:\n        priority = priority / max_priority\n    \n    return priority\n\n[Heuristics 19th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Enhances the priority function by introducing a dynamic penalty term that adjusts based on the item size relative to the bin capacity,\n    and incorporates a more nuanced non-linear prioritization that considers both the tightness of fit and the remaining capacity.\n    \"\"\"\n    # Calculate valid bins and remaining capacity after adding the item\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Dynamic penalty term based on item size relative to bin capacity\n    penalty_term = np.where(valid_bins == 1, \n                            1 - (item / bins_remain_cap),  # Encourages bins that are filled to a larger proportion\n                            -np.inf)\n    \n    # Enhanced non-linear prioritization with adjusted penalty for balancing tight fit and future capacity\n    priority = np.where(valid_bins == 1, \n                         np.exp(-remain_cap_after_add / (item + 1e-6)) * penalty_term,  # Adds a small value to avoid division by zero\n                         -np.inf)\n    \n    # Normalize priority scores for better adaptability and to ensure scores are within a comparable range\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:\n        priority = priority / max_priority\n    \n    return priority\n\n[Heuristics 20th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Enhances the priority function by introducing a more nuanced penalty term \n    that considers both the tightness of the fit and the remaining capacity in a non-linear fashion.\n    \"\"\"\n    # Identify valid bins\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    \n    # Calculate remaining capacity after adding the item and its proportion to the item size\n    remain_cap_after_add = bins_remain_cap - item\n    proportion_remain = remain_cap_after_add / item\n    \n    # Introduce a non-linear penalty term that decreases as the remaining capacity approaches zero\n    # and increases as the remaining capacity becomes larger, but with diminishing returns\n    penalty_term = -np.log1p(proportion_remain)  # Using log1p to avoid division by zero and to introduce non-linearity\n    \n    # Assign -inf priority to invalid bins\n    priority = np.where(valid_bins == 1, penalty_term, -np.inf)\n    \n    # Normalize priority scores to ensure they are within a comparable range\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:\n        priority = priority / max_priority\n    \n    return priority\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}