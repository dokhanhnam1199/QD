[
  {
    "stdout_filepath": "problem_iter11_response0.txt_stdout.txt",
    "code_path": "problem_iter11_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a balancing term for tight fitting and future capacity.\n    Prioritizes bins with enough capacity and a good balance between tightness and remaining capacity.\n    \"\"\"\n    # Identify bins that are too small and assign them a very low priority\n    priority = np.where(bins_remain_cap >= item, \n                        # Use a non-linear function to prioritize bins based on remaining capacity and item size\n                        np.exp(-(bins_remain_cap - item) / (bins_remain_cap + 1e-6)), \n                        -np.inf)\n    \n    # Apply an additional balancing term to prioritize bins that are not too full\n    valid_bins = priority != -np.inf\n    if np.any(valid_bins):\n        # Normalize the priority scores for valid bins to ensure they are on the same scale\n        max_score = np.max(priority[valid_bins])\n        min_score = np.min(priority[valid_bins])\n        priority[valid_bins] = (priority[valid_bins] - min_score) / (max_score - min_score + 1e-6)\n        # Apply the balancing term\n        priority[valid_bins] *= (1 - item / bins_remain_cap[valid_bins])\n        \n    return priority",
    "response_id": 0,
    "tryHS": false,
    "obj": 9.782608695652188,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 96.0,
    "mi": 87.34050010374426,
    "token_count": 85.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response1.txt_stdout.txt",
    "code_path": "problem_iter11_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines best-fit and tight-fitting heuristics with a non-linear priority score.\n    Balances tight fitting and future capacity using exp function and remaining capacity.\n    \"\"\"\n    # Identify bins that are too small for the item and give them a very low priority\n    priority = np.where(bins_remain_cap >= item, np.exp(-(bins_remain_cap - item) / item), -np.inf)\n    \n    # Weigh the priority scores by a factor that considers the remaining capacity\n    valid_bins = priority != -np.inf\n    if np.any(valid_bins):\n        # Use a non-linear function to further balance between tight fitting and future capacity\n        priority[valid_bins] *= (1 + np.tanh(bins_remain_cap[valid_bins] - np.mean(bins_remain_cap[valid_bins])))\n    \n    return priority",
    "response_id": 1,
    "tryHS": false,
    "obj": 94.68488232947747,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 96.0,
    "mi": 87.34050010374426,
    "token_count": 85.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response2.txt_stdout.txt",
    "code_path": "problem_iter11_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a penalty for large remaining capacity.\n    Balances tight fitting and future capacity by using bins_remain_cap in the exponent.\n    \"\"\"\n    # Check if item fits and calculate remaining capacity after addition\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Non-linear priority with a penalty term for large remaining capacity\n    # Divide by item in the exponent to balance tight fitting and future capacity\n    priority = np.where(valid_bins == 1, np.exp(-remaining_cap_after_addition / item) - 0.01 * remaining_cap_after_addition / bins_remain_cap, 0)\n    \n    return priority",
    "response_id": 2,
    "tryHS": true,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 96.0,
    "mi": 87.34050010374426,
    "token_count": 85.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response3.txt_stdout.txt",
    "code_path": "problem_iter11_code3.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, \n                threshold_multiplier: float = 0.6146913810542726, \n                epsilon: float = 9.542102062488644e-05) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a balance between tight fitting and future capacity.\n    \"\"\"\n    # Identify bins that are too small for the item and calculate initial priority\n    priority = np.where(bins_remain_cap >= item, np.exp(-threshold_multiplier * (bins_remain_cap - item)), -np.inf)\n    \n    # Calculate average remaining capacity for valid bins\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):\n        avg_remain_cap = np.mean(bins_remain_cap[valid_bins])\n        \n        # Balance between tight fitting and future capacity\n        priority[valid_bins] = priority[valid_bins] * (1 + (avg_remain_cap - bins_remain_cap[valid_bins]) / (avg_remain_cap + epsilon))\n        \n        # Normalize priority scores for valid bins to enhance differentiation\n        max_score = np.max(priority[valid_bins])\n        min_score = np.min(priority[valid_bins])\n        if max_score != min_score:  # Avoid division by zero\n            priority[valid_bins] = (priority[valid_bins] - min_score) / (max_score - min_score + 1e-6)\n    \n    return priority",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 96.0,
    "mi": 87.34050010374426,
    "token_count": 85.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response4.txt_stdout.txt",
    "code_path": "problem_iter11_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a balance between tight fitting and future capacity.\n    \"\"\"\n    # Identify bins that are too small for the item and give them a very low priority\n    priority = np.where(bins_remain_cap >= item, np.exp(-(bins_remain_cap - item) / item), -np.inf)\n    \n    # Apply an additional term to balance tight fitting and future capacity\n    valid_bins = priority != -np.inf\n    if np.any(valid_bins):\n        priority[valid_bins] = priority[valid_bins] * (1 - item / bins_remain_cap[valid_bins])\n        \n    return priority",
    "response_id": 4,
    "tryHS": false,
    "obj": 16.513761467889925,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 96.0,
    "mi": 87.34050010374426,
    "token_count": 85.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response5.txt_stdout.txt",
    "code_path": "problem_iter11_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear functions to prioritize bins with remaining capacity just enough for the item,\n    balancing tight fitting and future capacity, normalized for better distribution.\n    \"\"\"\n    # Identify bins that are too small and give them a very low priority\n    priority = np.where(bins_remain_cap >= item, np.exp(-(bins_remain_cap - item) / item), -np.inf)\n    \n    # Normalize valid priority scores to ensure a better distribution\n    valid_bins = priority != -np.inf\n    if np.any(valid_bins):\n        max_score = np.max(priority[valid_bins])\n        min_score = np.min(priority[valid_bins])\n        priority[valid_bins] = (priority[valid_bins] - min_score) / (max_score - min_score + 1e-6)\n        \n    return priority",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 96.0,
    "mi": 87.34050010374426,
    "token_count": 85.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response6.txt_stdout.txt",
    "code_path": "problem_iter11_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines best-fit and tight-fitting heuristics with a non-linear priority score.\n    Balances tight fitting and future capacity using exp function and remaining capacity.\n    \"\"\"\n    # Identify bins that are too small for the item and give them a very low priority\n    priority = np.where(bins_remain_cap >= item, np.exp(-(bins_remain_cap - item) / item), -np.inf)\n    \n    # Weigh the priority scores by a factor that considers the remaining capacity\n    valid_bins = priority != -np.inf\n    if np.any(valid_bins):\n        # Use a non-linear function to further balance between tight fitting and future capacity\n        priority[valid_bins] *= (1 + np.tanh(bins_remain_cap[valid_bins] - np.mean(bins_remain_cap[valid_bins])))\n    \n    return priority",
    "response_id": 6,
    "tryHS": false,
    "obj": 94.68488232947747,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 96.0,
    "mi": 87.34050010374426,
    "token_count": 85.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response7.txt_stdout.txt",
    "code_path": "problem_iter11_code7.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a balance between tight fitting and future capacity.\n    Prioritizes bins with enough capacity and smaller remaining capacity after addition.\n    \"\"\"\n    # Calculate priority scores using a non-linear function that balances tight fitting and future capacity\n    priority_scores = np.where(bins_remain_cap >= item, np.exp(-(bins_remain_cap - item) / item), -np.inf)\n    \n    # Return the priority scores\n    return priority_scores",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 96.0,
    "mi": 87.34050010374426,
    "token_count": 85.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response8.txt_stdout.txt",
    "code_path": "problem_iter11_code8.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, \n                threshold_multiplier: float = 0.6146913810542726, \n                epsilon: float = 9.542102062488644e-05) -> np.ndarray:\n    \"\"\"\n    Combines non-linear priority scoring with a balance between tight fitting and future capacity.\n    \"\"\"\n    # Identify bins that are too small for the item\n    priority = np.where(bins_remain_cap >= item, np.exp(-threshold_multiplier * (bins_remain_cap - item)), -np.inf)\n    \n    # Weigh the priority scores by the remaining capacity after addition to encourage tight-fitting\n    valid_bins = priority != -np.inf\n    if np.any(valid_bins):\n        # Balance between tight fitting and future capacity using a non-linear function\n        avg_remain_cap = np.mean(bins_remain_cap[valid_bins])\n        priority[valid_bins] *= (1 + np.tanh(avg_remain_cap - bins_remain_cap[valid_bins]) / (avg_remain_cap + epsilon))\n    \n    return priority",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 96.0,
    "mi": 87.34050010374426,
    "token_count": 85.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response9.txt_stdout.txt",
    "code_path": "problem_iter11_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear function for tight fit with consideration for future capacity.\n    \n    Uses np.exp(-(bins_remain_cap - item) / item) to balance tight fitting and future capacity.\n    \"\"\"\n    # Calculate priority score using a non-linear function for valid bins\n    priority = np.where(bins_remain_cap >= item, np.exp(-(bins_remain_cap - item) / item), -np.inf)\n    \n    # Add a small bonus to prioritize bins with more remaining capacity\n    priority = np.where(priority > -np.inf, priority + 1e-6 * bins_remain_cap, priority)\n    \n    return priority",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.058635819704831,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 96.0,
    "mi": 87.34050010374426,
    "token_count": 85.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response0.txt_stdout.txt",
    "code_path": "problem_iter12_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is based on the remaining capacity of the bin and the size of the item.\n    A bin with a remaining capacity that is just enough for the item will have the highest priority.\n    A bin that is too small for the item will have a priority of negative infinity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # First, we identify bins that are too small for the item and give them a very low priority\n    priority = np.where(bins_remain_cap >= item, 1 / (1 + bins_remain_cap - item), -np.inf)\n    \n    # Return the priority scores\n    return priority",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 3.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 28.07354922057604,
    "mi": 49.64835513596704,
    "token_count": 61.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response1.txt_stdout.txt",
    "code_path": "problem_iter12_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is based on a non-linear function of the remaining capacity of the bin and the size of the item.\n    It balances between tight fitting and leaving room for future items.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Identify bins that are too small for the item and give them a very low priority\n    priority = np.where(bins_remain_cap >= item, np.exp(-(bins_remain_cap - item)), -np.inf)\n    \n    # Return the priority scores\n    return priority",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 3.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 28.07354922057604,
    "mi": 49.64835513596704,
    "token_count": 61.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response2.txt_stdout.txt",
    "code_path": "problem_iter12_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is based on a non-linear function that balances tight fitting and future capacity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # First, we identify bins that are too small for the item and give them a very low priority\n    priority = np.where(bins_remain_cap >= item, np.exp(-(bins_remain_cap - item)), -np.inf)\n    \n    # Return the priority scores\n    return priority",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 3.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 28.07354922057604,
    "mi": 49.64835513596704,
    "token_count": 61.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response3.txt_stdout.txt",
    "code_path": "problem_iter12_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is based on the remaining capacity of the bin and the size of the item.\n    A bin with a remaining capacity that is just enough for the item and has a larger remaining capacity after packing will have a higher priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # First, we identify bins that are too small for the item and give them a very low priority\n    priority = np.where(bins_remain_cap >= item, (bins_remain_cap - item) / bins_remain_cap, -np.inf)\n    \n    # Return the priority scores\n    return priority",
    "response_id": 3,
    "tryHS": false,
    "obj": 149.30195452732352,
    "SLOC": 3.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 28.07354922057604,
    "mi": 49.64835513596704,
    "token_count": 61.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response4.txt_stdout.txt",
    "code_path": "problem_iter12_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is based on the remaining capacity of the bin and the size of the item.\n    A bin with a remaining capacity that is just enough for the item will have the highest priority.\n    A bin that is too small for the item will have a priority of negative infinity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # First, we identify bins that are too small for the item and give them a very low priority\n    priority = np.where(bins_remain_cap >= item, np.exp(-(bins_remain_cap - item)), -np.inf)\n    \n    # Return the priority scores\n    return priority",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 3.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 28.07354922057604,
    "mi": 49.64835513596704,
    "token_count": 61.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter13_response0.txt_stdout.txt",
    "code_path": "problem_iter13_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, penalty_weight: float = 0.8952215992744905, tight_fitting_exponent_base: float = 2.718281828459045) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a penalty for large remaining capacity.\n    Balances tight fitting and future capacity by using bins_remain_cap in the exponent.\n    \"\"\"\n    # Check if item fits and calculate remaining capacity after addition\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Non-linear priority with a penalty term for large remaining capacity\n    # Divide by item in the exponent to balance tight fitting and future capacity\n    priority = np.where(valid_bins == 1, \n                        np.exp(-remaining_cap_after_addition / item) - penalty_weight * remaining_cap_after_addition / bins_remain_cap, \n                        0)\n    \n    return priority",
    "response_id": 0,
    "tryHS": true,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 92.0,
    "mi": 94.78277715597198,
    "token_count": 97.0,
    "exec_success": true
  }
]