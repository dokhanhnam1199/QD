[
  {
    "stdout_filepath": "problem_iter2_response0.txt_stdout.txt",
    "code_path": "problem_iter2_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority score for each bin based on remaining capacity after adding the item.\n    Bins with remaining capacity just enough for the item get higher priority.\n    \"\"\"\n    # Identify bins that are too small and give them a very low priority\n    priority = np.where(bins_remain_cap >= item, bins_remain_cap - item, -np.inf)\n    \n    # Normalize the priority scores using a simple and effective method\n    valid_bins = (priority != -np.inf)\n    if np.any(valid_bins):\n        max_priority = np.max(-priority[valid_bins])  # max of -priority for valid bins\n        min_priority = np.min(-priority[valid_bins])  # min of -priority for valid bins\n        if max_priority != min_priority:\n            priority[valid_bins] = (-priority[valid_bins] - min_priority) / (max_priority - min_priority)\n        else:\n            priority[valid_bins] = 1.0  # all valid bins get the same priority\n    \n    return priority",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 20.67970000576925,
    "mi": 86.80643539003533,
    "token_count": 62.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response1.txt_stdout.txt",
    "code_path": "problem_iter2_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Priority score based on remaining capacity after adding item and First-Fit decreasing heuristic.\n    \"\"\"\n    # Calculate priority score as negative of remaining capacity after adding item\n    priority = np.where(bins_remain_cap >= item, -(bins_remain_cap - item), -np.inf)\n    \n    # Apply First-Fit decreasing heuristic by adding a small bonus to bins with more remaining capacity\n    priority = np.where(priority > -np.inf, priority + 1e-6 * bins_remain_cap, priority)\n    \n    return priority",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 20.67970000576925,
    "mi": 86.80643539003533,
    "token_count": 62.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response2.txt_stdout.txt",
    "code_path": "problem_iter2_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Priority score for each bin based on remaining capacity after adding the item.\n    Higher score for bins with capacity closest to the item size.\n    \"\"\"\n    # Calculate the priority score for each bin\n    valid_bins = (bins_remain_cap >= item).astype(float)  # Check if item fits\n    priority = np.where(valid_bins == 1, 1 - (bins_remain_cap - item) / bins_remain_cap, 0)\n    \n    return priority",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 20.67970000576925,
    "mi": 86.80643539003533,
    "token_count": 62.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response3.txt_stdout.txt",
    "code_path": "problem_iter2_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority score for each bin. \n    Prioritizes bins that can fit the item and have the least remaining capacity after addition.\n    \"\"\"\n    # Calculate remaining capacity after adding the item\n    remaining_capacity_after_addition = bins_remain_cap - item\n    \n    # Prioritize bins based on remaining capacity after addition\n    priority = np.where(\n        remaining_capacity_after_addition >= 0, \n        bins_remain_cap,  # First-Fit decreasing heuristic for valid bins\n        -np.inf  # Invalid bins get -inf priority\n    )\n    \n    # Normalize priority scores for valid bins\n    valid_bins = priority != -np.inf\n    if np.any(valid_bins):\n        max_cap = np.max(priority[valid_bins])\n        min_cap = np.min(priority[valid_bins])\n        priority[valid_bins] = (priority[valid_bins] - min_cap) / (max_cap - min_cap)\n    else:\n        priority = np.zeros_like(bins_remain_cap)\n        \n    return priority",
    "response_id": 3,
    "tryHS": false,
    "obj": 149.30195452732352,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 20.67970000576925,
    "mi": 86.80643539003533,
    "token_count": 62.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response4.txt_stdout.txt",
    "code_path": "problem_iter2_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority score for each bin based on remaining capacity after adding the item.\n    Prioritizes bins that fit the item well and minimizes waste.\n    \"\"\"\n    # Check if item can fit into each bin\n    can_fit = bins_remain_cap >= item\n    \n    # Calculate remaining capacity after adding the item\n    remaining_cap_after_add = bins_remain_cap - item\n    \n    # Priority is inversely proportional to remaining capacity after addition, with a small epsilon to avoid division by zero\n    epsilon = 1e-6\n    priority = np.where(can_fit, 1 / (epsilon + remaining_cap_after_add), -1)\n    \n    # Normalize priority scores to be between 0 and 1 for bins that can hold the item\n    valid_priority = priority[can_fit]\n    if len(valid_priority) > 0:\n        max_priority = np.max(valid_priority)\n        min_priority = np.min(valid_priority)\n        if max_priority != min_priority:\n            valid_priority = (valid_priority - min_priority) / (max_priority - min_priority)\n        else:\n            valid_priority = np.ones_like(valid_priority)\n        priority[can_fit] = valid_priority\n    \n    return priority",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 20.67970000576925,
    "mi": 86.80643539003533,
    "token_count": 62.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response5.txt_stdout.txt",
    "code_path": "problem_iter2_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for each bin based on remaining capacity after adding the item.\n    Combines elements of minimizing remaining capacity and simple logic.\n    \"\"\"\n    # Calculate priority score as the negative of the remaining capacity after adding the item\n    priority = np.where(bins_remain_cap >= item, -(bins_remain_cap - item), -np.inf)\n    \n    # Normalize the priority scores to be between 0 and 1 for valid bins\n    valid_bins = priority > -np.inf\n    if np.any(valid_bins):\n        min_priority = np.min(priority[valid_bins])\n        max_priority = np.max(priority[valid_bins])\n        priority = np.where(valid_bins, (priority - min_priority) / (max_priority - min_priority), 0)\n    \n    return priority",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 20.67970000576925,
    "mi": 86.80643539003533,
    "token_count": 62.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response6.txt_stdout.txt",
    "code_path": "problem_iter2_code6.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Priority score based on remaining capacity after adding item and minimizing waste.\n    \n    Combines elements of top heuristics to prioritize bins where the item fits well.\n    \"\"\"\n    # Calculate priority score: bins with remaining capacity closest to item size get highest priority\n    priority = np.where(bins_remain_cap >= item, 1 - (bins_remain_cap - item) / np.maximum(bins_remain_cap, 1e-9), -1)\n    # Normalize priority scores to be between 0 and 1\n    priority = np.maximum(0, (priority - priority.min()) / (priority.max() - priority.min() + 1e-9))\n    return priority",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 20.67970000576925,
    "mi": 86.80643539003533,
    "token_count": 62.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response7.txt_stdout.txt",
    "code_path": "problem_iter2_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for each bin based on remaining capacity after adding the item.\n    Prioritizes bins with a tighter fit for the item.\n    \"\"\"\n    # Calculate priority scores; higher for bins with enough capacity and smaller remaining capacity\n    priority_scores = np.where(bins_remain_cap >= item, 1 / (bins_remain_cap - item + 1e-6), -1.0)\n    \n    return priority_scores",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 20.67970000576925,
    "mi": 86.80643539003533,
    "token_count": 62.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response8.txt_stdout.txt",
    "code_path": "problem_iter2_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority score for each bin. \n    Prioritizes bins that have enough capacity and are most full, with a simple and intuitive logic.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that do not have enough capacity for the item get a priority of -inf\n    # For other bins, priority is inversely proportional to remaining capacity after addition\n    priority = np.where(remaining_after_addition >= 0, -remaining_after_addition + bins_remain_cap.max(), -np.inf)\n    \n    return priority",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 20.67970000576925,
    "mi": 86.80643539003533,
    "token_count": 62.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response9.txt_stdout.txt",
    "code_path": "problem_iter2_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority score for each bin based on remaining capacity and item size.\n    Prioritizes bins that have just enough remaining capacity to hold the item.\n    \"\"\"\n    # Calculate the priority score for each bin based on the remaining capacity and item size\n    valid_bins = bins_remain_cap >= item  # Check if the item can fit in each bin\n    # A bin with remaining capacity closer to the item size gets higher priority\n    priority_scores = np.where(valid_bins, np.exp(-(bins_remain_cap - item)), 0)\n    \n    return priority_scores",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 20.67970000576925,
    "mi": 86.80643539003533,
    "token_count": 62.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response0.txt_stdout.txt",
    "code_path": "problem_iter3_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is based on the remaining capacity of the bin and the size of the item.\n    A bin with a remaining capacity that is just enough for the item and leaves the least remaining capacity will have the highest priority.\n    A bin that is too small for the item will have a priority of negative infinity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # First, we identify bins that are too small for the item and give them a very low priority\n    priority = np.where(bins_remain_cap >= item, bins_remain_cap - item, -np.inf)\n    \n    # We give higher priority to bins that will have less remaining capacity after the item is added\n    # So, we directly use the negative of the remaining capacity after adding the item as the priority\n    priority = - (bins_remain_cap - item)\n    \n    # To make the priority more intuitive and to avoid potential overflow when bins_remain_cap is large,\n    # we can simply use the negative of the remaining capacity after the item is placed as the priority score.\n    # However, to keep it simple and focused on the goal, we stick with a straightforward calculation.\n\n    # Return the priority scores\n    return priority",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 3.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 48.43204266092217,
    "mi": 47.99003010285215,
    "token_count": 64.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response1.txt_stdout.txt",
    "code_path": "problem_iter3_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is based on the remaining capacity of the bin and the size of the item.\n    A bin with a remaining capacity that is just enough for the item and leaves the least remaining capacity will have the highest priority.\n    A bin that is too small for the item will have a priority of negative infinity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # First, we identify bins that are too small for the item and give them a very low priority\n    priority = np.where(bins_remain_cap >= item, bins_remain_cap - item, -np.inf)\n    \n    # Then, we give higher priority to bins that will have less remaining capacity after the item is added\n    # This is done by subtracting the remaining capacity after adding the item from a large number\n    # So, bins with less remaining capacity after adding the item will have higher priority\n    max_remaining_capacity = np.max(bins_remain_cap)\n    priority = np.where(priority != -np.inf, max_remaining_capacity - (bins_remain_cap - item), -np.inf)\n    \n    # Return the priority scores\n    return priority",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 3.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 48.43204266092217,
    "mi": 47.99003010285215,
    "token_count": 64.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response2.txt_stdout.txt",
    "code_path": "problem_iter3_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is based on the remaining capacity of the bin and the size of the item.\n    A bin with a remaining capacity that is closest to the item size will have the highest priority.\n    A bin that is too small for the item will have a priority of negative infinity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # First, we identify bins that are too small for the item and give them a very low priority\n    priority = np.where(bins_remain_cap >= item, 1 / (1 + np.abs(bins_remain_cap - item)), -np.inf)\n    \n    # Return the priority scores\n    return priority",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 3.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 48.43204266092217,
    "mi": 47.99003010285215,
    "token_count": 64.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response3.txt_stdout.txt",
    "code_path": "problem_iter3_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is based on the remaining capacity of the bin and the size of the item.\n    A bin with a remaining capacity that is closest to the item size will have the highest priority.\n    A bin that is too small for the item will have a priority of negative infinity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Identify bins that are too small for the item and give them a very low priority\n    priority = np.where(bins_remain_cap >= item, 1 / (1 + np.abs(bins_remain_cap - item)), -np.inf)\n    \n    # Return the priority scores\n    return priority",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 3.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 48.43204266092217,
    "mi": 47.99003010285215,
    "token_count": 64.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response4.txt_stdout.txt",
    "code_path": "problem_iter3_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is based on the remaining capacity of the bin and the size of the item.\n    A bin with a remaining capacity that is closest to the item size will have the highest priority.\n    A bin that is too small for the item will have a priority of negative infinity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Identify bins that are too small for the item and give them a very low priority\n    priority = np.where(bins_remain_cap >= item, 1 / (1 + np.abs(bins_remain_cap - item)), -np.inf)\n    \n    # Return the priority scores\n    return priority",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 3.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 48.43204266092217,
    "mi": 47.99003010285215,
    "token_count": 64.0,
    "exec_success": true
  }
]