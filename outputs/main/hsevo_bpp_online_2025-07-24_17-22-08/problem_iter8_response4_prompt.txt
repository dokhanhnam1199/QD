{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Combines elements of minimizing remaining capacity and using a non-linear function.\n    Prioritizes bins with remaining capacity closer to the item size using a reciprocal function.\n    \"\"\"\n    # Calculate priority score using a reciprocal function for valid bins\n    priority = np.where(bins_remain_cap >= item, 1 / (bins_remain_cap - item + 1), -np.inf)\n    \n    # Normalize the priority scores to be between 0 and 1 for valid bins\n    valid_bins = priority > -np.inf\n    if np.any(valid_bins):\n        min_priority = np.min(priority[valid_bins])\n        max_priority = np.max(priority[valid_bins])\n        priority = np.where(valid_bins, (priority - min_priority) / (max_priority - min_priority), 0)\n    \n    return priority\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Priority score based on negative remaining capacity after adding item and \n    a bonus for bins with more remaining capacity to balance tight fit and future capacity.\n    \"\"\"\n    # Calculate priority score as negative of remaining capacity after adding item\n    priority = np.where(bins_remain_cap >= item, -(bins_remain_cap - item), -np.inf)\n    \n    # Add a bonus to bins with more remaining capacity to balance tight fit and future capacity\n    priority = np.where(priority > -np.inf, priority + 1e-3 * np.exp(bins_remain_cap / (item + 1e-6)), priority)\n    \n    return priority\n\n### Analyze & experience\n- Comparing the best heuristic (1st) with the worst (20th), we see that the top heuristic uses a simple, normalized priority score based on the remaining capacity, while the worst uses a logarithmic function with a penalty term. \nComparing (1st) vs (2nd), we see that both use non-linear functions, but the 1st normalizes the priority scores directly, whereas the 2nd normalizes after applying a reciprocal function. \n(3rd) vs (4th) shows that both combine elements of best-fit and tight-fitting heuristics, but the 3rd weighs priority scores by remaining capacity, whereas the 4th uses a non-linear function with an additional term for future items. \nComparing (second worst) vs (worst), we see that they are almost identical, using a logarithmic function with a penalty term. \nOverall, top heuristics tend to use simpler, more direct normalization and non-linear functions, while worse heuristics often introduce additional complexity or penalty terms.\n- \nTo redesign 'Current self-reflection' and come up with ideas to design better heuristics while avoiding 'Ineffective self-reflection', let's first analyze the given inputs.\n\n### Analysis\n\n- **Current self-reflection** suggests focusing on simple, normalized priority scores and non-linear functions that balance between tight fitting and future capacity, avoiding unnecessary complexity and penalty terms.\n- **Ineffective self-reflection** advises using simple, intuitive logic targeting the problem's objective directly, like minimizing waste. It suggests using non-linear functions to prioritize bins based on remaining capacity and considering the trade-off between tight fitting and future capacity, avoiding unnecessary normalization.\n\n### Redefining 'Current self-reflection'\n\nBy synthesizing insights from both, we can redefine 'Current self-reflection' to be more effective.\n\n### Response\n\nHere are the key points in 4 bullet points (<100 words):\n* **Keywords**: Simple logic, non-linear functions, balance, intuitive.\n* **Advice**: Use non-linear functions to balance tight fitting and future capacity; directly target the problem's objective.\n* **Avoid**: Unnecessary complexity, penalty terms, and normalization unless significantly impactful.\n* **Explanation**: By combining simplicity with non-linear prioritization, heuristics can effectively minimize waste and optimize bin usage, directly addressing the problem's objectives without unnecessary complications.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}