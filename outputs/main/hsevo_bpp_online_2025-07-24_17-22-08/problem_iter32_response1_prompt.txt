{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Improved priority function that balances tight fitting and future capacity with a simpler, more effective non-linear prioritization.\n    \"\"\"\n    # Identify valid bins\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    \n    # Calculate the remaining capacity after adding the item\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Simple and effective non-linear prioritization that focuses on tight fits while considering future capacity\n    priority = np.where(valid_bins == 1, \n                         np.exp(-remain_cap_after_add / (item + 1e-6)) + 0.1 * (remain_cap_after_add <= item / 2),  \n                         -np.inf)\n    \n    return priority\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    A mutated priority function that simplifies the calculation while maintaining a balance between tight fitting and future capacity.\n    \"\"\"\n    # Identify valid bins\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    \n    # Calculate the remaining capacity after adding the item\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Simplified non-linear prioritization focusing on tight fit with a consideration for future capacity\n    priority = np.where(valid_bins == 1, \n                         np.exp(-remain_cap_after_add / (item + 1e-6)) + 0.1 * (remain_cap_after_add / (bins_remain_cap + 1e-6)),  \n                         -np.inf)\n    \n    return priority\n\n### Analyze & experience\n- Comparing the top-ranked heuristics with the lower-ranked ones, we observe that the top heuristics tend to use a combination of non-linear prioritization and refined penalty terms to balance tight fitting and future capacity. For example, Heuristics 1st and 2nd use `np.exp` for non-linear prioritization and incorporate terms that consider both remaining capacity and item size. In contrast, lower-ranked heuristics like 19th and 20th, although similar in structure, lack the nuanced balancing terms seen in the top heuristics. Comparing (1st) vs (2nd), we see that both use non-linear prioritization but differ in their penalty terms; the 1st heuristic incorporates a more complex balancing term. (3rd) vs (4th) shows a similar pattern, with the 3rd using a simpler yet effective non-linear prioritization. Overall, the top heuristics strike a balance between complexity and effectiveness in their prioritization and penalty terms.\n- \nTo design better heuristics, let's analyze the given information. \n\n* **Keywords**: Non-linear prioritization, nuanced penalty terms, balancing tight fitting and future capacity.\n* **Advice**: Combine non-linear prioritization with refined penalty terms, and consider trade-offs between complexity and effectiveness.\n* **Avoid**: Unnecessary complexity, redundant code, and overly simplistic approaches that don't balance competing objectives.\n* **Explanation**: The goal is to create heuristics that effectively balance competing demands, such as tight fitting and future capacity, using non-linear prioritization and thoughtful penalty terms, while avoiding unnecessary complexity.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}