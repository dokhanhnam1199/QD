{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is based on the remaining capacity of the bin and the size of the item.\n    A bin with a remaining capacity that is just enough for the item will have the highest priority.\n    A bin that is too small for the item will have a priority of negative infinity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # First, we identify bins that are too small for the item and give them a very low priority\n    priority = np.where(bins_remain_cap >= item, bins_remain_cap - item, -np.inf)\n    \n    # Then, we normalize the priority scores so that the bin with the smallest remaining capacity \n    # that is still enough for the item gets the highest priority\n    priority = -priority\n    \n    # Return the priority scores\n    return priority\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    \n    The priority is calculated based on the remaining capacity of each bin. \n    The bin with the least remaining capacity that can still fit the item gets the highest priority.\n    \n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priority scores as negative infinity for bins that cannot fit the item\n    priority = np.where(bins_remain_cap >= item, bins_remain_cap, -np.inf)\n    \n    # Calculate the priority score as the negative of the remaining capacity after adding the item\n    # This gives higher priority to bins that are more full\n    priority = np.where(priority > -np.inf, -(priority - item), priority)\n    \n    return priority\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin based on \n    the remaining capacity and the item size.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin\n    # The priority score is high when the remaining capacity is just enough for the item\n    priority = np.where(bins_remain_cap >= item, 1 - (bins_remain_cap - item) / bins_remain_cap, -1)\n    \n    # Return the priority scores\n    return priority\n\n[Heuristics 4th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_capacity_after_addition = bins_remain_cap - item\n    \n    # We want to prioritize bins that have enough capacity for the item\n    # and have the least remaining capacity after adding the item\n    # to minimize waste\n    priority = np.where(\n        remaining_capacity_after_addition >= 0, \n        -remaining_capacity_after_addition,  # Lower remaining capacity is better\n        -np.inf  # Bins that cannot hold the item get -inf priority\n    )\n    \n    return priority\n\n[Heuristics 5th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    The priority is based on how well the item fits into the bin. \n    If the item fits perfectly into the bin, the priority is highest. \n    If the item is too large for the bin, the priority is lowest.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # For each bin, check if the item can fit into it\n    can_fit = bins_remain_cap >= item\n    \n    # Calculate the remaining capacity after adding the item\n    remaining_cap_after_add = bins_remain_cap - item\n    \n    # The priority is inversely proportional to the remaining capacity after adding the item\n    # and is 0 if the item cannot fit into the bin\n    priority = np.where(can_fit, 1 / (1 + remaining_cap_after_add), -1)\n    \n    return priority\n\n[Heuristics 6th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    \n    The priority is calculated based on the remaining capacity of each bin. \n    The bin with the least remaining capacity that can still fit the item gets the highest priority.\n    \n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priority scores as negative infinity for bins that cannot fit the item\n    priority = np.where(bins_remain_cap >= item, bins_remain_cap, -np.inf)\n    \n    # Calculate the priority score as the negative of the remaining capacity after adding the item\n    # This gives higher priority to bins that are more full\n    priority = np.where(priority > -np.inf, -(priority - item), priority)\n    \n    return priority\n\n[Heuristics 7th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    \n    The priority is calculated based on the remaining capacity of each bin.\n    The bin with the least remaining capacity that can still hold the item gets the highest priority.\n    \n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin\n    # The bin with remaining capacity closest to the item size gets the highest priority\n    priority = np.where(bins_remain_cap >= item, 1 - (bins_remain_cap - item) / bins_remain_cap, -1)\n    \n    # Return the priority score for each bin\n    return priority\n\n[Heuristics 8th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is higher for bins that have enough capacity to hold the item and \n    have less remaining capacity, indicating a tighter fit.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin\n    # The score is high if the bin has enough capacity and the remaining capacity is small\n    priority_scores = np.where(bins_remain_cap >= item, 1 / (bins_remain_cap + 1e-6), -1.0)\n    \n    return priority_scores\n\n[Heuristics 9th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    The priority is higher for bins that have enough capacity and are most full.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the capacity remaining after adding the item to each bin\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that do not have enough capacity for the item get a priority of -inf\n    # So they will not be chosen unless there are no other options\n    priority = np.where(remaining_after_addition >= 0, -remaining_after_addition, -np.inf)\n    \n    return priority\n\n[Heuristics 10th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    The priority is calculated based on the remaining capacity of the bin and the size of the item.\n    A higher priority is given to bins that have just enough remaining capacity to hold the item.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin based on the remaining capacity and item size\n    # A bin with remaining capacity closer to the item size gets higher priority\n    priority_scores = np.where(bins_remain_cap >= item, np.exp(-(bins_remain_cap - item)), 0)\n    \n    return priority_scores\n\n[Heuristics 11th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Check if the item can fit in the bin\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    \n    # Prioritize bins that have just enough capacity for the item\n    # The closer the remaining capacity to the item size, the higher the priority\n    priority = np.where(valid_bins == 1, bins_remain_cap - item, -np.inf)\n    \n    # To avoid division by zero, we add a small epsilon to the denominator\n    epsilon = 1e-6\n    priority = - (priority + epsilon) ** -1\n    \n    # Normalize the priority scores to be between 0 and 1\n    max_priority = np.max(priority)\n    min_priority = np.min(priority)\n    if max_priority != min_priority:\n        priority = (priority - min_priority) / (max_priority - min_priority)\n    else:\n        priority = np.ones_like(priority)\n    \n    # Set priority to zero for bins that cannot hold the item\n    priority = np.where(valid_bins == 1, priority, 0)\n    \n    return priority\n\n[Heuristics 12th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    \n    This function implements the First-Fit decreasing heuristic. \n    The bin with the highest remaining capacity that can fit the item is given the highest priority.\n    If no bin can fit the item, the priority is 0 for all bins.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Check if the item can fit in each bin\n    valid_bins = bins_remain_cap >= item\n    \n    # Initialize priority scores to negative infinity for bins that can't fit the item\n    priority_scores = np.where(valid_bins, bins_remain_cap, -np.inf)\n    \n    # Normalize the priority scores to be between 0 and 1\n    max_cap = np.max(priority_scores)\n    if max_cap == -np.inf:  # No bin can fit the item\n        return np.zeros_like(bins_remain_cap)\n    else:\n        priority_scores = np.where(valid_bins, (priority_scores - np.min(priority_scores[valid_bins])) / (max_cap - np.min(priority_scores[valid_bins])), 0)\n        \n    return priority_scores\n\n[Heuristics 13th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Check if the item can fit in the bin\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    \n    # Prioritize bins that have just enough capacity for the item\n    # The closer the remaining capacity to the item size, the higher the priority\n    priority = np.where(valid_bins == 1, bins_remain_cap - item, -np.inf)\n    \n    # To avoid division by zero, we add a small epsilon to the denominator\n    epsilon = 1e-6\n    priority = - (priority + epsilon) ** -1\n    \n    # Normalize the priority scores to be between 0 and 1\n    max_priority = np.max(priority)\n    min_priority = np.min(priority)\n    if max_priority != min_priority:\n        priority = (priority - min_priority) / (max_priority - min_priority)\n    else:\n        priority = np.ones_like(priority)\n    \n    # Set priority to zero for bins that cannot hold the item\n    priority = np.where(valid_bins == 1, priority, 0)\n    \n    return priority\n\n[Heuristics 14th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    \n    This function implements the First-Fit decreasing heuristic. \n    The bin with the highest remaining capacity that can fit the item is given the highest priority.\n    If no bin can fit the item, the priority is 0 for all bins.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Check if the item can fit in each bin\n    valid_bins = bins_remain_cap >= item\n    \n    # Initialize priority scores to negative infinity for bins that can't fit the item\n    priority_scores = np.where(valid_bins, bins_remain_cap, -np.inf)\n    \n    # Normalize the priority scores to be between 0 and 1\n    max_cap = np.max(priority_scores)\n    if max_cap == -np.inf:  # No bin can fit the item\n        return np.zeros_like(bins_remain_cap)\n    else:\n        priority_scores = np.where(valid_bins, (priority_scores - np.min(priority_scores[valid_bins])) / (max_cap - np.min(priority_scores[valid_bins])), 0)\n        \n    return priority_scores\n\n[Heuristics 15th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Check if the item can fit in the bin\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    \n    # Prioritize bins that have just enough capacity for the item\n    # The closer the remaining capacity to the item size, the higher the priority\n    priority = np.where(valid_bins == 1, bins_remain_cap - item, -np.inf)\n    \n    # To avoid division by zero, we add a small epsilon to the denominator\n    epsilon = 1e-6\n    priority = - (priority + epsilon) ** -1\n    \n    # Normalize the priority scores to be between 0 and 1\n    max_priority = np.max(priority)\n    min_priority = np.min(priority)\n    if max_priority != min_priority:\n        priority = (priority - min_priority) / (max_priority - min_priority)\n    else:\n        priority = np.ones_like(priority)\n    \n    # Set priority to zero for bins that cannot hold the item\n    priority = np.where(valid_bins == 1, priority, 0)\n    \n    return priority\n\n[Heuristics 16th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    \n    This function implements the First-Fit decreasing heuristic. \n    The bin with the highest remaining capacity that can fit the item is given the highest priority.\n    If no bin can fit the item, the priority is 0 for all bins.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Check if the item can fit in each bin\n    valid_bins = bins_remain_cap >= item\n    \n    # Initialize priority scores to negative infinity for bins that can't fit the item\n    priority_scores = np.where(valid_bins, bins_remain_cap, -np.inf)\n    \n    # Normalize the priority scores to be between 0 and 1\n    max_cap = np.max(priority_scores)\n    if max_cap == -np.inf:  # No bin can fit the item\n        return np.zeros_like(bins_remain_cap)\n    else:\n        priority_scores = np.where(valid_bins, (priority_scores - np.min(priority_scores[valid_bins])) / (max_cap - np.min(priority_scores[valid_bins])), 0)\n        \n    return priority_scores\n\n[Heuristics 17th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    The priority is calculated based on the remaining capacity of each bin. \n    The bin with the least remaining capacity that can still fit the item gets the highest priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin\n    # The bin with remaining capacity closest to the item size gets the highest priority\n    priority = np.where(bins_remain_cap >= item, bins_remain_cap.max() - bins_remain_cap, bins_remain_cap.max() + 1)\n    \n    # Normalize the priority scores to be between 0 and 1\n    priority = np.maximum(0, 1 - (priority - priority.min()) / (priority.max() - priority.min() + 1e-9))\n    \n    return priority\n\n[Heuristics 18th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Check if the item can fit in the bin\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    \n    # Prioritize bins that have just enough capacity for the item\n    # The closer the remaining capacity to the item size, the higher the priority\n    priority = np.where(valid_bins == 1, bins_remain_cap - item, -np.inf)\n    \n    # To avoid division by zero, we add a small epsilon to the denominator\n    epsilon = 1e-6\n    priority = - (priority + epsilon) ** -1\n    \n    # Normalize the priority scores to be between 0 and 1\n    max_priority = np.max(priority)\n    min_priority = np.min(priority)\n    if max_priority != min_priority:\n        priority = (priority - min_priority) / (max_priority - min_priority)\n    else:\n        priority = np.ones_like(priority)\n    \n    # Set priority to zero for bins that cannot hold the item\n    priority = np.where(valid_bins == 1, priority, 0)\n    \n    return priority\n\n[Heuristics 19th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    The priority is calculated based on the remaining capacity of each bin. \n    The bin with the least remaining capacity that can still fit the item gets the highest priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin\n    # The bin with remaining capacity closest to the item size gets the highest priority\n    priority = np.where(bins_remain_cap >= item, bins_remain_cap.max() - bins_remain_cap, bins_remain_cap.max() + 1)\n    \n    # Normalize the priority scores to be between 0 and 1\n    priority = np.maximum(0, 1 - (priority - priority.min()) / (priority.max() - priority.min() + 1e-9))\n    \n    return priority\n\n[Heuristics 20th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    \n    This function implements the First-Fit decreasing heuristic. \n    The bin with the highest remaining capacity that can fit the item is given the highest priority.\n    If no bin can fit the item, the priority is 0 for all bins.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Check if the item can fit in each bin\n    valid_bins = bins_remain_cap >= item\n    \n    # Initialize priority scores to negative infinity for bins that can't fit the item\n    priority_scores = np.where(valid_bins, bins_remain_cap, -np.inf)\n    \n    # Normalize the priority scores to be between 0 and 1\n    max_cap = np.max(priority_scores)\n    if max_cap == -np.inf:  # No bin can fit the item\n        return np.zeros_like(bins_remain_cap)\n    else:\n        priority_scores = np.where(valid_bins, (priority_scores - np.min(priority_scores[valid_bins])) / (max_cap - np.min(priority_scores[valid_bins])), 0)\n        \n    return priority_scores\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}