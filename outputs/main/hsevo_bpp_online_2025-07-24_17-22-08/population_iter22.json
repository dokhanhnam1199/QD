[
  {
    "stdout_filepath": "problem_iter20_response0.txt_stdout.txt",
    "code_path": "problem_iter20_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a refined balance between tight fitting and future capacity.\n    Uses np.exp for non-linear prioritization and a bonus term for remaining capacity.\n    \"\"\"\n    # Non-linear prioritization for valid bins\n    priority = np.where(bins_remain_cap >= item, np.exp(-(bins_remain_cap - item) / (bins_remain_cap + 1e-6)), -np.inf)\n    \n    # Refined balancing term considering remaining capacity and a logarithmic adjustment\n    valid_bins = priority != -np.inf\n    if np.any(valid_bins):\n        priority[valid_bins] += 1e-6 * bins_remain_cap[valid_bins] + np.log(bins_remain_cap[valid_bins] - item + 1)\n        \n    return priority",
    "response_id": 0,
    "tryHS": false,
    "obj": 149.30195452732352,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 98.09910819000817,
    "mi": 91.72766838010844,
    "token_count": 106.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response1.txt_stdout.txt",
    "code_path": "problem_iter20_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a refined balancing term for tight fitting and future capacity.\n    Utilizes np.exp for prioritization and a ratio for balancing, avoiding unnecessary complexity.\n    \"\"\"\n    # Non-linear prioritization for valid bins\n    priority = np.where(bins_remain_cap >= item, np.exp(-(bins_remain_cap - item) / item), -np.inf)\n    \n    # Refined balancing term: prioritize bins that are not too full\n    valid_bins = priority != -np.inf\n    if np.any(valid_bins):\n        remaining_cap_after_addition = bins_remain_cap[valid_bins] - item\n        # Balance between tight fitting and future capacity using a simple ratio\n        priority[valid_bins] *= (1 - (remaining_cap_after_addition / bins_remain_cap[valid_bins]))\n        # Normalize to emphasize the importance of tight fitting\n        priority[valid_bins] = - (bins_remain_cap[valid_bins] - item)\n        \n    return priority",
    "response_id": 1,
    "tryHS": true,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 98.09910819000817,
    "mi": 91.72766838010844,
    "token_count": 106.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response2.txt_stdout.txt",
    "code_path": "problem_iter20_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Improved heuristic combining non-linear prioritization with a refined penalty term \n    to balance tight fitting and future capacity effectively.\n    \"\"\"\n    # Calculate remaining capacity after adding the item\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Non-linear prioritization with a refined penalty for large remaining capacity\n    priority = np.where(bins_remain_cap >= item, \n                         np.exp(-remain_cap_after_add / item) - 0.01 * remain_cap_after_add, \n                         -np.inf)\n    \n    return priority",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 98.09910819000817,
    "mi": 91.72766838010844,
    "token_count": 106.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response3.txt_stdout.txt",
    "code_path": "problem_iter20_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for each bin based on a refined non-linear function \n    that balances tight fitting and future capacity, combining exp and log terms.\n    \"\"\"\n    # Use a non-linear function combining exp and log terms for prioritization\n    priority = np.where(bins_remain_cap >= item, \n                        np.exp(-(bins_remain_cap - item) / (bins_remain_cap + 1e-6)) + np.log(bins_remain_cap - item + 1), \n                        -np.inf)\n    return priority",
    "response_id": 3,
    "tryHS": false,
    "obj": 149.30195452732352,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 98.09910819000817,
    "mi": 91.72766838010844,
    "token_count": 106.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response4.txt_stdout.txt",
    "code_path": "problem_iter20_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a balancing term for tight fitting and future capacity.\n    Uses np.exp(-(bins_remain_cap - item)) and a balancing term (bins_remain_cap - item) / bins_remain_cap for valid bins.\n    \"\"\"\n    # Identify valid bins and assign a very low priority to invalid bins\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    priority = np.where(valid_bins == 1, np.exp(-(bins_remain_cap - item)), -np.inf)\n    \n    # Apply a balancing term to valid bins\n    priority = np.where(valid_bins == 1, priority * ((bins_remain_cap - item) / bins_remain_cap), priority)\n    \n    return priority",
    "response_id": 4,
    "tryHS": false,
    "obj": 5.195452732349436,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 98.09910819000817,
    "mi": 91.72766838010844,
    "token_count": 106.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response5.txt_stdout.txt",
    "code_path": "problem_iter20_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a refined balancing term.\n    Uses exp function and a penalty for large remaining capacity with a bonus for remaining capacity after addition.\n    \"\"\"\n    # Non-linear prioritization for valid bins\n    priority = np.where(bins_remain_cap >= item, np.exp(-(bins_remain_cap - item) / item), -np.inf)\n    \n    # Refined balancing term\n    valid_bins = priority != -np.inf\n    if np.any(valid_bins):\n        remaining_cap_after_addition = bins_remain_cap[valid_bins] - item\n        # Combine penalty for large remaining capacity with a bonus for remaining capacity after addition\n        priority[valid_bins] *= 1 / (1 + bins_remain_cap[valid_bins] - item)\n        priority[valid_bins] += 1e-6 * remaining_cap_after_addition\n        \n    return priority",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.058635819704831,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 98.09910819000817,
    "mi": 91.72766838010844,
    "token_count": 106.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response6.txt_stdout.txt",
    "code_path": "problem_iter20_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a refined balancing term for tight fitting and future capacity.\n    Uses exp function and considers remaining capacity after addition for balancing.\n    \"\"\"\n    # Identify bins that are too small for the item and give them a very low priority\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Non-linear priority with a refined balance term for valid bins\n    priority = np.where(valid_bins == 1, \n                         np.exp(-remaining_cap_after_addition / item) *  # Non-linear prioritization\n                         (1 / (1 + remaining_cap_after_addition)) +     # Balancing term\n                         1e-6 * remaining_cap_after_addition,           # Small bonus for remaining capacity\n                         -np.inf)\n    \n    return priority",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.058635819704831,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 98.09910819000817,
    "mi": 91.72766838010844,
    "token_count": 106.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response7.txt_stdout.txt",
    "code_path": "problem_iter20_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a balancing term for tight fitting and future capacity.\n    Uses np.exp for prioritization and a ratio for balancing, with a penalty for large remaining capacity.\n    \"\"\"\n    # Calculate remaining capacity after adding the item\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Non-linear prioritization with a penalty for large remaining capacity\n    priority = np.where(bins_remain_cap >= item, \n                         np.exp(-remain_cap_after_add / item) * (remain_cap_after_add / bins_remain_cap) - 0.01 * bins_remain_cap, \n                         -np.inf)\n    \n    return priority",
    "response_id": 7,
    "tryHS": false,
    "obj": 7.319505384922227,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 98.09910819000817,
    "mi": 91.72766838010844,
    "token_count": 106.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response8.txt_stdout.txt",
    "code_path": "problem_iter20_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for each bin based on a non-linear function of remaining capacity and item size.\n    Combines exp function for prioritization and a balancing term to manage tight fitting and future capacity.\n    \"\"\"\n    # Calculate priority using a combination of exp function and a balancing term\n    priority = np.where(bins_remain_cap >= item, \n                        np.exp(-(bins_remain_cap - item) / (item + 1e-6)) + np.log(bins_remain_cap - item + 1), \n                        -np.inf)\n    return priority",
    "response_id": 8,
    "tryHS": false,
    "obj": 149.30195452732352,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 98.09910819000817,
    "mi": 91.72766838010844,
    "token_count": 106.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response9.txt_stdout.txt",
    "code_path": "problem_iter20_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a balance term for tight fitting and future capacity.\n    Uses np.exp(-(bins_remain_cap - item)) and a balancing term for valid bins.\n    \"\"\"\n    # Non-linear prioritization for valid bins\n    priority = np.where(bins_remain_cap >= item, np.exp(-(bins_remain_cap - item)), -np.inf)\n    \n    # Apply a balancing term to valid bins\n    valid_bins = priority != -np.inf\n    if np.any(valid_bins):\n        remaining_cap_after_addition = bins_remain_cap[valid_bins] - item\n        # Balance between tight fitting and future capacity\n        priority[valid_bins] *= (remaining_cap_after_addition / bins_remain_cap[valid_bins])\n        \n    return priority",
    "response_id": 9,
    "tryHS": false,
    "obj": 5.195452732349436,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 98.09910819000817,
    "mi": 91.72766838010844,
    "token_count": 106.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter21_response0.txt_stdout.txt",
    "code_path": "problem_iter21_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is based on the remaining capacity of the bin and the size of the item.\n    A bin with a remaining capacity that is just enough for the item will have the highest priority.\n    A bin that is too small for the item will have a priority of negative infinity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # First, we identify bins that are too small for the item and give them a very low priority\n    priority = np.where(bins_remain_cap >= item, np.exp(-(bins_remain_cap - item)), -np.inf)\n    \n    # Then, we normalize the priority scores so that the bin with the most suitable remaining capacity \n    # gets the highest priority, considering both tight fitting and future capacity\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:\n        priority = priority / max_priority\n    \n    # Return the priority scores\n    return priority",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 112.0,
    "mi": 47.902453501477574,
    "token_count": 102.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter21_response1.txt_stdout.txt",
    "code_path": "problem_iter21_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is based on a non-linear combination of the remaining capacity of the bin and the size of the item.\n    A bin with a remaining capacity that is just enough for the item will have a high priority, \n    while also considering the future capacity of the bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # First, we identify bins that are too small for the item and give them a very low priority\n    priority = np.where(bins_remain_cap >= item, np.exp(-(bins_remain_cap - item)), -np.inf)\n    \n    # Then, we add a balancing term to the priority scores to consider the future capacity of the bin\n    priority = np.where(bins_remain_cap >= item, priority * (bins_remain_cap / (bins_remain_cap - item + 1e-6)), priority)\n    \n    # Return the priority scores\n    return priority",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 112.0,
    "mi": 47.902453501477574,
    "token_count": 102.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter21_response2.txt_stdout.txt",
    "code_path": "problem_iter21_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is based on a non-linear function of the remaining capacity of the bin and the size of the item.\n    A bin with a remaining capacity that is just enough for the item will have the highest priority.\n    A bin that is too small for the item will have a priority of negative infinity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Identify bins that are too small for the item and give them a very low priority\n    priority = np.where(bins_remain_cap >= item, np.exp(-(bins_remain_cap - item)), -np.inf)\n    \n    # Normalize the priority scores so that the bin with the best fit gets the highest priority\n    # max_priority = np.max(priority)\n    # if max_priority != -np.inf:\n    #     priority = np.where(priority != -np.inf, priority / max_priority, -np.inf)\n    \n    # Return the priority scores\n    return priority",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 112.0,
    "mi": 47.902453501477574,
    "token_count": 102.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter21_response3.txt_stdout.txt",
    "code_path": "problem_iter21_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is based on a non-linear combination of the remaining capacity of the bin and the size of the item.\n    It balances between tight fitting and leaving sufficient future capacity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # First, we identify bins that are too small for the item and give them a very low priority\n    too_small = bins_remain_cap < item\n    \n    # For bins that can fit the item, we calculate a priority score that balances between \n    # having just enough capacity (tight fitting) and having more capacity left for future items\n    enough_capacity = ~too_small\n    priority = np.zeros_like(bins_remain_cap)\n    priority[enough_capacity] = -((bins_remain_cap[enough_capacity] - item) ** 2) + bins_remain_cap[enough_capacity] / (item + 1e-6)\n    \n    # Bins that are too small get a very low priority\n    priority[too_small] = -np.inf\n    \n    # Return the priority scores\n    return priority",
    "response_id": 3,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 28, in priority_v2\nOverflowError: cannot convert float infinity to integer\n4\n1\n112.0\n47.902453501477574\n102\n"
  },
  {
    "stdout_filepath": "problem_iter21_response4.txt_stdout.txt",
    "code_path": "problem_iter21_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is based on a non-linear combination of the remaining capacity of the bin and the size of the item.\n    A bin with a remaining capacity that is just enough for the item will have the highest priority.\n    A bin that is too small for the item will have a priority of negative infinity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # First, we identify bins that are too small for the item and give them a very low priority\n    priority = np.where(bins_remain_cap >= item, np.exp(-(bins_remain_cap - item)), -np.inf)\n    \n    # Then, we apply a penalty to bins that are too large for the item, to avoid wasting space\n    # We use a sigmoid-like function to penalize large remaining capacities\n    priority = np.where(bins_remain_cap >= item, priority * (1 / (1 + np.exp((bins_remain_cap - item) / item))), priority)\n    \n    # Return the priority scores\n    return priority",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 112.0,
    "mi": 47.902453501477574,
    "token_count": 102.0,
    "exec_success": true
  }
]