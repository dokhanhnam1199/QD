{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, \n                penalty_weight: float = 0.015962034932029284, \n                perturbation_max: float = 8.082068759055226e-06) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with nuanced penalty terms, \n    balancing tight fit and future capacity effectively with slight perturbation.\n    \"\"\"\n    # Identify valid bins and calculate remaining capacity after adding the item\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Non-linear prioritization focusing on tight fit\n    tight_fit_score = np.exp(-remain_cap_after_add / (item + 1e-6))\n    tight_fit_measure = item / bins_remain_cap\n    \n    # Refined penalty term for future capacity and balancing\n    future_capacity_penalty = (1 / (1 + np.exp((remain_cap_after_add - item/2) / item)))\n    \n    # Combine scores with a refined penalty term for better adaptability and robustness\n    priority = np.where(valid_bins == 1, \n                         0.7 * tight_fit_score * (1 + tight_fit_measure) + 0.3 * future_capacity_penalty - penalty_weight * remain_cap_after_add, \n                         -np.inf)\n    \n    # Normalize priority scores\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:\n        priority = priority / max_priority\n    \n    # Introduce a slight perturbation to avoid identical priorities for different bins\n    priority += np.random.uniform(0, perturbation_max, size=len(priority))\n    \n    return priority\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, \n                penalty_weight: float = 0.015962034932029284, \n                perturbation_max: float = 8.082068759055226e-06) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a refined penalty term, \n    balancing tight fit and future capacity for online bin packing.\n    \"\"\"\n    # Calculate valid bins and remaining capacity after adding the item\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Non-linear prioritization focusing on tight fit and future capacity\n    tight_fit_score = np.exp(-remain_cap_after_add / (item + 1e-6))\n    tight_fit_measure = item / bins_remain_cap\n    \n    # Combine scores with a weighted average, apply a refined penalty term, \n    # and incorporate a tight fit measure for enhanced prioritization\n    priority = np.where(valid_bins == 1, \n                         (0.7 * tight_fit_score + 0.3 * (tight_fit_measure)) - penalty_weight * remain_cap_after_add, \n                         -np.inf)\n    \n    # Normalize priority scores for better adaptability and robustness\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:\n        priority = priority / max_priority\n    \n    # Introduce a slight perturbation to avoid identical priorities for different bins\n    priority += np.random.uniform(0, perturbation_max, size=len(priority))\n    \n    return priority\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, \n                penalty_weight: float = 0.015962034932029284, \n                perturbation_max: float = 8.082068759055226e-06) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a refined penalty term, \n    balancing tight fit and future capacity for online bin packing.\n    \"\"\"\n    # Calculate valid bins and remaining capacity after adding the item\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Non-linear prioritization focusing on tight fit and future capacity\n    tight_fit_score = np.exp(-remain_cap_after_add / (item + 1e-6))\n    tight_fit_measure = item / bins_remain_cap\n    \n    # Combine scores with a weighted average, apply a refined penalty term, \n    # and incorporate a tight fit measure for enhanced prioritization\n    priority = np.where(valid_bins == 1, \n                         (0.7 * tight_fit_score + 0.3 * (tight_fit_measure)) - penalty_weight * remain_cap_after_add, \n                         -np.inf)\n    \n    # Normalize priority scores for better adaptability and robustness\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:\n        priority = priority / max_priority\n    \n    # Introduce a slight perturbation to avoid identical priorities for different bins\n    priority += np.random.uniform(0, perturbation_max, size=len(priority))\n    \n    return priority\n\n[Heuristics 4th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, \n                penalty_weight: float = 0.015962034932029284, \n                perturbation_max: float = 8.082068759055226e-06) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a refined penalty term, \n    balancing tight fit and future capacity for online bin packing.\n    \"\"\"\n    # Calculate valid bins and remaining capacity after adding the item\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Non-linear prioritization focusing on tight fit and future capacity\n    tight_fit_score = np.exp(-remain_cap_after_add / (item + 1e-6))\n    tight_fit_measure = item / bins_remain_cap\n    \n    # Combine scores with a weighted average, apply a refined penalty term, \n    # and incorporate a tight fit measure for enhanced prioritization\n    priority = np.where(valid_bins == 1, \n                         (0.7 * tight_fit_score + 0.3 * (tight_fit_measure)) - penalty_weight * remain_cap_after_add, \n                         -np.inf)\n    \n    # Normalize priority scores for better adaptability and robustness\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:\n        priority = priority / max_priority\n    \n    # Introduce a slight perturbation to avoid identical priorities for different bins\n    priority += np.random.uniform(0, perturbation_max, size=len(priority))\n    \n    return priority\n\n[Heuristics 5th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, \n                alpha: float = 0.7, beta: float = 0.3, \n                penalty_weight: float = 0.01, \n                perturbation_max: float = 1e-5) -> np.ndarray:\n    \"\"\"\n    Advanced priority function that adaptively balances tight fit and future capacity with nuanced non-linear prioritization.\n    \"\"\"\n    # Identify valid bins\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    \n    # Calculate tight fit measure and future capacity penalty\n    tight_fit_measure = np.exp(-(bins_remain_cap - item) / item)\n    future_capacity_penalty = np.where(bins_remain_cap - item > 0, \n                                       (bins_remain_cap - item) / bins_remain_cap, \n                                       0)\n    \n    # Combine tight fit and future capacity with adaptive weights\n    priority = np.where(valid_bins == 1, \n                         alpha * tight_fit_measure + beta * (1 - future_capacity_penalty) - penalty_weight * (bins_remain_cap - item), \n                         -np.inf)\n    \n    # Normalize priority scores for adaptability\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:\n        priority = priority / max_priority\n    \n    # Introduce slight perturbation\n    priority += np.random.uniform(0, perturbation_max, size=len(priority))\n    \n    return priority\n\n[Heuristics 6th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, \n                alpha: float = 0.7, beta: float = 0.3, \n                penalty_weight: float = 0.01, \n                perturbation_max: float = 1e-5) -> np.ndarray:\n    \"\"\"\n    Advanced priority function that adaptively balances tight fit and future capacity with nuanced non-linear prioritization.\n    \"\"\"\n    # Identify valid bins\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    \n    # Calculate tight fit measure and future capacity penalty\n    tight_fit_measure = np.exp(-(bins_remain_cap - item) / item)\n    future_capacity_penalty = np.where(bins_remain_cap - item > 0, \n                                       (bins_remain_cap - item) / bins_remain_cap, \n                                       0)\n    \n    # Combine tight fit and future capacity with adaptive weights\n    priority = np.where(valid_bins == 1, \n                         alpha * tight_fit_measure + beta * (1 - future_capacity_penalty) - penalty_weight * (bins_remain_cap - item), \n                         -np.inf)\n    \n    # Normalize priority scores for adaptability\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:\n        priority = priority / max_priority\n    \n    # Introduce slight perturbation\n    priority += np.random.uniform(0, perturbation_max, size=len(priority))\n    \n    return priority\n\n[Heuristics 7th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a dynamic penalty term, \n    balancing tight fit and future capacity effectively.\n    \"\"\"\n    # Identify valid bins and calculate remaining capacity after adding the item\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Non-linear prioritization focusing on tight fit\n    tight_fit_score = np.exp(-remain_cap_after_add / (item + 1e-6))\n    \n    # Dynamic penalty term for future capacity and balancing\n    future_capacity_penalty = 1 - (remain_cap_after_add / (bins_remain_cap + 1e-6))  # Simplified penalty term\n    \n    # Combine scores for better adaptability\n    priority = np.where(valid_bins == 1, \n                         0.7 * tight_fit_score + 0.3 * future_capacity_penalty, \n                         -np.inf)\n    \n    # Enhance differentiation among valid bins by applying a non-linear scaling\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:\n        priority = np.where(priority != -np.inf, (priority / max_priority) ** 1.5, -np.inf)  # Adjusted exponent for better differentiation\n    \n    return priority\n\n[Heuristics 8th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a dynamic penalty term for effective bin selection.\n    Balances tight fitting and future capacity using a ratio-based penalty and exponential decay.\n    \"\"\"\n    # Identify valid bins and calculate remaining capacity after adding the item\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Non-linear prioritization for valid bins with a penalty term for tight fits\n    priority = np.where(valid_bins == 1, 1 / (1 + np.abs(bins_remain_cap - item)), -np.inf)\n    \n    # Dynamic penalty term based on the proportion of remaining capacity\n    penalty_term = np.exp(-remain_cap_after_add / (item + 1e-6))  # Avoids division by zero\n    \n    # Combine prioritization and penalty term\n    priority *= penalty_term\n    \n    # Normalize priority scores for better adaptability\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:\n        priority = priority / max_priority\n    \n    return priority\n\n[Heuristics 9th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a dynamic penalty term, \n    balancing tight fit and future capacity effectively.\n    \"\"\"\n    # Identify valid bins and calculate remaining capacity after adding the item\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Non-linear prioritization focusing on tight fit\n    tight_fit_score = np.exp(-remain_cap_after_add / (item + 1e-6))\n    \n    # Dynamic penalty term for future capacity and balancing\n    future_capacity_penalty = 1 - (remain_cap_after_add / (bins_remain_cap + 1e-6))  # Simplified penalty term\n    \n    # Combine scores for better adaptability\n    priority = np.where(valid_bins == 1, \n                         0.7 * tight_fit_score + 0.3 * future_capacity_penalty, \n                         -np.inf)\n    \n    # Enhance differentiation among valid bins by applying a non-linear scaling\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:\n        priority = np.where(priority != -np.inf, (priority / max_priority) ** 1.5, -np.inf)  # Adjusted exponent for better differentiation\n    \n    return priority\n\n[Heuristics 10th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a dynamic penalty term for effective bin selection.\n    Balances tight fitting and future capacity using a ratio-based penalty and exponential decay.\n    \"\"\"\n    # Identify valid bins and calculate remaining capacity after adding the item\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Non-linear prioritization for valid bins with a penalty term for tight fits\n    priority = np.where(valid_bins == 1, 1 / (1 + np.abs(bins_remain_cap - item)), -np.inf)\n    \n    # Dynamic penalty term based on the proportion of remaining capacity\n    penalty_term = np.exp(-remain_cap_after_add / (item + 1e-6))  # Avoids division by zero\n    \n    # Combine prioritization and penalty term\n    priority *= penalty_term\n    \n    # Normalize priority scores for better adaptability\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:\n        priority = priority / max_priority\n    \n    return priority\n\n[Heuristics 11th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a nuanced penalty term and a tight fit bonus.\n    Balances tight fitting and future capacity for effective bin packing.\n    \"\"\"\n    # Identify valid bins and calculate remaining capacity after adding the item\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Non-linear prioritization with a dynamic penalty term\n    proportion_remain = remain_cap_after_add / item\n    priority = np.where(valid_bins == 1, np.exp(-proportion_remain), -np.inf)\n    \n    # Refined penalty term to balance tight fitting and future capacity\n    valid_bins_idx = np.where(valid_bins == 1)[0]\n    if len(valid_bins_idx) > 0:\n        balancing_term = 1 / (1 + np.abs(bins_remain_cap[valid_bins_idx] - item))\n        priority[valid_bins_idx] *= balancing_term\n        \n    # Apply a bonus for bins with very tight fits to encourage efficient packing\n    tight_fit_bonus = np.where((remain_cap_after_add > 0) & (remain_cap_after_add < 0.1 * item), 0.1, 0)\n    priority += tight_fit_bonus\n    \n    # Normalize priority scores for adaptability\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:\n        priority = priority / max_priority\n    else:\n        priority = valid_bins - 1  # When all bins are invalid, return -1 for invalid bins\n    \n    return priority\n\n[Heuristics 12th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a nuanced penalty term and a tight fit bonus.\n    Balances tight fitting and future capacity for effective bin packing.\n    \"\"\"\n    # Identify valid bins and calculate remaining capacity after adding the item\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Non-linear prioritization with a dynamic penalty term\n    proportion_remain = remain_cap_after_add / item\n    priority = np.where(valid_bins == 1, np.exp(-proportion_remain), -np.inf)\n    \n    # Refined penalty term to balance tight fitting and future capacity\n    valid_bins_idx = np.where(valid_bins == 1)[0]\n    if len(valid_bins_idx) > 0:\n        balancing_term = 1 / (1 + np.abs(bins_remain_cap[valid_bins_idx] - item))\n        priority[valid_bins_idx] *= balancing_term\n        \n    # Apply a bonus for bins with very tight fits to encourage efficient packing\n    tight_fit_bonus = np.where((remain_cap_after_add > 0) & (remain_cap_after_add < 0.1 * item), 0.1, 0)\n    priority += tight_fit_bonus\n    \n    # Normalize priority scores for adaptability\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:\n        priority = priority / max_priority\n    else:\n        priority = valid_bins - 1  # When all bins are invalid, return -1 for invalid bins\n    \n    return priority\n\n[Heuristics 13th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, \n                alpha: float = 0.7, beta: float = 0.3, \n                penalty_weight: float = 0.01, \n                perturbation_max: float = 1e-5) -> np.ndarray:\n    \"\"\"\n    Advanced priority function that adaptively balances tight fit and future capacity with nuanced penalty terms.\n    \"\"\"\n    # Identify valid bins\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    \n    # Calculate tight fit measure and future capacity penalty\n    tight_fit_measure = np.exp(-(bins_remain_cap - item) / item)\n    future_capacity_penalty = penalty_weight * (bins_remain_cap - item) / bins_remain_cap\n    \n    # Combine tight fit and future capacity with adaptive weighting\n    priority = np.where(valid_bins == 1, \n                         alpha * tight_fit_measure - beta * future_capacity_penalty, \n                         -np.inf)\n    \n    # Normalize priority scores while avoiding division by -inf\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:\n        priority = priority / max_priority\n    \n    # Introduce a slight perturbation to break ties\n    priority += np.random.uniform(0, perturbation_max, size=len(priority))\n    \n    return priority\n\n[Heuristics 14th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, \n                alpha: float = 0.7, beta: float = 0.3, \n                penalty_weight: float = 0.01, \n                perturbation_max: float = 1e-5) -> np.ndarray:\n    \"\"\"\n    Advanced priority function that adaptively balances tight fit and future capacity with nuanced penalty terms.\n    \"\"\"\n    # Identify valid bins\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    \n    # Calculate tight fit measure and future capacity penalty\n    tight_fit_measure = np.exp(-(bins_remain_cap - item) / item)\n    future_capacity_penalty = penalty_weight * (bins_remain_cap - item) / bins_remain_cap\n    \n    # Combine tight fit and future capacity with adaptive weighting\n    priority = np.where(valid_bins == 1, \n                         alpha * tight_fit_measure - beta * future_capacity_penalty, \n                         -np.inf)\n    \n    # Normalize priority scores while avoiding division by -inf\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:\n        priority = priority / max_priority\n    \n    # Introduce a slight perturbation to break ties\n    priority += np.random.uniform(0, perturbation_max, size=len(priority))\n    \n    return priority\n\n[Heuristics 15th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, \n                penalty_weight: float = 0.01, \n                perturbation_max: float = 1e-5) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with nuanced penalty terms, \n    balancing tight fitting and future capacity.\n    \"\"\"\n    # Identify valid bins and calculate remaining capacity after adding the item\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Calculate tight fit measure and non-linear penalty term\n    tight_fit_measure = item / bins_remain_cap\n    penalty_term = -np.log1p(remain_cap_after_add / item)  # Non-linear penalty term\n    \n    # Combine non-linear prioritization with nuanced penalty terms\n    priority = np.where(valid_bins == 1, \n                         np.exp(-remain_cap_after_add / item) * (1 + tight_fit_measure) + penalty_weight * penalty_term, \n                         -np.inf)\n    \n    # Normalize priority scores and introduce slight perturbation\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:\n        priority = priority / max_priority\n    priority += np.random.uniform(0, perturbation_max, size=len(priority))\n    \n    return priority\n\n[Heuristics 16th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, \n                penalty_weight: float = 0.01, \n                perturbation_max: float = 1e-5) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with nuanced penalty terms, \n    balancing tight fitting and future capacity.\n    \"\"\"\n    # Identify valid bins and calculate remaining capacity after adding the item\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Calculate tight fit measure and non-linear penalty term\n    tight_fit_measure = item / bins_remain_cap\n    penalty_term = -np.log1p(remain_cap_after_add / item)  # Non-linear penalty term\n    \n    # Combine non-linear prioritization with nuanced penalty terms\n    priority = np.where(valid_bins == 1, \n                         np.exp(-remain_cap_after_add / item) * (1 + tight_fit_measure) + penalty_weight * penalty_term, \n                         -np.inf)\n    \n    # Normalize priority scores and introduce slight perturbation\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:\n        priority = priority / max_priority\n    priority += np.random.uniform(0, perturbation_max, size=len(priority))\n    \n    return priority\n\n[Heuristics 17th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, \n                alpha: float = 0.7, beta: float = 0.3, \n                penalty_weight: float = 0.01, \n                perturbation_max: float = 1e-5) -> np.ndarray:\n    \"\"\"\n    Advanced priority function that adaptively balances tight fit and future capacity with nuanced non-linear prioritization.\n    \"\"\"\n    # Identify valid bins\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    \n    # Calculate tight fit measure and future capacity penalty\n    tight_fit_measure = np.exp(-(bins_remain_cap - item) / item)\n    future_capacity_penalty = np.where(bins_remain_cap - item > 0, \n                                        (bins_remain_cap - item) / bins_remain_cap, \n                                        1)\n    \n    # Non-linear prioritization balancing tight fit and future capacity\n    priority = np.where(valid_bins == 1, \n                         alpha * tight_fit_measure + beta * (1 - future_capacity_penalty) - penalty_weight * (bins_remain_cap - item), \n                         -np.inf)\n    \n    # Normalize priority scores for adaptability\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:\n        priority = priority / max_priority\n    \n    # Introduce slight perturbation to avoid identical priorities\n    priority += np.random.uniform(0, perturbation_max, size=len(priority))\n    \n    return priority\n\n[Heuristics 18th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, \n                alpha: float = 0.7, beta: float = 0.3, \n                penalty_weight: float = 0.01, \n                perturbation_max: float = 1e-5) -> np.ndarray:\n    \"\"\"\n    Advanced priority function that adaptively balances tight fit and future capacity with nuanced non-linear prioritization.\n    \"\"\"\n    # Identify valid bins\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    \n    # Calculate tight fit measure and future capacity penalty\n    tight_fit_measure = np.exp(-(bins_remain_cap - item) / item)\n    future_capacity_penalty = np.where(bins_remain_cap - item > 0, \n                                        (bins_remain_cap - item) / bins_remain_cap, \n                                        1)\n    \n    # Non-linear prioritization balancing tight fit and future capacity\n    priority = np.where(valid_bins == 1, \n                         alpha * tight_fit_measure + beta * (1 - future_capacity_penalty) - penalty_weight * (bins_remain_cap - item), \n                         -np.inf)\n    \n    # Normalize priority scores for adaptability\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:\n        priority = priority / max_priority\n    \n    # Introduce slight perturbation to avoid identical priorities\n    priority += np.random.uniform(0, perturbation_max, size=len(priority))\n    \n    return priority\n\n[Heuristics 19th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, \n                alpha: float = 0.7, beta: float = 0.3, \n                penalty_weight: float = 0.01, \n                perturbation_max: float = 1e-5) -> np.ndarray:\n    \"\"\"\n    Advanced priority function that adaptively balances tight fit and future capacity with nuanced non-linear prioritization.\n    \"\"\"\n    # Identify valid bins\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    \n    # Calculate tight fit measure and future capacity penalty\n    tight_fit_measure = np.exp(-(bins_remain_cap - item) / item)\n    future_capacity_penalty = np.where(bins_remain_cap - item > 0, \n                                        (bins_remain_cap - item) / bins_remain_cap, \n                                        1)\n    \n    # Non-linear prioritization balancing tight fit and future capacity\n    priority = np.where(valid_bins == 1, \n                         alpha * tight_fit_measure + beta * (1 - future_capacity_penalty) - penalty_weight * (bins_remain_cap - item), \n                         -np.inf)\n    \n    # Normalize priority scores for adaptability\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:\n        priority = priority / max_priority\n    \n    # Introduce slight perturbation to avoid identical priorities\n    priority += np.random.uniform(0, perturbation_max, size=len(priority))\n    \n    return priority\n\n[Heuristics 20th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a balanced penalty term, \n    balancing tight fit and future capacity effectively.\n    \"\"\"\n    # Calculate valid bins and remaining capacity after adding the item\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Non-linear prioritization focusing on tight fit\n    tight_fit_score = np.exp(-remain_cap_after_add / (item + 1e-6))\n    \n    # Refined penalty term for future capacity and balancing\n    future_capacity_penalty = (1 / (1 + np.exp((remain_cap_after_add - item/2) / item)))\n    future_capacity_score = remain_cap_after_add / (bins_remain_cap + 1e-6)\n    penalty_term = np.where(valid_bins == 1, future_capacity_score, 1)\n    \n    # Combine scores for better adaptability\n    priority = np.where(valid_bins == 1, \n                         0.7 * tight_fit_score * penalty_term + 0.3 * future_capacity_penalty, \n                         -np.inf)\n    \n    # Normalize priority scores\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:\n        priority = priority / max_priority\n    \n    return priority\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}