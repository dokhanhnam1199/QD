{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a refined penalty term for tighter fits and future capacity.\n    \"\"\"\n    # Identify valid bins and calculate remaining capacity after adding the item\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Non-linear prioritization with a penalty for large remaining capacity\n    priority = np.where(valid_bins == 1, \n                         np.exp(-remain_cap_after_add / item) - 0.01 * remain_cap_after_add,  # Balance tight fit and future capacity\n                         -np.inf)\n    \n    # Normalize priority scores for better adaptability\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:\n        priority = priority / max_priority\n    \n    return priority\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a refined penalty term for tighter fits and future capacity.\n    \"\"\"\n    # Identify valid bins and calculate remaining capacity after adding the item\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Non-linear prioritization with a penalty for large remaining capacity\n    priority = np.where(valid_bins == 1, \n                         np.exp(-remain_cap_after_add / item) - 0.01 * remain_cap_after_add,  # Balance tight fit and future capacity\n                         -np.inf)\n    \n    # Normalize priority scores for better adaptability\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:\n        priority = priority / max_priority\n    \n    return priority\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a refined penalty term for large remaining capacities.\n    Uses np.exp for non-linear prioritization and a balancing term to encourage tighter fits.\n    \"\"\"\n    # Identify valid bins and calculate remaining capacity after adding the item\n    valid_bins = (bins_remain_cap >= item)\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Non-linear prioritization with a penalty term for large remaining capacities\n    priority = np.where(valid_bins, \n                         np.exp(-remain_cap_after_add / item) * (1 / (1 + np.exp((remain_cap_after_add - item/2) / item))), \n                         -np.inf)\n    \n    return priority\n\n[Heuristics 4th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for each bin based on remaining capacity and item size.\n    Combines non-linear prioritization with a refined penalty term for better bin selection.\n    \"\"\"\n    # Non-linear prioritization for bins with sufficient capacity\n    priority = np.where(bins_remain_cap >= item, 1 / (1 + np.abs(bins_remain_cap - item)), -np.inf)\n    \n    # Refined penalty term to balance tight fitting and future capacity\n    penalty_term = np.where(bins_remain_cap >= item, -((bins_remain_cap - item) / bins_remain_cap) + (item / bins_remain_cap), 0)\n    priority *= penalty_term\n    \n    return priority\n\n[Heuristics 5th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a refined balancing term for optimal bin selection.\n    \"\"\"\n    # Calculate remaining capacity after adding the item\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Non-linear prioritization with a penalty for large remaining capacity and a balancing term\n    priority = np.where(bins_remain_cap >= item, \n                         np.exp(-remain_cap_after_add / item) * (1 - remain_cap_after_add / bins_remain_cap), \n                         -np.inf)\n    \n    return priority\n\n[Heuristics 6th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Enhances non-linear prioritization with a dynamic penalty term that adapts to the remaining capacity and item size.\n    \"\"\"\n    # Calculate valid bins and remaining capacity after adding the item\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Dynamic non-linear prioritization balancing tight fit and future capacity\n    tight_fit_score = np.exp(-remain_cap_after_add / (item + 1e-6))  # Avoid division by zero\n    future_capacity_score = 1 - (remain_cap_after_add / bins_remain_cap) ** 2  # Penalize bins that are too full or too empty relative to their original capacity\n    \n    # Combine scores with a weighted average for better adaptability\n    priority = np.where(valid_bins == 1, \n                         0.7 * tight_fit_score + 0.3 * future_capacity_score,  # Balance between tight fit and future capacity\n                         -np.inf)\n    \n    # Normalize priority scores for enhanced adaptability across different item sizes\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:\n        priority = priority / max_priority\n    \n    return priority\n\n[Heuristics 7th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for each bin based on remaining capacity and item size.\n    Combines non-linear prioritization with a refined penalty term for better bin selection.\n    \"\"\"\n    # Non-linear prioritization for bins with sufficient capacity\n    priority = np.where(bins_remain_cap >= item, 1 / (1 + np.abs(bins_remain_cap - item)), -np.inf)\n    \n    # Refined penalty term to balance tight fitting and future capacity\n    penalty_term = np.where(bins_remain_cap >= item, -((bins_remain_cap - item) / bins_remain_cap) + (item / bins_remain_cap), 0)\n    priority *= penalty_term\n    \n    return priority\n\n[Heuristics 8th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a refined penalty term for large remaining capacities.\n    Uses np.exp for non-linear prioritization and a balancing term to encourage tighter fits.\n    \"\"\"\n    # Identify valid bins and calculate remaining capacity after adding the item\n    valid_bins = (bins_remain_cap >= item)\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Non-linear prioritization with a penalty term for large remaining capacities\n    priority = np.where(valid_bins, \n                         np.exp(-remain_cap_after_add / item) * (1 / (1 + np.exp((remain_cap_after_add - item/2) / item))), \n                         -np.inf)\n    \n    return priority\n\n[Heuristics 9th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Enhances the priority function by introducing a more nuanced non-linear prioritization \n    that effectively balances tight fitting and future capacity, while maintaining simplicity.\n    \"\"\"\n    # Identify valid bins\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    \n    # Calculate a more nuanced priority score that balances tight fit and future capacity\n    remain_cap_after_add = bins_remain_cap - item\n    priority = np.where(valid_bins == 1, \n                         np.exp(-remain_cap_after_add / (item + 1e-6)) + 0.1 * np.exp(-remain_cap_after_add / bins_remain_cap),  \n                         -np.inf)\n    \n    # Simplify the normalization process by directly returning the priority scores\n    # Since the scores are already comparable and the highest score will be selected, \n    # further normalization is not necessary unless dealing with very large numbers.\n    return priority\n\n[Heuristics 10th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for each bin based on remaining capacity and item size.\n    Combines non-linear prioritization with a refined penalty term for better bin selection.\n    \"\"\"\n    # Non-linear prioritization for bins with sufficient capacity\n    priority = np.where(bins_remain_cap >= item, 1 / (1 + np.abs(bins_remain_cap - item)), -np.inf)\n    \n    # Refined penalty term to balance tight fitting and future capacity\n    penalty_term = np.where(bins_remain_cap >= item, -((bins_remain_cap - item) / bins_remain_cap) + (item / bins_remain_cap), 0)\n    priority *= penalty_term\n    \n    return priority\n\n[Heuristics 11th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Simplifies and refines the non-linear prioritization with a focus on balancing tight fits and future capacity.\n    \"\"\"\n    # Identify valid bins\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    \n    # Calculate the remaining capacity after adding the item\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Simplified non-linear prioritization focusing on tight fit and future capacity\n    priority = np.where(valid_bins == 1, \n                         np.exp(-remain_cap_after_add / (item + 1e-6)) + 0.1 * (remain_cap_after_add / (bins_remain_cap + 1e-6)),  \n                         -np.inf)\n    \n    # Directly return priority scores without normalization to maintain distinction between tight and loose fits\n    return priority\n\n[Heuristics 12th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a refined penalty term for large remaining capacities.\n    Uses np.exp(-(bins_remain_cap - item)) and a balancing term to encourage tighter fits and future capacity.\n    \"\"\"\n    # Non-linear prioritization for valid bins\n    priority = np.where(bins_remain_cap >= item, np.exp(-(bins_remain_cap - item)), -np.inf)\n    \n    # Refine penalty term to balance tight fitting and future capacity\n    valid_bins = priority != -np.inf\n    if np.any(valid_bins):\n        # Combine the benefits of both v0 and v1 by using a term that considers both remaining capacity and item size\n        penalty_term = (bins_remain_cap[valid_bins] - item) / bins_remain_cap[valid_bins]\n        balancing_term = 1 / (1 + np.exp((bins_remain_cap[valid_bins] - item) / item))\n        priority[valid_bins] *= penalty_term * balancing_term\n        \n    return priority\n\n[Heuristics 13th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for each bin based on non-linear prioritization and a refined penalty term.\n    \"\"\"\n    # Non-linear prioritization for bins with enough capacity\n    priority = np.where(bins_remain_cap >= item, np.exp(-(bins_remain_cap - item)), -np.inf)\n    # Refined penalty term to balance tight fitting and future capacity\n    priority = np.where(bins_remain_cap >= item, priority * ((bins_remain_cap - item) / bins_remain_cap), priority)\n    return priority\n\n[Heuristics 14th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a refined penalty term for tighter fits and future capacity.\n    \"\"\"\n    # Non-linear prioritization for bins that can fit the item\n    priority = np.where(bins_remain_cap >= item, np.exp(-(bins_remain_cap - item)), -np.inf)\n    # Refined penalty term to balance tight fitting and future capacity\n    penalty_term = np.where(bins_remain_cap - item > 0, (bins_remain_cap - item) / bins_remain_cap, 0)\n    priority *= penalty_term\n    # Normalize priority scores for better adaptability\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:\n        priority = priority / max_priority\n    \n    return priority\n\n[Heuristics 15th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a refined penalty term for large remaining capacities.\n    Uses np.exp(-(bins_remain_cap - item)) and a balancing term to encourage tighter fits and future capacity.\n    \"\"\"\n    # Non-linear prioritization for valid bins\n    priority = np.where(bins_remain_cap >= item, np.exp(-(bins_remain_cap - item)), -np.inf)\n    \n    # Refine penalty term to balance tight fitting and future capacity\n    valid_bins = priority != -np.inf\n    if np.any(valid_bins):\n        # Combine the benefits of both v0 and v1 by using a term that considers both remaining capacity and item size\n        penalty_term = (bins_remain_cap[valid_bins] - item) / bins_remain_cap[valid_bins]\n        balancing_term = 1 / (1 + np.exp((bins_remain_cap[valid_bins] - item) / item))\n        priority[valid_bins] *= penalty_term * balancing_term\n        \n    return priority\n\n[Heuristics 16th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a refined penalty term for large remaining capacities.\n    Uses np.exp(-(bins_remain_cap - item)) and a balancing term to encourage tighter fits and future capacity.\n    \"\"\"\n    # Non-linear prioritization for valid bins\n    priority = np.where(bins_remain_cap >= item, np.exp(-(bins_remain_cap - item)), -np.inf)\n    \n    # Refine penalty term to balance tight fitting and future capacity\n    valid_bins = priority != -np.inf\n    if np.any(valid_bins):\n        # Combine the benefits of both v0 and v1 by using a term that considers both remaining capacity and item size\n        penalty_term = (bins_remain_cap[valid_bins] - item) / bins_remain_cap[valid_bins]\n        balancing_term = 1 / (1 + np.exp((bins_remain_cap[valid_bins] - item) / item))\n        priority[valid_bins] *= penalty_term * balancing_term\n        \n    return priority\n\n[Heuristics 17th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for each bin based on non-linear prioritization and a refined penalty term.\n    \"\"\"\n    # Non-linear prioritization for bins with enough capacity\n    priority = np.where(bins_remain_cap >= item, np.exp(-(bins_remain_cap - item)), -np.inf)\n    # Refined penalty term to balance tight fitting and future capacity\n    priority = np.where(bins_remain_cap >= item, priority * ((bins_remain_cap - item) / bins_remain_cap), priority)\n    return priority\n\n[Heuristics 18th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a refined penalty term for balance.\n    Encourages tight fits while leaving capacity for future items.\n    \"\"\"\n    # Calculate remaining capacity after adding the item\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Non-linear prioritization with a refined penalty for large remaining capacity\n    priority = np.where(bins_remain_cap >= item, \n                         np.exp(-remain_cap_after_add / item) * (remain_cap_after_add / bins_remain_cap), \n                         -np.inf)\n    \n    return priority\n\n[Heuristics 19th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, \n                penalty_weight: float = 0.2226320942296571, \n                exp_scale_factor: float = 3.2571208170312453) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a refined penalty term for tighter fits and future capacity.\n    \"\"\"\n    # Identify valid bins and calculate remaining capacity after adding the item\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Non-linear prioritization with a penalty for large remaining capacity\n    priority = np.where(valid_bins == 1, \n                         np.exp(-remain_cap_after_add / (item * exp_scale_factor)) - penalty_weight * remain_cap_after_add,  \n                         -np.inf)\n    \n    # Normalize priority scores for better adaptability\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:\n        priority = priority / max_priority\n    \n    return priority\n\n[Heuristics 20th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, \n                penalty_weight: float = 0.2226320942296571, \n                exp_scale_factor: float = 3.2571208170312453) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a refined penalty term for tighter fits and future capacity.\n    \"\"\"\n    # Identify valid bins and calculate remaining capacity after adding the item\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Non-linear prioritization with a penalty for large remaining capacity\n    priority = np.where(valid_bins == 1, \n                         np.exp(-remain_cap_after_add / (item * exp_scale_factor)) - penalty_weight * remain_cap_after_add,  \n                         -np.inf)\n    \n    # Normalize priority scores for better adaptability\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:\n        priority = priority / max_priority\n    \n    return priority\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}