def priority_v2(item, bins_remain_cap):
  """{This algorithm prioritizes bins based on a combination of remaining capacity and how well the item fits, favoring bins with slightly larger capacity than the item size while avoiding bins that are nearly full or much larger than the item.}"""
  priority = []
  for cap in bins_remain_cap:
    if cap < item:
      priority.append(-1)  # Invalid bin
    else:
      # Base priority: higher capacity = higher priority, but penalize too large.
      base_priority = cap #
      # Fit score: how well the item fits. Higher fit = better
      fit_score = (cap - item)**2 #Smaller diff means better fit
      # Combine
      priority.append(base_priority-fit_score)
  return priority
