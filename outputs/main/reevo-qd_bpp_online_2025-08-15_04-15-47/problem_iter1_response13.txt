```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Almost Full Fit strategy.

    The Almost Full Fit strategy prioritizes bins that are almost full, meaning
    they have just enough remaining capacity to fit the current item. This
    aims to keep fuller bins together, potentially leaving more space in other
    bins for future items.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins that can accommodate the item
    fit_mask = bins_remain_cap >= item

    # For bins that can fit the item, assign a priority based on how "almost full" they are.
    # A smaller remaining capacity (but still able to fit the item) is preferred.
    # We use the inverse of remaining capacity as a proxy for "fullness".
    # To avoid division by zero or very small numbers, we can add a small epsilon
    # or simply use a large number for bins that are exactly full (if that's desired,
    # though for "almost full", we're looking for slightly more than what's needed).
    # A simple approach is to prioritize bins with the smallest remaining capacity
    # that can still fit the item.

    # Calculate a score: prioritize bins with smaller remaining capacity (closer to 'item' size).
    # We want to favor bins where `bins_remain_cap - item` is minimal.
    # However, to implement "almost full fit" where the bin is *nearly* full *after*
    # adding the item, we want to prioritize bins where `bins_remain_cap` is *just*
    # above `item`. So, `bins_remain_cap - item` should be small and non-negative.
    # A higher priority should be given to bins with smaller positive `bins_remain_cap - item`.
    # We can use `1 / (bins_remain_cap - item + epsilon)` for this.

    # To avoid issues with division by zero if `bins_remain_cap == item`,
    # we can add a small epsilon. A slightly better approach for "almost full fit"
    # might be to define "almost full" as having a remaining capacity `R` such that
    # `R` is within some tolerance `T` of the bin capacity `C`. If we consider the
    # remaining capacity after fitting, `R - item`, we want this to be small and non-negative.
    # So, `bins_remain_cap - item` should be minimized.

    # Let's refine: "Almost Full Fit" often means fitting into a bin that has
    # very little space left. If we add 'item', the remaining capacity becomes
    # `bins_remain_cap - item`. We want this value to be as small as possible,
    # but non-negative.

    # Calculate the "gap" after fitting the item.
    gaps = bins_remain_cap[fit_mask] - item

    # Prioritize bins where the gap is smallest. A smaller gap means the bin is "more full"
    # after fitting the item. We want the smallest positive gap.
    # A common way to achieve this with maximization is `1 / (gap + epsilon)`.
    epsilon = 1e-6  # Small value to prevent division by zero and handle exact fits
    priorities[fit_mask] = 1.0 / (gaps + epsilon)

    # If no bins can fit the item, all priorities remain 0, which is handled by initialization.

    return priorities
```
