```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This heuristic prioritizes bins that can fit the item. Among those that can fit,
    it prioritizes bins where the remaining capacity is closest to the item's size,
    aiming to minimize wasted space (Best Fit aspect). If a bin can exactly fit the item,
    it gets the highest priority. If multiple bins have the same "closest fit",
    the one with a smaller index is prioritized (arbitrary tie-breaking).

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins that can fit the item
    can_fit_mask = bins_remain_cap >= item

    # Calculate the "waste" if the item is placed in a bin
    # For bins that can't fit, the waste is considered infinite (or a very large number)
    waste = np.where(can_fit_mask, bins_remain_cap - item, np.inf)

    # Higher priority for smaller waste.
    # If waste is 0 (perfect fit), it gets the highest priority.
    # We want to *minimize* waste, so we can invert the waste and add a small
    # epsilon to ensure non-zero priorities, or simply use negative waste.
    # A simple approach is to give a higher score to less waste.
    # Let's assign scores such that perfect fit is prioritized.
    # We can invert the waste and add a large constant to ensure positive scores,
    # and prioritize smaller waste.

    # Assign a high score to bins that fit, with higher scores for less waste.
    # If waste is 0, it's a perfect fit, give it a very high priority.
    # Use a large number like 1e9 for perfect fit, and then smaller values
    # based on the waste for other bins.

    # Strategy:
    # 1. Bins that can fit the item get a positive priority.
    # 2. Among those that fit, prioritize those with less remaining capacity *after*
    #    placing the item. This is equivalent to minimizing (bins_remain_cap - item).
    # 3. A perfect fit (bins_remain_cap == item) is the best.
    #
    # We can achieve this by scoring based on -waste.
    # However, we need to ensure bins that *can't* fit get a score of 0 or less.
    #
    # Let's define priority:
    # If bin can fit item:
    #   priority = (MAX_PRIORITY - (bins_remain_cap - item))
    #   where MAX_PRIORITY is high enough to differentiate from non-fitting bins.
    #   A perfect fit (waste=0) gets MAX_PRIORITY.
    # If bin cannot fit item:
    #   priority = 0

    # Maximize priority for minimum waste.
    # The score for a bin will be proportional to -(bins_remain_cap - item)
    # To make sure it's a priority score where higher is better:
    # Let's use: 1 / (1 + waste) for bins that fit.
    # A perfect fit (waste=0) gives 1. Other fitting bins give less than 1.
    # Non-fitting bins get 0.

    # Ensure we don't divide by zero if some bins have negative remaining capacity
    # which shouldn't happen in a typical BPP but for robustness.
    valid_waste = np.maximum(0, waste)
    priorities[can_fit_mask] = 1.0 / (1.0 + valid_waste[can_fit_mask])

    # Tie-breaking: If multiple bins have the same priority (e.g., same amount of waste),
    # First Fit usually implies picking the one that appeared first. In our array
    # context, this means picking the one with the lowest index.
    # NumPy's argmax picks the first occurrence in case of ties, which aligns with
    # the "first fit" aspect if we were to pick the index with the max priority.
    # So, this definition implicitly handles the tie-breaking for First Fit.

    return priorities
```
