```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Inverse Distance strategy.

    The Inverse Distance (Proximity Fit) strategy prioritizes bins that have a
    remaining capacity closer to the item's size. A higher score indicates a
    better fit.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Calculate the difference between remaining capacity and item size.
    # We only consider bins where the item can actually fit.
    differences = bins_remain_cap - item

    # We want bins with a small positive difference (tight fit).
    # A very small positive difference should have a high priority.
    # A negative difference (item doesn't fit) should have zero priority.
    # A large positive difference should have lower priority than a tight fit.

    # To achieve this:
    # 1. Filter out bins where the item doesn't fit (differences < 0). Set their priority to 0.
    # 2. For bins where the item fits, calculate the inverse of the difference.
    #    Add a small epsilon to the difference to avoid division by zero if the fit is perfect.
    #    A smaller positive difference will result in a larger inverse, hence higher priority.

    # Create a mask for valid bins (where the item fits)
    valid_bins_mask = differences >= 0

    # Initialize priorities to zero
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Calculate priorities for valid bins
    # Add a small epsilon to avoid division by zero and to ensure that perfect fits (diff=0)
    # get a high priority, but not infinite.
    epsilon = 1e-9
    priorities[valid_bins_mask] = 1.0 / (differences[valid_bins_mask] + epsilon)

    return priorities
```
