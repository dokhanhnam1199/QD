```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Exact Fit First strategy.

    The Exact Fit First strategy prioritizes bins where the item fits exactly,
    meaning the remaining capacity of the bin will be zero after placing the item.
    Among bins that allow an exact fit, no further prioritization is applied in this version.
    If no exact fit is possible, bins that can accommodate the item are given a lower priority
    based on their remaining capacity (smaller remaining capacity is better, meaning less wasted space).
    Bins that cannot accommodate the item are given a priority of 0.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins that can fit the item
    can_fit_mask = bins_remain_cap >= item

    # Calculate the remaining capacity if the item is placed in a fitting bin
    potential_remaining_caps = bins_remain_cap[can_fit_mask] - item

    # Strategy: Prioritize exact fits (remaining capacity of 0)
    exact_fit_mask = can_fit_mask.copy()
    exact_fit_mask[can_fit_mask] = (potential_remaining_caps == 0)

    # Assign highest priority to exact fits
    priorities[exact_fit_mask] = 1.0

    # For bins that can fit but not exactly, prioritize those with less wasted space
    # Assign a priority inversely proportional to the remaining capacity after fit
    # Use a small epsilon to avoid division by zero if potential_remaining_caps is 0 (already handled by exact fit)
    non_exact_fit_mask = can_fit_mask.copy()
    non_exact_fit_mask[can_fit_mask] = ~exact_fit_mask[can_fit_mask]

    if np.any(non_exact_fit_mask):
        # Calculate priorities for non-exact fits: higher score for smaller leftover capacity
        # We want smaller leftover capacity to have a higher priority.
        # So, we can use 1 / (1 + leftover_capacity) to get values between (0, 1]
        # Adding 1 to leftover_capacity to ensure division by non-zero and scale appropriately.
        leftover_capacities = bins_remain_cap[non_exact_fit_mask] - item
        priorities[non_exact_fit_mask] = 1.0 / (1.0 + leftover_capacities)


    # Normalize priorities to be between 0 and 1, and ensure exact fits are clearly higher
    # Exact fits have priority 1.0. Non-exact fits will be between (0, 1) depending on leftover space.
    # Bins that don't fit remain 0.

    return priorities
```
