```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using First Fit strategy.

    The First Fit strategy places the item in the first bin that has enough remaining capacity.
    This priority function assigns a high priority to bins that can accommodate the item
    and a lower priority to those that cannot. Among the bins that can accommodate the item,
    it prioritizes the bins that would leave the least remaining capacity after placing the item
    (Best Fit component for tie-breaking).

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap)
    # Bins that can fit the item get a positive priority
    # Bins that cannot fit the item get a priority of 0 (implicitly handled by initialization)
    can_fit_mask = bins_remain_cap >= item

    # For bins that can fit the item, calculate a priority score
    # The strategy is to prefer bins that leave the least remaining space after fitting the item.
    # This encourages tighter packing.
    # We assign a priority based on the inverse of the remaining capacity AFTER fitting.
    # Adding 1 to the denominator prevents division by zero if remaining capacity - item is 0,
    # although in this case it means a perfect fit. A small epsilon could also be used.
    priorities[can_fit_mask] = 1.0 / (bins_remain_cap[can_fit_mask] - item + 1e-9)

    # To implement the "First Fit" aspect more directly in a priority queue context,
    # we can add a small bonus for bins that appear earlier in the array if they can fit.
    # This gives a preference to earlier bins among equally "good" fits.
    # We can add a small value proportional to the inverse of the bin index, scaled down.
    # For example, if two bins have the same (bins_remain_cap - item), the earlier bin
    # will get a slightly higher priority due to this addition.
    # The scaling factor needs to be small enough not to override the primary fitting logic.
    # A value like 1e-3 can be used, assuming the fitting priorities are generally > 1.
    earlier_bin_bonus = 1e-3 / (np.arange(len(bins_remain_cap)) + 1)
    priorities[can_fit_mask] += earlier_bin_bonus[can_fit_mask]

    return priorities
```
