```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Best Fit strategy.

    The Best Fit strategy aims to place the item in the bin that leaves the least
    remaining capacity after the item is placed. This minimizes wasted space.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
        A higher score indicates a better fit.
    """
    # Calculate the remaining capacity if the item is placed in each bin.
    # Only consider bins where the item can actually fit.
    potential_remaining_caps = bins_remain_cap - item

    # We want to prioritize bins where the remaining capacity is minimal (closest to zero).
    # A simple way to achieve this is to use the negative of the remaining capacity.
    # This means bins with less remaining space (i.e., a better fit) will have higher (less negative) priority scores.
    # For bins where the item doesn't fit, we assign a very low priority (a large negative number).

    # Initialize priorities to a very low value (representing a bad fit or no fit)
    priorities = np.full_like(bins_remain_cap, -np.inf)

    # Find the indices of bins where the item can fit
    can_fit_indices = np.where(bins_remain_cap >= item)[0]

    if len(can_fit_indices) > 0:
        # For bins where the item fits, calculate the priority based on the remaining capacity.
        # The priority is inversely related to the remaining capacity.
        # The "best fit" is the one that results in the smallest non-negative remaining capacity.
        # We can represent this by assigning a priority score based on the difference between
        # the bin's remaining capacity and the item's size. A smaller positive difference is better.
        # To convert this into a "higher is better" priority, we can use the negative of this difference.
        # However, a more robust approach that directly targets the "least remaining capacity" idea
        # is to calculate how much capacity is "leftover". The best fit leaves the *least* leftover.
        # So, we can prioritize based on `-(bins_remain_cap[idx] - item)`.
        # A higher value means a smaller non-negative leftover capacity.

        # Another perspective: we want the smallest non-negative `potential_remaining_caps`.
        # To convert this into a "higher priority is better" metric, we can subtract
        # `potential_remaining_caps` from a large constant or simply use `-potential_remaining_caps`.
        # Let's try `-potential_remaining_caps` which directly reflects the "least remaining".

        priorities[can_fit_indices] = -potential_remaining_caps[can_fit_indices]

        # Alternative: To strictly pick the bin with the *smallest positive* remaining capacity,
        # we could do something like:
        # residual_capacities = bins_remain_cap[can_fit_indices] - item
        # # Assign a large positive value to the smallest residual capacity
        # min_residual_idx_in_subset = np.argmin(residual_capacities)
        # priorities[can_fit_indices[min_residual_idx_in_subset]] = 1.0
        # However, the request is for a priority *score for each bin*, implying a continuous ranking.
        # The `-potential_remaining_caps` approach provides this ranking.

    return priorities
```
