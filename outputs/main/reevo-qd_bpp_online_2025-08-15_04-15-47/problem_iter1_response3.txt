```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Almost Full Fit strategy.

    The Almost Full Fit strategy prioritizes bins that have just enough capacity
    to fit the item, leaving the most empty space in the bins that are already
    quite full. This aims to keep fuller bins fuller and sparser bins sparser,
    potentially leading to better packing.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # We only consider bins that can fit the item
    can_fit_mask = bins_remain_cap >= item

    # Initialize priorities to a very low value for bins that cannot fit the item
    priorities = np.full_like(bins_remain_cap, -np.inf)

    # For bins that can fit the item, calculate a priority score.
    # The score is the remaining capacity AFTER placing the item.
    # We want to maximize this value for the "Almost Full Fit" heuristic.
    # A larger remaining capacity means the bin was less full to begin with,
    # but for the 'almost full' idea, we actually want to pick bins where
    # the remaining capacity after fitting is minimized, i.e., the bin is closer
    # to being full.
    # So, let's rephrase: we want to pick bins where the *difference*
    # between the remaining capacity and the item size is minimized.
    # Or, equivalently, where `bins_remain_cap - item` is minimized.
    # Since we want the *highest* priority for the chosen bin, we can invert this
    # and assign a priority of `-(bins_remain_cap - item)`.
    # A simpler way to think about "Almost Full Fit" is that we want to place the
    # item into a bin such that the *resulting* remaining capacity is as *small* as
    # possible (while still being non-negative). This means the bin was already
    # quite full.

    # Calculate the remaining capacity if the item were placed in each bin
    potential_remaining_caps = bins_remain_cap - item

    # The priority will be the negative of the potential remaining capacity.
    # This way, bins that will have the smallest remaining capacity (i.e., are closest to full)
    # will have the highest priority score.
    priorities[can_fit_mask] = -potential_remaining_caps[can_fit_mask]

    return priorities
```
