```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Best Fit strategy.

    The Best Fit strategy prioritizes bins that have just enough remaining capacity
    to accommodate the item. A bin with very little excess capacity is preferred
    over one with a lot of excess capacity, as this aims to leave larger gaps
    in other bins for potentially larger future items.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Only consider bins that have enough capacity for the item
    valid_bins_mask = bins_remain_cap >= item

    # Calculate the remaining capacity if the item were placed in the bin.
    # This is the 'waste' or the gap left behind.
    remaining_after_placement = bins_remain_cap - item

    # The priority is inversely related to the remaining capacity after placement.
    # A smaller remaining capacity (meaning a tighter fit) is better.
    # We use a small epsilon to avoid division by zero if a bin's remaining capacity is exactly the item size.
    epsilon = 1e-9
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # For bins that can fit the item, assign a priority.
    # The priority is calculated as 1 / (remaining_after_placement + epsilon).
    # This means bins with smaller remaining_after_placement will have higher priorities.
    # If remaining_after_placement is 0 (perfect fit), the priority will be 1/epsilon (very high).
    priorities[valid_bins_mask] = 1.0 / (remaining_after_placement[valid_bins_mask] + epsilon)

    # To make it more robust and avoid extremely high values from near-perfect fits
    # that might dominate other considerations (even though Best Fit *wants* tight fits),
    # we can cap the priority or use a function that grows less rapidly.
    # For a pure Best Fit, the current calculation is accurate.
    # An alternative approach could involve ranking or using a smooth function like
    # exp(-k * remaining_after_placement) but the inverse is the most direct representation.

    # Let's ensure that bins that CANNOT fit the item have a priority of 0,
    # which is already handled by the initialization and the valid_bins_mask.

    return priorities
```
