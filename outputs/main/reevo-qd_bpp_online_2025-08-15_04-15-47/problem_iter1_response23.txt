```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Almost Full Fit.

    The Almost Full Fit strategy prioritizes bins that are almost full,
    but can still accommodate the current item. This helps in packing
    larger items into bins that have just enough space, leaving more
    flexible space in other bins for smaller items later.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap)

    # Identify bins that can accommodate the item
    can_accommodate_mask = bins_remain_cap >= item

    # Calculate priorities only for bins that can accommodate the item
    # The priority is inversely proportional to the remaining capacity
    # (i.e., smaller remaining capacity means higher priority)
    # We add a small epsilon to the remaining capacity to avoid division by zero
    # and to ensure that bins with exactly the item's size are prioritized over
    # those with slightly more space.
    priorities[can_accommodate_mask] = 1.0 / (bins_remain_cap[can_accommodate_mask] - item + 1e-6)

    # We can optionally add a small bonus to bins that are 'almost full'
    # to further encourage packing into these bins.
    # For example, a bin is 'almost full' if its remaining capacity
    # is less than some threshold, say, twice the item size.
    # This is a tuning parameter and can be adjusted.
    almost_full_threshold = 2 * item
    almost_full_mask = (bins_remain_cap >= item) & (bins_remain_cap < almost_full_threshold)
    priorities[almost_full_mask] += 0.1 * (almost_full_threshold - bins_remain_cap[almost_full_mask]) / almost_full_threshold

    # Ensure no negative priorities
    priorities = np.maximum(priorities, 0)

    return priorities
```
