```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Epsilon-Greedy.

    The Epsilon-Greedy strategy balances exploration (trying less optimal bins)
    and exploitation (choosing the best available bin).

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    epsilon = 0.1  # Probability of exploration

    num_bins = len(bins_remain_cap)
    priorities = np.zeros(num_bins)

    # Find bins that can accommodate the item
    suitable_bins_mask = bins_remain_cap >= item
    suitable_bins_indices = np.where(suitable_bins_mask)[0]

    if len(suitable_bins_indices) == 0:
        return priorities  # No bin can fit the item

    # Exploitation: Calculate the "best fit" priority for suitable bins
    # A common heuristic for bin packing is "best fit": choosing the bin
    # where the remaining capacity after placing the item is minimized.
    # We want higher priority for bins that leave less remaining capacity
    # (i.e., are a tighter fit).
    remaining_capacities_after_fit = bins_remain_cap[suitable_bins_mask] - item
    # Higher priority for smaller remaining capacities. We can use inverse of
    # remaining capacity, but need to handle zero or very small remaining capacities.
    # Adding a small constant to avoid division by zero and to normalize.
    # A simple approach is to use 1 / (remaining_capacity + epsilon)
    # or to transform it so that smaller remaining capacity means higher priority.
    # Let's use the negative of the remaining capacity, which naturally
    # gives higher values to smaller remaining capacities.
    exploitation_priorities = -remaining_capacities_after_fit

    # Assign these exploitation priorities to the suitable bins
    priorities[suitable_bins_mask] = exploitation_priorities

    # Exploration: With probability epsilon, pick a random suitable bin
    # and assign it a very high priority to encourage exploration.
    if np.random.rand() < epsilon and len(suitable_bins_indices) > 0:
        random_bin_index = np.random.choice(suitable_bins_indices)
        # Assign a high priority (e.g., a value larger than any possible
        # exploitation priority). Since exploitation priorities are negative,
        # any positive value will do. Let's pick a value that's clearly
        # better than the best exploitation score.
        exploration_priority_value = np.max(exploitation_priorities) + 1.0
        priorities[random_bin_index] = exploration_priority_value

    return priorities
```
