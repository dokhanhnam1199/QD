[
  {
    "stdout_filepath": "problem_iter8_response0.txt_stdout.txt",
    "code_path": "problem_iter8_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_size = bins_remain_cap.max()  # Assuming all bins have the same capacity\n\n    # 1. Feasibility: Only consider bins where the item fits.\n    feasible_bins = bins_remain_cap >= item\n\n    # 2. Calculate remaining capacity after placing the item\n    post_fill_levels = bins_remain_cap - item\n\n    # 3. Infeasibility penalty: Very low priority for infeasible bins\n    priorities[~feasible_bins] = -np.inf\n\n    # 4. Waste minimization using normalized waste\n    waste = post_fill_levels[feasible_bins]\n    normalized_waste = waste / bin_size\n    priorities[feasible_bins] = -normalized_waste\n\n    # 5. Bonus for near-full bins (encourage filling bins completely)\n    near_full_threshold = 0.1\n    near_full_bonus = 1.0\n    near_full_bins = feasible_bins & (post_fill_levels >= 0) & (post_fill_levels <= (bin_size * near_full_threshold))\n    priorities[near_full_bins] += near_full_bonus\n\n    # 6. Penalty for bins that would become too empty (encourage consolidation)\n    too_empty_threshold = 0.2\n    too_empty_penalty = -0.5\n    too_empty_bins = feasible_bins & (post_fill_levels > 0) & (post_fill_levels <= (bin_size * too_empty_threshold))\n    priorities[too_empty_bins] += too_empty_penalty\n\n    # 7. If no feasible bin exists, give preference to the fullest bin\n    if not np.any(feasible_bins):\n        # Give priority to the fullest bin when no bin can accommodate the item.\n        priorities = bins_remain_cap / bin_size #Prioritize fullest\n    \n    return priorities",
    "response_id": 0,
    "obj": 3.7295572397287686,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response1.txt_stdout.txt",
    "code_path": "problem_iter8_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # 1. Feasibility: Only consider bins where the item fits.\n    feasible_bins = bins_remain_cap >= item\n    \n    # 2. Waste minimization: Prioritize bins with smallest normalized remaining capacity *after* placing the item\n    post_fill_levels = bins_remain_cap - item\n    bin_size = bins_remain_cap.max() #Assuming all bins have the same capacity\n    normalized_waste = post_fill_levels / bin_size #Waste as a percentage of bin capacity\n    \n    # 3. Infesibility penalty\n    priorities[~feasible_bins] = -np.inf\n    \n    # 4. Reward tight fits, penalize waste:\n    priorities[feasible_bins] = -normalized_waste[feasible_bins]  #Invert waste to make it a priority.\n\n    # 5. Bonus for near-full bins:\n    near_full_threshold = 0.1  # Define a threshold for \"near full\" (e.g., 10% remaining capacity)\n    near_full_bonus = 5  # Increased bonus\n\n    near_full_bins = feasible_bins & (post_fill_levels >= 0) & (post_fill_levels <= (bin_size * near_full_threshold))\n    priorities[near_full_bins] += near_full_bonus\n    \n    # 6. Penalize bins that would have too little remaining capacity, to consolidate items.\n    too_little_threshold = 0.2\n    too_little_penalty = -0.5\n\n    too_little_bins = feasible_bins & (post_fill_levels > 0) & (post_fill_levels <= (bin_size * too_little_threshold))\n    priorities[too_little_bins] += too_little_penalty\n\n    # 7. Perfect fit bonus\n    perfect_fit_bonus = 10\n    perfect_fit_bins = np.isclose(bins_remain_cap, item) & feasible_bins\n    priorities[perfect_fit_bins] += perfect_fit_bonus\n\n    # 8. Prioritize using almost empty bins if there is no better option\n    if not np.any(feasible_bins):\n        almost_empty_threshold = 0.9\n        almost_empty_bins = bins_remain_cap >= (almost_empty_threshold * bin_size)\n        if np.any(almost_empty_bins):\n            priorities[almost_empty_bins] = 1.0/len(bins_remain_cap)\n        else:\n            priorities[:] = 1.0 / len(bins_remain_cap) #Distribute evenly\n\n    return priorities",
    "response_id": 1,
    "obj": 3.7295572397287686,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response2.txt_stdout.txt",
    "code_path": "problem_iter8_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_size = bins_remain_cap.max()\n\n    # 1. Feasibility: Only consider bins where the item fits.\n    feasible_bins = bins_remain_cap >= item\n\n    # 2. Calculate remaining capacity *after* placing the item\n    post_fill_levels = bins_remain_cap - item\n\n    # 3. Infeasibility penalty: Heavily penalize infeasible bins.\n    priorities[~feasible_bins] = -np.inf\n\n    # 4. Prioritize bins with higher utilization after placing the item.\n    utilization = (bin_size - post_fill_levels) / bin_size\n    utilization[~feasible_bins] = -np.inf  # Ensure infeasible bins have the lowest priority\n    priorities = utilization\n\n    # 5. Encourage tighter fits by slightly rewarding near-full bins after placement\n    near_full_threshold = 0.1\n    near_full_bonus = 0.15\n\n    near_full_bins = feasible_bins & (post_fill_levels >= 0) & (post_fill_levels <= (bin_size * near_full_threshold))\n    priorities[near_full_bins] += near_full_bonus\n\n    # 6. Penalize bins that would have too little remaining capacity, to consolidate items.\n    too_little_threshold = 0.2\n    too_little_penalty = -0.05\n\n    too_little_bins = feasible_bins & (post_fill_levels > 0) & (post_fill_levels <= (bin_size * too_little_threshold))\n    priorities[too_little_bins] += too_little_penalty\n\n    # 7. If no feasible bin found, give all bins a default priority to allow placement in any bin.\n    if not np.any(feasible_bins):\n        priorities = np.ones_like(priorities) * 0.01 # Add a tiny value for arbitrary choice\n\n    return priorities",
    "response_id": 2,
    "obj": 3.9788591942560925,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response3.txt_stdout.txt",
    "code_path": "problem_iter8_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: Only consider bins where the item fits.\n    feasible_bins = bins_remain_cap >= item\n\n    # 2. Waste minimization: Prioritize bins with smallest remaining capacity *after* placing the item\n    post_fill_levels = bins_remain_cap - item\n\n    # 3. Infeasibility penalty\n    priorities[~feasible_bins] = -np.inf\n\n    # 4. Reward tight fits, penalize waste:\n    waste = post_fill_levels[feasible_bins]\n    bin_size = bins_remain_cap.max()  # Assuming all bins have the same capacity\n    normalized_waste = waste / bin_size  # Waste as a percentage of bin capacity\n\n    priorities[feasible_bins] = -normalized_waste  # Invert waste to make it a priority.\n\n    # 5. Bonus for near-full bins:\n    near_full_threshold = 0.1  # Define a threshold for \"near full\" (e.g., 10% remaining capacity)\n    near_full_bonus = 1\n\n    near_full_bins = feasible_bins & (post_fill_levels >= 0) & (post_fill_levels <= (bin_size * near_full_threshold))  # Only consider non-negative remaining capacities to fix error\n    priorities[near_full_bins] += near_full_bonus\n\n    # 6. Penalize bins that would have too little remaining capacity, to consolidate items.\n    too_little_threshold = 0.2\n    too_little_penalty = -0.5\n\n    too_little_bins = feasible_bins & (post_fill_levels > 0) & (post_fill_levels <= (bin_size * too_little_threshold))\n    priorities[too_little_bins] += too_little_penalty\n    \n    # 7. Encourage balanced bin usage\n    average_fill = np.mean(bin_size - bins_remain_cap) / bin_size #As percentage\n    balance_bonus = 0.1\n\n    #Give a small bonus for bins that are close to the average fill level after placing the item\n    post_fill_level_percentage = (bin_size - post_fill_levels) / bin_size\n    average_fill_proximity = np.abs(post_fill_level_percentage - average_fill)\n    priorities[feasible_bins] -= balance_bonus * average_fill_proximity[feasible_bins]\n    \n    #8. Prioritize bins based on current fullness\n    current_fill_level = (bin_size - bins_remain_cap)/bin_size\n    fullness_bonus = 0.05 #A small weight so it does not dominate\n\n    priorities[feasible_bins] += fullness_bonus * current_fill_level[feasible_bins]\n\n    # 9. Normalize priorities if feasible bins exist to make them comparable\n    if np.any(feasible_bins):\n        max_priority = np.max(priorities[feasible_bins])\n        min_priority = np.min(priorities[feasible_bins])\n\n        if max_priority != min_priority:\n            priorities[feasible_bins] = (priorities[feasible_bins] - min_priority) / (max_priority - min_priority)\n        else:\n            priorities[feasible_bins] = 0.5 #Assign equal probabilities if max and min are equal.\n    #If no feasible bin, return equal priorities\n    else:\n        priorities = np.ones_like(priorities)\n        \n    return priorities",
    "response_id": 3,
    "obj": 3.839250099720782,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response4.txt_stdout.txt",
    "code_path": "problem_iter8_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: Only consider bins where the item fits.\n    feasible_bins = bins_remain_cap >= item\n\n    # 2. Infeasibility penalty: Set to -inf for bins that cannot fit the item.\n    priorities[~feasible_bins] = -np.inf\n\n    # 3. Waste Minimization (Normalized): Prioritize bins with minimal *normalized* waste.\n    post_fill_levels = bins_remain_cap - item\n    bin_size = bins_remain_cap.max()  # Assuming all bins have the same capacity\n    normalized_waste = post_fill_levels / bin_size\n    priorities[feasible_bins] = -normalized_waste[feasible_bins]  # Invert waste to priority.\n\n    # 4. Consolidation Bonus: Reward bins that become near-full.\n    near_full_threshold = 0.1\n    near_full_bonus = 1.0\n    near_full_bins = feasible_bins & (post_fill_levels >= 0) & (normalized_waste <= near_full_threshold)\n    priorities[near_full_bins] += near_full_bonus\n\n    # 5. Fragmentation Penalty: Penalize bins that would have very little remaining capacity.\n    tiny_rem_threshold = 0.2\n    tiny_rem_penalty = -0.5\n    tiny_rem_bins = feasible_bins & (post_fill_levels > 0) & (normalized_waste <= tiny_rem_threshold)\n    priorities[tiny_rem_bins] += tiny_rem_penalty\n\n    # 6. Perfect Fit Bonus: Substantially reward perfect fits.\n    perfect_fit_bonus = 2.0\n    perfect_fit_bins = np.isclose(bins_remain_cap, item) & feasible_bins\n    priorities[perfect_fit_bins] += perfect_fit_bonus\n\n    # 7. Handle Infeasible Case: If no bins fit, assign equal priorities.  This avoids -inf.\n    if not np.any(feasible_bins):\n        priorities = np.ones_like(priorities) / len(priorities)\n\n    return priorities",
    "response_id": 4,
    "obj": 3.7295572397287686,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response5.txt_stdout.txt",
    "code_path": "problem_iter8_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: Only consider bins where the item fits.\n    feasible_bins = bins_remain_cap >= item\n\n    # 2. Waste minimization: Prioritize bins with smallest remaining capacity *after* placing the item\n    post_fill_levels = bins_remain_cap - item\n\n    # 3. Infeasibility penalty\n    priorities[~feasible_bins] = -np.inf\n\n    # 4. Reward tight fits, penalize waste:\n    waste = post_fill_levels[feasible_bins]\n    bin_size = bins_remain_cap.max() #Assuming all bins have the same capacity\n    normalized_waste = waste / bin_size #Waste as a percentage of bin capacity\n\n    priorities[feasible_bins] =  -normalized_waste  #Invert waste to make it a priority.\n\n    # 5. Bonus for near-full bins:\n    near_full_threshold = 0.1  # Define a threshold for \"near full\" (e.g., 10% remaining capacity)\n    near_full_bonus = 10  # Increased bonus\n\n    near_full_bins = feasible_bins & (post_fill_levels >= 0) & (post_fill_levels <= (bin_size * near_full_threshold))  #Only consider non-negative remaining capacities to fix error\n    priorities[near_full_bins] += near_full_bonus\n\n    # 6. Penalize bins that would have too little remaining capacity, to consolidate items.\n    too_little_threshold = 0.2\n    too_little_penalty = -2\n\n    too_little_bins = feasible_bins & (post_fill_levels > 0) & (post_fill_levels <= (bin_size * too_little_threshold))\n    priorities[too_little_bins] += too_little_penalty\n\n    # 7. Normalize priorities if no feasible bin exists:\n    if not np.any(feasible_bins):\n        priorities = np.random.rand(len(bins_remain_cap))\n        priorities /= np.sum(priorities)\n\n    return priorities",
    "response_id": 5,
    "obj": 4.148384523334677,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response6.txt_stdout.txt",
    "code_path": "problem_iter8_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_size = bins_remain_cap.max()\n\n    # 1. Feasibility: Only consider bins where the item fits.\n    feasible_bins = bins_remain_cap >= item\n\n    # 2. Calculate remaining capacity *after* placing the item\n    post_fill_levels = bins_remain_cap - item\n\n    # 3. Infeasibility penalty: Heavily penalize infeasible bins.\n    priorities[~feasible_bins] = -np.inf\n\n    # 4. Prioritize bins with highest normalized utilization after placing the item\n    # Use post_fill_levels directly for waste calculation\n    waste = post_fill_levels\n    waste[~feasible_bins] = bin_size  # Ensure infeasible bins have maximum waste\n\n    normalized_utilization = (bin_size - waste) / bin_size  # Higher is better\n    priorities[feasible_bins] = normalized_utilization[feasible_bins]\n\n    # 5. Encourage tighter fits with a small bonus for near-full bins after placement\n    near_full_threshold = 0.1\n    near_full_bonus = 0.1  # Reduced bonus\n\n    near_full_bins = feasible_bins & (post_fill_levels >= 0) & (post_fill_levels <= (bin_size * near_full_threshold))\n    priorities[near_full_bins] += near_full_bonus\n\n    # 6. Penalize bins that would have too little remaining capacity, to consolidate items.\n    too_little_threshold = 0.2\n    too_little_penalty = -0.05  # Reduced penalty\n\n    too_little_bins = feasible_bins & (post_fill_levels > 0) & (post_fill_levels <= (bin_size * too_little_threshold))\n    priorities[too_little_bins] += too_little_penalty\n    \n    # 7. Slightly prioritize bins that are already somewhat full before placing the item\n    # This encourages filling existing bins before starting new ones.\n    already_full_threshold = 0.9 #Bins that are already 90% full\n    already_full_bonus = 0.02\n    \n    already_full_bins = feasible_bins & (bins_remain_cap <= (bin_size * (1 - already_full_threshold)))\n    priorities[already_full_bins] += already_full_bonus\n\n    # 8. If no feasible bin found, reset all priorities to a small positive value to select a bin.\n    if not np.any(feasible_bins):\n        priorities = np.full_like(priorities, 0.01)  # Small positive value\n\n    return priorities",
    "response_id": 6,
    "obj": 3.9788591942560925,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response7.txt_stdout.txt",
    "code_path": "problem_iter8_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: Only consider bins where the item fits.\n    feasible_bins = bins_remain_cap >= item\n\n    # 2. Calculate remaining capacity after placing the item\n    post_fill_levels = bins_remain_cap - item\n\n    # 3. Infeasibility penalty: Very low priority for infeasible bins\n    priorities[~feasible_bins] = -np.inf\n\n    # 4. Waste minimization using normalized waste\n    bin_size = bins_remain_cap.max()  # Assuming all bins have the same capacity\n    waste = post_fill_levels[feasible_bins]\n    normalized_waste = waste / bin_size\n    priorities[feasible_bins] = -normalized_waste\n\n    # 5. Bonus for near-full bins (encourage filling bins completely)\n    near_full_threshold = 0.1\n    near_full_bonus = 1.0\n    near_full_bins = feasible_bins & (post_fill_levels >= 0) & (post_fill_levels <= (bin_size * near_full_threshold))\n    priorities[near_full_bins] += near_full_bonus\n\n    # 6. Penalty for bins that would become too empty (encourage consolidation)\n    too_empty_threshold = 0.2\n    too_empty_penalty = -0.5\n    too_empty_bins = feasible_bins & (post_fill_levels > 0) & (post_fill_levels <= (bin_size * too_empty_threshold))\n    priorities[too_empty_bins] += too_empty_penalty\n\n    # 7. If no feasible bin exists, give preference to the fullest bin\n    if not np.any(feasible_bins):\n        # Give priority to the fullest bin when no bin can accommodate the item.\n        max_cap = np.max(bins_remain_cap)\n        if max_cap > 0:\n            priorities = bins_remain_cap / max_cap\n        else:\n            priorities = np.ones_like(priorities) * 0.1 # Add small non-zero priority to all, avoiding zero division in other steps\n    \n    # 8. Adjust the near full bonus dynamically based on item size.  Larger items should more aggressively fill bins.\n    item_size_factor = item / bin_size\n    near_full_bins = feasible_bins & (post_fill_levels >= 0) & (post_fill_levels <= (bin_size * near_full_threshold))\n    priorities[near_full_bins] += near_full_bonus * item_size_factor\n    \n    return priorities",
    "response_id": 7,
    "obj": 3.7295572397287686,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response8.txt_stdout.txt",
    "code_path": "problem_iter8_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: Only consider bins where the item fits.\n    feasible_bins = bins_remain_cap >= item\n\n    # 2. Waste minimization: Prioritize bins with smallest remaining capacity *after* placing the item\n    post_fill_levels = bins_remain_cap - item\n\n    # 3. Infeasibility penalty: Harsh penalty for infeasible bins.\n    priorities[~feasible_bins] = -np.inf\n\n    # 4. Reward tight fits, penalize waste:\n    waste = post_fill_levels[feasible_bins]\n    bin_size = bins_remain_cap.max()  # Assuming all bins have the same capacity\n    normalized_waste = waste / bin_size  # Waste as a percentage of bin capacity\n\n    priorities[feasible_bins] = -normalized_waste  # Invert waste to make it a priority.\n\n    # 5. Bonus for near-full bins:\n    near_full_threshold = 0.1  # Define a threshold for \"near full\" (e.g., 10% remaining capacity)\n    near_full_bonus = 1\n\n    near_full_bins = feasible_bins & (post_fill_levels >= 0) & (post_fill_levels <= (bin_size * near_full_threshold))  # Only consider non-negative remaining capacities to fix error\n    priorities[near_full_bins] += near_full_bonus\n\n    # 6. Penalize bins that would have too little remaining capacity, to consolidate items.\n    too_little_threshold = 0.2\n    too_little_penalty = -0.5\n\n    too_little_bins = feasible_bins & (post_fill_levels > 0) & (post_fill_levels <= (bin_size * too_little_threshold))\n    priorities[too_little_bins] += too_little_penalty\n    \n    # 7. Encourage balanced bin usage\n    average_fill = np.mean(bins_remain_cap) / bin_size #As percentage\n    balance_bonus = 0.1\n\n    #Give a small bonus for bins that are close to the average fill level after placing the item\n    average_fill_proximity = np.abs(normalized_waste - average_fill)\n    priorities[feasible_bins] -= balance_bonus * average_fill_proximity\n\n    \n    #8. Prioritize bins based on current fullness\n    current_fill_level = (bin_size - bins_remain_cap)/bin_size\n    fullness_bonus = 0.05 #A small weight so it does not dominate\n\n    priorities[feasible_bins] += fullness_bonus * current_fill_level[feasible_bins]\n\n    # 9. Normalize priorities if feasible bins exist to make them comparable\n    if np.any(feasible_bins):\n        max_priority = np.max(priorities[feasible_bins])\n        min_priority = np.min(priorities[feasible_bins])\n\n        if max_priority != min_priority:\n            priorities[feasible_bins] = (priorities[feasible_bins] - min_priority) / (max_priority - min_priority)\n    #If no feasible bin, return equal priorities\n    else:\n        priorities = np.ones_like(priorities) / len(bins_remain_cap)\n\n\n    return priorities",
    "response_id": 8,
    "obj": 3.839250099720782,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response9.txt_stdout.txt",
    "code_path": "problem_iter8_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_size = bins_remain_cap.max() #Assuming all bins have the same capacity\n\n    # 1. Feasibility: Only consider bins where the item fits.\n    feasible_bins = bins_remain_cap >= item\n\n    # 2. Infeasibility penalty:  Set a very large negative priority.\n    priorities[~feasible_bins] = -np.inf\n\n    # Proceed only if at least one bin is feasible\n    if np.any(feasible_bins):\n        # Calculate remaining capacity after placing the item for feasible bins\n        post_fill_levels = bins_remain_cap[feasible_bins] - item\n\n        # 3. Waste minimization: Prioritize bins with smallest waste AFTER placing the item\n        normalized_waste = post_fill_levels / bin_size\n        priorities[feasible_bins] = -normalized_waste\n\n        # 4. Bonus for near-full bins:\n        near_full_threshold = 0.1\n        near_full_bonus = 1.0\n        near_full_bins = (post_fill_levels >= 0) & (post_fill_levels <= (bin_size * near_full_threshold))\n        priorities[feasible_bins][near_full_bins] += near_full_bonus\n\n        # 5. Penalty for bins that would have too little remaining capacity, to consolidate items.\n        too_little_threshold = 0.2\n        too_little_penalty = -0.5\n        too_little_bins = (post_fill_levels > 0) & (post_fill_levels <= (bin_size * too_little_threshold))\n        priorities[feasible_bins][too_little_bins] += too_little_penalty\n\n    else:\n        # If no bin is feasible, give preference to the fullest bin to open it.\n        # But use a lower priority than potentially feasible bins.\n        if np.any(bins_remain_cap > 0):\n            priorities = bins_remain_cap / bin_size - 1.1 # Slightly negative to avoid immediate use if feasible becomes available\n        else:\n            #All bins are full, but no feasible bin exists. This shouldn't happen\n            priorities = np.ones_like(priorities) * -1.1\n\n    return priorities",
    "response_id": 9,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response0.txt_stdout.txt",
    "code_path": "problem_iter9_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_size = bins_remain_cap.max()\n\n    # 1. Feasibility: Only consider bins where the item fits.\n    feasible_bins = bins_remain_cap >= item\n\n    # 2. Waste minimization & Infeasibility: Prioritize bins with smallest remaining capacity *after* placing the item\n    post_fill_levels = bins_remain_cap - item\n    priorities[~feasible_bins] = -np.inf\n\n    # 3. Reward tight fits, penalize waste:\n    waste = post_fill_levels[feasible_bins]\n    normalized_waste = waste / bin_size\n\n    priorities[feasible_bins] = -normalized_waste  # Invert waste to make it a priority.\n\n    # 4. Bonus for near-full bins:\n    near_full_threshold = 0.1\n    near_full_bonus = 1\n\n    near_full_bins = feasible_bins & (post_fill_levels >= 0) & (post_fill_levels <= (bin_size * near_full_threshold))\n    priorities[near_full_bins] += near_full_bonus\n\n    # 5. Penalize bins that would have too little remaining capacity, to consolidate items.\n    too_little_threshold = 0.2\n    too_little_penalty = -0.5\n\n    too_little_bins = feasible_bins & (post_fill_levels > 0) & (post_fill_levels <= (bin_size * too_little_threshold))\n    priorities[too_little_bins] += too_little_penalty\n\n    # 6. Adaptive Bonus/Penalty based on item size:\n    item_size_ratio = item / bin_size\n\n    # Encourage using bins with high remaining capacity if the item is large\n    large_item_bonus = 0.2\n    if item_size_ratio > 0.5:\n        high_capacity_bins = feasible_bins & (bins_remain_cap > 0.75 * bin_size) #Bins that were already near empty\n        priorities[high_capacity_bins] += large_item_bonus\n\n    # Strongly discourage creating tiny remaining space for small items\n    small_item_penalty = -0.3\n    if item_size_ratio < 0.2:\n        tiny_space_bins = feasible_bins & (post_fill_levels > 0) & (post_fill_levels < 0.1*bin_size)\n        priorities[tiny_space_bins] += small_item_penalty\n\n    # 7. Avoid creating many bins at the same fill level. Prioritize bins that are significantly different in fill level\n    fill_level_penalty = -0.1\n    if np.sum(feasible_bins) > 1:  # Only apply if there are multiple feasible bins\n        fill_level_std = np.std(bins_remain_cap[feasible_bins])\n        if fill_level_std < 0.2 * bin_size: #If std is low, all bins are similarly filled.\n            priorities[feasible_bins] += fill_level_penalty\n\n\n    # 8. If no feasible bin exists, slightly prioritize bins closest to fitting to reduce wasted search\n    if not np.any(feasible_bins):\n        capacity_diff = item - bins_remain_cap\n        min_diff = np.min(capacity_diff)\n\n        if np.any(capacity_diff>0): # Make sure at least one bin can fit.\n            closest_bins = capacity_diff == min_diff # Select the bins with the closest capacity\n            priorities[closest_bins] = 0.01 # Add tiny priority to bins closest in capacity\n\n\n    return priorities",
    "response_id": 0,
    "obj": 3.7495013960909587,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response1.txt_stdout.txt",
    "code_path": "problem_iter9_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_size = bins_remain_cap.max() # Assuming all bins have same capacity\n\n    # 1. Feasibility: Only consider bins where the item fits.\n    feasible_bins = bins_remain_cap >= item\n\n    # 2. Infeasibility penalty: Set priority to -inf for infeasible bins\n    priorities[~feasible_bins] = -np.inf\n\n    # Only calculate priorities for feasible bins\n    if np.any(feasible_bins):\n        # 3. Waste minimization: Prioritize bins with smallest remaining capacity *after* placing the item\n        post_fill_levels = bins_remain_cap[feasible_bins] - item\n        normalized_waste = post_fill_levels / bin_size\n        priorities[feasible_bins] = -normalized_waste  # Invert waste to make it a priority.\n\n        # 4. Bonus for near-full bins: Incentivize tight packing\n        near_full_threshold = 0.1\n        near_full_bonus = 1\n        near_full_bins = (post_fill_levels >= 0) & (post_fill_levels <= (bin_size * near_full_threshold))\n        priorities[feasible_bins][near_full_bins] += near_full_bonus\n\n        # 5. Penalize bins that would have too little remaining capacity, to consolidate items.\n        too_little_threshold = 0.2\n        too_little_penalty = -0.5\n        too_little_bins = (post_fill_levels > 0) & (post_fill_levels <= (bin_size * too_little_threshold))\n        priorities[feasible_bins][too_little_bins] += too_little_penalty\n    else:\n        # If no feasible bin, spread the load if possible or indicate total failure\n        priorities = np.full_like(priorities, -np.inf) # If no feasible bin, all should be -inf\n        return priorities # No feasible solution\n\n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response2.txt_stdout.txt",
    "code_path": "problem_iter9_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: Only consider bins where the item fits.\n    feasible_bins = bins_remain_cap >= item\n\n    # 2. Waste minimization: Prioritize bins with smallest remaining capacity *after* placing the item\n    post_fill_levels = bins_remain_cap - item\n\n    # 3. Infesibility penalty\n    priorities[~feasible_bins] = -np.inf\n\n    # 4. Reward tight fits, penalize waste:\n    waste = post_fill_levels[feasible_bins]\n    bin_size = bins_remain_cap.max()  # Assuming all bins have the same capacity\n    normalized_waste = waste / bin_size  # Waste as a percentage of bin capacity\n\n    priorities[feasible_bins] = -normalized_waste  # Invert waste to make it a priority.\n\n    # 5. Bonus for near-full bins:\n    near_full_threshold = 0.1  # Define a threshold for \"near full\" (e.g., 10% remaining capacity)\n    near_full_bonus = 1\n\n    near_full_bins = feasible_bins & (post_fill_levels >= 0) & (post_fill_levels <= (bin_size * near_full_threshold))  # Only consider non-negative remaining capacities to fix error\n    priorities[near_full_bins] += near_full_bonus\n\n    # 6. Penalize bins that would have too little remaining capacity, to consolidate items.\n    too_little_threshold = 0.2\n    too_little_penalty = -0.5\n\n    too_little_bins = feasible_bins & (post_fill_levels > 0) & (post_fill_levels <= (bin_size * too_little_threshold))\n    priorities[too_little_bins] += too_little_penalty\n\n    # 7. Small item consolidation: bonus if item fits well into near-empty bin\n    near_empty_threshold = 0.9\n    near_empty_bonus = 0.2\n    near_empty_bins = feasible_bins & (bins_remain_cap/bin_size >= near_empty_threshold)\n    item_size_ratio = item / bin_size\n    consolidation_bins = near_empty_bins & (item_size_ratio <= 0.1)  # Small item into near empty bin\n    priorities[consolidation_bins] += near_empty_bonus\n\n\n    # 8. Normalize priorities if no feasible bin exists:\n    if not np.any(feasible_bins):\n        priorities = np.ones_like(priorities)\n\n    return priorities",
    "response_id": 2,
    "obj": 3.7295572397287686,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response3.txt_stdout.txt",
    "code_path": "problem_iter9_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # 1. Feasibility: Only consider bins where the item fits.\n    feasible_bins = bins_remain_cap >= item\n    \n    # 2. Waste minimization: Prioritize bins with smallest remaining capacity *after* placing the item\n    post_fill_levels = bins_remain_cap - item\n    \n    # 3. Infesibility penalty\n    priorities[~feasible_bins] = -np.inf\n    \n    # 4. Reward tight fits, penalize waste:\n    waste = post_fill_levels[feasible_bins]\n    bin_size = bins_remain_cap.max() #Assuming all bins have the same capacity\n    normalized_waste = waste / bin_size #Waste as a percentage of bin capacity\n    \n    priorities[feasible_bins] =  -normalized_waste  #Invert waste to make it a priority.\n\n    # 5. Bonus for near-full bins:\n    near_full_threshold = 0.1  # Define a threshold for \"near full\" (e.g., 10% remaining capacity)\n    near_full_bonus = 1\n\n    near_full_bins = feasible_bins & (post_fill_levels >= 0) & (post_fill_levels <= (bin_size * near_full_threshold))  #Only consider non-negative remaining capacities to fix error\n    priorities[near_full_bins] += near_full_bonus\n    \n    # 6. Penalize bins that would have too little remaining capacity, to consolidate items.\n    too_little_threshold = 0.2\n    too_little_penalty = -0.5\n\n    too_little_bins = feasible_bins & (post_fill_levels > 0) & (post_fill_levels <= (bin_size * too_little_threshold))\n    priorities[too_little_bins] += too_little_penalty\n    \n    # 7. Large item bonus: If item is larger than certain threshold, incentivize filling nearly empty bins\n    large_item_threshold = 0.6\n    nearly_empty_threshold = 0.9\n    nearly_empty_bonus = 0.5\n\n    if item > bin_size * large_item_threshold:\n      nearly_empty_bins = feasible_bins & (bins_remain_cap >= bin_size * nearly_empty_threshold)\n      priorities[nearly_empty_bins] += nearly_empty_bonus\n\n    # 8. Normalize priorities if no feasible bin exists:\n    if not np.any(feasible_bins):\n       priorities = np.ones_like(priorities)\n\n    return priorities",
    "response_id": 3,
    "obj": 3.7295572397287686,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response4.txt_stdout.txt",
    "code_path": "problem_iter9_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: Only consider bins where the item fits.\n    feasible_bins = bins_remain_cap >= item\n\n    # 2. Waste minimization: Prioritize bins with smallest remaining capacity *after* placing the item\n    post_fill_levels = bins_remain_cap - item\n\n    # 3. Infesibility penalty\n    priorities[~feasible_bins] = -np.inf\n\n    # Assuming all bins have the same capacity\n    bin_size = bins_remain_cap.max()\n\n    # 4. Reward tight fits, penalize waste:\n    waste = post_fill_levels[feasible_bins]\n    normalized_waste = waste / bin_size  # Waste as a percentage of bin capacity\n\n    priorities[feasible_bins] = -normalized_waste  # Invert waste to make it a priority.\n\n    # 5. Bonus for near-full bins:\n    near_full_threshold = 0.1  # Define a threshold for \"near full\" (e.g., 10% remaining capacity)\n    near_full_bonus = 1\n\n    near_full_bins = feasible_bins & (post_fill_levels >= 0) & (post_fill_levels <= (bin_size * near_full_threshold))\n    priorities[near_full_bins] += near_full_bonus\n\n    # 6. Penalize bins that would have too little remaining capacity, to consolidate items.\n    too_little_threshold = 0.2\n    too_little_penalty = -0.5\n\n    too_little_bins = feasible_bins & (post_fill_levels > 0) & (post_fill_levels <= (bin_size * too_little_threshold))\n    priorities[too_little_bins] += too_little_penalty\n    \n    # 7. Adaptive penalty for filling up big chunks, favoring small bins when almost full.\n    almost_empty_threshold = 0.9\n    almost_empty_penalty = -0.1\n\n    almost_empty_bins = feasible_bins & (bins_remain_cap > bin_size * almost_empty_threshold)\n    priorities[almost_empty_bins] += almost_empty_penalty\n\n\n    # 8. Normalize priorities if no feasible bin exists:\n    if not np.any(feasible_bins):\n        priorities = np.ones_like(priorities)\n\n    return priorities",
    "response_id": 4,
    "obj": 3.7794176306342333,
    "exec_success": true
  }
]