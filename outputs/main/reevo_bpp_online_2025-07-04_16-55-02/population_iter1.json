[
  {
    "stdout_filepath": "problem_iter1_response0.txt_stdout.txt",
    "code_path": "problem_iter1_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # 1. Feasibility: Only consider bins that can fit the item\n    feasible_bins = bins_remain_cap >= item\n    \n    # 2. Remaining Capacity: Prioritize bins with smaller remaining capacity after placing the item,\n    #    but only if the bin is feasible. This is First-Fit Decreasing like behavior. Avoids fragmentation.\n    remaining_capacity_after_placement = bins_remain_cap - item\n    remaining_capacity_after_placement[remaining_capacity_after_placement < 0] = np.inf  # mark infeasible bins\n    priorities = -remaining_capacity_after_placement\n\n    # 3. Reward for tight fit: Give a bonus to bins where the item fits snugly.\n    #    This encourages filling bins completely.\n    tight_fit_threshold = 0.1  # Adjust as needed\n    tight_fit = (bins_remain_cap - item) <= tight_fit_threshold\n    priorities[tight_fit] += 10  # adjust bonus\n    \n    # 4. Ensure infeasible bins have the lowest priority (very important). Setting to -inf\n    priorities[~feasible_bins] = -np.inf\n    \n\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response1.txt_stdout.txt",
    "code_path": "problem_iter1_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Give higher priority to bins that can accommodate the item\n    can_fit = bins_remain_cap >= item\n    priorities[can_fit] = 1.0\n\n    # If no bin can fit, prioritize bins with the largest remaining capacity\n    if not np.any(can_fit):\n        priorities = bins_remain_cap / np.max(bins_remain_cap) # Normalize\n    else:\n        #Prioritize bins that fit the item closely. Calculate wasted space\n        wasted_space = bins_remain_cap - item\n        wasted_space[~can_fit] = np.inf  # Ignore bins that can't fit\n        \n        min_waste = np.min(wasted_space)\n        \n        # Prioritize bins with the smallest wasted space. Smallest waste gets highest score.\n        close_fit = can_fit & (wasted_space <= (min_waste + 0.1)) #Tolerance added. Otherwise, zero-division occurs\n        priorities[close_fit] = 2.0\n\n        #Prioritize nearly full bins to try and close them\n        nearly_full = can_fit & (bins_remain_cap <= 2*item) #try bins which are almost full first\n        priorities[nearly_full] = 3.0\n\n        \n    return priorities",
    "response_id": 1,
    "obj": 4.447546868767465,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response2.txt_stdout.txt",
    "code_path": "problem_iter1_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Calculate remaining capacity after adding the item.\n    remaining_after_add = bins_remain_cap - item\n\n    # Give high priority to bins where the item fits and leaves less space.\n    fit_mask = remaining_after_add >= 0\n    priorities[fit_mask] = bins_remain_cap[fit_mask] - item # Prioritize lower remaining space\n\n    # If no bins can fit, prioritize the bin that leaves the least negative space.\n    if not np.any(fit_mask):\n       priorities = -abs(remaining_after_add)  # least negative slack\n    else: #give other bins low negative priorities, so no fitting bins always has priority.\n        priorities[~fit_mask] = -np.inf\n    return priorities",
    "response_id": 2,
    "obj": 149.30195452732352,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response3.txt_stdout.txt",
    "code_path": "problem_iter1_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Assign high priority to bins that can accommodate the item\n    # with minimal waste.  Avoids creating many almost-full bins.\n    mask = bins_remain_cap >= item\n    if np.any(mask):\n        waste = bins_remain_cap[mask] - item\n        priorities[mask] = 1 / (waste + 1e-6)  # Minimize waste\n        # Further prioritize bins with small waste relative to bin size.\n\n        relative_waste = waste / bins_remain_cap[mask]\n        priorities[mask] += 1/(relative_waste + 1e-6)\n\n    # Assign low priority to bins that cannot accommodate the item.\n    priorities[bins_remain_cap < item] = -1e9 # Very low priority\n\n    # A bin that is almost full receives lower priority\n    priorities -= 10*(1 - bins_remain_cap/bins_remain_cap.max()) # Encourage bins to be used\n\n    return priorities",
    "response_id": 3,
    "obj": 68.61786996410054,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response4.txt_stdout.txt",
    "code_path": "problem_iter1_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: Only consider bins that can accommodate the item.\n    feasible_bins = bins_remain_cap >= item\n\n    # If no feasible bins, return all -inf\n    if not np.any(feasible_bins):\n        return np.full_like(bins_remain_cap, -np.inf)\n\n    # 2. Remaining capacity after packing: Prefer bins that leave less wasted space.\n    remaining_after_packing = bins_remain_cap - item\n    remaining_after_packing[remaining_after_packing < 0] = np.inf  # Mark infeasible bins as infinitely bad\n\n    # 3. Utilization: Prioritize bins with higher utilization after packing (avoid near-empty bins).\n    utilization = (bins_remain_cap - remaining_after_packing) / bins_remain_cap\n    utilization[~feasible_bins] = 0  # Set utilization of infeasible bins to 0\n\n\n    # Combine these factors into a single priority score.\n\n    priorities = feasible_bins * (1 / (remaining_after_packing + 1e-9))  # higher priority for lower remaining after packing (among feasible bins)\n\n    # Enhance priority using utilization, by adding some weight\n    priorities = priorities + utilization\n\n    return priorities",
    "response_id": 4,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response5.txt_stdout.txt",
    "code_path": "problem_iter1_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Rule 1: Bins that can fit the item get a higher priority.\n    fit_mask = bins_remain_cap >= item\n    priorities[fit_mask] += 1\n\n    # Rule 2: Give higher priority to bins with less remaining capacity (among those that can fit the item)\n    # Prioritize filling up bins to completion. Also adding a small value to avoid division by zero.\n    remaining_capacity_priority = 1 / (bins_remain_cap[fit_mask] + 0.00001)\n    priorities[fit_mask] += remaining_capacity_priority\n\n    # Rule 3: Smallest Wastage Heuristic: Prefer to place the item in the bin that will result in the least wasted space if it fits\n    wastage = bins_remain_cap - item\n    wastage_priority = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    fit_mask2 = bins_remain_cap >= item\n    wastage_priority[fit_mask2] = -wastage[fit_mask2]\n\n    priorities[fit_mask2] += wastage_priority[fit_mask2]\n\n    return priorities",
    "response_id": 5,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response6.txt_stdout.txt",
    "code_path": "problem_iter1_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            # Base priority on how much space is left after placing the item. Favor bins that leave less empty space.\n            remaining_space = cap - item\n            priorities[i] = 1.0 / (remaining_space + 0.0001)  # Avoid division by zero\n            \n            # Give a bonus to bins that are nearly full, so we can close them sooner.\n            if remaining_space <= 0.1:\n                priorities[i] += 10  # Substantially boost the priority\n                \n            # Penalize bins with very high capacity compared to item size.\n            if cap > 2 * item:\n                priorities[i] *= 0.5\n\n    return priorities",
    "response_id": 6,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.99997695000002 seconds"
  },
  {
    "stdout_filepath": "problem_iter1_response7.txt_stdout.txt",
    "code_path": "problem_iter1_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            # Encourage bins that can fit the item reasonably well.\n            # Higher priority for bins where the remaining capacity after adding the item is small but positive.\n            remaining_after_fit = cap - item\n            if remaining_after_fit == 0:\n                priorities[i] = 1000  # Perfect fit, highest priority.\n            else:\n                #Prioritize bins that leave a small fraction of capacity unused.\n                priorities[i] = 1 / (remaining_after_fit + 0.0001)  #Adding a small value to avoid division by zero\n                #Or we can use the capacity used after adding item as a fraction of initial capcity as follows\n                #priorities[i] = (item/cap)*100 # Prioritize based on what proportion of bin capacity would be used.\n\n\n        else:\n            priorities[i] = -100  # Cannot fit, very low priority.\n\n    return priorities",
    "response_id": 7,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.99997725000003 seconds"
  },
  {
    "stdout_filepath": "problem_iter1_response8.txt_stdout.txt",
    "code_path": "problem_iter1_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if item <= cap:\n            # Bin is feasible\n\n            # First Fit Decreasing principle: prefer bins where item fits best\n            # Fill rate heuristic: Choose bins such that fill rate after adding item will be high\n            fill_rate_after = (item + (np.ones_like(bins_remain_cap)*np.sum(bins_remain_cap) - cap)[i]) / np.sum(bins_remain_cap) # fill rate = items in bin / bin_capacity\n\n            # Remaining capacity heuristic: Use almost full bins first\n            remaining_cap_score = (1- (cap - item) / np.max(bins_remain_cap[bins_remain_cap>=item]) ) if np.any(bins_remain_cap>=item) else 0 #prioritize bins which will be fuller after item insertion\n\n            #Prioritize by 1/(remaining capacity)\n            cap_inversed_score = 1/cap\n\n            # Combination\n            priorities[i] = 0.4*remaining_cap_score + 0.6*cap_inversed_score #weightage to each heuristic\n        else:\n            #Bin is not feasible so cannot be selected\n            priorities[i] = -np.inf\n\n    return priorities",
    "response_id": 8,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.99997876999987 seconds"
  },
  {
    "stdout_filepath": "problem_iter1_response9.txt_stdout.txt",
    "code_path": "problem_iter1_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Give high priority to bins that can fit the item with minimal waste.\n    can_fit = bins_remain_cap >= item\n    if np.any(can_fit):\n        waste = bins_remain_cap[can_fit] - item\n        min_waste = np.min(waste)\n        priorities[can_fit] = 1.0 / (1e-6 + waste) # Inverse of waste. Smaller waste, bigger priority. add 1e-6 for numerical stability.\n        priorities[can_fit] += 1 # Give all fitting bins higher priority than non-fitting bins\n\n    # If no bin can fit, give lower priority proportional to remaining capacity\n    else:\n        priorities = bins_remain_cap / np.sum(bins_remain_cap)\n    return priorities",
    "response_id": 9,
    "obj": 4.198244914240141,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response10.txt_stdout.txt",
    "code_path": "problem_iter1_code10.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Give very low priority to bins that cannot fit the item\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -np.inf\n    \n    # For feasible bins:\n\n    # 1. First-Fit-Decreasing heuristic inspired priority: prefer bins with smallest remaining capacity that can still fit item\n    # This favors filling partially-full bins instead of starting new ones\n    feasible_bins = bins_remain_cap >= item\n    if np.any(feasible_bins):\n        priorities[feasible_bins] = bins_remain_cap[feasible_bins] # Smaller remaining cap is better\n\n        # 2. Modified Best-Fit heuristic inspired priority\n        # Smaller wasted space is better. Use only feasible bins from above\n        waste = bins_remain_cap[feasible_bins] - item\n        priorities[feasible_bins] += 1.0 / (waste + 0.0001)  # Add a small constant to avoid division by zero\n    \n        #3. Avoid near perfect fits - they block the bins\n        near_perfect_fit = np.isclose(bins_remain_cap[feasible_bins], item, rtol=1e-05, atol=1e-08)\n        priorities[feasible_bins][near_perfect_fit] *= 0.5 #Reduce priority for perfect fits.\n        \n    return priorities",
    "response_id": 10,
    "obj": 86.58755484643,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response11.txt_stdout.txt",
    "code_path": "problem_iter1_code11.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Give high priority to bins that can fit the item perfectly.\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    priorities[perfect_fit] = 1000  # A very high priority\n\n    # Give high priority to bins with small remaining capacity that can still fit. This tries to fill the bins as much as possible.\n    can_fit = bins_remain_cap >= item\n    \n    #If can fit and not perfect fit (i.e., there exists some leftover capacity).\n    valid_bins = can_fit & ~perfect_fit\n    \n    if np.any(valid_bins): #If there exists at least one bin to fit the item in which there is some leftover capacity.\n      priorities[valid_bins] = (bins_remain_cap[valid_bins] - item)**-1 # the smaller the difference, the higher the priority. If very large differences exist they have low priority.\n    \n    # Penalize bins that cannot fit the item.\n    priorities[~can_fit] = -100 #Very low priority\n    \n\n    return priorities",
    "response_id": 11,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response12.txt_stdout.txt",
    "code_path": "problem_iter1_code12.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            # Basic score based on remaining capacity.  Higher capacity gets a higher base score.\n            priority = cap\n\n            # Bonus for bins where the item fills a significant portion.\n            fill_ratio = item / cap\n            if 0.75 <= fill_ratio <= 1.0:\n                priority += 10  # subtracct to have higher capacity have smaller score. and the more filling one have higher score.\n            elif 0.5 <= fill_ratio < 0.75:\n                 priority += 5\n\n            # Penalize near-full bins.  Try to avoid creating bins that are just barely used.\n            remaining_after_fill = cap - item\n            if 0 < remaining_after_fill <= 0.1: #Avoid creating very small space\n                priority -= 20\n\n            priorities[i] = priority\n\n        else:\n            priorities[i] = -np.inf  # Impossible to place, make it a very low priority.\n\n    return priorities",
    "response_id": 12,
    "obj": 148.9329876346231,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response13.txt_stdout.txt",
    "code_path": "problem_iter1_code13.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # First Fit Decreasing heuristic inspiration: prioritize bins that can fit the item with minimal waste.\n    # However, we are in the online setting, so we adapt the core idea.\n\n    # 1. Bins that cannot fit the item get a negative priority.\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] = -np.inf\n\n    # 2. For feasible bins, prioritize based on remaining capacity AFTER packing the item.\n    feasible_mask = ~infeasible_mask\n    remaining_after_pack = bins_remain_cap[feasible_mask] - item\n    \n    # 3. A smaller remaining capacity is preferred (First Fit Decreasing).\n    # Use a transformation to scale the priority values; avoid division by zero if some bins fit perfectly\n    priorities[feasible_mask] = -remaining_after_pack + np.max(bins_remain_cap) # Larger max to allow for items larger than single bin.\n\n    #4 Introduce noise\n    priorities += np.random.normal(0,0.001, size = bins_remain_cap.shape)\n\n    return priorities",
    "response_id": 13,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response14.txt_stdout.txt",
    "code_path": "problem_iter1_code14.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    # 1. Feasibility: Only consider bins where the item fits.\n    feasible_bins = bins_remain_cap >= item\n    \n    # 2. Waste minimization: Prioritize bins with smallest remaining capacity *after* placing the item\n    post_fill_levels = bins_remain_cap - item\n    post_fill_levels[~feasible_bins] = np.inf  # Ignore infeasible bins when finding minimum\n    \n    # Prioritize bins with the smallest resulting remaining capacity (i.e., most full bin post placement)\n    priorities[feasible_bins] = -post_fill_levels[feasible_bins]\n    \n    # 3. Bonus for near-full bins:\n    near_full_threshold = 0.1  # Define a threshold for \"near full\" (e.g., 10% remaining capacity)\n    near_full_bonus = 10\n    \n    near_full_bins = (post_fill_levels >= 0) & (post_fill_levels <= (bins_remain_cap.max() * near_full_threshold))  #Only consider non-negative remaining capacities to fix error\n    priorities[near_full_bins] += near_full_bonus\n    \n    # 4. Penalize bins that would have too little remaining capacity\n    too_little_threshold = 0.2\n    too_little_penalty = -5\n\n    too_little_bins = (post_fill_levels > 0) & (post_fill_levels/bins_remain_cap.max() <= too_little_threshold)\n    priorities[too_little_bins] += too_little_penalty\n    \n    return priorities",
    "response_id": 14,
    "obj": 3.9589150378939015,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response15.txt_stdout.txt",
    "code_path": "problem_iter1_code15.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # First Fit Decreasing heuristic-inspired component: Give high priority to bins that can fit the item closely\n    fit_check = bins_remain_cap >= item\n    \n    # If no bin can fit the item, return a very negative priority to avoid selecting them (indicates a new bin must be opened)\n    if not np.any(fit_check):\n        return np.full_like(bins_remain_cap, -np.inf)\n    \n    # Give some small penalty to bins that cannot fit the item (without setting to -inf), so bins that fit always are prioritized.\n    priorities[~fit_check] = -1e9 \n\n    # For bins that can fit the item, prioritize bins with smaller remaining capacity *after* placing the item, inspired by Best Fit Decreasing.\n    remaining_after_fit = bins_remain_cap[fit_check] - item\n    priorities[fit_check] = -remaining_after_fit # Lower remaining is better so make the value negative for prioritizing bins with smaller remainings\n\n    # Add a tiny randomness to break ties and potentially explore different configurations\n    priorities[fit_check] += np.random.rand(np.sum(fit_check)) * 1e-6\n    \n    return priorities",
    "response_id": 15,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response16.txt_stdout.txt",
    "code_path": "problem_iter1_code16.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Initialize with a base score (e.g., remaining capacity)\n    priorities = bins_remain_cap.copy()\n\n    # 1. Feasibility: prioritize bins that can actually fit the item\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] = -np.inf # Extremely low priority, practically exclude\n    \n    # 2. Fill ratio: Prioritize bins that would be filled close to full\n    # But not overflowing. Closer to 1 is better\n    fill_ratios = item / bins_remain_cap\n    fill_ratios[infeasible_mask] = 0 # set fill_ratios of invalid bins to 0\n    \n    priorities += 5 * (1 - np.abs(1 - fill_ratios)) # Adding the 'inverse distance' from fill ration to 1.\n\n    # 3. Avoid fragmentation: penalize bins that will have a very small remaining capacity\n    remaining_after_placement = bins_remain_cap - item\n    fragmentation_penalty = np.where(remaining_after_placement > 0, -10 * (remaining_after_placement < 0.1), 0) # heavily penalize if remaining capacity < 0.1\n    priorities += fragmentation_penalty\n    \n    #4. First Fit Adjustment: Slight bias towards bins seen earlier.\n    priorities += 0.01 * np.arange(len(bins_remain_cap))\n\n    return priorities",
    "response_id": 16,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 20, in priority_v2\n    remaining_after_fit = bins_remain_cap[fit_mask] - item\nOverflowError: cannot convert float infinity to integer\n"
  },
  {
    "stdout_filepath": "problem_iter1_response17.txt_stdout.txt",
    "code_path": "problem_iter1_code17.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Heuristic 1: Prefer bins that can fit the item.\n    fit_mask = bins_remain_cap >= item\n    priorities[fit_mask] += 1\n\n    # Heuristic 2: Among bins that fit, prefer those with least remaining capacity after placing item.\n    remaining_after_fit = bins_remain_cap[fit_mask] - item\n    priorities[fit_mask] += np.exp(-remaining_after_fit) # Smaller remaining capacity gets higher priority\n\n    # Heuristic 3: Penalize bins that cannot fit\n    no_fit_mask = bins_remain_cap < item\n    priorities[no_fit_mask] -= (item - bins_remain_cap[no_fit_mask])**2 # Larger the gap higher the penalty.\n\n\n    #Heuristic 4: If no bins can fit, prefer bins with largest capacity (least waste if a future large item comes).\n    if not np.any(fit_mask):\n        priorities += bins_remain_cap / np.max(bins_remain_cap)\n    return priorities",
    "response_id": 17,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response18.txt_stdout.txt",
    "code_path": "problem_iter1_code18.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            waste = cap - item\n            # Prioritize bins that minimize waste, but also consider bin utilization.\n            priorities[i] = (item / cap) - (waste / np.sum(bins_remain_cap))  # Favor bins with high item/capacity ratio, penalized by waste compared to total capacity\n\n            # If it's a near fit, heavily prioritize\n            if waste <= 0.1 * item: #arbitrary small number. Tune it.\n                priorities[i] += 1.0 # boost the priority\n\n        else:\n            priorities[i] = -np.inf # Or a very small negative number if necessary.\n\n    return priorities",
    "response_id": 18,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.999992250000105 seconds"
  },
  {
    "stdout_filepath": "problem_iter1_response19.txt_stdout.txt",
    "code_path": "problem_iter1_code19.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            # Best Fit heuristic: Prefer bins with capacity close to item size.\n            priorities[i] = (cap - item)**-1 # Inverse of wasted space. Prevents division by zero when item perfectly fits.  Higher value means fits more nicely\n            \n            #Modified first fit: prioritizes partially filled bins\n            if cap > item: # Encourages filling bins partially\n                 priorities[i] *= 1.1 #Give slight additional priority to encourage partially filling\n\n        else:\n            priorities[i] = -np.inf  # Cannot fit, so assign lowest priority.\n    return priorities",
    "response_id": 19,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response20.txt_stdout.txt",
    "code_path": "problem_iter1_code20.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    # 1. Feasibility: Only consider bins that can accommodate the item\n    feasible_bins = bins_remain_cap >= item\n    \n    if not np.any(feasible_bins): # If item cannot be placed in any bin, return 0 for all, to denote item placement failure handling outside\n        return priorities\n\n    # 2. Remaining capacity after placement\n    remaining_capacity_after_placement = bins_remain_cap - item\n    remaining_capacity_after_placement[remaining_capacity_after_placement < 0] = -1 #Mark infeasible bins\n\n    # 3. Score based on how full the bin will be (higher is better) among feasible bins. Use scaled remaining capacity instead of direct remaining capacity.\n    \n    priorities[feasible_bins] = 1 - (remaining_capacity_after_placement[feasible_bins] / bins_remain_cap[feasible_bins])\n    \n    # 4. Tie-breaking: Prefer bins with smaller remaining capacity after placement (more full, higher priority)\n    # Add small amount to differentiate between equal priorities derived from fullness, to avoid issues that could occur when np.argmax is used.\n\n    priorities[feasible_bins] += (bins_remain_cap[feasible_bins].max() - remaining_capacity_after_placement[feasible_bins])/bins_remain_cap[feasible_bins].max()*0.0001 #Add small amount\n\n    return priorities",
    "response_id": 20,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 32, in priority_v2\nnumpy._core._exceptions._UFuncOutputCastingError: Cannot cast ufunc 'add' output from dtype('float64') to dtype('int64') with casting rule 'same_kind'\n"
  },
  {
    "stdout_filepath": "problem_iter1_response21.txt_stdout.txt",
    "code_path": "problem_iter1_code21.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Assign very low priority to bins that cannot accommodate the item\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] = -np.inf\n\n    # For feasible bins, prioritize based on the remaining capacity *after* placing the item\n    feasible_mask = bins_remain_cap >= item\n    remaining_capacity_after_placement = bins_remain_cap[feasible_mask] - item\n    \n    #Give large value when there's small wastage (Best fit approximation)\n    priorities[feasible_mask] = np.exp(-np.abs(remaining_capacity_after_placement))\n    \n    #Further refine the priority by considering the fill ratio *before* placement\n    fill_ratio_before_placement = 1 - (bins_remain_cap[feasible_mask] / np.max(bins_remain_cap)) #Scaled to max bin capacity so no scaling issue.\n\n    priorities[feasible_mask] = priorities[feasible_mask] + fill_ratio_before_placement # Add the fill ration to further prioritize bins which already filled.\n        \n    return priorities",
    "response_id": 21,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response22.txt_stdout.txt",
    "code_path": "problem_iter1_code22.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            waste = cap - item\n            # Prioritize bins with smallest waste, but give a boost to almost full bins\n            priorities[i] = (1 / (waste + 0.0001)) + (100 if waste < 0.1 else 0)  # Add a small constant to avoid division by zero\n\n        else:\n            priorities[i] = -1000 # Very low priority if item doesn't fit\n    return priorities",
    "response_id": 22,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response23.txt_stdout.txt",
    "code_path": "problem_iter1_code23.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Calculate wasted space if item is placed in each bin\n    wasted_space = bins_remain_cap - item\n\n    # Give high priority to bins where the item fits and wasted space is minimized\n    fit_indices = wasted_space >= 0\n    if np.any(fit_indices):\n        priorities[fit_indices] = 1 / (wasted_space[fit_indices] + 1e-6) # Avoid division by zero\n        # Boost bins that are filled most efficiently.\n        fill_ratios = item / bins_remain_cap[fit_indices]\n        priorities[fit_indices] *= fill_ratios**2 # Further promote well-filled bins\n\n    # If no bin fits, assign a very low priority (negative to clearly indicate this case)\n    else:\n        priorities = -1 * np.ones_like(bins_remain_cap)\n        # Assign priority based on \"how much\" it overflows\n        overflow_amount = item - bins_remain_cap\n        priorities = - overflow_amount\n        priorities = priorities / np.sum(overflow_amount)  #normalize, so a smaller overflow gets a higher priority among the overflowed bins\n\n    return priorities",
    "response_id": 23,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response24.txt_stdout.txt",
    "code_path": "problem_iter1_code24.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            # Primary criterion: how much space is left *after* placing the item\n            remaining_after_fit = cap - item\n            \n            # Give preference to bins that would leave less space after fitting.  Bins with nearly perfect fit get very high priority. Bins that will leave very large space will be ranked lower but not 0\n            priorities[i] = (1.0 / (remaining_after_fit + 0.0001))  # Avoid division by zero, prioritize tighter fits\n\n            #Bonus for fitting more items\n            items_fitted=0\n            if(remaining_after_fit > 0):\n                 items_fitted = np.floor(remaining_after_fit/np.mean(item))\n\n            priorities[i] += items_fitted *0.01\n\n            \n        else:\n            # Item doesn't fit: lowest priority\n            priorities[i] = -1e9  #Very low priority\n\n    return priorities",
    "response_id": 24,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.999991089000105 seconds"
  },
  {
    "stdout_filepath": "problem_iter1_response25.txt_stdout.txt",
    "code_path": "problem_iter1_code25.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            # First-Fit Decreasing heuristic inspiration: prefer bins where the item fits best (but not perfectly)\n            priority = (cap - item) / cap  # Smaller waste is better\n            # Avoid near-perfect fits (e.g., waste close to zero) to leave flexibility\n            if cap - item < 0.1: # Adjust 0.1 if the optimal wasted space is known to be closer or further\n              priority = -1 # A negative value serves to avoid these placements. The thresholding could be adapted according to prior knowledge\n\n            #Prioritize bins with larger capacity. This should improve on average\n            #Since items are packed into relatively emptier bins which will on average\n            #lead to a better long-run capacity use.\n            priority = priority + cap\n\n            priorities[i] = priority\n        else:\n            priorities[i] = -np.inf  # Impossible to fit, lowest priority\n\n    return priorities",
    "response_id": 25,
    "obj": 149.30195452732352,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response26.txt_stdout.txt",
    "code_path": "problem_iter1_code26.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: Can the item fit?\n    feasible_bins = bins_remain_cap >= item\n\n    # 2. Remaining Capacity: Prefer bins with enough space, but not too much.\n    remaining_space = bins_remain_cap - item\n    # Scale the remaining space to [0,1]\n    scaled_remaining_space = np.clip(remaining_space / np.max(bins_remain_cap), 0, 1) if np.max(bins_remain_cap) > 0 else np.zeros_like(remaining_space)\n\n    # 3. Fill percentage\n    fill_percentage = 1 - scaled_remaining_space\n\n    # Calculate priority for feasible bins\n    priorities[feasible_bins] = fill_percentage[feasible_bins]\n\n    #Very small remaining cap is better (higher priority)\n    priorities[feasible_bins] += 1/(bins_remain_cap[feasible_bins]+1e-6)\n\n    #4. If there's little free capacity (close to item size), boost the priority to nearly force the placement\n    close_to_full = (bins_remain_cap >= item) & (bins_remain_cap < item*1.1) #can adjust the multiplier. A smaller value means closer to being packed.\n    priorities[close_to_full] += 10 # high constant, makes bin very favorable for placing the current item\n\n\n    return priorities",
    "response_id": 26,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response27.txt_stdout.txt",
    "code_path": "problem_iter1_code27.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Rule 1: Prefer bins that can fit the item\n    fit_mask = bins_remain_cap >= item\n    priorities[fit_mask] += 1\n\n    # Rule 2: Among bins that can fit, prefer those with less wasted space after fitting.\n    wasted_space = bins_remain_cap - item\n    wasted_space[wasted_space < 0] = np.inf  # Ignore bins that cannot fit.\n\n    # Normalize wasted space to prioritize bins with smallest waste\n    normalized_waste = 1 / (1 + wasted_space) # higher is better\n    priorities[fit_mask] += normalized_waste[fit_mask]\n\n    # Rule 3: Add a bonus for bins that are close to full before adding the item\n    # Helps utilize bins effectively before opening new ones.\n\n    fullness = 1 - (bins_remain_cap / np.max(bins_remain_cap)) # scale to between 0 and 1\n    priorities[fit_mask] += fullness[fit_mask] * 0.5 # weigh it by 0.5\n\n\n    # Rule 4: Apply a penalty to bins that would become almost full after adding the item.\n    # Helps avoid bins that are almost full but still requires opening another one.\n\n    almost_full_threshold = 0.1 # if after packing the bins has 10% of space remaining\n    remaining_after_pack = bins_remain_cap - item\n    almost_full_mask = (remaining_after_pack > 0) & (remaining_after_pack / np.max(bins_remain_cap) <= almost_full_threshold)\n    priorities[almost_full_mask] -= 0.2 # slight penalty\n\n\n    return priorities",
    "response_id": 27,
    "obj": 4.168328679696844,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response28.txt_stdout.txt",
    "code_path": "problem_iter1_code28.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Calculate remaining capacity after adding the item\n    remaining_after_add = bins_remain_cap - item\n\n    # Give high priority to bins where the item fits and the remaining capacity is minimized (but not negative)\n    fit_indices = remaining_after_add >= 0\n    if np.any(fit_indices):\n        priorities[fit_indices] = 1 / (remaining_after_add[fit_indices] + 0.00001) #avoid division by zero\n\n    # For bins where item doesn't fit, assign a negative priority.  The magnitude reflects how badly it doesn't fit\n    no_fit_indices = ~fit_indices\n    if np.any(no_fit_indices):\n         priorities[no_fit_indices] = -(item - bins_remain_cap[no_fit_indices]) # Negative values. Larger when the item cannot fit\n\n    return priorities",
    "response_id": 28,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response29.txt_stdout.txt",
    "code_path": "problem_iter1_code29.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # High priority if the item fits snugly (but not perfectly)\n    fit_snugly = (bins_remain_cap >= item) & (bins_remain_cap < 1.2 * item)\n    priorities[fit_snugly] += 10\n\n    # Moderate priority if the item fits with some space to spare\n    fit_ok = (bins_remain_cap >= item)\n    priorities[fit_ok] += (bins_remain_cap[fit_ok] - item) / np.max(bins_remain_cap)\n\n    # Give a lower priority to almost full bins as we want to keep them for small items\n    almost_full = (bins_remain_cap > 0) & (bins_remain_cap <= 0.2)\n    priorities[almost_full] -= 5\n        \n    # Give a higher penalty if the item doesn't fit\n    doesnt_fit = bins_remain_cap < item\n    priorities[doesnt_fit] = -np.inf\n\n    return priorities",
    "response_id": 29,
    "obj": 55.5145592341444,
    "exec_success": true
  }
]