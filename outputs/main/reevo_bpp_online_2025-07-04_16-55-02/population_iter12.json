[
  {
    "stdout_filepath": "problem_iter12_response0.txt_stdout.txt",
    "code_path": "problem_iter12_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_size = bins_remain_cap.max()\n\n    # 1. Feasibility: Only consider bins where the item fits.\n    feasible_bins = bins_remain_cap >= item\n\n    # 2. Waste Minimization: Primary objective is to minimize waste.\n    post_fill_levels = bins_remain_cap - item\n    priorities[feasible_bins] = -post_fill_levels[feasible_bins] / bin_size  # Directly use negative normalized waste\n\n    # 3. Infeasibility Penalty: Strong penalty for infeasible bins.\n    priorities[~feasible_bins] = -np.inf\n\n    # 4. Tight Fit Bonus: Significant bonus for bins that become nearly full.\n    near_full_threshold = 0.05  # Even tighter fit\n    near_full_bonus = 3.0  # Increased bonus\n\n    near_full_bins = feasible_bins & (post_fill_levels >= 0) & (post_fill_levels <= (bin_size * near_full_threshold))\n    \n    # Dynamic tight fit bonus based on how tight fit is\n    tight_fit_scale = 1 - (post_fill_levels[near_full_bins] / (bin_size * near_full_threshold))\n    priorities[near_full_bins] += near_full_bonus * tight_fit_scale\n\n    # 5. Consolidate Items: Penalize bins with very small remaining capacity.\n    too_little_threshold = 0.15\n    too_little_penalty = -2.0  # Stronger penalty\n\n    too_little_bins = feasible_bins & (post_fill_levels > 0) & (post_fill_levels <= (bin_size * too_little_threshold))\n    \n    # Dynamic adjustment of consolidation penalty based on item size\n    consolidation_penalty_scale = item / bin_size\n    priorities[too_little_bins] += too_little_penalty * consolidation_penalty_scale\n\n    # 6. Large Item Strategy: Fill nearly empty bins if the item is large.\n    large_item_threshold = 0.7\n    nearly_empty_threshold = 0.95\n    nearly_empty_bonus = 2.5\n\n    if item > bin_size * large_item_threshold:\n        nearly_empty_bins = feasible_bins & (bins_remain_cap >= bin_size * nearly_empty_threshold)\n        priorities[nearly_empty_bins] += nearly_empty_bonus\n\n    # 7. Slightly prefer bins that are already relatively full\n    already_full_threshold = 0.85\n    already_full_bonus = 0.5\n\n    already_full_bins = feasible_bins & (bins_remain_cap <= bin_size * (1 - already_full_threshold))\n    priorities[already_full_bins] += already_full_bonus\n\n    # 8. Item size based waste minimization adjustment:\n    # Bigger items should prioritize bins closer to their size\n    waste = post_fill_levels[feasible_bins]\n    item_size_proximity_bonus = np.exp(-np.abs(waste - (bin_size - item)) / bin_size)  # Gaussian-like bonus\n    priorities[feasible_bins] += item_size_proximity_bonus * 0.2 #Scaling this proximity bonus\n\n    # 9. Handle No Feasible Bins: Ensure a bin is always chosen.\n    if not np.any(feasible_bins):\n        # Find the bin with minimum waste if item were placed (even if it overflows)\n        waste = item - bins_remain_cap\n        min_waste_bin = np.argmin(waste)\n        priorities[min_waste_bin] = 0.01  # Very small positive priority\n        priorities[waste > 0] = -np.inf  # Still prefer to only overflow the least\n    \n    return priorities",
    "response_id": 0,
    "obj": 2.602712405265271,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response1.txt_stdout.txt",
    "code_path": "problem_iter12_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_size = bins_remain_cap.max()  # Assuming all bins have same capacity\n\n    # 1. Feasibility: Only consider bins where the item fits.\n    feasible_bins = bins_remain_cap >= item\n\n    # 2. Calculate post-fill levels directly\n    post_fill_levels = bins_remain_cap - item\n\n    # 3. Infeasibility penalty: Set priority to -inf for infeasible bins\n    priorities[~feasible_bins] = -np.inf\n\n    # 4. Waste minimization: Prioritize bins with smallest remaining capacity *after* placing the item\n    waste = post_fill_levels[feasible_bins]\n    normalized_waste = waste / bin_size  # Waste as a percentage of bin capacity\n\n    priorities[feasible_bins] = -normalized_waste  # Invert waste to make it a priority.\n\n    # 5. Bonus for near-full bins: Incentivize tight packing\n    near_full_threshold = 0.1\n    near_full_bonus = 1\n    near_full_bins = feasible_bins & (post_fill_levels >= 0) & (post_fill_levels <= (bin_size * near_full_threshold))\n    priorities[near_full_bins] += near_full_bonus\n\n    # 6. Penalize bins that would have too little remaining capacity, to consolidate items.\n    too_little_threshold = 0.2\n    too_little_penalty = -0.5\n    too_little_bins = feasible_bins & (post_fill_levels > 0) & (post_fill_levels <= (bin_size * too_little_threshold))\n    priorities[too_little_bins] += too_little_penalty\n\n    # 7. Large item bonus: If item is larger than a certain threshold, incentivize filling nearly empty bins\n    large_item_threshold = 0.6\n    nearly_empty_threshold = 0.9\n    nearly_empty_bonus = 0.5\n\n    if item > bin_size * large_item_threshold:\n        nearly_empty_bins = feasible_bins & (bins_remain_cap >= bin_size * nearly_empty_threshold)\n        priorities[nearly_empty_bins] += nearly_empty_bonus\n\n    # 8. Normalize priorities if no feasible bin exists, provide a minimal preference\n    if not np.any(feasible_bins):\n        # Prefer bins with more space if no feasible bin exists.\n        priorities = bins_remain_cap / bin_size\n    else:\n        # Normalize feasible priorities to be between 0 and 1\n        feasible_priorities = priorities[feasible_bins]\n        min_priority = np.min(feasible_priorities)\n        max_priority = np.max(feasible_priorities)\n        if max_priority > min_priority:\n            priorities[feasible_bins] = (feasible_priorities - min_priority) / (max_priority - min_priority)\n        else:\n            priorities[feasible_bins] = 0.5  # Assign a neutral value if all priorities are the same\n\n    return priorities",
    "response_id": 1,
    "obj": 3.7295572397287686,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response2.txt_stdout.txt",
    "code_path": "problem_iter12_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_size = bins_remain_cap.max()\n\n    # 1. Feasibility: Only consider bins where the item fits.\n    feasible_bins = bins_remain_cap >= item\n\n    # 2. Waste Minimization: Primary objective is to minimize waste.\n    post_fill_levels = bins_remain_cap - item\n    priorities[feasible_bins] = -post_fill_levels[feasible_bins] / bin_size  # Directly use negative normalized waste\n\n    # 3. Infeasibility Penalty:  Strong penalty for infeasible bins.\n    priorities[~feasible_bins] = -np.inf\n\n    # 4. Tight Fit Bonus: Significant bonus for bins that become nearly full.\n    near_full_threshold = 0.05  # Even tighter fit\n    near_full_bonus = 3.0  # Increased bonus\n\n    near_full_bins = feasible_bins & (post_fill_levels >= 0) & (post_fill_levels <= (bin_size * near_full_threshold))\n    priorities[near_full_bins] += near_full_bonus\n\n    # 5. Consolidate Items: Penalize bins with very small remaining capacity.\n    too_little_threshold = 0.15\n    too_little_penalty = -2.0  # Stronger penalty\n\n    too_little_bins = feasible_bins & (post_fill_levels > 0) & (post_fill_levels <= (bin_size * too_little_threshold))\n    priorities[too_little_bins] += too_little_penalty\n\n    # 6. Dynamic penalty based on remaining capacity and item size\n    capacity_ratio = bins_remain_cap / bin_size\n    item_ratio = item / bin_size\n    dynamic_penalty = -np.abs(capacity_ratio[feasible_bins] - item_ratio)\n    priorities[feasible_bins] += dynamic_penalty\n\n    # 7. Large Item Strategy: Fill nearly empty bins if the item is large.\n    large_item_threshold = 0.7\n    nearly_empty_threshold = 0.95\n    nearly_empty_bonus = 2.5\n\n    if item > bin_size * large_item_threshold:\n        nearly_empty_bins = feasible_bins & (bins_remain_cap >= bin_size * nearly_empty_threshold)\n        priorities[nearly_empty_bins] += nearly_empty_bonus\n\n    # 8. Slightly prefer bins that are already relatively full\n    already_full_threshold = 0.85\n    already_full_bonus = 0.5\n\n    already_full_bins = feasible_bins & (bins_remain_cap <= bin_size * (1 - already_full_threshold))\n    priorities[already_full_bins] += already_full_bonus\n\n    # 9. Handle No Feasible Bins:  Ensure a bin is always chosen.\n    if not np.any(feasible_bins):\n       # Find the bin with the maximum remaining capacity among infeasible bins.\n        max_infeasible_cap = np.max(bins_remain_cap[~feasible_bins], initial=-1)\n\n        # If there are infeasible bins\n        if max_infeasible_cap > -1:\n            best_infeasible_bin = np.argmax(bins_remain_cap == max_infeasible_cap)\n            priorities[best_infeasible_bin] = -1e-6 # Very small value\n        else: #no bins at all\n           priorities = np.zeros_like(priorities) # keep same size\n           priorities[0] = -1e-6\n\n    return priorities",
    "response_id": 2,
    "obj": 2.4331870761866865,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response3.txt_stdout.txt",
    "code_path": "problem_iter12_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_size = bins_remain_cap.max()  # Assuming all bins have the same capacity\n\n    # 1. Feasibility: Only consider bins where the item fits.\n    feasible_bins = bins_remain_cap >= item\n\n    # 2. Infeasibility penalty: Set to -inf for bins that cannot fit the item.\n    priorities[~feasible_bins] = -np.inf\n\n    # 3. Waste Minimization (Normalized): Prioritize bins with minimal *normalized* waste.\n    post_fill_levels = bins_remain_cap - item\n    normalized_waste = post_fill_levels / bin_size\n    priorities[feasible_bins] = -normalized_waste[feasible_bins]  # Invert waste to priority.\n\n    # 4. Consolidation Bonus: Reward bins that become near-full.\n    near_full_threshold = 0.1\n    near_full_bonus = 1.0\n    near_full_bins = feasible_bins & (post_fill_levels >= 0) & (normalized_waste <= near_full_threshold)\n    priorities[near_full_bins] += near_full_bonus\n\n    # 5. Fragmentation Penalty: Penalize bins that would have very little remaining capacity.\n    tiny_rem_threshold = 0.2\n    tiny_rem_penalty = -0.5\n    tiny_rem_bins = feasible_bins & (post_fill_levels > 0) & (normalized_waste <= tiny_rem_threshold)\n    priorities[tiny_rem_bins] += tiny_rem_penalty\n\n    # 6. Perfect Fit Bonus: Substantially reward perfect fits.\n    perfect_fit_bonus = 2.0\n    perfect_fit_bins = np.isclose(bins_remain_cap, item) & feasible_bins\n    priorities[perfect_fit_bins] += perfect_fit_bonus\n\n    # 7. Handle Infeasible Case: If no bins fit, assign priorities based on remaining capacity.\n    if not np.any(feasible_bins):\n        # Prioritize bins that are closest to fitting the item.\n        capacity_diff = item - bins_remain_cap\n\n        #Assign very low priority to bins that can not fit the item\n        priorities = -capacity_diff\n        priorities[bins_remain_cap <=0] = -np.inf\n\n        #Scale priority by bin size to avoid extreme high/low value, and shift value by 1, so the value is negative\n        priorities = priorities / bin_size - 1\n        priorities[bins_remain_cap <= 0] = -np.inf #make sure infeasible bins are still the lowest priority.\n\n    return priorities",
    "response_id": 3,
    "obj": 3.7295572397287686,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response4.txt_stdout.txt",
    "code_path": "problem_iter12_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_size = bins_remain_cap.max()\n\n    # 1. Feasibility: Only consider bins where the item fits.\n    feasible_bins = bins_remain_cap >= item\n\n    # 2. Waste Minimization: Primary objective is to minimize waste.\n    post_fill_levels = bins_remain_cap - item\n    normalized_waste = post_fill_levels / bin_size\n    priorities[feasible_bins] = -normalized_waste[feasible_bins]\n\n    # 3. Infeasibility Penalty: Strong penalty for infeasible bins.\n    priorities[~feasible_bins] = -np.inf\n\n    # 4. Tight Fit Bonus: Significant bonus for bins that become nearly full. Dynamic bonus.\n    near_full_threshold = 0.05\n    near_full_bonus = 3.0 * np.exp(-item / bin_size)  # Bonus depends on relative item size\n\n    near_full_bins = feasible_bins & (post_fill_levels >= 0) & (post_fill_levels <= (bin_size * near_full_threshold))\n    priorities[near_full_bins] += near_full_bonus\n\n    # 5. Consolidate Items: Penalize bins with very small remaining capacity. Dynamic penalty.\n    too_little_threshold = 0.15\n    too_little_penalty = -2.0 * (1 - item / bin_size)  # Penalty inversely proportional to item size.\n\n    too_little_bins = feasible_bins & (post_fill_levels > 0) & (post_fill_levels <= (bin_size * too_little_threshold))\n    priorities[too_little_bins] += too_little_penalty\n\n    # 6. Large Item Strategy: Fill nearly empty bins if the item is large.\n    large_item_threshold = 0.7\n    nearly_empty_threshold = 0.95\n    nearly_empty_bonus = 2.0\n\n    if item > bin_size * large_item_threshold:\n        nearly_empty_bins = feasible_bins & (bins_remain_cap >= bin_size * nearly_empty_threshold)\n        priorities[nearly_empty_bins] += nearly_empty_bonus\n\n    # 7. Preferentially choose bins that are already relatively full - small bonus\n    already_full_threshold = 0.85\n    already_full_bonus = 0.3\n\n    already_full_bins = feasible_bins & (bins_remain_cap <= bin_size * (1 - already_full_threshold))\n    priorities[already_full_bins] += already_full_bonus\n\n    # 8. Introduce a small bonus for bins close to the average fill level\n\n    fill_levels = bins_remain_cap / bin_size\n    avg_fill = np.mean(fill_levels)\n    similar_fill_threshold = 0.1\n    similar_fill_bonus = 0.15\n\n    similar_fill_bins = feasible_bins & (np.abs(fill_levels - avg_fill) <= similar_fill_threshold)\n    priorities[similar_fill_bins] += similar_fill_bonus\n    \n    # 9. Dynamic adjustment based on global bin fill levels\n    global_fill_level = np.sum(bin_size - bins_remain_cap) / (len(bins_remain_cap) * bin_size)\n\n    # Encourage filling if bins are mostly empty, discourage if mostly full\n    global_fill_adjustment = 0.5 * (global_fill_level - 0.5)  # Scale adjustment\n\n    priorities[feasible_bins] += global_fill_adjustment\n    \n\n    # 10. Handle No Feasible Bins: Select the least infeasible bin with a small score.\n    if not np.any(feasible_bins):\n      least_infeasible_bin = np.argmin(bins_remain_cap + item)\n      priorities[least_infeasible_bin] = -0.01  # Very small, negative priority\n\n    return priorities",
    "response_id": 4,
    "obj": 2.5029916234543417,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response5.txt_stdout.txt",
    "code_path": "problem_iter12_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_size = bins_remain_cap.max()\n\n    # 1. Feasibility: Only consider bins where the item fits.\n    feasible_bins = bins_remain_cap >= item\n\n    # 2. Waste Minimization: Primary objective is to minimize waste.\n    post_fill_levels = bins_remain_cap - item\n    waste = post_fill_levels / bin_size\n    priorities[feasible_bins] = -waste[feasible_bins]\n\n    # 3. Infeasibility Penalty: Strong penalty for infeasible bins.\n    priorities[~feasible_bins] = -np.inf\n\n    # 4. Tight Fit Bonus: Significant bonus for bins that become nearly full.\n    near_full_threshold = 0.05\n    near_full_bonus = 3.0\n    near_full_bins = feasible_bins & (post_fill_levels >= 0) & (waste <= near_full_threshold)\n    priorities[near_full_bins] += near_full_bonus\n\n    # 5. Fragmentation Penalty: Penalize bins that would result in small remaining capacity.\n    frag_threshold = 0.15\n    frag_penalty = -2.0\n    frag_bins = feasible_bins & (post_fill_levels > 0) & (waste <= frag_threshold)\n    priorities[frag_bins] += frag_penalty\n\n    # 6. Large Item Strategy: Preferentially fill bins close to full or nearly empty if item is large\n    large_item_threshold = 0.7\n    nearly_empty_threshold = 0.95\n    nearly_full_threshold = 0.2 #Bins close to full\n    large_item_bonus = 2.5\n\n    if item > bin_size * large_item_threshold:\n        nearly_empty_bins = feasible_bins & (bins_remain_cap >= bin_size * nearly_empty_threshold)\n        nearly_full_bins = feasible_bins & (bins_remain_cap <= bin_size * nearly_full_threshold)\n        priorities[nearly_empty_bins] += large_item_bonus\n        priorities[nearly_full_bins] += large_item_bonus\n\n    # 7. Dynamic Waste Penalty: Adjust waste penalty based on item size. Larger items increase waste penalty.\n    item_ratio = item / bin_size\n    dynamic_waste_penalty = -waste * (1 + item_ratio)\n    priorities[feasible_bins] += dynamic_waste_penalty[feasible_bins]\n\n    # 8. Prefer bins that are already relatively full.\n    already_full_threshold = 0.85\n    already_full_bonus = 0.5\n    already_full_bins = feasible_bins & (bins_remain_cap <= bin_size * (1 - already_full_threshold))\n    priorities[already_full_bins] += already_full_bonus\n\n\n    # 9. Handle No Feasible Bins: Add item to the bin that *least* exceeds its capacity.\n    if not np.any(feasible_bins):\n        overfill_amounts = item - bins_remain_cap\n        min_overfill = np.min(overfill_amounts)\n        best_infeasible_bin = np.argmin(overfill_amounts)\n        priorities[best_infeasible_bin] = -1e-6\n\n    return priorities",
    "response_id": 5,
    "obj": 2.4331870761866865,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response6.txt_stdout.txt",
    "code_path": "problem_iter12_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_size = bins_remain_cap.max()\n\n    # 1. Feasibility: Only consider bins where the item fits.\n    feasible_bins = bins_remain_cap >= item\n\n    # 2. Waste Minimization: Primary objective is to minimize waste.\n    post_fill_levels = bins_remain_cap - item\n    priorities[feasible_bins] = -post_fill_levels[feasible_bins] / bin_size  # Directly use negative normalized waste\n\n    # 3. Infeasibility Penalty: Strong penalty for infeasible bins.\n    priorities[~feasible_bins] = -np.inf\n\n    # 4. Tight Fit Bonus: Significant bonus for bins that become nearly full.\n    near_full_threshold = 0.05  # Even tighter fit\n    near_full_bonus = 2.0  # Increased bonus\n    near_full_bins = feasible_bins & (post_fill_levels >= 0) & (post_fill_levels <= (bin_size * near_full_threshold))\n    priorities[near_full_bins] += near_full_bonus\n\n    # 5. Consolidate Items: Penalize bins with very small remaining capacity.\n    too_little_threshold = 0.15\n    too_little_penalty = -1.0  # Stronger penalty\n    too_little_bins = feasible_bins & (post_fill_levels > 0) & (post_fill_levels <= (bin_size * too_little_threshold))\n    priorities[too_little_bins] += too_little_penalty\n    \n    # 6. Prioritize already full bins\n    already_full_threshold = 0.8\n    already_full_bonus = 0.5\n    already_full_bins = feasible_bins & (bins_remain_cap <= (1 - already_full_threshold) * bin_size)\n    priorities[already_full_bins] += already_full_bonus\n    \n\n    # 7. Handle No Feasible Bins: Ensure a bin is always chosen.\n    if not np.any(feasible_bins):\n        # Open a new bin only if all bins are full.\n        if np.all(bins_remain_cap <= 0):\n            priorities = np.ones_like(priorities) * 0.01  # Small positive value for new bin\n        else:\n            # Assign priority based on how close they are to full.  Prefer to open fullest bin.\n            priorities = (bin_size - bins_remain_cap) / bin_size * 0.01  # Still small positive value\n\n    return priorities",
    "response_id": 6,
    "obj": 2.4531312325488766,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response7.txt_stdout.txt",
    "code_path": "problem_iter12_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_size = bins_remain_cap.max()  # Assuming all bins have same capacity\n\n    # 1. Feasibility: Only consider bins where the item fits.\n    feasible_bins = bins_remain_cap >= item\n\n    # 2. Calculate post-fill levels directly\n    post_fill_levels = bins_remain_cap - item\n\n    # 3. Infeasibility penalty: Set priority to -inf for infeasible bins\n    priorities[~feasible_bins] = -np.inf\n\n    # 4. Waste minimization: Prioritize bins with smallest waste after placing the item\n    waste = post_fill_levels\n    normalized_waste = waste / bin_size\n    priorities[feasible_bins] = -normalized_waste[feasible_bins] # Apply only to feasible bins\n\n    # 5. Bonus for near-full bins: Incentivize tight packing. Stronger bonus.\n    near_full_threshold = 0.05\n    near_full_bonus = 5  #Increased Bonus\n    near_full_bins = feasible_bins & (post_fill_levels >= 0) & (post_fill_levels <= (bin_size * near_full_threshold))\n    priorities[near_full_bins] += near_full_bonus\n\n    # 6. Penalize bins that would have too little remaining capacity, to consolidate items. Reduced Penalty.\n    too_little_threshold = 0.2\n    too_little_penalty = -0.1 # Reduced penalty\n    too_little_bins = feasible_bins & (post_fill_levels > 0) & (post_fill_levels <= (bin_size * too_little_threshold))\n    priorities[too_little_bins] += too_little_penalty\n\n    # 7. Large item bonus: If item is larger than a certain threshold, incentivize filling nearly empty bins\n    large_item_threshold = 0.7\n    nearly_empty_threshold = 0.9\n    nearly_empty_bonus = 2 #Increased bonus\n\n    if item > bin_size * large_item_threshold:\n        nearly_empty_bins = feasible_bins & (bins_remain_cap >= bin_size * nearly_empty_threshold)\n        priorities[nearly_empty_bins] += nearly_empty_bonus\n\n    # 8. Small item bonus: Encourage using bins with more space if the item is small\n    small_item_threshold = 0.3\n    if item < bin_size * small_item_threshold:\n        # Prioritize bins with a higher remaining capacity\n        normalized_remaining_cap = bins_remain_cap / bin_size\n        priorities[feasible_bins] += normalized_remaining_cap[feasible_bins] * 0.5 # Only for feasible bins, reduced weight\n\n    # 9. Normalize priorities if no feasible bin exists, provide a minimal preference. Less negative values.\n    if not np.any(feasible_bins):\n        priorities = bins_remain_cap/bin_size * 0.001 # Prefer bins with more space.\n\n    return priorities",
    "response_id": 7,
    "obj": 3.7395293179098523,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response8.txt_stdout.txt",
    "code_path": "problem_iter12_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_size = bins_remain_cap.max()\n\n    # 1. Feasibility: Only consider bins where the item fits.\n    feasible_bins = bins_remain_cap >= item\n\n    # 2. Waste Minimization: Primary objective is to minimize waste.  Stronger weight.\n    post_fill_levels = bins_remain_cap - item\n    priorities[feasible_bins] = -10 * post_fill_levels[feasible_bins] / bin_size  # Increased weight to waste minimization\n\n    # 3. Infeasibility Penalty: Very strong penalty for infeasible bins.\n    priorities[~feasible_bins] = -1e9\n\n    # 4. Tight Fit Bonus: Significant bonus for bins that become nearly full. Even tighter fit. Larger bonus.\n    near_full_threshold = 0.04  # Even tighter fit\n    near_full_bonus = 5.0  # Further increased bonus\n\n    near_full_bins = feasible_bins & (post_fill_levels >= 0) & (post_fill_levels <= (bin_size * near_full_threshold))\n    priorities[near_full_bins] += near_full_bonus\n\n    # 5. Consolidate Items: Penalize bins with very small remaining capacity, relative to the item size. More Aggressive\n    too_little_threshold = 0.3 # Increased threshold, more aggressive\n    too_little_penalty = -4.0  # Much Stronger penalty\n\n    too_little_bins = feasible_bins & (post_fill_levels > 0) & (post_fill_levels <= (bin_size * too_little_threshold)) & (post_fill_levels > item * 0.1) #Check if enough space remains to be usable\n    priorities[too_little_bins] += too_little_penalty\n\n    # 6. Large Item Strategy: Fill nearly empty bins if the item is large. Make this a very strong incentive\n    large_item_threshold = 0.75 #Increased threshold slightly\n    nearly_empty_threshold = 0.96 #Increased threshold slightly\n    nearly_empty_bonus = 7.0 #Significantly increased bonus\n\n    if item > bin_size * large_item_threshold:\n        nearly_empty_bins = feasible_bins & (bins_remain_cap >= bin_size * nearly_empty_threshold)\n        priorities[nearly_empty_bins] += nearly_empty_bonus\n\n    # 7. Slightly prefer bins that are already relatively full. Increased incentive\n    already_full_threshold = 0.8\n    already_full_bonus = 1.0 #increased bonus\n\n    already_full_bins = feasible_bins & (bins_remain_cap <= bin_size * (1 - already_full_threshold))\n    priorities[already_full_bins] += already_full_bonus\n    \n    # 8. Moderate item prefers moderate fill level.\n    moderate_item_threshold_lower = 0.3\n    moderate_item_threshold_upper = 0.6\n    moderate_fill_level_lower = 0.3\n    moderate_fill_level_upper = 0.7\n    moderate_item_bonus = 2.0\n    \n    if moderate_item_threshold_lower * bin_size < item < moderate_item_threshold_upper * bin_size:\n        moderate_fill_bins = feasible_bins & (bins_remain_cap < bin_size * (1 - moderate_fill_level_lower)) & (bins_remain_cap > bin_size * (1 - moderate_fill_level_upper))\n        priorities[moderate_fill_bins] += moderate_item_bonus\n\n\n    # 9. Handle No Feasible Bins: Ensure a bin is always chosen.  Fall back to largest remaining capacity.\n    if not np.any(feasible_bins):\n        # If no feasible bins exist, select the bin with largest remaining capacity. Weight by item size to promote use when its bigger.\n        max_cap_bin = np.argmax(bins_remain_cap)\n        priorities[max_cap_bin] = 0.0001 * item #Arbitrary positive value, weighted\n\n    return priorities",
    "response_id": 8,
    "obj": 3.9988033506182825,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response9.txt_stdout.txt",
    "code_path": "problem_iter12_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_size = bins_remain_cap.max()\n\n    # 1. Feasibility: Only consider bins where the item fits.\n    feasible_bins = bins_remain_cap >= item\n\n    # 2. Waste Minimization: Primary objective is to minimize waste.\n    post_fill_levels = bins_remain_cap - item\n    priorities[feasible_bins] = -post_fill_levels[feasible_bins] / bin_size  # Directly use negative normalized waste\n\n    # 3. Infeasibility Penalty:  Strong penalty for infeasible bins.\n    priorities[~feasible_bins] = -np.inf\n\n    # 4. Tight Fit Bonus: Significant bonus for bins that become nearly full.\n    near_full_threshold = 0.05  # Even tighter fit\n    near_full_bonus = 3.0  # Increased bonus\n\n    near_full_bins = feasible_bins & (post_fill_levels >= 0) & (post_fill_levels <= (bin_size * near_full_threshold))\n    priorities[near_full_bins] += near_full_bonus\n\n    # 5. Consolidate Items: Penalize bins with very small remaining capacity.\n    too_little_threshold = 0.15\n    too_little_penalty = -1.5  # Stronger penalty\n\n    too_little_bins = feasible_bins & (post_fill_levels > 0) & (post_fill_levels <= (bin_size * too_little_threshold))\n    priorities[too_little_bins] += too_little_penalty\n\n    # 6. Large Item Strategy: Fill nearly empty bins if the item is large.\n    large_item_threshold = 0.7\n    nearly_empty_threshold = 0.95\n    nearly_empty_bonus = 2.0\n\n    if item > bin_size * large_item_threshold:\n        nearly_empty_bins = feasible_bins & (bins_remain_cap >= bin_size * nearly_empty_threshold)\n        priorities[nearly_empty_bins] += nearly_empty_bonus\n\n    # 7. Slightly prefer bins that are already relatively full\n    already_full_threshold = 0.85\n    already_full_bonus = 0.3\n\n    already_full_bins = feasible_bins & (bins_remain_cap <= bin_size * (1 - already_full_threshold))\n    priorities[already_full_bins] += already_full_bonus\n\n    # 8. Moderate item strategy. Fill moderately empty bins\n    moderate_item_threshold = 0.4\n    moderate_empty_threshold = 0.6\n    moderate_empty_bonus = 0.5\n\n    if item > bin_size * moderate_item_threshold:\n        moderate_empty_bins = feasible_bins & (bins_remain_cap >= bin_size * moderate_empty_threshold) & (bins_remain_cap < bin_size * nearly_empty_threshold)\n        priorities[moderate_empty_bins] += moderate_empty_bonus\n\n    # 9. Handle No Feasible Bins:  Ensure a bin is always chosen.\n    if not np.any(feasible_bins):\n        # Give preference to bins with more remaining capacity, slightly negative\n        priorities = bins_remain_cap / bin_size - 1.1\n\n\n    return priorities",
    "response_id": 9,
    "obj": 2.4331870761866865,
    "exec_success": true
  }
]