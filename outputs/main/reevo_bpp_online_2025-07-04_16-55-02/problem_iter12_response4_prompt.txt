{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: Only consider bins where the item fits.\n    feasible_bins = bins_remain_cap >= item\n\n    # 2. Calculate remaining capacity after placing the item\n    post_fill_levels = bins_remain_cap - item\n\n    # 3. Infeasibility penalty: Very low priority for infeasible bins\n    priorities[~feasible_bins] = -np.inf\n\n    # 4. Waste minimization using normalized waste\n    bin_size = bins_remain_cap.max()  # Assuming all bins have the same capacity\n    waste = post_fill_levels[feasible_bins]\n    normalized_waste = waste / bin_size\n    priorities[feasible_bins] = -normalized_waste\n\n    # 5. Bonus for near-full bins (encourage filling bins completely)\n    near_full_threshold = 0.1\n    near_full_bonus = 1.0\n    near_full_bins = feasible_bins & (post_fill_levels >= 0) & (post_fill_levels <= (bin_size * near_full_threshold))\n    \n    # 8. Adjust the near full bonus dynamically based on item size.  Larger items should more aggressively fill bins.\n    item_size_factor = item / bin_size\n    priorities[near_full_bins] += near_full_bonus * item_size_factor\n\n    # 6. Penalty for bins that would become too empty (encourage consolidation)\n    too_empty_threshold = 0.2\n    too_empty_penalty = -0.5\n    too_empty_bins = feasible_bins & (post_fill_levels > 0) & (post_fill_levels <= (bin_size * too_empty_threshold))\n    priorities[too_empty_bins] += too_empty_penalty\n    \n    # 7. Encourage bins with similar fill level\n    similar_fill_bonus = 0.2\n    fill_levels = bins_remain_cap / bin_size\n    median_fill = np.median(fill_levels)\n    similar_fill = np.abs(fill_levels - median_fill) < 0.1  # Tune the tolerance here\n    priorities[feasible_bins & similar_fill] += similar_fill_bonus\n    \n    # 9. Prioritize bins that, after placing the item, are closer to a multiple of a fraction of the bin size\n    fraction = 0.25 # Try to fill bins to multiples of 1/4 the bin size\n    target_levels = np.round(post_fill_levels / (bin_size * fraction)) * (bin_size * fraction)\n    distance_to_target = np.abs(post_fill_levels - target_levels)\n    # Invert the distance so that smaller distances get higher priority. Adjust the scaling factor for sensitivity.\n    priorities[feasible_bins] += -distance_to_target[feasible_bins] / bin_size * 0.5\n    \n\n    # 10. If no feasible bin exists, give preference to the fullest bin\n    if not np.any(feasible_bins):\n        # Give priority to the fullest bin when no bin can accommodate the item.\n        max_cap = np.max(bins_remain_cap)\n        if max_cap > 0:\n            priorities = bins_remain_cap / max_cap\n        else:\n            priorities = np.ones_like(priorities) * 0.1 # Add small non-zero priority to all, avoiding zero division in other steps\n    \n\n    return priorities\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_size = bins_remain_cap.max()\n\n    # 1. Feasibility: Only consider bins where the item fits.\n    feasible_bins = bins_remain_cap >= item\n\n    # 2. Waste Minimization: Primary objective is to minimize waste.\n    post_fill_levels = bins_remain_cap - item\n    normalized_waste = post_fill_levels / bin_size\n    priorities[feasible_bins] = -normalized_waste[feasible_bins]\n\n    # 3. Infeasibility Penalty:  Strong penalty for infeasible bins.\n    priorities[~feasible_bins] = -np.inf\n\n    # 4. Tight Fit Bonus: Significant bonus for bins that become nearly full.  Dynamic bonus.\n    near_full_threshold = 0.05\n    near_full_bonus = 3.0 * np.exp(-item / bin_size)  # Bonus depends on relative item size\n\n    near_full_bins = feasible_bins & (post_fill_levels >= 0) & (post_fill_levels <= (bin_size * near_full_threshold))\n    priorities[near_full_bins] += near_full_bonus\n\n    # 5. Consolidate Items: Penalize bins with very small remaining capacity. Dynamic penalty.\n    too_little_threshold = 0.15\n    too_little_penalty = -2.0 * (1 - item / bin_size)  # Penalty inversely proportional to item size.\n\n    too_little_bins = feasible_bins & (post_fill_levels > 0) & (post_fill_levels <= (bin_size * too_little_threshold))\n    priorities[too_little_bins] += too_little_penalty\n\n    # 6. Large Item Strategy: Fill nearly empty bins if the item is large.\n    large_item_threshold = 0.7\n    nearly_empty_threshold = 0.95\n    nearly_empty_bonus = 2.0\n\n    if item > bin_size * large_item_threshold:\n        nearly_empty_bins = feasible_bins & (bins_remain_cap >= bin_size * nearly_empty_threshold)\n        priorities[nearly_empty_bins] += nearly_empty_bonus\n\n    # 7. Preferentially choose bins that are already relatively full - small bonus\n    already_full_threshold = 0.85\n    already_full_bonus = 0.3\n\n    already_full_bins = feasible_bins & (bins_remain_cap <= bin_size * (1 - already_full_threshold))\n    priorities[already_full_bins] += already_full_bonus\n\n    # 8. Handle No Feasible Bins: Select the least infeasible bin with a small score.\n    if not np.any(feasible_bins):\n      least_infeasible_bin = np.argmin(bins_remain_cap + item)\n      priorities[least_infeasible_bin] = -0.01  # Very small, negative priority\n\n    return priorities\n\n[Reflection]\nPrioritize waste, use dynamic bonuses/penalties, and handle large items/infeasibility strategically for improvements.\n\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}