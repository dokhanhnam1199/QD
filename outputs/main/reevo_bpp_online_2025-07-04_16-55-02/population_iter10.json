[
  {
    "stdout_filepath": "problem_iter10_response0.txt_stdout.txt",
    "code_path": "problem_iter10_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_size = bins_remain_cap.max()\n\n    # 1. Feasibility: Only consider bins where the item fits.\n    feasible_bins = bins_remain_cap >= item\n\n    # 2. Waste Minimization: Primary objective is to minimize waste.\n    post_fill_levels = bins_remain_cap - item\n    priorities[feasible_bins] = -post_fill_levels[feasible_bins] / bin_size  # Directly use negative normalized waste\n\n    # 3. Infeasibility Penalty:  Strong penalty for infeasible bins.\n    priorities[~feasible_bins] = -np.inf\n\n    # 4. Tight Fit Bonus: Significant bonus for bins that become nearly full.\n    near_full_threshold = 0.05  # Even tighter fit\n    near_full_bonus = 2.0  # Increased bonus\n\n    near_full_bins = feasible_bins & (post_fill_levels >= 0) & (post_fill_levels <= (bin_size * near_full_threshold))\n    priorities[near_full_bins] += near_full_bonus\n\n    # 5. Consolidate Items: Penalize bins with very small remaining capacity.\n    too_little_threshold = 0.15\n    too_little_penalty = -1.0  # Stronger penalty\n\n    too_little_bins = feasible_bins & (post_fill_levels > 0) & (post_fill_levels <= (bin_size * too_little_threshold))\n    priorities[too_little_bins] += too_little_penalty\n\n    # 6. Large Item Strategy: Fill nearly empty bins if the item is large.\n    large_item_threshold = 0.7\n    nearly_empty_threshold = 0.95\n    nearly_empty_bonus = 1.5\n\n    if item > bin_size * large_item_threshold:\n        nearly_empty_bins = feasible_bins & (bins_remain_cap >= bin_size * nearly_empty_threshold)\n        priorities[nearly_empty_bins] += nearly_empty_bonus\n\n    # 7. Slightly prefer bins that are already relatively full\n    already_full_threshold = 0.85\n    already_full_bonus = 0.2\n\n    already_full_bins = feasible_bins & (bins_remain_cap <= bin_size * (1 - already_full_threshold))\n    priorities[already_full_bins] += already_full_bonus\n\n\n    # 8. Handle No Feasible Bins:  Ensure a bin is always chosen.\n    if not np.any(feasible_bins):\n        priorities = np.ones_like(priorities) * 0.01 # Small value\n        \n    return priorities",
    "response_id": 0,
    "obj": 2.4331870761866865,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response1.txt_stdout.txt",
    "code_path": "problem_iter10_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_size = bins_remain_cap.max()  # Assuming all bins have the same capacity\n\n    # 1. Feasibility: Only consider bins where the item fits.\n    feasible_bins = bins_remain_cap >= item\n\n    # 2. Infeasibility penalty:  Set a very large negative priority.\n    priorities[~feasible_bins] = -np.inf\n\n    # Proceed only if at least one bin is feasible\n    if np.any(feasible_bins):\n        # Calculate remaining capacity after placing the item for feasible bins\n        post_fill_levels = bins_remain_cap[feasible_bins] - item\n\n        # 3. Waste minimization: Prioritize bins with smallest waste AFTER placing the item\n        normalized_waste = post_fill_levels / bin_size\n        priorities[feasible_bins] = -normalized_waste\n\n        # 4. Bonus for near-full bins:\n        near_full_threshold = 0.1\n        near_full_bonus = 1.0\n        near_full_bins = (post_fill_levels >= 0) & (post_fill_levels <= (bin_size * near_full_threshold))\n        priorities[feasible_bins][near_full_bins] += near_full_bonus\n\n        # 5. Penalty for bins that would have too little remaining capacity, to consolidate items.\n        too_little_threshold = 0.2\n        too_little_penalty = -0.5\n        too_little_bins = (post_fill_levels > 0) & (post_fill_levels <= (bin_size * too_little_threshold))\n        priorities[feasible_bins][too_little_bins] += too_little_penalty\n\n        # 6. Encourage balanced bin usage: give a bonus to bins close to the average fill level\n        average_fill = np.mean(bin_size - bins_remain_cap) / bin_size  # As a percentage\n        balance_bonus = 0.1\n        post_fill_level_percentage = (bin_size - post_fill_levels) / bin_size\n        average_fill_proximity = np.abs(post_fill_level_percentage - average_fill)\n        priorities[feasible_bins] -= balance_bonus * average_fill_proximity\n\n        # 7. Prioritize bins based on current fullness:\n        current_fill_level = (bin_size - bins_remain_cap) / bin_size\n        fullness_bonus = 0.05  # A small weight so it does not dominate\n        priorities[feasible_bins] += fullness_bonus * current_fill_level[feasible_bins]\n\n        # 8. Normalize priorities if feasible bins exist to make them comparable:\n        max_priority = np.max(priorities[feasible_bins])\n        min_priority = np.min(priorities[feasible_bins])\n\n        if max_priority != min_priority:\n            priorities[feasible_bins] = (priorities[feasible_bins] - min_priority) / (max_priority - min_priority)\n        else:\n            priorities[feasible_bins] = 0.5  # Assign equal priorities if max and min are equal.\n\n    else:\n        # If no bin is feasible, give preference to the fullest bin to open it.\n        # But use a lower priority than potentially feasible bins.\n        if np.any(bins_remain_cap > 0):\n            priorities = bins_remain_cap / bin_size - 1.1  # Slightly negative to avoid immediate use if feasible becomes available\n        else:\n            # All bins are full, but no feasible bin exists. This shouldn't happen\n            priorities = np.ones_like(priorities) * -1.1\n\n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response2.txt_stdout.txt",
    "code_path": "problem_iter10_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_size = bins_remain_cap.max()\n\n    # 1. Feasibility: Only consider bins where the item fits.\n    feasible_bins = bins_remain_cap >= item\n\n    # 2. Calculate remaining capacity *after* placing the item\n    post_fill_levels = bins_remain_cap - item\n\n    # 3. Infeasibility penalty: Heavily penalize infeasible bins.\n    priorities[~feasible_bins] = -np.inf\n\n    # 4. Prioritize bins with highest normalized utilization after placing the item\n    normalized_utilization = (bin_size - post_fill_levels) / bin_size\n    normalized_utilization[~feasible_bins] = 0  # Set utilization of infeasible bins to 0\n    priorities[feasible_bins] = normalized_utilization[feasible_bins]\n\n    # 5. Encourage tighter fits with a small bonus for near-full bins after placement\n    near_full_threshold = 0.1\n    near_full_bonus = 0.05\n\n    near_full_bins = feasible_bins & (post_fill_levels >= 0) & (post_fill_levels <= (bin_size * near_full_threshold))\n    priorities[near_full_bins] += near_full_bonus\n\n    # 6. Penalize bins that would have too little remaining capacity, to consolidate items.\n    too_little_threshold = 0.2\n    too_little_penalty = -0.02\n\n    too_little_bins = feasible_bins & (post_fill_levels > 0) & (post_fill_levels <= (bin_size * too_little_threshold))\n    priorities[too_little_bins] += too_little_penalty\n    \n    # 7. Slightly prioritize bins that are already somewhat full before placing the item\n    # This encourages filling existing bins before starting new ones.\n    already_full_threshold = 0.8\n    already_full_bonus = 0.01\n    \n    already_full_bins = feasible_bins & (bins_remain_cap <= (bin_size * (1 - already_full_threshold)))\n    priorities[already_full_bins] += already_full_bonus\n\n    # 8. Prioritize bins that are very empty slightly less (to avoid over-filling new bins)\n    very_empty_threshold = 0.1\n    very_empty_penalty = -0.005\n    \n    very_empty_bins = feasible_bins & (bins_remain_cap >= (bin_size * (1 - very_empty_threshold)))\n    priorities[very_empty_bins] += very_empty_penalty\n\n\n    # 9. If no feasible bin found, select the bin with maximum remaining capacity\n    if not np.any(feasible_bins):\n        max_cap_bin = np.argmax(bins_remain_cap)\n        priorities[max_cap_bin] = 0.01 #Assign a small positive value\n\n    return priorities",
    "response_id": 2,
    "obj": 4.038691663342641,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response3.txt_stdout.txt",
    "code_path": "problem_iter10_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: Only consider bins where the item fits.\n    feasible_bins = bins_remain_cap >= item\n\n    # 2. Waste minimization: Prioritize bins with smallest remaining capacity *after* placing the item\n    post_fill_levels = bins_remain_cap - item\n\n    # 3. Infesibility penalty\n    priorities[~feasible_bins] = -np.inf\n\n    # Assuming all bins have the same capacity\n    bin_size = bins_remain_cap.max()\n\n    # 4. Reward tight fits, penalize waste:\n    waste = post_fill_levels[feasible_bins]\n    normalized_waste = waste / bin_size  # Waste as a percentage of bin capacity\n\n    priorities[feasible_bins] = -normalized_waste  # Invert waste to make it a priority.\n\n    # 5. Bonus for near-full bins:\n    near_full_threshold = 0.1  # Define a threshold for \"near full\" (e.g., 10% remaining capacity)\n    near_full_bonus = 1\n\n    near_full_bins = feasible_bins & (post_fill_levels >= 0) & (post_fill_levels <= (bin_size * near_full_threshold))\n    priorities[near_full_bins] += near_full_bonus\n\n    # 6. Penalize bins that would have too little remaining capacity, to consolidate items.\n    too_little_threshold = 0.2\n    too_little_penalty = -0.5\n\n    too_little_bins = feasible_bins & (post_fill_levels > 0) & (post_fill_levels <= (bin_size * too_little_threshold))\n    priorities[too_little_bins] += too_little_penalty\n\n    # 7. Small item consolidation: bonus if item fits well into near-empty bin\n    near_empty_threshold = 0.9\n    near_empty_bonus = 0.2\n    near_empty_bins = feasible_bins & (bins_remain_cap/bin_size >= near_empty_threshold)\n    item_size_ratio = item / bin_size\n    consolidation_bins = near_empty_bins & (item_size_ratio <= 0.1)  # Small item into near empty bin\n    priorities[consolidation_bins] += near_empty_bonus\n\n    # 8. Encourage placing large items into emptier bins:\n    large_item_threshold = 0.5\n    empty_bin_bonus = 0.1\n    large_item_bins = feasible_bins & (item_size_ratio >= large_item_threshold) & (bins_remain_cap/bin_size >= 0.5)\n    priorities[large_item_bins] += empty_bin_bonus\n\n    # 9. Normalize priorities if no feasible bin exists:\n    if not np.any(feasible_bins):\n        priorities = np.ones_like(priorities)\n\n    return priorities",
    "response_id": 3,
    "obj": 3.7295572397287686,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response4.txt_stdout.txt",
    "code_path": "problem_iter10_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_size = bins_remain_cap.max()  # Assuming all bins have same capacity\n\n    # 1. Feasibility: Only consider bins where the item fits.\n    feasible_bins = bins_remain_cap >= item\n\n    # 2. Calculate post-fill levels directly\n    post_fill_levels = bins_remain_cap - item\n\n    # 3. Infeasibility penalty: Set priority to -inf for infeasible bins\n    priorities[~feasible_bins] = -np.inf\n\n    # 4. Waste minimization: Prioritize bins with smallest remaining capacity *after* placing the item\n    waste = post_fill_levels[feasible_bins]\n    normalized_waste = waste / bin_size  # Waste as a percentage of bin capacity\n\n    priorities[feasible_bins] = -normalized_waste  # Invert waste to make it a priority.\n\n    # 5. Bonus for near-full bins: Incentivize tight packing\n    near_full_threshold = 0.1\n    near_full_bonus = 1\n    near_full_bins = feasible_bins & (post_fill_levels >= 0) & (post_fill_levels <= (bin_size * near_full_threshold))\n    priorities[near_full_bins] += near_full_bonus\n\n    # 6. Penalize bins that would have too little remaining capacity, to consolidate items.\n    too_little_threshold = 0.2\n    too_little_penalty = -0.5\n    too_little_bins = feasible_bins & (post_fill_levels > 0) & (post_fill_levels <= (bin_size * too_little_threshold))\n    priorities[too_little_bins] += too_little_penalty\n\n    # 7. Large item bonus: If item is larger than a certain threshold, incentivize filling nearly empty bins\n    large_item_threshold = 0.6\n    nearly_empty_threshold = 0.9\n    nearly_empty_bonus = 0.5\n\n    if item > bin_size * large_item_threshold:\n        nearly_empty_bins = feasible_bins & (bins_remain_cap >= bin_size * nearly_empty_threshold)\n        priorities[nearly_empty_bins] += nearly_empty_bonus\n\n    # 8. Normalize priorities if no feasible bin exists, provide a minimal preference\n    if not np.any(feasible_bins):\n        priorities = np.ones_like(priorities) * -1 # all bins equally bad, but not -inf.\n\n    return priorities",
    "response_id": 4,
    "obj": 3.7295572397287686,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response5.txt_stdout.txt",
    "code_path": "problem_iter10_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: Only consider bins where the item fits.\n    feasible_bins = bins_remain_cap >= item\n\n    # 2. Infeasibility penalty: Set to -inf for bins that cannot fit the item.\n    priorities[~feasible_bins] = -np.inf\n\n    # 3. Waste Minimization (Normalized): Prioritize bins with minimal *normalized* waste.\n    post_fill_levels = bins_remain_cap - item\n    bin_size = bins_remain_cap.max()  # Assuming all bins have the same capacity\n    normalized_waste = post_fill_levels / bin_size\n    priorities[feasible_bins] = -normalized_waste[feasible_bins]  # Invert waste to priority.\n\n    # 4. Consolidation Bonus: Reward bins that become near-full.\n    near_full_threshold = 0.1\n    near_full_bonus = 1.0\n    near_full_bins = feasible_bins & (post_fill_levels >= 0) & (normalized_waste <= near_full_threshold)\n    priorities[near_full_bins] += near_full_bonus\n\n    # 5. Fragmentation Penalty: Penalize bins that would have very little remaining capacity.\n    tiny_rem_threshold = 0.2\n    tiny_rem_penalty = -0.5\n    tiny_rem_bins = feasible_bins & (post_fill_levels > 0) & (normalized_waste <= tiny_rem_threshold)\n    priorities[tiny_rem_bins] += tiny_rem_penalty\n\n    # 6. Perfect Fit Bonus: Substantially reward perfect fits.\n    perfect_fit_bonus = 2.0\n    perfect_fit_bins = np.isclose(bins_remain_cap, item) & feasible_bins\n    priorities[perfect_fit_bins] += perfect_fit_bonus\n\n    # 7. Handle Infeasible Case: If no bins fit, assign priorities based on remaining capacity.\n    if not np.any(feasible_bins):\n        # Prioritize bins that are closest to fitting the item.\n        capacity_diff = item - bins_remain_cap\n        min_diff = np.min(capacity_diff)\n        \n        #Assign very low priority to bins that can not fit the item\n        priorities = -capacity_diff\n        priorities[bins_remain_cap <=0] = -np.inf\n        \n        #Scale priority by bin size to avoid extreme high/low value, and shift value by 1, so the value is negative\n        priorities = priorities / bin_size - 1\n        priorities[bins_remain_cap <= 0] = -np.inf #make sure infeasible bins are still the lowest priority.\n\n    return priorities",
    "response_id": 5,
    "obj": 3.7295572397287686,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response6.txt_stdout.txt",
    "code_path": "problem_iter10_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_size = bins_remain_cap.max() #Assuming all bins have the same capacity\n    \n    # 1. Feasibility: Only consider bins where the item fits.\n    feasible_bins = bins_remain_cap >= item\n    \n    # 2. Waste minimization: Prioritize bins with smallest remaining capacity *after* placing the item\n    post_fill_levels = bins_remain_cap - item\n    \n    # 3. Infesibility penalty\n    priorities[~feasible_bins] = -np.inf\n    \n    # 4. Reward tight fits, penalize waste:\n    waste = post_fill_levels[feasible_bins]\n    \n    normalized_waste = waste / bin_size #Waste as a percentage of bin capacity\n    \n    priorities[feasible_bins] =  -normalized_waste  #Invert waste to make it a priority.\n\n    # 5. Bonus for near-full bins:\n    near_full_threshold = 0.1  # Define a threshold for \"near full\" (e.g., 10% remaining capacity)\n    near_full_bonus = 1\n\n    near_full_bins = feasible_bins & (post_fill_levels >= 0) & (post_fill_levels <= (bin_size * near_full_threshold))  #Only consider non-negative remaining capacities to fix error\n    priorities[near_full_bins] += near_full_bonus\n    \n    # 6. Penalize bins that would have too little remaining capacity, to consolidate items.\n    too_little_threshold = 0.2\n    too_little_penalty = -0.5\n\n    too_little_bins = feasible_bins & (post_fill_levels > 0) & (post_fill_levels <= (bin_size * too_little_threshold))\n    priorities[too_little_bins] += too_little_penalty\n    \n    # 7. Large item bonus: If item is larger than certain threshold, incentivize filling nearly empty bins\n    large_item_threshold = 0.6\n    nearly_empty_threshold = 0.9\n    nearly_empty_bonus = 0.5\n\n    if item > bin_size * large_item_threshold:\n        nearly_empty_bins = feasible_bins & (bins_remain_cap >= bin_size * nearly_empty_threshold)\n        priorities[nearly_empty_bins] += nearly_empty_bonus\n    \n    # 8. Normalize priorities if no feasible bin exists:\n    if not np.any(feasible_bins):\n        # Give preference to bins with more remaining capacity if no feasible bin exists\n        priorities = bins_remain_cap / bin_size\n\n    return priorities",
    "response_id": 6,
    "obj": 3.7295572397287686,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response7.txt_stdout.txt",
    "code_path": "problem_iter10_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_size = bins_remain_cap.max()\n\n    # 1. Feasibility: Only consider bins where the item fits.\n    feasible_bins = bins_remain_cap >= item\n\n    # 2. Calculate remaining capacity *after* placing the item\n    post_fill_levels = bins_remain_cap - item\n\n    # 3. Infeasibility penalty: Heavily penalize infeasible bins.\n    priorities[~feasible_bins] = -np.inf\n\n    # 4. Prioritize bins with highest normalized utilization after placing the item\n    normalized_utilization = (bin_size - post_fill_levels) / bin_size\n    normalized_utilization[~feasible_bins] = 0  # Ensure infeasible bins have zero utilization\n    priorities = normalized_utilization\n\n\n    # 5. Encourage tighter fits with a bonus for near-full bins after placement\n    near_full_threshold = 0.1\n    near_full_bonus = 0.1  # Reduced bonus\n\n    near_full_bins = feasible_bins & (post_fill_levels >= 0) & (post_fill_levels <= (bin_size * near_full_threshold))\n    priorities[near_full_bins] += near_full_bonus\n\n    # 6. Penalize bins that would have too little remaining capacity, to consolidate items.\n    too_little_threshold = 0.2\n    too_little_penalty = -0.05  # Reduced penalty\n\n    too_little_bins = feasible_bins & (post_fill_levels > 0) & (post_fill_levels <= (bin_size * too_little_threshold))\n    priorities[too_little_bins] += too_little_penalty\n    \n    # 7. Slightly prioritize bins that are already somewhat full before placing the item\n    # This encourages filling existing bins before starting new ones.\n    already_full_threshold = 0.9 #Bins that are already 90% full\n    already_full_bonus = 0.02\n    \n    already_full_bins = feasible_bins & (bins_remain_cap <= (bin_size * (1 - already_full_threshold)))\n    priorities[already_full_bins] += already_full_bonus\n\n    # 8. If no feasible bin found, prioritize bins with the most remaining capacity\n    if not np.any(feasible_bins):\n        # Prioritize bins that have largest remaing capacity, normalized\n        normalized_remaining_cap = bins_remain_cap / bin_size\n        priorities = normalized_remaining_cap * 0.01 #Small value to avoid overshadowing other priorities\n\n    return priorities",
    "response_id": 7,
    "obj": 3.9788591942560925,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response8.txt_stdout.txt",
    "code_path": "problem_iter10_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: Only consider bins where the item fits.\n    feasible_bins = bins_remain_cap >= item\n\n    # 2. Calculate remaining capacity after placing the item\n    post_fill_levels = bins_remain_cap - item\n\n    # 3. Infeasibility penalty: Very low priority for infeasible bins\n    priorities[~feasible_bins] = -np.inf\n\n    # 4. Waste minimization using normalized waste\n    bin_size = bins_remain_cap.max()  # Assuming all bins have the same capacity\n    waste = post_fill_levels[feasible_bins]\n    normalized_waste = waste / bin_size\n    priorities[feasible_bins] = -normalized_waste\n\n    # 5. Bonus for near-full bins (encourage filling bins completely)\n    near_full_threshold = 0.1\n    near_full_bonus = 1.0\n    near_full_bins = feasible_bins & (post_fill_levels >= 0) & (post_fill_levels <= (bin_size * near_full_threshold))\n    \n    # 8. Adjust the near full bonus dynamically based on item size.  Larger items should more aggressively fill bins.\n    item_size_factor = item / bin_size\n    priorities[near_full_bins] += near_full_bonus * item_size_factor\n\n    # 6. Penalty for bins that would become too empty (encourage consolidation)\n    too_empty_threshold = 0.2\n    too_empty_penalty = -0.5\n    too_empty_bins = feasible_bins & (post_fill_levels > 0) & (post_fill_levels <= (bin_size * too_empty_threshold))\n    priorities[too_empty_bins] += too_empty_penalty\n    \n    # 7. Encourage bins with similar fill level\n    similar_fill_bonus = 0.2\n    fill_levels = bins_remain_cap / bin_size\n    median_fill = np.median(fill_levels)\n    similar_fill = np.abs(fill_levels - median_fill) < 0.1  # Tune the tolerance here\n    priorities[feasible_bins & similar_fill] += similar_fill_bonus\n    \n    # 9. Prioritize bins that, after placing the item, are closer to a multiple of a fraction of the bin size\n    fraction = 0.25 # Try to fill bins to multiples of 1/4 the bin size\n    target_levels = np.round(post_fill_levels / (bin_size * fraction)) * (bin_size * fraction)\n    distance_to_target = np.abs(post_fill_levels - target_levels)\n    # Invert the distance so that smaller distances get higher priority. Adjust the scaling factor for sensitivity.\n    priorities[feasible_bins] += -distance_to_target[feasible_bins] / bin_size * 0.5\n    \n\n    # 10. If no feasible bin exists, give preference to the fullest bin\n    if not np.any(feasible_bins):\n        # Give priority to the fullest bin when no bin can accommodate the item.\n        max_cap = np.max(bins_remain_cap)\n        if max_cap > 0:\n            priorities = bins_remain_cap / max_cap\n        else:\n            priorities = np.ones_like(priorities) * 0.1 # Add small non-zero priority to all, avoiding zero division in other steps\n    \n\n    return priorities",
    "response_id": 8,
    "obj": 3.260869565217396,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response9.txt_stdout.txt",
    "code_path": "problem_iter10_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_size = bins_remain_cap.max() #Assuming all bins have the same capacity\n\n    # 1. Feasibility: Only consider bins where the item fits.\n    feasible_bins = bins_remain_cap >= item\n\n    # 2. Infeasibility penalty: Set a very large negative priority.\n    priorities[~feasible_bins] = -np.inf\n\n    # Proceed only if at least one bin is feasible\n    if np.any(feasible_bins):\n        # Calculate remaining capacity after placing the item for feasible bins\n        post_fill_levels = bins_remain_cap[feasible_bins] - item\n\n        # 3. Waste minimization: Prioritize bins with smallest waste AFTER placing the item\n        normalized_waste = post_fill_levels / bin_size\n        priorities[feasible_bins] = -normalized_waste\n\n        # 4. Bonus for near-full bins:\n        near_full_threshold = 0.1\n        near_full_bonus = 1.0\n        near_full_bins = (post_fill_levels >= 0) & (post_fill_levels <= (bin_size * near_full_threshold))\n        priorities[feasible_bins][near_full_bins] += near_full_bonus\n\n        # 5. Penalty for bins that would have too little remaining capacity, to consolidate items.\n        too_little_threshold = 0.2\n        too_little_penalty = -0.5\n        too_little_bins = (post_fill_levels > 0) & (post_fill_levels <= (bin_size * too_little_threshold))\n        priorities[feasible_bins][too_little_bins] += too_little_penalty\n\n        # 6. Small preference for bins with more initial capacity before placing the item\n        #    among the feasible bins, to encourage using partially filled bins first.\n        priorities[feasible_bins] += bins_remain_cap[feasible_bins] / (2 * bin_size)\n\n    else:\n        # If no bin is feasible, give preference to the fullest bin to open it.\n        # But use a lower priority than potentially feasible bins.\n        if np.any(bins_remain_cap > 0):\n            priorities = bins_remain_cap / bin_size - 1.1 # Slightly negative to avoid immediate use if feasible becomes available\n        else:\n            #All bins are full, but no feasible bin exists. This shouldn't happen\n            priorities = np.ones_like(priorities) * -1.1\n\n    return priorities",
    "response_id": 9,
    "obj": 4.048663741523748,
    "exec_success": true
  }
]