[
  {
    "stdout_filepath": "problem_iter6_response0.txt_stdout.txt",
    "code_path": "problem_iter6_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: Only consider bins where the item fits.\n    feasible_bins = bins_remain_cap >= item\n\n    # 2. Calculate remaining capacity after placing the item\n    post_fill_levels = bins_remain_cap - item\n\n    # 3. Infeasibility penalty: Very low priority for infeasible bins\n    priorities[~feasible_bins] = -np.inf\n\n    # 4. Waste minimization using normalized waste.  Only consider feasible bins.\n    bin_size = np.max(bins_remain_cap)  # Assuming all bins have the same capacity\n    waste = post_fill_levels[feasible_bins]\n    normalized_waste = waste / bin_size\n    priorities[feasible_bins] = -normalized_waste\n\n    # 5. Bonus for near-full bins (encourage filling bins completely). Consider only feasible bins.\n    near_full_threshold = 0.1\n    near_full_bonus = 1.0\n    near_full_bins = feasible_bins & (post_fill_levels >= 0) & (post_fill_levels <= (bin_size * near_full_threshold))\n    priorities[near_full_bins] += near_full_bonus\n\n    # 6. Penalty for bins that would become too empty (encourage consolidation). Consider only feasible bins.\n    too_empty_threshold = 0.2\n    too_empty_penalty = -0.5\n    too_empty_bins = feasible_bins & (post_fill_levels >= 0) & (post_fill_levels >= (bin_size * too_empty_threshold)) & (post_fill_levels < (bin_size * (1-near_full_threshold)))\n    priorities[too_empty_bins] += too_empty_penalty\n\n    # 7. If no feasible bin exists, give preference to the fullest bin.\n    if not np.any(feasible_bins):\n        if np.any(bins_remain_cap > 0):\n          priorities = bins_remain_cap / bin_size\n        else:\n          priorities = np.ones_like(priorities)\n\n    return priorities",
    "response_id": 0,
    "obj": 4.058635819704831,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response1.txt_stdout.txt",
    "code_path": "problem_iter6_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_size = bins_remain_cap.max()\n\n    # 1. Feasibility: Only consider bins where the item fits.\n    feasible_bins = bins_remain_cap >= item\n\n    # 2. Calculate remaining capacity *after* placing the item\n    post_fill_levels = bins_remain_cap - item\n\n    # 3. Infeasibility penalty: Heavily penalize infeasible bins.\n    priorities[~feasible_bins] = -np.inf\n\n    # 4. Prioritize bins with smallest waste (inverse of utilization), but only for feasible bins.\n    waste = post_fill_levels\n    waste[~feasible_bins] = bin_size  # Assign max waste to infeasible bins to exclude them from prioritization.\n\n    # Normalize Waste - higher is more full (better)\n    normalized_utilization = (bin_size - waste) / bin_size\n    priorities[feasible_bins] = normalized_utilization[feasible_bins]\n\n    # 5. Encourage tighter fits by slightly rewarding near-full bins after placement\n    near_full_threshold = 0.1\n    near_full_bonus = 0.2\n\n    near_full_bins = feasible_bins & (post_fill_levels >= 0) & (post_fill_levels <= (bin_size * near_full_threshold))\n    priorities[near_full_bins] += near_full_bonus\n\n    # 6. Penalize bins that would have too little remaining capacity, to consolidate items.\n    too_little_threshold = 0.2\n    too_little_penalty = -0.1\n\n    too_little_bins = feasible_bins & (post_fill_levels > 0) & (post_fill_levels <= (bin_size * too_little_threshold))\n    priorities[too_little_bins] += too_little_penalty\n\n    # 7. If no feasible bin found, reset all priorities to 1 to select a bin.\n    if not np.any(feasible_bins):\n        priorities = np.ones_like(priorities)\n\n    return priorities",
    "response_id": 1,
    "obj": 3.9389708815317115,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response2.txt_stdout.txt",
    "code_path": "problem_iter6_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: Only consider bins where the item fits.\n    feasible_bins = bins_remain_cap >= item\n\n    # 2. Waste minimization: Use inverse waste to heavily penalize large waste.\n    waste = bins_remain_cap - item\n    waste[~feasible_bins] = np.inf  # Set infeasible waste to infinity\n    priorities[feasible_bins] = -waste[feasible_bins]\n\n    # 3. Bonus for near-full bins (consolidation):\n    near_full_threshold = 0.1  # Define a threshold for \"near full\" (e.g., 10% remaining capacity)\n    near_full_bonus = 10\n    max_capacity = np.max(bins_remain_cap) if len(bins_remain_cap) > 0 else 1.0 # avoid zero division\n    near_full_bins = feasible_bins & (waste >= 0) & (waste <= (max_capacity * near_full_threshold))\n    priorities[near_full_bins] += near_full_bonus\n\n    # 4. Penalize bins that would have too little remaining capacity\n    too_little_threshold = 0.2\n    too_little_penalty = -5\n\n    too_little_bins = feasible_bins & (waste > 0) & (waste/max_capacity <= too_little_threshold)\n    priorities[too_little_bins] += too_little_penalty\n    \n    # 5. Perfect fit\n    perfect_fit_bonus = 20\n    perfect_fit_bins = np.isclose(bins_remain_cap, item) & feasible_bins\n    priorities[perfect_fit_bins] += perfect_fit_bonus\n\n    # 6. Prioritize using almost empty bins if there is no better option\n    if not np.any(feasible_bins):\n        almost_empty_threshold = 0.9\n        almost_empty_bins = bins_remain_cap >= (almost_empty_threshold * max_capacity)\n        if np.any(almost_empty_bins):\n            priorities[almost_empty_bins] = 1.0/len(bins_remain_cap)\n        else:\n            priorities[:] = 1.0 / len(bins_remain_cap)\n\n    return priorities",
    "response_id": 2,
    "obj": 3.9589150378939015,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response3.txt_stdout.txt",
    "code_path": "problem_iter6_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # 1. Feasibility: Only consider bins where the item fits.\n    feasible_bins = bins_remain_cap >= item\n    \n    # 2. Waste minimization: Prioritize bins with smallest remaining capacity *after* placing the item\n    post_fill_levels = bins_remain_cap - item\n    \n    # 3. Infesibility penalty\n    priorities[~feasible_bins] = -np.inf\n    \n    # 4. Reward tight fits, penalize waste:\n    waste = post_fill_levels[feasible_bins]\n    bin_size = bins_remain_cap.max() #Assuming all bins have the same capacity\n    normalized_waste = waste / bin_size #Waste as a percentage of bin capacity\n    \n    priorities[feasible_bins] =  -normalized_waste  #Invert waste to make it a priority.\n\n    # 5. Bonus for near-full bins:\n    near_full_threshold = 0.1  # Define a threshold for \"near full\" (e.g., 10% remaining capacity)\n    near_full_bonus = 5  # Increased bonus\n\n    near_full_bins = feasible_bins & (post_fill_levels >= 0) & (post_fill_levels <= (bin_size * near_full_threshold))  #Only consider non-negative remaining capacities to fix error\n    priorities[near_full_bins] += near_full_bonus\n    \n    # 6. Penalize bins that would have too little remaining capacity, to consolidate items.\n    too_little_threshold = 0.2\n    too_little_penalty = -0.5\n\n    too_little_bins = feasible_bins & (post_fill_levels > 0) & (post_fill_levels <= (bin_size * too_little_threshold))\n    priorities[too_little_bins] += too_little_penalty\n\n    # 7. Normalize priorities if no feasible bin exists:\n    if not np.any(feasible_bins):\n       priorities = np.ones_like(priorities)\n\n    return priorities",
    "response_id": 3,
    "obj": 3.7295572397287686,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response4.txt_stdout.txt",
    "code_path": "problem_iter6_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: Only consider bins where the item fits.\n    feasible_bins = bins_remain_cap >= item\n\n    # 2. Calculate remaining capacity after placing the item\n    post_fill_levels = bins_remain_cap - item\n\n    # 3. Infeasibility penalty: Very low priority for infeasible bins\n    priorities[~feasible_bins] = -np.inf\n\n    # 4. Waste minimization using normalized waste\n    bin_size = bins_remain_cap.max()  # Assuming all bins have the same capacity\n    waste = post_fill_levels[feasible_bins]\n    normalized_waste = waste / bin_size\n    priorities[feasible_bins] = -normalized_waste\n\n    # 5. Bonus for near-full bins (encourage filling bins completely)\n    near_full_threshold = 0.1\n    near_full_bonus = 1.0\n    near_full_bins = feasible_bins & (post_fill_levels >= 0) & (post_fill_levels <= (bin_size * near_full_threshold))\n    priorities[near_full_bins] += near_full_bonus\n\n    # 6. Penalty for bins that would become too empty (encourage consolidation)\n    too_empty_threshold = 0.2\n    too_empty_penalty = -0.5\n    too_empty_bins = feasible_bins & (post_fill_levels > 0) & (post_fill_levels <= (bin_size * too_empty_threshold))\n    priorities[too_empty_bins] += too_empty_penalty\n\n    # 7. If no feasible bin exists, give preference to the fullest bin\n    if not np.any(feasible_bins):\n        # Give priority to the fullest bin when no bin can accommodate the item.\n        max_cap = np.max(bins_remain_cap)\n        if max_cap > 0:\n            priorities = bins_remain_cap / max_cap\n        else:\n            priorities = np.ones_like(priorities) * 0.1 # Add small non-zero priority to all, avoiding zero division in other steps\n    return priorities",
    "response_id": 4,
    "obj": 3.7295572397287686,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response5.txt_stdout.txt",
    "code_path": "problem_iter6_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # 1. Feasibility: Only consider bins where the item fits.\n    feasible_bins = bins_remain_cap >= item\n    \n    # 2. Waste minimization: Prioritize bins with smallest remaining capacity *after* placing the item\n    post_fill_levels = bins_remain_cap - item\n    \n    # 3. Infesibility penalty\n    priorities[~feasible_bins] = -np.inf\n    \n    # 4. Reward tight fits, penalize waste:\n    if np.any(feasible_bins):\n        waste = post_fill_levels[feasible_bins]\n        bin_size = bins_remain_cap.max() #Assuming all bins have the same capacity\n        normalized_waste = waste / bin_size #Waste as a percentage of bin capacity\n        \n        priorities[feasible_bins] =  -normalized_waste  #Invert waste to make it a priority.\n\n        # 5. Bonus for near-full bins:\n        near_full_threshold = 0.1  # Define a threshold for \"near full\" (e.g., 10% remaining capacity)\n        near_full_bonus = 1.0\n\n        near_full_bins = feasible_bins & (post_fill_levels >= 0) & (post_fill_levels <= (bin_size * near_full_threshold))  #Only consider non-negative remaining capacities to fix error\n        priorities[near_full_bins] += near_full_bonus\n        \n        # 6. Penalize bins that would have too little remaining capacity, to consolidate items.\n        too_little_threshold = 0.2\n        too_little_penalty = -0.5\n\n        too_little_bins = feasible_bins & (post_fill_levels > 0) & (post_fill_levels <= (bin_size * too_little_threshold))\n        priorities[too_little_bins] += too_little_penalty\n\n    # 7. Normalize priorities if no feasible bin exists:\n    else:\n       priorities = np.ones_like(priorities)\n\n    return priorities",
    "response_id": 5,
    "obj": 3.7295572397287686,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response6.txt_stdout.txt",
    "code_path": "problem_iter6_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # 1. Feasibility: Only consider bins where the item fits.\n    feasible_bins = bins_remain_cap >= item\n    \n    # 2. Waste minimization: Prioritize bins with smallest remaining capacity *after* placing the item\n    post_fill_levels = bins_remain_cap - item\n    \n    # 3. Infesibility penalty\n    priorities[~feasible_bins] = -np.inf\n    \n    # 4. Reward tight fits, penalize waste:\n    waste = post_fill_levels[feasible_bins]\n    bin_size = bins_remain_cap.max() #Assuming all bins have the same capacity\n    normalized_waste = waste / bin_size #Waste as a percentage of bin capacity\n    \n    priorities[feasible_bins] =  -normalized_waste  #Invert waste to make it a priority.\n\n    # 5. Bonus for near-full bins:\n    near_full_threshold = 0.1  # Define a threshold for \"near full\" (e.g., 10% remaining capacity)\n    near_full_bonus = 1\n\n    near_full_bins = feasible_bins & (post_fill_levels >= 0) & (post_fill_levels <= (bin_size * near_full_threshold))  #Only consider non-negative remaining capacities to fix error\n    priorities[near_full_bins] += near_full_bonus\n    \n    # 6. Penalize bins that would have too little remaining capacity, to consolidate items.\n    too_little_threshold = 0.2\n    too_little_penalty = -0.5\n\n    too_little_bins = feasible_bins & (post_fill_levels > 0) & (post_fill_levels <= (bin_size * too_little_threshold))\n    priorities[too_little_bins] += too_little_penalty\n\n    # 7. Normalize priorities if no feasible bin exists:\n    if not np.any(feasible_bins):\n       return np.ones_like(priorities) * -np.inf # Force a new bin.\n\n    # 8. Adjust bonus/penalty based on item size. Larger items get larger bonuses and penalties.\n    item_size_factor = item / bin_size\n\n    near_full_bins = feasible_bins & (post_fill_levels >= 0) & (post_fill_levels <= (bin_size * near_full_threshold))\n    priorities[near_full_bins] += near_full_bonus * item_size_factor\n    \n    too_little_bins = feasible_bins & (post_fill_levels > 0) & (post_fill_levels <= (bin_size * too_little_threshold))\n    priorities[too_little_bins] += too_little_penalty * item_size_factor\n\n    # 9. Dynamic near full threshold based on item size.\n    dynamic_near_full_threshold = min(0.2, item / bin_size) #If item is half the bin, threshold is 0.25.\n    dynamic_near_full_bonus = 1\n\n    dynamic_near_full_bins = feasible_bins & (post_fill_levels >= 0) & (post_fill_levels <= (bin_size * dynamic_near_full_threshold))\n    priorities[dynamic_near_full_bins] += dynamic_near_full_bonus\n\n    return priorities",
    "response_id": 6,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response7.txt_stdout.txt",
    "code_path": "problem_iter6_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: Only consider bins where the item fits.\n    feasible_bins = bins_remain_cap >= item\n\n    # 2. Waste minimization: Prioritize bins with less waste (remaining capacity).\n    waste = bins_remain_cap - item\n    waste[~feasible_bins] = np.inf  # Mark infeasible bins with infinite waste.\n    priorities[feasible_bins] = -waste[feasible_bins]  # Smaller waste is better (higher priority)\n\n    # 3. Consolidation: Give a bonus for bins that become near-full after adding the item.\n    near_full_threshold = 0.2  # Define \"near-full\" as having <= 20% remaining capacity\n    near_full_bonus = 15\n    post_fill_capacity = bins_remain_cap - item\n    near_full_bins = feasible_bins & (post_fill_capacity >= 0) & (post_fill_capacity / np.max(bins_remain_cap, initial=0) <= near_full_threshold)\n    priorities[near_full_bins] += near_full_bonus\n\n    # 4. Avoid tiny remaining capacities: Penalize bins that would have very little space left.\n    tiny_rem_threshold = 0.1  # Define \"tiny\" as having <= 10% remaining capacity relative to bin size\n    tiny_rem_penalty = -10\n    tiny_rem_bins = feasible_bins & (post_fill_capacity > 0) & (post_fill_capacity / np.max(bins_remain_cap, initial=0) <= tiny_rem_threshold)\n    priorities[tiny_rem_bins] += tiny_rem_penalty\n\n    # 5. Perfect fit: Reward perfect fits handsomely.\n    perfect_fit_bonus = 25\n    perfect_fit_bins = np.isclose(bins_remain_cap, item) & feasible_bins\n    priorities[perfect_fit_bins] += perfect_fit_bonus\n    \n    # 6. Handling the infeasible case: if no bins fit, distribute randomly\n    if not np.any(feasible_bins):\n        priorities[:] = 1.0 / len(bins_remain_cap)\n\n    return priorities",
    "response_id": 7,
    "obj": 4.457518946948548,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response8.txt_stdout.txt",
    "code_path": "problem_iter6_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: Only consider bins where the item fits.\n    feasible_bins = bins_remain_cap >= item\n\n    # 2. Waste minimization: Prioritize bins with smallest remaining capacity *after* placing the item\n    post_fill_levels = bins_remain_cap - item\n\n    # 3. Infeasibility penalty\n    priorities[~feasible_bins] = -np.inf\n\n    # 4. Reward tight fits, penalize waste:\n    waste = post_fill_levels[feasible_bins]\n    bin_size = bins_remain_cap.max()  # Assuming all bins have the same capacity\n    normalized_waste = waste / bin_size  # Waste as a percentage of bin capacity\n\n    priorities[feasible_bins] = -normalized_waste  # Invert waste to make it a priority.\n\n    # 5. Bonus for near-full bins:\n    near_full_threshold = 0.1  # Define a threshold for \"near full\" (e.g., 10% remaining capacity)\n    near_full_bonus = 1\n\n    near_full_bins = feasible_bins & (post_fill_levels >= 0) & (post_fill_levels <= (bin_size * near_full_threshold))  # Only consider non-negative remaining capacities to fix error\n    priorities[near_full_bins] += near_full_bonus\n\n    # 6. Penalize bins that would have too little remaining capacity, to consolidate items.\n    too_little_threshold = 0.2\n    too_little_penalty = -0.5\n\n    too_little_bins = feasible_bins & (post_fill_levels > 0) & (post_fill_levels <= (bin_size * too_little_threshold))\n    priorities[too_little_bins] += too_little_penalty\n    \n    # 7. Encourage balanced bin usage\n    average_fill = np.mean(bins_remain_cap) / bin_size #As percentage\n    balance_bonus = 0.1\n\n    #Give a small bonus for bins that are close to the average fill level after placing the item\n    average_fill_proximity = np.abs(normalized_waste - average_fill)\n    priorities[feasible_bins] -= balance_bonus * average_fill_proximity[feasible_bins]\n    \n    #8. Prioritize bins based on current fullness\n    current_fill_level = (bin_size - bins_remain_cap)/bin_size\n    fullness_bonus = 0.05 #A small weight so it does not dominate\n\n    priorities[feasible_bins] += fullness_bonus * current_fill_level[feasible_bins]\n\n    # 9. Normalize priorities if feasible bins exist to make them comparable\n    if np.any(feasible_bins):\n        max_priority = np.max(priorities[feasible_bins])\n        min_priority = np.min(priorities[feasible_bins])\n\n        if max_priority != min_priority:\n            priorities[feasible_bins] = (priorities[feasible_bins] - min_priority) / (max_priority - min_priority)\n    #If no feasible bin, return equal priorities\n    else:\n        priorities = np.ones_like(priorities)\n\n    return priorities",
    "response_id": 8,
    "obj": 3.839250099720782,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response9.txt_stdout.txt",
    "code_path": "problem_iter6_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: Only consider bins where the item fits.\n    feasible_bins = bins_remain_cap >= item\n\n    # 2. Calculate remaining capacity after placing the item\n    post_fill_levels = bins_remain_cap - item\n\n    # 3. Infeasibility penalty: Very low priority for infeasible bins\n    priorities[~feasible_bins] = -np.inf\n\n    # 4. Waste minimization using normalized waste\n    bin_size = bins_remain_cap.max()  # Assuming all bins have the same capacity\n    waste = post_fill_levels[feasible_bins]\n    normalized_waste = waste / bin_size\n    priorities[feasible_bins] = -normalized_waste\n\n    # 5. Bonus for near-full bins (encourage filling bins completely)\n    near_full_threshold = 0.1\n    near_full_bonus = 1.0\n    near_full_bins = feasible_bins & (post_fill_levels >= 0) & (post_fill_levels <= (bin_size * near_full_threshold))\n    priorities[near_full_bins] += near_full_bonus\n\n    # 6. Penalty for bins that would become too empty (encourage consolidation)\n    too_empty_threshold = 0.2\n    too_empty_penalty = -0.5\n    too_empty_bins = feasible_bins & (post_fill_levels > 0) & (post_fill_levels <= (bin_size * too_empty_threshold))\n    priorities[too_empty_bins] += too_empty_penalty\n\n    # 7. Slightly prioritize bins with more remaining capacity before placing the item to avoid overfilling one bin while other bins have space\n    priorities[feasible_bins] += 0.01 * (bins_remain_cap[feasible_bins] / bin_size)\n\n\n    # 8. If no feasible bin exists, give all bins equal priority\n    if not np.any(feasible_bins):\n        priorities = np.ones_like(priorities)\n\n    return priorities",
    "response_id": 9,
    "obj": 3.7395293179098523,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter7_response0.txt_stdout.txt",
    "code_path": "problem_iter7_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_size = bins_remain_cap.max() #Assuming all bins have the same capacity\n\n    # 1. Feasibility: Only consider bins where the item fits.\n    feasible_bins = bins_remain_cap >= item\n\n    # 2. Infesibility penalty\n    priorities[~feasible_bins] = -np.inf\n\n    # Proceed only if at least one bin is feasible\n    if np.any(feasible_bins):\n        # 3. Waste minimization: Prioritize bins with smallest waste AFTER placing the item\n        post_fill_levels = bins_remain_cap - item\n        waste = post_fill_levels[feasible_bins]\n        normalized_waste = waste / bin_size\n\n        priorities[feasible_bins] = -normalized_waste\n\n        # 4. Bonus for near-full bins:\n        near_full_threshold = 0.1\n        near_full_bonus = 1.0\n        near_full_bins = (post_fill_levels[feasible_bins] >= 0) & (post_fill_levels[feasible_bins] <= (bin_size * near_full_threshold))\n        priorities[feasible_bins][near_full_bins] += near_full_bonus\n\n        # 5. Penalty for bins that would have too little remaining capacity, to consolidate items.\n        too_little_threshold = 0.2\n        too_little_penalty = -0.5\n        too_little_bins = (post_fill_levels[feasible_bins] > 0) & (post_fill_levels[feasible_bins] <= (bin_size * too_little_threshold))\n        priorities[feasible_bins][too_little_bins] += too_little_penalty\n    else:\n        # If no bin is feasible, spread the item across bins using a low priority to ensure eventually a bin will be opened. This is a fallback strategy and should ideally not be used.\n        priorities = np.ones_like(priorities) * -0.1 # Ensure a very small negative priority for all bins\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter7_response1.txt_stdout.txt",
    "code_path": "problem_iter7_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: Only consider bins where the item fits.\n    feasible_bins = bins_remain_cap >= item\n\n    # 2. Waste minimization: Prioritize bins with smallest remaining capacity *after* placing the item\n    post_fill_levels = bins_remain_cap - item\n    \n    # 3. Infesibility penalty\n    priorities[~feasible_bins] = -np.inf\n\n    # 4. Reward tight fits, penalize waste:\n    waste = np.copy(post_fill_levels)\n    waste[waste < 0] = 0 #Consider only the bins that fit\n    bin_size = bins_remain_cap.max() #Assuming all bins have the same capacity\n\n    # Avoid division by zero by adding a small epsilon\n    epsilon = 1e-9\n    normalized_waste = waste / (bin_size + epsilon)\n\n    priorities[feasible_bins] =  -normalized_waste[feasible_bins]  #Invert waste to make it a priority.\n    \n    # 5. Bonus for near-full bins:\n    near_full_threshold = 0.2  # Define a threshold for \"near full\" (e.g., 20% remaining capacity)\n    near_full_bonus = 1.5\n\n    near_full_bins = feasible_bins & (post_fill_levels >= 0) & (post_fill_levels <= (bin_size * near_full_threshold))\n    priorities[near_full_bins] += near_full_bonus\n\n    # 6. Penalize bins that would have too little remaining capacity, to consolidate items.\n    too_little_threshold = 0.1\n    too_little_penalty = -0.8\n\n    too_little_bins = feasible_bins & (post_fill_levels > 0) & (post_fill_levels <= (bin_size * too_little_threshold))\n    priorities[too_little_bins] += too_little_penalty\n\n    # 7. Slightly prioritize more filled bins to encourage consolidation.\n    fill_level = (bin_size - bins_remain_cap) / (bin_size + epsilon)\n    priorities[feasible_bins] += 0.1 * fill_level[feasible_bins]\n\n    # 8. If no bins are feasible, allow overflow into any bin with a very low priority.\n    if not np.any(feasible_bins):\n      priorities = np.ones_like(priorities) * -10  # Assign low priority to all\n      \n      # Assign some bins positive priorities arbitrarily if bin_remain_cap are not empty (select the first one)\n      if np.any(bins_remain_cap > 0):\n          first_available_index = np.argmax(bins_remain_cap) # the first bin available\n          priorities[first_available_index] = 1\n\n    return priorities",
    "response_id": 1,
    "obj": 4.8065416832868015,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter7_response2.txt_stdout.txt",
    "code_path": "problem_iter7_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_size = bins_remain_cap.max()  # Assuming all bins have the same capacity\n\n    # 1. Feasibility: Only consider bins where the item fits.\n    feasible_bins = bins_remain_cap >= item\n\n    # 2. Post-fill levels\n    post_fill_levels = bins_remain_cap - item\n\n    # 3. Infesibility penalty\n    priorities[~feasible_bins] = -np.inf\n\n    # 4. Waste minimization: Prioritize bins with smallest remaining capacity *after* placing the item\n    #    Handle cases where item doesn't fit robustly using a large penalty.\n    waste = np.where(feasible_bins, post_fill_levels, bin_size)  # Use bin_size as waste if item doesn't fit.\n\n    # 5. Normalized Waste as priority:\n    normalized_waste = waste / bin_size\n\n    priorities[feasible_bins] = -normalized_waste[feasible_bins]\n\n    # 6. Bonus for near-full bins:\n    near_full_threshold = 0.1  # Define a threshold for \"near full\" (e.g., 10% remaining capacity)\n    near_full_bonus = 1\n    near_full_bins = feasible_bins & (post_fill_levels >= 0) & (post_fill_levels <= (bin_size * near_full_threshold))\n    priorities[near_full_bins] += near_full_bonus\n\n    # 7. Penalize bins that would have too little remaining capacity, to consolidate items.\n    too_little_threshold = 0.2\n    too_little_penalty = -0.5\n    too_little_bins = feasible_bins & (post_fill_levels > 0) & (post_fill_levels <= (bin_size * too_little_threshold))\n    priorities[too_little_bins] += too_little_penalty\n\n    # 8. If there are no feasible bins, distribute the priority evenly based on current occupancy\n    if not np.any(feasible_bins):\n        normalized_occupancy = (bin_size - bins_remain_cap) / bin_size\n        priorities = normalized_occupancy\n\n    return priorities",
    "response_id": 2,
    "obj": 3.7295572397287686,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter7_response3.txt_stdout.txt",
    "code_path": "problem_iter7_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # 1. Feasibility: Only consider bins where the item fits.\n    feasible_bins = bins_remain_cap >= item\n    \n    # 2. Waste minimization: Prioritize bins with smallest remaining capacity *after* placing the item\n    post_fill_levels = bins_remain_cap - item\n    \n    # 3. Infesibility penalty\n    priorities[~feasible_bins] = -np.inf\n    \n    # 4. Reward tight fits, penalize waste:\n    waste = post_fill_levels[feasible_bins]\n    bin_size = bins_remain_cap.max() #Assuming all bins have the same capacity\n    normalized_waste = waste / bin_size if bin_size > 0 else np.zeros_like(waste) #Waste as a percentage of bin capacity, avoid division by zero\n    \n    priorities[feasible_bins] =  -normalized_waste  #Invert waste to make it a priority.\n\n    # 5. Bonus for near-full bins:\n    near_full_threshold = 0.1  # Define a threshold for \"near full\" (e.g., 10% remaining capacity)\n    near_full_bonus = 1\n\n    near_full_bins = feasible_bins & (post_fill_levels >= 0) & (post_fill_levels <= (bin_size * near_full_threshold))  #Only consider non-negative remaining capacities to fix error\n    priorities[near_full_bins] += near_full_bonus\n    \n    # 6. Penalize bins that would have too little remaining capacity, to consolidate items.\n    too_little_threshold = 0.2\n    too_little_penalty = -0.5\n\n    too_little_bins = feasible_bins & (post_fill_levels > 0) & (post_fill_levels <= (bin_size * too_little_threshold))\n    priorities[too_little_bins] += too_little_penalty\n\n    # 7. Handle case where item is larger than any existing capacity\n\n    if not np.any(feasible_bins):\n        priorities = np.full_like(priorities, -np.inf) # Set all to -inf, so no bin is chosen.\n        # Find the largest bin, and set its priority to 0\n        if bins_remain_cap.size > 0:  # Check if bins_remain_cap is not empty\n            largest_bin_index = np.argmax(bins_remain_cap)\n            priorities[largest_bin_index] = 0 \n\n    return priorities",
    "response_id": 3,
    "obj": 3.7295572397287686,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter7_response4.txt_stdout.txt",
    "code_path": "problem_iter7_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # 1. Feasibility: Only consider bins where the item fits.\n    feasible_bins = bins_remain_cap >= item\n    \n    # 2. Waste minimization: Prioritize bins with smallest remaining capacity *after* placing the item\n    post_fill_levels = bins_remain_cap - item\n    \n    # 3. Infesibility penalty\n    priorities[~feasible_bins] = -np.inf\n    \n    # 4. Reward tight fits, penalize waste:\n    waste = post_fill_levels[feasible_bins]\n    bin_size = bins_remain_cap.max() #Assuming all bins have the same capacity\n    normalized_waste = waste / bin_size #Waste as a percentage of bin capacity\n    \n    priorities[feasible_bins] =  -normalized_waste  #Invert waste to make it a priority.\n\n    # 5. Bonus for near-full bins: increased bonus to encourage packing items into partially filled bins\n    near_full_threshold = 0.1  # Define a threshold for \"near full\" (e.g., 10% remaining capacity)\n    near_full_bonus = 2\n\n    near_full_bins = feasible_bins & (post_fill_levels >= 0) & (post_fill_levels <= (bin_size * near_full_threshold))  #Only consider non-negative remaining capacities to fix error\n    priorities[near_full_bins] += near_full_bonus\n    \n    # 6. Penalize bins that would have too little remaining capacity, to consolidate items. increased penalty to improve consolidation\n    too_little_threshold = 0.2\n    too_little_penalty = -1\n\n    too_little_bins = feasible_bins & (post_fill_levels > 0) & (post_fill_levels <= (bin_size * too_little_threshold))\n    priorities[too_little_bins] += too_little_penalty\n    \n    #7. Modify waste calculation to avoid division by zero and use relative waste.\n    waste_ratio = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    valid_bins = bins_remain_cap > 0 #Avoid division by zero\n\n    waste_ratio[valid_bins] = item / bins_remain_cap[valid_bins] #Ratio of item size to remaining capacity\n\n    priorities[feasible_bins] += waste_ratio[feasible_bins] #Add the ratio as a priority\n\n    # 8. Normalize priorities if no feasible bin exists:Removed normalization\n    if not np.any(feasible_bins):\n       priorities = np.full_like(priorities, -np.inf) #If no bins are available, mark all as unavailable by giving a large negative priority\n\n    return priorities",
    "response_id": 4,
    "obj": 4.048663741523748,
    "exec_success": true
  }
]