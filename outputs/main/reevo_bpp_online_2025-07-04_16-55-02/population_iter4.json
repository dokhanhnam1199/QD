[
  {
    "stdout_filepath": "problem_iter4_response0.txt_stdout.txt",
    "code_path": "problem_iter4_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    can_fit = bins_remain_cap >= item\n\n    if np.any(can_fit):\n        waste = bins_remain_cap[can_fit] - item\n        priorities[can_fit] = 1.0 / (1e-9 + waste)  # Prioritize tight fits using inverse waste, add small constant for numerical stability.\n        \n        #Optional: Adjust priority based on remaining capacity to break ties based on more full bins.\n        #priorities[can_fit] += bins_remain_cap[can_fit] / np.max(bins_remain_cap)\n        \n    else:\n        # If no bin can fit the item, spread the probability based on available capacity.\n        # This helps to distribute items and potentially open up space in the future.\n        total_capacity = np.sum(bins_remain_cap)\n        if total_capacity > 0:  # Avoid division by zero if all bins are full.\n            priorities = bins_remain_cap / total_capacity\n        else:\n            priorities = np.ones_like(bins_remain_cap) / len(bins_remain_cap) #Distribute evenly if everything is full\n            \n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response1.txt_stdout.txt",
    "code_path": "problem_iter4_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Rule 1: Very high priority for perfect fits\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    priorities[perfect_fit] = 1000\n\n    # Rule 2: High priority for bins that can fit, inversely proportional to wasted space\n    can_fit = bins_remain_cap >= item\n    waste = bins_remain_cap - item\n    waste[~can_fit] = np.inf  # Ensure only bins that can fit are considered\n\n    # Avoid division by zero, and only apply to bins that can fit and are not perfect fits\n    valid_bins = can_fit & ~perfect_fit\n    if np.any(valid_bins):\n        priorities[valid_bins] = 100 / (waste[valid_bins] + 0.0001)  # Small constant to avoid division by zero and scale up\n\n    # Rule 3: Very low priority (penalty) for bins that cannot fit\n    priorities[~can_fit] = -1000\n\n    # Rule 4: slight bonus for nearly full bins that can fit\n    nearly_full = can_fit & (bins_remain_cap <= 2 * item) & ~perfect_fit\n    priorities[nearly_full] += 50 #add a bonus for nearly full, but not perfect bins\n\n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response2.txt_stdout.txt",
    "code_path": "problem_iter4_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: Only consider bins where the item fits.\n    feasible_bins = bins_remain_cap >= item\n\n    # 2. Waste minimization: Use inverse waste to heavily penalize large waste.\n    waste = bins_remain_cap - item\n    waste[~feasible_bins] = np.inf  # Set infeasible waste to infinity\n\n    # Calculate priorities based on minimized waste for feasible bins\n    priorities[feasible_bins] = -waste[feasible_bins]\n\n    # 3. Bonus for near-full bins (consolidation):\n    near_full_threshold = 0.1  # Define a threshold for \"near full\" (e.g., 10% remaining capacity)\n    near_full_bonus = 10\n\n    near_full_bins = feasible_bins & (waste >= 0) & (waste <= (bins_remain_cap.max() * near_full_threshold))\n    priorities[near_full_bins] += near_full_bonus\n\n    # 4. Penalize bins that would have too little remaining capacity\n    too_little_threshold = 0.2\n    too_little_penalty = -5\n\n    too_little_bins = feasible_bins & (waste > 0) & (waste/bins_remain_cap.max() <= too_little_threshold)\n    priorities[too_little_bins] += too_little_penalty\n    \n    # 5. Perfect fit\n    perfect_fit_bonus = 20\n    perfect_fit_bins = np.isclose(bins_remain_cap, item) & feasible_bins\n    priorities[perfect_fit_bins] += perfect_fit_bonus\n\n\n    # 6. If no bin fits, normalize priorities (distribute item randomly)\n    if not np.any(feasible_bins):\n        priorities[:] = 1.0 / len(bins_remain_cap)  # Assign equal probability\n\n    return priorities",
    "response_id": 2,
    "obj": 3.9589150378939015,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response3.txt_stdout.txt",
    "code_path": "problem_iter4_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Rule 1: Very high priority for perfect fits\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    priorities[perfect_fit] = 1000\n\n    # Rule 2: High priority for bins that can fit, inversely proportional to wasted space\n    can_fit = bins_remain_cap >= item\n    waste = bins_remain_cap - item\n    waste[~can_fit] = np.inf  # Ensure only bins that can fit are considered\n\n    # Avoid division by zero, and only apply to bins that can fit and are not perfect fits\n    valid_bins = can_fit & ~perfect_fit\n    if np.any(valid_bins):\n        priorities[valid_bins] = 100 / (waste[valid_bins] + 0.0001)  # Small constant to avoid division by zero. Scale to differentiate.\n\n    # Rule 3: Very low priority (penalty) for bins that cannot fit\n    priorities[~can_fit] = -1000\n\n    # Rule 4: Slightly increased priority for almost full bins.\n    almost_full = can_fit & (waste < 0.1 * np.mean(bins_remain_cap[can_fit] if np.any(can_fit) else bins_remain_cap))  #Adjust the threshold 0.1 based on tests.\n    priorities[almost_full] += 10 # Additive bonus.\n\n    return priorities",
    "response_id": 3,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response4.txt_stdout.txt",
    "code_path": "problem_iter4_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: Only consider bins that can accommodate the item.\n    feasible_bins = bins_remain_cap >= item\n\n    # If no feasible bins, return all -inf to force opening a new bin if possible\n    if not np.any(feasible_bins):\n        return np.full_like(bins_remain_cap, -np.inf)\n\n    # 2. Waste minimization: Prioritize bins with minimal waste after packing.\n    waste = bins_remain_cap - item\n    waste[~feasible_bins] = np.inf  # Penalize infeasible bins\n\n    # 3. Utilization: Prioritize bins with higher utilization after packing.\n    utilization = (bins_remain_cap - waste) / np.max(bins_remain_cap) # Normalize by max capacity\n    utilization[~feasible_bins] = -np.inf  # Ensure infeasible bins have the lowest priority\n\n\n    # Combine waste and utilization into a single priority score. Give higher weight to waste.\n\n    priorities = -waste + 10 * utilization  # Minimize waste and maximize utilization\n\n\n\n    priorities[~feasible_bins] = -np.inf  # Explicitly set infeasible bins to lowest priority\n\n    return priorities",
    "response_id": 4,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response5.txt_stdout.txt",
    "code_path": "problem_iter4_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: Only consider bins that can accommodate the item.\n    feasible_bins = bins_remain_cap >= item\n\n    # If no feasible bins, return all -inf to force opening a new bin if possible\n    if not np.any(feasible_bins):\n        return np.full_like(bins_remain_cap, -np.inf)\n\n    # 2. Waste minimization: Prioritize bins with minimal waste after packing.\n    waste = bins_remain_cap - item\n    waste[~feasible_bins] = np.inf  # Penalize infeasible bins\n\n    # 3. Utilization: Prioritize bins with higher utilization after packing.\n    utilization = (bins_remain_cap - waste) / bins_remain_cap\n    utilization[~feasible_bins] = -np.inf  # Ensure infeasible bins have the lowest priority\n\n\n    # Combine waste and utilization into a single priority score. Give higher weight to utilization.\n\n    priorities = -waste + 10 * utilization  # Minimize waste and maximize utilization\n\n\n\n    priorities[~feasible_bins] = -np.inf  # Explicitly set infeasible bins to lowest priority\n\n    return priorities",
    "response_id": 5,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response6.txt_stdout.txt",
    "code_path": "problem_iter4_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: Only consider bins that can accommodate the item.\n    feasible_bins = bins_remain_cap >= item\n\n    # If no feasible bins, return all -inf to force opening a new bin if possible\n    if not np.any(feasible_bins):\n        return np.full_like(bins_remain_cap, -np.inf)\n\n    # 2. Waste minimization: Prioritize bins with minimal waste after packing.\n    waste = bins_remain_cap - item\n    waste[~feasible_bins] = np.inf  # Penalize infeasible bins\n\n    # 3. Utilization: Prioritize bins with higher utilization after packing.\n    utilization = (bins_remain_cap - waste) / (bins_remain_cap + 1e-9) # Adding a small number to the denominator to avoid division by zero\n    utilization[~feasible_bins] = -np.inf  # Ensure infeasible bins have the lowest priority\n    \n    #4. Near full bonus\n    near_full = feasible_bins & (bins_remain_cap <= 1.1 * item)\n    \n    # Combine waste and utilization into a single priority score. Give higher weight to waste.\n    priorities = -waste + 5 * utilization\n    priorities[near_full] += 1 #Slightly boost near full bins\n    \n\n    priorities[~feasible_bins] = -np.inf  # Explicitly set infeasible bins to lowest priority\n\n    return priorities",
    "response_id": 6,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response7.txt_stdout.txt",
    "code_path": "problem_iter4_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    can_fit = bins_remain_cap >= item\n\n    if np.any(can_fit):\n        waste = bins_remain_cap[can_fit] - item\n        priorities[can_fit] = 1.0 / (1e-9 + waste)  # Prioritize tight fits using inverse waste. Adding small constant for numerical stability\n    else:\n        # When no bin can fit, prioritize bins with larger remaining capacity to potentially accommodate future smaller items.\n        total_capacity = np.sum(bins_remain_cap)\n        if total_capacity > 0:\n            priorities = bins_remain_cap / total_capacity  # Normalize to prioritize bins with larger remaining capacity\n        else:\n            priorities = np.ones_like(bins_remain_cap) / len(bins_remain_cap) # If all bins are empty, assign equal probability\n\n    return priorities",
    "response_id": 7,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response8.txt_stdout.txt",
    "code_path": "problem_iter4_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: Only consider bins where the item fits.\n    feasible_bins = bins_remain_cap >= item\n\n    # 2. Calculate remaining capacity after placing the item\n    post_fill_levels = bins_remain_cap - item\n\n    # 3. Infeasibility penalty: Very low priority for infeasible bins\n    priorities[~feasible_bins] = -np.inf\n\n    # 4. Waste minimization using normalized waste\n    bin_size = bins_remain_cap.max()  # Assuming all bins have the same capacity\n    waste = post_fill_levels[feasible_bins]\n    normalized_waste = waste / bin_size\n    priorities[feasible_bins] = -normalized_waste\n\n    # 5. Bonus for near-full bins (encourage filling bins completely)\n    near_full_threshold = 0.1\n    near_full_bonus = 1.0\n    near_full_bins = feasible_bins & (post_fill_levels >= 0) & (post_fill_levels <= (bin_size * near_full_threshold))\n    priorities[near_full_bins] += near_full_bonus\n\n    # 6. Penalty for bins that would become too empty (encourage consolidation)\n    too_empty_threshold = 0.2\n    too_empty_penalty = -0.5\n    too_empty_bins = feasible_bins & (post_fill_levels > 0) & (post_fill_levels <= (bin_size * too_empty_threshold))\n    priorities[too_empty_bins] += too_empty_penalty\n\n    # 7. If no feasible bin exists, give all bins equal priority\n    if not np.any(feasible_bins):\n        priorities = np.ones_like(priorities)\n\n    return priorities",
    "response_id": 8,
    "obj": 3.7295572397287686,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response9.txt_stdout.txt",
    "code_path": "problem_iter4_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Heuristic 1: Reward fitting items significantly.\n    fit_mask = bins_remain_cap >= item\n    priorities[fit_mask] += 100  # Substantially reward fitting\n\n    # Heuristic 2: Among bins that fit, prefer those with the least *percentage* of remaining capacity after placing the item.\n    remaining_after_fit = bins_remain_cap[fit_mask] - item\n    percentage_remaining = remaining_after_fit / bins_remain_cap[fit_mask]\n    priorities[fit_mask] += np.exp(-10 * percentage_remaining)  # Exponential decay favors smaller percentages\n\n    # Heuristic 3: Heavily penalize bins that cannot fit, proportional to the overflow.\n    no_fit_mask = bins_remain_cap < item\n    overflow = item - bins_remain_cap[no_fit_mask]\n    priorities[no_fit_mask] -= 50 * overflow  # Penalty proportional to overflow\n    \n\n    # Heuristic 4: If no bins can fit, prefer bins with largest capacity.  Only apply if no fit is possible.\n    if not np.any(fit_mask):\n        max_cap = np.max(bins_remain_cap)\n        if max_cap > 0:\n            priorities += bins_remain_cap / max_cap  # Normalize to avoid dominating penalties\n        else:\n            priorities += 0  # All bins are empty, so no preference\n    return priorities",
    "response_id": 9,
    "obj": 4.048663741523748,
    "exec_success": true
  }
]