Use dynamic penalties and boosts, prioritize large gaps and precise fits, penalize emptiness, and significantly boost perfect fits, while balancing complexity for practical efficiency.
