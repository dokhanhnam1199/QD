```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using a strategy that prioritizes bins with minimal remaining space after packing, and among those, favors bins that are fuller.

    This strategy is a refinement of Best Fit.
    1. Primary objective: Minimize the "slack" (remaining capacity - item size).
       Bins with slack closer to zero are preferred.
    2. Secondary objective: Among bins with the same slack, prefer bins that are fuller.
       A fuller bin has less remaining capacity.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Returns:
        Array of same size as bins_remain_cap with priority score of each bin.
        A higher score indicates a higher priority. Bins that cannot fit the item
        will have a priority of 0.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins that can accommodate the item
    can_fit_mask = bins_remain_cap >= item

    if not np.any(can_fit_mask):
        return priorities

    # Calculate slack for fittable bins
    # Slack = remaining_capacity - item_size
    slack = bins_remain_cap[can_fit_mask] - item

    # Primary scoring: Minimize slack. We want to maximize a function that is
    # large for small slack. Using 1.0 / (slack + epsilon) achieves this.
    # A slack of 0 gives the highest score (1.0).
    best_fit_score = 1.0 / (slack + 1e-9)

    # Secondary scoring: Favor fuller bins. This means preferring bins with
    # smaller remaining capacity among those with the same slack.
    # We can achieve this by maximizing 1.0 / bins_remain_cap.
    fuller_bin_score = 1.0 / (bins_remain_cap[can_fit_mask] + 1e-9)

    # Combine scores. We want slack to be the primary driver.
    # A simple way to combine is to add them, but to ensure slack is dominant,
    # we can multiply by a factor that makes the slack score much larger.
    # Alternatively, we can use a weighted sum where the slack component
    # has a larger weight.
    # Let's try a composite score where we consider slack first, and then remaining capacity.
    # A common way to achieve lexicographical ordering is to use a base and scaled values.
    # For example: score = PrimaryScore * Scale + SecondaryScore
    # Here, we want to maximize `best_fit_score` and `fuller_bin_score`.
    # If `best_fit_score` is the primary, we want it to have a higher impact.

    # Let's use a weighting approach.
    # Weight for best fit: Give it a higher weight to ensure it's considered first.
    # Weight for fuller bin: Give it a smaller weight as it's a secondary preference.
    # However, directly adding might lead to issues if the scales are very different.

    # A robust way for "minimize A, then minimize B" is to maximize (-A - alpha*B).
    # So, we want to maximize `-(slack) - alpha * (bins_remain_cap)`.
    # This translates to maximizing `-(slack + alpha * bins_remain_cap)`.
    # Let's use alpha = 1, and see how it performs.
    # The priority will be `- (slack + bins_remain_cap[can_fit_mask])`.
    # This means smaller values of `slack + bins_remain_cap` get higher priority.
    # Example:
    # Bin A: slack=0, rem_cap=5  => sum=5, priority = -5
    # Bin B: slack=0, rem_cap=10 => sum=10, priority = -10
    # Bin C: slack=1, rem_cap=5  => sum=6, priority = -6
    # Bin D: slack=1, rem_cap=10 => sum=11, priority = -11
    # This correctly prioritizes Bin A (best fit, fullest), then Bin C (good fit, fullest), then Bin B (best fit, less full), then Bin D.

    # However, the reflection asked to "prioritize fuller bins by inverting remaining capacity for better fit."
    # This implies that `1.0 / bins_remain_cap` should contribute positively to the priority.
    # So, we want to maximize `1.0 / (slack + epsilon)` AND maximize `1.0 / (bins_remain_cap + epsilon)`.
    # Let's use a simple additive approach, ensuring the best-fit component is primary.
    # We can scale the "fuller bin" score.
    # `priorities[can_fit_mask] = best_fit_score + 0.1 * fuller_bin_score`
    # The `0.1` is a heuristic weight. It makes the "fuller bin" score less influential than "best fit".
    # For example, if slack is 0, BF score is 1. If rem_cap is 5, FB score is 0.2. Total 1.2.
    # If slack is 0, rem_cap is 10, BF score is 1. FB score is 0.1. Total 1.1.
    # This correctly prioritizes the fuller bin among those with the same slack.

    # Let's consider the case where slack is small but not zero.
    # slack=0.1, rem_cap=5. BF score = 1 / 1.1 = 0.909. FB score = 0.2. Total = 1.109.
    # slack=0, rem_cap=10. BF score = 1.0. FB score = 0.1. Total = 1.1.
    # In this case, the slack=0.1 bin is prioritized over the slack=0, fuller bin. This is not ideal.

    # The reflection implies a stronger preference for fuller bins when slack is the same.
    # Let's combine them in a way that ensures the primary objective (minimal slack) is paramount,
    # and the secondary objective (fuller bins) breaks ties effectively.

    # A common way is to sort by (slack, bins_remain_cap). We want the smallest such pair.
    # For priority, we want to maximize a score reflecting this.
    # So, we want to maximize `(-slack, -bins_remain_cap)`.
    # We can achieve this by converting to a single score: `-slack - alpha * bins_remain_cap`.
    # If alpha is chosen large enough, `-slack` dominates.
    # Let's use `alpha = 1`. The score is `-(slack + bins_remain_cap[can_fit_mask])`.
    # This means the highest priority (least negative) is for the smallest `slack + bins_remain_cap`.

    # Example:
    # Bin A: slack=0, rem_cap=5  => sum=5, priority = -5
    # Bin B: slack=0, rem_cap=10 => sum=10, priority = -10
    # Bin C: slack=1, rem_cap=5  => sum=6, priority = -6
    # Bin D: slack=1, rem_cap=10 => sum=11, priority = -11
    # This seems to match the desired behavior: A is best, then C, then B, then D.
    # This priority function directly implements minimizing slack first, then minimizing remaining capacity.

    priorities[can_fit_mask] = -(slack + bins_remain_cap[can_fit_mask])

    return priorities
```
