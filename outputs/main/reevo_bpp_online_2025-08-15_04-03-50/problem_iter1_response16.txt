```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Sigmoid Fit Score.

    The Sigmoid Fit Score prioritizes bins that are a "good fit" for the item.
    A good fit is defined as a bin where the remaining capacity is slightly larger
    than the item size. This strategy aims to leave larger gaps in other bins
    for potentially larger future items, while efficiently using space in the
    current bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Returns:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Ensure item size is not larger than any bin's capacity (otherwise it can't fit)
    # For items that cannot fit, assign a very low priority (-inf)
    valid_bins_mask = bins_remain_cap >= item
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # For bins where the item can fit
    remaining_capacities_for_valid_bins = bins_remain_cap[valid_bins_mask]

    # Calculate the difference between remaining capacity and item size
    # This represents how much "extra" space is left after placing the item.
    # We want this difference to be small but positive for a good fit.
    diff = remaining_capacities_for_valid_bins - item

    # Apply a sigmoid-like function to map the differences to priorities.
    # A steep sigmoid centered around 0 (meaning diff=0) would give the highest score.
    # We want to penalize bins that are too small (negative diff, item doesn't fit, already handled by -inf)
    # and bins that are too large (large positive diff, leaving a lot of wasted space).
    # A common approach is to use a sigmoid scaled and shifted.
    # Let's center the sigmoid around 0. The logistic function is 1 / (1 + exp(-x)).
    # To prioritize bins with diff close to 0, we can use exp(-abs(diff)).
    # Alternatively, we can use a transformed diff in the sigmoid:
    # sigmoid(k * (target_diff - diff)). We want target_diff to be close to 0.
    # So, exp(-k * diff) or exp(-k * abs(diff)) might be suitable.
    # Let's try exp(-k * diff). If diff is small and positive, exp(-k*diff) is close to 1.
    # If diff is negative (item doesn't fit), exp(-k*diff) would be large, which is good for negative values,
    # but we've already filtered those.
    #
    # A more robust sigmoid fit could be:
    # priority = 1 / (1 + exp(-k * (remaining_capacity - item - margin)))
    # where 'margin' is a desired small positive buffer.
    # For simplicity, let's use a Gaussian-like shape centered around zero difference,
    # which is achieved by exp(-diff^2) or similar.

    # Let's use exp(-k * diff) where k is a scaling factor. A larger k makes the preference for
    # a tight fit more pronounced.
    k = 2.0  # Sensitivity parameter, adjust as needed. Higher k means tighter fit preferred.
    priorities[valid_bins_mask] = np.exp(-k * diff)

    # To make it more "priority-like" where higher means more desirable,
    # and we want to strongly prefer bins that are just big enough,
    # we can also consider how much space is left.
    # A simple logistic function centered around the "ideal" remaining capacity might be:
    # ideal_remaining_capacity = item  (or item + a small buffer)
    # Let's try a function that is high when remaining_capacity is slightly larger than item, and decreases otherwise.
    # For example, a Gaussian-like shape: exp(-((remaining_capacity - item - buffer)**2) / sigma**2)
    # Let's use a simpler approach: 1 / (1 + exp(k * (item - remaining_capacity)))
    # If remaining_capacity is slightly larger than item, (item - remaining_capacity) is small negative, exp is close to 0, priority is close to 1.
    # If remaining_capacity is much larger than item, (item - remaining_capacity) is large negative, exp is close to 0, priority is close to 1. This is not ideal.
    #
    # Let's re-evaluate the goal: we want to select bins where the remaining capacity is *just* enough.
    # This means `remaining_capacity - item` should be small and positive.
    # So, `diff = remaining_capacity - item` should be close to zero.
    # A function that peaks at diff=0 would be `exp(-c * diff^2)` or `1 / (1 + exp(-c * diff))`.
    #
    # Let's refine using the sigmoid idea for "fit score":
    # Consider the "waste" ratio: `(remaining_capacity - item) / remaining_capacity` if remaining_capacity > 0.
    # We want this ratio to be small.
    # Let's try prioritizing bins where `remaining_capacity` is close to `item`.
    # This means `remaining_capacity / item` is close to 1.

    # Let's try a sigmoid applied to the difference:
    # sigmoid(a * (ideal_fit - (remaining_capacity - item)))
    # ideal_fit = 0 (meaning we want remaining_capacity - item = 0)
    # So, sigmoid(a * (- (remaining_capacity - item))) = sigmoid(a * (item - remaining_capacity))
    # If remaining_capacity is just slightly larger than item, `item - remaining_capacity` is small negative, sigmoid output is ~0.5
    # If remaining_capacity is much larger than item, `item - remaining_capacity` is large negative, sigmoid output is ~0.
    # If remaining_capacity is less than item, `item - remaining_capacity` is positive, sigmoid output is ~1. This is also not good as it implies larger bins are better when item doesn't fit.

    # Let's use a sigmoid that peaks at `remaining_capacity == item` (i.e., `diff == 0`).
    # A common choice for this is a scaled Gaussian-like function or a logistic function focused on the difference.
    # Let's use `1 / (1 + exp(k * abs(diff)))`. This peaks at diff=0 (score=1) and decays as diff increases.
    # We already filtered for diff >= 0. So, `abs(diff)` is just `diff`.
    # `1 / (1 + exp(k * diff))`.
    # If diff = 0, score = 1.
    # If diff is small positive (e.g., 0.1), score is slightly less than 1.
    # If diff is large positive, score is close to 0.
    # This means bins that *exactly* fit the item are prioritized the most, and bins with much larger capacity are de-prioritized.

    k_sigmoid = 5.0 # Controls how sharply the priority drops as the fit becomes less tight.
    priorities[valid_bins_mask] = 1.0 / (1.0 + np.exp(k_sigmoid * diff))

    # Optional: Normalize priorities or add a small constant to avoid zero priorities if needed,
    # but for this strategy, zero is a valid low priority if nothing fits.
    # The current approach ensures items that can fit have priority > 0 and <= 1.

    return priorities
```
