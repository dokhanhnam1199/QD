```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin, prioritizing minimal waste and then fuller bins.

    This strategy aims to find bins where the remaining capacity is just enough to fit the item (minimizing slack).
    Among bins that offer a similar "tight fit" (i.e., similar slack), it prioritizes those that are already fuller
    (have less remaining capacity).

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Returns:
        Array of same size as bins_remain_cap with priority score of each bin.
        A higher score indicates a higher priority. Bins that cannot fit the item
        will have a priority of 0.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins where the item can fit
    can_fit_mask = bins_remain_cap >= item

    # For bins that can fit, calculate the "slack" (waste after insertion)
    slack = bins_remain_cap[can_fit_mask] - item

    # To prioritize minimal waste (smallest slack), we want a score that is
    # higher for smaller slack values. A common way is `1.0 / (slack + epsilon)`.
    # This maps slack [0, infinity) to priority (1, 0].

    # To prioritize fuller bins among those with similar slack, we want a score
    # that is higher for smaller `bins_remain_cap`. A common way is `1.0 / bins_remain_cap`.

    # Combine these two objectives additively.
    # The primary objective is minimal slack, so its term should ideally dominate.
    # However, a simple sum often works well, assuming the scales are somewhat managed.
    # Using `1.0 / (slack + epsilon)` for minimal waste.
    # Using `1.0 / (bins_remain_cap[can_fit_mask] + epsilon)` for fuller bins preference.
    # Adding a small epsilon to denominators to prevent division by zero and to avoid
    # issues with exact zero remaining capacities (though unlikely in BPP context, good practice).

    # If slack is 0, the first term is ~1. If slack is large, first term approaches 0.
    # If bin_remain_cap is small (fuller bin), second term is large. If bin_remain_cap is large, second term is small.
    # This combination correctly prioritizes bins with small slack and small remaining capacity.
    
    epsilon = 1e-9  # Small value to prevent division by zero

    # Calculate the score for fitting bins
    # Score = (Inverse of slack) + (Inverse of remaining capacity)
    # Higher score means better priority
    priorities[can_fit_mask] = (1.0 / (slack + epsilon)) + (1.0 / (bins_remain_cap[can_fit_mask] + epsilon))

    return priorities
```
