```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Inverse Distance (Proximity Fit) strategy.

    The Inverse Distance (Proximity Fit) strategy prioritizes bins that have a remaining capacity
    closest to the item's size, but still large enough to fit the item. A higher score
    means a better fit.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap)
    
    # Consider only bins that can fit the item
    eligible_bins_mask = bins_remain_cap >= item
    eligible_bins_capacities = bins_remain_cap[eligible_bins_mask]

    if np.sum(eligible_bins_mask) > 0:
        # Calculate the difference between bin capacity and item size
        # We want this difference to be small (i.e., a tight fit)
        differences = eligible_bins_capacities - item
        
        # Invert the differences to get priority. Smaller differences should have higher priority.
        # Add a small epsilon to avoid division by zero if a bin's remaining capacity
        # is exactly equal to the item's size.
        epsilon = 1e-9
        priorities[eligible_bins_mask] = 1.0 / (differences + epsilon)
        
        # Normalize priorities to have a maximum of 1 (optional, but can help in some scenarios)
        # max_priority = np.max(priorities[eligible_bins_mask])
        # if max_priority > 0:
        #     priorities[eligible_bins_mask] /= max_priority
            
    return priorities
```
