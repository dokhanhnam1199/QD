```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Worst Fit.

    Worst Fit strategy prioritizes bins that have the most remaining capacity,
    aiming to leave smaller gaps that might be harder to fill later.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # In Worst Fit, we want to choose the bin with the most remaining capacity.
    # However, we can only place the item if it fits.
    # A simple way to represent "highest priority" is to assign a score equal
    # to the remaining capacity, but only for bins that can accommodate the item.
    # For bins that cannot accommodate the item, the priority should be zero
    # or negative infinity to ensure they are not chosen.
    
    # Create a copy to avoid modifying the original array
    priorities = np.copy(bins_remain_cap)
    
    # Set priority to 0 for bins that cannot fit the item
    priorities[bins_remain_cap < item] = 0.0
    
    # The higher the remaining capacity, the higher the priority
    # We can optionally add a small constant to ensure positive priorities if needed,
    # or scale them if a specific range is desired, but for direct comparison,
    # remaining capacity works.
    
    # To make it more robust and less sensitive to the exact capacity values,
    # we can introduce a slight penalty for very large remaining capacities
    # which might encourage filling up bins more evenly if that's a secondary goal,
    # but for pure Worst Fit, the remaining capacity itself is the priority.
    # For this implementation, we stick to the core Worst Fit principle.
    
    return priorities
```
