```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using a refined "Almost Full Fit" strategy.

    This strategy prioritizes bins that offer the tightest fit for the item, meaning
    the remaining capacity after insertion is minimized. This is achieved by maximizing
    the negative of the slack (remaining_capacity - item_size).
    To also incorporate the "favoring fuller bins" aspect (i.e., preferring bins that
    were already closer to full before insertion), a secondary prioritization is
    applied: preferring bins with smaller initial remaining capacities.

    The combined priority is a weighted sum designed to maximize:
    -minimize(slack) - alpha * minimize(initial_remaining_capacity)
    This translates to maximizing:
    -slack - alpha * initial_remaining_capacity
    which is equivalent to:
    -(bins_remain_cap - item) - alpha * bins_remain_cap

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins where the item can fit
    fit_mask = bins_remain_cap >= item

    if not np.any(fit_mask):
        # If no bins can fit the item, return all zeros (no priority)
        return priorities

    # Calculate the slack for bins that can fit the item
    # slack = remaining_capacity - item_size
    slack = bins_remain_cap[fit_mask] - item

    # Primary criterion: Minimize slack (tight fit). Maximize -(slack).
    # Secondary criterion: Minimize initial remaining capacity (favor fuller bins). Maximize -(bins_remain_cap).
    # We combine them, giving slightly more weight to the tight fit.
    # The expression is: -slack - alpha * bins_remain_cap
    # This means we are maximizing: (item - bins_remain_cap) - alpha * bins_remain_cap
    # Or more directly, maximizing the negative of (slack + alpha * bins_remain_cap)

    alpha = 0.1  # Weight for the secondary criterion (smaller bins)

    # Calculate the combined priority for fitting bins
    # We want to maximize -(slack + alpha * bins_remain_cap[fit_mask])
    # This is equivalent to maximizing (item - bins_remain_cap[fit_mask]) - alpha * bins_remain_cap[fit_mask]
    # Let's rewrite to avoid confusion with maximization: we assign a score where higher is better.
    # High score = small slack AND small initial capacity.
    # Score = -slack - alpha * initial_capacity
    #       = -(bins_remain_cap[fit_mask] - item) - alpha * bins_remain_cap[fit_mask]
    #       = item - bins_remain_cap[fit_mask] - alpha * bins_remain_cap[fit_mask]

    # Let's try the simpler approach of maximizing the negative slack, and then using
    # the negative initial capacity as a tie-breaker.
    # Priority = -slack - alpha * bins_remain_cap[fit_mask]
    priorities[fit_mask] = -slack - alpha * bins_remain_cap[fit_mask]

    # Example: item = 3
    # bins_remain_cap = [5, 4, 7]
    # Bin 0: cap=5, slack=2. priority = -2 - 0.1*5 = -2.5
    # Bin 1: cap=4, slack=1. priority = -1 - 0.1*4 = -1.4
    # Bin 2: cap=7, slack=4. priority = -4 - 0.1*7 = -4.7

    # Bin 1 has the highest priority (-1.4), which is correct (tightest fit).
    # Bin 0 has the second highest priority (-2.5), which is also correct (smaller initial capacity than Bin 2, though slack is larger).
    # Bin 2 has the lowest priority (-4.7).

    # Example: item = 3
    # bins_remain_cap = [5, 5]
    # Bin 0: cap=5, slack=2. priority = -2 - 0.1*5 = -2.5
    # Bin 1: cap=5, slack=2. priority = -2 - 0.1*5 = -2.5
    # Tie. This is expected as both criteria are equal. The selection would be arbitrary between them.

    return priorities
```
