```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using the Almost Full Fit strategy.

    The strategy prioritizes bins that will be "almost full" after packing the item.
    A bin is considered "almost full" if its remaining capacity after packing the item
    is small. We want to maximize this small remaining capacity (i.e., minimize it).

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Calculate the remaining capacity if the item were placed in each bin
    potential_remain_cap = bins_remain_cap - item

    # We want to prioritize bins where potential_remain_cap is small.
    # However, we can only place items in bins where they fit.
    # So, for bins where the item doesn't fit, assign a very low priority (e.g., negative infinity)
    # to effectively exclude them from selection.
    # For bins where the item fits, the priority is higher if potential_remain_cap is smaller.
    # A simple way to achieve this is to take the negative of the potential remaining capacity.
    # This makes smaller positive remaining capacities result in larger (less negative) scores,
    # but we want to *minimize* remaining capacity.
    # A better approach for "almost full" is to consider the *inverse* or some function
    # that grows as remaining capacity shrinks towards zero.
    # For simplicity and to capture the "almost full" idea, let's prioritize bins that have
    # just enough space for the item, aiming for the smallest non-negative remaining capacity.

    # Initialize priorities to a very low value for bins that cannot accommodate the item
    priorities = np.full_like(bins_remain_cap, -np.inf)

    # Find indices of bins where the item fits
    fit_indices = np.where(bins_remain_cap >= item)[0]

    # For bins where the item fits, calculate the priority.
    # The "almost full" strategy aims to leave the smallest possible remaining capacity.
    # So, we want to maximize the negative of the remaining capacity after fitting.
    # This means a remaining capacity closer to 0 will have a higher priority score.
    if len(fit_indices) > 0:
        priorities[fit_indices] = -(bins_remain_cap[fit_indices] - item)

    # An alternative interpretation of "almost full fit" could be to favor bins
    # that become full (remaining capacity 0) or nearly full.
    # If we want to strictly favor bins that result in the *smallest positive* remaining capacity,
    # the above `-(bins_remain_cap[fit_indices] - item)` works.
    # If we want to slightly favor bins that are *already* close to full and can still take the item,
    # we could add a term related to the current remaining capacity.
    # For this specific problem statement, "Almost Full Fit" implies leaving minimal remainder.

    # To make it slightly more robust, we can consider a small penalty for bins that are
    # excessively large, to avoid filling up bins that could potentially hold larger items later.
    # However, the core "Almost Full Fit" is about minimizing leftover space.

    # Let's refine the priority to directly reflect "almost full".
    # We want to pick the bin that, after fitting the item, has the smallest remaining capacity,
    # but importantly, that remaining capacity should be non-negative.
    # If multiple bins have the same smallest remaining capacity, any selection is fine by this heuristic.

    # Re-calculate priorities: For fitting bins, priority is `1 / (1 + remaining_capacity_after_fit)`.
    # This maps smaller remaining capacities to higher priorities. Adding 1 prevents division by zero
    # if remaining capacity becomes exactly 0, and ensures a positive priority.
    if len(fit_indices) > 0:
        # Calculate remaining capacity for fitting bins
        remaining_after_fit = bins_remain_cap[fit_indices] - item
        # Assign priorities: higher for smaller remaining capacity
        # Using 1/(1+x) makes values closer to 1 for smaller x.
        priorities[fit_indices] = 1.0 / (1.0 + remaining_after_fit)

    # The -np.inf for non-fitting bins ensures they are never chosen.

    return priorities
```
