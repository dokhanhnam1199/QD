{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin using Best Fit strategy.\n\n    The Best Fit strategy aims to place the item into the bin where it leaves the\n    least amount of remaining capacity. This is achieved by prioritizing bins\n    that have just enough space for the item.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        A higher score indicates a higher priority. Bins that cannot fit the item\n        will have a priority of 0.\n    \"\"\"\n    # Calculate the remaining capacity if the item is placed in each bin.\n    # Only consider bins that have enough capacity to hold the item.\n    potential_remaining_cap = bins_remain_cap - item\n    \n    # Bins that cannot fit the item should have a priority of 0.\n    # We can achieve this by setting their priority to a very low negative value\n    # or by filtering them out. Here, we assign 0 priority to bins that cannot fit.\n    can_fit_mask = bins_remain_cap >= item\n    \n    # The Best Fit strategy prioritizes bins that result in the *smallest*\n    # positive remaining capacity. This means we want to minimize (bins_remain_cap - item).\n    # A higher priority should be given to smaller values of (bins_remain_cap - item).\n    # To map smaller (bins_remain_cap - item) to higher priorities, we can use\n    # the negative of these values, or a function that is inversely related.\n    #\n    # A common way to implement \"best fit\" is to calculate the \"waste\"\n    # (bins_remain_cap - item) and then select the bin with the minimum waste.\n    # For a priority function, we want the highest priority for the minimum waste.\n    #\n    # Consider the following:\n    # If we want to minimize `waste = bins_remain_cap - item`, then\n    # we want the largest `priority = -waste`.\n    #\n    # So, for bins where `can_fit_mask` is True, the priority is `-(bins_remain_cap - item)`.\n    # For bins where `can_fit_mask` is False, the priority is 0.\n    \n    priorities = np.zeros_like(bins_remain_cap)\n    \n    # For bins that can fit the item, calculate the priority.\n    # The priority is the negative of the remaining capacity after fitting the item.\n    # This ensures that bins with less remaining space (better fit) get higher priority.\n    # We invert the concept: smaller positive differences are better.\n    # `priorities = -(bins_remain_cap - item)` would work, but a slightly adjusted\n    # approach can be more robust if we want to differentiate more clearly between\n    # \"perfect fits\" and \"almost perfect fits\".\n    #\n    # A simple way to achieve \"best fit\" priority is to assign higher priority\n    # to the smallest positive difference.\n    # Let's assign priority as 1 / (1 + remaining_capacity_after_fit) for fitting bins.\n    # This maps smaller remaining capacities to larger priority values.\n    # Adding 1 in the denominator prevents division by zero and scales priorities.\n    \n    # We want to maximize `bins_remain_cap - item` to be as close to 0 as possible,\n    # for the bins that can fit the item.\n    # So, if `bins_remain_cap[i] >= item`, we want a high priority for small `bins_remain_cap[i] - item`.\n    # A good heuristic for this is to use `1.0 / (1.0 + (bins_remain_cap[i] - item))`\n    # This maps the smallest non-negative difference to the highest priority (close to 1).\n    # For example, if remaining cap is 10 and item is 7, difference is 3. Priority = 1/(1+3) = 0.25\n    # If remaining cap is 10 and item is 9, difference is 1. Priority = 1/(1+1) = 0.5\n    # If remaining cap is 10 and item is 10, difference is 0. Priority = 1/(1+0) = 1.0\n    \n    fitting_bins_remain_cap = bins_remain_cap[can_fit_mask]\n    \n    # Calculate the \"cost\" or \"waste\" for fitting bins\n    waste = fitting_bins_remain_cap - item\n    \n    # Assign priorities: higher priority for smaller waste.\n    # We use 1 / (1 + waste) to ensure priorities are between 0 and 1,\n    # and smaller waste gets a higher score.\n    priorities[can_fit_mask] = 1.0 / (1.0 + waste)\n    \n    # For bins that cannot fit the item, their priority remains 0,\n    # which means they will not be chosen if any bin can fit the item.\n    \n    return priorities\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin using a First Fit strategy with a preference for fuller bins.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Create a boolean mask for bins that can accommodate the item\n    can_fit_mask = bins_remain_cap >= item\n    \n    # For bins that can fit the item, calculate priority\n    # The priority is inversely related to the remaining capacity.\n    # Bins with less remaining capacity (i.e., are fuller) get higher priority.\n    # Add a small epsilon to avoid division by zero if a bin has exactly 'item' remaining capacity.\n    priorities[can_fit_mask] = 1.0 / (bins_remain_cap[can_fit_mask] - item + 1e-9)\n    \n    # Bins that cannot fit the item get a priority of 0 (or a very low negative number if desired for clear distinction)\n    # For this implementation, 0 is sufficient as it will not be chosen over any bin that can fit.\n    \n    return priorities\n\n[Reflection]\nPrioritize fuller bins for better packing density. Experiment with different priority calculations.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}