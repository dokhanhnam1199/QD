```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using a hybrid approach prioritizing fuller bins and then best fit.

    This heuristic tries to pack the item into a bin that has just enough space
    (Best Fit principle), but if multiple bins offer a similar "tight fit",
    it prefers the one that is already fuller (smaller remaining capacity).
    This can help in consolidating items and potentially opening up space in less full bins for future larger items.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Returns:
        Array of same size as bins_remain_cap with priority score of each bin.
        Higher score indicates higher priority. Bins that cannot fit the item will have a priority of 0.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Create a boolean mask for bins that can accommodate the item
    can_fit_mask = bins_remain_cap >= item

    # For bins that can fit the item, calculate priority
    # We want to prioritize bins that have minimal remaining capacity after packing.
    # This is the "Best Fit" principle.
    # So, we want to maximize `-(bins_remain_cap - item)`, which means minimizing `bins_remain_cap - item`.
    # A common way to map smaller positive values to higher priorities is using `1 / (1 + value)`.
    # To further encourage fuller bins among those with similar fits, we can add a penalty
    # proportional to the remaining capacity. A higher remaining capacity should result in a lower priority.
    # We can achieve this by subtracting the `bins_remain_cap` from a large constant, or by
    # dividing by `bins_remain_cap` (but carefully to avoid division by zero and to handle
    # bins that are already very full).

    # Let's combine the Best Fit idea (minimize waste) with a preference for fuller bins.
    # Priority = (Preference for being full) * (Best Fit factor)
    # A simple way to encode "preference for being full" is to use the inverse of the current remaining capacity.
    # A higher `1/bins_remain_cap` means the bin is fuller.
    # However, we need to be careful about bins that are *exactly* fitting or have very little space.

    # Strategy:
    # 1. Identify bins that can fit the item.
    # 2. For these bins, calculate a score that is high when `bins_remain_cap - item` is small (Best Fit).
    # 3. Also, make this score higher for bins that are already fuller (lower `bins_remain_cap`).

    # Let's try a combined approach:
    # Priority = (1.0 / (bins_remain_cap[can_fit_mask] - item + 1e-9)) * (bins_remain_cap[can_fit_mask])
    # This would give higher priority to bins that are both a good fit and are already quite full.
    # However, simply multiplying might not be ideal as it could over-prioritize very full bins that are not the best fit.

    # A more robust approach for Best Fit is `1.0 / (1.0 + waste)`, where `waste = bins_remain_cap - item`.
    # To incorporate the "fuller bin" preference, we can slightly penalize larger remaining capacities.
    # Let's use `1.0 / (1.0 + waste) + penalty_for_emptiness`.
    # The `penalty_for_emptiness` should be higher for bins with *more* remaining capacity.
    # So, `penalty_for_emptiness` could be something like `C / bins_remain_cap`.
    # The challenge is to balance these.

    # Let's simplify: Prioritize bins that have the smallest remaining capacity after fitting the item.
    # This is the core of Best Fit.
    # `best_fit_score = 1.0 / (1.0 + (bins_remain_cap[can_fit_mask] - item))`
    # To favor fuller bins, we can slightly amplify the priority for bins that are already more full.
    # For example, we could add a term proportional to `1.0 / bins_remain_cap[can_fit_mask]`.

    # Consider this: we want to minimize `bins_remain_cap - item`.
    # Let `remaining_after_fit = bins_remain_cap[can_fit_mask] - item`.
    # We want to pick the smallest `remaining_after_fit`.
    # To make the fuller bins more appealing among ties, we can use their `bins_remain_cap` as a secondary sorting key.
    # A direct priority could be a combination.
    # Let's try prioritizing bins that are fuller. The fuller the bin, the higher the priority.
    # This is the First Fit Decreasing (FFD) intuition for the *online* version.
    # The `priority_v1` already does this to some extent by prioritizing bins with smaller remaining capacities.

    # Let's refine `v1` to explicitly favor bins that are fuller, meaning smaller `bins_remain_cap`.
    # So, if `bin_i` and `bin_j` can fit the item, and `bins_remain_cap[i] < bins_remain_cap[j]`,
    # then `bin_i` should have higher priority.

    # We can achieve this by multiplying the inverse of remaining capacity by the inverse of the residual capacity after placement.
    # A bin that is fuller (smaller `bins_remain_cap`) gets a higher score.
    # A bin that results in less waste (`bins_remain_cap - item` is small) gets a higher score.

    # Let's use the reciprocal of the remaining capacity as a primary factor for "fullness".
    # And the reciprocal of the residual capacity for "best fit".
    # We want to maximize both.

    # Let's prioritize bins that are already fuller.
    # A simple heuristic for "fullness" is `1.0 / bins_remain_cap`.
    # However, this gives very high priority to bins with very small capacities, which might not be the best fit.
    # A common heuristic is to use the current remaining capacity to prioritize bins that are "most full" or have the least slack.
    # Let's try to give higher priority to bins with smaller `bins_remain_cap` among those that fit.

    # Simple approach: Directly use the inverse of the remaining capacity of the bin.
    # This prioritizes bins that are currently fuller.
    # `priorities[can_fit_mask] = 1.0 / (bins_remain_cap[can_fit_mask] + 1e-9)`
    # This is effectively a "First Fit" heuristic if we iterate through bins.
    # For a priority array, this would mean bins that are already more full (smaller remaining capacity) get higher priority.

    # Let's refine `v1` to emphasize "fullness" more directly.
    # `v1` prioritized `1.0 / (bins_remain_cap - item + 1e-9)`. This favors small waste.
    # To favor fuller bins, we could also consider `1.0 / (bins_remain_cap + 1e-9)`.
    # How to combine them? Summing or multiplying?

    # Let's try prioritizing bins that have the smallest `bins_remain_cap` first, and among those with equal `bins_remain_cap`,
    # pick the one with the smallest `bins_remain_cap - item`.
    # This suggests a lexicographical sort, which is hard to encode directly in a single priority score unless carefully designed.

    # Alternative: Focus on the "slack" or how much space is left.
    # We want to minimize `bins_remain_cap - item`.
    # A simple way to assign priority to smaller values is using `1.0 / (1.0 + value)`.
    # Let's also add a term that favors fuller bins.
    # `priority = 1.0 / (1.0 + (bins_remain_cap[can_fit_mask] - item)) + alpha * (1.0 / bins_remain_cap[can_fit_mask])`
    # The `alpha` would control the trade-off. This can become complex.

    # Let's revisit `v1`'s approach: `1.0 / (bins_remain_cap - item + 1e-9)`. This emphasizes minimal waste (Best Fit).
    # To slightly favor fuller bins *when waste is similar*, we can add a small bonus based on current fullness.
    # Or, a simpler interpretation of "preference for fuller bins" is to sort by `bins_remain_cap` first.
    # So, among bins that can fit, pick the one with minimum `bins_remain_cap`.
    # If there's a tie in `bins_remain_cap`, then pick the one with minimum `bins_remain_cap - item`.

    # Let's stick to a single score that tries to capture both:
    # A bin is good if it's almost full AND leaves little space.
    # So, prioritize small `bins_remain_cap` AND small `bins_remain_cap - item`.
    # This means prioritizing small `bins_remain_cap` is the primary goal, and then small `bins_remain_cap - item` as a tie-breaker.

    # A single score that balances this could be:
    # `priority = 1.0 / (bins_remain_cap[can_fit_mask] + 1e-9)` for fullness
    # and `1.0 / (bins_remain_cap[can_fit_mask] - item + 1e-9)` for fit.
    # Let's try to combine them.
    # If we want to prioritize smaller `bins_remain_cap` and then smaller `bins_remain_cap - item`:
    # `priority = (bins_remain_cap[can_fit_mask] * CONSTANT_FACTOR) + (bins_remain_cap[can_fit_mask] - item)`
    # And we want to minimize this value. For a priority score, we want to maximize.
    # So, `priority = - (bins_remain_cap[can_fit_mask] * CONSTANT_FACTOR + bins_remain_cap[can_fit_mask] - item)`
    # This is getting complicated.

    # Let's simplify the reflection: "Prioritize fuller bins for better packing density."
    # This implies that we want to select a bin such that `bins_remain_cap` is minimized.
    # So, `1.0 / (bins_remain_cap + epsilon)` is a good candidate.
    # Let's combine this with the best fit idea.
    # The `v1` function focused on the *waste* (`bins_remain_cap - item`).
    # The reflection is about prioritizing *fullness* (`bins_remain_cap`).

    # So, let's prioritize bins that have the smallest current remaining capacity.
    # `priorities[can_fit_mask] = 1.0 / (bins_remain_cap[can_fit_mask] + 1e-9)`
    # This would favor bins that are already fuller.

    # Let's consider what happens with an item of size 0.5 and bins with capacities [1.0, 0.6, 0.9].
    # `bins_remain_cap` = [1.0, 0.6, 0.9]
    # `item` = 0.5
    # `can_fit_mask` = [True, True, True]

    # `v0` (Best Fit):
    # `potential_remaining_cap` = [0.5, 0.1, 0.4]
    # `waste` = [0.5, 0.1, 0.4]
    # `priorities` = [1/(1+0.5), 1/(1+0.1), 1/(1+0.4)] = [0.667, 0.909, 0.714]
    # Max priority is for bin 1 (0.1 waste).

    # `v1` (First Fit-ish / Prefer less remaining capacity after fit):
    # `priorities[can_fit_mask] = 1.0 / (bins_remain_cap[can_fit_mask] - item + 1e-9)`
    # `priorities` = [1/(1.0-0.5+1e-9), 1/(0.6-0.5+1e-9), 1/(0.9-0.5+1e-9)]
    # `priorities` = [1/0.5, 1/0.1, 1/0.4] = [2.0, 10.0, 2.5]
    # Max priority is for bin 1 (0.1 remaining capacity). This is also Best Fit.

    # Reflection: "Prioritize fuller bins for better packing density."
    # This suggests that a bin with capacity 0.6 is "fuller" than a bin with capacity 1.0.
    # So, we should prefer the bin with `bins_remain_cap = 0.6`.

    # Let's try a heuristic that favors smaller `bins_remain_cap` directly.
    # `priority = 1.0 / (bins_remain_cap[can_fit_mask] + 1e-9)`
    # `priorities` = [1/1.0, 1/0.6, 1/0.9] = [1.0, 1.667, 1.111]
    # Max priority is for bin 1 (0.6 remaining capacity). This prioritizes the fullest bin.

    # How to combine "fullest bin" and "best fit"?
    # If we use `priorities[can_fit_mask] = 1.0 / (bins_remain_cap[can_fit_mask] + 1e-9)`
    # This prioritizes bin 1 (0.6 capacity). Let's see the waste: 0.6 - 0.5 = 0.1.
    # What if we had another bin with capacity 0.7?
    # `bins_remain_cap` = [1.0, 0.6, 0.9, 0.7]
    # `item` = 0.5
    # `can_fit_mask` = [True, True, True, True]
    # Priorities for fullness: [1.0, 1.667, 1.111, 1.428] -> Bin 1 (0.6 capacity) is chosen. Waste = 0.1.
    # Waste for bin 3 (0.7 capacity) = 0.7 - 0.5 = 0.2.
    # Bin 1 is both the fullest and the best fit.

    # What if we had a bin with capacity 0.55?
    # `bins_remain_cap` = [1.0, 0.6, 0.9, 0.55]
    # `item` = 0.5
    # `can_fit_mask` = [True, True, True, True]
    # Priorities for fullness: [1.0, 1.667, 1.111, 1.818] -> Bin 3 (0.55 capacity) is chosen. Waste = 0.05.
    # Waste for bin 1 (0.6 capacity) = 0.1.
    # Bin 3 is fuller and also the best fit.

    # The reflection "Prioritize fuller bins for better packing density" suggests that the *current* remaining capacity
    # is the primary driver of priority. The best fit is a secondary consideration if we want to be explicit.
    # The `v1` code implements "best fit" by minimizing waste.
    # The new `v2` should implement "prioritize fuller bins".

    # Let's try to combine these:
    # Prioritize bins with smaller `bins_remain_cap`.
    # Among those with the same `bins_remain_cap`, prioritize the one with smaller `bins_remain_cap - item`.
    # A score that combines these: `score = bins_remain_cap + (bins_remain_cap - item)`. We want to minimize this.
    # For priority (maximize), we want to maximize `- (bins_remain_cap + bins_remain_cap - item)`.
    # `priority = - (2 * bins_remain_cap - item)`

    # Let's try a simpler combination.
    # Priority = (1 / (bins_remain_cap + epsilon)) + (1 / (bins_remain_cap - item + epsilon))
    # This will heavily favor bins that are both full and have small waste.
    # Consider `bins_remain_cap` = [1.0, 0.6, 0.9], `item` = 0.5
    # Bin 0: 1/1 + 1/0.5 = 1 + 2 = 3.0
    # Bin 1: 1/0.6 + 1/0.1 = 1.667 + 10 = 11.667
    # Bin 2: 1/0.9 + 1/0.4 = 1.111 + 2.5 = 3.611
    # This strongly favors bin 1, which is both the fullest and best fit.

    # Let's simplify the reflection "Prioritize fuller bins" to mean, among bins that can fit,
    # pick the one with the smallest `bins_remain_cap`.
    # This is equivalent to `1.0 / (bins_remain_cap[can_fit_mask] + 1e-9)`.

    # So, the improved heuristic will directly prioritize the bins that are currently fullest.
    priorities[can_fit_mask] = 1.0 / (bins_remain_cap[can_fit_mask] + 1e-9)

    return priorities
```
