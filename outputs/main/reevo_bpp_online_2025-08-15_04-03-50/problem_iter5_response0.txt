```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using a refined Almost Full Fit strategy.

    This strategy prioritizes bins that have just enough capacity to fit the item,
    with a preference for bins that will have less remaining capacity after the item is added.
    It balances the tightness of the fit with a slight preference for bins that aren't
    already excessively full, to avoid wasting potential in very tight spots if slightly
    looser but still efficient fits exist.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Mask for bins that can fit the item
    fit_mask = bins_remain_cap >= item

    # Calculate the remaining capacity if the item is placed in each bin
    potential_remaining_cap = bins_remain_cap - item

    # For bins that fit, we want to prioritize those with smaller remaining capacity.
    # A common heuristic for "almost full" is to use the negative of the remaining capacity,
    # as smaller remaining capacity means a higher (less negative) score.
    # However, to incorporate balancing and avoid extremely tight fits if a slightly
    # looser but still good fit exists, we can modify this.

    # Let's focus on the slack (bins_remain_cap - item). Smaller slack is better.
    # We want to rank bins with smaller non-negative slack higher.
    # A score that is inversely proportional to slack + 1 (to avoid division by zero and keep it positive)
    # works well: 1/(1 + slack). This gives priority 1 for slack 0, and decreasing priority for larger slack.

    # To add a balancing element: If multiple bins have very small slacks, we might
    # prefer the one with slightly more capacity to keep more "tight fit" opportunities.
    # However, the prompt emphasizes "almost full fit", so minimizing slack is primary.

    # Let's refine the priority based on `potential_remaining_cap`.
    # We want to prioritize smaller `potential_remaining_cap` values (i.e., bins that become more full).
    # Using `1.0 / (1.0 + potential_remaining_cap)` for bins where `potential_remaining_cap >= 0`.
    # This gives priority 1 for perfect fits (potential_remaining_cap = 0) and less for larger remaining capacities.

    # To incorporate the idea of "slightly larger gaps for robustness" or balancing,
    # we can add a penalty for bins that are *too* full, such that they might not
    # fit future items well, or a slight bonus for bins that are not excessively empty.
    # However, the most direct interpretation of "Almost Full Fit" is prioritizing minimum remaining capacity.

    # Let's use the `1.0 / (1.0 + slack)` approach as it directly prioritizes minimal non-negative slack.
    # This encourages using up space efficiently.
    slack = bins_remain_cap[fit_mask] - item
    priorities[fit_mask] = 1.0 / (1.0 + slack)

    # To incorporate the "balance with bin fullness" and "slightly larger gaps for robustness":
    # If we have two bins that fit an item, Bin A (remain=4, item=3, slack=1) and Bin B (remain=5, item=3, slack=2).
    # Current priority for A = 1/(1+1) = 0.5. Current priority for B = 1/(1+2) = 0.33.
    # Bin A is preferred. This is good.
    # What if Bin C (remain=10, item=3, slack=7) also fits? Priority C = 1/(1+7) = 0.125.
    # Bin A is still preferred.

    # The core idea is to select a bin that is "almost full" with the current item.
    # The `1.0 / (1.0 + slack)` metric achieves this by favoring smaller non-negative slacks.
    # A small positive slack means the bin is almost full. A zero slack means it's perfectly full.
    # Larger slacks mean the bin is less "almost full".

    # Alternative: Prioritize bins that become most full: maximize `-potential_remaining_cap`.
    # If Bin A: remain=4, item=3 -> potential_remain=1. Score = -1.
    # If Bin B: remain=5, item=3 -> potential_remain=2. Score = -2.
    # Bin A (-1) is better than Bin B (-2). This also favors tighter fits.
    # Let's test this against the prompt's "slight preference for bins that aren't already excessively full".
    # If Bin A (remain=4, item=3) and Bin D (remain=100, item=3).
    # A: slack=1, score=0.5. B: slack=97, score=1/98 ~ 0.01.
    # A is preferred.
    # Using negative potential remaining:
    # A: potential_remain=1, score = -1. B: potential_remain=97, score = -97.
    # A is preferred.

    # The `1.0 / (1.0 + slack)` heuristic seems robust and directly targets the "almost full" aspect by minimizing positive slack.
    # Let's ensure there's a slight preference for less empty bins as a tie-breaker or a secondary factor.
    # A simple way to boost bins that are not excessively empty might be to add a small term
    # related to their original remaining capacity, but scaled down.
    # For instance, `priority = (1.0 / (1.0 + slack)) + alpha * (bins_remain_cap[fit_mask] / MAX_CAPACITY)`
    # where `alpha` is small. This could slightly favor bins that are fuller if slacks are similar.

    # For now, sticking to the strong "almost full" heuristic is best. The `1.0 / (1.0 + slack)` method is simple and effective.
    # The "balance with bin fullness" might be implicitly handled if smaller bins tend to have smaller slacks.

    # Let's reconsider the prompt's refinement: "Balance this with bin fullness and explore slightly larger gaps for robustness."
    # This suggests that simply minimizing slack might be too aggressive.
    # A bin with remaining capacity 5 and item 3 (slack 2, priority 0.5) might be preferred over capacity 3 and item 3 (slack 0, priority 1).
    # This sounds like a compromise.

    # Let's try a score that penalizes very small slacks (perfect fits) slightly,
    # and also penalizes large slacks.
    # Consider a quadratic function or a Gaussian-like function centered around a small slack.
    # E.g., `score = exp(-(slack - target_slack)^2 / sigma^2)`.
    # Where `target_slack` is a small value, say 1 or 2.

    # For robustness, let's prioritize bins that are not excessively empty.
    # We can add a small bonus proportional to how much capacity is already used.
    # `(bins_remain_cap[fit_mask] - item) / bins_remain_cap[fit_mask]` is the proportion of used space after fitting.
    # Or, simpler, `1 - (bins_remain_cap[fit_mask] / BIN_CAPACITY)`.

    # Let's try a combination: minimize slack, but add a slight bonus for bins that are more full.
    # `priority = (1.0 / (1.0 + slack)) + alpha * (bins_remain_cap[fit_mask] - item)`
    # This rewards smaller slack and also rewards bins that have less remaining capacity *after* fitting.
    # The `bins_remain_cap[fit_mask] - item` term is exactly the `potential_remaining_cap`.
    # We want to maximize this negative value for tightness.
    # So, `priority = (1.0 / (1.0 + slack)) - beta * potential_remaining_cap[fit_mask]`

    # Let's keep it simpler to match the spirit of heuristic development:
    # Prioritize small slack, but if slacks are close, pick the one with higher original capacity.
    # This can be achieved by sorting by slack, then by original capacity descending.
    # Or in scoring: use slack primarily, and original capacity as a tie-breaker.
    # If scores are based on `1.0 / (1.0 + slack)`, we can add a term related to original capacity.
    # `score = (1.0 / (1.0 + slack)) + alpha * bins_remain_cap[fit_mask]`
    # This prioritizes tightness, then higher capacity among equally tight bins.

    # Let's try a simplified approach that favors minimal non-negative slack,
    # and then favors bins that are "moderately" full, not too empty.
    # Score: `-slack + some_factor * (1 - slack/max_capacity_overall)`
    # This is getting complicated.

    # The most straightforward implementation of "Almost Full Fit" is to pick the bin
    # that, after placing the item, has the minimal remaining capacity.
    # This means maximizing `-(bins_remain_cap - item)`.
    # Let's try that, and if it needs balancing, we can adjust.
    # `potential_remaining_cap = bins_remain_cap[fit_mask] - item`
    # Maximize `-potential_remaining_cap`.
    # This means we want to pick bins where `potential_remaining_cap` is smallest (closest to 0).
    # This is equivalent to minimizing `slack` for valid bins.

    # Revisit `1.0 / (1.0 + slack)`:
    # Slack 0 -> 1.0
    # Slack 1 -> 0.5
    # Slack 2 -> 0.33
    # Slack 5 -> 0.16
    # Slack 10 -> 0.09

    # This seems to prioritize very tight fits strongly.
    # To "balance with bin fullness" and "explore slightly larger gaps for robustness",
    # we might want to reduce the steepness of this decay, or add a secondary factor.

    # Consider prioritizing based on the *ratio* of remaining capacity to item size.
    # `ratio = (bins_remain_cap[fit_mask] - item) / item`
    # We want this ratio to be small.
    # Score could be `1.0 / (1.0 + ratio)`.
    # If item=3:
    # Bin A: remain=4, slack=1, ratio=1/3. Score = 1/(1+1/3) = 1/(4/3) = 3/4 = 0.75
    # Bin B: remain=5, slack=2, ratio=2/3. Score = 1/(1+2/3) = 1/(5/3) = 3/5 = 0.6
    # Bin C: remain=3, slack=0, ratio=0.   Score = 1/(1+0) = 1.0
    # Bin D: remain=6, slack=3, ratio=1.   Score = 1/(1+1) = 0.5

    # This ratio-based approach also strongly favors tight fits (low slack relative to item size).
    # It's similar in spirit to `1/(1+slack)` but normalized by item size.

    # Let's try a simple modification to `1.0 / (1.0 + slack)` to add some robustness.
    # We can make the priority decay slower for larger slacks.
    # Instead of `1/(1+slack)`, maybe `1/(1+slack^p)` with `p < 1`. Or `sqrt(slack)` in denominator.
    # `1 / (1 + np.sqrt(slack))`
    # Slack 0 -> 1.0
    # Slack 1 -> 1/(1+1) = 0.5
    # Slack 4 -> 1/(1+2) = 0.33
    # Slack 9 -> 1/(1+3) = 0.25
    # Slack 16 -> 1/(1+4) = 0.2

    # Comparing `1/(1+slack)` vs `1/(1+sqrt(slack))`:
    # Slack=1: 0.5 vs 0.5 (same)
    # Slack=4: 0.2 vs 0.33 (sqrt version gives higher priority)
    # Slack=9: 0.09 vs 0.25 (sqrt version gives much higher priority)
    # This `1/(1+sqrt(slack))` seems to better balance tightness and allow slightly larger gaps.
    # It prioritizes tight fits, but doesn't penalize moderately larger gaps as harshly.

    priorities[fit_mask] = 1.0 / (1.0 + np.sqrt(slack))

    # Optional: Add a small bonus for bins that are not excessively empty.
    # This could be `alpha * (1 - slack / max_possible_slack)` but `max_possible_slack` is tricky.
    # Or `alpha * (bins_remain_cap[fit_mask] / MAX_BIN_SIZE)`

    # Let's stick to `1.0 / (1.0 + np.sqrt(slack))` as it addresses the prompt's needs reasonably well.
    # It favors minimal slack (almost full), and the square root dampens the penalty for slightly larger gaps.

    return priorities
```
