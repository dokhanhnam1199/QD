```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using a modified Best Fit Decreasing heuristic.

    This heuristic prioritizes bins that can fit the item. Among the bins that can fit,
    it assigns a higher priority to bins where the remaining capacity is closest to the item size
    (i.e., the "tightest fit"). This is achieved by assigning a priority score that is the
    inverse of the absolute difference between the bin's remaining capacity and the item size.
    Bins that cannot accommodate the item are assigned a priority of 0.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Returns:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Identify bins that have enough remaining capacity for the item
    can_fit_mask = bins_remain_cap >= item

    # Initialize priorities to zero for all bins. Bins that cannot fit will retain a priority of 0.
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Calculate priorities only for bins that can fit the item
    if np.any(can_fit_mask):
        # Calculate the absolute difference between the remaining capacity and the item size for fitting bins.
        # We want to prioritize bins where this difference is minimized (tightest fit).
        diff = bins_remain_cap[can_fit_mask] - item

        # Assign a priority score that is inversely proportional to the absolute difference.
        # A smaller absolute difference means a tighter fit, hence a higher priority.
        # We use `1.0 / (1.0 + abs(diff))` to ensure:
        # 1. Division by zero is avoided (by adding 1.0).
        # 2. A perfect fit (diff = 0) gets the highest possible priority (1.0).
        # 3. As the difference increases, the priority decreases.
        priorities[can_fit_mask] = 1.0 / (1.0 + np.abs(diff))

    return priorities
```
