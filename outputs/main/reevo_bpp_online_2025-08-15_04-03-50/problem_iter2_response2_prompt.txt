{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin using the Almost Full Fit strategy.\n\n    The strategy prioritizes bins that will be \"almost full\" after packing the item.\n    A bin is considered \"almost full\" if its remaining capacity after packing the item\n    is small. We want to maximize this small remaining capacity (i.e., minimize it).\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity if the item were placed in each bin\n    potential_remain_cap = bins_remain_cap - item\n\n    # We want to prioritize bins where potential_remain_cap is small.\n    # However, we can only place items in bins where they fit.\n    # So, for bins where the item doesn't fit, assign a very low priority (e.g., negative infinity)\n    # to effectively exclude them from selection.\n    # For bins where the item fits, the priority is higher if potential_remain_cap is smaller.\n    # A simple way to achieve this is to take the negative of the potential remaining capacity.\n    # This makes smaller positive remaining capacities result in larger (less negative) scores,\n    # but we want to *minimize* remaining capacity.\n    # A better approach for \"almost full\" is to consider the *inverse* or some function\n    # that grows as remaining capacity shrinks towards zero.\n    # For simplicity and to capture the \"almost full\" idea, let's prioritize bins that have\n    # just enough space for the item, aiming for the smallest non-negative remaining capacity.\n\n    # Initialize priorities to a very low value for bins that cannot accommodate the item\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    # Find indices of bins where the item fits\n    fit_indices = np.where(bins_remain_cap >= item)[0]\n\n    # For bins where the item fits, calculate the priority.\n    # The \"almost full\" strategy aims to leave the smallest possible remaining capacity.\n    # So, we want to maximize the negative of the remaining capacity after fitting.\n    # This means a remaining capacity closer to 0 will have a higher priority score.\n    if len(fit_indices) > 0:\n        priorities[fit_indices] = -(bins_remain_cap[fit_indices] - item)\n\n    # An alternative interpretation of \"almost full fit\" could be to favor bins\n    # that become full (remaining capacity 0) or nearly full.\n    # If we want to strictly favor bins that result in the *smallest positive* remaining capacity,\n    # the above `-(bins_remain_cap[fit_indices] - item)` works.\n    # If we want to slightly favor bins that are *already* close to full and can still take the item,\n    # we could add a term related to the current remaining capacity.\n    # For this specific problem statement, \"Almost Full Fit\" implies leaving minimal remainder.\n\n    # To make it slightly more robust, we can consider a small penalty for bins that are\n    # excessively large, to avoid filling up bins that could potentially hold larger items later.\n    # However, the core \"Almost Full Fit\" is about minimizing leftover space.\n\n    # Let's refine the priority to directly reflect \"almost full\".\n    # We want to pick the bin that, after fitting the item, has the smallest remaining capacity,\n    # but importantly, that remaining capacity should be non-negative.\n    # If multiple bins have the same smallest remaining capacity, any selection is fine by this heuristic.\n\n    # Re-calculate priorities: For fitting bins, priority is `1 / (1 + remaining_capacity_after_fit)`.\n    # This maps smaller remaining capacities to higher priorities. Adding 1 prevents division by zero\n    # if remaining capacity becomes exactly 0, and ensures a positive priority.\n    if len(fit_indices) > 0:\n        # Calculate remaining capacity for fitting bins\n        remaining_after_fit = bins_remain_cap[fit_indices] - item\n        # Assign priorities: higher for smaller remaining capacity\n        # Using 1/(1+x) makes values closer to 1 for smaller x.\n        priorities[fit_indices] = 1.0 / (1.0 + remaining_after_fit)\n\n    # The -np.inf for non-fitting bins ensures they are never chosen.\n\n    return priorities\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin using Almost Full Fit.\n\n    Almost Full Fit (AFF) is a heuristic for the bin packing problem.\n    The idea behind AFF is to pack the current item into the bin that has\n    just enough remaining capacity to hold the item, or the bin that has the\n    smallest remaining capacity among those that can hold the item. This\n    tends to leave larger gaps in other bins for future, potentially larger items.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Higher priority is given to bins that are almost full (i.e., have a small\n        remaining capacity that is still sufficient for the item).\n    \"\"\"\n    # Initialize priorities to a very low value for bins that cannot accommodate the item\n    # and a base priority for bins that can.\n    # We want to prioritize bins that leave the smallest gap after packing.\n    # The gap is bins_remain_cap - item.\n    # So, we want to minimize this gap.\n    # A simple way to prioritize is to assign a higher score to smaller positive gaps.\n\n    # Identify bins that can accommodate the item\n    can_accommodate_mask = bins_remain_cap >= item\n\n    # For bins that can accommodate the item, calculate the \"tightness\" or remaining capacity.\n    # The tighter the fit (smaller remaining capacity after packing), the higher the priority.\n    # We want to sort bins by remaining_capacity - item.\n    # However, directly using remaining_capacity - item might lead to issues if we just\n    # want to assign high values to \"almost full\".\n    # Let's define priority as the inverse of the remaining capacity after packing,\n    # but only for bins that can fit the item.\n\n    # A good strategy for AFF would be to give the highest priority to the bin\n    # where (bin_capacity - item) is minimized.\n    # If multiple bins have the same minimum difference, we can break ties by\n    # selecting the bin with the smallest index or some other arbitrary but consistent method.\n\n    # Let's create a priority score where a smaller remaining capacity (after packing)\n    # results in a higher priority.\n    # The difference is bins_remain_cap[i] - item.\n    # We want to prioritize smaller positive differences.\n    # We can achieve this by using the negative of the difference.\n    # However, this still needs to be non-positive for bins that *cannot* fit the item.\n\n    priorities = np.full_like(bins_remain_cap, -np.inf)  # Initialize with a very low priority\n\n    # Calculate the remaining capacity after placing the item in eligible bins\n    remaining_after_packing = bins_remain_cap[can_accommodate_mask] - item\n\n    # For AFF, we want the smallest positive difference.\n    # So, we can assign a priority score based on this difference.\n    # A common way to ensure higher values are preferred is to use negative values\n    # and then take the negative, or simply sort in reverse.\n    # Let's assign priorities such that the smallest positive (bins_remain_cap - item)\n    # gets the highest priority.\n    # We can achieve this by using the negative of the remaining capacity after packing.\n    # Or more simply, the remaining capacity itself, and then we'd look for the minimum among positive values.\n\n    # Let's try a score where a bin that *exactly* fits gets the highest priority,\n    # and bins that have a slightly larger remaining capacity get slightly lower priority.\n    # This suggests a function that is high when (bins_remain_cap - item) is small and positive.\n\n    # Calculate the difference (gap) for eligible bins.\n    gaps = bins_remain_cap[can_accommodate_mask] - item\n\n    # To prioritize the smallest positive gap, we can assign priorities like:\n    # If gap == 0, priority = infinity (or a very large number).\n    # If gap > 0, priority = 1 / gap.\n    # This might be problematic with floating point precision.\n\n    # A simpler approach: assign priority based on the negative of the gap.\n    # The smallest gap will have the largest negative value (closest to zero).\n    # This still requires careful handling of negative gaps (bins that can't fit).\n\n    # Let's try a more direct interpretation of AFF: find the bin with the smallest\n    # `bins_remain_cap` that is still greater than or equal to `item`.\n    # We can achieve this by assigning a \"priority\" score where the minimum `bins_remain_cap`\n    # (among those >= item) gets the highest score.\n    # A score of `-bins_remain_cap` would naturally prioritize smaller remaining capacities.\n    # For bins that *cannot* fit, we assign a very low score.\n\n    priorities[can_accommodate_mask] = -bins_remain_cap[can_accommodate_mask]\n\n    # Another common way to implement \"smallest remaining capacity\" priority is to\n    # give a high priority to bins that are \"closest\" to fitting the item without going over.\n    # This means bins with `bins_remain_cap - item` closest to 0 (and positive).\n    # A simple way to get this behavior: if a bin can fit, assign a priority inversely proportional\n    # to its remaining capacity *after* the item is placed.\n\n    # Let's use the remaining capacity after placement as the basis.\n    # We want to MINIMIZE this remaining capacity.\n    # So, a smaller value should correspond to a higher priority.\n    # Using `-bins_remain_cap + item` directly gives the negative of the gap.\n    # The bin with the smallest positive gap will have the least negative value.\n\n    # For bins that can accommodate the item:\n    # The priority should be higher for bins with smaller remaining capacity.\n    # So, we want to maximize `bins_remain_cap - item` when `bins_remain_cap - item` is small.\n    # Or, we want to minimize `bins_remain_cap` among eligible bins.\n\n    # Let's assign a score based on the negative of the bin's remaining capacity.\n    # The largest negative value (closest to 0) will correspond to the smallest capacity.\n    # For bins that can accommodate the item, we assign a score of `-bins_remain_cap`.\n    # This implicitly prioritizes bins with smaller remaining capacities.\n\n    # Consider the case where multiple bins have the same minimal remaining capacity.\n    # AFF typically means selecting *one* such bin. Our scoring mechanism would\n    # give them equal scores. A tie-breaking rule would be needed in the selection logic,\n    # but the priority function just needs to assign comparable scores.\n\n    # A simple and effective priority for AFF could be:\n    # For bins that can fit the item, assign a priority based on their current remaining capacity.\n    # The lower the remaining capacity, the higher the priority.\n    # So, priority = -bins_remain_cap.\n    # For bins that cannot fit, assign a very low priority (-infinity).\n\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n    eligible_bins_indices = np.where(bins_remain_cap >= item)[0]\n\n    if eligible_bins_indices.size > 0:\n        # Assign a priority score such that smaller remaining capacities get higher scores.\n        # Using the negative of the remaining capacity works well:\n        # e.g., if remaining caps are [5, 3, 8] and item is 2,\n        # eligible caps are [5, 3, 8]. Scores would be [-5, -3, -8].\n        # The max score is -3, which corresponds to the bin with remaining cap 3.\n        priorities[eligible_bins_indices] = -bins_remain_cap[eligible_bins_indices]\n\n    return priorities\n\n[Reflection]\nFocus on precisely defining the \"almost full\" metric and its relationship to priority.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}