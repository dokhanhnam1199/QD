```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using a refined Almost Full Fit strategy.

    This strategy prioritizes bins that provide the "tightest fit" for the item,
    meaning the remaining capacity after insertion is minimized. This is achieved
    by maximizing `1.0 / (1.0 + slack)`, where slack is `remaining_capacity - item_size`.
    Additionally, it introduces a secondary preference for bins that are already
    "fuller" (i.e., have less initial remaining capacity) among those offering similar
    tight fits, to promote more balanced packing. The weight of the secondary
    criterion is tuned to balance the two objectives.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins where the item can fit
    fit_mask = bins_remain_cap >= item

    if not np.any(fit_mask):
        return priorities

    # Calculate the slack for bins that can fit the item
    # Slack = remaining_capacity - item_size
    slack = bins_remain_cap[fit_mask] - item

    # Primary scoring: Prioritize minimal slack (tightest fits).
    # Use `1.0 / (1.0 + slack)`: higher score for smaller slack.
    # A slack of 0 gives priority 1.0.
    primary_score = 1.0 / (1.0 + slack)

    # Secondary scoring: Among bins with similar slacks, prioritize those that are
    # "fuller" initially. This means preferring bins with smaller original `bins_remain_cap`.
    # We add a term proportional to the negative of the initial remaining capacity.
    # The coefficient `alpha` is tuned to balance the primary and secondary criteria.
    # A smaller alpha means the "fuller bin" preference has less impact.
    alpha = 0.05  # Tuned parameter
    secondary_score = -alpha * bins_remain_cap[fit_mask]

    # Combine scores: maximize primary score, then secondary score
    priorities[fit_mask] = primary_score + secondary_score

    return priorities
```
