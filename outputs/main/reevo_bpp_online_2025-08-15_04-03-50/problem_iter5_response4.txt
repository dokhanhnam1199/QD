```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using a refined Almost Full Fit strategy.

    This strategy prioritizes bins that have just enough capacity to fit the item,
    with a preference for bins that will have less remaining capacity after the item is added.
    It balances tight fits with a slight preference for bins that are not excessively large,
    even if they could accommodate the item.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Calculate the remaining capacity if the item is placed in each bin
    potential_remaining_cap = bins_remain_cap - item

    # Identify bins where the item can fit
    fit_mask = bins_remain_cap >= item

    # For bins that can fit the item, calculate their priority.
    # The core idea of "Almost Full Fit" is to minimize the remaining capacity *after* placing the item.
    # This means we want to prioritize bins where `potential_remaining_cap` is minimal and non-negative.
    # A common heuristic for this is to use the inverse of `potential_remaining_cap` + epsilon.
    # Using `1.0 / (1.0 + slack)` where slack = `potential_remaining_cap` is a good approach.
    # It gives higher priority to smaller non-negative slacks (closer to 0).

    # Calculate slack for bins that can fit the item
    slack = potential_remaining_cap[fit_mask]

    # Assign priority: Higher priority for smaller slack.
    # The term `1.0 + slack` ensures that:
    # 1. For a perfect fit (slack=0), priority is 1.0.
    # 2. For small positive slacks, priority is high but less than 1.0.
    # 3. For larger slacks, priority decreases.
    # This prioritizes bins that become "most full" after adding the item.
    priorities[fit_mask] = 1.0 / (1.0 + slack)

    # To add robustness and avoid bins that are excessively large being chosen just because
    # they might have a small negative `potential_remaining_cap` (if we were considering them),
    # or even a small positive `slack` but still have a lot of original capacity,
    # we can introduce a secondary factor that slightly penalizes bins with very large initial remaining capacity.
    # This helps in ensuring that we don't "waste" large bins on items that could fit in smaller ones,
    # while still prioritizing tight fits.
    # A simple way to do this is to slightly decrease the priority for bins that have a large initial capacity.
    # However, the primary driver should be the "almost full" characteristic after insertion.

    # A common refinement is to use a function that is steep for small slacks and flattens out.
    # The current `1.0 / (1.0 + slack)` achieves this.

    # Let's consider the "balance this with bin fullness" part of the reflection.
    # This might mean we don't want to pick a bin that's *too* empty, unless it's the only option.
    # However, the primary goal is "almost full fit".
    # The current heuristic `1.0 / (1.0 + slack)` strongly favors minimum slack.

    # To balance minimal remaining capacity with bin fullness and explore slightly larger gaps:
    # We want to prioritize small non-negative `potential_remaining_cap`.
    # Let's consider a score that is higher for smaller `potential_remaining_cap`.
    # And, for bins that have very large `potential_remaining_cap`, we can give them a slightly
    # lower priority relative to their slack, to favor moderately sized bins.

    # A simple approach for "slightly larger gaps":
    # Consider the ratio of the item size to the bin's original capacity.
    # `item / bins_remain_cap[fit_mask]`
    # This ratio is higher for bins that are smaller relative to the item.
    # We want to combine this with minimal slack.

    # Let's refine the priority calculation.
    # We want to maximize `1 / (1 + slack)`.
    # To "balance with bin fullness" (or consider slightly larger gaps as a secondary preference if slack is similar),
    # we can modify the score.

    # Option 1: Prioritize minimal slack, then largest capacity among those with minimal slack.
    # This is hard to do directly in a single priority score.

    # Option 2: A score that favors minimal slack, but not too aggressively if the bin is very large.
    # Consider `(1.0 / (1.0 + slack)) * (item / bins_remain_cap[fit_mask])` - this would favor
    # smaller ratios, which means smaller bins for the item, but might conflict with minimal slack.

    # Let's stick to the "almost full" and "tight fit" principle:
    # The current `1.0 / (1.0 + slack)` is a strong candidate for "tight fits".
    # The "balance this with bin fullness" might suggest avoiding picking a bin
    # that, after packing, is still *very* empty, even if its slack is minimal compared to other bins.
    # Example: Bin A (cap 100), item 98 -> slack 2, priority ~ 1/3. Bin B (cap 5), item 3 -> slack 2, priority ~ 1/3.
    # The current heuristic would give them equal priority. If we want to favor Bin B (more filled relative to its capacity),
    # we might introduce a term related to `item / original_capacity`.

    # Let's consider a hybrid approach:
    # Primary factor: Minimal slack (for "almost full").
    # Secondary factor: Larger ratio of `item / (original_capacity_before_item_added)`
    # to favor bins that are more utilized by this item.

    # `original_capacity_before_item_added` = `bins_remain_cap[fit_mask]`
    # So, we want to maximize `1.0 / (1.0 + slack)` AND maximize `item / bins_remain_cap[fit_mask]`.
    # We can combine these multiplicatively.

    # Let's try: `priority = (1.0 / (1.0 + slack)) * (item / bins_remain_cap[fit_mask])`
    # For slack=0 (perfect fit): priority = `1.0 * (item / bins_remain_cap[fit_mask])`
    # This would favor a perfect fit in a smaller bin.

    # Example with this new approach:
    # Item = 3
    # Bin A: bins_remain_cap=5. Slack = 2. Ratio = 3/5 = 0.6. Priority = (1/3) * 0.6 = 0.2
    # Bin B: bins_remain_cap=4. Slack = 1. Ratio = 3/4 = 0.75. Priority = (1/2) * 0.75 = 0.375
    # Bin C: bins_remain_cap=3. Slack = 0. Ratio = 3/3 = 1.0. Priority = (1/1) * 1.0 = 1.0
    # Bin D: bins_remain_cap=2. No fit. Priority = 0.
    # Bin E: bins_remain_cap=6. Slack = 3. Ratio = 3/6 = 0.5. Priority = (1/4) * 0.5 = 0.125

    # This seems to better capture "tight fits" (from slack) and also "balancing with bin fullness"
    # by favoring bins that are more utilized by the current item (from the ratio).
    # "Explore slightly larger gaps for robustness" is subjective, but this might pick
    # a bin that's not *perfectly* the tightest, if it offers a better overall utilization ratio.

    # Let's implement this refined heuristic.
    # We need to be careful if `bins_remain_cap[fit_mask]` is zero or very small, but
    # `fit_mask` already ensures `bins_remain_cap[fit_mask] >= item`, and we assume item > 0.
    # So, `bins_remain_cap[fit_mask]` will be at least `item`, which is positive.

    original_caps_fitting = bins_remain_cap[fit_mask]
    utilization_ratio = item / original_caps_fitting

    # Combine slack-based priority and utilization ratio.
    # Higher priority for smaller slack AND higher utilization ratio.
    # Using `1.0 / (1.0 + slack)` for minimal slack.
    # Using `utilization_ratio` for better utilization.
    # Multiplying them together:
    priorities[fit_mask] = (1.0 / (1.0 + slack)) * utilization_ratio

    # Consider edge case: if `item` is very close to `original_caps_fitting`,
    # slack is close to 0, ratio is close to 1. This gives high priority.
    # If `item` is much smaller than `original_caps_fitting`, slack is large, ratio is small.
    # This seems to align with the desired properties.

    return priorities
```
