{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin using a hybrid strategy.\n\n    This strategy combines a \"Best Fit\" approach (prioritizing bins that leave minimal\n    remaining capacity after packing) with a \"Worst Fit\" element (prioritizing bins\n    with more remaining capacity to encourage spreading items). It also incorporates\n    a small probability of choosing a random bin to escape local optima.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    exploration_prob = 0.05  # Probability of exploring (choosing a random fittable bin)\n    n_bins = len(bins_remain_cap)\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Identify bins that can fit the item\n    fittable_bins_mask = bins_remain_cap >= item\n\n    if not np.any(fittable_bins_mask):\n        # If no bin can fit the item, return all zeros.\n        return priorities\n\n    # Calculate scores for fittable bins\n    fittable_bins_indices = np.where(fittable_bins_mask)[0]\n    fittable_bins_capacities = bins_remain_cap[fittable_bins_mask]\n\n    # Hybrid scoring:\n    # 1. Best Fit component: Prioritize bins where (capacity - item) is minimized.\n    #    We use 1 / (difference + epsilon) for this.\n    epsilon = 1e-9\n    best_fit_scores = 1.0 / (fittable_bins_capacities - item + epsilon)\n\n    # 2. Worst Fit component: Prioritize bins with larger remaining capacity.\n    #    We can use the capacity itself or a scaled version. Here, we'll use\n    #    the capacity directly as a secondary scoring factor.\n    worst_fit_scores = fittable_bins_capacities\n\n    # Combine scores: A simple linear combination. You can tune weights.\n    # Here, we give slightly more weight to the \"best fit\" aspect.\n    combined_scores = 0.7 * best_fit_scores + 0.3 * worst_fit_scores\n\n    # Assign combined scores to priorities for fittable bins\n    priorities[fittable_bins_mask] = combined_scores\n\n    # Apply exploration: With a small probability, pick a random fittable bin.\n    if np.random.rand() < exploration_prob:\n        random_fittable_index_in_fittable_array = np.random.randint(len(fittable_bins_indices))\n        chosen_bin_global_index = fittable_bins_indices[random_fittable_index_in_fittable_array]\n\n        # Reset priorities and set the randomly chosen bin's priority to 1\n        priorities = np.zeros_like(bins_remain_cap, dtype=float)\n        priorities[chosen_bin_global_index] = 1.0\n    else:\n        # Normalize priorities to sum to 1 if we are not exploring randomly\n        if np.sum(priorities[fittable_bins_mask]) > 0:\n            priorities[fittable_bins_mask] /= np.sum(priorities[fittable_bins_mask])\n\n    return priorities\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin using a strategy that prioritizes bins that have *just enough* space, and among those, favors fuller bins.\n\n    This strategy is a variation of Best Fit, aiming to minimize wasted space.\n    It prioritizes bins where `bins_remain_cap - item` is smallest and non-negative.\n    A secondary preference is given to bins that are fuller (have less remaining capacity)\n    among those that can fit the item.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        A higher score indicates a higher priority. Bins that cannot fit the item\n        will have a priority of 0.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Create a boolean mask for bins that can accommodate the item\n    can_fit_mask = bins_remain_cap >= item\n\n    # For bins that can fit the item, calculate the \"slack\" or \"waste\"\n    # This is the remaining capacity after placing the item.\n    slack = bins_remain_cap[can_fit_mask] - item\n\n    # To prioritize bins with the least slack (best fit), we can use the\n    # inverse of slack. A smaller slack should result in a higher priority.\n    # Add a small epsilon to avoid division by zero if slack is 0.\n    # Higher priority for smaller slack values.\n    # We can use `1.0 / (slack + epsilon)` or `-slack`.\n    # Using `-slack` directly favors bins with minimal non-negative slack.\n    # For example, slack of 0 gets priority 0, slack of 1 gets -1, slack of 5 gets -5.\n    # We want to maximize this value, so we use `-slack`.\n\n    # To incorporate the preference for fuller bins (which is implied by smaller\n    # `bins_remain_cap` among fitting bins), we can combine this with the slack.\n    # A simple approach is to subtract the original remaining capacity from the\n    # inverse slack, or simply use a combination.\n\n    # Let's prioritize bins with minimal slack.\n    # If slack is 0, priority should be highest.\n    # If slack is positive, priority should be lower.\n    # We can map slack to priority. A common mapping for \"minimize X\" to \"maximize Y\" is Y = -X or Y = 1/(1+X).\n    # Using `-slack` gives higher values for smaller slacks.\n    # We also want to prefer bins that were initially fuller (smaller bins_remain_cap).\n    # This means that among bins with the same slack, the one with the smaller original\n    # `bins_remain_cap` should be preferred.\n\n    # Let's consider the inverse of the remaining capacity as a secondary sorting key.\n    # A higher inverse remaining capacity (meaning lower original remaining capacity, i.e. fuller bin) is better.\n    # So, for fitting bins, we want to maximize: `priority = -slack + C * (1 / bins_remain_cap[can_fit_mask])`\n    # where C is a weighting factor. A simpler approach is to rank them based on slack first,\n    # and then remaining capacity.\n\n    # A common heuristic for Best Fit is to sort by remaining capacity and pick the first one.\n    # For priority, we want the bin with the smallest `bins_remain_cap - item` to have the highest score.\n    # This means `bins_remain_cap - item` should be minimized.\n    # So, we can use `- (bins_remain_cap - item)` as a primary score.\n    # To break ties, or to add a preference for fuller bins, we can add a term that\n    # is proportional to `1.0 / bins_remain_cap`.\n\n    # Let's try to prioritize based on minimal slack first.\n    # A bin with slack 0 is best.\n    # A bin with slack 1 is second best.\n    # ...\n    # For bins with the same slack, the one with less remaining capacity (fuller) is better.\n    # This implies we want to maximize `-(bins_remain_cap[i] - item)` and secondarily maximize `bins_remain_cap[i]`.\n\n    # A common approach for \"best fit\" is to aim for a score where smaller `bins_remain_cap - item` are better.\n    # So, we can use a score like `1.0 / (1.0 + (bins_remain_cap[can_fit_mask] - item))`.\n    # This gives a value between 0 and 1, with 1 for a perfect fit (slack=0).\n\n    # To add a preference for fuller bins among those with the same slack,\n    # we can add a secondary term that increases with decreasing `bins_remain_cap`.\n    # For example, `1.0 / (1.0 + slack)` could be the primary score.\n    # A secondary score could be `1.0 / bins_remain_cap`.\n    # Combined: `priority = 1.0 / (1.0 + slack) + weight * (1.0 / bins_remain_cap[can_fit_mask])`\n\n    # However, the reflection implies prioritizing fuller bins directly.\n    # A simple way to prioritize fuller bins is to use the inverse of their remaining capacity.\n    # `1.0 / bins_remain_cap[can_fit_mask]` gives higher scores to fuller bins.\n    # But this doesn't directly address the \"just enough space\" aspect of Best Fit.\n\n    # Let's refine the Best Fit idea: we want the smallest *positive* slack.\n    # So, `slack = bins_remain_cap[can_fit_mask] - item`.\n    # We want to minimize `slack`.\n    # For priority, we want to maximize a function of `slack`.\n    # A simple way is `priorities[can_fit_mask] = -slack`.\n    # This means slack 0 -> priority 0, slack 1 -> priority -1, slack 5 -> priority -5.\n    # Higher priority for smaller slack.\n\n    # Now, consider the \"preference for fuller bins\". This means that among bins\n    # with the same slack, we prefer the one that was more full to begin with.\n    # So if `bins_remain_cap[i] - item == bins_remain_cap[j] - item`, and\n    # `bins_remain_cap[i] < bins_remain_cap[j]`, then bin `i` is preferred.\n    # This implies that `bins_remain_cap[i]` itself should contribute to higher priority.\n\n    # We can combine these: maximize `-slack` and maximize `bins_remain_cap[can_fit_mask]`.\n    # A potential priority score could be: `priority = -(bins_remain_cap[can_fit_mask] - item) + alpha * bins_remain_cap[can_fit_mask]`\n    # where `alpha` is a small positive weight to ensure slack is primary.\n\n    # Let's try a simpler, more direct approach that captures both aspects.\n    # Prioritize bins with the smallest positive `slack`.\n    # Among those with the same slack, prioritize bins with the smallest `bins_remain_cap`.\n\n    # One way to achieve this is to use a composite score.\n    # The value `bins_remain_cap[can_fit_mask] - item` should be minimized.\n    # The value `bins_remain_cap[can_fit_mask]` should also be minimized (to favor fuller bins).\n    # We can create a composite key for sorting: `(slack, bins_remain_cap[can_fit_mask])`.\n    # For priority, we want to maximize this composite key, but in reverse.\n    # So, we want to maximize `(-slack, -bins_remain_cap[can_fit_mask])`.\n\n    # A direct mapping to a single priority score:\n    # We want to maximize `1.0 / (1.0 + slack)` for best fit.\n    # To favor fuller bins, we can add a term like `1.0 / bins_remain_cap`.\n    # Let's use a scaling factor to balance these two objectives.\n\n    # A common technique for multiple objectives is to scale and sum.\n    # Objective 1: Minimize slack (maximize 1 / (1 + slack))\n    # Objective 2: Minimize bins_remain_cap (maximize 1 / bins_remain_cap)\n\n    # Let's normalize the slack and remaining capacities first, or use a well-behaved function.\n    # Using `1.0 / (1.0 + slack)` maps slack [0, inf) to priority (1, 0].\n    # Using `1.0 / bins_remain_cap` maps remaining_cap [item, inf) to priority (1/item, 0).\n\n    # Let's combine them directly:\n    # Higher priority for smaller slack AND smaller remaining_capacity.\n    # We can use a lexicographical ordering effect by careful function design.\n    # `priorities[can_fit_mask] = 1.0 / (bins_remain_cap[can_fit_mask] - item + 1e-9) * (1.0 / bins_remain_cap[can_fit_mask] + 1e-9)`\n    # This might over-prioritize very small remaining capacities regardless of slack.\n\n    # A more robust approach for \"just enough space\" (Best Fit):\n    # Prioritize bins where `bins_remain_cap - item` is minimized.\n    # Let `score_bf = -(bins_remain_cap[can_fit_mask] - item)`. Maximize this.\n    # For tie-breaking (prefer fuller bins), we want to maximize `bins_remain_cap[can_fit_mask]`.\n    # So, we want to maximize `score_bf` and secondarily `bins_remain_cap`.\n    # This can be achieved by `priority = score_bf + alpha * bins_remain_cap`.\n    # A suitable `alpha` would be small enough that `score_bf` dominates for same slack.\n\n    # Let's use a large multiplier for the secondary criterion to make it effective.\n    # Consider the remaining capacities themselves.\n    # We want to pick the bin with minimum `bins_remain_cap` that fits the item.\n    # If multiple bins have the same minimum `bins_remain_cap` that fits, pick the one with the smallest slack.\n    # This is a subtle ordering.\n\n    # The reflection states: \"prioritize fuller bins by inverting remaining capacity for better fit.\"\n    # This implies that if two bins can fit an item, the one that is *more full* is preferred.\n    # This sounds like a variation of First Fit Decreasing or Best Fit.\n    # \"Better fit\" usually means less waste.\n\n    # Let's reconsider the goal: \"prioritize bins that have *just enough* space, and among those, favors fuller bins.\"\n    # \"Just enough space\" implies minimizing `bins_remain_cap - item`.\n    # \"Favors fuller bins\" implies minimizing `bins_remain_cap`.\n\n    # So we want to minimize two values:\n    # 1. `slack = bins_remain_cap[can_fit_mask] - item`\n    # 2. `bins_remain_cap[can_fit_mask]`\n\n    # To maximize priority, we want to maximize functions of these.\n    # Maximize `-slack` and maximize `-bins_remain_cap`.\n    # A common approach is to combine them, e.g., `priority = -slack - alpha * bins_remain_cap`.\n    # Or, more directly: `priority = -(slack + alpha * bins_remain_cap)`.\n    # Here, `slack` is minimized first, and then `bins_remain_cap` is minimized.\n\n    # Let's assign a score that is inversely proportional to slack, and then inversely proportional to remaining capacity.\n    # `score1 = 1.0 / (slack + epsilon)`\n    # `score2 = 1.0 / bins_remain_cap[can_fit_mask]`\n    # `priorities[can_fit_mask] = score1 + weight * score2`\n\n    # Let's try to make the slack minimization dominant.\n    # If slack is 0, priority should be high.\n    # If slack is 0 and bin_rem_cap is 5, priority is X.\n    # If slack is 0 and bin_rem_cap is 10, priority is Y, where Y < X.\n    # If slack is 1, priority should be lower than X and Y.\n\n    # Let's use a score that heavily penalizes slack, and then uses remaining capacity.\n    # `priorities[can_fit_mask] = 1.0 / (1.0 + slack) - alpha * bins_remain_cap[can_fit_mask]`\n    # This would prioritize smaller slack, but then penalize larger remaining capacities.\n    # This sounds correct for \"just enough space\" and then \"fuller bins\".\n\n    # Let's use a small `alpha` to ensure the slack is the primary driver.\n    # A common strategy is to use `1.0 / (1.0 + slack)` and `1.0 / bins_remain_cap`.\n    # Combining them: `priorities[can_fit_mask] = 1.0 / (1.0 + slack) + 0.1 * (1.0 / bins_remain_cap[can_fit_mask])`\n    # The `0.1` is an arbitrary weight.\n\n    # A simpler interpretation of \"prioritize fuller bins by inverting remaining capacity\" might be:\n    # For best fit, we want `bins_remain_cap - item` to be minimal.\n    # So, prioritize bins with `bins_remain_cap` closest to `item`.\n    # Let `diff = bins_remain_cap[can_fit_mask] - item`. We want to minimize `diff`.\n    # The priority should be high for small `diff`.\n    # So, `priority = 1.0 / (diff + epsilon)`. This is Best Fit.\n\n    # Now, \"favors fuller bins\". This means, if `diff` is the same for two bins,\n    # the one with smaller `bins_remain_cap` is preferred.\n    # This implies that `bins_remain_cap` itself should positively contribute to priority.\n    # So, we want to maximize `1.0 / (diff + epsilon)` AND maximize `bins_remain_cap`.\n    # This is counter-intuitive. If fuller bins are preferred, it means smaller `bins_remain_cap`.\n    # So, we want to maximize `1.0 / (diff + epsilon)` AND maximize `(1.0 / bins_remain_cap)`.\n\n    # Let's try a direct mapping:\n    # We want to minimize `bins_remain_cap - item`. Let this be `waste`.\n    # We want to minimize `bins_remain_cap`.\n    # So, the ideal bin has small `waste` and small `bins_remain_cap`.\n    # For priority, we want to maximize `1.0 / (waste + epsilon)` and `1.0 / bins_remain_cap`.\n\n    # Combining: `priorities[can_fit_mask] = (1.0 / (slack + 1e-9)) * (1.0 / bins_remain_cap[can_fit_mask] + 1e-9)`\n    # This might scale too aggressively.\n\n    # Let's stick to the idea of minimizing `slack` AND `bins_remain_cap`.\n    # Maximize `-slack` and maximize `-bins_remain_cap`.\n    # Priority = `-slack - alpha * bins_remain_cap`\n\n    # Let's assign priorities based on `-(slack)` and then `-bins_remain_cap`.\n    # `priorities[can_fit_mask] = -(slack + bins_remain_cap[can_fit_mask])`\n    # This prioritizes bins with smaller `slack + bins_remain_cap`.\n    # If slack is 0, and remaining_cap is 5, sum is 5. Priority -5.\n    # If slack is 0, and remaining_cap is 10, sum is 10. Priority -10.\n    # This favors fuller bins when slack is the same.\n\n    # However, the prompt for v1 was \"preference for fuller bins\" by inverting remaining capacity.\n    # This usually implies something like `1.0 / bins_remain_cap`.\n    # So, the reflection means the *priority* should be higher for fuller bins.\n\n    # Let's try a composite score that directly favors smaller `slack` AND smaller `bins_remain_cap`.\n    # We can make `slack` the primary factor, and `bins_remain_cap` the secondary.\n    #\n    # For Best Fit, we want to minimize `slack = bins_remain_cap - item`.\n    # So, prioritize by `1.0 / (slack + epsilon)`.\n    #\n    # For preferring fuller bins, we want to minimize `bins_remain_cap`.\n    # So, prioritize by `1.0 / bins_remain_cap`.\n    #\n    # Combining these:\n    # We want to maximize `f(slack, bins_remain_cap)` where `f` increases with `1/slack` and `1/bins_remain_cap`.\n    # A simple additive approach:\n    # `priorities[can_fit_mask] = (1.0 / (slack + 1e-9)) + (1.0 / bins_remain_cap[can_fit_mask] + 1e-9)`\n    # This gives higher priority to bins with small slack AND small remaining capacity.\n    # The `+ 1e-9` in the second term is to avoid division by zero if the bin capacity itself is 0 (though unlikely in BPP).\n    # The first term `1.0 / (slack + 1e-9)` ensures Best Fit logic (smaller slack is better).\n    # The second term `1.0 / bins_remain_cap[can_fit_mask]` adds the preference for fuller bins.\n\n    priorities[can_fit_mask] = (1.0 / (slack + 1e-9)) + (1.0 / (bins_remain_cap[can_fit_mask] + 1e-9))\n\n    return priorities\n\n[Reflection]\nPrioritize minimal slack first, then favor fuller bins by inverting remaining capacity.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}