```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Almost Full Fit.

    Almost Full Fit (AFF) is a heuristic for the bin packing problem.
    The idea behind AFF is to pack the current item into the bin that has
    just enough remaining capacity to hold the item, or the bin that has the
    smallest remaining capacity among those that can hold the item. This
    tends to leave larger gaps in other bins for future, potentially larger items.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
        Higher priority is given to bins that are almost full (i.e., have a small
        remaining capacity that is still sufficient for the item).
    """
    # Initialize priorities to a very low value for bins that cannot accommodate the item
    # and a base priority for bins that can.
    # We want to prioritize bins that leave the smallest gap after packing.
    # The gap is bins_remain_cap - item.
    # So, we want to minimize this gap.
    # A simple way to prioritize is to assign a higher score to smaller positive gaps.

    # Identify bins that can accommodate the item
    can_accommodate_mask = bins_remain_cap >= item

    # For bins that can accommodate the item, calculate the "tightness" or remaining capacity.
    # The tighter the fit (smaller remaining capacity after packing), the higher the priority.
    # We want to sort bins by remaining_capacity - item.
    # However, directly using remaining_capacity - item might lead to issues if we just
    # want to assign high values to "almost full".
    # Let's define priority as the inverse of the remaining capacity after packing,
    # but only for bins that can fit the item.

    # A good strategy for AFF would be to give the highest priority to the bin
    # where (bin_capacity - item) is minimized.
    # If multiple bins have the same minimum difference, we can break ties by
    # selecting the bin with the smallest index or some other arbitrary but consistent method.

    # Let's create a priority score where a smaller remaining capacity (after packing)
    # results in a higher priority.
    # The difference is bins_remain_cap[i] - item.
    # We want to prioritize smaller positive differences.
    # We can achieve this by using the negative of the difference.
    # However, this still needs to be non-positive for bins that *cannot* fit the item.

    priorities = np.full_like(bins_remain_cap, -np.inf)  # Initialize with a very low priority

    # Calculate the remaining capacity after placing the item in eligible bins
    remaining_after_packing = bins_remain_cap[can_accommodate_mask] - item

    # For AFF, we want the smallest positive difference.
    # So, we can assign a priority score based on this difference.
    # A common way to ensure higher values are preferred is to use negative values
    # and then take the negative, or simply sort in reverse.
    # Let's assign priorities such that the smallest positive (bins_remain_cap - item)
    # gets the highest priority.
    # We can achieve this by using the negative of the remaining capacity after packing.
    # Or more simply, the remaining capacity itself, and then we'd look for the minimum among positive values.

    # Let's try a score where a bin that *exactly* fits gets the highest priority,
    # and bins that have a slightly larger remaining capacity get slightly lower priority.
    # This suggests a function that is high when (bins_remain_cap - item) is small and positive.

    # Calculate the difference (gap) for eligible bins.
    gaps = bins_remain_cap[can_accommodate_mask] - item

    # To prioritize the smallest positive gap, we can assign priorities like:
    # If gap == 0, priority = infinity (or a very large number).
    # If gap > 0, priority = 1 / gap.
    # This might be problematic with floating point precision.

    # A simpler approach: assign priority based on the negative of the gap.
    # The smallest gap will have the largest negative value (closest to zero).
    # This still requires careful handling of negative gaps (bins that can't fit).

    # Let's try a more direct interpretation of AFF: find the bin with the smallest
    # `bins_remain_cap` that is still greater than or equal to `item`.
    # We can achieve this by assigning a "priority" score where the minimum `bins_remain_cap`
    # (among those >= item) gets the highest score.
    # A score of `-bins_remain_cap` would naturally prioritize smaller remaining capacities.
    # For bins that *cannot* fit, we assign a very low score.

    priorities[can_accommodate_mask] = -bins_remain_cap[can_accommodate_mask]

    # Another common way to implement "smallest remaining capacity" priority is to
    # give a high priority to bins that are "closest" to fitting the item without going over.
    # This means bins with `bins_remain_cap - item` closest to 0 (and positive).
    # A simple way to get this behavior: if a bin can fit, assign a priority inversely proportional
    # to its remaining capacity *after* the item is placed.

    # Let's use the remaining capacity after placement as the basis.
    # We want to MINIMIZE this remaining capacity.
    # So, a smaller value should correspond to a higher priority.
    # Using `-bins_remain_cap + item` directly gives the negative of the gap.
    # The bin with the smallest positive gap will have the least negative value.

    # For bins that can accommodate the item:
    # The priority should be higher for bins with smaller remaining capacity.
    # So, we want to maximize `bins_remain_cap - item` when `bins_remain_cap - item` is small.
    # Or, we want to minimize `bins_remain_cap` among eligible bins.

    # Let's assign a score based on the negative of the bin's remaining capacity.
    # The largest negative value (closest to 0) will correspond to the smallest capacity.
    # For bins that can accommodate the item, we assign a score of `-bins_remain_cap`.
    # This implicitly prioritizes bins with smaller remaining capacities.

    # Consider the case where multiple bins have the same minimal remaining capacity.
    # AFF typically means selecting *one* such bin. Our scoring mechanism would
    # give them equal scores. A tie-breaking rule would be needed in the selection logic,
    # but the priority function just needs to assign comparable scores.

    # A simple and effective priority for AFF could be:
    # For bins that can fit the item, assign a priority based on their current remaining capacity.
    # The lower the remaining capacity, the higher the priority.
    # So, priority = -bins_remain_cap.
    # For bins that cannot fit, assign a very low priority (-infinity).

    priorities = np.full_like(bins_remain_cap, -np.inf)
    eligible_bins_indices = np.where(bins_remain_cap >= item)[0]

    if eligible_bins_indices.size > 0:
        # Assign a priority score such that smaller remaining capacities get higher scores.
        # Using the negative of the remaining capacity works well:
        # e.g., if remaining caps are [5, 3, 8] and item is 2,
        # eligible caps are [5, 3, 8]. Scores would be [-5, -3, -8].
        # The max score is -3, which corresponds to the bin with remaining cap 3.
        priorities[eligible_bins_indices] = -bins_remain_cap[eligible_bins_indices]

    return priorities
```
