```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin, prioritizing fuller bins first, then best fit.

    This heuristic prioritizes bins that are already fuller (have less remaining capacity).
    If multiple bins have the same minimal remaining capacity, it then applies the Best Fit
    principle to choose the one that results in the least waste. This aims to pack items
    more densely by preferring bins that are closer to being full.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Returns:
        Array of same size as bins_remain_cap with priority score of each bin.
        Higher score indicates higher priority. Bins that cannot fit the item will have a priority of 0.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    epsilon = 1e-9

    # Create a boolean mask for bins that can accommodate the item
    can_fit_mask = bins_remain_cap >= item

    if not np.any(can_fit_mask):
        return priorities

    fittable_bins_capacities = bins_remain_cap[can_fit_mask]

    # Primary goal: Prioritize fuller bins. This means prioritizing bins with smaller remaining capacity.
    # We can use the inverse of remaining capacity as a score. Higher score for smaller capacity.
    # `fullness_score = 1.0 / (fittable_bins_capacities + epsilon)`

    # Secondary goal: Among equally full bins, prioritize the best fit (minimize waste).
    # Waste = `fittable_bins_capacities - item`.
    # Best fit score = `1.0 / (waste + epsilon)`

    # Combine the two: We want to prioritize bins with smaller `bins_remain_cap` first,
    # and then smaller `fittable_bins_capacities - item` as a tie-breaker.
    # A single score that achieves this is to create a composite key:
    # `composite_key = (fittable_bins_capacities, fittable_bins_capacities - item)`
    # We want to minimize this composite key lexicographically.
    # For priority (maximize), we want to maximize the inverse of this key.
    # A simple way to combine them into a single score for maximization is:
    # `priority = (1.0 / (fittable_bins_capacities + epsilon)) + (1.0 / (fittable_bins_capacities - item + epsilon))`
    # This gives a higher score to bins that are both fuller and have less waste.
    # Let's test this combination:
    # Bin A: remain_cap=0.6, item=0.5 -> waste=0.1. Score = 1/0.6 + 1/0.1 = 1.667 + 10 = 11.667
    # Bin B: remain_cap=0.7, item=0.5 -> waste=0.2. Score = 1/0.7 + 1/0.2 = 1.428 + 5 = 6.428
    # Bin C: remain_cap=0.6, item=0.4 -> waste=0.2. Score = 1/0.6 + 1/0.2 = 1.667 + 5 = 6.667
    # Bin A (fullest, best fit) gets highest score. Bin C (equally full as A, worse fit) gets second highest. Bin B (less full, worse fit) gets lowest.
    # This combination seems to correctly prioritize fullness first, then best fit.

    combined_score = (1.0 / (fittable_bins_capacities + epsilon)) + \
                     (1.0 / (fittable_bins_capacities - item + epsilon))

    priorities[can_fit_mask] = combined_score

    return priorities
```
