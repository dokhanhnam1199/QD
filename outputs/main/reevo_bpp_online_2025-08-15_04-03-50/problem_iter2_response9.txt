```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using a hybrid strategy.

    This strategy combines a "Best Fit" approach (prioritizing bins that leave minimal
    remaining capacity after packing) with a "Worst Fit" element (prioritizing bins
    with more remaining capacity to encourage spreading items). It also incorporates
    a small probability of choosing a random bin to escape local optima.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    exploration_prob = 0.05  # Probability of exploring (choosing a random fittable bin)
    n_bins = len(bins_remain_cap)
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins that can fit the item
    fittable_bins_mask = bins_remain_cap >= item

    if not np.any(fittable_bins_mask):
        # If no bin can fit the item, return all zeros.
        return priorities

    # Calculate scores for fittable bins
    fittable_bins_indices = np.where(fittable_bins_mask)[0]
    fittable_bins_capacities = bins_remain_cap[fittable_bins_mask]

    # Hybrid scoring:
    # 1. Best Fit component: Prioritize bins where (capacity - item) is minimized.
    #    We use 1 / (difference + epsilon) for this.
    epsilon = 1e-9
    best_fit_scores = 1.0 / (fittable_bins_capacities - item + epsilon)

    # 2. Worst Fit component: Prioritize bins with larger remaining capacity.
    #    We can use the capacity itself or a scaled version. Here, we'll use
    #    the capacity directly as a secondary scoring factor.
    worst_fit_scores = fittable_bins_capacities

    # Combine scores: A simple linear combination. You can tune weights.
    # Here, we give slightly more weight to the "best fit" aspect.
    combined_scores = 0.7 * best_fit_scores + 0.3 * worst_fit_scores

    # Assign combined scores to priorities for fittable bins
    priorities[fittable_bins_mask] = combined_scores

    # Apply exploration: With a small probability, pick a random fittable bin.
    if np.random.rand() < exploration_prob:
        random_fittable_index_in_fittable_array = np.random.randint(len(fittable_bins_indices))
        chosen_bin_global_index = fittable_bins_indices[random_fittable_index_in_fittable_array]

        # Reset priorities and set the randomly chosen bin's priority to 1
        priorities = np.zeros_like(bins_remain_cap, dtype=float)
        priorities[chosen_bin_global_index] = 1.0
    else:
        # Normalize priorities to sum to 1 if we are not exploring randomly
        if np.sum(priorities[fittable_bins_mask]) > 0:
            priorities[fittable_bins_mask] /= np.sum(priorities[fittable_bins_mask])

    return priorities
```
