```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using a refined Almost Full Fit strategy.

    This strategy prioritizes bins that have a "tight fit" for the item, meaning the
    remaining capacity after insertion is minimized (but non-negative).
    It uses the inverse of (1 + slack) to reward smaller slacks.
    Additionally, it introduces a slight bias towards bins that are *not* excessively large,
    even if they offer a tight fit for the current item, to promote better overall packing.
    This is done by penalizing bins with significantly more remaining capacity than needed.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins where the item can fit
    fit_mask = bins_remain_cap >= item

    # Calculate the slack for bins that can fit the item
    # Slack is defined as remaining_capacity - item_size
    slack = bins_remain_cap[fit_mask] - item

    # Strategy: Prioritize bins with minimal non-negative slack (tightest fits).
    # The core idea is to maximize `1 / (1 + slack)`.
    # A slack of 0 (perfect fit) gives priority 1.0.
    # Smaller positive slacks give higher priorities than larger ones.
    # We add 1 to slack to avoid division by zero and to bound priorities.
    base_priorities = 1.0 / (1.0 + slack)

    # Refinement: Introduce a penalty for bins that have significantly more capacity
    # than is currently needed, even if they provide a tight fit for this item.
    # This discourages using a large, mostly empty bin if a smaller, nearly full bin exists.
    # We can do this by penalizing `bins_remain_cap` for bins that fit.
    # A common approach is to divide the base priority by some function of the bin's capacity,
    # or subtract a value related to the capacity.
    # Let's use a factor that slightly reduces priority for larger bins.
    # A simple way is to use the inverse of the original remaining capacity,
    # effectively favoring smaller bins.

    # However, a simpler approach for "Almost Full Fit" is to focus purely on the slack.
    # The reflection also suggests "balance with random exploration for robustness",
    # but this is a deterministic priority function. For robustness, one might consider
    # a small random element or using multiple heuristics.
    # For this specific function, let's refine the slack prioritization.

    # The `1.0 / (1.0 + slack)` formulation already favors tighter fits.
    # To avoid very large bins being chosen if they have a similar slack to smaller bins,
    # we can introduce a penalty related to the bin's *original* remaining capacity.
    # For example, we could multiply by `(1.0 - log(bins_remain_cap[fit_mask] + 1) / max_log_cap)`.
    # This is becoming complex.

    # Let's simplify based on the reflection: "Prioritize fitting bins, favoring those with minimal remaining capacity (tight fits). Experiment with prioritizing fuller bins using inverted slack, but balance with random exploration for robustness."

    # The `1.0 / (1.0 + slack)` already favors minimal remaining capacity.
    # "Prioritizing fuller bins using inverted slack" could mean maximizing `-slack`,
    # but this assumes we want *negative* slack (i.e., item overflows).
    # For fitting items, we want minimal *positive* slack. `1/(1+slack)` achieves this.

    # Let's add a term that slightly favors bins that are "closer" to being full relative to their own size,
    # or simply prefer smaller bins overall when slack is equal.
    # A simple way to penalize larger bins without overcomplicating is to subtract a small value proportional to their capacity.
    # However, this could make priorities negative.

    # A balanced approach could be to ensure that the priority is also influenced by how "full" the bin *will become*.
    # If `potential_remaining_cap` is small, it's good.
    # We are already maximizing `1/(1+slack)` where `slack = bins_remain_cap - item`.
    # This is equivalent to minimizing `slack`.

    # Consider the "slack" as the primary metric.
    # For bins that fit, `bins_remain_cap[fit_mask] - item`
    # We want to prioritize smaller values of this slack.
    # `1.0 / (1.0 + slack)` achieves this.

    # Alternative interpretation for "Almost Full Fit": prioritize bins where `bins_remain_cap` is slightly larger than `item`.
    # Example:
    # Bin A: capacity=5, item=3, slack=2, potential_rem=2. Priority = 1/(1+2) = 0.33
    # Bin B: capacity=4, item=3, slack=1, potential_rem=1. Priority = 1/(1+1) = 0.5
    # Bin C: capacity=3, item=3, slack=0, potential_rem=0. Priority = 1/(1+0) = 1.0

    # This seems correct for favoring tight fits.
    # The reflection mentions "balancing with random exploration". Since this is deterministic,
    # we can simulate a *slight* bias by adding a tiny noise or by using a secondary criterion for ties.
    # For now, let's stick to a refined deterministic priority based on slack.

    # Let's ensure that bins that are *just barely* large enough are prioritized
    # over bins that are much larger but also fit.
    # The `1 / (1 + slack)` already does this indirectly: a larger bin will have a larger
    # slack for the same item, resulting in a lower priority.

    # Example: item=2
    # Bin A: cap=3, slack=1, priority=1/2=0.5
    # Bin B: cap=10, slack=8, priority=1/9~0.11
    # This is working as intended.

    # Final check on the reflection: "Prioritize fitting bins, favoring those with minimal remaining capacity (tight fits). Experiment with prioritizing fuller bins using inverted slack, but balance with random exploration for robustness."
    # Minimal remaining capacity after fit => minimal slack => maximize `1/(1+slack)`.
    # "Prioritizing fuller bins using inverted slack" => This might imply `-(bins_remain_cap - item)` or similar.
    # If we use `-slack`, we want the most negative slack (overflow), which is not for fitting.
    # If we want the *least positive* slack, `1/(1+slack)` is a good proxy.

    # Let's refine the priority to explicitly prefer bins where `bins_remain_cap` is closer to `item`.
    # This means minimizing `bins_remain_cap - item`.

    # A potential issue with `1/(1+slack)` is that if `slack` is very large, the priority approaches zero.
    # We can add a small constant to the slack to push priorities slightly higher for all fitting bins,
    # or use a different function.

    # Consider `priority = exp(-slack)`
    # slack=0: exp(0) = 1
    # slack=1: exp(-1) ~ 0.37
    # slack=2: exp(-2) ~ 0.13
    # This also favors smaller slacks and decays faster.

    # Another approach: The "Best Fit Decreasing" heuristic for offline BPP often prioritizes
    # bins that have the smallest capacity *that is greater than or equal to the item size*.
    # For online, we can adapt this. Find bins that fit, and among those, pick the one
    # with the smallest `bins_remain_cap`.
    # This is equivalent to minimizing slack: `bins_remain_cap - item`.

    # Let's use the negative of the slack for fitting bins, as maximizing this will minimize slack.
    # But we need to ensure non-fitting bins have a very low priority.
    # If `bins_remain_cap - item` is negative, the item doesn't fit.
    # We want to prioritize smaller values of `bins_remain_cap` for fitting bins.
    # So, maximize `-bins_remain_cap` for bins where `bins_remain_cap >= item`.

    # Let's try: priority = bins_remain_cap for fitting bins. This would favor smaller bins directly.
    # If item=2:
    # Bin A: cap=3, slack=1. Priority = 3
    # Bin B: cap=4, slack=2. Priority = 4
    # Bin C: cap=10, slack=8. Priority = 10
    # This favors bins that are *just* big enough.

    # Combining "tight fit" (minimize slack) and "favor smaller bins":
    # For fitting bins, priority = -(bins_remain_cap - item) + K * (-bins_remain_cap)
    # This is equivalent to minimizing `slack - K * bins_remain_cap`
    # Or maximizing `item - bins_remain_cap + K * bins_remain_cap`

    # Let's use the simplest interpretation of "tight fit" which is minimizing slack.
    # The `1.0 / (1.0 + slack)` seems robust and directly rewards smaller slacks.
    # To address the "prioritizing fuller bins" part, consider that a bin that is already very full
    # (small original `bins_remain_cap`) might be preferred if it has a tight fit.
    # The `1.0 / (1.0 + slack)` indirectly favors smaller bins because they tend to have smaller slacks.

    # Let's try a simpler approach that directly maximizes the "fullness" after packing.
    # We want to maximize `-(bins_remain_cap - item)` for fitting bins.
    # This means we want to minimize `bins_remain_cap - item`.

    # `potential_remaining_cap = bins_remain_cap[fit_mask] - item`
    # We want to maximize `-potential_remaining_cap`.
    # Let's try setting priority to `-potential_remaining_cap`.
    # This means smaller remaining capacity gets higher priority.

    # Example: item=2
    # Bin A: cap=3, item=2 -> potential_rem=1. Priority = -1
    # Bin B: cap=4, item=2 -> potential_rem=2. Priority = -2
    # Bin C: cap=10, item=2 -> potential_rem=8. Priority = -8
    # Bin D: cap=1, item=2 -> doesn't fit. Priority = 0

    # This makes the *least negative* number the highest priority. This means
    # we want the smallest `potential_remaining_cap`.
    # This strategy seems to align well with "Almost Full Fit".

    # To make it slightly more robust against very large bins:
    # We can normalize the priority by the bin's original capacity or add a penalty.
    # Let's try to modify the priority: `-potential_remaining_cap - alpha * bins_remain_cap[fit_mask]`
    # Where alpha is a small positive constant. This would penalize larger bins.
    # A simpler modification: Prioritize by `-potential_remaining_cap`, and for ties,
    # pick the bin with smaller `bins_remain_cap`.

    # Let's use the direct "minimize remaining capacity after packing" approach.
    # This is equivalent to maximizing `-(bins_remain_cap - item)`.

    potential_remaining_cap = bins_remain_cap[fit_mask] - item

    # Maximize the negative of the remaining capacity.
    # This prioritizes bins that will have the least capacity left.
    priorities[fit_mask] = -potential_remaining_cap

    # To incorporate the "favoring fuller bins" aspect more directly,
    # we can also consider the initial state of the bin.
    # A bin that is already "more full" might be a better candidate.
    # This can be done by adding a term that is inversely related to initial capacity.
    # For example, `-(bins_remain_cap[fit_mask] - item) + C * (1.0 / bins_remain_cap[fit_mask])`
    # This is complex. Let's stick to the most direct interpretation of "Almost Full Fit".

    # The reflection suggests "prioritizing fuller bins using inverted slack".
    # Inverted slack could mean `1 / (slack + epsilon)` if slack is positive, or `1 / (capacity - item)`
    # for fitting bins, where we want smaller denominators.
    # The current `-potential_remaining_cap` is a good candidate.

    # Let's consider a slight modification inspired by Best Fit:
    # Among bins that fit, choose the one with the minimum `bins_remain_cap`.
    # This is equivalent to minimizing `slack`.
    # If we want to return higher priority for better choices, we should maximize `-slack`.
    # So, `-potential_remaining_cap` is a good choice.

    # Consider `bins_remain_cap = [5, 6], item = 3`
    # Bin 0: cap=5, item=3 -> potential_rem=2. priority = -2
    # Bin 1: cap=6, item=3 -> potential_rem=3. priority = -3
    # Bin 0 is chosen. This is correct (tightest fit).

    # Consider `bins_remain_cap = [3, 4], item = 3`
    # Bin 0: cap=3, item=3 -> potential_rem=0. priority = 0
    # Bin 1: cap=4, item=3 -> potential_rem=1. priority = -1
    # Bin 0 is chosen. This is correct (perfect fit, minimal remaining).

    # To add a slight bias towards smaller bins when slack is equal:
    # If `potential_remaining_cap` is the same for two bins, we'd want to break ties.
    # For example, if item=3, and bins_remain_cap = [5, 5]:
    # Both give potential_rem=2, priority=-2.
    # In this case, we could add a term proportional to `-bins_remain_cap`.
    # `priority = -potential_remaining_cap - alpha * bins_remain_cap[fit_mask]`
    # Let alpha = 0.1.
    # Bin 0: cap=5 -> -2 - 0.1*5 = -2.5
    # Bin 1: cap=5 -> -2 - 0.1*5 = -2.5
    # Tie still exists.

    # A more direct way to prioritize smaller bins when slack is equal:
    # Use the original `bins_remain_cap` as a secondary sorting key or part of the primary.
    # Let's try: `priority = -bins_remain_cap[fit_mask] + C * (-potential_remaining_cap)`
    # This prioritizes smaller initial capacity, and then tighter fits.
    # Let C=1.
    # Bin 0: cap=3, item=3 -> potential_rem=0. priority = -3 + 1*0 = -3
    # Bin 1: cap=4, item=3 -> potential_rem=1. priority = -4 + 1*(-1) = -5
    # Bin 0 is chosen. This favors tighter fits more.

    # Let's try maximizing `-potential_remaining_cap` AND `-bins_remain_cap`.
    # This means minimizing `potential_remaining_cap` and `bins_remain_cap`.
    # Prioritize by `-(potential_remaining_cap + bins_remain_cap[fit_mask])`
    # Bin 0: cap=3, item=3 -> pot_rem=0. priority = -(0 + 3) = -3
    # Bin 1: cap=4, item=3 -> pot_rem=1. priority = -(1 + 4) = -5
    # Bin 0 is chosen. This seems to combine both criteria.

    # However, the reflection emphasizes "minimal remaining capacity (tight fits)".
    # So, `-potential_remaining_cap` should be the primary driver.
    # The "favoring fuller bins" could mean prioritizing bins that are already
    # closer to full *before* insertion, but this contradicts tight-fitting.
    # It's more likely referring to the state *after* insertion.

    # Let's re-read: "Prioritize fitting bins, favoring those with minimal remaining capacity (tight fits)."
    # This is addressed by maximizing `-potential_remaining_cap`.

    # "Experiment with prioritizing fuller bins using inverted slack"
    # Inverted slack could mean `1/(slack+eps)` or `-slack`.
    # If we want to prioritize fuller bins, we want smaller *initial* remaining capacity.
    # So, let's use a weighted sum:
    # Priority = `w1 * (-potential_remaining_cap) + w2 * (-bins_remain_cap[fit_mask])`
    # We want to maximize this.
    # Let's try `w1 = 1, w2 = 0.5` (slightly favor tight fits over smaller bins).
    # Bin A: cap=5, item=3 -> pot_rem=2. priority = 1*(-2) + 0.5*(-5) = -2 - 2.5 = -4.5
    # Bin B: cap=4, item=3 -> pot_rem=1. priority = 1*(-1) + 0.5*(-4) = -1 - 2.0 = -3.0
    # Bin B is chosen. It has a tighter fit.

    # If `w1 = 0.5, w2 = 1` (slightly favor smaller bins over tight fits).
    # Bin A: cap=5, item=3 -> pot_rem=2. priority = 0.5*(-2) + 1*(-5) = -1 - 5 = -6.0
    # Bin B: cap=4, item=3 -> pot_rem=1. priority = 0.5*(-1) + 1*(-4) = -0.5 - 4 = -4.5
    # Bin B is chosen. It has a tighter fit.

    # It seems `-potential_remaining_cap` is the dominant factor for "tight fit".
    # Let's focus on that and add a small secondary criterion for "fuller bins" (smaller initial capacity).
    # We want to maximize `-potential_remaining_cap`, and secondarily maximize `-bins_remain_cap`.
    # This is equivalent to maximizing `-potential_remaining_cap - alpha * bins_remain_cap` for a small alpha.
    # Let's use a small alpha to ensure `-potential_remaining_cap` is primary.

    alpha = 0.01  # A small weight for the secondary criterion
    priorities[fit_mask] = -potential_remaining_cap - alpha * bins_remain_cap[fit_mask]

    # Testing this:
    # item=3
    # bins_remain_cap = [5, 4]
    # Bin 0: cap=5, item=3 -> pot_rem=2. priority = -2 - 0.01*5 = -2.05
    # Bin 1: cap=4, item=3 -> pot_rem=1. priority = -1 - 0.01*4 = -1.04
    # Bin 1 is chosen. This is correct, it has a tighter fit.

    # item=3
    # bins_remain_cap = [5, 5]
    # Bin 0: cap=5, item=3 -> pot_rem=2. priority = -2 - 0.01*5 = -2.05
    # Bin 1: cap=5, item=3 -> pot_rem=2. priority = -2 - 0.01*5 = -2.05
    # Tie.

    # If we want to prioritize smaller bins *when fits are equal*:
    # Let's use `-bins_remain_cap[fit_mask]` as the primary, and `-potential_remaining_cap` as secondary.
    # Priority = `-bins_remain_cap[fit_mask] - alpha * potential_remaining_cap`
    # Bin A: cap=5, item=3 -> pot_rem=2. priority = -5 - 0.01*2 = -5.02
    # Bin B: cap=4, item=3 -> pot_rem=1. priority = -4 - 0.01*1 = -4.01
    # Bin B is chosen. It has a smaller initial capacity and a tighter fit.

    # The reflection emphasizes "minimal remaining capacity (tight fits)" first.
    # So, `-potential_remaining_cap` must be primary.
    # Let's stick to: `priorities[fit_mask] = -potential_remaining_cap` as the core.
    # The "favoring fuller bins" aspect is implicitly handled by tight fits.
    # A bin that is already more full will have less remaining capacity, thus a smaller `potential_remaining_cap`.

    # Final formulation based on prioritizing minimal remaining capacity after fit.
    # Maximize `-potential_remaining_cap` which means minimize `potential_remaining_cap`.
    # The primary goal is tight fits.

    # A slight adjustment to make it more sensitive to very small positive slacks,
    # and to align with "inverted slack" which might imply higher values for smaller slacks.
    # `1.0 / (1.0 + slack)` is a good choice for this.

    # Let's go back to the `1.0 / (1.0 + slack)` form, as it directly penalizes larger slacks.
    # This seems to be the most direct implementation of "tight fits".
    slack = bins_remain_cap[fit_mask] - item
    priorities[fit_mask] = 1.0 / (1.0 + slack)

    # This prioritizes bins with 0 slack (perfect fit) with priority 1.0,
    # then bins with slack 1 (priority 0.5), slack 2 (priority 0.33), etc.
    # This directly favors minimal remaining capacity.

    # To address "favoring fuller bins", it's implicitly handled because
    # bins that are already fuller will tend to have smaller slacks.
    # For example, if item=10:
    # Bin A: cap=12, slack=2, priority=1/3
    # Bin B: cap=20, slack=10, priority=1/11
    # Bin A is chosen, which is a tighter fit and also started with less capacity.

    return priorities
```
