```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using a refined strategy.

    This strategy prioritizes bins that offer the "tightest fit" for the item,
    meaning the remaining capacity after insertion is minimized. This is achieved
    by maximizing `1.0 / (1.0 + slack)`, where slack is `remaining_capacity - item_size`.
    Additionally, it introduces a secondary preference for bins that are already
    "fuller" (i.e., have less initial remaining capacity) among those offering similar
    tight fits, to promote more balanced packing. This favors bins that are closer to
    being full, making it easier to close them sooner.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
        Bins that cannot fit the item will have a priority of 0.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins where the item can fit
    fit_mask = bins_remain_cap >= item

    # If no bins can fit the item, return all zeros
    if not np.any(fit_mask):
        return priorities

    # Calculate the slack for bins that can fit the item
    # Slack = remaining_capacity - item_size
    slack = bins_remain_cap[fit_mask] - item

    # Primary scoring: Prioritize minimal slack (tightest fits).
    # Use `1.0 / (1.0 + slack)`: higher score for smaller slack.
    # A slack of 0 gives priority 1.0.
    primary_score = 1.0 / (1.0 + slack)

    # Secondary scoring: Among bins with similar slacks, prioritize those that are
    # "fuller" initially. This means preferring bins with smaller original `bins_remain_cap`.
    # A small negative term `bins_remain_cap` will be added to the priority.
    # We add a small epsilon to `slack` before inverting to avoid division by zero
    # if an item perfectly fits into a bin (slack=0). However, since we are
    # using `1.0 + slack`, this is not strictly necessary as `1.0 + 0 = 1.0`.
    # The secondary score is simply the negative of the bin's remaining capacity.
    # This implicitly favors bins that are closer to being full (smaller remaining capacity).
    secondary_score = -bins_remain_cap[fit_mask]

    # Combine scores: Maximize primary score (tightest fit), then secondary score (fuller bin).
    # A simple addition works here, as the primary score is generally more significant.
    # Normalization is not strictly required by the prompt but can be useful for
    # comparing different scoring functions or if probabilities are needed.
    # For this function, we are returning raw scores, and the selection mechanism
    # (e.g., argmax) will handle picking the highest score.
    priorities[fit_mask] = primary_score + secondary_score

    return priorities
```
