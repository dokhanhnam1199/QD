```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Minimum Remaining Capacity strategy.

    This strategy prioritizes bins that will have the least remaining capacity
    after the item is placed, aiming to fill bins as tightly as possible.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins where the item can fit
    fit_mask = bins_remain_cap >= item

    # For bins that can fit the item, calculate the remaining capacity *after* placing the item.
    # We want to prioritize bins with the *minimum* remaining capacity.
    # To achieve this with a maximization-based priority system (higher score is better),
    # we can use the negative of the remaining capacity as the score.
    # E.g., if remaining capacities after placement are [2, 1, 5], we want to pick the one with 1.
    # Scores would be [-2, -1, -5]. The maximum score is -1.
    potential_remaining_cap = bins_remain_cap[fit_mask] - item

    # Assign scores: negative of the remaining capacity.
    # Higher value (less negative) means more remaining capacity, lower value (more negative) means less remaining capacity.
    # Thus, to pick the bin with the *least* remaining capacity, we want the most negative score.
    # So, we want to maximize `potential_remaining_cap` directly, if we consider the definition of "minimum remaining capacity" as the target.
    # However, the problem statement asks for "highest priority score". If higher score means better,
    # and we want minimum remaining capacity, we need to map minimum remaining capacity to a maximum score.
    # This can be done by `1 / (1 + remaining_capacity)` as in v1, or `MAX_CAP - remaining_capacity`.
    # A simple inversion like `-remaining_capacity` works if remaining capacities are positive.
    # But if we have capacities [10, 20, 30] and item=5, remaining are [5, 15, 25]. We want 5.
    # Using `-remaining_capacity`: [-5, -15, -25]. Max score is -5. This selects the bin with 5 remaining.
    # This seems correct for "minimum remaining capacity".

    # Let's refine: The goal is to minimize `bins_remain_cap - item`.
    # If we use `bins_remain_cap - item` directly as the score, we'd pick the bin with the most remaining capacity.
    # If we use `-(bins_remain_cap - item)`, we'd pick the bin with the least remaining capacity.
    # This interpretation aligns with the "tightest fit" goal.

    # So, for bins that fit, the priority is the negative of the remaining capacity after placement.
    priorities[fit_mask] = -potential_remaining_cap

    return priorities
```
