```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Best Fit strategy.

    The Best Fit strategy aims to place the item into the bin where it leaves the
    least amount of remaining capacity. This is achieved by prioritizing bins
    that have just enough space for the item.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
        A higher score indicates a higher priority. Bins that cannot fit the item
        will have a priority of 0.
    """
    # Mask for bins that can fit the item
    can_fit_mask = bins_remain_cap >= item

    # Initialize priorities to 0
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # For bins that can fit the item, calculate the remaining capacity after placing the item
    fitting_bins_remain_cap = bins_remain_cap[can_fit_mask]
    waste = fitting_bins_remain_cap - item

    # Best Fit prioritizes bins with the minimum waste (smallest positive difference).
    # To map smaller waste to higher priorities, we can use the inverse of (1 + waste).
    # This maps a waste of 0 to a priority of 1, and larger waste to smaller priorities.
    priorities[can_fit_mask] = 1.0 / (1.0 + waste)

    return priorities
```
