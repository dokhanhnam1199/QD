```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using a strategy that prioritizes bins with minimal remaining space after packing (tightest fit), and among those, favors bins that are fuller (less remaining capacity).

    This strategy is a refinement of Best Fit, aiming to pack items tightly while
    also considering the overall fullness of the bins for tie-breaking.

    1. Primary objective: Minimize the "slack" (remaining capacity - item size).
       Bins with slack closer to zero are preferred. This is achieved by maximizing
       a term inversely proportional to slack, or directly using negative slack
       where smaller negative slack (closer to zero) is better.
    2. Secondary objective: Among bins with the same slack, prefer bins that are fuller.
       A fuller bin has less remaining capacity. This is achieved by preferring
       bins with smaller `bins_remain_cap`.

    The combined priority aims to achieve a lexicographical ordering: minimize slack first,
    then minimize remaining capacity. This can be modeled by maximizing a score like
    `-(slack + alpha * bins_remain_cap)`, where `alpha` is a scaling factor. For simplicity
    and to directly reflect the two objectives, we can use `-(slack + bins_remain_cap)`.
    The highest priority (least negative value) will correspond to the bin with the smallest
    sum of slack and remaining capacity.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Returns:
        Array of same size as bins_remain_cap with priority score of each bin.
        A higher score (less negative) indicates a higher priority. Bins that cannot fit
        the item will have a priority of negative infinity (or a very large negative number)
        to ensure they are never chosen if fittable bins exist.
    """
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Identify bins that can accommodate the item
    can_fit_mask = bins_remain_cap >= item

    if not np.any(can_fit_mask):
        # No bin can fit the item, return all -inf priorities
        return priorities

    # Calculate slack for fittable bins
    # Slack = remaining_capacity - item_size
    fittable_bins_capacities = bins_remain_cap[can_fit_mask]
    slack = fittable_bins_capacities - item

    # Combine objectives: Minimize slack, then minimize remaining capacity.
    # We want to maximize a score that reflects this.
    # Using `-(slack + bins_remain_cap)` achieves this.
    # A smaller (slack + bins_remain_cap) value results in a larger (less negative) priority.
    # Example:
    # Bin A: slack=0, rem_cap=5  => sum=5, priority = -5
    # Bin B: slack=0, rem_cap=10 => sum=10, priority = -10
    # Bin C: slack=1, rem_cap=5  => sum=6, priority = -6
    # Bin D: slack=1, rem_cap=10 => sum=11, priority = -11
    # This prioritizes A > C > B > D, which is the desired order.
    combined_score = -(slack + fittable_bins_capacities)

    priorities[can_fit_mask] = combined_score

    return priorities
```
