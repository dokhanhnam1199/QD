```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin, prioritizing fuller bins first, then best fit.

    This heuristic prioritizes bins that are already fuller (have less remaining capacity).
    If multiple bins have the same minimal remaining capacity, it then applies the Best Fit
    principle to choose the one that results in the least waste. This aims to pack items
    more densely by preferring bins that are closer to being full. The strategy aims for
    deterministic behavior, prioritizing fuller bins, and then best fit among equally full bins.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Returns:
        Array of same size as bins_remain_cap with priority score of each bin.
        Higher score indicates higher priority. Bins that cannot fit the item will have a priority of 0.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    epsilon = 1e-9  # Small value to prevent division by zero

    # Identify bins that can fit the item
    can_fit_mask = bins_remain_cap >= item

    if not np.any(can_fit_mask):
        return priorities

    fittable_bins_capacities = bins_remain_cap[can_fit_mask]

    # Primary objective: Prioritize fuller bins (smaller remaining capacity).
    # Score component 1: Inverse of remaining capacity. Higher score for smaller capacity.
    fullness_score_component = 1.0 / (fittable_bins_capacities + epsilon)

    # Secondary objective: Among equally full bins, prioritize best fit (minimize waste).
    # Waste = remaining_capacity - item_size.
    # Score component 2: Inverse of waste. Higher score for smaller waste.
    waste = fittable_bins_capacities - item
    best_fit_score_component = 1.0 / (waste + epsilon)

    # Combine scores: Summing the two components gives a higher priority to bins that are
    # both fuller and offer a better fit. This combination prioritizes fullness first
    # due to the nature of inverse functions, and then best fit as a tie-breaker or
    # secondary factor.
    # Example:
    # Bin A: remain_cap=0.6, item=0.5 -> waste=0.1. Score = 1/0.6 + 1/0.1 = 1.667 + 10 = 11.667
    # Bin B: remain_cap=0.7, item=0.5 -> waste=0.2. Score = 1/0.7 + 1/0.2 = 1.428 + 5 = 6.428
    # Bin C: remain_cap=0.6, item=0.4 -> waste=0.2. Score = 1/0.6 + 1/0.2 = 1.667 + 5 = 6.667
    # Bin A (fullest, best fit) gets highest score. Bin C (equally full as A, worse fit) gets second highest. Bin B (less full, worse fit) gets lowest.
    # This combination correctly prioritizes fullness, then best fit.
    combined_scores = fullness_score_component + best_fit_score_component

    priorities[can_fit_mask] = combined_scores

    return priorities
```
