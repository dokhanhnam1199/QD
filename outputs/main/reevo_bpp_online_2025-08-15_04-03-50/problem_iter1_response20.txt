```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using a First Fit strategy.

    The First Fit strategy aims to place the item in the first bin that has enough
    remaining capacity. For a priority function, we can assign a higher priority
    to bins that can accommodate the item.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Assign a high priority to bins that have enough capacity for the item.
    # Assign a low priority to bins that do not have enough capacity.
    # This simple approach prioritizes bins that can fit the item,
    # and the 'first fit' nature is handled by the selection mechanism
    # that iterates through these priorities.
    priorities = np.where(bins_remain_cap >= item, 1.0, 0.0)

    # A slightly more nuanced approach could consider how "tight" the fit is.
    # However, for pure First Fit, just being able to fit is the primary criterion.
    # For this 'priority' function to work with a 'highest priority score'
    # selection, we can assign higher scores to bins that fit.

    # A common way to implement First Fit with a priority queue
    # is to ensure that the bins that are encountered first and have
    # capacity are chosen. The prompt asks for a priority score where
    # the *highest* score is chosen. This is slightly contradictory
    # to a strict "first encountered" rule unless we can encode that
    # order.

    # Let's assume the selection process *iterates* through the returned
    # priorities array and picks the first one with a non-zero (or highest)
    # priority. To mimic First Fit directly: we want the *earliest* bin
    # that fits to have the highest priority.

    # A simple way to encode "first fit" into a priority score where higher is better:
    # Give a high priority to the *first* bin that can fit the item, and lower
    # or zero priority to others. This still doesn't quite capture "first fit"
    # if multiple bins fit.

    # Let's re-interpret: the priority function gives a score to each bin.
    # The *selection* mechanism then picks the bin based on these scores.
    # If we want to strictly follow First Fit, the priority should reflect
    # the *order* of the bins.

    # Let's assign priority based on index if it fits. Lower index = higher priority.
    # However, the prompt says "highest priority score". So, if bin 0 fits,
    # it should have a higher score than bin 5 if bin 5 also fits.

    # A direct implementation of "highest priority score" where higher means better,
    # and we want to select the *first* bin that fits.
    # We can give a very large number to the first bin that fits, and a smaller number
    # to subsequent bins that fit, and 0 to those that don't.

    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    bin_indices = np.arange(len(bins_remain_cap))

    # Assign a score that favors earlier bins that fit.
    # We can give a score that decreases with index for bins that fit.
    # This way, the first bin that fits (smallest index) will have the highest score.
    fits_mask = bins_remain_cap >= item
    
    # If a bin fits, assign a priority. Higher priority for earlier bins.
    # Let's assign a priority score based on (number_of_bins - index).
    # This ensures that smaller indices (earlier bins) get higher priority scores.
    # For example, if there are 10 bins, index 0 gets 10, index 1 gets 9, ..., index 9 gets 1.
    num_bins = len(bins_remain_cap)
    priorities[fits_mask] = num_bins - bin_indices[fits_mask]

    # Alternatively, if we want to prioritize the *tightest* fit among those that fit,
    # but still honor the "first fit" concept by giving a bonus to earlier bins.
    # However, the prompt focuses on First Fit strategy. The core of First Fit is
    # to pick the first available bin. Encoding this directly into a priority score
    # where "highest score wins" is tricky without knowing the selection method.

    # Assuming selection iterates and picks the highest score:
    # To simulate "First Fit" behaviour (picking the *first* bin that fits),
    # we can assign a higher priority to bins earlier in the array if they fit.
    # Example: if bins_remain_cap = [5, 3, 7] and item = 4.
    # Bin 0 fits (5 >= 4)
    # Bin 1 does not fit (3 < 4)
    # Bin 2 fits (7 >= 4)
    # For First Fit, we'd pick Bin 0.
    # To achieve this with highest score: Bin 0 needs highest score.
    # We can assign priority based on (MaxPossiblePriority - Index), for bins that fit.
    # Let's use a large constant for "MaxPossiblePriority".
    # If we use `num_bins - bin_indices[fits_mask]`, then for the example above:
    # Bin 0: fits, index=0, num_bins=3. Priority = 3 - 0 = 3.
    # Bin 1: doesn't fit. Priority = 0.
    # Bin 2: fits, index=2, num_bins=3. Priority = 3 - 2 = 1.
    # Priorities: [3, 0, 1]. The highest score is 3, corresponding to bin 0.

    return priorities
```
