```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    The Exact Fit First (EFF) strategy prioritizes bins that can accommodate the item
    and have the smallest remaining capacity after placement, as this aims to leave
    larger remaining capacities in other bins for potentially larger future items.
    A large positive value is assigned to bins that can fit the item, and a
    negative value (or zero) for bins that cannot.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Create a mask for bins that have enough capacity for the item.
    can_fit_mask = bins_remain_cap >= item

    # Initialize priorities to a low value (e.g., negative infinity)
    # to indicate that bins that cannot fit the item have no priority.
    priorities = np.full_like(bins_remain_cap, -np.inf)

    # For bins that can fit the item, assign a priority based on the
    # Exact Fit First strategy: the bin with the smallest remaining capacity
    # *after* placing the item gets the highest priority.
    # This is equivalent to prioritizing bins with the smallest current remaining capacity.
    # We negate the remaining capacity so that smaller capacities result in higher (less negative) priority scores.
    # We add a small epsilon to the priority of bins that perfectly fit,
    # to prefer perfect fits over bins that have just enough space and more leftover.
    priorities[can_fit_mask] = -(bins_remain_cap[can_fit_mask] - item)

    # To strictly implement "Exact Fit First", we can also give a slight bonus
    # to bins where the remaining capacity *after* placement is exactly zero.
    perfect_fit_mask = (bins_remain_cap - item) == 0
    priorities[perfect_fit_mask] += 0.1 # A small bonus for a perfect fit

    return priorities
```
