{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin using a refined 'Almost Full Fit' strategy.\n\n    This strategy prioritizes bins that can fit the item and, after fitting,\n    will have the least remaining capacity (i.e., the 'tightest' fits).\n    It also introduces a slight bias towards bins that have more overall remaining capacity\n    among those that offer a similarly tight fit, aiming to preserve very tight fits for\n    potentially smaller items later and to explore fuller bins.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Identify bins where the item can fit\n    fit_mask = bins_remain_cap >= item\n\n    # Calculate the remaining capacity if the item is placed in each fitting bin\n    potential_remaining_cap_fitting = bins_remain_cap[fit_mask] - item\n\n    # The core idea of \"Almost Full Fit\" is to minimize the remaining capacity after insertion.\n    # So, we want to prioritize bins with smaller `potential_remaining_cap_fitting`.\n    # We can use the inverse of (1 + slack) as a score, where slack is `potential_remaining_cap_fitting`.\n    # This gives higher scores to smaller slacks. A slack of 0 gets a priority of 1.0.\n    # A slack of 1 gets 0.5, etc.\n    # This part directly addresses the \"tight fit\" preference.\n\n    # To introduce a preference for fuller bins or to break ties in slack,\n    # we can add a secondary criterion. A common approach is to prefer bins\n    # that are already fuller among those with similar slacks.\n    # This can be approximated by using the original `bins_remain_cap` as a factor.\n    # However, a simpler way to break ties is to add a small, increasing value based\n    # on the original remaining capacity, ensuring that if two bins have the same slack,\n    # the one that was originally fuller (and thus has less capacity now) gets a slightly\n    # higher priority if we were to simply maximize `-potential_remaining_cap`.\n\n    # Let's refine the scoring to prioritize smaller `potential_remaining_cap_fitting`\n    # but also provide a subtle bias towards bins that were not excessively large to begin with,\n    # while still favoring tighter fits.\n\n    # Strategy: Prioritize based on `1.0 / (1.0 + slack)`.\n    # To break ties or encourage slightly less full bins when slacks are equal (to save tighter fits),\n    # we can also consider the original `bins_remain_cap`.\n    # A common heuristic for \"Best Fit\" or variations is to pick the bin with the smallest remaining capacity\n    # *after* insertion. This is `potential_remaining_cap_fitting`.\n    # To maximize this (i.e., get the smallest positive remaining capacity), we can use `-(potential_remaining_cap_fitting)`.\n    # To ensure robustness and avoid extremely large bins being picked if they result in a similar \"tightness\",\n    # we can also add a small factor related to the original capacity.\n\n    # Let's try a scoring function that prioritizes minimum slack, but with a slight\n    # nudge for bins that were not excessively large.\n    # Consider the score as: (priority for slack) + (small bonus for being less full initially, to break ties in favor of tighter bins).\n    # Or, more simply, maximize `-potential_remaining_cap_fitting`.\n\n    # The prompt reflection mentions \"Prioritize fitting bins, favoring those with minimal remaining capacity (tight fits).\"\n    # This is achieved by `1.0 / (1.0 + slack)`.\n    # It also suggests \"balancing with random exploration for robustness\", but this function\n    # is deterministic. \"Favoring fuller bins using inverted slack\" is captured by `1/(1+slack)` where slack is minimized.\n\n    # Let's re-evaluate based on the reflection: \"Prioritize bins that have just enough capacity to fit the item,\n    # with a preference for bins that will have less remaining capacity after the item is added.\"\n    # This is still `1.0 / (1.0 + slack)`.\n\n    # A common variant to break ties or introduce exploration is to add a random component.\n    # However, for deterministic heuristics, tie-breaking is key.\n    # If multiple bins have the same minimal slack, which one to pick?\n    # Some strategies pick the one with the smallest original capacity (First Fit Decreasing logic),\n    # or the one with the largest original capacity (to consolidate larger bins).\n\n    # Let's use the inverse slack `1.0 / (1.0 + slack)` as the primary score.\n    # For tie-breaking, if slacks are equal, we might prefer the bin that was originally less full\n    # (higher `bins_remain_cap` among those with minimal slack). This helps keep the very tightest\n    # bins available for future very small items.\n    # To implement this, we can add a small value proportional to `bins_remain_cap[fit_mask]`\n    # to the primary score, or use a lexicographical sort implicitly.\n\n    # Score = (1.0 / (1.0 + slack)) + small_epsilon * bins_remain_cap[fit_mask]\n    # This would prioritize smaller slack, and for equal slacks, it would prioritize bins\n    # that originally had more capacity. This seems to align with \"balancing with random exploration\"\n    # by making choices less extreme in favoring already full bins.\n\n    slack = bins_remain_cap[fit_mask] - item\n    # Primary score: higher for smaller slack\n    primary_score = 1.0 / (1.0 + slack)\n\n    # Secondary score for tie-breaking or introducing slight variation:\n    # Adding a small fraction of the original remaining capacity.\n    # This boosts scores for bins that were less full if they have the same slack.\n    # We use a small multiplier (e.g., 1e-3) to ensure slack is the dominant factor.\n    secondary_score = 1e-3 * bins_remain_cap[fit_mask]\n\n    priorities[fit_mask] = primary_score + secondary_score\n\n    # Ensure that bins that don't fit have a priority of 0.\n    # The initialisation to zeros and `fit_mask` already handle this.\n\n    return priorities\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin using a strategy that prioritizes bins that have *just enough* space, and among those, favors fuller bins.\n\n    This strategy is a variation of Best Fit, aiming to minimize wasted space.\n    It prioritizes bins where `bins_remain_cap - item` is smallest and non-negative.\n    A secondary preference is given to bins that are fuller (have less remaining capacity)\n    among those that can fit the item.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        A higher score indicates a higher priority. Bins that cannot fit the item\n        will have a priority of 0.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Create a boolean mask for bins that can accommodate the item\n    can_fit_mask = bins_remain_cap >= item\n\n    # For bins that can fit the item, calculate the \"slack\" or \"waste\"\n    # This is the remaining capacity after placing the item.\n    slack = bins_remain_cap[can_fit_mask] - item\n\n    # To prioritize bins with the least slack (best fit), we can use the\n    # inverse of slack. A smaller slack should result in a higher priority.\n    # Add a small epsilon to avoid division by zero if slack is 0.\n    # Higher priority for smaller slack values.\n    # We can use `1.0 / (slack + epsilon)` or `-slack`.\n    # Using `-slack` directly favors bins with minimal non-negative slack.\n    # For example, slack of 0 gets priority 0, slack of 1 gets -1, slack of 5 gets -5.\n    # We want to maximize this value, so we use `-slack`.\n\n    # To incorporate the preference for fuller bins (which is implied by smaller\n    # `bins_remain_cap` among fitting bins), we can combine this with the slack.\n    # A simple approach is to subtract the original remaining capacity from the\n    # inverse slack, or simply use a combination.\n\n    # Let's prioritize bins with minimal slack.\n    # If slack is 0, priority should be highest.\n    # If slack is positive, priority should be lower.\n    # We can map slack to priority. A common mapping for \"minimize X\" to \"maximize Y\" is Y = -X or Y = 1/(1+X).\n    # Using `-slack` gives higher values for smaller slacks.\n    # We also want to prefer bins that were initially fuller (smaller bins_remain_cap).\n    # This means that among bins with the same slack, the one with the smaller original\n    # `bins_remain_cap` should be preferred.\n\n    # Let's consider the inverse of the remaining capacity as a secondary sorting key.\n    # A higher inverse remaining capacity (meaning lower original remaining capacity, i.e. fuller bin) is better.\n    # So, for fitting bins, we want to maximize: `priority = -slack + C * (1 / bins_remain_cap[can_fit_mask])`\n    # where C is a weighting factor. A simpler approach is to rank them based on slack first,\n    # and then remaining capacity.\n\n    # A common heuristic for Best Fit is to sort by remaining capacity and pick the first one.\n    # For priority, we want the bin with the smallest `bins_remain_cap - item` to have the highest score.\n    # This means `bins_remain_cap - item` should be minimized.\n    # So, we can use `- (bins_remain_cap - item)` as a primary score.\n    # To break ties, or to add a preference for fuller bins, we can add a term that\n    # is proportional to `1.0 / bins_remain_cap`.\n\n    # Let's try to prioritize based on minimal slack first.\n    # A bin with slack 0 is best.\n    # A bin with slack 1 is second best.\n    # ...\n    # For bins with the same slack, the one with less remaining capacity (fuller) is better.\n    # This implies we want to maximize `-(bins_remain_cap[i] - item)` and secondarily maximize `bins_remain_cap[i]`.\n\n    # A common approach for \"best fit\" is to aim for a score where smaller `bins_remain_cap - item` are better.\n    # So, we can use a score like `1.0 / (1.0 + (bins_remain_cap[can_fit_mask] - item))`.\n    # This gives a value between 0 and 1, with 1 for a perfect fit (slack=0).\n\n    # To add a preference for fuller bins among those with the same slack,\n    # we can add a secondary term that increases with decreasing `bins_remain_cap`.\n    # For example, `1.0 / (1.0 + slack)` could be the primary score.\n    # A secondary score could be `1.0 / bins_remain_cap`.\n    # Combined: `priority = 1.0 / (1.0 + slack) + weight * (1.0 / bins_remain_cap[can_fit_mask])`\n\n    # However, the reflection implies prioritizing fuller bins directly.\n    # A simple way to prioritize fuller bins is to use the inverse of their remaining capacity.\n    # `1.0 / bins_remain_cap[can_fit_mask]` gives higher scores to fuller bins.\n    # But this doesn't directly address the \"just enough space\" aspect of Best Fit.\n\n    # Let's refine the Best Fit idea: we want the smallest *positive* slack.\n    # So, `slack = bins_remain_cap[can_fit_mask] - item`.\n    # We want to minimize `slack`.\n    # For priority, we want to maximize a function of `slack`.\n    # A simple way is `priorities[can_fit_mask] = -slack`.\n    # This means slack 0 -> priority 0, slack 1 -> priority -1, slack 5 -> priority -5.\n    # Higher priority for smaller slack.\n\n    # Now, consider the \"preference for fuller bins\". This means that among bins\n    # with the same slack, we prefer the one that was more full to begin with.\n    # So if `bins_remain_cap[i] - item == bins_remain_cap[j] - item`, and\n    # `bins_remain_cap[i] < bins_remain_cap[j]`, then bin `i` is preferred.\n    # This implies that `bins_remain_cap[i]` itself should contribute to higher priority.\n\n    # We can combine these: maximize `-slack` and maximize `bins_remain_cap[can_fit_mask]`.\n    # A potential priority score could be: `priority = -(bins_remain_cap[can_fit_mask] - item) + alpha * bins_remain_cap[can_fit_mask]`\n    # where `alpha` is a small positive weight to ensure slack is primary.\n\n    # Let's try a simpler, more direct approach that captures both aspects.\n    # Prioritize bins with the smallest positive `slack`.\n    # Among those with the same slack, prioritize bins with the smallest `bins_remain_cap`.\n\n    # One way to achieve this is to use a composite score.\n    # The value `bins_remain_cap[can_fit_mask] - item` should be minimized.\n    # The value `bins_remain_cap[can_fit_mask]` should also be minimized (to favor fuller bins).\n    # We can create a composite key for sorting: `(slack, bins_remain_cap[can_fit_mask])`.\n    # For priority, we want to maximize this composite key, but in reverse.\n    # So, we want to maximize `(-slack, -bins_remain_cap[can_fit_mask])`.\n\n    # A direct mapping to a single priority score:\n    # We want to maximize `1.0 / (1.0 + slack)` for best fit.\n    # To favor fuller bins, we can add a term like `1.0 / bins_remain_cap`.\n    # Let's use a scaling factor to balance these two objectives.\n\n    # A common technique for multiple objectives is to scale and sum.\n    # Objective 1: Minimize slack (maximize 1 / (1 + slack))\n    # Objective 2: Minimize bins_remain_cap (maximize 1 / bins_remain_cap)\n\n    # Let's normalize the slack and remaining capacities first, or use a well-behaved function.\n    # Using `1.0 / (1.0 + slack)` maps slack [0, inf) to priority (1, 0].\n    # Using `1.0 / bins_remain_cap` maps remaining_cap [item, inf) to priority (1/item, 0).\n\n    # Let's combine them directly:\n    # Higher priority for smaller slack AND smaller remaining_capacity.\n    # We can use a lexicographical ordering effect by careful function design.\n    # `priorities[can_fit_mask] = 1.0 / (bins_remain_cap[can_fit_mask] - item + 1e-9) * (1.0 / bins_remain_cap[can_fit_mask] + 1e-9)`\n    # This might over-prioritize very small remaining capacities regardless of slack.\n\n    # A more robust approach for \"just enough space\" (Best Fit):\n    # Prioritize bins where `bins_remain_cap - item` is minimized.\n    # Let `score_bf = -(bins_remain_cap[can_fit_mask] - item)`. Maximize this.\n    # For tie-breaking (prefer fuller bins), we want to maximize `bins_remain_cap[can_fit_mask]`.\n    # So, we want to maximize `score_bf` and secondarily `bins_remain_cap`.\n    # This can be achieved by `priority = score_bf + alpha * bins_remain_cap`.\n    # A suitable `alpha` would be small enough that `score_bf` dominates for same slack.\n\n    # Let's use a large multiplier for the secondary criterion to make it effective.\n    # Consider the remaining capacities themselves.\n    # We want to pick the bin with minimum `bins_remain_cap` that fits the item.\n    # If multiple bins have the same minimum `bins_remain_cap` that fits, pick the one with the smallest slack.\n    # This is a subtle ordering.\n\n    # The reflection states: \"prioritize fuller bins by inverting remaining capacity for better fit.\"\n    # This implies that if two bins can fit an item, the one that is *more full* is preferred.\n    # This sounds like a variation of First Fit Decreasing or Best Fit.\n    # \"Better fit\" usually means less waste.\n\n    # Let's reconsider the goal: \"prioritize bins that have *just enough* space, and among those, favors fuller bins.\"\n    # \"Just enough space\" implies minimizing `bins_remain_cap - item`.\n    # \"Favors fuller bins\" implies minimizing `bins_remain_cap`.\n\n    # So we want to minimize two values:\n    # 1. `slack = bins_remain_cap[can_fit_mask] - item`\n    # 2. `bins_remain_cap[can_fit_mask]`\n\n    # To maximize priority, we want to maximize functions of these.\n    # Maximize `-slack` and maximize `-bins_remain_cap`.\n    # A common approach is to combine them, e.g., `priority = -slack - alpha * bins_remain_cap`.\n    # Or, more directly: `priority = -(slack + alpha * bins_remain_cap)`.\n    # Here, `slack` is minimized first, and then `bins_remain_cap` is minimized.\n\n    # Let's assign a score that is inversely proportional to slack, and then inversely proportional to remaining capacity.\n    # `score1 = 1.0 / (slack + epsilon)`\n    # `score2 = 1.0 / bins_remain_cap[can_fit_mask]`\n    # `priorities[can_fit_mask] = score1 + weight * score2`\n\n    # Let's try to make the slack minimization dominant.\n    # If slack is 0, priority should be high.\n    # If slack is 0 and bin_rem_cap is 5, priority is X.\n    # If slack is 0 and bin_rem_cap is 10, priority is Y, where Y < X.\n    # If slack is 1, priority should be lower than X and Y.\n\n    # Let's use a score that heavily penalizes slack, and then uses remaining capacity.\n    # `priorities[can_fit_mask] = 1.0 / (1.0 + slack) - alpha * bins_remain_cap[can_fit_mask]`\n    # This would prioritize smaller slack, but then penalize larger remaining capacities.\n    # This sounds correct for \"just enough space\" and then \"fuller bins\".\n\n    # Let's use a small `alpha` to ensure the slack is the primary driver.\n    # A common strategy is to use `1.0 / (1.0 + slack)` and `1.0 / bins_remain_cap`.\n    # Combining them: `priorities[can_fit_mask] = 1.0 / (1.0 + slack) + 0.1 * (1.0 / bins_remain_cap[can_fit_mask])`\n    # The `0.1` is an arbitrary weight.\n\n    # A simpler interpretation of \"prioritize fuller bins by inverting remaining capacity\" might be:\n    # For best fit, we want `bins_remain_cap - item` to be minimal.\n    # So, prioritize bins with `bins_remain_cap` closest to `item`.\n    # Let `diff = bins_remain_cap[can_fit_mask] - item`. We want to minimize `diff`.\n    # The priority should be high for small `diff`.\n    # So, `priority = 1.0 / (diff + epsilon)`. This is Best Fit.\n\n    # Now, \"favors fuller bins\". This means, if `diff` is the same for two bins,\n    # the one with smaller `bins_remain_cap` is preferred.\n    # This implies that `bins_remain_cap` itself should positively contribute to priority.\n    # So, we want to maximize `1.0 / (diff + epsilon)` AND maximize `bins_remain_cap`.\n    # This is counter-intuitive. If fuller bins are preferred, it means smaller `bins_remain_cap`.\n    # So, we want to maximize `1.0 / (diff + epsilon)` AND maximize `(1.0 / bins_remain_cap)`.\n\n    # Let's try a direct mapping:\n    # We want to minimize `bins_remain_cap - item`. Let this be `waste`.\n    # We want to minimize `bins_remain_cap`.\n    # So, the ideal bin has small `waste` and small `bins_remain_cap`.\n    # For priority, we want to maximize `1.0 / (waste + epsilon)` and `1.0 / bins_remain_cap`.\n\n    # Combining: `priorities[can_fit_mask] = (1.0 / (slack + 1e-9)) * (1.0 / bins_remain_cap[can_fit_mask] + 1e-9)`\n    # This might scale too aggressively.\n\n    # Let's stick to the idea of minimizing `slack` AND `bins_remain_cap`.\n    # Maximize `-slack` and maximize `-bins_remain_cap`.\n    # Priority = `-slack - alpha * bins_remain_cap`\n\n    # Let's assign priorities based on `-(slack)` and then `-bins_remain_cap`.\n    # `priorities[can_fit_mask] = -(slack + bins_remain_cap[can_fit_mask])`\n    # This prioritizes bins with smaller `slack + bins_remain_cap`.\n    # If slack is 0, and remaining_cap is 5, sum is 5. Priority -5.\n    # If slack is 0, and remaining_cap is 10, sum is 10. Priority -10.\n    # This favors fuller bins when slack is the same.\n\n    # However, the prompt for v1 was \"preference for fuller bins\" by inverting remaining capacity.\n    # This usually implies something like `1.0 / bins_remain_cap`.\n    # So, the reflection means the *priority* should be higher for fuller bins.\n\n    # Let's try a composite score that directly favors smaller `slack` AND smaller `bins_remain_cap`.\n    # We can make `slack` the primary factor, and `bins_remain_cap` the secondary.\n    #\n    # For Best Fit, we want to minimize `slack = bins_remain_cap - item`.\n    # So, prioritize by `1.0 / (slack + epsilon)`.\n    #\n    # For preferring fuller bins, we want to minimize `bins_remain_cap`.\n    # So, prioritize by `1.0 / bins_remain_cap`.\n    #\n    # Combining these:\n    # We want to maximize `f(slack, bins_remain_cap)` where `f` increases with `1/slack` and `1/bins_remain_cap`.\n    # A simple additive approach:\n    # `priorities[can_fit_mask] = (1.0 / (slack + 1e-9)) + (1.0 / bins_remain_cap[can_fit_mask] + 1e-9)`\n    # This gives higher priority to bins with small slack AND small remaining capacity.\n    # The `+ 1e-9` in the second term is to avoid division by zero if the bin capacity itself is 0 (though unlikely in BPP).\n    # The first term `1.0 / (slack + 1e-9)` ensures Best Fit logic (smaller slack is better).\n    # The second term `1.0 / bins_remain_cap[can_fit_mask]` adds the preference for fuller bins.\n\n    priorities[can_fit_mask] = (1.0 / (slack + 1e-9)) + (1.0 / (bins_remain_cap[can_fit_mask] + 1e-9))\n\n    return priorities\n\n[Reflection]\nPrioritize minimal waste, then favor fuller bins by combining inverse slack and inverse capacity.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}