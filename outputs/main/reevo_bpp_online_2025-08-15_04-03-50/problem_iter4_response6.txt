```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Best Fit strategy with a slight random perturbation.

    The Best Fit strategy aims to minimize wasted space by selecting the bin that
    has the least remaining capacity after the item is placed. To encourage
    exploration and avoid getting stuck in local optima, a small random value is
    added to the priority of eligible bins.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Identify bins that can accommodate the item
    eligible_bins_mask = bins_remain_cap >= item

    # Initialize priorities to a very low value for bins that cannot accommodate the item.
    # This ensures they are never chosen.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    if np.any(eligible_bins_mask):
        # For eligible bins, calculate a priority based on the remaining capacity.
        # The Best Fit strategy prioritizes bins with the smallest remaining capacity
        # after placing the item. Therefore, we use -(bins_remain_cap - item).
        # A small random perturbation is added to break ties and introduce some
        # stochasticity, which can help in escaping local optima.
        # The smaller the remaining capacity after placement (bins_remain_cap - item),
        # the higher the priority (less negative value).
        priorities[eligible_bins_mask] = -(bins_remain_cap[eligible_bins_mask] - item) + np.random.rand(np.sum(eligible_bins_mask)) * 1e-6

    return priorities
```
