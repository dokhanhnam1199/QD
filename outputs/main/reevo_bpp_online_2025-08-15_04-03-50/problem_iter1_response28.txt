```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Implements the Epsilon-Greedy strategy for online Bin Packing.

    The priority is determined by a balance between greedy exploration (picking
    the bin with the most remaining capacity) and random exploration.

    Args:
        item: Size of the item to be packed.
        bins_remain_cap: A numpy array where each element is the remaining
                         capacity of a bin.

    Returns:
        A numpy array of the same size as bins_remain_cap, where each element
        is the priority score for packing the item into the corresponding bin.
    """
    epsilon = 0.1  # Exploration rate
    num_bins = len(bins_remain_cap)
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify valid bins (those that can fit the item)
    valid_bins_mask = bins_remain_cap >= item

    # If no bins can fit the item, return zero priorities
    if not np.any(valid_bins_mask):
        return priorities

    # Calculate greedy priorities for valid bins
    # Higher remaining capacity means higher priority
    greedy_priorities = np.zeros_like(bins_remain_cap, dtype=float)
    greedy_priorities[valid_bins_mask] = bins_remain_cap[valid_bins_mask]

    # Introduce randomness for exploration
    random_priorities = np.random.rand(num_bins) * 0.1 # Small random exploration bonus

    # Combine greedy and random choices using epsilon-greedy logic
    # With probability epsilon, choose a random valid bin
    # With probability 1-epsilon, choose the best greedy valid bin
    # For simplicity in priority assignment, we can think of it as:
    # most bins get a base greedy score, some get an extra boost for randomness.

    # Assign base priorities based on greedy choice (if valid)
    priorities[valid_bins_mask] = greedy_priorities[valid_bins_mask]

    # Add a small random component to all bins for exploration
    priorities += random_priorities

    # Normalize priorities to prevent excessively large values and ensure
    # a more stable distribution, especially if capacities are very large.
    # We'll normalize based on the maximum possible priority to keep relative
    # differences meaningful.
    max_priority = np.max(priorities[valid_bins_mask]) if np.any(valid_bins_mask) else 1.0
    if max_priority > 0:
        priorities /= max_priority

    # Ensure that bins that cannot fit the item have zero priority
    priorities[~valid_bins_mask] = 0.0

    return priorities
```
