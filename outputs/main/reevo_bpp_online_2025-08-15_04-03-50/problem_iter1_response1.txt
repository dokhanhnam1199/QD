```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Best Fit strategy.

    The Best Fit strategy aims to place the item into the bin where it leaves the
    least amount of remaining capacity. This is achieved by prioritizing bins
    that have just enough space for the item.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
        A higher score indicates a higher priority. Bins that cannot fit the item
        will have a priority of 0.
    """
    # Calculate the remaining capacity if the item is placed in each bin.
    # Only consider bins that have enough capacity to hold the item.
    potential_remaining_cap = bins_remain_cap - item
    
    # Bins that cannot fit the item should have a priority of 0.
    # We can achieve this by setting their priority to a very low negative value
    # or by filtering them out. Here, we assign 0 priority to bins that cannot fit.
    can_fit_mask = bins_remain_cap >= item
    
    # The Best Fit strategy prioritizes bins that result in the *smallest*
    # positive remaining capacity. This means we want to minimize (bins_remain_cap - item).
    # A higher priority should be given to smaller values of (bins_remain_cap - item).
    # To map smaller (bins_remain_cap - item) to higher priorities, we can use
    # the negative of these values, or a function that is inversely related.
    #
    # A common way to implement "best fit" is to calculate the "waste"
    # (bins_remain_cap - item) and then select the bin with the minimum waste.
    # For a priority function, we want the highest priority for the minimum waste.
    #
    # Consider the following:
    # If we want to minimize `waste = bins_remain_cap - item`, then
    # we want the largest `priority = -waste`.
    #
    # So, for bins where `can_fit_mask` is True, the priority is `-(bins_remain_cap - item)`.
    # For bins where `can_fit_mask` is False, the priority is 0.
    
    priorities = np.zeros_like(bins_remain_cap)
    
    # For bins that can fit the item, calculate the priority.
    # The priority is the negative of the remaining capacity after fitting the item.
    # This ensures that bins with less remaining space (better fit) get higher priority.
    # We invert the concept: smaller positive differences are better.
    # `priorities = -(bins_remain_cap - item)` would work, but a slightly adjusted
    # approach can be more robust if we want to differentiate more clearly between
    # "perfect fits" and "almost perfect fits".
    #
    # A simple way to achieve "best fit" priority is to assign higher priority
    # to the smallest positive difference.
    # Let's assign priority as 1 / (1 + remaining_capacity_after_fit) for fitting bins.
    # This maps smaller remaining capacities to larger priority values.
    # Adding 1 in the denominator prevents division by zero and scales priorities.
    
    # We want to maximize `bins_remain_cap - item` to be as close to 0 as possible,
    # for the bins that can fit the item.
    # So, if `bins_remain_cap[i] >= item`, we want a high priority for small `bins_remain_cap[i] - item`.
    # A good heuristic for this is to use `1.0 / (1.0 + (bins_remain_cap[i] - item))`
    # This maps the smallest non-negative difference to the highest priority (close to 1).
    # For example, if remaining cap is 10 and item is 7, difference is 3. Priority = 1/(1+3) = 0.25
    # If remaining cap is 10 and item is 9, difference is 1. Priority = 1/(1+1) = 0.5
    # If remaining cap is 10 and item is 10, difference is 0. Priority = 1/(1+0) = 1.0
    
    fitting_bins_remain_cap = bins_remain_cap[can_fit_mask]
    
    # Calculate the "cost" or "waste" for fitting bins
    waste = fitting_bins_remain_cap - item
    
    # Assign priorities: higher priority for smaller waste.
    # We use 1 / (1 + waste) to ensure priorities are between 0 and 1,
    # and smaller waste gets a higher score.
    priorities[can_fit_mask] = 1.0 / (1.0 + waste)
    
    # For bins that cannot fit the item, their priority remains 0,
    # which means they will not be chosen if any bin can fit the item.
    
    return priorities
```
