{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin using a First Fit strategy.\n\n    The First Fit strategy aims to place the item in the first bin that has enough\n    remaining capacity. For a priority function, we can assign a higher priority\n    to bins that can accommodate the item.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Assign a high priority to bins that have enough capacity for the item.\n    # Assign a low priority to bins that do not have enough capacity.\n    # This simple approach prioritizes bins that can fit the item,\n    # and the 'first fit' nature is handled by the selection mechanism\n    # that iterates through these priorities.\n    priorities = np.where(bins_remain_cap >= item, 1.0, 0.0)\n\n    # A slightly more nuanced approach could consider how \"tight\" the fit is.\n    # However, for pure First Fit, just being able to fit is the primary criterion.\n    # For this 'priority' function to work with a 'highest priority score'\n    # selection, we can assign higher scores to bins that fit.\n\n    # A common way to implement First Fit with a priority queue\n    # is to ensure that the bins that are encountered first and have\n    # capacity are chosen. The prompt asks for a priority score where\n    # the *highest* score is chosen. This is slightly contradictory\n    # to a strict \"first encountered\" rule unless we can encode that\n    # order.\n\n    # Let's assume the selection process *iterates* through the returned\n    # priorities array and picks the first one with a non-zero (or highest)\n    # priority. To mimic First Fit directly: we want the *earliest* bin\n    # that fits to have the highest priority.\n\n    # A simple way to encode \"first fit\" into a priority score where higher is better:\n    # Give a high priority to the *first* bin that can fit the item, and lower\n    # or zero priority to others. This still doesn't quite capture \"first fit\"\n    # if multiple bins fit.\n\n    # Let's re-interpret: the priority function gives a score to each bin.\n    # The *selection* mechanism then picks the bin based on these scores.\n    # If we want to strictly follow First Fit, the priority should reflect\n    # the *order* of the bins.\n\n    # Let's assign priority based on index if it fits. Lower index = higher priority.\n    # However, the prompt says \"highest priority score\". So, if bin 0 fits,\n    # it should have a higher score than bin 5 if bin 5 also fits.\n\n    # A direct implementation of \"highest priority score\" where higher means better,\n    # and we want to select the *first* bin that fits.\n    # We can give a very large number to the first bin that fits, and a smaller number\n    # to subsequent bins that fit, and 0 to those that don't.\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_indices = np.arange(len(bins_remain_cap))\n\n    # Assign a score that favors earlier bins that fit.\n    # We can give a score that decreases with index for bins that fit.\n    # This way, the first bin that fits (smallest index) will have the highest score.\n    fits_mask = bins_remain_cap >= item\n    \n    # If a bin fits, assign a priority. Higher priority for earlier bins.\n    # Let's assign a priority score based on (number_of_bins - index).\n    # This ensures that smaller indices (earlier bins) get higher priority scores.\n    # For example, if there are 10 bins, index 0 gets 10, index 1 gets 9, ..., index 9 gets 1.\n    num_bins = len(bins_remain_cap)\n    priorities[fits_mask] = num_bins - bin_indices[fits_mask]\n\n    # Alternatively, if we want to prioritize the *tightest* fit among those that fit,\n    # but still honor the \"first fit\" concept by giving a bonus to earlier bins.\n    # However, the prompt focuses on First Fit strategy. The core of First Fit is\n    # to pick the first available bin. Encoding this directly into a priority score\n    # where \"highest score wins\" is tricky without knowing the selection method.\n\n    # Assuming selection iterates and picks the highest score:\n    # To simulate \"First Fit\" behaviour (picking the *first* bin that fits),\n    # we can assign a higher priority to bins earlier in the array if they fit.\n    # Example: if bins_remain_cap = [5, 3, 7] and item = 4.\n    # Bin 0 fits (5 >= 4)\n    # Bin 1 does not fit (3 < 4)\n    # Bin 2 fits (7 >= 4)\n    # For First Fit, we'd pick Bin 0.\n    # To achieve this with highest score: Bin 0 needs highest score.\n    # We can assign priority based on (MaxPossiblePriority - Index), for bins that fit.\n    # Let's use a large constant for \"MaxPossiblePriority\".\n    # If we use `num_bins - bin_indices[fits_mask]`, then for the example above:\n    # Bin 0: fits, index=0, num_bins=3. Priority = 3 - 0 = 3.\n    # Bin 1: doesn't fit. Priority = 0.\n    # Bin 2: fits, index=2, num_bins=3. Priority = 3 - 2 = 1.\n    # Priorities: [3, 0, 1]. The highest score is 3, corresponding to bin 0.\n\n    return priorities\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin using a First Fit strategy with a preference for fuller bins.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Create a boolean mask for bins that can accommodate the item\n    can_fit_mask = bins_remain_cap >= item\n    \n    # For bins that can fit the item, calculate priority\n    # The priority is inversely related to the remaining capacity.\n    # Bins with less remaining capacity (i.e., are fuller) get higher priority.\n    # Add a small epsilon to avoid division by zero if a bin has exactly 'item' remaining capacity.\n    priorities[can_fit_mask] = 1.0 / (bins_remain_cap[can_fit_mask] - item + 1e-9)\n    \n    # Bins that cannot fit the item get a priority of 0 (or a very low negative number if desired for clear distinction)\n    # For this implementation, 0 is sufficient as it will not be chosen over any bin that can fit.\n    \n    return priorities\n\n[Reflection]\nPrioritize fuller bins that fit the item.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}