```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using a Best Fit strategy.

    The Best Fit strategy aims to place the item in the bin that has the smallest
    remaining capacity that is still large enough to accommodate the item.
    This often leads to fuller bins, reducing wasted space.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Returns:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    # Create a boolean mask for bins that can accommodate the item
    can_fit_mask = bins_remain_cap >= item
    
    # For bins that can fit the item, calculate priority.
    # The priority should be higher for bins with less remaining capacity
    # (i.e., the 'tightest' fit).
    # We can assign a priority inversely proportional to the difference
    # between the bin's remaining capacity and the item's size.
    # A smaller difference means a tighter fit, thus a higher priority.
    # Add a small epsilon to avoid division by zero if remaining_capacity == item.
    
    # Calculate the difference: remaining_capacity - item_size
    difference = bins_remain_cap[can_fit_mask] - item
    
    # Assign higher priority to smaller differences.
    # We can use 1 / (difference + epsilon) to achieve this.
    # A larger difference will result in a smaller priority score.
    priorities[can_fit_mask] = 1.0 / (difference + 1e-9)
    
    # Bins that cannot fit the item receive a priority of 0, as they are not viable options.
    
    return priorities
```
