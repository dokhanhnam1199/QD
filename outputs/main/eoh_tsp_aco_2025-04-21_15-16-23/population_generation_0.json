[
     {
          "algorithm": "This algorithm samples TSP solutions using a nearest neighbor heuristic and biases edge selection towards shorter distances and edges frequently appearing in good solutions.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm samples TSP solutions using a nearest neighbor heuristic and biases edge selection towards shorter distances and edges frequently appearing in good solutions.}\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    num_samples = 100\n\n    for _ in range(num_samples):\n        start_node = np.random.randint(n)\n        current_node = start_node\n        unvisited_nodes = set(range(n))\n        unvisited_nodes.remove(current_node)\n        path = [current_node]\n        path_length = 0\n\n        while unvisited_nodes:\n            nearest_neighbor = None\n            min_distance = np.inf\n            for neighbor in unvisited_nodes:\n                distance = distance_matrix[current_node, neighbor]\n                if distance < min_distance:\n                    min_distance = distance\n                    nearest_neighbor = neighbor\n\n            path.append(nearest_neighbor)\n            path_length += distance_matrix[current_node, nearest_neighbor]\n            unvisited_nodes.remove(nearest_neighbor)\n            current_node = nearest_neighbor\n        \n        path.append(start_node)\n        path_length += distance_matrix[current_node, start_node]\n        \n        for i in range(n):\n            heuristics_matrix[path[i], path[i+1]] += 1.0 / path_length\n            heuristics_matrix[path[i+1], path[i]] += 1.0 / path_length\n\n    # Incorporate distance information directly\n    heuristics_matrix = heuristics_matrix / np.max(heuristics_matrix)\n    heuristics_matrix = heuristics_matrix / (distance_matrix / np.max(distance_matrix))\n    \n    return heuristics_matrix",
          "objective": 6.08504,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm uses a combination of nearest neighbor and random sampling to generate multiple candidate tours, then averages the edge frequencies across these tours to produce a heuristic matrix.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm uses a combination of nearest neighbor and random sampling to generate multiple candidate tours, then averages the edge frequencies across these tours to produce a heuristic matrix.}\"\"\"\n    n = len(distance_matrix)\n    heuristics_matrix = np.zeros((n, n))\n    num_samples = 100\n\n    for _ in range(num_samples):\n        start_node = np.random.randint(n)\n        current_node = start_node\n        unvisited = set(range(n))\n        unvisited.remove(current_node)\n        tour = [current_node]\n\n        while unvisited:\n            nearest_neighbor = None\n            min_distance = np.inf\n\n            # Nearest Neighbor Step\n            for neighbor in unvisited:\n                distance = distance_matrix[current_node][neighbor]\n                if distance < min_distance:\n                    min_distance = distance\n                    nearest_neighbor = neighbor\n\n            # Introduce randomness: Sometimes choose a random unvisited node\n            if np.random.rand() < 0.2:  # 20% chance of random selection\n                nearest_neighbor = np.random.choice(list(unvisited))\n\n            tour.append(nearest_neighbor)\n            unvisited.remove(nearest_neighbor)\n            current_node = nearest_neighbor\n\n        tour.append(start_node)\n\n        # Update heuristic matrix based on the tour\n        for i in range(n):\n            node1 = tour[i]\n            node2 = tour[i + 1]\n            heuristics_matrix[node1][node2] += 1\n            heuristics_matrix[node2][node1] += 1\n\n    heuristics_matrix /= num_samples\n    return heuristics_matrix",
          "objective": 6.12703,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm samples multiple near-greedy TSP solutions, and then uses the frequency of each edge's appearance in these solutions as a heuristic indicator for its importance.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm samples multiple near-greedy TSP solutions, and then uses the frequency of each edge's appearance in these solutions as a heuristic indicator for its importance.}\"\"\"\n    num_nodes = distance_matrix.shape[0]\n    num_samples = 100  # Number of sample solutions to generate\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    for _ in range(num_samples):\n        current_node = np.random.randint(num_nodes)  # Start from a random node\n        unvisited_nodes = set(range(num_nodes))\n        unvisited_nodes.remove(current_node)\n        tour = [current_node]\n\n        while unvisited_nodes:\n            nearest_neighbor = None\n            min_distance = np.inf\n            for neighbor in unvisited_nodes:\n                distance = distance_matrix[current_node, neighbor]\n                if distance < min_distance:\n                    min_distance = distance\n                    nearest_neighbor = neighbor\n\n            tour.append(nearest_neighbor)\n            unvisited_nodes.remove(nearest_neighbor)\n            current_node = nearest_neighbor\n\n        tour.append(tour[0])  # Return to the starting node\n\n        # Update heuristics matrix based on the edges in the tour\n        for i in range(num_nodes):\n            node1 = tour[i]\n            node2 = tour[i+1]\n            heuristics_matrix[node1, node2] += 1\n            heuristics_matrix[node2, node1] += 1\n\n    # Normalize the heuristics matrix\n    heuristics_matrix /= num_samples\n\n    return heuristics_matrix",
          "objective": 6.2473,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm iteratively samples TSP solutions using a nearest neighbor heuristic, updating a matrix that reflects the frequency with which each edge appears in promising solutions.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm iteratively samples TSP solutions using a nearest neighbor heuristic, updating a matrix that reflects the frequency with which each edge appears in promising solutions.}\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    num_samples = 100\n    \n    for _ in range(num_samples):\n        start_node = np.random.randint(n)\n        current_node = start_node\n        unvisited = set(range(n))\n        unvisited.remove(start_node)\n        path = [start_node]\n        path_length = 0\n\n        while unvisited:\n            nearest_neighbor = -1\n            min_distance = float('inf')\n            for neighbor in unvisited:\n                distance = distance_matrix[current_node, neighbor]\n                if distance < min_distance:\n                    min_distance = distance\n                    nearest_neighbor = neighbor\n\n            path.append(nearest_neighbor)\n            path_length += min_distance\n            unvisited.remove(nearest_neighbor)\n            current_node = nearest_neighbor\n\n        path.append(start_node)\n        path_length += distance_matrix[current_node, start_node]\n\n        # Update heuristics matrix based on path length (better paths contribute more)\n        if path_length > 0:\n            reward = 1 / path_length \n        else:\n            reward = 0  # avoid division by zero\n            \n        for i in range(n):\n            node1 = path[i]\n            node2 = path[i+1]\n            heuristics_matrix[node1, node2] += reward\n            heuristics_matrix[node2, node1] += reward\n\n    return heuristics_matrix",
          "objective": 6.33119,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm creates a heuristic matrix for the TSP by prioritizing edges with short distances and discouraging edges that would lead to isolated nodes or long detours.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"\n    {This algorithm creates a heuristic matrix for the TSP by prioritizing edges with short distances and discouraging edges that would lead to isolated nodes or long detours.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    \n    # Heuristic 1: Inverse of distance (shorter distances are better)\n    heuristics_matrix = 1 / (distance_matrix + 1e-9)  # Add a small value to avoid division by zero\n    \n    # Heuristic 2: Penalty for creating isolated nodes\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                # Calculate the sum of distances from node i to all other nodes except j\n                sum_distances_i = np.sum(distance_matrix[i, :]) - distance_matrix[i, j]\n                \n                # Calculate the sum of distances from node j to all other nodes except i\n                sum_distances_j = np.sum(distance_matrix[j, :]) - distance_matrix[j, i]\n                \n                # Penalize the edge (i, j) if the sum of distances from either i or j to all other nodes is large\n                heuristics_matrix[i, j] -= (sum_distances_i + sum_distances_j) / (n * n)\n    \n    # Heuristic 3: Encourage local connections and penalize long detours\n    mean_distance = np.mean(distance_matrix)\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                if distance_matrix[i, j] > mean_distance:\n                    heuristics_matrix[i, j] *= 0.5  # Reduce the heuristic value if the distance is larger than the mean\n\n    # Ensure the diagonal elements are zero\n    for i in range(n):\n        heuristics_matrix[i, i] = 0\n\n    return heuristics_matrix",
          "objective": 6.56102,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm samples multiple solutions using a nearest neighbor heuristic with random starting nodes and edge selection probabilities biased towards shorter distances, then averages the edge frequencies across these solutions to generate a heuristic matrix.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm samples multiple solutions using a nearest neighbor heuristic with random starting nodes and edge selection probabilities biased towards shorter distances, then averages the edge frequencies across these solutions to generate a heuristic matrix.}\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros((n, n))\n    num_samples = 100\n\n    for _ in range(num_samples):\n        start_node = np.random.randint(n)\n        current_node = start_node\n        unvisited = set(range(n))\n        unvisited.remove(current_node)\n        path = [current_node]\n\n        while unvisited:\n            distances = distance_matrix[current_node, :]\n            probabilities = 1 / (distances + 1e-6)  # Bias towards shorter distances\n            probabilities[current_node] = 0  # Avoid revisiting the current node\n            \n            # Mask visited nodes\n            for visited_node in path:\n                probabilities[visited_node] = 0\n                \n            probabilities = probabilities / np.sum(probabilities) if np.sum(probabilities) > 0 else np.ones(n) / n # Avoid division by zero\n            \n            next_node = np.random.choice(n, p=probabilities)\n            \n            path.append(next_node)\n            unvisited.remove(next_node)\n            current_node = next_node\n\n        path.append(start_node)  # Return to the start\n\n        for i in range(n):\n            heuristics_matrix[path[i], path[(i + 1) % n]] += 1\n            heuristics_matrix[path[(i + 1) % n], path[i]] += 1 #Symmetric\n\n    heuristics_matrix = heuristics_matrix / num_samples\n    return heuristics_matrix",
          "objective": 7.56744,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm samples many near-optimal TSP solutions using a greedy nearest neighbor approach with stochastic restarts and edge recombination, then aggregates edge frequencies to estimate edge inclusion probabilities.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm samples many near-optimal TSP solutions using a greedy nearest neighbor approach with stochastic restarts and edge recombination, then aggregates edge frequencies to estimate edge inclusion probabilities.}\"\"\"\n    n = distance_matrix.shape[0]\n    num_samples = 1000\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    for _ in range(num_samples):\n        start_node = np.random.randint(n)\n        current_node = start_node\n        unvisited_nodes = set(range(n))\n        unvisited_nodes.remove(current_node)\n        tour = [current_node]\n        \n        while unvisited_nodes:\n            distances = distance_matrix[current_node, :]\n            \n            # Apply stochasticity: select from the k-nearest neighbors\n            k = min(5, len(unvisited_nodes))  # Consider top k nearest neighbors\n            nearest_neighbors_indices = np.argsort(distances)[1:] #exclude the same node itself from consideration\n            \n            valid_neighbors = [idx for idx in nearest_neighbors_indices if idx in unvisited_nodes] #select only unvisited ones\n            \n            if len(valid_neighbors) > 0:\n                \n                if len(valid_neighbors) <= k:\n                     chosen_neighbor = np.random.choice(valid_neighbors) #random choice from all valid neighbours\n                else:\n                    chosen_neighbor = np.random.choice(valid_neighbors[:k]) #random choice from k nearest neighbors\n                \n                tour.append(chosen_neighbor)\n                unvisited_nodes.remove(chosen_neighbor)\n                current_node = chosen_neighbor\n            else:\n                 # Handle the edge case where there are no unvisited nodes.\n                break\n\n\n        # Complete the tour if necessary\n        if len(tour) < n:\n            remaining_nodes = list(set(range(n)) - set(tour))\n            tour.extend(remaining_nodes)\n            \n        # Ensure tour is closed: add start node at the end\n        tour.append(start_node)\n        \n\n        # Update heuristics matrix\n        for i in range(n):\n            heuristics_matrix[tour[i], tour[i+1]] += 1\n            heuristics_matrix[tour[i+1], tour[i]] += 1  # Symmetric\n\n    heuristics_matrix /= num_samples\n    return heuristics_matrix",
          "objective": 9.50085,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm samples many random tours, favoring shorter edges, and then returns a matrix indicating how frequently each edge appears in the sampled tours.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm samples many random tours, favoring shorter edges, and then returns a matrix indicating how frequently each edge appears in the sampled tours.}\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    num_samples = 1000\n\n    for _ in range(num_samples):\n        current_node = np.random.randint(n)\n        unvisited_nodes = set(range(n))\n        unvisited_nodes.remove(current_node)\n        tour = [current_node]\n\n        while unvisited_nodes:\n            distances = distance_matrix[current_node, :]\n            probabilities = np.zeros(n)\n            for node in unvisited_nodes:\n                probabilities[node] = np.exp(-distances[node] / (np.mean(distance_matrix) + 1e-6)) # Softmax favoring shorter edges\n            \n            probabilities /= np.sum(probabilities)\n            \n            next_node = np.random.choice(n, p=probabilities)\n            \n            if next_node not in unvisited_nodes:\n              candidates = list(unvisited_nodes)\n              distances_to_candidates = distances[candidates]\n              next_node = candidates[np.argmin(distances_to_candidates)] # Fallback in case random choice fails due to numerical instability\n\n\n            tour.append(next_node)\n            unvisited_nodes.remove(next_node)\n            current_node = next_node\n\n        tour.append(tour[0])  # Return to starting node\n\n        for i in range(n):\n            heuristics_matrix[tour[i], tour[i+1]] += 1\n            heuristics_matrix[tour[i+1], tour[i]] += 1\n\n    heuristics_matrix /= num_samples\n    return heuristics_matrix",
          "objective": 9.53272,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm iteratively samples random paths, favoring shorter edges and penalizing edges that frequently appear in long paths, to generate a heuristic matrix indicating the likelihood of each edge being part of an optimal TSP solution.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"\n    {This algorithm iteratively samples random paths, favoring shorter edges and penalizing edges that frequently appear in long paths, to generate a heuristic matrix indicating the likelihood of each edge being part of an optimal TSP solution.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    num_iterations = 1000\n    alpha = 0.1 \n    beta = 0.9\n\n    for _ in range(num_iterations):\n        # Sample a random path with preference for shorter edges\n        current_node = np.random.randint(n)\n        unvisited_nodes = set(range(n))\n        unvisited_nodes.remove(current_node)\n        path = [current_node]\n        total_distance = 0\n\n        while unvisited_nodes:\n            probabilities = np.zeros(n)\n            for neighbor in unvisited_nodes:\n                probabilities[neighbor] = (1 / distance_matrix[current_node, neighbor])**2 # Prefer shorter distances\n            \n            probabilities /= np.sum(probabilities)\n            next_node = np.random.choice(n, p=probabilities)\n            \n            if next_node not in unvisited_nodes:\n                available_nodes = list(unvisited_nodes)\n                if len(available_nodes) > 0:\n                    next_node = available_nodes[0]\n                else:\n                    break\n            \n            path.append(next_node)\n            total_distance += distance_matrix[current_node, next_node]\n            current_node = next_node\n            unvisited_nodes.remove(current_node)\n\n        # Complete the cycle\n        path.append(path[0])\n        total_distance += distance_matrix[path[-2], path[0]]\n\n        # Update the heuristic matrix based on path quality\n        for i in range(n):\n            j = (i + 1) % n\n            node1 = path[i]\n            node2 = path[j]\n\n            heuristics_matrix[node1, node2] = beta * heuristics_matrix[node1, node2] + alpha * (1 / total_distance)\n            heuristics_matrix[node2, node1] = beta * heuristics_matrix[node2, node1] + alpha * (1 / total_distance)\n\n    return heuristics_matrix",
          "objective": 13.83149,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm generates multiple random tours, selects the best ones based on total distance, and then averages the frequency with which each edge appears in these best tours to create a heuristic matrix.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"\n    {This algorithm generates multiple random tours, selects the best ones based on total distance, and then averages the frequency with which each edge appears in these best tours to create a heuristic matrix.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    num_tours = 1000\n    num_best = 100\n    tours = []\n    distances = []\n\n    for _ in range(num_tours):\n        tour = np.random.permutation(n)\n        tours.append(tour)\n        distance = 0\n        for i in range(n - 1):\n            distance += distance_matrix[tour[i], tour[i+1]]\n        distance += distance_matrix[tour[-1], tour[0]]\n        distances.append(distance)\n\n    ranked_tours = np.argsort(distances)\n    best_tours = [tours[i] for i in ranked_tours[:num_best]]\n\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    for tour in best_tours:\n        for i in range(n - 1):\n            heuristics_matrix[tour[i], tour[i+1]] += 1\n            heuristics_matrix[tour[i+1], tour[i]] += 1  # Ensure symmetry\n        heuristics_matrix[tour[-1], tour[0]] += 1\n        heuristics_matrix[tour[0], tour[-1]] += 1\n\n    heuristics_matrix /= num_best\n\n    return heuristics_matrix",
          "objective": 14.27205,
          "other_inf": null
     }
]