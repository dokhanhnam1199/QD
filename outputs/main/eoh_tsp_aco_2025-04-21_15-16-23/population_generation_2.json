[
     {
          "algorithm": "This algorithm estimates edge desirability for TSP by iteratively constructing tours using a nearest neighbor approach, improving them with 2-opt swaps, and averaging the inclusion frequency of each edge across multiple runs, weighting edges in shorter tours higher.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm estimates edge desirability for TSP by iteratively constructing tours using a nearest neighbor approach, improving them with 2-opt swaps, and averaging the inclusion frequency of each edge across multiple runs, weighting edges in shorter tours higher.}\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros((n, n))\n    num_trials = 50\n\n    def calculate_tour_length(tour):\n        length = 0\n        for i in range(n):\n            length += distance_matrix[tour[i], tour[(i + 1) % n]]\n        return length\n\n    def two_opt_swap(tour, i, k):\n        new_tour = tour[:i] + tour[i:k+1][::-1] + tour[k+1:]\n        return new_tour\n\n    def two_opt(tour):\n        best_tour = tour\n        best_length = calculate_tour_length(tour)\n        improved = True\n        while improved:\n            improved = False\n            for i in range(1, n - 1):\n                for k in range(i + 1, n):\n                    new_tour = two_opt_swap(best_tour, i, k)\n                    new_length = calculate_tour_length(new_tour)\n                    if new_length < best_length:\n                        best_tour = new_tour\n                        best_length = new_length\n                        improved = True\n        return best_tour, best_length\n\n    def nearest_neighbor_tour(start_node):\n        tour = [start_node]\n        unvisited_nodes = set(range(n))\n        unvisited_nodes.remove(start_node)\n        current_node = start_node\n\n        while unvisited_nodes:\n            nearest_node = min(unvisited_nodes, key=lambda x: distance_matrix[current_node, x])\n            tour.append(nearest_node)\n            unvisited_nodes.remove(nearest_node)\n            current_node = nearest_node\n        tour.append(start_node)\n        tour = tour[:-1]\n        return tour\n\n    for _ in range(num_trials):\n        # Generate a tour using nearest neighbor heuristic\n        start_node = np.random.randint(0, n)\n        initial_tour = nearest_neighbor_tour(start_node)\n\n        # Apply 2-opt to improve the tour\n        best_tour, best_length = two_opt(initial_tour)\n\n        # Update the heuristics matrix based on the edges in the improved tour, weighting by tour length\n        weight = 1.0 / best_length\n        for i in range(n):\n            node1 = best_tour[i]\n            node2 = best_tour[(i + 1) % n]\n            heuristics_matrix[node1, node2] += weight\n            heuristics_matrix[node2, node1] += weight\n\n    # Normalize the heuristics matrix\n    total_weight = np.sum(heuristics_matrix)\n    if total_weight > 0:\n        heuristics_matrix /= total_weight\n\n    return heuristics_matrix",
          "objective": 5.71614,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm estimates edge desirability for TSP by iteratively constructing tours using a nearest neighbor approach, improving them with 2-opt swaps, and averaging the inclusion frequency of each edge across multiple runs.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm estimates edge desirability for TSP by iteratively constructing tours using a nearest neighbor approach, improving them with 2-opt swaps, and averaging the inclusion frequency of each edge across multiple runs.}\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros((n, n))\n    num_trials = 50\n\n    def calculate_tour_length(tour):\n        length = 0\n        for i in range(n):\n            length += distance_matrix[tour[i], tour[(i + 1) % n]]\n        return length\n\n    def two_opt_swap(tour, i, k):\n        new_tour = tour[:i] + tour[i:k+1][::-1] + tour[k+1:]\n        return new_tour\n\n    def two_opt(tour):\n        best_tour = tour\n        best_length = calculate_tour_length(tour)\n        improved = True\n        while improved:\n            improved = False\n            for i in range(1, n - 1):\n                for k in range(i + 1, n):\n                    new_tour = two_opt_swap(best_tour, i, k)\n                    new_length = calculate_tour_length(new_tour)\n                    if new_length < best_length:\n                        best_tour = new_tour\n                        best_length = new_length\n                        improved = True\n        return best_tour, best_length\n\n    def nearest_neighbor_tour(start_node):\n        tour = [start_node]\n        unvisited_nodes = set(range(n))\n        unvisited_nodes.remove(start_node)\n        current_node = start_node\n\n        while unvisited_nodes:\n            nearest_node = min(unvisited_nodes, key=lambda x: distance_matrix[current_node, x])\n            tour.append(nearest_node)\n            unvisited_nodes.remove(nearest_node)\n            current_node = nearest_node\n        tour.append(start_node)\n        tour = tour[:-1]\n        return tour\n\n    for _ in range(num_trials):\n        # Generate a tour using nearest neighbor heuristic\n        start_node = np.random.randint(0, n)\n        initial_tour = nearest_neighbor_tour(start_node)\n\n        # Apply 2-opt to improve the tour\n        best_tour, best_length = two_opt(initial_tour)\n\n        # Update the heuristics matrix based on the edges in the improved tour\n        for i in range(n):\n            node1 = best_tour[i]\n            node2 = best_tour[(i + 1) % n]\n            heuristics_matrix[node1, node2] += 1\n            heuristics_matrix[node2, node1] += 1\n\n    heuristics_matrix /= num_trials\n    return heuristics_matrix",
          "objective": 5.72254,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm estimates edge desirability by iteratively constructing tours using a nearest neighbor approach, improving them with 2-opt swaps, and averaging the frequency of each edge across multiple trials.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm estimates edge desirability by iteratively constructing tours using a nearest neighbor approach, improving them with 2-opt swaps, and averaging the frequency of each edge across multiple trials.}\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros((n, n))\n    num_trials = 50\n\n    def calculate_tour_length(tour):\n        length = 0\n        for i in range(n):\n            length += distance_matrix[tour[i], tour[(i + 1) % n]]\n        return length\n\n    def two_opt_swap(tour, i, k):\n        new_tour = tour[:i] + tour[i:k+1][::-1] + tour[k+1:]\n        return new_tour\n\n    def two_opt(tour):\n        best_tour = tour\n        best_length = calculate_tour_length(tour)\n        improved = True\n        while improved:\n            improved = False\n            for i in range(1, n - 1):\n                for k in range(i + 1, n):\n                    new_tour = two_opt_swap(best_tour, i, k)\n                    new_length = calculate_tour_length(new_tour)\n                    if new_length < best_length:\n                        best_tour = new_tour\n                        best_length = new_length\n                        improved = True\n        return best_tour, best_length\n    \n    def nearest_neighbor_tour(start_node):\n        unvisited = set(range(n))\n        unvisited.remove(start_node)\n        tour = [start_node]\n        current_node = start_node\n\n        while unvisited:\n            nearest_node = min(unvisited, key=lambda node: distance_matrix[current_node, node])\n            tour.append(nearest_node)\n            unvisited.remove(nearest_node)\n            current_node = nearest_node\n        tour.append(start_node)\n        return tour[:-1]\n\n    for _ in range(num_trials):\n        # Generate an initial tour using nearest neighbor\n        start_node = np.random.randint(0, n)\n        initial_tour = nearest_neighbor_tour(start_node)\n\n        # Apply 2-opt to improve the tour\n        best_tour, best_length = two_opt(initial_tour)\n\n        # Update the heuristics matrix based on the edges in the improved tour\n        for i in range(n):\n            node1 = best_tour[i]\n            node2 = best_tour[(i + 1) % n]\n            heuristics_matrix[node1, node2] += 1\n            heuristics_matrix[node2, node1] += 1\n\n    heuristics_matrix /= num_trials\n    return heuristics_matrix",
          "objective": 5.74904,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm estimates edge desirability for TSP by iteratively improving random tours using 2-opt swaps and averaging the improvement contribution of each edge across multiple runs.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm estimates edge desirability for TSP by iteratively improving random tours using 2-opt swaps and averaging the improvement contribution of each edge across multiple runs.}\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros((n, n))\n    num_iterations = 100\n    num_trials = 50\n\n    def calculate_tour_length(tour):\n        length = 0\n        for i in range(n):\n            length += distance_matrix[tour[i], tour[(i + 1) % n]]\n        return length\n\n    def two_opt_swap(tour, i, k):\n        new_tour = tour[:i] + tour[i:k+1][::-1] + tour[k+1:]\n        return new_tour\n\n    def two_opt(tour):\n        best_tour = tour\n        best_length = calculate_tour_length(tour)\n        improved = True\n        while improved:\n            improved = False\n            for i in range(1, n - 1):\n                for k in range(i + 1, n):\n                    new_tour = two_opt_swap(best_tour, i, k)\n                    new_length = calculate_tour_length(new_tour)\n                    if new_length < best_length:\n                        best_tour = new_tour\n                        best_length = new_length\n                        improved = True\n        return best_tour, best_length\n\n    for _ in range(num_trials):\n        # Generate a random initial tour\n        initial_tour = np.random.permutation(n).tolist()\n        initial_tour.append(initial_tour[0])\n        initial_tour = initial_tour[:-1]\n\n        # Apply 2-opt to improve the tour\n        best_tour, best_length = two_opt(initial_tour)\n\n        # Update the heuristics matrix based on the edges in the improved tour\n        for i in range(n):\n            node1 = best_tour[i]\n            node2 = best_tour[(i + 1) % n]\n            heuristics_matrix[node1, node2] += 1\n            heuristics_matrix[node2, node1] += 1\n\n    heuristics_matrix /= num_trials\n    return heuristics_matrix",
          "objective": 5.75233,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm estimates edge desirability for TSP by iteratively constructing tours using a nearest neighbor approach, improving them with 2-opt swaps, and averaging edge occurrences across multiple runs.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm estimates edge desirability for TSP by iteratively constructing tours using a nearest neighbor approach, improving them with 2-opt swaps, and averaging edge occurrences across multiple runs.}\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros((n, n))\n    num_trials = 50\n\n    def calculate_tour_length(tour):\n        length = 0\n        for i in range(n):\n            length += distance_matrix[tour[i], tour[(i + 1) % n]]\n        return length\n\n    def two_opt_swap(tour, i, k):\n        new_tour = tour[:i] + tour[i:k+1][::-1] + tour[k+1:]\n        return new_tour\n\n    def two_opt(tour):\n        best_tour = tour\n        best_length = calculate_tour_length(tour)\n        improved = True\n        while improved:\n            improved = False\n            for i in range(1, n - 1):\n                for k in range(i + 1, n):\n                    new_tour = two_opt_swap(best_tour, i, k)\n                    new_length = calculate_tour_length(new_tour)\n                    if new_length < best_length:\n                        best_tour = new_tour\n                        best_length = new_length\n                        improved = True\n        return best_tour, best_length\n    \n    def nearest_neighbor_tour(start_node):\n        tour = [start_node]\n        unvisited = list(range(n))\n        unvisited.remove(start_node)\n\n        while unvisited:\n            last_node = tour[-1]\n            nearest_node = min(unvisited, key=lambda x: distance_matrix[last_node, x])\n            tour.append(nearest_node)\n            unvisited.remove(nearest_node)\n        tour.append(start_node)\n        tour = tour[:-1]\n        return tour\n\n    for _ in range(num_trials):\n        # Generate initial tour using nearest neighbor\n        start_node = np.random.randint(n)\n        initial_tour = nearest_neighbor_tour(start_node)\n\n        # Apply 2-opt to improve the tour\n        best_tour, best_length = two_opt(initial_tour)\n\n        # Update the heuristics matrix based on the edges in the improved tour\n        for i in range(n):\n            node1 = best_tour[i]\n            node2 = best_tour[(i + 1) % n]\n            heuristics_matrix[node1, node2] += 1\n            heuristics_matrix[node2, node1] += 1\n\n    heuristics_matrix /= num_trials\n    return heuristics_matrix",
          "objective": 5.75662,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm constructs a heuristic matrix by simulating ant colony optimization with adaptive parameter adjustments based on the iteration's best path length and pheromone updates favoring edges in elite solutions.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm constructs a heuristic matrix by simulating ant colony optimization with adaptive parameter adjustments based on the iteration's best path length and pheromone updates favoring edges in elite solutions.}\"\"\"\n    n = distance_matrix.shape[0]\n    pheromone = np.ones((n, n))  # Initialize pheromone trails\n    heuristics_matrix = np.zeros((n, n))\n    alpha = 0.7  # Pheromone influence\n    beta = 2   # Distance influence\n    rho = 0.3  # Evaporation rate\n    Q = 100    # Pheromone deposit constant\n    num_ants = 30\n    num_iterations = 60\n    elite_ants = 5  # Number of top ants to reinforce pheromones\n\n    for iteration in range(num_iterations):\n        all_paths = []\n        all_path_lengths = []\n\n        for ant in range(num_ants):\n            start_node = np.random.randint(n)\n            current_node = start_node\n            unvisited = set(range(n))\n            unvisited.remove(current_node)\n            path = [current_node]\n\n            while unvisited:\n                probabilities = (pheromone[current_node, :]**alpha) * ((1 / (distance_matrix[current_node, :] + 1e-6))**beta)\n                \n                # Mask visited nodes\n                for visited_node in path:\n                    probabilities[visited_node] = 0\n                \n                probabilities = probabilities / np.sum(probabilities) if np.sum(probabilities) > 0 else np.ones(n) / n\n\n                next_node = np.random.choice(n, p=probabilities)\n                path.append(next_node)\n                unvisited.remove(next_node)\n                current_node = next_node\n\n            path.append(start_node)\n            all_paths.append(path)\n\n            path_length = 0\n            for i in range(n):\n                path_length += distance_matrix[path[i], path[(i + 1) % n]]\n            all_path_lengths.append(path_length)\n\n        # Find the best path in this iteration\n        best_path_index = np.argmin(all_path_lengths)\n        best_path = all_paths[best_path_index]\n        best_path_length = all_path_lengths[best_path_index]\n        \n        # Sort ants by path length to find elite ants\n        sorted_indices = np.argsort(all_path_lengths)\n        elite_paths = [all_paths[i] for i in sorted_indices[:elite_ants]]\n\n        # Update pheromones\n        pheromone *= (1 - rho)  # Evaporation\n        for path in elite_paths:\n            path_length = all_path_lengths[all_paths.index(path)]\n            for i in range(n):\n                pheromone[path[i], path[(i + 1) % n]] += Q / path_length\n                pheromone[path[(i + 1) % n], path[i]] += Q / path_length\n\n    # Construct heuristic matrix based on pheromone levels\n    heuristics_matrix = pheromone\n    return heuristics_matrix",
          "objective": 5.79607,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm estimates edge desirability for TSP by iteratively constructing tours using a nearest neighbor approach with a probability-based selection of the next node, improving them with 2-opt swaps, and averaging the inclusion frequency of each edge across multiple runs.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm estimates edge desirability for TSP by iteratively constructing tours using a nearest neighbor approach with a probability-based selection of the next node, improving them with 2-opt swaps, and averaging the inclusion frequency of each edge across multiple runs.}\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros((n, n))\n    num_trials = 50\n\n    def calculate_tour_length(tour):\n        length = 0\n        for i in range(n):\n            length += distance_matrix[tour[i], tour[(i + 1) % n]]\n        return length\n\n    def two_opt_swap(tour, i, k):\n        new_tour = tour[:i] + tour[i:k+1][::-1] + tour[k+1:]\n        return new_tour\n\n    def two_opt(tour):\n        best_tour = tour\n        best_length = calculate_tour_length(tour)\n        improved = True\n        while improved:\n            improved = False\n            for i in range(1, n - 1):\n                for k in range(i + 1, n):\n                    new_tour = two_opt_swap(best_tour, i, k)\n                    new_length = calculate_tour_length(new_tour)\n                    if new_length < best_length:\n                        best_tour = new_tour\n                        best_length = new_length\n                        improved = True\n        return best_tour, best_length\n\n    def nearest_neighbor_tour_probabilistic(start_node):\n        tour = [start_node]\n        unvisited_nodes = set(range(n))\n        unvisited_nodes.remove(start_node)\n        current_node = start_node\n\n        while unvisited_nodes:\n            probabilities = np.array([1 / distance_matrix[current_node, node] for node in unvisited_nodes])\n            probabilities /= np.sum(probabilities)\n            nearest_node = np.random.choice(list(unvisited_nodes), p=probabilities)\n            tour.append(nearest_node)\n            unvisited_nodes.remove(nearest_node)\n            current_node = nearest_node\n        tour.append(start_node)\n        tour = tour[:-1]\n        return tour\n\n    for _ in range(num_trials):\n        # Generate a tour using nearest neighbor heuristic\n        start_node = np.random.randint(0, n)\n        initial_tour = nearest_neighbor_tour_probabilistic(start_node)\n\n        # Apply 2-opt to improve the tour\n        best_tour, best_length = two_opt(initial_tour)\n\n        # Update the heuristics matrix based on the edges in the improved tour\n        for i in range(n):\n            node1 = best_tour[i]\n            node2 = best_tour[(i + 1) % n]\n            heuristics_matrix[node1, node2] += 1\n            heuristics_matrix[node2, node1] += 1\n\n    heuristics_matrix /= num_trials\n    return heuristics_matrix",
          "objective": 5.7976,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm estimates edge desirability for TSP by iteratively constructing tours using a nearest neighbor approach with a stochastic element, improving them with 2-opt swaps with a limited number of iterations, and averaging the inclusion frequency of each edge across multiple runs.}\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros((n, n))\n    num_trials = 50\n\n    def calculate_tour_length(tour):\n        length = 0\n        for i in range(n):\n            length += distance_matrix[tour[i], tour[(i + 1) % n]]\n        return length\n\n    def two_opt_swap(tour, i, k):\n        new_tour = tour[:i] + tour[i:k+1][::-1] + tour[k+1:]\n        return new_tour\n\n    def two_opt(tour, max_iterations=10):\n        best_tour = tour\n        best_length = calculate_tour_length(tour)\n        improved = True\n        iterations = 0\n        while improved and iterations < max_iterations:\n            improved = False\n            for i in range(1, n - 1):\n                for k in range(i + 1, n):\n                    new_tour = two_opt_swap(best_tour, i, k)\n                    new_length = calculate_tour_length(new_tour)\n                    if new_length < best_length:\n                        best_tour = new_tour\n                        best_length = new_length\n                        improved = True\n            iterations += 1\n        return best_tour, best_length\n\n    def nearest_neighbor_tour(start_node, stochasticity=0.2):\n        tour = [start_node]\n        unvisited_nodes = set(range(n))\n        unvisited_nodes.remove(start_node)\n        current_node = start_node\n\n        while unvisited_nodes:\n            # Introduce stochasticity: select from the top candidates\n            distances = {node: distance_matrix[current_node, node] for node in unvisited_nodes",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm estimates edge desirability for TSP by iteratively constructing tours using a nearest neighbor approach with a stochastic element, improving them with 2-opt swaps with a limited number of iterations, and averaging the inclusion frequency of each edge across multiple runs.}\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros((n, n))\n    num_trials = 50\n\n    def calculate_tour_length(tour):\n        length = 0\n        for i in range(n):\n            length += distance_matrix[tour[i], tour[(i + 1) % n]]\n        return length\n\n    def two_opt_swap(tour, i, k):\n        new_tour = tour[:i] + tour[i:k+1][::-1] + tour[k+1:]\n        return new_tour\n\n    def two_opt(tour, max_iterations=10):\n        best_tour = tour\n        best_length = calculate_tour_length(tour)\n        improved = True\n        iterations = 0\n        while improved and iterations < max_iterations:\n            improved = False\n            for i in range(1, n - 1):\n                for k in range(i + 1, n):\n                    new_tour = two_opt_swap(best_tour, i, k)\n                    new_length = calculate_tour_length(new_tour)\n                    if new_length < best_length:\n                        best_tour = new_tour\n                        best_length = new_length\n                        improved = True\n            iterations += 1\n        return best_tour, best_length\n\n    def nearest_neighbor_tour(start_node, stochasticity=0.2):\n        tour = [start_node]\n        unvisited_nodes = set(range(n))\n        unvisited_nodes.remove(start_node)\n        current_node = start_node\n\n        while unvisited_nodes:\n            # Introduce stochasticity: select from the top candidates\n            distances = {node: distance_matrix[current_node, node] for node in unvisited_nodes}\n            sorted_nodes = sorted(distances.items(), key=lambda item: item[1])\n            k = min(int(len(sorted_nodes) * stochasticity) + 1, len(sorted_nodes))\n            candidates = [node for node, dist in sorted_nodes[:k]]\n\n            nearest_node = np.random.choice(candidates)\n            tour.append(nearest_node)\n            unvisited_nodes.remove(nearest_node)\n            current_node = nearest_node\n        tour.append(start_node)\n        tour = tour[:-1]\n        return tour\n\n    for _ in range(num_trials):\n        # Generate a tour using nearest neighbor heuristic with stochasticity\n        start_node = np.random.randint(0, n)\n        initial_tour = nearest_neighbor_tour(start_node)\n\n        # Apply 2-opt to improve the tour\n        best_tour, best_length = two_opt(initial_tour)\n\n        # Update the heuristics matrix based on the edges in the improved tour\n        for i in range(n):\n            node1 = best_tour[i]\n            node2 = best_tour[(i + 1) % n]\n            heuristics_matrix[node1, node2] += 1\n            heuristics_matrix[node2, node1] += 1\n\n    heuristics_matrix /= num_trials\n    return heuristics_matrix",
          "objective": 5.82532,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm constructs a heuristic matrix by simulating ant colony optimization with increased pheromone evaporation and a stronger emphasis on distance when making path choices.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm constructs a heuristic matrix by simulating ant colony optimization with increased pheromone evaporation and a stronger emphasis on distance when making path choices.}\"\"\"\n    n = distance_matrix.shape[0]\n    pheromone = np.ones((n, n))  # Initialize pheromone trails\n    heuristics_matrix = np.zeros((n, n))\n    alpha = 0.5  # Pheromone influence (reduced)\n    beta = 3   # Distance influence (increased)\n    rho = 0.7  # Evaporation rate (increased)\n    Q = 100    # Pheromone deposit constant\n    num_ants = 20\n    num_iterations = 50\n    elite_ants = 3  # Number of top ants to reinforce pheromones\n\n    for iteration in range(num_iterations):\n        all_paths = []\n        all_path_lengths = []\n\n        for ant in range(num_ants):\n            start_node = np.random.randint(n)\n            current_node = start_node\n            unvisited = set(range(n))\n            unvisited.remove(current_node)\n            path = [current_node]\n\n            while unvisited:\n                probabilities = (pheromone[current_node, :]**alpha) * ((1 / (distance_matrix[current_node, :] + 1e-6))**beta)\n                \n                # Mask visited nodes\n                for visited_node in path:\n                    probabilities[visited_node] = 0\n                \n                probabilities = probabilities / np.sum(probabilities) if np.sum(probabilities) > 0 else np.ones(n) / n\n\n                next_node = np.random.choice(n, p=probabilities)\n                path.append(next_node)\n                unvisited.remove(next_node)\n                current_node = next_node\n\n            path.append(start_node)\n            all_paths.append(path)\n\n            path_length = 0\n            for i in range(n):\n                path_length += distance_matrix[path[i], path[(i + 1) % n]]\n            all_path_lengths.append(path_length)\n\n        # Find the best path in this iteration\n        best_path_index = np.argmin(all_path_lengths)\n        best_path = all_paths[best_path_index]\n        best_path_length = all_path_lengths[best_path_index]\n        \n        # Sort ants by path length to find elite ants\n        sorted_indices = np.argsort(all_path_lengths)\n        elite_paths = [all_paths[i] for i in sorted_indices[:elite_ants]]\n\n        # Update pheromones\n        pheromone *= (1 - rho)  # Evaporation\n        for path in elite_paths:\n            path_length = all_path_lengths[all_paths.index(path)]\n            for i in range(n):\n                pheromone[path[i], path[(i + 1) % n]] += Q / path_length\n                pheromone[path[(i + 1) % n], path[i]] += Q / path_length\n\n    # Construct heuristic matrix based on pheromone levels\n    heuristics_matrix = pheromone\n    return heuristics_matrix",
          "objective": 5.83506,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm constructs a heuristic matrix by combining pheromone and distance information, where pheromone is updated using a rank-based approach, emphasizing the best solutions found during each iteration, and a different constant is used for pheromone deposit.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm constructs a heuristic matrix by combining pheromone and distance information, where pheromone is updated using a rank-based approach, emphasizing the best solutions found during each iteration, and a different constant is used for pheromone deposit.}\"\"\"\n    n = distance_matrix.shape[0]\n    pheromone = np.ones((n, n))  # Initialize pheromone trails\n    heuristics_matrix = np.zeros((n, n))\n    alpha = 0.5  # Pheromone influence\n    beta = 1.5   # Distance influence\n    rho = 0.1  # Evaporation rate\n    Q = 100   # Pheromone deposit constant\n    num_ants = 30\n    num_iterations = 60\n\n    for iteration in range(num_iterations):\n        all_paths = []\n        all_path_lengths = []\n\n        for ant in range(num_ants):\n            start_node = np.random.randint(n)\n            current_node = start_node\n            unvisited = set(range(n))\n            unvisited.remove(current_node)\n            path = [current_node]\n\n            while unvisited:\n                probabilities = (pheromone[current_node, :]**alpha) * ((1 / (distance_matrix[current_node, :] + 1e-6))**beta)\n                \n                # Mask visited nodes\n                for visited_node in path:\n                    probabilities[visited_node] = 0\n                \n                probabilities = probabilities / np.sum(probabilities) if np.sum(probabilities) > 0 else np.ones(n) / n\n\n                next_node = np.random.choice(n, p=probabilities)\n                path.append(next_node)\n                unvisited.remove(next_node)\n                current_node = next_node\n\n            path.append(start_node)\n            all_paths.append(path)\n\n            path_length = 0\n            for i in range(n):\n                path_length += distance_matrix[path[i], path[(i + 1) % n]]\n            all_path_lengths.append(path_length)\n\n        # Rank-based pheromone update\n        ranked_paths = np.argsort(all_path_lengths)\n        for rank, ant_index in enumerate(ranked_paths):\n            path = all_paths[ant_index]\n            path_length = all_path_lengths[ant_index]\n            \n            # Higher rank gets more pheromone deposit\n            deposit_amount = (num_ants - rank) * (Q / path_length)\n            \n            for i in range(n):\n                pheromone[path[i], path[(i + 1) % n]] += deposit_amount\n                pheromone[path[(i + 1) % n], path[i]] += deposit_amount\n\n        # Evaporation\n        pheromone *= (1 - rho)\n\n    # Construct heuristic matrix based on pheromone levels and distance\n    heuristics_matrix = pheromone * (1 / (distance_matrix + 1e-6))\n    return heuristics_matrix",
          "objective": 5.87317,
          "other_inf": null
     }
]