[
     {
          "algorithm": "This algorithm constructs a heuristic matrix by simulating ant colony optimization, where ants probabilistically build solutions biased by pheromone trails and distance, and pheromone is updated based on the quality of the solutions found, and then the heuristic matrix is constructed by combining pheromone and distance information.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm constructs a heuristic matrix by simulating ant colony optimization, where ants probabilistically build solutions biased by pheromone trails and distance, and pheromone is updated based on the quality of the solutions found, and then the heuristic matrix is constructed by combining pheromone and distance information.}\"\"\"\n    n = distance_matrix.shape[0]\n    pheromone = np.ones((n, n))  # Initialize pheromone trails\n    heuristics_matrix = np.zeros((n, n))\n    alpha = 0.8  # Pheromone influence\n    beta = 1.2   # Distance influence\n    rho = 0.2  # Evaporation rate\n    Q = 50   # Pheromone deposit constant\n    num_ants = 40\n    num_iterations = 80\n\n    for iteration in range(num_iterations):\n        all_paths = []\n        all_path_lengths = []\n\n        for ant in range(num_ants):\n            start_node = np.random.randint(n)\n            current_node = start_node\n            unvisited = set(range(n))\n            unvisited.remove(current_node)\n            path = [current_node]\n\n            while unvisited:\n                probabilities = (pheromone[current_node, :]**alpha) * ((1 / (distance_matrix[current_node, :] + 1e-6))**beta)\n                \n                # Mask visited nodes\n                for visited_node in path:\n                    probabilities[visited_node] = 0\n                \n                probabilities = probabilities / np.sum(probabilities) if np.sum(probabilities) > 0 else np.ones(n) / n\n\n                next_node = np.random.choice(n, p=probabilities)\n                path.append(next_node)\n                unvisited.remove(next_node)\n                current_node = next_node\n\n            path.append(start_node)\n            all_paths.append(path)\n\n            path_length = 0\n            for i in range(n):\n                path_length += distance_matrix[path[i], path[(i + 1) % n]]\n            all_path_lengths.append(path_length)\n\n        # Update pheromones\n        pheromone *= (1 - rho)  # Evaporation\n        for ant in range(num_ants):\n            path = all_paths[ant]\n            path_length = all_path_lengths[ant]\n            for i in range(n):\n                pheromone[path[i], path[(i + 1) % n]] += Q / path_length\n                pheromone[path[(i + 1) % n], path[i]] += Q / path_length\n\n    # Construct heuristic matrix based on pheromone levels and distance\n    heuristics_matrix = pheromone * (1 / (distance_matrix + 1e-6))\n    return heuristics_matrix",
          "objective": 5.93176,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm constructs a heuristic matrix by simulating ant colony optimization, where ants probabilistically build solutions biased by pheromone trails and distance, and pheromone is updated based on the quality of the solutions found, with adjusted parameter settings.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm constructs a heuristic matrix by simulating ant colony optimization, where ants probabilistically build solutions biased by pheromone trails and distance, and pheromone is updated based on the quality of the solutions found, with adjusted parameter settings.}\"\"\"\n    n = distance_matrix.shape[0]\n    pheromone = np.ones((n, n))  # Initialize pheromone trails\n    heuristics_matrix = np.zeros((n, n))\n    alpha = 0.5  # Pheromone influence\n    beta = 3   # Distance influence\n    rho = 0.2  # Evaporation rate\n    Q = 50    # Pheromone deposit constant\n    num_ants = 30\n    num_iterations = 50\n\n    for iteration in range(num_iterations):\n        all_paths = []\n        all_path_lengths = []\n\n        for ant in range(num_ants):\n            start_node = np.random.randint(n)\n            current_node = start_node\n            unvisited = set(range(n))\n            unvisited.remove(current_node)\n            path = [current_node]\n\n            while unvisited:\n                probabilities = (pheromone[current_node, :]**alpha) * ((1 / (distance_matrix[current_node, :] + 1e-6))**beta)\n                \n                # Mask visited nodes\n                for visited_node in path:\n                    probabilities[visited_node] = 0\n                \n                probabilities = probabilities / np.sum(probabilities) if np.sum(probabilities) > 0 else np.ones(n) / n\n\n                next_node = np.random.choice(n, p=probabilities)\n                path.append(next_node)\n                unvisited.remove(next_node)\n                current_node = next_node\n\n            path.append(start_node)\n            all_paths.append(path)\n\n            path_length = 0\n            for i in range(n):\n                path_length += distance_matrix[path[i], path[(i + 1) % n]]\n            all_path_lengths.append(path_length)\n\n        # Update pheromones\n        pheromone *= (1 - rho)  # Evaporation\n        for ant in range(num_ants):\n            path = all_paths[ant]\n            path_length = all_path_lengths[ant]\n            for i in range(n):\n                pheromone[path[i], path[(i + 1) % n]] += Q / path_length\n                pheromone[path[(i + 1) % n], path[i]] += Q / path_length\n\n    # Construct heuristic matrix based on pheromone levels\n    heuristics_matrix = pheromone\n    return heuristics_matrix",
          "objective": 5.93326,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm iteratively constructs TSP tours by probabilistically selecting edges based on their length and pheromone trails, then updates pheromone levels according to tour quality, resulting in a heuristic matrix reflecting edge importance, with adjusted parameters.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm iteratively constructs TSP tours by probabilistically selecting edges based on their length and pheromone trails, then updates pheromone levels according to tour quality, resulting in a heuristic matrix reflecting edge importance, with adjusted parameters.}\"\"\"\n    n = distance_matrix.shape[0]\n    pheromone = np.ones_like(distance_matrix)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    alpha = 0.5\n    beta = 3\n    rho = 0.7\n    Q = 50\n    num_iterations = 50\n\n    for iteration in range(num_iterations):\n        tours = []\n        tour_lengths = []\n\n        for start_node in range(n):\n            current_node = start_node\n            unvisited = set(range(n))\n            unvisited.remove(current_node)\n            tour = [current_node]\n\n            while unvisited:\n                probabilities = np.zeros(n)\n                for neighbor in unvisited:\n                    probabilities[neighbor] = (pheromone[current_node, neighbor]**alpha) * ((1 / distance_matrix[current_node, neighbor])**beta)\n                \n                probabilities /= np.sum(probabilities)\n                \n                next_node = np.random.choice(n, p=probabilities)\n\n                if next_node not in unvisited:\n                    available_nodes = list(unvisited)\n                    if len(available_nodes) > 0:\n                        next_node = np.random.choice(available_nodes)\n                    else:\n                        break\n\n                tour.append(next_node)\n                unvisited.remove(next_node)\n                current_node = next_node\n\n            tour.append(start_node)\n            tours.append(tour)\n\n            tour_length = 0\n            for i in range(n):\n                tour_length += distance_matrix[tour[i], tour[i+1]]\n            tour_lengths.append(tour_length)\n\n        # Update pheromones\n        delta_pheromone = np.zeros_like(distance_matrix)\n        for k in range(n):\n            tour = tours[k]\n            tour_length = tour_lengths[k]\n            for i in range(n):\n                delta_pheromone[tour[i], tour[i+1]] += Q / tour_length\n                delta_pheromone[tour[i+1], tour[i]] += Q / tour_length\n\n        pheromone = (1 - rho) * pheromone + delta_pheromone\n\n        # Update heuristic matrix\n        for tour in tours:\n            for i in range(n):\n                heuristics_matrix[tour[i], tour[i+1]] += 1\n                heuristics_matrix[tour[i+1], tour[i]] += 1\n\n    heuristics_matrix /= (num_iterations * n)\n    return heuristics_matrix",
          "objective": 5.94445,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm constructs a heuristic matrix by simulating ant colony optimization, where ants probabilistically build solutions biased by pheromone trails and distance, and pheromone is updated based on the quality of the solutions found using different parameter settings.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm constructs a heuristic matrix by simulating ant colony optimization, where ants probabilistically build solutions biased by pheromone trails and distance, and pheromone is updated based on the quality of the solutions found using different parameter settings.}\"\"\"\n    n = distance_matrix.shape[0]\n    pheromone = np.ones((n, n))  # Initialize pheromone trails\n    heuristics_matrix = np.zeros((n, n))\n    alpha = 0.5  # Pheromone influence (reduced)\n    beta = 3   # Distance influence (increased)\n    rho = 0.2  # Evaporation rate (increased)\n    Q = 50    # Pheromone deposit constant (reduced)\n    num_ants = 25 #Reduced number of ants\n    num_iterations = 50 #Reduced number of iterations\n\n    for iteration in range(num_iterations):\n        all_paths = []\n        all_path_lengths = []\n\n        for ant in range(num_ants):\n            start_node = np.random.randint(n)\n            current_node = start_node\n            unvisited = set(range(n))\n            unvisited.remove(current_node)\n            path = [current_node]\n\n            while unvisited:\n                probabilities = (pheromone[current_node, :]**alpha) * ((1 / (distance_matrix[current_node, :] + 1e-6))**beta)\n                \n                # Mask visited nodes\n                for visited_node in path:\n                    probabilities[visited_node] = 0\n                \n                probabilities = probabilities / np.sum(probabilities) if np.sum(probabilities) > 0 else np.ones(n) / n\n\n                next_node = np.random.choice(n, p=probabilities)\n                path.append(next_node)\n                unvisited.remove(next_node)\n                current_node = next_node\n\n            path.append(start_node)\n            all_paths.append(path)\n\n            path_length = 0\n            for i in range(n):\n                path_length += distance_matrix[path[i], path[(i + 1) % n]]\n            all_path_lengths.append(path_length)\n\n        # Update pheromones\n        pheromone *= (1 - rho)  # Evaporation\n        for ant in range(num_ants):\n            path = all_paths[ant]\n            path_length = all_path_lengths[ant]\n            for i in range(n):\n                pheromone[path[i], path[(i + 1) % n]] += Q / path_length\n                pheromone[path[(i + 1) % n], path[i]] += Q / path_length\n\n    # Construct heuristic matrix based on pheromone levels\n    heuristics_matrix = pheromone\n    return heuristics_matrix",
          "objective": 5.9572,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm constructs a heuristic matrix by simulating ant colony optimization, where ants probabilistically build solutions biased by pheromone trails and distance, and pheromone is updated based on the quality of the solutions found.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm constructs a heuristic matrix by simulating ant colony optimization, where ants probabilistically build solutions biased by pheromone trails and distance, and pheromone is updated based on the quality of the solutions found.}\"\"\"\n    n = distance_matrix.shape[0]\n    pheromone = np.ones((n, n))  # Initialize pheromone trails\n    heuristics_matrix = np.zeros((n, n))\n    alpha = 1  # Pheromone influence\n    beta = 2   # Distance influence\n    rho = 0.1  # Evaporation rate\n    Q = 100    # Pheromone deposit constant\n    num_ants = 50\n    num_iterations = 100\n\n    for iteration in range(num_iterations):\n        all_paths = []\n        all_path_lengths = []\n\n        for ant in range(num_ants):\n            start_node = np.random.randint(n)\n            current_node = start_node\n            unvisited = set(range(n))\n            unvisited.remove(current_node)\n            path = [current_node]\n\n            while unvisited:\n                probabilities = (pheromone[current_node, :]**alpha) * ((1 / (distance_matrix[current_node, :] + 1e-6))**beta)\n                \n                # Mask visited nodes\n                for visited_node in path:\n                    probabilities[visited_node] = 0\n                \n                probabilities = probabilities / np.sum(probabilities) if np.sum(probabilities) > 0 else np.ones(n) / n\n\n                next_node = np.random.choice(n, p=probabilities)\n                path.append(next_node)\n                unvisited.remove(next_node)\n                current_node = next_node\n\n            path.append(start_node)\n            all_paths.append(path)\n\n            path_length = 0\n            for i in range(n):\n                path_length += distance_matrix[path[i], path[(i + 1) % n]]\n            all_path_lengths.append(path_length)\n\n        # Update pheromones\n        pheromone *= (1 - rho)  # Evaporation\n        for ant in range(num_ants):\n            path = all_paths[ant]\n            path_length = all_path_lengths[ant]\n            for i in range(n):\n                pheromone[path[i], path[(i + 1) % n]] += Q / path_length\n                pheromone[path[(i + 1) % n], path[i]] += Q / path_length\n\n    # Construct heuristic matrix based on pheromone levels\n    heuristics_matrix = pheromone\n    return heuristics_matrix",
          "objective": 5.97873,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm constructs a heuristic matrix by simulating ant colony optimization with simplified parameter settings to prioritize distance over pheromone and reduce computational complexity.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm constructs a heuristic matrix by simulating ant colony optimization with simplified parameter settings to prioritize distance over pheromone and reduce computational complexity.}\"\"\"\n    n = distance_matrix.shape[0]\n    pheromone = np.ones((n, n)) * 0.1 # Initialize pheromone trails with a low value\n    heuristics_matrix = np.zeros((n, n))\n    alpha = 0.5  # Reduced pheromone influence\n    beta = 5   # Increased distance influence\n    rho = 0.05  # Reduced evaporation rate\n    Q = 10    # Reduced pheromone deposit constant\n    num_ants = 25 # Reduced number of ants\n    num_iterations = 50 # Reduced number of iterations\n\n    for iteration in range(num_iterations):\n        all_paths = []\n        all_path_lengths = []\n\n        for ant in range(num_ants):\n            start_node = np.random.randint(n)\n            current_node = start_node\n            unvisited = set(range(n))\n            unvisited.remove(current_node)\n            path = [current_node]\n\n            while unvisited:\n                probabilities = (pheromone[current_node, :]**alpha) * ((1 / (distance_matrix[current_node, :] + 1e-6))**beta)\n                \n                # Mask visited nodes\n                for visited_node in path:\n                    probabilities[visited_node] = 0\n                \n                probabilities = probabilities / np.sum(probabilities) if np.sum(probabilities) > 0 else np.ones(n) / n\n\n                next_node = np.random.choice(n, p=probabilities)\n                path.append(next_node)\n                unvisited.remove(next_node)\n                current_node = next_node\n\n            path.append(start_node)\n            all_paths.append(path)\n\n            path_length = 0\n            for i in range(n):\n                path_length += distance_matrix[path[i], path[(i + 1) % n]]\n            all_path_lengths.append(path_length)\n\n        # Update pheromones\n        pheromone *= (1 - rho)  # Evaporation\n        for ant in range(num_ants):\n            path = all_paths[ant]\n            path_length = all_path_lengths[ant]\n            for i in range(n):\n                pheromone[path[i], path[(i + 1) % n]] += Q / path_length\n                pheromone[path[(i + 1) % n], path[i]] += Q / path_length\n\n    # Construct heuristic matrix based on pheromone levels\n    heuristics_matrix = pheromone\n    return heuristics_matrix",
          "objective": 5.98072,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm samples TSP solutions using a nearest neighbor heuristic with probabilistic edge selection based on pheromone and distance, and updates a pheromone matrix with a modified update rule emphasizing shorter paths.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm samples TSP solutions using a nearest neighbor heuristic with probabilistic edge selection based on pheromone and distance, and updates a pheromone matrix with a modified update rule emphasizing shorter paths.}\"\"\"\n    n = distance_matrix.shape[0]\n    pheromone_matrix = np.ones_like(distance_matrix, dtype=float)\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    num_samples = 100\n    alpha = 0.5\n    beta = 1.5\n    decay_rate = 0.05\n    q = 2.0\n\n    for _ in range(num_samples):\n        start_node = np.random.randint(n)\n        current_node = start_node\n        unvisited_nodes = set(range(n))\n        unvisited_nodes.remove(current_node)\n        path = [current_node]\n        path_length = 0\n\n        while unvisited_nodes:\n            probabilities = np.zeros(n)\n            for neighbor in unvisited_nodes:\n                probabilities[neighbor] = (pheromone_matrix[current_node, neighbor]**alpha) / (distance_matrix[current_node, neighbor]**beta)\n            \n            probabilities = probabilities / np.sum(probabilities)\n            \n            nearest_neighbor = np.random.choice(n, p=probabilities)\n            \n            if nearest_neighbor not in unvisited_nodes:\n                available_nodes = list(unvisited_nodes)\n                nearest_neighbor = available_nodes[0] if len(available_nodes) > 0 else None\n                \n                if nearest_neighbor is None:\n                    break\n            \n\n            path.append(nearest_neighbor)\n            path_length += distance_matrix[current_node, nearest_neighbor]\n            unvisited_nodes.remove(nearest_neighbor)\n            current_node = nearest_neighbor\n        \n        if len(path) != n:\n            continue\n        \n        path.append(start_node)\n        path_length += distance_matrix[current_node, start_node]\n        \n        delta = q / path_length\n        for i in range(n):\n            heuristics_matrix[path[i], path[i+1]] += 1.0 / path_length\n            heuristics_matrix[path[i+1], path[i]] += 1.0 / path_length\n            pheromone_matrix[path[i], path[i+1]] += delta\n            pheromone_matrix[path[i+1], path[i]] += delta\n\n        pheromone_matrix *= (1 - decay_rate)\n\n    heuristics_matrix = heuristics_matrix / np.max(heuristics_matrix)\n    heuristics_matrix = heuristics_matrix / (distance_matrix / np.max(distance_matrix))\n\n    return heuristics_matrix",
          "objective": 5.98946,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm iteratively constructs TSP tours by probabilistically selecting edges based on their length and pheromone trails, then updates pheromone levels according to tour quality, resulting in a heuristic matrix reflecting edge importance.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm iteratively constructs TSP tours by probabilistically selecting edges based on their length and pheromone trails, then updates pheromone levels according to tour quality, resulting in a heuristic matrix reflecting edge importance.}\"\"\"\n    n = distance_matrix.shape[0]\n    pheromone = np.ones_like(distance_matrix)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    alpha = 1\n    beta = 2\n    rho = 0.5\n    Q = 100\n    num_iterations = 100\n\n    for iteration in range(num_iterations):\n        tours = []\n        tour_lengths = []\n\n        for start_node in range(n):\n            current_node = start_node\n            unvisited = set(range(n))\n            unvisited.remove(current_node)\n            tour = [current_node]\n\n            while unvisited:\n                probabilities = np.zeros(n)\n                for neighbor in unvisited:\n                    probabilities[neighbor] = (pheromone[current_node, neighbor]**alpha) * ((1 / distance_matrix[current_node, neighbor])**beta)\n                \n                probabilities /= np.sum(probabilities)\n                \n                next_node = np.random.choice(n, p=probabilities)\n\n                if next_node not in unvisited:\n                    available_nodes = list(unvisited)\n                    if len(available_nodes) > 0:\n                        next_node = np.random.choice(available_nodes)\n                    else:\n                        break\n\n                tour.append(next_node)\n                unvisited.remove(next_node)\n                current_node = next_node\n\n            tour.append(start_node)\n            tours.append(tour)\n\n            tour_length = 0\n            for i in range(n):\n                tour_length += distance_matrix[tour[i], tour[i+1]]\n            tour_lengths.append(tour_length)\n\n        # Update pheromones\n        delta_pheromone = np.zeros_like(distance_matrix)\n        for k in range(n):\n            tour = tours[k]\n            tour_length = tour_lengths[k]\n            for i in range(n):\n                delta_pheromone[tour[i], tour[i+1]] += Q / tour_length\n                delta_pheromone[tour[i+1], tour[i]] += Q / tour_length\n\n        pheromone = (1 - rho) * pheromone + delta_pheromone\n\n        # Update heuristic matrix\n        for tour in tours:\n            for i in range(n):\n                heuristics_matrix[tour[i], tour[i+1]] += 1\n                heuristics_matrix[tour[i+1], tour[i]] += 1\n\n    heuristics_matrix /= (num_iterations * n)\n    return heuristics_matrix",
          "objective": 6.0133,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm samples TSP solutions using a nearest neighbor heuristic and biases edge selection towards shorter distances and edges frequently appearing in good solutions.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm samples TSP solutions using a nearest neighbor heuristic and biases edge selection towards shorter distances and edges frequently appearing in good solutions.}\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    num_samples = 100\n\n    for _ in range(num_samples):\n        start_node = np.random.randint(n)\n        current_node = start_node\n        unvisited_nodes = set(range(n))\n        unvisited_nodes.remove(current_node)\n        path = [current_node]\n        path_length = 0\n\n        while unvisited_nodes:\n            nearest_neighbor = None\n            min_distance = np.inf\n            for neighbor in unvisited_nodes:\n                distance = distance_matrix[current_node, neighbor]\n                if distance < min_distance:\n                    min_distance = distance\n                    nearest_neighbor = neighbor\n\n            path.append(nearest_neighbor)\n            path_length += distance_matrix[current_node, nearest_neighbor]\n            unvisited_nodes.remove(nearest_neighbor)\n            current_node = nearest_neighbor\n        \n        path.append(start_node)\n        path_length += distance_matrix[current_node, start_node]\n        \n        for i in range(n):\n            heuristics_matrix[path[i], path[i+1]] += 1.0 / path_length\n            heuristics_matrix[path[i+1], path[i]] += 1.0 / path_length\n\n    # Incorporate distance information directly\n    heuristics_matrix = heuristics_matrix / np.max(heuristics_matrix)\n    heuristics_matrix = heuristics_matrix / (distance_matrix / np.max(distance_matrix))\n    \n    return heuristics_matrix",
          "objective": 6.08504,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm samples TSP solutions using a greedy nearest neighbor heuristic with probabilistic edge selection, favoring shorter distances and edges appearing in previously sampled good solutions, and updates a pheromone-inspired matrix.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm samples TSP solutions using a greedy nearest neighbor heuristic with probabilistic edge selection, favoring shorter distances and edges appearing in previously sampled good solutions, and updates a pheromone-inspired matrix.}\"\"\"\n    n = distance_matrix.shape[0]\n    pheromone_matrix = np.ones_like(distance_matrix, dtype=float)\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    num_samples = 100\n    alpha = 1.0\n    beta = 2.0\n    decay_rate = 0.1\n\n    for _ in range(num_samples):\n        start_node = np.random.randint(n)\n        current_node = start_node\n        unvisited_nodes = set(range(n))\n        unvisited_nodes.remove(current_node)\n        path = [current_node]\n        path_length = 0\n\n        while unvisited_nodes:\n            probabilities = np.zeros(n)\n            for neighbor in unvisited_nodes:\n                probabilities[neighbor] = (pheromone_matrix[current_node, neighbor]**alpha) / (distance_matrix[current_node, neighbor]**beta)\n            \n            probabilities = probabilities / np.sum(probabilities)\n            \n            nearest_neighbor = np.random.choice(n, p=probabilities)\n            \n            if nearest_neighbor not in unvisited_nodes:\n                available_nodes = list(unvisited_nodes)\n                nearest_neighbor = available_nodes[0] if len(available_nodes) > 0 else None\n                \n                if nearest_neighbor is None:\n                    break\n            \n\n            path.append(nearest_neighbor)\n            path_length += distance_matrix[current_node, nearest_neighbor]\n            unvisited_nodes.remove(nearest_neighbor)\n            current_node = nearest_neighbor\n        \n        if len(path) != n:\n            continue\n        \n        path.append(start_node)\n        path_length += distance_matrix[current_node, start_node]\n        \n        for i in range(n):\n            heuristics_matrix[path[i], path[i+1]] += 1.0 / path_length\n            heuristics_matrix[path[i+1], path[i]] += 1.0 / path_length\n            pheromone_matrix[path[i], path[i+1]] += 1.0 / path_length\n            pheromone_matrix[path[i+1], path[i]] += 1.0 / path_length\n\n        pheromone_matrix *= (1 - decay_rate)\n\n    heuristics_matrix = heuristics_matrix / np.max(heuristics_matrix)\n    heuristics_matrix = heuristics_matrix / (distance_matrix / np.max(distance_matrix))\n\n    return heuristics_matrix",
          "objective": 6.09747,
          "other_inf": null
     }
]