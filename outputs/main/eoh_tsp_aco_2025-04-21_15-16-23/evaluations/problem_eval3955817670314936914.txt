import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm iteratively builds a heuristic matrix by prioritizing shorter edges and penalizing edges that would create short cycles.}"""
    n = len(distance_matrix)
    heuristics_matrix = np.zeros((n, n))

    # Initialize heuristics with inverse of distances (shorter edges are preferred)
    for i in range(n):
        for j in range(n):
            if i != j:
                heuristics_matrix[i, j] = 1 / distance_matrix[i, j]

    # Penalize edges that form short cycles (length 3 or 4)
    for i in range(n):
        for j in range(n):
            if i != j:
                # Check for cycles of length 3
                for k in range(n):
                    if k != i and k != j:
                        cycle_dist = distance_matrix[i, j] + distance_matrix[j, k] + distance_matrix[k, i]
                        if cycle_dist < 3 * np.mean(distance_matrix):  # Heuristic threshold
                            heuristics_matrix[i, j] *= 0.5  # Penalize the edge

                # Check for cycles of length 4
                for k in range(n):
                    if k != i and k != j:
                        for l in range(n):
                            if l != i and l != j and l != k:
                                cycle_dist = distance_matrix[i, j] + distance_matrix[j, k] + distance_matrix[k, l] + distance_matrix[l, i]
                                if cycle_dist < 4 * np.mean(distance_matrix):
                                    heuristics_matrix[i, j] *= 0.5  # Penalize the edge

    return heuristics_matrix
