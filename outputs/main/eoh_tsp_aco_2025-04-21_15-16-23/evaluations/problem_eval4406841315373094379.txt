import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm estimates edge desirability for TSP by combining shortest path edge frequencies with simulated annealing to refine the solution.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros((n, n))
    num_shortest_paths = 50
    num_iterations_sa = 1000
    initial_temperature = 100
    cooling_rate = 0.95

    # Calculate shortest paths and edge frequencies
    for _ in range(num_shortest_paths):
        start_node = np.random.randint(n)
        unvisited = set(range(n))
        path = [start_node]
        unvisited.remove(start_node)

        while unvisited:
            distances = distance_matrix[path[-1], list(unvisited)]
            next_node = list(unvisited)[np.argmin(distances)]
            path.append(next_node)
            unvisited.remove(next_node)
        
        path.append(start_node)

        for i in range(n):
            node1 = path[i]
            node2 = path[(i + 1) % n]
            heuristics_matrix[node1, node2] += 1
            heuristics_matrix[node2, node1] += 1

    heuristics_matrix /= num_shortest_paths

    # Simulated Annealing to refine heuristics
    current_solution = np.random.permutation(n).tolist()
    current_solution.append(current_solution[0])
    current_solution = current_solution[:-1]
    
    def calculate_tour_length(tour):
        length = 0
        for i in range(n):
            length += distance_matrix[tour[i], tour[(i + 1) % n]]
        return length
    
    current_cost = calculate_tour_length(current_solution)
    temperature = initial_temperature

    for _ in range(num_iterations_sa):
        i, j = np.random.choice(n, 2, replace=False)
        
        neighbor_solution = current_solution[:]
        neighbor_solution[i], neighbor_solution[j] = neighbor_solution[j], neighbor_solution[i]
        neighbor_cost = calculate_tour_length(neighbor_solution)

        cost_difference = neighbor_cost - current_cost

        if cost_difference < 0 or np.random.rand() < np.exp(-cost_difference / temperature):
            
            for k in range(n):
                heuristics_matrix[current_solution[k], current_solution[(k + 1) % n]] *= 0.9
                heuristics_matrix[current_solution[(k + 1) % n], current_solution[k]] *= 0.9

            current_solution = neighbor_solution
            current_cost = neighbor_cost

            for k in range(n):
                heuristics_matrix[current_solution[k], current_solution[(k + 1) % n]] += 0.1
                heuristics_matrix[current_solution[(k + 1) % n], current_solution[k]] += 0.1
        temperature *= cooling_rate
    
    return heuristics_matrix
