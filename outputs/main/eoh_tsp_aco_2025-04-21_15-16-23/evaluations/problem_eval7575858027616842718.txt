import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm uses a greedy approach to construct a tour, iteratively adding the shortest edge that doesn't create a cycle or exceed node degree limits, and returns a heuristic matrix based on edge usage in the greedy tour.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    edges = []
    for i in range(n):
        for j in range(i + 1, n):
            edges.append((i, j, distance_matrix[i, j]))
    
    edges.sort(key=lambda x: x[2])
    
    parent = list(range(n))
    degree = [0] * n

    def find(i):
        if parent[i] == i:
            return i
        parent[i] = find(parent[i])
        return parent[i]

    def union(i, j):
        root_i = find(i)
        root_j = find(j)
        if root_i != root_j:
            parent[root_i] = root_j
            return True
        return False
    
    num_edges = 0
    
    for u, v, dist in edges:
        if find(u) != find(v) and degree[u] < 2 and degree[v] < 2:
            if union(u, v):
                heuristics_matrix[u, v] = 1
                heuristics_matrix[v, u] = 1
                degree[u] += 1
                degree[v] += 1
                num_edges += 1
                if num_edges == n:
                    break

    start_node = 0
    current_node = start_node
    path = [start_node]
    visited = {start_node}

    while len(path) < n:
        next_node = -1
        min_dist = float('inf')
        for i in range(n):
            if i not in visited and heuristics_matrix[current_node, i] > 0:
                if distance_matrix[current_node, i] < min_dist:
                    min_dist = distance_matrix[current_node, i]
                    next_node = i

        if next_node != -1:
            path.append(next_node)
            visited.add(next_node)
            current_node = next_node

    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

    for i in range(len(path) - 1):
        heuristics_matrix[path[i], path[i+1]] = 1
        heuristics_matrix[path[i+1], path[i]] = 1

    first_node = path[0]
    last_node = path[-1]
    heuristics_matrix[first_node, last_node] = 1
    heuristics_matrix[last_node, first_node] = 1


    return heuristics_matrix
