import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm samples TSP solutions using a randomized greedy approach, weighting edge selection by distance and accumulated edge frequencies from past successful paths, and dynamically adjusts the weighting during the sampling process.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    edge_frequency = np.zeros_like(distance_matrix, dtype=float)
    num_samples = 100
    alpha = 0.5  # Weight for edge frequency

    for _ in range(num_samples):
        start_node = np.random.randint(n)
        current_node = start_node
        unvisited = set(range(n))
        unvisited.remove(start_node)
        path = [start_node]
        path_length = 0

        while unvisited:
            # Weighted random selection of the next node
            weights = np.array([0.0 if neighbor not in unvisited else (1 / distance_matrix[current_node, neighbor]) * (1 + alpha * edge_frequency[current_node, neighbor]) for neighbor in range(n)])
            weights = weights / np.sum(weights) if np.sum(weights) > 0 else np.ones(n) / n # Normalize weights

            chosen_neighbor = np.random.choice(n, p=weights)
            while chosen_neighbor not in unvisited:
                weights[chosen_neighbor] = 0
                weights = weights / np.sum(weights) if np.sum(weights) > 0 else np.ones(n) / n
                chosen_neighbor = np.random.choice(n, p=weights)

            path.append(chosen_neighbor)
            path_length += distance_matrix[current_node, chosen_neighbor]
            unvisited.remove(chosen_neighbor)
            current_node = chosen_neighbor

        path.append(start_node)
        path_length += distance_matrix[current_node, start_node]

        # Update edge frequency based on path length
        if path_length > 0:
            reward = 1 / path_length
        else:
            reward = 0

        for i in range(n):
            node1 = path[i]
            node2 = path[i+1]
            edge_frequency[node1, node2] += reward
            edge_frequency[node2, node1] += reward

    # Normalize edge frequency
    edge_frequency = edge_frequency / np.max(edge_frequency) if np.max(edge_frequency) > 0 else edge_frequency

    heuristics_matrix = edge_frequency

    return heuristics_matrix
