import numpy as np

def heuristics_v2(distance_matrix):
    """
    {This algorithm constructs a heuristic matrix by combining inverse distance, savings values, and shortest path information to estimate the desirability of each edge in the TSP solution.}
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros((n, n))

    # Inverse distance heuristic
    inverse_distance = 1 / (distance_matrix + np.eye(n))
    heuristics_matrix += inverse_distance

    # Savings heuristic (Clarke-Wright)
    savings = np.zeros((n, n))
    for i in range(n):
        for j in range(n):
            if i != j:
                savings[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]
    heuristics_matrix += savings

    # Shortest path heuristic
    shortest_paths = np.zeros((n, n))
    for i in range(n):
        for j in range(n):
            if i != j:
                 # Find shortest paths between all pairs using Floyd-Warshall (simple for this example)
                 dist = np.copy(distance_matrix)
                 for k in range(n):
                    for l in range(n):
                        for m in range(n):
                            dist[l, m] = min(dist[l, m], dist[l, k] + dist[k, m])
                 shortest_paths[i, j] = dist[i, j]

    inverse_shortest_paths = 1 / (shortest_paths + np.eye(n))
    heuristics_matrix += inverse_shortest_paths

    # Normalize the heuristic matrix (optional, but often helpful)
    max_val = np.max(heuristics_matrix)
    if max_val > 0:
        heuristics_matrix /= max_val

    return heuristics_matrix
