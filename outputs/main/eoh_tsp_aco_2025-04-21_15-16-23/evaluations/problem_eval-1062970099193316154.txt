import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm initializes a heuristic matrix with inverse distances, refines it through simulated annealing by accepting edge swaps based on a temperature-dependent probability, and returns the refined matrix.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = 1 / (distance_matrix + np.eye(n))  # Initialize with inverse distances, avoid division by zero
    
    temperature = 100.0
    cooling_rate = 0.95
    num_iterations = 1000

    for _ in range(num_iterations):
        i = np.random.randint(0, n)
        j = np.random.randint(0, n)
        k = np.random.randint(0, n)
        l = np.random.randint(0, n)
        
        if i == j or k == l:
            continue
            
        current_cost = heuristics_matrix[i, j] + heuristics_matrix[k, l]
        new_cost = heuristics_matrix[i, l] + heuristics_matrix[k, j]
        
        cost_diff = new_cost - current_cost
        
        if cost_diff < 0 or np.random.rand() < np.exp(-cost_diff / temperature):
            heuristics_matrix[i, j] = new_cost / 2
            heuristics_matrix[j, i] = new_cost / 2
            heuristics_matrix[k, l] = new_cost / 2
            heuristics_matrix[l, k] = new_cost / 2
            heuristics_matrix[i, l] = current_cost / 2
            heuristics_matrix[l, i] = current_cost / 2
            heuristics_matrix[k, j] = current_cost / 2
            heuristics_matrix[j, k] = current_cost / 2

        temperature *= cooling_rate

    return heuristics_matrix
