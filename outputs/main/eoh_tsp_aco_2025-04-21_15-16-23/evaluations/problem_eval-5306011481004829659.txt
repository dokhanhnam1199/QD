import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm constructs a heuristic matrix by simulating a simplified evolutionary process where solutions are iteratively improved by mutation and selection based on tour length.}"""
    n = distance_matrix.shape[0]
    num_solutions = 50
    num_iterations = 100
    mutation_rate = 0.1

    # Initialize solutions randomly
    solutions = []
    for _ in range(num_solutions):
        solution = np.random.permutation(n)
        solutions.append(solution)

    def calculate_tour_length(solution):
        length = 0
        for i in range(n):
            length += distance_matrix[solution[i], solution[(i + 1) % n]]
        return length

    for iteration in range(num_iterations):
        # Mutate solutions
        mutated_solutions = []
        for solution in solutions:
            if np.random.rand() < mutation_rate:
                # Swap two random cities
                idx1, idx2 = np.random.choice(n, 2, replace=False)
                mutated_solution = solution.copy()
                mutated_solution[idx1], mutated_solution[idx2] = mutated_solution[idx2], mutated_solution[idx1]
                mutated_solutions.append(mutated_solution)
            else:
                mutated_solutions.append(solution)

        # Evaluate tour lengths
        tour_lengths = [calculate_tour_length(solution) for solution in mutated_solutions]

        # Selection (keep best solutions)
        sorted_indices = np.argsort(tour_lengths)
        solutions = [mutated_solutions[i] for i in sorted_indices[:num_solutions // 2]] # Keep best half
        while len(solutions) < num_solutions:
            solutions.append(mutated_solutions[np.random.choice(sorted_indices[:num_solutions//2])])

    # Construct heuristic matrix based on solution frequency
    heuristics_matrix = np.zeros((n, n))
    for solution in solutions:
        for i in range(n):
            heuristics_matrix[solution[i], solution[(i + 1) % n]] += 1
            heuristics_matrix[solution[(i + 1) % n], solution[i]] += 1

    heuristics_matrix /= np.max(heuristics_matrix) if np.max(heuristics_matrix) > 0 else 1
    return heuristics_matrix
