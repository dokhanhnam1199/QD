import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm refines the heuristic matrix by iteratively exploring paths using a combination of pheromone trails and distance, and updates pheromones based on path quality with a focus on global best solution and pheromone smoothing.}"""
    n = distance_matrix.shape[0]
    pheromone = np.ones((n, n))  # Initialize pheromone trails
    heuristics_matrix = np.zeros((n, n))
    alpha = 0.8  # Pheromone influence
    beta = 1.5  # Distance influence
    rho = 0.2  # Evaporation rate
    Q = 100    # Pheromone deposit constant
    num_ants = 25
    num_iterations = 50
    
    global_best_path = None
    global_best_length = float('inf')

    for iteration in range(num_iterations):
        all_paths = []
        all_path_lengths = []

        for ant in range(num_ants):
            start_node = np.random.randint(n)
            current_node = start_node
            unvisited = set(range(n))
            unvisited.remove(current_node)
            path = [current_node]

            while unvisited:
                probabilities = (pheromone[current_node, :]**alpha) * ((1 / (distance_matrix[current_node, :] + 1e-6))**beta)
                
                # Mask visited nodes
                for visited_node in path:
                    probabilities[visited_node] = 0
                
                probabilities = probabilities / np.sum(probabilities) if np.sum(probabilities) > 0 else np.ones(n) / n

                next_node = np.random.choice(n, p=probabilities)
                path.append(next_node)
                unvisited.remove(next_node)
                current_node = next_node

            path.append(start_node)
            all_paths.append(path)

            path_length = 0
            for i in range(n):
                path_length += distance_matrix[path[i], path[(i + 1) % n]]
            all_path_lengths.append(path_length)

        # Find the best path in this iteration
        best_path_index = np.argmin(all_path_lengths)
        best_path = all_paths[best_path_index]
        best_path_length = all_path_lengths[best_path_index]
        
        # Update global best
        if best_path_length < global_best_length:
            global_best_length = best_path_length
            global_best_path = best_path

        # Update pheromones based on global best
        pheromone *= (1 - rho)  # Evaporation

        if global_best_path is not None:
            for i in range(n):
                pheromone[global_best_path[i], global_best_path[(i + 1) % n]] += Q / global_best_length
                pheromone[global_best_path[(i + 1) % n], global_best_path[i]] += Q / global_best_length
        
        # Pheromone smoothing - prevent premature convergence
        pheromone = (pheromone + pheromone.T) / 2

    # Construct heuristic matrix based on pheromone levels
    heuristics_matrix = pheromone
    return heuristics_matrix
