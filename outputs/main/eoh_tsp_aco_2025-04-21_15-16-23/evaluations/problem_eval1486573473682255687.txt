import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm samples many near-optimal TSP solutions using a greedy nearest neighbor approach with stochastic restarts and edge recombination, then aggregates edge frequencies to estimate edge inclusion probabilities.}"""
    n = distance_matrix.shape[0]
    num_samples = 1000
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

    for _ in range(num_samples):
        start_node = np.random.randint(n)
        current_node = start_node
        unvisited_nodes = set(range(n))
        unvisited_nodes.remove(current_node)
        tour = [current_node]
        
        while unvisited_nodes:
            distances = distance_matrix[current_node, :]
            
            # Apply stochasticity: select from the k-nearest neighbors
            k = min(5, len(unvisited_nodes))  # Consider top k nearest neighbors
            nearest_neighbors_indices = np.argsort(distances)[1:] #exclude the same node itself from consideration
            
            valid_neighbors = [idx for idx in nearest_neighbors_indices if idx in unvisited_nodes] #select only unvisited ones
            
            if len(valid_neighbors) > 0:
                
                if len(valid_neighbors) <= k:
                     chosen_neighbor = np.random.choice(valid_neighbors) #random choice from all valid neighbours
                else:
                    chosen_neighbor = np.random.choice(valid_neighbors[:k]) #random choice from k nearest neighbors
                
                tour.append(chosen_neighbor)
                unvisited_nodes.remove(chosen_neighbor)
                current_node = chosen_neighbor
            else:
                 # Handle the edge case where there are no unvisited nodes.
                break


        # Complete the tour if necessary
        if len(tour) < n:
            remaining_nodes = list(set(range(n)) - set(tour))
            tour.extend(remaining_nodes)
            
        # Ensure tour is closed: add start node at the end
        tour.append(start_node)
        

        # Update heuristics matrix
        for i in range(n):
            heuristics_matrix[tour[i], tour[i+1]] += 1
            heuristics_matrix[tour[i+1], tour[i]] += 1  # Symmetric

    heuristics_matrix /= num_samples
    return heuristics_matrix
