import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm creates a heuristic matrix based on a combination of inverse distance and shortest path estimations.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros((n, n))

    # Inverse distance heuristic
    inverse_distance = 1 / (distance_matrix + 1e-6)

    # Shortest path heuristic
    shortest_paths = np.zeros((n, n))
    for i in range(n):
        for j in range(n):
            if i != j:
                # Dijkstra's algorithm (simplified for demonstration)
                unvisited = set(range(n))
                distances = {node: float('inf') for node in range(n)}
                distances[i] = 0
                
                while unvisited:
                    current_node = min(unvisited, key=distances.get)
                    
                    if distances[current_node] == float('inf'):
                        break
                    
                    unvisited.remove(current_node)
                    
                    for neighbor in range(n):
                        if distance_matrix[current_node, neighbor] > 0:
                            new_distance = distances[current_node] + distance_matrix[current_node, neighbor]
                            if new_distance < distances[neighbor]:
                                distances[neighbor] = new_distance
                shortest_paths[i, j] = distances[j]

    # Combine heuristics
    heuristics_matrix = inverse_distance + (1 / (shortest_paths + 1e-6))
    return heuristics_matrix
