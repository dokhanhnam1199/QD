import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm samples multiple random paths, improves them using 2-opt swaps, and averages the edge frequencies across the improved paths to generate a heuristic matrix.}"""
    n = distance_matrix.shape[0]
    num_samples = 100
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

    for _ in range(num_samples):
        # 1. Generate a random path
        path = np.random.permutation(n)

        # 2. Improve the path using 2-opt swaps
        improved_path = two_opt(path, distance_matrix)

        # 3. Update the heuristics matrix based on the improved path
        for i in range(n):
            u = improved_path[i]
            v = improved_path[(i + 1) % n]
            heuristics_matrix[u, v] += 1
            heuristics_matrix[v, u] += 1

    # 4. Normalize the heuristics matrix
    heuristics_matrix /= num_samples

    return heuristics_matrix


def two_opt(path, distance_matrix):
    """Improves a given path using 2-opt swaps."""
    n = len(path)
    improved = True
    best_path = path.copy()
    best_distance = path_distance(path, distance_matrix)

    while improved:
        improved = False
        for i in range(1, n - 1):
            for k in range(i + 1, n):
                new_path = path_2opt_swap(best_path, i, k)
                new_distance = path_distance(new_path, distance_matrix)

                if new_distance < best_distance:
                    best_distance = new_distance
                    best_path = new_path
                    improved = True
        if improved:
            path = best_path.copy()

    return best_path


def path_2opt_swap(path, i, k):
    """Performs a 2-opt swap on a given path."""
    new_path = path[:i] + path[i:k+1][::-1] + path[k+1:]
    return new_path


def path_distance(path, distance_matrix):
    """Calculates the total distance of a given path."""
    total_distance = 0
    n = len(path)
    for i in range(n):
        u = path[i]
        v = path[(i + 1) % n]
        total_distance += distance_matrix[u, v]
    return heuristics_matrix
