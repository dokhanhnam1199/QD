import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm uses a genetic algorithm approach to evolve a population of TSP tours, selecting and mutating tours based on their length, and then constructs a heuristic matrix based on the frequency of each edge appearing in the best tours of the final generation.}"""
    n = distance_matrix.shape[0]
    population_size = 50
    mutation_rate = 0.05
    num_generations = 100

    # Initialize population with random tours
    population = []
    for _ in range(population_size):
        tour = np.random.permutation(n)
        population.append(tour)

    def calculate_tour_length(tour):
        length = 0
        for i in range(n):
            length += distance_matrix[tour[i], tour[(i + 1) % n]]
        return length

    for generation in range(num_generations):
        # Evaluate fitness of each tour
        fitness = [calculate_tour_length(tour) for tour in population]
        
        # Selection (tournament selection)
        selected_indices = np.random.choice(population_size, size=population_size, replace=True)
        selected_population = [population[i] for i in selected_indices]
        
        # Crossover (order crossover) and Mutation (swap mutation)
        new_population = []
        for i in range(0, population_size, 2):
            parent1 = selected_population[i]
            parent2 = selected_population[(i + 1) % population_size]

            # Crossover
            start = np.random.randint(n)
            length = np.random.randint(1, n - 1)
            child1 = np.zeros(n, dtype=int)
            child2 = np.zeros(n, dtype=int)

            child1[start:(start + length) % n] = parent1[start:(start + length) % n]
            child2[start:(start + length) % n] = parent2[start:(start + length) % n]

            remaining1 = [node for node in parent2 if node not in child1]
            remaining2 = [node for node in parent1 if node not in child2]

            child1[np.where(child1 == 0)[0]] = remaining1
            child2[np.where(child2 == 0)[0]] = remaining2
            
            # Mutation
            if np.random.rand() < mutation_rate:
                idx1, idx2 = np.random.choice(n, 2, replace=False)
                child1[idx1], child1[idx2] = child1[idx2], child1[idx1]
            if np.random.rand() < mutation_rate:
                idx1, idx2 = np.random.choice(n, 2, replace=False)
                child2[idx1], child2[idx2] = child2[idx2], child2[idx1]

            new_population.append(child1)
            new_population.append(child2)

        population = new_population
    
    # Construct heuristic matrix based on the best tours in the final generation
    best_tours_count = 10  # Consider the top N best tours
    sorted_indices = np.argsort(fitness)
    best_tours = [population[i] for i in sorted_indices[:best_tours_count]]
    
    heuristics_matrix = np.zeros((n, n))
    for tour in best_tours:
        for i in range(n):
            heuristics_matrix[tour[i], tour[(i + 1) % n]] += 1
            heuristics_matrix[tour[(i + 1) % n], tour[i]] += 1

    heuristics_matrix /= (best_tours_count * 2)  # Normalize by the number of tours considered and edges per tour
    
    return heuristics_matrix
