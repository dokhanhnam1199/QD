import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm constructs a heuristic matrix by simulating a simplified ACO, where the heuristic value for an edge is proportional to the inverse of the distance and is dynamically adjusted by the pheromone level updated based on random walks.}"""
    n = distance_matrix.shape[0]
    pheromone = np.ones((n, n))
    heuristics_matrix = np.zeros((n, n))
    rho = 0.05
    Q = 10
    num_walks = 30
    walk_length = n // 2

    for _ in range(num_walks):
        start_node = np.random.randint(n)
        current_node = start_node
        path = [current_node]

        for _ in range(walk_length):
            probabilities = pheromone[current_node, :] / np.sum(pheromone[current_node, :] + 1e-6) if np.sum(pheromone[current_node, :]) > 0 else np.ones(n) / n
            next_node = np.random.choice(n, p=probabilities)
            path.append(next_node)
            current_node = next_node

        for i in range(len(path) - 1):
            pheromone[path[i], path[i+1]] += Q / distance_matrix[path[i], path[i+1]]
            pheromone[path[i+1], path[i]] += Q / distance_matrix[path[i+1], path[i]]

        pheromone *= (1 - rho)

    heuristics_matrix = pheromone / (distance_matrix + 1e-6)
    return heuristics_matrix
