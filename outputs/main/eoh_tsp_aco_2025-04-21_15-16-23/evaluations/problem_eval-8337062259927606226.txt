import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm generates multiple tours by iteratively adding the edge with the highest probability based on previous tours and a decay factor, then averages the edge frequencies across these tours to produce a heuristic matrix.}"""
    n = distance_matrix.shape[0]
    num_samples = 1000
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    edge_probabilities = np.ones_like(distance_matrix)  # Initialize edge probabilities
    decay_factor = 0.9  # Decay factor for edge probabilities

    for _ in range(num_samples):
        tour = []
        unvisited_nodes = set(range(n))
        start_node = np.random.randint(n)
        current_node = start_node
        tour.append(current_node)
        unvisited_nodes.remove(current_node)

        while unvisited_nodes:
            # Calculate edge scores based on distance and probability
            edge_scores = np.zeros(n)
            for neighbor in range(n):
                if neighbor in unvisited_nodes:
                    edge_scores[neighbor] = edge_probabilities[current_node, neighbor] / distance_matrix[current_node, neighbor]

            # Select the next node with the highest score
            if np.any(edge_scores > 0):  #check if array is non-empty and contains at least one element bigger than zero to avoid a warning
                next_node = np.argmax(edge_scores)
            else:
                next_node = np.random.choice(list(unvisited_nodes)) # Handle the case where no scores are positive.

            tour.append(next_node)
            unvisited_nodes.remove(next_node)
            current_node = next_node
            

        tour.append(start_node)

        # Update heuristics matrix and edge probabilities
        for i in range(n):
            node1 = tour[i]
            node2 = tour[i + 1]
            heuristics_matrix[node1, node2] += 1
            heuristics_matrix[node2, node1] += 1

            # Decrease probability of edges not in the tour, increase for edges in the tour
            for u in range(n):
                for v in range(n):
                    if (u == node1 and v == node2) or (u == node2 and v == node1):
                        edge_probabilities[u, v] = min(1.0, edge_probabilities[u, v] + 0.1) #Increase by a small constant rather than set to one
                    else:
                        edge_probabilities[u, v] *= decay_factor

    heuristics_matrix /= num_samples
    return heuristics_matrix
