import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm constructs a heuristic matrix based on a nearest neighbor approach combined with random perturbations to diversify the search.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros((n, n))

    for i in range(n):
        # Find nearest neighbors for node i
        distances = distance_matrix[i, :]
        sorted_indices = np.argsort(distances)

        # Assign high heuristic values to nearest neighbors
        num_neighbors = min(5, n - 1)  # Consider top 5 nearest neighbors
        for j in range(1, num_neighbors + 1):  # Exclude the node itself
            neighbor_index = sorted_indices[j]
            heuristics_matrix[i, neighbor_index] = 1 / (distance_matrix[i, neighbor_index] + 1e-6)
            heuristics_matrix[neighbor_index, i] = 1 / (distance_matrix[neighbor_index, i] + 1e-6)

        # Add some random exploration
        num_random = min(3, n - num_neighbors -1)
        remaining_nodes = np.array([k for k in range(n) if k not in sorted_indices[:num_neighbors+1] and k != i])

        if remaining_nodes.size > 0:
            random_indices = np.random.choice(remaining_nodes, size=min(num_random, remaining_nodes.size), replace=False)
            for rand_index in random_indices:
                heuristics_matrix[i, rand_index] = 0.5 / (distance_matrix[i, rand_index] + 1e-6)
                heuristics_matrix[rand_index, i] = 0.5 / (distance_matrix[rand_index, i] + 1e-6)

    return heuristics_matrix
