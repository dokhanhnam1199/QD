import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm constructs a heuristic matrix by combining shortest-edge preference with cycle-breaking encouragement and path-smoothing rewards to guide TSP solvers.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

    # Heuristic 1: Shortest edge preference (normalized inverse distance)
    max_distance = np.max(distance_matrix)
    heuristics_matrix = (max_distance - distance_matrix) / max_distance  # Normalize to [0, 1]

    # Heuristic 2: Cycle-breaking encouragement
    for i in range(n):
        for j in range(n):
            if i != j:
                # Encourage edges that break small cycles.  This is a simplified approximation.
                neighbors_i = np.argsort(distance_matrix[i, :])[1:4]  # 3 nearest neighbors of i
                neighbors_j = np.argsort(distance_matrix[j, :])[1:4]  # 3 nearest neighbors of j

                common_neighbors = len(set(neighbors_i).intersection(neighbors_j))
                heuristics_matrix[i, j] += 0.1 * common_neighbors # reward edges with fewer shared neighbours to avoid short cycles

    # Heuristic 3: Path smoothing (penalize sharp turns)
    for i in range(n):
        for j in range(n):
            if i != j:
                # Encourage edges that create smoother paths by considering neighbors
                best_neighbor_i = np.argsort(distance_matrix[i, :])[1]
                heuristics_matrix[i,j] -= 0.05 * distance_matrix[best_neighbor_i,j] # Penilize if it is far from the best neighbour of i

    # Ensure the diagonal elements are zero and avoid negative values
    for i in range(n):
        heuristics_matrix[i, i] = 0
        for j in range(n):
            heuristics_matrix[i, j] = max(0, heuristics_matrix[i, j])  # Ensure no negative values

    return heuristics_matrix
