import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm samples multiple solutions using a nearest neighbor heuristic with random starting nodes and edge selection probabilities biased towards shorter distances, then averages the edge frequencies across these solutions to generate a heuristic matrix.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros((n, n))
    num_samples = 100

    for _ in range(num_samples):
        start_node = np.random.randint(n)
        current_node = start_node
        unvisited = set(range(n))
        unvisited.remove(current_node)
        path = [current_node]

        while unvisited:
            distances = distance_matrix[current_node, :]
            probabilities = 1 / (distances + 1e-6)  # Bias towards shorter distances
            probabilities[current_node] = 0  # Avoid revisiting the current node
            
            # Mask visited nodes
            for visited_node in path:
                probabilities[visited_node] = 0
                
            probabilities = probabilities / np.sum(probabilities) if np.sum(probabilities) > 0 else np.ones(n) / n # Avoid division by zero
            
            next_node = np.random.choice(n, p=probabilities)
            
            path.append(next_node)
            unvisited.remove(next_node)
            current_node = next_node

        path.append(start_node)  # Return to the start

        for i in range(n):
            heuristics_matrix[path[i], path[(i + 1) % n]] += 1
            heuristics_matrix[path[(i + 1) % n], path[i]] += 1 #Symmetric

    heuristics_matrix = heuristics_matrix / num_samples
    return heuristics_matrix
