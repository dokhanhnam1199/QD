import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm constructs a heuristic matrix by combining shortest path distances with a node-centrality measure derived from shortest path counts between all node pairs.}"""
    n = distance_matrix.shape[0]
    
    # Shortest path distance heuristic
    shortest_path_heuristic = 1 / (distance_matrix + np.eye(n))  # Add identity to avoid division by zero for self-loops
    np.fill_diagonal(shortest_path_heuristic, 0) # Ensure self-loops are zero
    
    # Calculate all-pairs shortest paths using Dijkstra's algorithm as an alternative to Floyd-Warshall
    shortest_paths = np.zeros((n, n), dtype=int)
    for start_node in range(n):
        dist = np.full(n, np.inf)
        dist[start_node] = 0
        visited = np.zeros(n, dtype=bool)
        
        for _ in range(n):
            u = -1
            min_dist = np.inf
            for v in range(n):
                if not visited[v] and dist[v] < min_dist:
                    min_dist = dist[v]
                    u = v
            
            if u == -1:
                break
            
            visited[u] = True
            
            for v in range(n):
                if distance_matrix[u, v] > 0 and dist[u] + distance_matrix[u, v] < dist[v]:
                    dist[v] = dist[u] + distance_matrix[u, v]
        
        shortest_paths[start_node, :] = dist
    
    # Node betweenness centrality heuristic (approximate using shortest paths)
    node_centrality = np.zeros(n)
    for i in range(n):
      for j in range(n):
        if i != j:
          #Count occurrences of each node on the shortest paths
          
          #Use a simplified approximation where we just increment all nodes besides the start and end
          nodes_on_path = list(range(n))
          for node in nodes_on_path:
            if node != i and node !=j:
              node_centrality[node] += 1

    # Normalize centrality
    node_centrality /= np.max(node_centrality) if np.max(node_centrality) > 0 else 1

    # Edge-based centrality: product of endpoint centralities
    edge_centrality = np.zeros((n, n))
    for i in range(n):
        for j in range(n):
            edge_centrality[i, j] = node_centrality[i] * node_centrality[j]

    # Combine heuristics
    heuristics_matrix = shortest_path_heuristic + edge_centrality
    heuristics_matrix /= np.max(heuristics_matrix)
    
    return heuristics_matrix
