import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm estimates edge desirability by combining information from shortest path computations with randomized perturbations of edge costs to diversify the exploration of the solution space.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros((n, n))
    num_iterations = 50
    shortest_path_counts = np.zeros((n, n))

    def shortest_path(cost_matrix, start_node):
        dist = {node: float('inf') for node in range(n)}
        dist[start_node] = 0
        unvisited = set(range(n))

        while unvisited:
            current_node = min(unvisited, key=dist.get)
            unvisited.remove(current_node)

            for neighbor in range(n):
                if cost_matrix[current_node, neighbor] != float('inf'):
                    alt_path = dist[current_node] + cost_matrix[current_node, neighbor]
                    if alt_path < dist[neighbor]:
                        dist[neighbor] = alt_path
        return dist
    
    for _ in range(num_iterations):
        # Perturb the distance matrix
        perturbed_matrix = distance_matrix + np.random.normal(0, np.std(distance_matrix)/5, size=(n, n))
        perturbed_matrix[perturbed_matrix < 0] = 0
        
        #Replace 0 with infinity
        perturbed_matrix[perturbed_matrix == 0] = float('inf')
        np.fill_diagonal(perturbed_matrix,0)

        # Compute shortest paths from each node
        for start_node in range(n):
            distances = shortest_path(perturbed_matrix, start_node)

            # Count edges used in shortest paths (naive approach - just increment all neighbors in each of the shortest path)
            for end_node in range(n):
               if(distances[end_node]!=float('inf')):
                    heuristics_matrix[start_node, end_node] += 1/(distances[end_node]+1e-6)
                    heuristics_matrix[end_node, start_node] += 1/(distances[end_node]+1e-6)

    return heuristics_matrix
