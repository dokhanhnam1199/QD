import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm constructs a heuristic matrix by using a combination of inverse distance and a clustering coefficient to prioritize edges that connect nearby nodes within denser regions of the graph.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros((n, n))

    # Calculate inverse distances (with a small constant to avoid division by zero)
    inverse_distances = 1 / (distance_matrix + 1e-6)

    # Calculate a clustering coefficient-like measure for each node
    clustering_coefficients = np.zeros(n)
    for i in range(n):
        neighbors = np.argsort(distance_matrix[i, :])[1:11]  # Consider the 10 nearest neighbors
        num_edges_between_neighbors = 0
        for j in range(len(neighbors)):
            for k in range(j + 1, len(neighbors)):
                if distance_matrix[neighbors[j], neighbors[k]] < np.mean(distance_matrix): # If the distance between 2 neighbors is small enough
                  num_edges_between_neighbors += 1
        max_possible_edges = len(neighbors) * (len(neighbors) - 1) / 2
        clustering_coefficients[i] = num_edges_between_neighbors / (max_possible_edges + 1e-6) if max_possible_edges > 0 else 0

    # Combine inverse distance and clustering coefficient
    for i in range(n):
        for j in range(n):
            if i != j:
                heuristics_matrix[i, j] = inverse_distances[i, j] * (clustering_coefficients[i] + clustering_coefficients[j]) / 2 #Use the average of two clustering_coefficients

    return heuristics_matrix
