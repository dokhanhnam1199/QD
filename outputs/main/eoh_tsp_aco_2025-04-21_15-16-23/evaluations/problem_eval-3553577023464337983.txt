import numpy as np

def heuristics_v2(distance_matrix):
    """
    {This algorithm iteratively samples random paths, favoring shorter edges and penalizing edges that frequently appear in long paths, to generate a heuristic matrix indicating the likelihood of each edge being part of an optimal TSP solution.}
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    num_iterations = 1000
    alpha = 0.1 
    beta = 0.9

    for _ in range(num_iterations):
        # Sample a random path with preference for shorter edges
        current_node = np.random.randint(n)
        unvisited_nodes = set(range(n))
        unvisited_nodes.remove(current_node)
        path = [current_node]
        total_distance = 0

        while unvisited_nodes:
            probabilities = np.zeros(n)
            for neighbor in unvisited_nodes:
                probabilities[neighbor] = (1 / distance_matrix[current_node, neighbor])**2 # Prefer shorter distances
            
            probabilities /= np.sum(probabilities)
            next_node = np.random.choice(n, p=probabilities)
            
            if next_node not in unvisited_nodes:
                available_nodes = list(unvisited_nodes)
                if len(available_nodes) > 0:
                    next_node = available_nodes[0]
                else:
                    break
            
            path.append(next_node)
            total_distance += distance_matrix[current_node, next_node]
            current_node = next_node
            unvisited_nodes.remove(current_node)

        # Complete the cycle
        path.append(path[0])
        total_distance += distance_matrix[path[-2], path[0]]

        # Update the heuristic matrix based on path quality
        for i in range(n):
            j = (i + 1) % n
            node1 = path[i]
            node2 = path[j]

            heuristics_matrix[node1, node2] = beta * heuristics_matrix[node1, node2] + alpha * (1 / total_distance)
            heuristics_matrix[node2, node1] = beta * heuristics_matrix[node2, node1] + alpha * (1 / total_distance)

    return heuristics_matrix
