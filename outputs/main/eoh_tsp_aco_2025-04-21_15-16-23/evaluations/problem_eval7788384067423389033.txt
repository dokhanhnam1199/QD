import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm constructs tours by iteratively inserting nodes into the best possible position in a growing tour, guided by a cost-benefit analysis that considers both distance and centrality.}"""
    n = len(distance_matrix)
    heuristics_matrix = np.zeros((n, n))
    num_samples = 100

    for _ in range(num_samples):
        start_node = np.random.randint(n)
        tour = [start_node]
        unvisited = set(range(n))
        unvisited.remove(start_node)

        while unvisited:
            best_node = None
            best_position = None
            min_insertion_cost = np.inf

            for node_to_insert in unvisited:
                for i in range(len(tour)):
                    # Calculate insertion cost
                    insertion_cost = (
                        distance_matrix[tour[i - 1]][node_to_insert]
                        + distance_matrix[node_to_insert][tour[i]]
                        - distance_matrix[tour[i - 1]][tour[i]]
                    )

                    if insertion_cost < min_insertion_cost:
                        min_insertion_cost = insertion_cost
                        best_node = node_to_insert
                        best_position = i

            tour.insert(best_position, best_node)
            unvisited.remove(best_node)

        tour.append(start_node)

        for i in range(n):
            node1 = tour[i]
            node2 = tour[i + 1]
            heuristics_matrix[node1][node2] += 1
            heuristics_matrix[node2][node1] += 1

    heuristics_matrix /= num_samples
    return heuristics_matrix
