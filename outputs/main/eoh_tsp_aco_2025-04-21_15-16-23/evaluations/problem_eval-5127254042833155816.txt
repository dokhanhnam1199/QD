import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm uses a simulated annealing approach to explore the solution space, probabilistically accepting worse solutions to escape local optima and build an edge frequency matrix.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    num_iterations = 1000
    initial_temperature = 100
    cooling_rate = 0.95

    # Initialize a random tour
    current_tour = np.random.permutation(n)
    current_tour = np.append(current_tour, current_tour[0]) #close the loop

    def tour_length(tour):
      length = 0
      for i in range(len(tour) - 1):
          length += distance_matrix[tour[i], tour[i+1]]
      return length
    
    current_energy = tour_length(current_tour)

    for iteration in range(num_iterations):
        temperature = initial_temperature * (cooling_rate ** iteration)

        # Generate a neighbor tour by swapping two random nodes
        idx1, idx2 = np.random.choice(n, 2, replace=False)
        neighbor_tour = current_tour.copy()
        neighbor_tour[idx1], neighbor_tour[idx2] = neighbor_tour[idx2], neighbor_tour[idx1]

        neighbor_energy = tour_length(neighbor_tour)

        # Acceptance probability
        delta_energy = neighbor_energy - current_energy
        if delta_energy < 0 or np.random.rand() < np.exp(-delta_energy / temperature):
            current_tour = neighbor_tour
            current_energy = neighbor_energy

        # Update heuristics matrix
        for i in range(n):
            heuristics_matrix[current_tour[i], current_tour[i+1]] += 1
            heuristics_matrix[current_tour[i+1], current_tour[i]] += 1

    heuristics_matrix /= num_iterations
    return heuristics_matrix
