import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm constructs a heuristic matrix by combining a greedy nearest neighbor approach with a simulated annealing-inspired perturbation to escape local optima.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros((n, n))
    
    # Nearest neighbor initialization
    for start_node in range(n):
        path = [start_node]
        unvisited = set(range(n))
        unvisited.remove(start_node)
        current_node = start_node
        
        while unvisited:
            nearest_neighbor = -1
            min_dist = float('inf')
            for neighbor in unvisited:
                dist = distance_matrix[current_node, neighbor]
                if dist < min_dist:
                    min_dist = dist
                    nearest_neighbor = neighbor
            
            path.append(nearest_neighbor)
            unvisited.remove(nearest_neighbor)
            current_node = nearest_neighbor
        
        path.append(start_node)
        
        # Update heuristic matrix based on nearest neighbor tour
        for i in range(n):
            heuristics_matrix[path[i], path[(i + 1) % (n + 1)]] += 1
            heuristics_matrix[path[(i + 1) % (n + 1)], path[i]] += 1
    
    # Simulated annealing-inspired perturbation
    temperature = 1.0
    cooling_rate = 0.95
    num_iterations = 100

    for _ in range(num_iterations):
      
        i = np.random.randint(0, n)
        j = np.random.randint(0, n)
        
        if i != j:
          cost_reduction = distance_matrix[i,j] - distance_matrix[i, (i-1)%n] - distance_matrix[j, (j-1)%n]
        else:
          cost_reduction = 0

        if cost_reduction < 0 or np.random.rand() < np.exp(-cost_reduction / temperature):
              heuristics_matrix[i, j] += 1 * temperature
              heuristics_matrix[j, i] += 1 * temperature
            

        temperature *= cooling_rate
    

    return heuristics_matrix
