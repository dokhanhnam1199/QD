import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm creates a heuristic matrix for the TSP by prioritizing edges with short distances, encouraging connections to nodes with low average distance, and penalizing edges that would lead to high increases in path length.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    
    # Heuristic 1: Inverse of distance (shorter distances are better)
    heuristics_matrix = 1 / (distance_matrix + 1e-9)  # Add a small value to avoid division by zero
    
    # Heuristic 2: Encourage connections to nodes with low average distance
    node_avg_distances = np.mean(distance_matrix, axis=1)
    for i in range(n):
        for j in range(n):
            if i != j:
                heuristics_matrix[i, j] += 1 / (node_avg_distances[i] + node_avg_distances[j] + 1e-9)
    
    # Heuristic 3: Penalize edges that lead to high increases in path length
    for i in range(n):
        for j in range(n):
            if i != j:
                detour_penalty = 0
                for k in range(n):
                    if k != i and k != j:
                        detour_penalty += max(0, distance_matrix[i, j] - (distance_matrix[i, k] + distance_matrix[k, j]))
                heuristics_matrix[i, j] -= detour_penalty / (n * n)
    
    # Ensure the diagonal elements are zero
    for i in range(n):
        heuristics_matrix[i, i] = 0

    return heuristics_matrix
