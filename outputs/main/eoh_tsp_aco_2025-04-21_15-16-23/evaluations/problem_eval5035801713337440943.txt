import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm calculates a heuristic matrix by simulating a diffusion process where nodes exchange desirability scores based on their proximity, favoring edges connecting nodes with high mutual desirability.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros((n, n))
    initial_desirability = np.ones(n)  # Initialize node desirability

    # Diffusion parameters
    diffusion_rate = 0.1
    num_iterations = 50

    for _ in range(num_iterations):
        new_desirability = np.zeros(n)
        for i in range(n):
            # Aggregate desirability from neighbors, weighted by inverse distance
            neighbor_desirability = 0
            total_weight = 0
            for j in range(n):
                if i != j:
                    weight = 1 / (distance_matrix[i, j] + 1e-6)  # Avoid division by zero
                    neighbor_desirability += initial_desirability[j] * weight
                    total_weight += weight
            
            if total_weight > 0:
                new_desirability[i] = initial_desirability[i] + diffusion_rate * (neighbor_desirability / total_weight - initial_desirability[i])
            else:
                new_desirability[i] = initial_desirability[i]
        initial_desirability = new_desirability

    # Construct heuristic matrix based on mutual desirability
    for i in range(n):
        for j in range(n):
            if i != j:
                heuristics_matrix[i, j] = initial_desirability[i] * initial_desirability[j] / (distance_matrix[i, j] + 1e-6)

    return heuristics_matrix
