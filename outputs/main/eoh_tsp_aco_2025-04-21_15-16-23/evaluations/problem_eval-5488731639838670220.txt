import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm estimates edge desirability for TSP by combining shortest path information with a Monte Carlo sampling of tour improvements based on local search swaps.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros((n, n))
    num_samples = 50
    swap_attempts = 10

    # Precompute shortest path matrix
    shortest_paths = np.zeros((n, n))
    for i in range(n):
        for j in range(n):
            if i != j:
                shortest_paths[i, j] = distance_matrix[i, j]
            else:
                shortest_paths[i, j] = np.inf
    
    for k in range(n):
        for i in range(n):
            for j in range(n):
                shortest_paths[i, j] = min(shortest_paths[i, j], shortest_paths[i, k] + shortest_paths[k, j])

    # Monte Carlo sampling with local search
    for _ in range(num_samples):
        tour = np.random.permutation(n).tolist()
        tour_length = sum(distance_matrix[tour[i], tour[(i + 1) % n]] for i in range(n))
        
        # Local search (swap edges)
        for _ in range(swap_attempts):
            i, j = np.random.choice(n, 2, replace=False)
            if i > j:
                i, j = j, i
            
            new_tour = tour[:i] + tour[i:j+1][::-1] + tour[j+1:]
            new_tour_length = sum(distance_matrix[new_tour[k], new_tour[(k + 1) % n]] for k in range(n))
            
            if new_tour_length < tour_length:
                tour = new_tour
                tour_length = new_tour_length

        # Update heuristics matrix
        for i in range(n):
            node1 = tour[i]
            node2 = tour[(i + 1) % n]
            heuristics_matrix[node1, node2] += 1
            heuristics_matrix[node2, node1] += 1

    # Incorporate shortest path information
    heuristics_matrix /= num_samples
    heuristics_matrix = 0.7 * heuristics_matrix + 0.3 * (1 / (shortest_paths + 1e-6))

    return heuristics_matrix
