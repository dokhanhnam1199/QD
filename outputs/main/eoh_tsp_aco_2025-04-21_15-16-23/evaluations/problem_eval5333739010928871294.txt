import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm combines aspects of ant colony optimization and tour improvement by iteratively constructing tours using a stochastic nearest neighbor approach, improving them with 3-opt swaps, and updating a pheromone matrix based on tour quality, which then serves as the heuristic matrix.}"""
    n = distance_matrix.shape[0]
    pheromone = np.ones((n, n))  # Initialize pheromone trails
    heuristics_matrix = np.zeros((n, n))
    alpha = 0.8  # Pheromone influence
    beta = 1.5   # Distance influence
    rho = 0.2  # Evaporation rate
    Q = 100    # Pheromone deposit constant
    num_ants = 40
    num_iterations = 40

    def calculate_tour_length(tour):
        length = 0
        for i in range(n):
            length += distance_matrix[tour[i], tour[(i + 1) % n]]
        return length

    def three_opt_swap(tour, i, j, k):
        """Do a 3-Opt swap."""
        a, b, c, d, e, f = tour[i:i + 1], tour[i + 1:j + 1], tour[j + 1:k + 1], tour[k + 1:i] ,[],[]
        new_tour = tour[:]
        if len(a)+len(b)+len(c)+len(d) == n:

            d = tour[k + 1:]
            a = tour[:i]
            b = tour[i:j+1]
            c = tour[j+1:k+1]


            options = [
                a + b + c + d,  # Keep original
                a + b + c[::-1] + d,  # Flip c
                a + b[::-1] + c + d,  # Flip b
                a + b[::-1] + c[::-1] + d,  # Flip b and c
                a + c + b + d,  # Swap b and c
                a + c + b[::-1] + d,  # Swap b and c, flip b
                a + c[::-1] + b + d,  # Swap b and c, flip c
                a + c[::-1] + b[::-1] + d,  # Swap b and c, flip b and c
            ]

            best_tour = tour[:]
            best_length = calculate_tour_length(best_tour)
            for t in options:
                length = calculate_tour_length(t)
                if length < best_length:
                    best_tour = t[:]
                    best_length = length
        return best_tour

    def three_opt(tour):
        best_tour = tour[:]
        best_length = calculate_tour_length(tour)
        improved = True
        while improved:
            improved = False
            for i in range(1, n - 2):
                for j in range(i + 1, n - 1):
                    for k in range(j + 1, n):
                        new_tour = three_opt_swap(best_tour, i, j, k)

                        new_length = calculate_tour_length(new_tour)
                        if new_length < best_length:
                            best_tour = new_tour[:]
                            best_length = new_length
                            improved = True
        return best_tour, best_length

    def stochastic_nearest_neighbor_tour(start_node):
        tour = [start_node]
        unvisited_nodes = set(range(n))
        unvisited_nodes.remove(start_node)
        current_node = start_node

        while unvisited_nodes:
            probabilities = np.array([1 / (distance_matrix[current_node, node] + 1e-6) for node in unvisited_nodes])
            probabilities /= np.sum(probabilities)
            next_node = np.random.choice(list(unvisited_nodes), p=probabilities)
            tour.append(next_node)
            unvisited_nodes.remove(next_node)
            current_node = next_node
        tour.append(start_node)
        tour = tour[:-1]
        return tour

    for iteration in range(num_iterations):
        all_paths = []
        all_path_lengths = []

        for ant in range(num_ants):
            # Generate a tour using stochastic nearest neighbor heuristic
            start_node = np.random.randint(0, n)
            initial_tour = stochastic_nearest_neighbor_tour(start_node)

            # Apply 3-opt to improve the tour
            best_tour, best_length = three_opt(initial_tour)

            all_paths.append(best_tour)
            all_path_lengths.append(best_length)

        # Find the best path in this iteration
        best_path_index = np.argmin(all_path_lengths)
        best_path = all_paths[best_path_index]
        best_path_length = all_path_lengths[best_path_index]

        # Update pheromones
        pheromone *= (1 - rho)  # Evaporation
        for i in range(n):
            pheromone[best_path[i], best_path[(i + 1) % n]] += Q / best_path_length
            pheromone[best_path[(i + 1) % n], best_path[i]] += Q / best_path_length

    # Construct heuristic matrix based on pheromone levels
    heuristics_matrix = pheromone
    return heuristics_matrix
