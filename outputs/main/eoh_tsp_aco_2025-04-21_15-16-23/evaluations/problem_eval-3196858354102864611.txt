import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm uses a genetic algorithm approach to evolve a population of tours and uses the edge frequencies in the best tours as heuristics.}"""
    n = distance_matrix.shape[0]
    population_size = 50
    num_generations = 50
    mutation_rate = 0.05

    def create_initial_population(size):
        population = []
        for _ in range(size):
            tour = np.random.permutation(n)
            population.append(tour)
        return population

    def calculate_fitness(tour):
        distance = 0
        for i in range(n - 1):
            distance += distance_matrix[tour[i], tour[i+1]]
        distance += distance_matrix[tour[-1], tour[0]]
        return 1 / (distance + 1e-9)  # Add a small value to avoid division by zero

    def selection(population, fitness_scores):
        probabilities = fitness_scores / np.sum(fitness_scores)
        indices = np.random.choice(len(population), size=2, replace=False, p=probabilities)
        return population[indices[0]], population[indices[1]]

    def crossover(parent1, parent2):
        start = np.random.randint(n)
        end = np.random.randint(start + 1, n + 1)
        child = np.zeros(n, dtype=int) - 1
        child[start:end] = parent1[start:end]
        
        remaining = [node for node in parent2 if node not in child]
        
        insert_index = 0
        for i in range(n):
            if child[i] == -1:
                child[i] = remaining[insert_index]
                insert_index += 1
                
        return child

    def mutate(tour):
        if np.random.rand() < mutation_rate:
            i, j = np.random.choice(n, 2, replace=False)
            tour[i], tour[j] = tour[j], tour[i]
        return tour

    population = create_initial_population(population_size)

    for _ in range(num_generations):
        fitness_scores = np.array([calculate_fitness(tour) for tour in population])
        new_population = []
        for _ in range(population_size):
            parent1, parent2 = selection(population, fitness_scores)
            child = crossover(parent1, parent2)
            child = mutate(child)
            new_population.append(child)
        population = new_population

    fitness_scores = np.array([calculate_fitness(tour) for tour in population])
    best_tours_indices = np.argsort(fitness_scores)[-population_size // 5:] # Top 20%
    best_tours = [population[i] for i in best_tours_indices]

    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

    for tour in best_tours:
        for i in range(n - 1):
            heuristics_matrix[tour[i], tour[i+1]] += 1
            heuristics_matrix[tour[i+1], tour[i]] += 1
        heuristics_matrix[tour[-1], tour[0]] += 1
        heuristics_matrix[tour[0], tour[-1]] += 1

    heuristics_matrix /= len(best_tours)

    return heuristics_matrix
