import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm uses a genetic algorithm approach, evolving a population of TSP solutions over multiple generations and using the frequency of edges in the best solutions to build a heuristic matrix.}"""
    num_nodes = distance_matrix.shape[0]
    population_size = 50
    num_generations = 100
    mutation_rate = 0.01
    
    # Initialize population with random tours
    population = []
    for _ in range(population_size):
        tour = np.random.permutation(num_nodes)
        population.append(tour)

    def calculate_fitness(tour):
        total_distance = 0
        for i in range(num_nodes):
            total_distance += distance_matrix[tour[i], tour[(i + 1) % num_nodes]]
        return 1 / total_distance  # Higher fitness for shorter tours

    def crossover(parent1, parent2):
        start = np.random.randint(num_nodes)
        length = np.random.randint(1, num_nodes // 2)
        child = np.zeros(num_nodes, dtype=int) - 1
        
        # Copy a segment from parent1
        for i in range(length):
            child[(start + i) % num_nodes] = parent1[(start + i) % num_nodes]
        
        # Fill in the rest from parent2
        current_index = 0
        for i in range(num_nodes):
            if parent2[i] not in child:
                while child[current_index] != -1:
                    current_index = (current_index + 1) % num_nodes
                child[current_index] = parent2[i]
        return child

    def mutate(tour):
        if np.random.rand() < mutation_rate:
            i, j = np.random.choice(num_nodes, 2, replace=False)
            tour[i], tour[j] = tour[j], tour[i]
        return tour

    # Evolve the population
    for _ in range(num_generations):
        # Calculate fitness for each tour
        fitness_scores = [calculate_fitness(tour) for tour in population]

        # Selection (roulette wheel selection)
        probabilities = np.array(fitness_scores) / np.sum(fitness_scores)
        selected_indices = np.random.choice(population_size, size=population_size, p=probabilities)
        selected_population = [population[i] for i in selected_indices]

        # Crossover and Mutation
        new_population = []
        for i in range(0, population_size, 2):
            parent1 = selected_population[i]
            parent2 = selected_population[(i + 1) % population_size]
            child1 = crossover(parent1, parent2)
            child2 = crossover(parent2, parent1)
            new_population.append(mutate(child1))
            new_population.append(mutate(child2))

        population = new_population

    # Select the best solutions and update the heuristic matrix
    fitness_scores = [calculate_fitness(tour) for tour in population]
    best_tours_indices = np.argsort(fitness_scores)[-population_size // 5:] #select top 20% tours
    best_tours = [population[i] for i in best_tours_indices]

    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    for tour in best_tours:
        for i in range(num_nodes):
            node1 = tour[i]
            node2 = tour[(i + 1) % num_nodes]
            heuristics_matrix[node1, node2] += 1
            heuristics_matrix[node2, node1] += 1

    heuristics_matrix /= len(best_tours)

    return heuristics_matrix
