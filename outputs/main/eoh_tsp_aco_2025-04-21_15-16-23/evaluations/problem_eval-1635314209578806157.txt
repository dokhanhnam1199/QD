import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm uses a combination of nearest neighbor and random sampling to generate multiple candidate tours, then averages the edge frequencies across these tours to produce a heuristic matrix.}"""
    n = len(distance_matrix)
    heuristics_matrix = np.zeros((n, n))
    num_samples = 100

    for _ in range(num_samples):
        start_node = np.random.randint(n)
        current_node = start_node
        unvisited = set(range(n))
        unvisited.remove(current_node)
        tour = [current_node]

        while unvisited:
            nearest_neighbor = None
            min_distance = np.inf

            # Nearest Neighbor Step
            for neighbor in unvisited:
                distance = distance_matrix[current_node][neighbor]
                if distance < min_distance:
                    min_distance = distance
                    nearest_neighbor = neighbor

            # Introduce randomness: Sometimes choose a random unvisited node
            if np.random.rand() < 0.2:  # 20% chance of random selection
                nearest_neighbor = np.random.choice(list(unvisited))

            tour.append(nearest_neighbor)
            unvisited.remove(nearest_neighbor)
            current_node = nearest_neighbor

        tour.append(start_node)

        # Update heuristic matrix based on the tour
        for i in range(n):
            node1 = tour[i]
            node2 = tour[i + 1]
            heuristics_matrix[node1][node2] += 1
            heuristics_matrix[node2][node1] += 1

    heuristics_matrix /= num_samples
    return heuristics_matrix
