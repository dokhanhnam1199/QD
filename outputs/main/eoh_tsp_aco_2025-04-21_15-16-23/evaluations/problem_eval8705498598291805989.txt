import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm constructs tours by iteratively adding the nearest unvisited node to the current tour, incorporating a stochastic element by sometimes selecting a slightly further node, and repeating this process to generate multiple tours for edge frequency analysis.}"""
    n = len(distance_matrix)
    heuristics_matrix = np.zeros((n, n))
    num_samples = 100
    stochasticity = 0.1

    for _ in range(num_samples):
        start_node = np.random.randint(n)
        tour = [start_node]
        unvisited = set(range(n))
        unvisited.remove(start_node)

        while unvisited:
            current_node = tour[-1]
            distances = {node: distance_matrix[current_node][node] for node in unvisited}
            
            # Introduce stochasticity: sort by distance and select with some randomness
            sorted_nodes = sorted(distances.items(), key=lambda item: item[1])
            
            # Apply a probability distribution skewed towards nearer nodes
            probabilities = np.exp(-stochasticity * np.array([item[1] for item in sorted_nodes]))
            probabilities /= np.sum(probabilities)

            chosen_node = np.random.choice([item[0] for item in sorted_nodes], p=probabilities)
            
            tour.append(chosen_node)
            unvisited.remove(chosen_node)

        tour.append(start_node)

        for i in range(n):
            node1 = tour[i]
            node2 = tour[i + 1]
            heuristics_matrix[node1][node2] += 1
            heuristics_matrix[node2][node1] += 1

    heuristics_matrix /= num_samples
    return heuristics_matrix
