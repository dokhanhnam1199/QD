import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm initializes a heuristic matrix based on the inverse of the distance matrix, then iteratively samples solutions using a roulette wheel selection biased by the current heuristic values, updating the heuristic matrix to favor edges frequently included in shorter sampled tours.}"""
    n = len(distance_matrix)
    heuristics_matrix = 1 / (distance_matrix + np.eye(n))
    heuristics_matrix = heuristics_matrix / np.sum(heuristics_matrix)

    num_samples = 1000
    for _ in range(num_samples):
        current_node = np.random.randint(n)
        tour = [current_node]
        unvisited = set(range(n))
        unvisited.remove(current_node)
        tour_length = 0

        while unvisited:
            probabilities = heuristics_matrix[current_node, list(unvisited)]
            probabilities /= np.sum(probabilities)
            next_node = np.random.choice(list(unvisited), p=probabilities)
            
            tour_length += distance_matrix[current_node, next_node]
            tour.append(next_node)
            unvisited.remove(next_node)
            current_node = next_node
        
        tour_length += distance_matrix[tour[-1], tour[0]]

        for i in range(n):
            j = (i + 1) % n
            node1 = tour[i]
            node2 = tour[j]
            heuristics_matrix[node1, node2] += 1 / tour_length
            heuristics_matrix[node2, node1] += 1 / tour_length

    return heuristics_matrix
