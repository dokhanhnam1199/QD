import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm combines stochastic sampling of nearest neighbor tours with adaptive weighting of edge frequencies to construct a heuristic matrix favoring edges frequently appearing in short tours.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros((n, n))
    num_samples = 100
    nearest_neighbors = 5

    for _ in range(num_samples):
        start_node = np.random.randint(n)
        current_node = start_node
        unvisited = set(range(n))
        unvisited.remove(current_node)
        tour = [current_node]
        tour_length = 0

        while unvisited:
            # Find nearest neighbors
            distances = distance_matrix[current_node, :]
            neighbor_indices = np.argsort(distances)[1:nearest_neighbors + 1]  # Exclude self

            # Filter to only include unvisited neighbors
            valid_neighbors = [neighbor for neighbor in neighbor_indices if neighbor in unvisited]
            
            if not valid_neighbors:
                # If no valid neighbors, choose a random unvisited node
                if unvisited:
                    next_node = np.random.choice(list(unvisited))
                else:
                    break # Tour complete
            else:
                # Choose a random nearest neighbor
                next_node = np.random.choice(valid_neighbors)

            tour_length += distance_matrix[current_node, next_node]
            tour.append(next_node)
            unvisited.remove(next_node)
            current_node = next_node

        tour_length += distance_matrix[tour[-1], start_node]  # Return to start
        tour.append(start_node)
        
        # Update heuristic matrix based on tour length
        for i in range(n):
            heuristics_matrix[tour[i], tour[(i + 1) % n]] += 1 / (tour_length + 1e-6)
            heuristics_matrix[tour[(i + 1) % n], tour[i]] += 1 / (tour_length + 1e-6)

    return heuristics_matrix
