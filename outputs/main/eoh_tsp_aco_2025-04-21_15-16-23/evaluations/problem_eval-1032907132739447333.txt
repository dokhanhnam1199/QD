import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm constructs a heuristic matrix by simulating a simplified neural network that learns edge importances based on path lengths from random walks.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros((n, n))
    learning_rate = 0.1
    num_walks = 500
    walk_length = n // 2

    for _ in range(num_walks):
        start_node = np.random.randint(n)
        current_node = start_node
        path = [current_node]
        
        for _ in range(walk_length):
            probabilities = 1 / (distance_matrix[current_node, :] + 1e-6)
            
            # Mask visited nodes
            for visited_node in path:
                probabilities[visited_node] = 0
            
            probabilities = probabilities / np.sum(probabilities) if np.sum(probabilities) > 0 else np.ones(n) / n
            
            next_node = np.random.choice(n, p=probabilities)
            path.append(next_node)
            current_node = next_node

        path_length = 0
        for i in range(len(path) - 1):
            path_length += distance_matrix[path[i], path[i+1]]

        for i in range(len(path) - 1):
            node1 = path[i]
            node2 = path[i+1]
            heuristics_matrix[node1, node2] += learning_rate / (path_length + 1e-6)
            heuristics_matrix[node2, node1] += learning_rate / (path_length + 1e-6)

    return heuristics_matrix
