import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm constructs a heuristic matrix by iteratively refining edge weights based on a combination of shortest path lengths and edge frequency within randomly sampled solutions.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.ones((n, n))
    num_iterations = 100
    num_samples = 50
    shortest_path_coeff = 0.5
    frequency_coeff = 0.5

    for _ in range(num_iterations):
        sampled_paths = []
        for _ in range(num_samples):
            start_node = np.random.randint(n)
            unvisited = set(range(n))
            unvisited.remove(start_node)
            path = [start_node]

            while unvisited:
                current_node = path[-1]
                distances = distance_matrix[current_node, :]
                
                # Only consider unvisited nodes
                valid_indices = list(unvisited)
                valid_distances = distances[valid_indices]
                
                next_node = valid_indices[np.argmin(valid_distances)]
                
                path.append(next_node)
                unvisited.remove(next_node)

            path.append(start_node)
            sampled_paths.append(path)

        # Update heuristics based on shortest path lengths
        for i in range(n):
            for j in range(n):
                shortest_path_length = float('inf')
                for path in sampled_paths:
                    path_length = 0
                    for k in range(n):
                        if (path[k] == i and path[(k + 1) % (n+1)] == j) or (path[k] == j and path[(k + 1) % (n+1)] == i):
                            path_length = distance_matrix[i,j]
                            break
                    if path_length > 0:
                        shortest_path_length = min(shortest_path_length, path_length)

                if shortest_path_length != float('inf'):
                    heuristics_matrix[i, j] += shortest_path_coeff / (shortest_path_length + 1e-6)

        # Update heuristics based on edge frequency
        edge_frequency = np.zeros((n, n))
        for path in sampled_paths:
            for k in range(n):
                i = path[k]
                j = path[(k + 1) % (n+1)]
                edge_frequency[i, j] += 1
                edge_frequency[j, i] += 1

        heuristics_matrix += frequency_coeff * edge_frequency

    return heuristics_matrix
