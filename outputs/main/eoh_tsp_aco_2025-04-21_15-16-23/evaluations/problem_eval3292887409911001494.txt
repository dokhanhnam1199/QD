import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm samples tours via biased random walks, favoring edges with shorter distances and accumulating edge appearance frequencies into a heuristic matrix.}"""
    n = len(distance_matrix)
    heuristics_matrix = np.zeros((n, n))
    num_samples = 100

    for _ in range(num_samples):
        start_node = np.random.randint(n)
        current_node = start_node
        unvisited = set(range(n))
        unvisited.remove(current_node)
        tour = [current_node]

        while unvisited:
            probabilities = []
            neighbors = list(unvisited)
            total_distance = 0
            for neighbor in neighbors:
                distance = distance_matrix[current_node][neighbor]
                total_distance += 1/distance if distance > 0 else 0

            for neighbor in neighbors:
                distance = distance_matrix[current_node][neighbor]
                probabilities.append((1/distance) / total_distance if distance > 0 and total_distance>0 else 1/len(unvisited))

            next_node = np.random.choice(neighbors, p=probabilities)
            tour.append(next_node)
            unvisited.remove(next_node)
            current_node = next_node

        tour.append(start_node)

        # Update heuristic matrix based on the tour
        for i in range(n):
            node1 = tour[i]
            node2 = tour[i + 1]
            heuristics_matrix[node1][node2] += 1
            heuristics_matrix[node2][node1] += 1

    heuristics_matrix /= num_samples
    return heuristics_matrix
