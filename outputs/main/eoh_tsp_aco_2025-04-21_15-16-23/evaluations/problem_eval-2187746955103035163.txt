import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm uses a spanning tree approach, iteratively adding shortest edges to a forest while avoiding cycles and ensuring all nodes are connected, then biases the heuristic matrix towards edges in the resulting minimum spanning tree.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    edges = []
    for i in range(n):
        for j in range(i + 1, n):
            edges.append((i, j, distance_matrix[i, j]))
    edges.sort(key=lambda x: x[2])

    parent = list(range(n))

    def find(i):
        if parent[i] == i:
            return i
        parent[i] = find(parent[i])
        return parent[i]

    def union(i, j):
        root_i = find(i)
        root_j = find(j)
        if root_i != root_j:
            parent[root_i] = root_j
            return True
        return False

    mst_weight = 0
    mst_edges = []
    for i, j, weight in edges:
        if union(i, j):
            mst_weight += weight
            mst_edges.append((i, j))

    for i, j in mst_edges:
        heuristics_matrix[i, j] = 1.0
        heuristics_matrix[j, i] = 1.0

    return heuristics_matrix
