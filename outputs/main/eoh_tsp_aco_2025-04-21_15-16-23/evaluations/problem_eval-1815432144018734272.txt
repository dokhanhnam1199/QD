import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm constructs a heuristic matrix by simulating a simplified version of ant colony optimization, where a single ant iteratively builds solutions biased by distance, and the heuristic matrix is updated based on the best solution found.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros((n, n))
    num_iterations = 100
    best_path = None
    best_path_length = float('inf')

    for iteration in range(num_iterations):
        start_node = np.random.randint(n)
        current_node = start_node
        unvisited = set(range(n))
        unvisited.remove(current_node)
        path = [current_node]

        while unvisited:
            distances = distance_matrix[current_node, :]
            
            # Mask visited nodes
            for visited_node in path:
                distances[visited_node] = float('inf')
            
            next_node = np.argmin(distances)
            path.append(next_node)
            unvisited.remove(next_node)
            current_node = next_node

        path.append(start_node)
        path_length = 0
        for i in range(n):
            path_length += distance_matrix[path[i], path[(i + 1) % n]]

        if path_length < best_path_length:
            best_path_length = path_length
            best_path = path

    # Update heuristic matrix based on the best path
    for i in range(n):
        heuristics_matrix[best_path[i], best_path[(i + 1) % n]] = 1 / (distance_matrix[best_path[i], best_path[(i + 1) % n]]+1e-6)
        heuristics_matrix[best_path[(i + 1) % n], best_path[i]] = 1 / (distance_matrix[best_path[i], best_path[(i + 1) % n]]+1e-6)
    return heuristics_matrix
