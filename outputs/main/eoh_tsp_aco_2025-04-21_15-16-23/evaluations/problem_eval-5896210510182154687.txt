import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm uses a Monte Carlo approach to estimate edge probabilities by simulating random walks and weighting edges based on the inverse of the total walk length.}"""
    n = len(distance_matrix)
    heuristics_matrix = np.zeros((n, n))
    num_walks = 100
    walk_length = n

    for _ in range(num_walks):
        start_node = np.random.randint(n)
        current_node = start_node
        visited = {start_node}
        total_distance = 0.0

        for _ in range(walk_length):
            probabilities = np.zeros(n)
            for neighbor in range(n):
                if neighbor != current_node and neighbor not in visited:
                    probabilities[neighbor] = 1.0 / distance_matrix[current_node][neighbor] if distance_matrix[current_node][neighbor] > 0 else 0.0
            
            if np.sum(probabilities) == 0:
                next_node = np.random.choice([i for i in range(n) if i != current_node and i not in visited]) if len([i for i in range(n) if i != current_node and i not in visited])>0 else -1
                if next_node == -1:
                   break
                else:
                    distance = distance_matrix[current_node][next_node]
            else:    
                probabilities /= np.sum(probabilities)
                next_node = np.random.choice(n, p=probabilities)
                distance = distance_matrix[current_node][next_node]
            
            heuristics_matrix[current_node][next_node] += 1.0 / (total_distance + distance + 1e-6)
            heuristics_matrix[next_node][current_node] += 1.0 / (total_distance + distance + 1e-6)

            total_distance += distance
            current_node = next_node
            visited.add(current_node)

    return heuristics_matrix
