```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristic function for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.

    This version combines distance, demand, and angle considerations to prioritize edges.
    It also sparsifies the matrix by setting unpromising elements to zero.

    Args:
        distance_matrix (np.ndarray): Distance matrix (shape: n by n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n by 2).
        demands (np.ndarray): Vector of customer demands (shape: n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n by n).
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix)

    # Parameters (tunable)
    alpha = 1.0   # Weight for distance
    beta = 0.5    # Weight for demand
    gamma = 0.2   # Weight for angle
    sparsity_threshold = 3.0 # Controls sparsification

    for i in range(n):
        for j in range(n):
            if i != j:
                # Distance factor: Shorter distances are more promising
                distance_factor = 1 / distance_matrix[i, j]

                # Demand factor: Edges connecting to nodes with higher demand are less promising if they lead to capacity issues.
                demand_factor = 1.0
                if i != 0 and j != 0:  #Exclude Depot for now
                  demand_factor = 1 / (demands[i] + demands[j] + 1e-6) #Avoid division by zero


                # Angle factor: Penalize sharp turns.  Calculates angle between i->j and depot->j
                if i != 0: #Only Calculate for nodes that are not depot
                  depot_x, depot_y = coordinates[0]
                  node_i_x, node_i_y = coordinates[i]
                  node_j_x, node_j_y = coordinates[j]

                  vector_ij = np.array([node_j_x - node_i_x, node_j_y - node_i_y])
                  vector_0j = np.array([node_j_x - depot_x, node_j_y - depot_y])

                  # Normalize the vectors
                  norm_ij = np.linalg.norm(vector_ij)
                  norm_0j = np.linalg.norm(vector_0j)

                  if norm_ij > 0 and norm_0j > 0:
                      vector_ij = vector_ij / norm_ij
                      vector_0j = vector_0j / norm_0j

                      #Calculate cosine similarity
                      angle_factor = np.dot(vector_ij, vector_0j) #The bigger the value (max 1.0), the smaller the angle. Close to -1 is big angle

                      # Scale the angle factor to make sense. The smaller the angle is better

                      angle_factor = (angle_factor + 1) / 2  #Value is in [0,1] with 1 being no angle (0 degress) and zero is 180 degress
                  else:
                      angle_factor = 0.5 # Neutral value if vectors cannot be normalized
                else: #No Angle is applied to the depot node for node I. Otherwise solutions starting at a depot and using small distances edges near each other might be penailized
                    angle_factor = 1.0

                # Combine the factors
                heuristic_value = (alpha * distance_factor +
                                   beta * demand_factor +
                                   gamma * angle_factor)


                heuristic_matrix[i, j] = heuristic_value

    # Sparsify the matrix:  Set unpromising edges to zero
    mean_heuristic = np.mean(heuristic_matrix[heuristic_matrix > 0])  # Only consider non-zero values
    heuristic_matrix[heuristic_matrix < mean_heuristic / sparsity_threshold] = 0


    return heuristic_matrix
```
