```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.

    This version combines distance, demand, and angle information to create a more informed heuristic.
    It also sparsifies the matrix by setting unpromising edges to zero.

    Args:
        distance_matrix (np.ndarray): Distance matrix between nodes (n x n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (n x 2).
        demands (np.ndarray): Vector of customer demands (n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (n x n).
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Parameters (can be tuned)
    distance_weight = 1.0
    demand_weight = 0.5
    angle_weight = 0.2
    sparsity_threshold = 0.8  # Only keep top (1 - threshold) edges for each node.

    for i in range(n):
        for j in range(n):
            if i != j:
                # Distance factor: Shorter distances are more promising
                distance_factor = 1 / (distance_matrix[i, j] + 1e-6) #Adding a small number to avoid division by zero

                # Demand factor: Penalize edges that connect to nodes with high demand if it's not the depot
                demand_factor = 1.0
                if i != 0 and j != 0: #do not penalize depot
                    demand_factor = 1 / (demands[i] + demands[j] + 1e-6)


                # Angle factor: Encourages edges that form smoother routes, based on the idea that direct paths are better.

                angle_factor = 1.0
                if i != 0 and j != 0:

                    #Calculate angles.
                    vector_i = coordinates[i] - coordinates[0]
                    vector_j = coordinates[j] - coordinates[0]

                    #Angle between the vector between depot and customer i, and depot and customer j.
                    dot_product = np.dot(vector_i, vector_j)
                    magn_i = np.linalg.norm(vector_i)
                    magn_j = np.linalg.norm(vector_j)

                    if (magn_i > 0 and magn_j > 0): #Avoid division by zero
                        cosine_angle = dot_product / (magn_i * magn_j)
                        angle = np.arccos(np.clip(cosine_angle, -1.0, 1.0)) #Clip due to potential precision issues

                        angle_factor = 1 / (angle + 1e-6) #Small angle is better

                heuristic_matrix[i, j] = (
                    distance_weight * distance_factor
                    + demand_weight * demand_factor
                    + angle_weight * angle_factor
                )

    # Sparsify the matrix: Keep only the most promising edges
    for i in range(n):
        row = heuristic_matrix[i, :]
        threshold = np.quantile(row, sparsity_threshold)
        heuristic_matrix[i, row < threshold] = 0

    return heuristic_matrix
```
