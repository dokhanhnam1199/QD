```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristic function for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.

    Args:
        distance_matrix (np.ndarray): Distance matrix (shape: n by n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n by 2).
        demands (np.ndarray): Vector of customer demands (shape: n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n by n).
    """
    n = distance_matrix.shape[0]

    # Initialize the heuristic matrix
    heuristic_matrix = np.zeros((n, n))

    # Parameters
    alpha = 1.0  # Weight for distance
    beta = 1.0   # Weight for demand consideration
    gamma = 0.5  # Weight for closeness to depot
    delta = 0.5 #Weight for node connectivity

    # Calculate closeness to depot
    depot_distances = distance_matrix[0, :]
    max_depot_distance = np.max(depot_distances)
    normalized_depot_distances = 1 - (depot_distances / max_depot_distance)

    # Demand consideration - prioritize edges connecting nodes with smaller combined demand
    max_demand = np.max(demands)
    normalized_demands = demands / max_demand

    # Node Connectivity (prefer to link to nodes with lower "degree" or connections)
    node_connectivity = np.zeros(n)

    for i in range(n):
        for j in range(n):
             if i!= j:
                node_connectivity[i] += 1/distance_matrix[i,j] if distance_matrix[i,j] > 0 else 0
    max_connectivity = np.max(node_connectivity)
    normalized_connectivity = node_connectivity / max_connectivity

    # Populate the heuristic matrix
    for i in range(n):
        for j in range(n):
            if i != j:
                # Edge desirability based on distance, demand, and closeness to depot.

                demand_factor = 1 / (normalized_demands[i] + normalized_demands[j] + 0.0001) # Add small value to prevent divide by zero

                connectivity_factor = 1 / (normalized_connectivity[i] + normalized_connectivity[j] + 0.0001)
                heuristic_matrix[i, j] = (
                    (1 / (distance_matrix[i, j] + 0.0001))**alpha *
                    (demand_factor)**beta *
                    (normalized_depot_distances[i] + normalized_depot_distances[j])**gamma*
                    (connectivity_factor) ** delta
                )


    # Sparsify the matrix: Remove edges that are too long or connect high demand nodes directly, except for depot
    distance_threshold = np.mean(distance_matrix) + np.std(distance_matrix) # Dynamic threshold
    demand_threshold = 0.8
    for i in range(1, n):
        for j in range(1, n):
            if i != j:
                if distance_matrix[i, j] > distance_threshold:
                    heuristic_matrix[i, j] = 0
                if normalized_demands[i] > demand_threshold and normalized_demands[j] > demand_threshold:
                    heuristic_matrix[i, j] = 0

    # Ensure that the depot is connected
    for i in range(1, n):
        if heuristic_matrix[0, i] == 0:
            heuristic_matrix[0, i] = (1 / (distance_matrix[0, i] + 0.0001))**alpha * (normalized_depot_distances[i])**gamma #Consider only distance and closeness to depot
        if heuristic_matrix[i, 0] == 0:
             heuristic_matrix[i, 0] = (1 / (distance_matrix[i, 0] + 0.0001))**alpha * (normalized_depot_distances[i])**gamma #Consider only distance and closeness to depot

    return heuristic_matrix
```
