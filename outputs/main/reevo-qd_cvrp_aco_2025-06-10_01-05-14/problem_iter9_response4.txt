```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    A heuristics function for Solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.
    This version improves upon v1 by incorporating more adaptive parameter adjustments and refining the edge penalization strategy.
    Args:
        distance_matrix (np.ndarray): Distance matrix (shape: n by n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n by 2).
        demands (np.ndarray): Customer demands (shape: n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (same shape as distance_matrix).
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Calculate savings for each pair of nodes (Clarke-Wright Savings Heuristic)
    savings_matrix = np.zeros((n, n))
    for i in range(1, n):
        for j in range(i + 1, n):
            savings_matrix[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]
            savings_matrix[j, i] = savings_matrix[i, j]

    # Combine distance, savings, and demand considerations
    for i in range(n):
        for j in range(n):
            if i == j:
                heuristic_matrix[i, j] = 0  # No self-loops
            else:
                # Distance factor (shorter distances are preferred)
                distance_factor = 1 / (distance_matrix[i, j] + 1e-6)  # Adding a small constant to avoid division by zero

                # Savings factor (higher savings are preferred)
                savings_factor = savings_matrix[i, j]

                # Demand factor (prioritize connections that help balance vehicle load).
                demand_factor = 1.0
                if (i != 0 and j != 0) and (demands[i] + demands[j] > capacity):
                    demand_factor = 0.0  # prevent node combination if capacity is exceeded

                heuristic_matrix[i, j] = distance_factor * savings_factor * demand_factor

    # Adaptive sparsification
    k = int(1.5 * np.log(n))  # Adjusted logarithmic scaling factor
    k = max(1, min(k, n - 1))  # Ensure k is within valid bounds

    for i in range(n):
        top_k_indices = np.argsort(heuristic_matrix[i, :])[::-1][:k]
        for j in range(n):
            if j not in top_k_indices:
                heuristic_matrix[i, j] = 0

    # Learned Component with dynamic scaling based on overall demand
    demand_boost = np.zeros((n, n))
    total_demand = np.sum(demands[1:])
    
    # Introduce a demand threshold for edges eligible for demand boost
    demand_threshold_percentage = 0.05 # Only edges connecting significant demand nodes are boosted
    demand_threshold = demand_threshold_percentage * total_demand
    
    for i in range(1, n):
        for j in range(1, n):
            if demands[i] > demand_threshold or demands[j] > demand_threshold:
                demand_component = (demands[i] / total_demand + demands[j] / total_demand)
                depot_proximity = (1 / (distance_matrix[i, 0] + 1e-6) + 1 / (distance_matrix[j, 0] + 1e-6)) if (i!=j) else 0

                demand_boost[i, j] = demand_component + 0.1 * depot_proximity

    # Dynamically adjust demand boost scale based on problem characteristics
    demand_boost_scale = 0.05 * (total_demand / (n * capacity)) #scale based on the total demand and vehicle capacity
    heuristic_matrix = heuristic_matrix + demand_boost_scale * demand_boost

    # Improved Capacity-Aware Edge Penalization with route demand prediction
    for i in range(1, n):
        for j in range(1, n):
            if i != j:
                combined_demand = demands[i] + demands[j]
                
                #Estimate route demand if the edge is added. Assume average demand increase is half the combined demand
                estimated_route_demand_increase = 0.5 * combined_demand
                
                if combined_demand > capacity:
                    penalty_factor = (combined_demand - capacity) / capacity
                    heuristic_matrix[i, j] *= (1 - 0.3 * penalty_factor)  # Increased penalty strength
                    heuristic_matrix[j, i] *= (1 - 0.3 * penalty_factor)
                elif estimated_route_demand_increase > 0.75 * capacity : # Penalize edges prone to quickly fill capacity
                    heuristic_matrix[i, j] *= 0.8 # mild penalization
                    heuristic_matrix[j, i] *= 0.8

    return heuristic_matrix
```
