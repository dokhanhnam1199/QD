```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    A heuristics function for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.

    This version combines distance, demand, and angular considerations to generate edge priorities.

    Args:
        distance_matrix (np.ndarray): Distance matrix (shape: n by n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n by 2).
        demands (np.ndarray): Customer demands (shape: n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n by n).
    """

    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros((n, n))

    # Parameters (can be tuned)
    alpha = 1.0   # Weight for distance
    beta = 0.5    # Weight for demand-related factor
    gamma = 0.5   # Weight for angle-related factor
    sparsity_threshold = 0.1 # Threshold for sparsifying the matrix

    depot_index = 0

    for i in range(n):
        for j in range(n):
            if i != j:
                distance_factor = distance_matrix[i, j]
                demand_factor = (demands[i] + demands[j]) / capacity  # Fraction of capacity used
                
                # Angle consideration: Penalize edges that make sharp turns away from depot
                # Calculate angle between vector from i to depot and vector from i to j. Smaller angle is better
                vector_i_depot = coordinates[depot_index] - coordinates[i]
                vector_i_j = coordinates[j] - coordinates[i]

                # Normalize vectors to handle zero vector edge cases:
                norm_i_depot = np.linalg.norm(vector_i_depot)
                norm_i_j = np.linalg.norm(vector_i_j)
                if norm_i_depot == 0 or norm_i_j == 0:
                    angle_factor = 1.0 #default if one of them is zero
                else:
                    vector_i_depot_norm = vector_i_depot / norm_i_depot
                    vector_i_j_norm = vector_i_j / norm_i_j
                    cos_angle = np.dot(vector_i_depot_norm, vector_i_j_norm)
                    cos_angle = np.clip(cos_angle, -1, 1)
                    angle = np.arccos(cos_angle) #Angle in radians (0 to pi)

                    angle_factor = angle / np.pi #Rescale angle to (0 to 1)
                    

                # Combine factors
                heuristics_matrix[i, j] = (
                    (alpha / distance_factor) +
                    (beta / (1 + demand_factor)) + #Invert to favour smaller demands
                    (gamma / (1 + angle_factor))  # Penalize edges forming angles away from depot
                    )

    # Normalize heuristics matrix
    max_heuristic = np.max(heuristics_matrix)
    if max_heuristic > 0: #Avoid div by zero
         heuristics_matrix = heuristics_matrix / max_heuristic

    #Sparsify matrix: Set low-priority edges to zero to promote exploration of promising routes
    threshold = sparsity_threshold * np.max(heuristics_matrix)  # Threshold for sparsification

    for i in range(n):
        for j in range(n):
             if heuristics_matrix[i,j] < threshold:
                 heuristics_matrix[i,j] = 0.0
    return heuristics_matrix
```
