```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics function for CVRP using stochastic solution sampling principles.

    This version incorporates several factors to assess the promise of each edge:
    - Distance: Shorter distances are generally preferred.
    - Demand: Considers the demands of the nodes connected by the edge.  Edges connecting nodes with larger demands might be less desirable
              initially (but not always!), since using this node could quickly fill up the capacity, making other nodes unreachable.
              Conversely, very small demands are slightly penalized to encourage route diversification.
    - Angle: Encourages connections that result in smaller turning angles, promoting more direct routes.
    - Sparsity: Zeros out edges deemed very unpromising based on a combined metric, to guide search.

    Args:
        distance_matrix (np.ndarray): Distance matrix between nodes (n x n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (n x 2).
        demands (np.ndarray): Customer demands (n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: A matrix (n x n) indicating the promise of each edge.  Higher values are more promising.
    """
    n = distance_matrix.shape[0]
    promise = np.zeros_like(distance_matrix)

    # Parameters (can be tuned)
    distance_weight = 1.0
    demand_weight = 0.5
    angle_weight = 0.5
    sparsity_threshold = 0.1 #tune

    for i in range(n):
        for j in range(n):
            if i == j:
                promise[i, j] = 0  # No self-loops
                continue

            # Distance factor (inverse of distance)
            dist_factor = distance_weight / (distance_matrix[i, j] + 1e-6)  # Adding small value to avoid division by zero.

            # Demand factor: Penalize if demand exceeds capacity or demand is very low
            demand_factor = 1.0 / (1 + np.abs(demands[i] + demands[j] - capacity / 2)) #penalty for nearing to total capacity with 2 demands
            if (demands[i] + demands[j] > capacity):
                demand_factor = 0.01
            demand_factor = demand_weight * demand_factor

            # Angle factor: Calculate angle between edges (i->j) and (j->k) for all other nodes k.
            # Aim is to promote edges that result in smaller turning angles
            angle_sum = 0.0
            for k in range(n):
                if k != i and k != j:
                    v1 = coordinates[j] - coordinates[i]
                    v2 = coordinates[k] - coordinates[j]
                    dot_product = np.dot(v1, v2)
                    magnitudes = np.linalg.norm(v1) * np.linalg.norm(v2)
                    if magnitudes > 0:  #Avoid dividing by zero
                        angle = np.arccos(np.clip(dot_product / magnitudes, -1.0, 1.0)) #Clip to avoid domain error
                        angle_sum += angle
            angle_factor = angle_weight / (angle_sum + 1e-6)


            promise[i, j] = dist_factor + demand_factor + angle_factor

    #Sparsify based on the values in 'promise'.
    max_promise = np.max(promise)
    if max_promise > 0: #ensure valid calculations
        normalized_promise = promise / max_promise
        promise[normalized_promise < sparsity_threshold] = 0

    return promise
```
