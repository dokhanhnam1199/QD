```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristic function for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.

    Args:
        distance_matrix: Distance matrix between nodes (shape: n x n).
        coordinates: Euclidean coordinates of nodes (shape: n x 2).
        demands: Demand of each node (shape: n).
        capacity: Vehicle capacity.

    Returns:
        A matrix of the same shape as distance_matrix, indicating the probability of each edge.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Calculate a combined heuristic score for each edge
    for i in range(n):
        for j in range(n):
            if i == j:
                heuristic_matrix[i, j] = 0  # Disallow self-loops
                continue

            # Factor 1: Distance-based desirability (Shorter distances are better)
            distance_factor = 1 / (distance_matrix[i, j] + 1e-6)  # Add a small constant to avoid division by zero

            # Factor 2: Demand-based desirability (Encourage connecting nodes with lower demands)
            # Avoid routes with nodes that have demands exceeding capacity.
            demand_factor_i = 1 / (demands[i] + 1e-6)
            demand_factor_j = 1 / (demands[j] + 1e-6)

            # Factor 3: Angle based scoring. Closer to the depot better
            depot_idx = 0
            angle_i = np.arctan2(coordinates[i, 1] - coordinates[depot_idx, 1], coordinates[i, 0] - coordinates[depot_idx, 0])
            angle_j = np.arctan2(coordinates[j, 1] - coordinates[depot_idx, 1], coordinates[j, 0] - coordinates[depot_idx, 0])

            angle_diff = np.abs(angle_i - angle_j)
            angle_factor = 1 / (angle_diff + 1e-6)  # Small angle differences better


            heuristic_matrix[i, j] = distance_factor * (demand_factor_i + demand_factor_j) * angle_factor


    # Sparsify the matrix: Only keep the most promising edges for each node. Remove the unpromising ones.
    sparsity_threshold = 0.2  # Keep only the top 20% of edges. Adjust as needed.
    for i in range(n):
        row = heuristic_matrix[i, :]
        threshold = np.quantile(row, 1 - sparsity_threshold)  # Calculate threshold for sparsity

        heuristic_matrix[i, row < threshold] = 0 # Set values below threshold to zero, thus sparsifying
        heuristic_matrix[i, i] = 0  # Set diagonal to zero to avoid self loops.


    return heuristic_matrix
```
