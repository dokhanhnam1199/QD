```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.

    This function combines several factors to determine how promising it is to select an edge,
    including distance, demand, angle between nodes, and a sparsification strategy.

    Args:
        distance_matrix (np.ndarray): Distance matrix (shape: n by n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n by 2).
        demands (np.ndarray): Vector of customer demands (shape: n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution
                    (same shape as distance_matrix).
    """

    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

    # Calculate angle between nodes relative to the depot (node 0)
    depot_x, depot_y = coordinates[0]
    angles = np.zeros(n)
    for i in range(1, n):
        angle = np.arctan2(coordinates[i, 1] - depot_y, coordinates[i, 0] - depot_x)
        angles[i] = angle

    for i in range(n):
        for j in range(n):
            if i == j:
                heuristics_matrix[i, j] = 0  # No self-loops
                continue

            # Distance factor: shorter distance is better
            distance_factor = 1 / (distance_matrix[i, j] + 1e-6)  # Adding a small constant to avoid division by zero

            # Demand factor: prioritize edges connecting to nodes with smaller demand (or depot)
            demand_factor = 1 / (demands[i] + demands[j] + 1e-6) if i != 0 and j != 0 else 1.0 # Favor connecting to depot
            if i ==0 or j ==0:
                 demand_factor = 1.0

            # Angle factor: penalize sharp turns (encourage smoother routes)
            angle_diff = abs(angles[i] - angles[j])
            angle_factor = 1 / (abs(angle_diff) + 0.1) if i > 0 and j > 0 else 1.0 # less significant near the depot
            #if angle_diff > np.pi / 2.0 and (i != 0 and j != 0):
            #     angle_factor = 0.01

            # Combine factors
            heuristics_matrix[i, j] = distance_factor * demand_factor * angle_factor

    # Sparsification: Keep only the top k promising edges for each node
    k = int(np.sqrt(n))  # Adjust k as needed

    for i in range(n):
        row = heuristics_matrix[i, :]
        indices = np.argsort(row)[-k:]  # Indices of top k values
        mask = np.ones(n, dtype=bool)
        mask[indices] = False
        heuristics_matrix[i, mask] = 0  # Set less promising edges to zero

    return heuristics_matrix
```
