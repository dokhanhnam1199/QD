```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.

    This version incorporates multiple factors to determine the attractiveness of each edge
    and sparsifies the resulting matrix by setting unpromising elements to zero.

    Args:
        distance_matrix (np.ndarray): Distance matrix (shape: n by n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n by 2).
        demands (np.ndarray): Vector of customer demands (shape: n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n by n).
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # Parameters (can be tuned)
    alpha = 1.0   # Distance factor
    beta = 0.5    # Demand factor
    gamma = 0.2   # Angle factor (relative to depot)
    delta = 0.1  # Capacity consideration factor

    # Calculate angles relative to the depot (node 0)
    depot_x, depot_y = coordinates[0]
    angles = np.zeros((n, n))
    for i in range(1, n):
        x1, y1 = coordinates[i]
        angle1 = np.arctan2(y1 - depot_y, x1 - depot_x)
        for j in range(i + 1, n):
            x2, y2 = coordinates[j]
            angle2 = np.arctan2(y2 - depot_y, x2 - depot_x)
            angle_diff = np.abs(angle1 - angle2)
            angles[i, j] = min(angle_diff, 2 * np.pi - angle_diff)  # Smaller angle
            angles[j, i] = angles[i, j]

    # Populate the heuristic matrix
    for i in range(n):
        for j in range(n):
            if i != j:
                # Distance factor: favor shorter distances
                distance_factor = 1 / distance_matrix[i, j]

                # Demand factor: discourage edges that quickly lead to exceeding capacity
                demand_factor = np.exp(-beta * (demands[i] + demands[j]) / capacity)

                # Angle factor:  Penalize large angle differences from the depot
                angle_factor = np.exp(-gamma * angles[i, j])

                # Combined heuristic value
                heuristic_value = (distance_factor**alpha) * demand_factor * angle_factor

                heuristic_matrix[i, j] = heuristic_value

    # Capacity consideration : Zero out if the demand would obviously be too large with depot.
    for i in range(1, n):
        if demands[i] > capacity:  # customer i's demand exceeds the vehicle capacity itself.
             heuristic_matrix[0, i] = 0.0
             heuristic_matrix[i, 0] = 0.0


    # Sparsify the matrix (optional: adjust threshold as needed)
    threshold = np.percentile(heuristic_matrix[heuristic_matrix > 0], 25)  # keep 75%
    heuristic_matrix[heuristic_matrix < threshold] = 0

    return heuristic_matrix
```
