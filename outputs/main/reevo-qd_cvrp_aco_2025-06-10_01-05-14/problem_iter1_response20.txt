```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristic function for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.

    This version combines distance, demand, and angle information to create a more informed heuristic.
    It also sparsifies the matrix by setting unpromising elements to zero.

    Args:
        distance_matrix (np.ndarray): Distance matrix (shape: n by n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n by 2).
        demands (np.ndarray): Customer demands (shape: n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n by n).
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Parameters to tune the influence of each factor
    distance_factor = 1.0
    demand_factor = 1.0
    angle_factor = 1.0

    for i in range(n):
        for j in range(n):
            if i != j:
                # Distance component: inversely proportional to distance
                distance_component = distance_factor / distance_matrix[i, j]

                # Demand component: inversely proportional to the sum of demands if either i or j is not depot
                if i == 0 or j == 0:
                    demand_component = 1.0  # Avoid division by zero and keep the possibility for depot connection
                else:
                    demand_component = demand_factor / (demands[i] + demands[j])

                # Angle component: penalize sharp turns (only if i is not depot)
                angle_component = 1.0
                if i != 0:  #Only use the angle if i is not the depot, else keep at 1.0

                    # Find a third point k to calculate the angle i-k-j or j-k-i that gives more "straightness"
                    best_angle_so_far = -10000  # initialize with a very small negative angle
                    best_k = -1
                    for k in range(n):
                        if (k != i and k != j):
                            # Compute angle at k, using i, j as other points on lines.
                            vec_ki = coordinates[i] - coordinates[k]
                            vec_kj = coordinates[j] - coordinates[k]

                            norm_ki = np.linalg.norm(vec_ki)
                            norm_kj = np.linalg.norm(vec_kj)

                            if (norm_ki > 0 and norm_kj > 0):  # Avoid division by zero.
                                cos_angle = np.dot(vec_ki, vec_kj) / (norm_ki * norm_kj)

                                if (cos_angle > best_angle_so_far):
                                    best_angle_so_far = cos_angle
                                    best_k = k
                    angle_component = angle_factor * (best_angle_so_far+1)/2 #Normalize from [-1 to 1] to [0 to 1] and reweight.




                # Combine the components
                heuristic_matrix[i, j] = distance_component * demand_component * angle_component

    # Sparsify the matrix: set elements to zero if they are below a certain threshold
    threshold = np.percentile(heuristic_matrix[heuristic_matrix > 0], 20)  # Keep top 80% percentile
    heuristic_matrix[heuristic_matrix < threshold] = 0

    return heuristic_matrix
```
