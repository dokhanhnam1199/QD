```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    A heuristic function for the Capacitated Vehicle Routing Problem (CVRP) that
    combines distance, demand, and angle to estimate the promise of including
    each edge in a solution. It sparsifies the matrix by setting unpromising
    elements to zero.

    Args:
        distance_matrix (np.ndarray): A matrix of pairwise distances between nodes.
        coordinates (np.ndarray): Euclidean coordinates of each node.
        demands (np.ndarray): Demand of each node.
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: A matrix of the same shape as distance_matrix, where each
                    element indicates the promise of including the corresponding
                    edge in a solution.
    """
    n = distance_matrix.shape[0]
    promise = np.zeros_like(distance_matrix)

    # Parameters (can be tuned)
    distance_weight = 1.0
    demand_weight = 0.5
    angle_weight = 0.5
    capacity_threshold = 0.8  # fraction of capacity

    for i in range(n):
        for j in range(n):
            if i == j:
                promise[i, j] = 0  # No self-loops
                continue

            # Distance factor (shorter distance is better)
            distance_factor = 1 / (distance_matrix[i, j] + 1e-6) # avoid division by zero

            # Demand factor (consider both nodes' demands)
            demand_factor = 1 - min(demands[i] + demands[j], capacity) / capacity #scaled to range from 0 to 1

            # Angle factor (penalize sharp turns)
            if i == 0:
              angle_factor = 1
            else:
              vector_ij = coordinates[j] - coordinates[i]
              vector_i0 = coordinates[0] - coordinates[i] # depot is node 0
              norm_ij = np.linalg.norm(vector_ij)
              norm_i0 = np.linalg.norm(vector_i0)

              if norm_ij == 0 or norm_i0 == 0:
                angle_factor = 1
              else:

                cos_angle = np.dot(vector_ij, vector_i0) / (norm_ij * norm_i0)
                angle_factor = (1 + cos_angle) / 2 #scale from 0 to 1 (acute angle is favorable)
            promise[i, j] = (distance_weight * distance_factor +
                                demand_weight * demand_factor +
                                angle_weight * angle_factor)

    # Sparsify the matrix: set unpromising edges to zero
    # Threshold based on the distribution of promise values
    threshold = np.mean(promise) + 0.5 * np.std(promise)
    promise[promise < threshold] = 0
    np.fill_diagonal(promise, 0) #set diagonal to zeros


    return promise
```
