```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristic function for solving the Capacitated Vehicle Routing Problem (CVRP)
    via stochastic solution sampling.

    This version incorporates several factors to estimate the desirability of including
    each edge in a solution and sparsifies the matrix.

    Args:
        distance_matrix (np.ndarray): Distance matrix between nodes (n x n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (n x 2).
        demands (np.ndarray): Vector of customer demands (n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution
                      (same shape as distance_matrix).  Sparse matrix: unpromising values set to zero
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix)

    # Parameters to tune: these could also be adaptive
    alpha = 1.0  # Weight for distance
    beta = 0.5   # Weight for demand proximity
    gamma = 0.2  # Weight for angle penalty
    sparsity_threshold = 0.1 #Remove the lowest X% of edges

    # Depot index
    depot = 0

    for i in range(n):
        for j in range(n):
            if i == j:
                heuristic_matrix[i, j] = 0  # No self-loops
                continue

            # Distance factor:  Shorter distances are more desirable
            distance_factor = alpha / (distance_matrix[i, j] + 1e-6) # add small number to avoid divide by zero

            # Demand proximity factor: Encourages grouping customers with compatible demands
            demand_proximity = 1.0
            if i != depot and j != depot:
                demand_proximity = np.exp(-beta * np.abs(demands[i] + demands[j] - capacity/2) / capacity) #Try to pair up edges to the neighborhood of average demands.

            # Angle penalty: Discourages sharp turns (makes routes more direct).  Only applicable when not at depot.
            angle_penalty = 1.0
            if i != depot and j != depot:
                # Calculate angles between vectors (depot -> i) and (i -> j)
                vector_di = coordinates[i] - coordinates[depot]  #Vector from depot to i
                vector_ij = coordinates[j] - coordinates[i]    #Vector from i to j

                # Normalize vectors to handle edge cases
                vector_di = vector_di / (np.linalg.norm(vector_di) + 1e-6)
                vector_ij = vector_ij / (np.linalg.norm(vector_ij) + 1e-6)

                dot_product = np.dot(vector_di, vector_ij)
                angle = np.arccos(np.clip(dot_product, -1.0, 1.0)) #Angle between 0 and Pi (clip to prevent errors)

                angle_penalty = np.exp(-gamma * angle) # Penalize larger angles, so favor small angle

            heuristic_matrix[i, j] = distance_factor * demand_proximity * angle_penalty

    # Sparsify the matrix:  Remove edges with low heuristic values
    threshold = np.quantile(heuristic_matrix[heuristic_matrix > 0], sparsity_threshold)
    heuristic_matrix[heuristic_matrix < threshold] = 0 #set to zero to cut unpromising edges

    return heuristic_matrix
```
