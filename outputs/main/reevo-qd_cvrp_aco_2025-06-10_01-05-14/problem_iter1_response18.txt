```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    A heuristic function for the Capacitated Vehicle Routing Problem (CVRP) that combines
    distance, demand, and node proximity to determine the promise of including an edge
    in a solution.  Sparsifies the matrix by setting unpromising elements to zero.

    Args:
        distance_matrix (np.ndarray): A matrix of pairwise distances between nodes.
        coordinates (np.ndarray): Coordinates of each node.
        demands (np.ndarray): Demand of each node.
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: A matrix of the same shape as distance_matrix, indicating the
                    promise of including each edge in a solution.
    """
    n = distance_matrix.shape[0]
    promise = np.zeros((n, n))

    # Parameters (tuned empirically)
    distance_weight = 0.5
    demand_weight = 0.3
    proximity_weight = 0.2
    sparsification_threshold = 0.1  # Edges below this threshold are zeroed out

    for i in range(n):
        for j in range(n):
            if i == j:
                promise[i, j] = 0  # No self-loops
                continue

            # Distance factor: Shorter distances are more promising
            distance_factor = 1 / (distance_matrix[i, j] + 1e-9)  # Add a small value to avoid division by zero

            # Demand factor: Lower demands on both nodes are more promising
            demand_factor = 1 / (demands[i] + demands[j] + 1e-9)

            # Proximity to depot factor: Nodes closer to the depot are more attractive as intermediate stops.
            # Encourages connecting far-away nodes to the depot through shorter links, thus spreading demand.
            proximity_factor = (1 / (distance_matrix[i, 0] + 1e-9) + 1/ (distance_matrix[j, 0] + 1e-9))

            # Combine the factors
            promise[i, j] = (distance_weight * distance_factor +
                             demand_weight * demand_factor +
                             proximity_weight * proximity_factor)

    # Normalize promise values between 0 and 1
    promise = (promise - np.min(promise)) / (np.max(promise) - np.min(promise) + 1e-9)


    #Sparsify the matrix: Zero out unpromising edges. Edges connecting to the depot are favored.
    for i in range(n):
      for j in range(n):
        if i == j:
          promise[i, j] = 0 # no self loops

        if (promise[i,j] < sparsification_threshold):
            if( i!= 0 and j !=0 ): #always allow connections with the depot
                promise[i, j] = 0 #sparsify edge
        if demands[i] + demands[j] > capacity and (i!=0 and j != 0): #demand is very large
            promise[i, j] = 0

    return promise
```
