{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # 1. Feasibility check: Disqualify bins that cannot fit the item.\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -np.inf\n    \n    # 2. Remaining capacity after placing the item\n    remaining_capacities = bins_remain_cap - item\n    remaining_capacities[infeasible_bins] = np.inf  # Avoid errors from infeasible bins.\n\n    # 3. Prioritize bins based on fill ratio *after* placing the item. Higher fill ratio is better, but avoid overfilling\n    fill_ratios = 1 - (remaining_capacities / np.max(bins_remain_cap))\n    priorities[~infeasible_bins] = fill_ratios[~infeasible_bins]\n    \n    # 4. Add a small bonus for bins that were already partially filled, so we dont start new bins unnecessarily\n    already_filled = bins_remain_cap < np.max(bins_remain_cap)\n    priorities[already_filled & ~infeasible_bins] += 0.1\n\n    #5. If two bins are equal in fill ratio after the addition of an item prioritize the one with smallest remaining capacity\n    priorities[~infeasible_bins] -= 0.0001 * remaining_capacities[~infeasible_bins]\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Heuristic 1: First-Fit Decreasing adapted for priorities.  Prioritize bins where the item fits, with preference for bins where the remaining capacity is closer to the item size, but not too close (avoiding very small leftovers).\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    for i, cap in enumerate(bins_remain_cap):\n        if item <= cap:\n            # Calculate \"closeness\" to item size, normalized by bin capacity.\n            closeness = 1 - abs(cap - item) / cap\n            # Penalize bins where the remaining space is too small (small leftover after packing).\n            leftover = cap - item\n            if leftover < 0.1:  # Adjust 0.1 based on problem scale\n                priorities[i] = -1  # Very low priority. Could also set to -np.inf\n            else:\n                priorities[i] = closeness\n        else:\n            priorities[i] = -np.inf  # Item doesn't fit; impossible assignment\n\n    # Heuristic 2: Add a small random component to break ties and explore the solution space.\n    priorities += np.random.rand(len(bins_remain_cap)) * 0.001\n\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (2nd), we see that they are identical. Comparing (1st) vs (11th), the 1st uses fill ratio after placing the item and a bonus for partially filled bins, while the 11th minimizes waste, encourages filling bins, avoids almost full bins, boosts bins with similar remaining capacity, and considers remaining capacity as a tie-breaker. Comparing (2nd worst) vs (worst), we see that they are identical. Comparing (3rd) vs (4th), the 3rd prioritizes based on wasted space and fill ratio if the item is added with division by zero protection, while the 4th gives high priority to bins that can fit, adjusts priorities based on remaining capacity ratio, and bonuses almost full bins. Comparing (second best) vs (second worst), they are identical. Comparing (1st) vs (3rd), the first uses fill ratio after placing item while the 3rd uses wasted space.\nOverall: The better heuristics utilize a fill-ratio based approach calculated *after* placing the item, combined with bonuses for already-partially-filled bins to avoid starting new bins. They also include a tie-breaker based on minimizing remaining capacity. The worse heuristics either overly penalize infeasible bins or combine too many different factors without clear weighting. Some heuristics also fail to normalize or scale certain components appropriately. Also, remember to consider edge cases (e.g. division by zero).\n- \nOkay, I'm ready to help you redefine 'Current self-reflection' to design better heuristics! Let's aim for a more effective and insightful approach.\n\nHere's a redefined 'Current self-reflection' focusing on actionable improvements:\n\n*   **Keywords:** Goal-oriented, iterative, adaptable, trade-offs, evaluation metrics, systematic exploration, assumptions, validation.\n*   **Advice:** Define clear, measurable goals *before* designing. Iteratively test and refine heuristics based on performance data. Document assumptions and limitations. Actively explore diverse heuristic structures.\n*   **Avoid:** Premature optimization, rigid adherence to initial designs, neglecting edge cases, relying solely on intuition without validation.\n*   **Explanation:** Emphasize a goal-driven, iterative design process with systematic exploration of different heuristic structures. Avoid getting stuck in initial designs by continuously validating and adapting based on concrete performance metrics. Consider and document the limitations in advance.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}