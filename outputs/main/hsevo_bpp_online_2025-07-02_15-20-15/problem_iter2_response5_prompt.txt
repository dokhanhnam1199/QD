{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Idea:\n    # 1. Heavily penalize bins that cannot fit the item.\n    # 2. Prioritize bins where the item fills a significant portion of the bin\n    #    but avoid bins that will become too full (small remaining space).\n    # 3. Add a small random component to break ties and encourage exploration.\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Penalize bins that cannot fit the item\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] = -np.inf\n\n    # Calculate remaining capacity after adding the item\n    remaining_after_add = bins_remain_cap - item\n\n    # Prioritize bins that can fit the item. Higher the percentage of item/bin size better it is\n    feasible_mask = bins_remain_cap >= item\n    fill_ratios = item / bins_remain_cap[feasible_mask]\n    priorities[feasible_mask] = fill_ratios # Favor bins that item fills well\n\n    # Moderate penalty for bins becoming near-full after adding the item\n    near_full_mask = (remaining_after_add > 0) & (remaining_after_add < 0.1) #remaining capacity less than 10%\n    priorities[near_full_mask] -= 0.2\n\n    # Slight boost for bins that will still have substantial remaining capacity. This is crucial.\n    substantial_remain_mask = (remaining_after_add >= 0.3)\n    priorities[substantial_remain_mask] += 0.1\n\n    # Add a small random number to break ties and explore\n    priorities += np.random.rand(len(bins_remain_cap)) * 0.01\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Heuristic 1: Avoid fragmentation by prioritizing bins that can fit the item snugly.\n    # Heuristic 2: Use a combination of remaining capacity and item size to calculate score.\n    # Heuristic 3: Prefer bins that are relatively full to avoid leaving too much empty space\n    # after placing the current item.\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            # Base priority: Higher remaining capacity implies potentially better fit (less waste).\n            priorities[i] = cap\n\n            # Adjust for 'snugness': Smaller remaining space *after* packing increases the score\n            remaining_after_pack = cap - item\n            priorities[i] += 1.0 / (remaining_after_pack + 0.0001)  # Avoid division by zero\n\n            # Scale the score by how full the bin currently is.\n            current_fullness = 1.0 - (cap / (cap + item)) # Approximation\n            priorities[i] += current_fullness\n        else:\n            priorities[i] = -np.inf  # Item doesn't fit: Lowest priority\n\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (2nd), we see that they are identical. Comparing (1st) vs (11th), the 1st uses fill ratio after placing the item and a bonus for partially filled bins, while the 11th minimizes waste, encourages filling bins, avoids almost full bins, boosts bins with similar remaining capacity, and considers remaining capacity as a tie-breaker. Comparing (2nd worst) vs (worst), we see that they are identical. Comparing (3rd) vs (4th), the 3rd prioritizes based on wasted space and fill ratio if the item is added with division by zero protection, while the 4th gives high priority to bins that can fit, adjusts priorities based on remaining capacity ratio, and bonuses almost full bins. Comparing (second best) vs (second worst), they are identical. Comparing (1st) vs (3rd), the first uses fill ratio after placing item while the 3rd uses wasted space.\nOverall: The better heuristics utilize a fill-ratio based approach calculated *after* placing the item, combined with bonuses for already-partially-filled bins to avoid starting new bins. They also include a tie-breaker based on minimizing remaining capacity. The worse heuristics either overly penalize infeasible bins or combine too many different factors without clear weighting. Some heuristics also fail to normalize or scale certain components appropriately. Also, remember to consider edge cases (e.g. division by zero).\n- \nOkay, I'm ready to help you redefine 'Current self-reflection' to design better heuristics! Let's aim for a more effective and insightful approach.\n\nHere's a redefined 'Current self-reflection' focusing on actionable improvements:\n\n*   **Keywords:** Goal-oriented, iterative, adaptable, trade-offs, evaluation metrics, systematic exploration, assumptions, validation.\n*   **Advice:** Define clear, measurable goals *before* designing. Iteratively test and refine heuristics based on performance data. Document assumptions and limitations. Actively explore diverse heuristic structures.\n*   **Avoid:** Premature optimization, rigid adherence to initial designs, neglecting edge cases, relying solely on intuition without validation.\n*   **Explanation:** Emphasize a goal-driven, iterative design process with systematic exploration of different heuristic structures. Avoid getting stuck in initial designs by continuously validating and adapting based on concrete performance metrics. Consider and document the limitations in advance.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}