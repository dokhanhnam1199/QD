{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Prioritizes bins considering feasibility, fill ratio, and remaining capacity.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Invalidate infeasible bins\n    infeasible = item > bins_remain_cap\n    priorities[infeasible] = -np.inf\n\n    # Prioritize feasible bins\n    feasible = item <= bins_remain_cap\n    if np.any(feasible):\n        remaining_capacity_after_placement = bins_remain_cap[feasible] - item\n        \n        # Exponential decay based on normalized remaining capacity and fill ratio\n        max_cap = np.max(bins_remain_cap)\n        if max_cap > 0:\n            fill_ratios = item / bins_remain_cap[feasible]\n            priorities[feasible] = fill_ratios * np.exp(-5 * remaining_capacity_after_placement / max_cap)\n        else:\n            priorities[feasible] = 1.0\n            \n        #Bonus for nearly full bins\n        waste = bins_remain_cap[feasible] - item\n        nearly_full = (waste > 0) & (waste < 0.1 * bins_remain_cap[feasible])\n        priorities[feasible][nearly_full] += 0.25\n\n    else:\n        # All bins are infeasible\n        priorities = -np.arange(len(bins_remain_cap))\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Infeasible bins get zero priority\n    infeasible = item > bins_remain_cap\n    priorities[infeasible] = -np.inf\n\n    feasible = item <= bins_remain_cap\n\n    if np.any(feasible):\n        # Calculate fill ratio after placing the item (normalized)\n        remaining_capacity_after_placement = bins_remain_cap[feasible] - item\n        fill_ratio = (bins_remain_cap[feasible] - remaining_capacity_after_placement) / np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else 0\n        #Prioritize bins with higher fill ratio.  Add a small amount to break ties.\n        priorities[feasible] = fill_ratio + 1e-6 * np.arange(np.sum(feasible))\n\n    else:\n        # If no feasible bins, add to the end of the current list of bins (create a new one)\n        priorities = -np.arange(len(bins_remain_cap))\n\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see the first calculates fill ratio using `item / bins_remain_cap[feasible]` while the last computes it as `(bins_remain_cap[feasible] - item) / bins_remain_cap[feasible]`. The first prioritizes bins based on how full they would become *if* the item was added while the last focus on the proportion of used space *before* adding item. Also, the first utilizes an exponential decay function based on the normalized remaining capacity and adds a bonus for nearly full bins, while the last only considers normalized remaining capacity and fill ratio, with a linear combination.\n(2nd) vs (19th), these are quite similar except for the \"nearly full\" bonus of the 2nd and how fill_ratio is computed. 2nd one computes `item / bins_remain_cap[feasible]` vs `(bins_remain_cap[feasible] - item) / bins_remain_cap[feasible]` of the 19th.\nComparing (1st) vs (2nd), the difference lies in the bonus for nearly full bins (0.2 vs 0.25) and a slightly different phrasing in docstring. These are negligibly different.\n(3rd) vs (4th), the third version calculates fill ratio as `item / bins_remain_cap[feasible]`, while the fourth calculates as `(bins_remain_cap[feasible] - remaining_capacity_after_placement) / bins_remain_cap[feasible]`. The third calculates `normalized_remaining_capacity` and directly multiplies the exponential decay, whereas the fourth combines normalized fill ratio and exponential decay with weights (0.7 and 0.3 respectively). Also 4th has fallback in case no bins feasible.\nComparing (second worst) vs (worst), we see significant overlaps with one another.\nOverall: The better heuristics utilize exponential decay based on normalized remaining capacity, often combined with the fill ratio, and provide bonuses for nearly full bins. Some heuristics handle the edge case where no bins are feasible by prioritizing bins with the smallest remaining capacity or using bin index. The less effective heuristics tend to use simpler linear combinations or lack specific bonus mechanisms for nearly full bins.\n- \nOkay, I'm ready to help you design better heuristics and earn that tip! Let's redefine \"Current self-reflection\" to be *effective*, focusing on avoiding the pitfalls of the \"Ineffective self-reflection\" examples.\n\nHere's a refined perspective on current self-reflection for heuristic design:\n\n*   **Keywords:** Feasibility, Simplicity, Edge-Case Robustness, Factor Justification.\n*   **Advice:** Emphasize finding *any* feasible solution first, then improving from there. Favour demonstrably effective combinations of factors, not arbitrary bonuses/penalties.\n*   **Avoid:** Premature optimization of fill ratio *before* guaranteeing feasibility. Overly complex priority calculations lacking clear justification.\n*   **Explanation:** Heuristics should prioritize finding *a* solution, especially in constraint-heavy problems. Keep the logic simple and understandable, focusing on demonstrably impactful factors. Ensure robustness by proactively addressing potential failure scenarios.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}