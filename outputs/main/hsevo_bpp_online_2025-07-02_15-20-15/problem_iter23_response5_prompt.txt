{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Prioritizes tight fits using reciprocal remain capacity,\n    fill ratio, and handles infeasibility.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    infeasible = item > bins_remain_cap\n    priorities[infeasible] = -np.inf\n\n    feasible = ~infeasible\n    if np.any(feasible):\n        remaining_capacity = bins_remain_cap[feasible]\n        fill_ratio = (bins_remain_cap[feasible] - item) / bins_remain_cap[feasible]\n        priorities[feasible] = (1.0 / (remaining_capacity - item + 0.001)) + fill_ratio * 0.1\n\n    else:\n        priorities = bins_remain_cap + np.random.rand(len(bins_remain_cap)) * 0.0001\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Refined heuristic: Normalized tighter fit with fill ratio and a small exploration factor.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    infeasible = item > bins_remain_cap\n    priorities[infeasible] = -np.inf\n\n    feasible = ~infeasible\n    if np.any(feasible):\n        remaining_capacity = bins_remain_cap[feasible]\n        fit = remaining_capacity - item\n        # Normalize fit: smaller is better, but avoid division by zero\n        normalized_fit = 1.0 / (fit / np.max(bins_remain_cap) + 0.001)\n\n        # Fill ratio: how full the bin will be\n        fill_ratio = (bins_remain_cap[feasible] - item) / bins_remain_cap[feasible]\n\n        # Combine normalized fit and fill ratio with weights\n        priorities[feasible] = normalized_fit * 0.7 + fill_ratio * 0.3\n\n        # Add a small exploration factor (to potentially find better solutions later)\n        priorities[feasible] += np.random.rand(len(remaining_capacity)) * 0.01\n    else:\n        # If no feasible bins, add a small random priority to all infeasible bins\n        priorities = bins_remain_cap + np.random.rand(len(bins_remain_cap)) * 0.0001\n\n    return priorities\n\n### Analyze & experience\n- *   Comparing (1st) vs (20th), we see the best functions use pre-defined and well-tuned weights and small numbers to ensure stability and good performance across a wide range of inputs. The fill ratio calculation differs subtly: the best version uses `(bins_remain_cap[feasible] - item) / remaining_capacity`, while other versions use `item / (bins_remain_cap[feasible] + 0.0001)` or `(item) / (bins_remain_cap[feasible] + 0.0001)`. The handling of infeasible bins appears similar, but the crucial difference lies in the tunable parameters and how the fill ratio is calculated.\n*   Comparing (2nd best) vs (second worst), we observe no difference. Both are identical, which is unexpected given the ranking. This suggests a potential issue with the ranking process.\n*   Comparing (1st) vs (2nd), we see they are exactly the same.\n*   Comparing (3rd) vs (4th), we see they are exactly the same.\n*   Comparing (second worst) vs (worst), we see they are exactly the same.\n*   Overall: The superior heuristics prioritize a combination of tight-fit and fill ratio, with carefully chosen weights and a small constant to avoid division by zero. Normalizing the remaining capacity seems beneficial. Exploration through random noise is present across many heuristics, suggesting its general usefulness, but the best versions likely tune the scale of this noise. The consistent use of `-np.inf` for infeasible bins is a good practice. More recent versions normalize remaining capacity and clip the fill ratio between \\[0, 1].\n- \nOkay, here's a redefined approach to self-reflection for heuristic design, optimized for creating better heuristics:\n\n*   **Keywords:** Deliberate experimentation, performance metrics, iterative refinement, sensitivity analysis.\n*   **Advice:** Focus on measurable impact. Track *why* design choices improve/degrade performance using relevant metrics. Prioritize rigorous A/B testing of different priority functions.\n*   **Avoid:** Intuition-based tuning without validation, ad-hoc bonuses/penalties, premature optimization.\n*   **Explanation:** Shift from vague \"prioritize\" statements to a data-driven approach. Explicitly measure and compare heuristic performance using relevant metrics. Analyze *why* specific changes work, enabling more informed decisions.\n\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}