{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # 1. Feasibility check: Disqualify bins that cannot fit the item.\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -np.inf\n    \n    # 2. Remaining capacity after placing the item\n    remaining_capacities = bins_remain_cap - item\n    remaining_capacities[infeasible_bins] = np.inf  # Avoid errors from infeasible bins.\n\n    # 3. Prioritize bins based on fill ratio *after* placing the item. Higher fill ratio is better, but avoid overfilling\n    fill_ratios = 1 - (remaining_capacities / np.max(bins_remain_cap))\n    priorities[~infeasible_bins] = fill_ratios[~infeasible_bins]\n    \n    # 4. Add a small bonus for bins that were already partially filled, so we dont start new bins unnecessarily\n    already_filled = bins_remain_cap < np.max(bins_remain_cap)\n    priorities[already_filled & ~infeasible_bins] += 0.1\n\n    #5. If two bins are equal in fill ratio after the addition of an item prioritize the one with smallest remaining capacity\n    priorities[~infeasible_bins] -= 0.0001 * remaining_capacities[~infeasible_bins]\n\n    return priorities\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # 1. Feasibility check: Disqualify bins that cannot fit the item.\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -np.inf\n    \n    # 2. Remaining capacity after placing the item\n    remaining_capacities = bins_remain_cap - item\n    remaining_capacities[infeasible_bins] = np.inf  # Avoid errors from infeasible bins.\n\n    # 3. Prioritize bins based on fill ratio *after* placing the item. Higher fill ratio is better, but avoid overfilling\n    fill_ratios = 1 - (remaining_capacities / np.max(bins_remain_cap))\n    priorities[~infeasible_bins] = fill_ratios[~infeasible_bins]\n    \n    # 4. Add a small bonus for bins that were already partially filled, so we dont start new bins unnecessarily\n    already_filled = bins_remain_cap < np.max(bins_remain_cap)\n    priorities[already_filled & ~infeasible_bins] += 0.1\n\n    #5. If two bins are equal in fill ratio after the addition of an item prioritize the one with smallest remaining capacity\n    priorities[~infeasible_bins] -= 0.0001 * remaining_capacities[~infeasible_bins]\n\n    return priorities\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # First, consider bins where the item fits.\n    fit_indices = np.where(bins_remain_cap >= item)[0]\n    \n    if len(fit_indices) > 0:\n        # Try to minimize wasted space, while favoring fuller bins.\n        # Calculate wasted space for each bin where the item fits.\n        wasted_space = bins_remain_cap[fit_indices] - item\n        \n        #Prioritize bins based on: 1/wasted_space + fill ratio if item is added\n        fill_ratio_if_added = (bins_remain_cap[fit_indices] - wasted_space) / (bins_remain_cap[fit_indices] + item - wasted_space)\n        priorities[fit_indices] = (1 / (wasted_space + 1e-9)) + fill_ratio_if_added #add small number to avoid division by 0\n\n    # For bins where the item doesn't fit, assign a very low priority.\n    else:\n      priorities = -np.inf * np.ones_like(bins_remain_cap, dtype=float)\n\n\n    return priorities\n\n[Heuristics 4th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priorities with a base value (e.g., 0).\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Give high priority to bins that can fit the item. If a bin cannot fit, the priority is zero\n    fit_indices = bins_remain_cap >= item\n    priorities[fit_indices] = 1.0\n\n    # Adjust priorities based on how well the item fits. Use a ratio of remaining capacity after fitting.\n    remaining_capacity = bins_remain_cap[fit_indices] - item\n    capacity_ratios = remaining_capacity / bins_remain_cap[fit_indices]\n\n    # A smaller remaining capacity should give a higher priority. The most full-like bin is thus prioritized\n    priorities[fit_indices] += (1.0 - capacity_ratios)**2  # Adding to the already existing '1'\n\n    #Bonus for almost full bin. If the bin can take the new item almost perfectly without leaving any considerable space, prioritize it\n    almost_full_indices = np.where((bins_remain_cap >= item) & (bins_remain_cap - item <= 0.1*bins_remain_cap ))[0]\n    priorities[almost_full_indices]+=1.0 #Bonus Score\n\n    return priorities\n\n[Heuristics 5th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priorities with a base value (e.g., 0).\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Give high priority to bins that can fit the item. If a bin cannot fit, the priority is zero\n    fit_indices = bins_remain_cap >= item\n    priorities[fit_indices] = 1.0\n\n    # Adjust priorities based on how well the item fits. Use a ratio of remaining capacity after fitting.\n    remaining_capacity = bins_remain_cap[fit_indices] - item\n    capacity_ratios = remaining_capacity / bins_remain_cap[fit_indices]\n\n    # A smaller remaining capacity should give a higher priority. The most full-like bin is thus prioritized\n    priorities[fit_indices] += (1.0 - capacity_ratios)**2  # Adding to the already existing '1'\n\n    #Bonus for almost full bin. If the bin can take the new item almost perfectly without leaving any considerable space, prioritize it\n    almost_full_indices = np.where((bins_remain_cap >= item) & (bins_remain_cap - item <= 0.1*bins_remain_cap ))[0]\n    priorities[almost_full_indices]+=1.0 #Bonus Score\n\n    return priorities\n\n[Heuristics 6th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Aimed at reducing bin fragmentation and overall bin count.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. High priority for bins that can fit the item closely\n    fit_mask = bins_remain_cap >= item\n    priorities[fit_mask] = (bins_remain_cap[fit_mask] - item) / bins_remain_cap[fit_mask]  # Remaining capacity ratio - Smaller is better, so invert\n\n    priorities[fit_mask] = 1 - priorities[fit_mask] #higher number, higher priority\n\n    # 2. Very low priority for bins that can't fit (to discourage large item being crammed in tight spaces later.)\n    priorities[bins_remain_cap < item] = -1.0\n\n    # 3. Favor bins that are relatively empty (encourage use of partially filled bins before starting new ones).\n    # This term is weaker than the fit closeness to allow bins close in capacity to be filled faster.\n    normalized_capacity = bins_remain_cap / np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else np.zeros_like(bins_remain_cap)\n    priorities += 0.1*normalized_capacity #add remaining capacity priority\n    return priorities\n\n[Heuristics 7th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Aimed at reducing bin fragmentation and overall bin count.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. High priority for bins that can fit the item closely\n    fit_mask = bins_remain_cap >= item\n    priorities[fit_mask] = (bins_remain_cap[fit_mask] - item) / bins_remain_cap[fit_mask]  # Remaining capacity ratio - Smaller is better, so invert\n\n    priorities[fit_mask] = 1 - priorities[fit_mask] #higher number, higher priority\n\n    # 2. Very low priority for bins that can't fit (to discourage large item being crammed in tight spaces later.)\n    priorities[bins_remain_cap < item] = -1.0\n\n    # 3. Favor bins that are relatively empty (encourage use of partially filled bins before starting new ones).\n    # This term is weaker than the fit closeness to allow bins close in capacity to be filled faster.\n    normalized_capacity = bins_remain_cap / np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else np.zeros_like(bins_remain_cap)\n    priorities += 0.1*normalized_capacity #add remaining capacity priority\n    return priorities\n\n[Heuristics 8th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Utilizes a combination of heuristics inspired by physics and a touch of 'divine intuition'.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # 1. Gravitational Attraction:\n    # Bins with capacity closer to the item's size have higher 'gravitational attraction'.\n    attraction = np.exp(-np.abs(bins_remain_cap - item) / (item + 1e-6))\n\n    # 2. Conservation of Energy (Bin Capacity):\n    # We don't want to 'overfill' the bin. Penalize bins that would be too full.\n    energy_potential = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    energy_potential[valid_bins] = (bins_remain_cap[valid_bins] - item) / bins_remain_cap[valid_bins]\n    energy_potential[~valid_bins] = -1  # Heavily penalize invalid bins\n    energy_potential = np.clip(energy_potential, -1, 1)  # Ensure values stay within a reasonable range\n\n\n    # 3. \"God Does Not Play Dice\":\n    # Preferentially use bins that are already partially filled. The more a bin is\n    # filled, the more likely it is to accept another item without wasting too much space\n    # \"Fullness\" factor -- encourages efficient space usage\n    fullness_factor = (1 - (bins_remain_cap / bins_remain_cap.max()))\n    fullness_factor = np.clip(fullness_factor, 0, 1) # Ensure values are non-negative\n\n    # 4. A touch of randomness for exploration. Add small Gaussian noise\n    noise = np.random.normal(0, 0.01, size=bins_remain_cap.shape)\n\n    # Combine these factors with carefully chosen weights.\n    priority = 0.5 * attraction + 0.3 * energy_potential + 0.2*fullness_factor + noise\n\n    return priority\n\n[Heuristics 9th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Find bins that can accommodate the item\n    feasible_bins = bins_remain_cap >= item\n\n    if np.any(feasible_bins):\n        # Calculate remaining capacity after placing item in feasible bins\n        remaining_capacities = bins_remain_cap[feasible_bins] - item\n\n        # Prioritize bins with smallest remaining capacity after placement (first-fit decreasing)\n        priorities[feasible_bins] = 1 / (remaining_capacities + 1e-9) # add a small constant to avoid division by zero\n\n        # Optionally, add a bonus for bins that are almost full\n        almost_full_threshold = 0.1  # e.g., bin is at least 90% full after placement\n        almost_full = remaining_capacities / bins_remain_cap[feasible_bins] < almost_full_threshold\n        priorities[feasible_bins][almost_full] *= 2  # Double the priority for almost full bins\n\n    else:\n        # If no feasible bins, penalize bins with low capacity\n        priorities = -1 / (bins_remain_cap + 1e-9) # Penalize the bins. Add small constant to avoid div by 0\n\n    return priorities\n\n[Heuristics 10th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Find bins that can accommodate the item\n    feasible_bins = bins_remain_cap >= item\n\n    if np.any(feasible_bins):\n        # Calculate remaining capacity after placing item in feasible bins\n        remaining_capacities = bins_remain_cap[feasible_bins] - item\n\n        # Prioritize bins with smallest remaining capacity after placement (first-fit decreasing)\n        priorities[feasible_bins] = 1 / (remaining_capacities + 1e-9) # add a small constant to avoid division by zero\n\n        # Optionally, add a bonus for bins that are almost full\n        almost_full_threshold = 0.1  # e.g., bin is at least 90% full after placement\n        almost_full = remaining_capacities / bins_remain_cap[feasible_bins] < almost_full_threshold\n        priorities[feasible_bins][almost_full] *= 2  # Double the priority for almost full bins\n\n    else:\n        # If no feasible bins, penalize bins with low capacity\n        priorities = -1 / (bins_remain_cap + 1e-9) # Penalize the bins. Add small constant to avoid div by 0\n\n    return priorities\n\n[Heuristics 11th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priorities with a default low value\n    priorities = np.zeros_like(bins_remain_cap, dtype=float) - np.inf\n\n    # Identify bins that can accommodate the item\n    valid_bins = bins_remain_cap >= item\n\n    if not np.any(valid_bins):\n        return priorities # No bin can fit the item, return lowest possible priorities.\n\n    # Calculate waste if item is placed in the bin\n    waste = bins_remain_cap - item\n\n    # Prioritize bins based on different strategies:\n    # 1. Minimize waste (First-Fit Decreasing variant): Favor bins with less remaining space after placement\n    priorities[valid_bins] = -waste[valid_bins]  # Smaller waste = higher priority\n\n    # 2. Avoid fragmentation (Encourage filling bins as much as possible):\n    fill_ratios = item / bins_remain_cap\n    priorities[valid_bins] += 5 * fill_ratios[valid_bins] # Reward higher fill ratios\n\n    # 3. Avoid bins that are ALMOST full after adding the item (Leave enough room for future smaller items):\n    nearly_full = (waste > 0) & (waste < 0.1 * bins_remain_cap) # Bins with waste less than 10% of bin capacity\n    priorities[nearly_full] -= 10  # Penalize nearly full bins\n\n    # 4. Boost bins with nearly the same size remaining capacity as the item\n    same_size = np.isclose(bins_remain_cap, item)\n    priorities[same_size] += 20\n\n    # 5. Consider the amount of remaining capacity as a tie-breaker\n    priorities[valid_bins] += 0.01 * bins_remain_cap[valid_bins]  # Higher remaining capacity, slightly higher priority (as a tie-breaker)\n\n    return priorities\n\n[Heuristics 12th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priorities with a default low value\n    priorities = np.zeros_like(bins_remain_cap, dtype=float) - np.inf\n\n    # Identify bins that can accommodate the item\n    valid_bins = bins_remain_cap >= item\n\n    if not np.any(valid_bins):\n        return priorities # No bin can fit the item, return lowest possible priorities.\n\n    # Calculate waste if item is placed in the bin\n    waste = bins_remain_cap - item\n\n    # Prioritize bins based on different strategies:\n    # 1. Minimize waste (First-Fit Decreasing variant): Favor bins with less remaining space after placement\n    priorities[valid_bins] = -waste[valid_bins]  # Smaller waste = higher priority\n\n    # 2. Avoid fragmentation (Encourage filling bins as much as possible):\n    fill_ratios = item / bins_remain_cap\n    priorities[valid_bins] += 5 * fill_ratios[valid_bins] # Reward higher fill ratios\n\n    # 3. Avoid bins that are ALMOST full after adding the item (Leave enough room for future smaller items):\n    nearly_full = (waste > 0) & (waste < 0.1 * bins_remain_cap) # Bins with waste less than 10% of bin capacity\n    priorities[nearly_full] -= 10  # Penalize nearly full bins\n\n    # 4. Boost bins with nearly the same size remaining capacity as the item\n    same_size = np.isclose(bins_remain_cap, item)\n    priorities[same_size] += 20\n\n    # 5. Consider the amount of remaining capacity as a tie-breaker\n    priorities[valid_bins] += 0.01 * bins_remain_cap[valid_bins]  # Higher remaining capacity, slightly higher priority (as a tie-breaker)\n\n    return priorities\n\n[Heuristics 13th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priorities with a default low value\n    priorities = np.zeros_like(bins_remain_cap, dtype=float) - np.inf\n\n    # Identify bins that can accommodate the item\n    valid_bins = bins_remain_cap >= item\n\n    if not np.any(valid_bins):\n        return priorities # No bin can fit the item, return lowest possible priorities.\n\n    # Calculate waste if item is placed in the bin\n    waste = bins_remain_cap - item\n\n    # Prioritize bins based on different strategies:\n    # 1. Minimize waste (First-Fit Decreasing variant): Favor bins with less remaining space after placement\n    priorities[valid_bins] = -waste[valid_bins]  # Smaller waste = higher priority\n\n    # 2. Avoid fragmentation (Encourage filling bins as much as possible):\n    fill_ratios = item / bins_remain_cap\n    priorities[valid_bins] += 5 * fill_ratios[valid_bins] # Reward higher fill ratios\n\n    # 3. Avoid bins that are ALMOST full after adding the item (Leave enough room for future smaller items):\n    nearly_full = (waste > 0) & (waste < 0.1 * bins_remain_cap) # Bins with waste less than 10% of bin capacity\n    priorities[nearly_full] -= 10  # Penalize nearly full bins\n\n    # 4. Boost bins with nearly the same size remaining capacity as the item\n    same_size = np.isclose(bins_remain_cap, item)\n    priorities[same_size] += 20\n\n    # 5. Consider the amount of remaining capacity as a tie-breaker\n    priorities[valid_bins] += 0.01 * bins_remain_cap[valid_bins]  # Higher remaining capacity, slightly higher priority (as a tie-breaker)\n\n    return priorities\n\n[Heuristics 14th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Idea:\n    # 1. Heavily penalize bins that cannot fit the item.\n    # 2. Prioritize bins where the item fills a significant portion of the bin\n    #    but avoid bins that will become too full (small remaining space).\n    # 3. Add a small random component to break ties and encourage exploration.\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Penalize bins that cannot fit the item\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] = -np.inf\n\n    # Calculate remaining capacity after adding the item\n    remaining_after_add = bins_remain_cap - item\n\n    # Prioritize bins that can fit the item. Higher the percentage of item/bin size better it is\n    feasible_mask = bins_remain_cap >= item\n    fill_ratios = item / bins_remain_cap[feasible_mask]\n    priorities[feasible_mask] = fill_ratios # Favor bins that item fills well\n\n    # Moderate penalty for bins becoming near-full after adding the item\n    near_full_mask = (remaining_after_add > 0) & (remaining_after_add < 0.1) #remaining capacity less than 10%\n    priorities[near_full_mask] -= 0.2\n\n    # Slight boost for bins that will still have substantial remaining capacity. This is crucial.\n    substantial_remain_mask = (remaining_after_add >= 0.3)\n    priorities[substantial_remain_mask] += 0.1\n\n    # Add a small random number to break ties and explore\n    priorities += np.random.rand(len(bins_remain_cap)) * 0.01\n\n    return priorities\n\n[Heuristics 15th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Idea:\n    # 1. Heavily penalize bins that cannot fit the item.\n    # 2. Prioritize bins where the item fills a significant portion of the bin\n    #    but avoid bins that will become too full (small remaining space).\n    # 3. Add a small random component to break ties and encourage exploration.\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Penalize bins that cannot fit the item\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] = -np.inf\n\n    # Calculate remaining capacity after adding the item\n    remaining_after_add = bins_remain_cap - item\n\n    # Prioritize bins that can fit the item. Higher the percentage of item/bin size better it is\n    feasible_mask = bins_remain_cap >= item\n    fill_ratios = item / bins_remain_cap[feasible_mask]\n    priorities[feasible_mask] = fill_ratios # Favor bins that item fills well\n\n    # Moderate penalty for bins becoming near-full after adding the item\n    near_full_mask = (remaining_after_add > 0) & (remaining_after_add < 0.1) #remaining capacity less than 10%\n    priorities[near_full_mask] -= 0.2\n\n    # Slight boost for bins that will still have substantial remaining capacity. This is crucial.\n    substantial_remain_mask = (remaining_after_add >= 0.3)\n    priorities[substantial_remain_mask] += 0.1\n\n    # Add a small random number to break ties and explore\n    priorities += np.random.rand(len(bins_remain_cap)) * 0.01\n\n    return priorities\n\n[Heuristics 16th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Heuristic 1: First-Fit Decreasing adapted for priorities.  Prioritize bins where the item fits, with preference for bins where the remaining capacity is closer to the item size, but not too close (avoiding very small leftovers).\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    for i, cap in enumerate(bins_remain_cap):\n        if item <= cap:\n            # Calculate \"closeness\" to item size, normalized by bin capacity.\n            closeness = 1 - abs(cap - item) / cap\n            # Penalize bins where the remaining space is too small (small leftover after packing).\n            leftover = cap - item\n            if leftover < 0.1:  # Adjust 0.1 based on problem scale\n                priorities[i] = -1  # Very low priority. Could also set to -np.inf\n            else:\n                priorities[i] = closeness\n        else:\n            priorities[i] = -np.inf  # Item doesn't fit; impossible assignment\n\n    # Heuristic 2: Add a small random component to break ties and explore the solution space.\n    priorities += np.random.rand(len(bins_remain_cap)) * 0.001\n\n    return priorities\n\n[Heuristics 17th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins that can fit the item closely,\n    but also adds a small bonus for bins that are emptier, to\n    encourage filling up partially empty bins. It also heavily penalizes bins that cannot fit the item.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Penalize bins that cannot fit the item *very* strongly.\n    infeasible = bins_remain_cap < item\n    priorities[infeasible] = -np.inf\n\n    # For bins that can fit the item, calculate a priority based on:\n    # 1. How closely the item fits (remaining capacity after adding)\n    # 2. A small bonus for the remaining capacity *before* adding the item.\n\n    feasible = bins_remain_cap >= item\n    remaining_after = bins_remain_cap[feasible] - item\n    \n    # The smaller remaining_after, the better.  Using reciprocal.\n    fit_priority = 1.0 / (remaining_after + 0.0001)  # add small constant to avoid division by zero if remaining_after is near zero\n\n    # Bonus for emptier bins. Using a logarithmic scale so as not to overpower the fit_priority.\n    empty_bonus = np.log(bins_remain_cap[feasible] + 1)\n\n    priorities[feasible] = fit_priority + 0.1 * empty_bonus  # weighted combination of fit priority and empty bonus\n\n    return priorities\n\n[Heuristics 18th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins that can fit the item closely,\n    but also adds a small bonus for bins that are emptier, to\n    encourage filling up partially empty bins. It also heavily penalizes bins that cannot fit the item.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Penalize bins that cannot fit the item *very* strongly.\n    infeasible = bins_remain_cap < item\n    priorities[infeasible] = -np.inf\n\n    # For bins that can fit the item, calculate a priority based on:\n    # 1. How closely the item fits (remaining capacity after adding)\n    # 2. A small bonus for the remaining capacity *before* adding the item.\n\n    feasible = bins_remain_cap >= item\n    remaining_after = bins_remain_cap[feasible] - item\n    \n    # The smaller remaining_after, the better.  Using reciprocal.\n    fit_priority = 1.0 / (remaining_after + 0.0001)  # add small constant to avoid division by zero if remaining_after is near zero\n\n    # Bonus for emptier bins. Using a logarithmic scale so as not to overpower the fit_priority.\n    empty_bonus = np.log(bins_remain_cap[feasible] + 1)\n\n    priorities[feasible] = fit_priority + 0.1 * empty_bonus  # weighted combination of fit priority and empty bonus\n\n    return priorities\n\n[Heuristics 19th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    This version incorporates a \"near miss\" bonus and a penalty for bins that are too small.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Penalty for bins that cannot contain the item\n    priorities[bins_remain_cap < item] = -np.inf  # Or a very large negative number\n\n    # Calculate \"near miss\" bonus - bins only slightly larger than the item get high priority\n    near_miss_threshold = item * 1.2 #tuneable, percentage above item size to be \"near miss\"\n    near_miss_bonus = np.exp(-np.abs(bins_remain_cap - item) / (item*0.1))  # Gaussian-like bonus near item size.  0.1 is tunable.\n    near_miss_bonus[bins_remain_cap < item] = 0 # Avoid triggering near-miss for impossible fits\n    priorities += near_miss_bonus\n\n    # Fill rate priority- favors filling almost empty bins somewhat.\n    fill_rate_priority = (bins_remain_cap - item)/bins_remain_cap\n    fill_rate_priority[bins_remain_cap < item] = -np.inf\n    priorities += fill_rate_priority # Consider scaling if one influence is too strong\n\n    #Remaining capacity priority (modified first-fit)\n    priorities += bins_remain_cap / np.sum(bins_remain_cap)\n\n    return priorities\n\n[Heuristics 20th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Heuristic 1: Avoid fragmentation by prioritizing bins that can fit the item snugly.\n    # Heuristic 2: Use a combination of remaining capacity and item size to calculate score.\n    # Heuristic 3: Prefer bins that are relatively full to avoid leaving too much empty space\n    # after placing the current item.\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            # Base priority: Higher remaining capacity implies potentially better fit (less waste).\n            priorities[i] = cap\n\n            # Adjust for 'snugness': Smaller remaining space *after* packing increases the score\n            remaining_after_pack = cap - item\n            priorities[i] += 1.0 / (remaining_after_pack + 0.0001)  # Avoid division by zero\n\n            # Scale the score by how full the bin currently is.\n            current_fullness = 1.0 - (cap / (cap + item)) # Approximation\n            priorities[i] += current_fullness\n        else:\n            priorities[i] = -np.inf  # Item doesn't fit: Lowest priority\n\n    return priorities\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}