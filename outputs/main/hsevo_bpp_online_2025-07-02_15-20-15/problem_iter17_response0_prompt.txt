{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Enhanced heuristic: Considers tightness of fit, fill ratio, and bin utilization with a balanced approach.\n\n    This heuristic prioritizes bins based on a combination of factors:\n    1. Tightness of fit: Favors bins where the item fits snugly (small remaining capacity).\n    2. Fill ratio: Encourages filling bins reasonably well without overfilling.\n    3. Bin utilization: Gives a slight preference to bins that are already partially filled,\n       promoting better overall bin usage.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    infeasible = item > bins_remain_cap\n    priorities[infeasible] = -np.inf  # Mark infeasible bins with negative infinity\n\n    feasible = ~infeasible\n    if np.any(feasible):\n        remaining_capacity = bins_remain_cap[feasible]\n\n        # Tightness of fit: Reciprocal of remaining capacity after placing the item\n        fit_priority = 1.0 / (remaining_capacity - item + 0.0001)\n\n        # Fill ratio: How well the item fills the bin\n        fill_ratio = (item) / (bins_remain_cap[feasible] + 0.0001)  # fill ratio with respect to the current bin cap\n\n        # Bin utilization: Encourages filling partially filled bins\n        utilization_priority = (bins_remain_cap[feasible] - item) / np.max(bins_remain_cap)\n        # Combine the priorities with carefully chosen weights\n        priorities[feasible] = 0.6 * fit_priority + 0.3 * fill_ratio + 0.1 * utilization_priority\n\n    else:\n        # If no bin can fit the item, create a new bin if applicable/possible,\n        # or select a bin randomly with a small priority to avoid infinite loops or unhandled exceptions\n        priorities = bins_remain_cap + np.random.rand(len(bins_remain_cap)) * 0.0001\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Prioritizes bins based on tight fit and remaining capacity.\n    Handles infeasible bins and encourages exploration.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    infeasible = item > bins_remain_cap\n    priorities[infeasible] = -np.inf\n\n    feasible = item <= bins_remain_cap\n\n    if np.any(feasible):\n        remaining_capacity = bins_remain_cap[feasible] - item\n        priorities[feasible] = (1 / remaining_capacity) if np.all(remaining_capacity != 0) else 0\n\n        # Boost partially full bins\n        current_fill_ratio = (bins_remain_cap[feasible] - remaining_capacity) / np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else 0\n        priorities[feasible] += 0.2 * current_fill_ratio  # Reduced boost\n\n    else:\n        # Prioritize emptiest bin with noise if no feasible bins\n        priorities = np.random.rand(len(bins_remain_cap)) * 0.001 - bins_remain_cap\n\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see the best heuristic prioritizes tight fits using the reciprocal of remaining capacity after placement, incorporates a fill ratio component, and adds a small constant to prevent division by zero. It uses `+ fill_ratio * 0.1` to add a fill ratio, while the worst only considers the inverse of remaining capacity and adds a fill ratio boost. The best also adds a small random component when no bin is feasible, using `np.random.rand(len(bins_remain_cap)) * 0.0001` to encourage exploration, whereas the worst prioritizes emptiest bin with noise. The best heuristics use `priorities = bins_remain_cap + np.random.rand(len(bins_remain_cap)) * 0.0001` if no bin is feasible.\n\nComparing (2nd best) vs (second worst), we see the second best prioritizes bins based on reciprocal remaining capacity and noise for infeasible bins. Boost partially full bins using `partially_full = (waste > 0) & (waste < 0.2 * bins_remain_cap[feasible])` and `priorities[feasible][partially_full] += 0.5`, with a noise for infeasible bins `priorities[infeasible] = -np.random.rand(np.sum(infeasible))`. The second worst heuristic also prioritizes based on reciprocal remaining capacity but boost partially full bins with noise (exploration) with condition `partially_full = (waste > 0) & (waste < 0.2 * bins_remain_cap[feasible])`. In the else case, the second worst heuristic uses random exploration `priorities = np.random.rand(len(bins_remain_cap))` if all bins are infeasible.\n\nComparing (1st) vs (2nd), they are all the same.\n\nComparing (3rd) vs (4th), they are all the same.\n\nComparing (second worst) vs (worst), we see the second worst prioritizes the emptiest bin with noise if no feasible bin while the worst prioritize emptiest bin with noise if no feasible bins as well.\n\nOverall:\nThe best heuristics seem to strike a balance between prioritizing tight fits (small remaining capacity), encouraging reasonable fill ratios, considering existing bin utilization, and incorporating an element of exploration (randomness) to escape local optima or handle cases where no feasible bins exist. Infeasible bins are consistently handled by assigning a very low priority (often -np.inf) or by using noise to ensure exploration. Weighting different factors (tightness of fit, fill ratio, bin utilization) appears to be a crucial element in differentiating the better heuristics.\n- \nOkay, let's refine \"Current Self-Reflection\" into something more actionable for designing better bin packing heuristics, while avoiding the pitfalls of \"Ineffective Self-Reflection.\" We'll focus on clarity, concrete suggestions, and avoiding complexity without justification.\n\nHere's a redefined \"Current Self-Reflection\":\n\n*   **Keywords:** Tight-fit, controlled randomness, normalization, infeasibility handling, reciprocal capacity, balanced factors, exploration\n\n*   **Advice:** Start with a small, well-defined set of priority factors (e.g., tightness of fit, fill ratio) and *systematically* introduce complexity if needed. Experiment with reciprocal remaining capacity instead of exponential decay. Use controlled randomness (e.g., epsilon-greedy) to explore new bin openings.\n\n*   **Avoid:** Overly complex combinations of factors without a clear, testable hypothesis. Relying solely on bonuses/penalties without a solid baseline heuristic. Prematurely normalizing all priority scores, especially without understanding individual factor distributions.\n\n*   **Explanation:** The goal is to create interpretable heuristics. Track the impact of each added factor. Focus on a reciprocal remaining capacity to emphasize tight fits while avoiding the potential for exponential decay to overly prioritize certain bins. Handle infeasibility explicitly and with minimal impact on other parts of heuristic.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}