{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Aimed at reducing bin fragmentation and overall bin count.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. High priority for bins that can fit the item closely\n    fit_mask = bins_remain_cap >= item\n    priorities[fit_mask] = (bins_remain_cap[fit_mask] - item) / bins_remain_cap[fit_mask]  # Remaining capacity ratio - Smaller is better, so invert\n\n    priorities[fit_mask] = 1 - priorities[fit_mask] #higher number, higher priority\n\n    # 2. Very low priority for bins that can't fit (to discourage large item being crammed in tight spaces later.)\n    priorities[bins_remain_cap < item] = -1.0\n\n    # 3. Favor bins that are relatively empty (encourage use of partially filled bins before starting new ones).\n    # This term is weaker than the fit closeness to allow bins close in capacity to be filled faster.\n    normalized_capacity = bins_remain_cap / np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else np.zeros_like(bins_remain_cap)\n    priorities += 0.1*normalized_capacity #add remaining capacity priority\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priorities with a default low value\n    priorities = np.zeros_like(bins_remain_cap, dtype=float) - np.inf\n\n    # Identify bins that can accommodate the item\n    valid_bins = bins_remain_cap >= item\n\n    if not np.any(valid_bins):\n        return priorities # No bin can fit the item, return lowest possible priorities.\n\n    # Calculate waste if item is placed in the bin\n    waste = bins_remain_cap - item\n\n    # Prioritize bins based on different strategies:\n    # 1. Minimize waste (First-Fit Decreasing variant): Favor bins with less remaining space after placement\n    priorities[valid_bins] = -waste[valid_bins]  # Smaller waste = higher priority\n\n    # 2. Avoid fragmentation (Encourage filling bins as much as possible):\n    fill_ratios = item / bins_remain_cap\n    priorities[valid_bins] += 5 * fill_ratios[valid_bins] # Reward higher fill ratios\n\n    # 3. Avoid bins that are ALMOST full after adding the item (Leave enough room for future smaller items):\n    nearly_full = (waste > 0) & (waste < 0.1 * bins_remain_cap) # Bins with waste less than 10% of bin capacity\n    priorities[nearly_full] -= 10  # Penalize nearly full bins\n\n    # 4. Boost bins with nearly the same size remaining capacity as the item\n    same_size = np.isclose(bins_remain_cap, item)\n    priorities[same_size] += 20\n\n    # 5. Consider the amount of remaining capacity as a tie-breaker\n    priorities[valid_bins] += 0.01 * bins_remain_cap[valid_bins]  # Higher remaining capacity, slightly higher priority (as a tie-breaker)\n\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (2nd), we see that they are identical. Comparing (1st) vs (11th), the 1st uses fill ratio after placing the item and a bonus for partially filled bins, while the 11th minimizes waste, encourages filling bins, avoids almost full bins, boosts bins with similar remaining capacity, and considers remaining capacity as a tie-breaker. Comparing (2nd worst) vs (worst), we see that they are identical. Comparing (3rd) vs (4th), the 3rd prioritizes based on wasted space and fill ratio if the item is added with division by zero protection, while the 4th gives high priority to bins that can fit, adjusts priorities based on remaining capacity ratio, and bonuses almost full bins. Comparing (second best) vs (second worst), they are identical. Comparing (1st) vs (3rd), the first uses fill ratio after placing item while the 3rd uses wasted space.\nOverall: The better heuristics utilize a fill-ratio based approach calculated *after* placing the item, combined with bonuses for already-partially-filled bins to avoid starting new bins. They also include a tie-breaker based on minimizing remaining capacity. The worse heuristics either overly penalize infeasible bins or combine too many different factors without clear weighting. Some heuristics also fail to normalize or scale certain components appropriately. Also, remember to consider edge cases (e.g. division by zero).\n- \nOkay, I'm ready to help you redefine 'Current self-reflection' to design better heuristics! Let's aim for a more effective and insightful approach.\n\nHere's a redefined 'Current self-reflection' focusing on actionable improvements:\n\n*   **Keywords:** Goal-oriented, iterative, adaptable, trade-offs, evaluation metrics, systematic exploration, assumptions, validation.\n*   **Advice:** Define clear, measurable goals *before* designing. Iteratively test and refine heuristics based on performance data. Document assumptions and limitations. Actively explore diverse heuristic structures.\n*   **Avoid:** Premature optimization, rigid adherence to initial designs, neglecting edge cases, relying solely on intuition without validation.\n*   **Explanation:** Emphasize a goal-driven, iterative design process with systematic exploration of different heuristic structures. Avoid getting stuck in initial designs by continuously validating and adapting based on concrete performance metrics. Consider and document the limitations in advance.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}