{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n                  exponent_factor: float = 7.680950338860305, \n                  nearly_full_threshold: float = 0.0864257844914425, \n                  nearly_full_bonus: float = 0.38195499308734604) -> np.ndarray:\n    \"\"\"Prioritizes bins based on fill ratio, remaining capacity, and nearly full bonus.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    infeasible = item > bins_remain_cap\n    priorities[infeasible] = -np.inf\n    feasible = item <= bins_remain_cap\n\n    if np.any(feasible):\n        fill_ratio = item / bins_remain_cap[feasible]\n        remaining_capacity = bins_remain_cap[feasible] - item\n        max_cap = np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else 1\n        normalized_remaining = remaining_capacity / max_cap\n        priorities[feasible] = fill_ratio * np.exp(-exponent_factor * normalized_remaining)\n\n        waste = bins_remain_cap[feasible] - item\n        nearly_full = (waste > 0) & (waste < nearly_full_threshold * bins_remain_cap[feasible])\n        priorities[feasible][nearly_full] += nearly_full_bonus\n    else:\n        priorities = -np.arange(len(bins_remain_cap))\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Prioritizes bins based on fill ratio and remaining capacity,\n    with bonus for nearly full bins and fallback strategy.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    infeasible = item > bins_remain_cap\n    priorities[infeasible] = -np.inf\n\n    feasible = item <= bins_remain_cap\n    if np.any(feasible):\n        remaining_capacity = bins_remain_cap[feasible]\n        fill_ratios = (bins_remain_cap[feasible] - item) / bins_remain_cap[feasible]\n        scale = np.max(bins_remain_cap)\n        \n        if scale > 0:\n            priorities[feasible] = fill_ratios * np.exp(-5 * remaining_capacity / scale)\n        else:\n            priorities[feasible] = fill_ratios\n\n        waste = bins_remain_cap - item\n        nearly_full = feasible & (waste > 0) & (waste < 0.1 * bins_remain_cap)\n        priorities[nearly_full] += 0.5\n    else:\n        priorities = -bins_remain_cap\n\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see that the best heuristic prioritizes tighter fits using a reciprocal of remaining capacity, while the worst uses fill ratio combined with exponential decay of normalized remaining capacity and a bonus for nearly full bins. Also the best heuristic prioritizes the emptiest bin with random noise when no bins are feasible. The worst heuristic prioritizes the bins with the largest remaining capacity when no bins are feasible.\n\nComparing (2nd) vs (19th), the second-best heuristic uses a weighted combination of normalized fill ratio and exponential decay of remaining capacity, whereas the 19th employs fill ratio with exponential decay of normalized remaining capacity and a bonus for nearly full bins. The second-best uses negative remaining capacity for infeasible bins, the 19th uses the bins remaining capacities.\n\nComparing (1st) vs (2nd), the first uses reciprocal of remaining capacity, boosting partially full bins, and noise on infeasible bins whereas the second uses normalized fill ratio and remaining capacity with exponential decay, and negative remaining capacity if infeasible.\n\nComparing (3rd) vs (4th), the 3rd prioritizes fill ratio and exponential decay with a small bonus for nearly full bins, and negative index for infeasible bins whereas the 4th prioritizes fill ratio with exponential decay having tunnable factor, nearly full bonus, and negative index if infeasible. The 3rd normalizes remaining capacity by dividing it by max capacity and setting it to 0 if max capacity is 0. The 4th does the same.\n\nComparing (second worst) vs (worst), we observe that both prioritize fill ratio and remaining capacity with exponential decay and a near-full bonus, the difference is that the second-worse one prioritizes bins with the largest remaining capacity for infeasible, and the worst prioritizes bins by their remaining capacities directly.\n\nOverall: The best heuristics seem to focus on directly optimizing for tight fits and efficient use of partially filled bins, even using reciprocal of remaining capacity. They incorporate mechanisms to handle infeasibility gracefully, often by prioritizing opening new bins when necessary. The worst heuristics tend to rely on a combination of fill ratio, exponential decay, and near-full bonuses, which may not always lead to the most efficient packing. Normalizing the remaining capacity seems useful.\n- \nOkay, I'll help you redefine \"Current self-reflection\" to design better bin-packing heuristics, avoiding the pitfalls of \"Ineffective self-reflection.\" Here's a revised approach:\n\n*   **Keywords:** Feasibility, Bin Initialization, Remaining Capacity, Priority Function, Edge Cases, Normalization, Exploration.\n\n*   **Advice:** Rigorously test priority functions on varied datasets. Emphasize graceful infeasibility handling to encourage exploration, and efficient bin initialization strategies.\n\n*   **Avoid:** Unjustified complexity in priority calculations. Premature scaling without experimentation. Over-reliance on bonuses without clear understanding of their impact. Blindly normalizing without empirical justification.\n\n*   **Explanation:** Focus on designing priority functions based on sound mathematical principles and extensive experimentation. Understand the interplay between feasibility constraints, exploration mechanisms, and the overall heuristic's performance.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}