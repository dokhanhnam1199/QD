{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, tight_fit_weight: float = 1.2365786483982943, fill_ratio_weight: float = 0.10565709595754275, small_number: float = 0.0011336374255713267, random_priority_scale: float = 1.9364104631291854e-05) -> np.ndarray:\n    \"\"\"Prioritizes bins based on tight-fit and fill ratio.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    infeasible = item > bins_remain_cap\n    priorities[infeasible] = -np.inf\n    feasible = ~infeasible\n    if np.any(feasible):\n        remaining_capacity = bins_remain_cap[feasible]\n        fill_ratio = (bins_remain_cap[feasible] - item) / remaining_capacity\n        priorities[feasible] = (tight_fit_weight / (remaining_capacity - item + small_number)) + fill_ratio * fill_ratio_weight\n    else:\n        priorities = bins_remain_cap + np.random.rand(len(bins_remain_cap)) * random_priority_scale\n    return priorities\n\n[Heuristics 2nd]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, tight_fit_weight: float = 1.2365786483982943, fill_ratio_weight: float = 0.10565709595754275, small_number: float = 0.0011336374255713267, random_priority_scale: float = 1.9364104631291854e-05) -> np.ndarray:\n    \"\"\"Prioritizes bins based on tight-fit and fill ratio.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    infeasible = item > bins_remain_cap\n    priorities[infeasible] = -np.inf\n    feasible = ~infeasible\n    if np.any(feasible):\n        remaining_capacity = bins_remain_cap[feasible]\n        fill_ratio = (bins_remain_cap[feasible] - item) / remaining_capacity\n        priorities[feasible] = (tight_fit_weight / (remaining_capacity - item + small_number)) + fill_ratio * fill_ratio_weight\n    else:\n        priorities = bins_remain_cap + np.random.rand(len(bins_remain_cap)) * random_priority_scale\n    return priorities\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes tight fits using reciprocal remain capacity,\n    fill ratio, and handles infeasibility.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    infeasible = item > bins_remain_cap\n    priorities[infeasible] = -np.inf\n\n    feasible = ~infeasible\n    if np.any(feasible):\n        remaining_capacity = bins_remain_cap[feasible]\n        fill_ratio = (bins_remain_cap[feasible] - item) / bins_remain_cap[feasible]\n        priorities[feasible] = (1.0 / (remaining_capacity - item + 0.001)) + fill_ratio * 0.1\n\n    else:\n        priorities = bins_remain_cap + np.random.rand(len(bins_remain_cap)) * 0.0001\n    return priorities\n\n[Heuristics 4th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on tight-fit and fill ratio.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    infeasible = item > bins_remain_cap\n    priorities[infeasible] = -np.inf\n    feasible = ~infeasible\n    if np.any(feasible):\n        remaining_capacity = bins_remain_cap[feasible]\n        fill_ratio = (bins_remain_cap[feasible] - item) / remaining_capacity\n        priorities[feasible] = (1.0 / (remaining_capacity - item + 0.001)) + fill_ratio * 0.1\n    else:\n        priorities = bins_remain_cap + np.random.rand(len(bins_remain_cap)) * 0.0001\n    return priorities\n\n[Heuristics 5th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on tight-fit and fill ratio.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    infeasible = item > bins_remain_cap\n    priorities[infeasible] = -np.inf\n    feasible = ~infeasible\n    if np.any(feasible):\n        remaining_capacity = bins_remain_cap[feasible]\n        fill_ratio = (bins_remain_cap[feasible] - item) / remaining_capacity\n        priorities[feasible] = (1.0 / (remaining_capacity - item + 0.001)) + fill_ratio * 0.1\n    else:\n        priorities = bins_remain_cap + np.random.rand(len(bins_remain_cap)) * 0.0001\n    return priorities\n\n[Heuristics 6th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins: tight fit, fill ratio. Infeasible bins get -inf.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    infeasible = item > bins_remain_cap\n    priorities[infeasible] = -np.inf\n\n    feasible = ~infeasible\n    if np.any(feasible):\n        remaining_capacity = bins_remain_cap[feasible]\n        fit_priority = 1.0 / (remaining_capacity - item + 0.0001)\n        fill_ratio = item / (bins_remain_cap[feasible] + 0.0001)\n        priorities[feasible] = 0.7 * fit_priority + 0.3 * fill_ratio\n    else:\n        priorities = bins_remain_cap + np.random.rand(len(bins_remain_cap)) * 0.0001\n\n    return priorities\n\n[Heuristics 7th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on tight-fit and fill ratio.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    infeasible = item > bins_remain_cap\n    priorities[infeasible] = -np.inf\n\n    feasible = ~infeasible\n    if np.any(feasible):\n        remaining_capacity = bins_remain_cap[feasible]\n        tight_fit = 1.0 / (remaining_capacity - item + 0.0001)\n        fill_ratio = item / (bins_remain_cap[feasible] + 0.0001)\n        priorities[feasible] = 0.7 * tight_fit + 0.3 * fill_ratio\n\n    return priorities\n\n[Heuristics 8th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes tight fit and fill ratio.\n    Penalizes infeasible bins. Adds small noise when no bin fits.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    infeasible = item > bins_remain_cap\n    priorities[infeasible] = -np.inf\n\n    feasible = ~infeasible\n    if np.any(feasible):\n        remaining_capacity = bins_remain_cap[feasible]\n        fit_priority = 1.0 / (remaining_capacity - item + 0.0001)\n        fill_ratio = item / bins_remain_cap[feasible]\n        priorities[feasible] = 0.7 * fit_priority + 0.3 * fill_ratio\n    else:\n        priorities = bins_remain_cap + np.random.rand(len(bins_remain_cap)) * 0.0001\n\n    return priorities\n\n[Heuristics 9th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Refined heuristic: Normalized tighter fit with fill ratio and a small exploration factor.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    infeasible = item > bins_remain_cap\n    priorities[infeasible] = -np.inf\n\n    feasible = ~infeasible\n    if np.any(feasible):\n        remaining_capacity = bins_remain_cap[feasible]\n        fit = remaining_capacity - item\n        # Normalize fit: smaller is better, but avoid division by zero\n        normalized_fit = 1.0 / (fit / np.max(bins_remain_cap) + 0.001)\n\n        # Fill ratio: how full the bin will be\n        fill_ratio = (bins_remain_cap[feasible] - item) / bins_remain_cap[feasible]\n\n        # Combine normalized fit and fill ratio with weights\n        priorities[feasible] = normalized_fit * 0.7 + fill_ratio * 0.3\n\n        # Add a small exploration factor (to potentially find better solutions later)\n        priorities[feasible] += np.random.rand(len(remaining_capacity)) * 0.01\n    else:\n        # If no feasible bins, add a small random priority to all infeasible bins\n        priorities = bins_remain_cap + np.random.rand(len(bins_remain_cap)) * 0.0001\n\n    return priorities\n\n[Heuristics 10th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes tight fits and fill ratio for online bin packing.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    infeasible = item > bins_remain_cap\n    priorities[infeasible] = -np.inf\n\n    feasible = ~infeasible\n    if np.any(feasible):\n        remaining_capacity = bins_remain_cap[feasible]\n        fill_ratio = (item) / (bins_remain_cap[feasible] + 0.0001)\n        fit_priority = 1.0 / (remaining_capacity - item + 0.0001)\n\n        priorities[feasible] = 0.7 * fit_priority + 0.3 * fill_ratio\n    else:\n        priorities = bins_remain_cap + np.random.rand(len(bins_remain_cap)) * 0.0001\n\n    return priorities\n\n[Heuristics 11th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines tight-fit and fill ratio with controlled exploration and infeasibility handling.\n    Prioritizes tighter fits and higher fill ratios, and explores new bins.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Handle infeasible bins.\n    infeasible = item > bins_remain_cap\n    priorities[infeasible] = -np.inf\n\n    feasible = ~infeasible\n    if np.any(feasible):\n        remaining_capacity = bins_remain_cap[feasible]\n\n        # Tight-fit component: Reciprocal of remaining capacity\n        fit_ratio = (remaining_capacity - item + 0.001)\n        tight_fit = 1.0 / fit_ratio\n\n        # Fill ratio component: How full the bin would be\n        fill_ratio = (bins_remain_cap[feasible] - item) / bins_remain_cap[feasible]\n\n        # Combine components.\n        priorities[feasible] = tight_fit + 0.2 * fill_ratio\n\n        #Exploration: Add noise with small probability\n        exploration_prob = 0.001\n        if np.random.rand() < exploration_prob:\n            priorities[feasible] += np.random.rand(np.sum(feasible)) * 0.001\n    else:\n        # Prioritize bins with more capacity if no feasible bin.\n        priorities = bins_remain_cap + np.random.rand(len(bins_remain_cap)) * 0.0001\n\n    return priorities\n\n[Heuristics 12th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines tight-fit and fill ratio with controlled exploration and infeasibility handling.\n    Prioritizes tighter fits and higher fill ratios, and explores new bins.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Handle infeasible bins.\n    infeasible = item > bins_remain_cap\n    priorities[infeasible] = -np.inf\n\n    feasible = ~infeasible\n    if np.any(feasible):\n        remaining_capacity = bins_remain_cap[feasible]\n\n        # Tight-fit component: Reciprocal of remaining capacity\n        fit_ratio = (remaining_capacity - item + 0.001)\n        tight_fit = 1.0 / fit_ratio\n\n        # Fill ratio component: How full the bin would be\n        fill_ratio = (bins_remain_cap[feasible] - item) / bins_remain_cap[feasible]\n\n        # Combine components.\n        priorities[feasible] = tight_fit + 0.2 * fill_ratio\n\n        #Exploration: Add noise with small probability\n        exploration_prob = 0.001\n        if np.random.rand() < exploration_prob:\n            priorities[feasible] += np.random.rand(np.sum(feasible)) * 0.001\n    else:\n        # Prioritize bins with more capacity if no feasible bin.\n        priorities = bins_remain_cap + np.random.rand(len(bins_remain_cap)) * 0.0001\n\n    return priorities\n\n[Heuristics 13th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines tight-fit and fill ratio with controlled exploration and infeasibility handling.\n    Prioritizes tighter fits and higher fill ratios, and explores new bins.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Handle infeasible bins.\n    infeasible = item > bins_remain_cap\n    priorities[infeasible] = -np.inf\n\n    feasible = ~infeasible\n    if np.any(feasible):\n        remaining_capacity = bins_remain_cap[feasible]\n\n        # Tight-fit component: Reciprocal of remaining capacity\n        fit_ratio = (remaining_capacity - item + 0.001)\n        tight_fit = 1.0 / fit_ratio\n\n        # Fill ratio component: How full the bin would be\n        fill_ratio = (bins_remain_cap[feasible] - item) / bins_remain_cap[feasible]\n\n        # Combine components.\n        priorities[feasible] = tight_fit + 0.2 * fill_ratio\n\n        #Exploration: Add noise with small probability\n        exploration_prob = 0.001\n        if np.random.rand() < exploration_prob:\n            priorities[feasible] += np.random.rand(np.sum(feasible)) * 0.001\n    else:\n        # Prioritize bins with more capacity if no feasible bin.\n        priorities = bins_remain_cap + np.random.rand(len(bins_remain_cap)) * 0.0001\n\n    return priorities\n\n[Heuristics 14th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes tight fits, fill ratio, with controlled exploration.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    infeasible = item > bins_remain_cap\n    priorities[infeasible] = -np.inf\n\n    feasible = ~infeasible\n    if np.any(feasible):\n        remaining_capacity = bins_remain_cap[feasible]\n        fit_priority = 1.0 / (remaining_capacity - item + 0.0001)\n        fill_ratio = (bins_remain_cap[feasible] - item) / (bins_remain_cap[feasible] + 0.0001)\n        priorities[feasible] = 0.7 * fit_priority + 0.3 * fill_ratio\n    else:\n        priorities = bins_remain_cap + np.random.rand(len(bins_remain_cap)) * 0.0001\n\n    return priorities\n\n[Heuristics 15th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Enhanced heuristic: Combines normalized remaining capacity, a tighter-fit reciprocal,\n    and fill-ratio consideration with exploration.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Mark infeasible bins with negative infinity\n    infeasible = item > bins_remain_cap\n    priorities[infeasible] = -np.inf\n\n    feasible = ~infeasible\n    if np.any(feasible):\n        remaining_capacity = bins_remain_cap[feasible]\n\n        # 1. Normalized Remaining Capacity: Prioritize bins with more space generally\n        normalized_capacity = remaining_capacity / np.max(bins_remain_cap)\n\n        # 2. Tighter-Fit Reciprocal: Favors bins where the item fits snugly (but not too tightly)\n        fit_difference = remaining_capacity - item\n        tight_fit = 1.0 / (fit_difference + 0.001)  # Prevent division by zero\n\n        # 3. Fill Ratio: Encourages efficient use of bin space\n        fill_ratio = (bins_remain_cap[feasible] - item) / bins_remain_cap[feasible]\n\n        # 4. Weighted Combination: Combine the factors\n        capacity_weight = 0.2\n        fit_weight = 0.6\n        fill_weight = 0.2\n\n        priorities[feasible] = (\n            capacity_weight * normalized_capacity\n            + fit_weight * tight_fit\n            + fill_weight * fill_ratio\n        )\n\n        # 5. Controlled Exploration: Add a small amount of noise to break ties\n        exploration_factor = 0.01\n        priorities[feasible] += np.random.rand(np.sum(feasible)) * exploration_factor\n\n    else:\n        # All bins are infeasible. Add some random noise to decide which one opens new bin\n         priorities = bins_remain_cap + np.random.rand(len(bins_remain_cap)) * 0.0001\n\n\n    return priorities\n\n[Heuristics 16th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Enhanced heuristic: Combines normalized remaining capacity, a tighter-fit reciprocal,\n    and fill-ratio consideration with exploration.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Mark infeasible bins with negative infinity\n    infeasible = item > bins_remain_cap\n    priorities[infeasible] = -np.inf\n\n    feasible = ~infeasible\n    if np.any(feasible):\n        remaining_capacity = bins_remain_cap[feasible]\n\n        # 1. Normalized Remaining Capacity: Prioritize bins with more space generally\n        normalized_capacity = remaining_capacity / np.max(bins_remain_cap)\n\n        # 2. Tighter-Fit Reciprocal: Favors bins where the item fits snugly (but not too tightly)\n        fit_difference = remaining_capacity - item\n        tight_fit = 1.0 / (fit_difference + 0.001)  # Prevent division by zero\n\n        # 3. Fill Ratio: Encourages efficient use of bin space\n        fill_ratio = (bins_remain_cap[feasible] - item) / bins_remain_cap[feasible]\n\n        # 4. Weighted Combination: Combine the factors\n        capacity_weight = 0.2\n        fit_weight = 0.6\n        fill_weight = 0.2\n\n        priorities[feasible] = (\n            capacity_weight * normalized_capacity\n            + fit_weight * tight_fit\n            + fill_weight * fill_ratio\n        )\n\n        # 5. Controlled Exploration: Add a small amount of noise to break ties\n        exploration_factor = 0.01\n        priorities[feasible] += np.random.rand(np.sum(feasible)) * exploration_factor\n\n    else:\n        # All bins are infeasible. Add some random noise to decide which one opens new bin\n         priorities = bins_remain_cap + np.random.rand(len(bins_remain_cap)) * 0.0001\n\n\n    return priorities\n\n[Heuristics 17th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Enhanced heuristic: Combines normalized remaining capacity, a tighter-fit reciprocal,\n    and fill-ratio consideration with exploration.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Mark infeasible bins with negative infinity\n    infeasible = item > bins_remain_cap\n    priorities[infeasible] = -np.inf\n\n    feasible = ~infeasible\n    if np.any(feasible):\n        remaining_capacity = bins_remain_cap[feasible]\n\n        # 1. Normalized Remaining Capacity: Prioritize bins with more space generally\n        normalized_capacity = remaining_capacity / np.max(bins_remain_cap)\n\n        # 2. Tighter-Fit Reciprocal: Favors bins where the item fits snugly (but not too tightly)\n        fit_difference = remaining_capacity - item\n        tight_fit = 1.0 / (fit_difference + 0.001)  # Prevent division by zero\n\n        # 3. Fill Ratio: Encourages efficient use of bin space\n        fill_ratio = (bins_remain_cap[feasible] - item) / bins_remain_cap[feasible]\n\n        # 4. Weighted Combination: Combine the factors\n        capacity_weight = 0.2\n        fit_weight = 0.6\n        fill_weight = 0.2\n\n        priorities[feasible] = (\n            capacity_weight * normalized_capacity\n            + fit_weight * tight_fit\n            + fill_weight * fill_ratio\n        )\n\n        # 5. Controlled Exploration: Add a small amount of noise to break ties\n        exploration_factor = 0.01\n        priorities[feasible] += np.random.rand(np.sum(feasible)) * exploration_factor\n\n    else:\n        # All bins are infeasible. Add some random noise to decide which one opens new bin\n         priorities = bins_remain_cap + np.random.rand(len(bins_remain_cap)) * 0.0001\n\n\n    return priorities\n\n[Heuristics 18th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Enhanced heuristic: Combines normalized remaining capacity, fill ratio,\n    and a controlled exploration factor. Addresses edge cases explicitly.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Mark infeasible bins with a very low priority\n    infeasible = item > bins_remain_cap\n    priorities[infeasible] = -np.inf\n\n    # Calculate priorities for feasible bins\n    feasible = ~infeasible\n    if np.any(feasible):\n        remaining_capacity = bins_remain_cap[feasible]\n\n        # Normalize remaining capacity to [0, 1]\n        normalized_capacity = remaining_capacity / np.max(bins_remain_cap)\n        \n        # Fill ratio calculation\n        fill_ratio = (remaining_capacity - item) / remaining_capacity\n        fill_ratio = np.clip(fill_ratio, 0, 1)  # Ensure fill_ratio is within [0, 1]\n\n        # Core priority calculation: Normalized capacity + Fill Ratio + Exploration\n        priorities[feasible] = normalized_capacity + fill_ratio * 0.5 + np.random.rand(np.sum(feasible)) * 0.01\n    else:\n        # If no feasible bin, explore with a small random value\n        priorities = bins_remain_cap + np.random.rand(len(bins_remain_cap)) * 0.0001\n    \n\n    return priorities\n\n[Heuristics 19th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Enhanced heuristic: Combines normalized remaining capacity, fill ratio,\n    and a controlled exploration factor. Addresses edge cases explicitly.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Mark infeasible bins with a very low priority\n    infeasible = item > bins_remain_cap\n    priorities[infeasible] = -np.inf\n\n    # Calculate priorities for feasible bins\n    feasible = ~infeasible\n    if np.any(feasible):\n        remaining_capacity = bins_remain_cap[feasible]\n\n        # Normalize remaining capacity to [0, 1]\n        normalized_capacity = remaining_capacity / np.max(bins_remain_cap)\n        \n        # Fill ratio calculation\n        fill_ratio = (remaining_capacity - item) / remaining_capacity\n        fill_ratio = np.clip(fill_ratio, 0, 1)  # Ensure fill_ratio is within [0, 1]\n\n        # Core priority calculation: Normalized capacity + Fill Ratio + Exploration\n        priorities[feasible] = normalized_capacity + fill_ratio * 0.5 + np.random.rand(np.sum(feasible)) * 0.01\n    else:\n        # If no feasible bin, explore with a small random value\n        priorities = bins_remain_cap + np.random.rand(len(bins_remain_cap)) * 0.0001\n    \n\n    return priorities\n\n[Heuristics 20th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Enhanced heuristic: Combines normalized remaining capacity, fill ratio,\n    and a controlled exploration factor. Addresses edge cases explicitly.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Mark infeasible bins with a very low priority\n    infeasible = item > bins_remain_cap\n    priorities[infeasible] = -np.inf\n\n    # Calculate priorities for feasible bins\n    feasible = ~infeasible\n    if np.any(feasible):\n        remaining_capacity = bins_remain_cap[feasible]\n\n        # Normalize remaining capacity to [0, 1]\n        normalized_capacity = remaining_capacity / np.max(bins_remain_cap)\n        \n        # Fill ratio calculation\n        fill_ratio = (remaining_capacity - item) / remaining_capacity\n        fill_ratio = np.clip(fill_ratio, 0, 1)  # Ensure fill_ratio is within [0, 1]\n\n        # Core priority calculation: Normalized capacity + Fill Ratio + Exploration\n        priorities[feasible] = normalized_capacity + fill_ratio * 0.5 + np.random.rand(np.sum(feasible)) * 0.01\n    else:\n        # If no feasible bin, explore with a small random value\n        priorities = bins_remain_cap + np.random.rand(len(bins_remain_cap)) * 0.0001\n    \n\n    return priorities\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}