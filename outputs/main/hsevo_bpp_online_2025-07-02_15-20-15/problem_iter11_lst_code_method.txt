{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on normalized fill ratio and remaining capacity.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Infeasible bins get negative infinity priority\n    infeasible = item > bins_remain_cap\n    priorities[infeasible] = -np.inf\n\n    # Calculate fill ratio and normalized remaining capacity for feasible bins\n    feasible = item <= bins_remain_cap\n    if np.any(feasible):\n        fill_ratio = item / bins_remain_cap[feasible]\n        remaining_capacity = bins_remain_cap[feasible] - item\n        max_cap = np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else 1 # Avoid division by zero\n        normalized_remaining = remaining_capacity / max_cap\n        priorities[feasible] = fill_ratio * np.exp(-5 * normalized_remaining)\n\n        # Bonus for nearly full bins\n        waste = bins_remain_cap[feasible] - item\n        nearly_full = (waste > 0) & (waste < 0.1 * bins_remain_cap[feasible])\n        priorities[feasible][nearly_full] += 0.2 # Reduced bonus\n\n    # Handle the edge case where no bin is feasible.\n    elif not np.any(feasible):\n         priorities = -np.arange(len(bins_remain_cap)) # use bin index\n\n    return priorities\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins considering feasibility, fill ratio, and remaining capacity.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Invalidate infeasible bins\n    infeasible = item > bins_remain_cap\n    priorities[infeasible] = -np.inf\n\n    # Prioritize feasible bins\n    feasible = item <= bins_remain_cap\n    if np.any(feasible):\n        remaining_capacity_after_placement = bins_remain_cap[feasible] - item\n        \n        # Exponential decay based on normalized remaining capacity and fill ratio\n        max_cap = np.max(bins_remain_cap)\n        if max_cap > 0:\n            fill_ratios = item / bins_remain_cap[feasible]\n            priorities[feasible] = fill_ratios * np.exp(-5 * remaining_capacity_after_placement / max_cap)\n        else:\n            priorities[feasible] = 1.0\n            \n        #Bonus for nearly full bins\n        waste = bins_remain_cap[feasible] - item\n        nearly_full = (waste > 0) & (waste < 0.1 * bins_remain_cap[feasible])\n        priorities[feasible][nearly_full] += 0.25\n\n    else:\n        # All bins are infeasible\n        priorities = -np.arange(len(bins_remain_cap))\n\n    return priorities\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins by fill ratio & exponential decay of normalized remaining capacity.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Infeasible bins get -inf priority\n    infeasible = item > bins_remain_cap\n    priorities[infeasible] = -np.inf\n\n    feasible = ~infeasible\n    if np.any(feasible):\n        remaining_capacity = bins_remain_cap[feasible] - item\n        \n        # Exponential decay based on normalized remaining capacity\n        max_capacity = np.max(bins_remain_cap)\n        normalized_remaining_capacity = remaining_capacity / max_capacity if max_capacity > 0 else 0\n        priorities[feasible] = (item / bins_remain_cap[feasible]) * np.exp(-5 * normalized_remaining_capacity) #Fill ratio * exponential decay\n\n        # Small bonus for almost full bins\n        near_full_mask = (remaining_capacity > 0) & (remaining_capacity < 0.1 * max_capacity)\n        priorities[feasible][near_full_mask] += 0.1\n    \n    return priorities\n\n[Heuristics 4th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Infeasible bins get a very low priority\n    infeasible = item > bins_remain_cap\n    priorities[infeasible] = -np.inf\n\n    feasible = item <= bins_remain_cap\n\n    if np.any(feasible):\n        # Calculate the fill ratio if the item were placed in the bin.\n        remaining_capacity_after_placement = bins_remain_cap[feasible] - item\n        fill_ratio = (bins_remain_cap[feasible] - remaining_capacity_after_placement) / bins_remain_cap[feasible]\n\n        # Normalize the remaining capacity and fill ratio.\n        normalized_remaining_capacity = remaining_capacity_after_placement / np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else np.zeros_like(remaining_capacity_after_placement)\n        normalized_fill_ratio = fill_ratio\n\n        # Combine normalized fill ratio and remaining capacity to create the priority.\n        # Experiment with the weights to fine-tune the performance.\n        priorities[feasible] = 0.7 * normalized_fill_ratio + 0.3 * np.exp(-5 * normalized_remaining_capacity)\n\n    else:\n        # If no feasible bins, prioritize based on bins with smallest remaining cap\n        # Encourages creation of new bins only when necessary\n        priorities = -bins_remain_cap\n\n    return priorities\n\n[Heuristics 5th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Infeasible bins get a very low priority\n    infeasible = item > bins_remain_cap\n    priorities[infeasible] = -np.inf\n\n    feasible = item <= bins_remain_cap\n\n    if np.any(feasible):\n        # Calculate the fill ratio if the item were placed in the bin.\n        remaining_capacity_after_placement = bins_remain_cap[feasible] - item\n        fill_ratio = (bins_remain_cap[feasible] - remaining_capacity_after_placement) / bins_remain_cap[feasible]\n\n        # Normalize the remaining capacity and fill ratio.\n        normalized_remaining_capacity = remaining_capacity_after_placement / np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else np.zeros_like(remaining_capacity_after_placement)\n        normalized_fill_ratio = fill_ratio\n\n        # Combine normalized fill ratio and remaining capacity to create the priority.\n        # Experiment with the weights to fine-tune the performance.\n        priorities[feasible] = 0.7 * normalized_fill_ratio + 0.3 * np.exp(-5 * normalized_remaining_capacity)\n\n    else:\n        # If no feasible bins, prioritize based on bins with smallest remaining cap\n        # Encourages creation of new bins only when necessary\n        priorities = -bins_remain_cap\n\n    return priorities\n\n[Heuristics 6th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins considering feasibility, fill ratio, and remaining capacity.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Invalidate infeasible bins\n    infeasible = item > bins_remain_cap\n    priorities[infeasible] = -np.inf\n\n    # Prioritize feasible bins\n    feasible = item <= bins_remain_cap\n    if np.any(feasible):\n        remaining_capacity_after_placement = bins_remain_cap[feasible] - item\n        \n        # Exponential decay based on normalized remaining capacity and fill ratio\n        max_cap = np.max(bins_remain_cap)\n        if max_cap > 0:\n            fill_ratios = item / bins_remain_cap[feasible]\n            priorities[feasible] = fill_ratios * np.exp(-5 * remaining_capacity_after_placement / max_cap)\n        else:\n            priorities[feasible] = 1.0\n            \n        #Bonus for nearly full bins\n        waste = bins_remain_cap[feasible] - item\n        nearly_full = (waste > 0) & (waste < 0.1 * bins_remain_cap[feasible])\n        priorities[feasible][nearly_full] += 0.25\n\n    else:\n        # All bins are infeasible\n        priorities = -np.arange(len(bins_remain_cap))\n\n    return priorities\n\n[Heuristics 7th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on fill ratio and normalized remaining capacity.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    infeasible = item > bins_remain_cap\n    priorities[infeasible] = -np.inf  # Mark infeasible bins\n\n    feasible = item <= bins_remain_cap\n    if np.any(feasible):\n        remaining_capacity_after_placement = bins_remain_cap[feasible] - item\n        fill_ratio = item / bins_remain_cap[feasible]\n        max_cap = np.max(bins_remain_cap)\n        priorities[feasible] = fill_ratio * np.exp(-remaining_capacity_after_placement / (max_cap if max_cap > 0 else 1))\n\n        # Bonus for nearly full bins\n        nearly_full = (remaining_capacity_after_placement > 0) & (remaining_capacity_after_placement <= 0.1 * max_cap if max_cap > 0 else 1)\n        priorities[feasible][nearly_full] += 0.5\n\n    return priorities\n\n[Heuristics 8th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins by fill ratio and normalized remaining capacity.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Infeasible bins get -inf priority\n    infeasible = item > bins_remain_cap\n    priorities[infeasible] = -np.inf\n\n    feasible = ~infeasible\n    if np.any(feasible):\n        remaining_capacity = bins_remain_cap[feasible]\n        fill_ratio = item / bins_remain_cap[feasible]\n\n        # Exponential decay based on normalized remaining capacity.\n        max_capacity = np.max(bins_remain_cap)\n        normalized_remaining_capacity = remaining_capacity / max_capacity if max_capacity > 0 else 0\n        priorities[feasible] = fill_ratio * np.exp(-5 * normalized_remaining_capacity)\n\n        # Bonus for nearly full bins.\n        waste = bins_remain_cap[feasible] - item\n        near_full_mask = (waste > 0) & (waste < 0.1 * max_capacity)\n        priorities[feasible][near_full_mask] += 0.1\n\n    return priorities\n\n[Heuristics 9th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins by fill ratio & exponential decay of normalized remaining capacity.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Infeasible bins get -inf priority\n    infeasible = item > bins_remain_cap\n    priorities[infeasible] = -np.inf\n\n    feasible = ~infeasible\n    if np.any(feasible):\n        remaining_capacity = bins_remain_cap[feasible] - item\n        \n        # Exponential decay based on normalized remaining capacity\n        max_capacity = np.max(bins_remain_cap)\n        normalized_remaining_capacity = remaining_capacity / max_capacity if max_capacity > 0 else 0\n        priorities[feasible] = (item / bins_remain_cap[feasible]) * np.exp(-5 * normalized_remaining_capacity) #Fill ratio * exponential decay\n\n        # Small bonus for almost full bins\n        near_full_mask = (remaining_capacity > 0) & (remaining_capacity < 0.1 * max_capacity)\n        priorities[feasible][near_full_mask] += 0.1\n    \n    return priorities\n\n[Heuristics 10th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins by fill ratio and normalized remaining capacity.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Infeasible bins get -inf priority\n    infeasible = item > bins_remain_cap\n    priorities[infeasible] = -np.inf\n\n    feasible = ~infeasible\n    if np.any(feasible):\n        remaining_capacity = bins_remain_cap[feasible]\n        fill_ratio = item / bins_remain_cap[feasible]\n\n        # Exponential decay based on normalized remaining capacity.\n        max_capacity = np.max(bins_remain_cap)\n        normalized_remaining_capacity = remaining_capacity / max_capacity if max_capacity > 0 else 0\n        priorities[feasible] = fill_ratio * np.exp(-5 * normalized_remaining_capacity)\n\n        # Bonus for nearly full bins.\n        waste = bins_remain_cap[feasible] - item\n        near_full_mask = (waste > 0) & (waste < 0.1 * max_capacity)\n        priorities[feasible][near_full_mask] += 0.1\n\n    return priorities\n\n[Heuristics 11th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Infeasible bins get zero priority\n    infeasible = item > bins_remain_cap\n    priorities[infeasible] = -np.inf\n\n    feasible = item <= bins_remain_cap\n\n    if np.any(feasible):\n        # Calculate fill ratio after placing the item (normalized)\n        remaining_capacity_after_placement = bins_remain_cap[feasible] - item\n        fill_ratio = (bins_remain_cap[feasible] - remaining_capacity_after_placement) / np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else 0\n        #Prioritize bins with higher fill ratio.  Add a small amount to break ties.\n        priorities[feasible] = fill_ratio + 1e-6 * np.arange(np.sum(feasible))\n\n    else:\n        # If no feasible bins, add to the end of the current list of bins (create a new one)\n        priorities = -np.arange(len(bins_remain_cap))\n\n    return priorities\n\n[Heuristics 12th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on fill ratio, exp decay of remain cap, and normalization.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Infeasible bins get -inf priority.\n    infeasible = item > bins_remain_cap\n    priorities[infeasible] = -np.inf\n\n    # Calculate fill ratios and scaled remaining capacity for feasible bins.\n    feasible = item <= bins_remain_cap\n    if np.any(feasible):\n        remaining_capacity = bins_remain_cap[feasible]\n        fill_ratios = item / bins_remain_cap[feasible]\n        scale = np.max(bins_remain_cap)\n        \n        if scale > 0:\n            priorities[feasible] = fill_ratios * np.exp(-5 * remaining_capacity / scale)\n        else:\n            priorities[feasible] = fill_ratios # if all bins empty, prioritize based on fill ratio\n        # Bonus for nearly full bins\n        waste = bins_remain_cap - item\n        nearly_full = feasible & (waste > 0) & (waste < 0.1 * bins_remain_cap)\n        priorities[nearly_full] += 0.5\n\n    # Penalize earlier bins if no feasible bins\n    if not np.any(feasible):\n        priorities = -np.arange(len(bins_remain_cap)) / len(bins_remain_cap)\n\n    return priorities\n\n[Heuristics 13th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on fill ratio, exp decay of remain cap, and normalization.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Infeasible bins get -inf priority.\n    infeasible = item > bins_remain_cap\n    priorities[infeasible] = -np.inf\n\n    # Calculate fill ratios and scaled remaining capacity for feasible bins.\n    feasible = item <= bins_remain_cap\n    if np.any(feasible):\n        remaining_capacity = bins_remain_cap[feasible]\n        fill_ratios = item / bins_remain_cap[feasible]\n        scale = np.max(bins_remain_cap)\n        \n        if scale > 0:\n            priorities[feasible] = fill_ratios * np.exp(-5 * remaining_capacity / scale)\n        else:\n            priorities[feasible] = fill_ratios # if all bins empty, prioritize based on fill ratio\n        # Bonus for nearly full bins\n        waste = bins_remain_cap - item\n        nearly_full = feasible & (waste > 0) & (waste < 0.1 * bins_remain_cap)\n        priorities[nearly_full] += 0.5\n\n    # Penalize earlier bins if no feasible bins\n    if not np.any(feasible):\n        priorities = -np.arange(len(bins_remain_cap)) / len(bins_remain_cap)\n\n    return priorities\n\n[Heuristics 14th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Infeasible bins get zero priority\n    infeasible = item > bins_remain_cap\n    priorities[infeasible] = -np.inf\n\n    feasible = item <= bins_remain_cap\n\n    if np.any(feasible):\n        # Calculate fill ratio after placing the item (normalized)\n        remaining_capacity_after_placement = bins_remain_cap[feasible] - item\n        fill_ratio = (bins_remain_cap[feasible] - remaining_capacity_after_placement) / np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else 0\n        #Prioritize bins with higher fill ratio.  Add a small amount to break ties.\n        priorities[feasible] = fill_ratio + 1e-6 * np.arange(np.sum(feasible))\n\n    else:\n        # If no feasible bins, add to the end of the current list of bins (create a new one)\n        priorities = -np.arange(len(bins_remain_cap))\n\n    return priorities\n\n[Heuristics 15th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Infeasible bins get zero priority\n    infeasible = item > bins_remain_cap\n    priorities[infeasible] = -np.inf\n\n    feasible = item <= bins_remain_cap\n\n    if np.any(feasible):\n        # Calculate fill ratio after placing the item (normalized)\n        remaining_capacity_after_placement = bins_remain_cap[feasible] - item\n        fill_ratio = (bins_remain_cap[feasible] - remaining_capacity_after_placement) / np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else 0\n        #Prioritize bins with higher fill ratio.  Add a small amount to break ties.\n        priorities[feasible] = fill_ratio + 1e-6 * np.arange(np.sum(feasible))\n\n    else:\n        # If no feasible bins, add to the end of the current list of bins (create a new one)\n        priorities = -np.arange(len(bins_remain_cap))\n\n    return priorities\n\n[Heuristics 16th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Infeasible bins get zero priority\n    infeasible = item > bins_remain_cap\n    priorities[infeasible] = -np.inf\n\n    feasible = item <= bins_remain_cap\n\n    if np.any(feasible):\n        # Calculate fill ratio after placing the item (normalized)\n        remaining_capacity_after_placement = bins_remain_cap[feasible] - item\n        fill_ratio = (bins_remain_cap[feasible] - remaining_capacity_after_placement) / np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else 0\n        #Prioritize bins with higher fill ratio.  Add a small amount to break ties.\n        priorities[feasible] = fill_ratio + 1e-6 * np.arange(np.sum(feasible))\n\n    else:\n        # If no feasible bins, add to the end of the current list of bins (create a new one)\n        priorities = -np.arange(len(bins_remain_cap))\n\n    return priorities\n\n[Heuristics 17th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Infeasible bins get zero priority\n    infeasible = item > bins_remain_cap\n    priorities[infeasible] = -np.inf\n\n    feasible = item <= bins_remain_cap\n\n    if np.any(feasible):\n        # Calculate fill ratio after placing the item (normalized)\n        remaining_capacity_after_placement = bins_remain_cap[feasible] - item\n        fill_ratio = (bins_remain_cap[feasible] - remaining_capacity_after_placement) / np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else 0\n        #Prioritize bins with higher fill ratio.  Add a small amount to break ties.\n        priorities[feasible] = fill_ratio + 1e-6 * np.arange(np.sum(feasible))\n\n    else:\n        # If no feasible bins, add to the end of the current list of bins (create a new one)\n        priorities = -np.arange(len(bins_remain_cap))\n\n    return priorities\n\n[Heuristics 18th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Infeasible bins get zero priority\n    infeasible = item > bins_remain_cap\n    priorities[infeasible] = -np.inf\n\n    feasible = item <= bins_remain_cap\n\n    if np.any(feasible):\n        # Calculate fill ratio after placing the item (normalized)\n        remaining_capacity_after_placement = bins_remain_cap[feasible] - item\n        fill_ratio = (bins_remain_cap[feasible] - remaining_capacity_after_placement) / np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else 0\n        #Prioritize bins with higher fill ratio.  Add a small amount to break ties.\n        priorities[feasible] = fill_ratio + 1e-6 * np.arange(np.sum(feasible))\n\n    else:\n        # If no feasible bins, add to the end of the current list of bins (create a new one)\n        priorities = -np.arange(len(bins_remain_cap))\n\n    return priorities\n\n[Heuristics 19th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Feasibility check: Strongly penalize infeasible bins\n    infeasible = item > bins_remain_cap\n    priorities[infeasible] = -np.inf\n\n    # Handle feasible bins\n    feasible = ~infeasible  # More efficient than item <= bins_remain_cap\n    if np.any(feasible):\n        remaining_capacity = bins_remain_cap[feasible]\n        fill_ratio = (bins_remain_cap[feasible] - item) / bins_remain_cap[feasible]\n\n        # Prioritize bins that minimize wasted space (smaller remaining capacity)\n        # and maximize fill ratio. This combines two desirable properties.\n        # Using a weighted combination of normalized metrics\n\n        normalized_remaining_capacity = remaining_capacity / np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else 0 #avoid division by zero and normalizing when all bins are empty.\n        priorities[feasible] =  (1 - normalized_remaining_capacity) + fill_ratio  # Combine normalized metrics\n\n\n    # Handle the case where no bins are feasible\n    else:\n        # Distribute evenly to new bins at the end\n        priorities = -np.arange(len(bins_remain_cap))\n\n    return priorities\n\n[Heuristics 20th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Feasibility check: Strongly penalize infeasible bins\n    infeasible = item > bins_remain_cap\n    priorities[infeasible] = -np.inf\n\n    # Handle feasible bins\n    feasible = ~infeasible  # More efficient than item <= bins_remain_cap\n    if np.any(feasible):\n        remaining_capacity = bins_remain_cap[feasible]\n        fill_ratio = (bins_remain_cap[feasible] - item) / bins_remain_cap[feasible]\n\n        # Prioritize bins that minimize wasted space (smaller remaining capacity)\n        # and maximize fill ratio. This combines two desirable properties.\n        # Using a weighted combination of normalized metrics\n\n        normalized_remaining_capacity = remaining_capacity / np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else 0 #avoid division by zero and normalizing when all bins are empty.\n        priorities[feasible] =  (1 - normalized_remaining_capacity) + fill_ratio  # Combine normalized metrics\n\n\n    # Handle the case where no bins are feasible\n    else:\n        # Distribute evenly to new bins at the end\n        priorities = -np.arange(len(bins_remain_cap))\n\n    return priorities\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}