{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priorities with a base value (e.g., 0).\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Give high priority to bins that can fit the item. If a bin cannot fit, the priority is zero\n    fit_indices = bins_remain_cap >= item\n    priorities[fit_indices] = 1.0\n\n    # Adjust priorities based on how well the item fits. Use a ratio of remaining capacity after fitting.\n    remaining_capacity = bins_remain_cap[fit_indices] - item\n    capacity_ratios = remaining_capacity / bins_remain_cap[fit_indices]\n\n    # A smaller remaining capacity should give a higher priority. The most full-like bin is thus prioritized\n    priorities[fit_indices] += (1.0 - capacity_ratios)**2  # Adding to the already existing '1'\n\n    #Bonus for almost full bin. If the bin can take the new item almost perfectly without leaving any considerable space, prioritize it\n    almost_full_indices = np.where((bins_remain_cap >= item) & (bins_remain_cap - item <= 0.1*bins_remain_cap ))[0]\n    priorities[almost_full_indices]+=1.0 #Bonus Score\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n    This version incorporates a \"near miss\" bonus and a penalty for bins that are too small.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Penalty for bins that cannot contain the item\n    priorities[bins_remain_cap < item] = -np.inf  # Or a very large negative number\n\n    # Calculate \"near miss\" bonus - bins only slightly larger than the item get high priority\n    near_miss_threshold = item * 1.2 #tuneable, percentage above item size to be \"near miss\"\n    near_miss_bonus = np.exp(-np.abs(bins_remain_cap - item) / (item*0.1))  # Gaussian-like bonus near item size.  0.1 is tunable.\n    near_miss_bonus[bins_remain_cap < item] = 0 # Avoid triggering near-miss for impossible fits\n    priorities += near_miss_bonus\n\n    # Fill rate priority- favors filling almost empty bins somewhat.\n    fill_rate_priority = (bins_remain_cap - item)/bins_remain_cap\n    fill_rate_priority[bins_remain_cap < item] = -np.inf\n    priorities += fill_rate_priority # Consider scaling if one influence is too strong\n\n    #Remaining capacity priority (modified first-fit)\n    priorities += bins_remain_cap / np.sum(bins_remain_cap)\n\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (2nd), we see that they are identical. Comparing (1st) vs (11th), the 1st uses fill ratio after placing the item and a bonus for partially filled bins, while the 11th minimizes waste, encourages filling bins, avoids almost full bins, boosts bins with similar remaining capacity, and considers remaining capacity as a tie-breaker. Comparing (2nd worst) vs (worst), we see that they are identical. Comparing (3rd) vs (4th), the 3rd prioritizes based on wasted space and fill ratio if the item is added with division by zero protection, while the 4th gives high priority to bins that can fit, adjusts priorities based on remaining capacity ratio, and bonuses almost full bins. Comparing (second best) vs (second worst), they are identical. Comparing (1st) vs (3rd), the first uses fill ratio after placing item while the 3rd uses wasted space.\nOverall: The better heuristics utilize a fill-ratio based approach calculated *after* placing the item, combined with bonuses for already-partially-filled bins to avoid starting new bins. They also include a tie-breaker based on minimizing remaining capacity. The worse heuristics either overly penalize infeasible bins or combine too many different factors without clear weighting. Some heuristics also fail to normalize or scale certain components appropriately. Also, remember to consider edge cases (e.g. division by zero).\n- \nOkay, I'm ready to help you redefine 'Current self-reflection' to design better heuristics! Let's aim for a more effective and insightful approach.\n\nHere's a redefined 'Current self-reflection' focusing on actionable improvements:\n\n*   **Keywords:** Goal-oriented, iterative, adaptable, trade-offs, evaluation metrics, systematic exploration, assumptions, validation.\n*   **Advice:** Define clear, measurable goals *before* designing. Iteratively test and refine heuristics based on performance data. Document assumptions and limitations. Actively explore diverse heuristic structures.\n*   **Avoid:** Premature optimization, rigid adherence to initial designs, neglecting edge cases, relying solely on intuition without validation.\n*   **Explanation:** Emphasize a goal-driven, iterative design process with systematic exploration of different heuristic structures. Avoid getting stuck in initial designs by continuously validating and adapting based on concrete performance metrics. Consider and document the limitations in advance.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}