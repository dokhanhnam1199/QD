{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Utilizes a combination of heuristics inspired by physics and a touch of 'divine intuition'.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # 1. Gravitational Attraction:\n    # Bins with capacity closer to the item's size have higher 'gravitational attraction'.\n    attraction = np.exp(-np.abs(bins_remain_cap - item) / (item + 1e-6))\n\n    # 2. Conservation of Energy (Bin Capacity):\n    # We don't want to 'overfill' the bin. Penalize bins that would be too full.\n    energy_potential = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    energy_potential[valid_bins] = (bins_remain_cap[valid_bins] - item) / bins_remain_cap[valid_bins]\n    energy_potential[~valid_bins] = -1  # Heavily penalize invalid bins\n    energy_potential = np.clip(energy_potential, -1, 1)  # Ensure values stay within a reasonable range\n\n\n    # 3. \"God Does Not Play Dice\":\n    # Preferentially use bins that are already partially filled. The more a bin is\n    # filled, the more likely it is to accept another item without wasting too much space\n    # \"Fullness\" factor -- encourages efficient space usage\n    fullness_factor = (1 - (bins_remain_cap / bins_remain_cap.max()))\n    fullness_factor = np.clip(fullness_factor, 0, 1) # Ensure values are non-negative\n\n    # 4. A touch of randomness for exploration. Add small Gaussian noise\n    noise = np.random.normal(0, 0.01, size=bins_remain_cap.shape)\n\n    # Combine these factors with carefully chosen weights.\n    priority = 0.5 * attraction + 0.3 * energy_potential + 0.2*fullness_factor + noise\n\n    return priority\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Find bins that can accommodate the item\n    feasible_bins = bins_remain_cap >= item\n\n    if np.any(feasible_bins):\n        # Calculate remaining capacity after placing item in feasible bins\n        remaining_capacities = bins_remain_cap[feasible_bins] - item\n\n        # Prioritize bins with smallest remaining capacity after placement (first-fit decreasing)\n        priorities[feasible_bins] = 1 / (remaining_capacities + 1e-9) # add a small constant to avoid division by zero\n\n        # Optionally, add a bonus for bins that are almost full\n        almost_full_threshold = 0.1  # e.g., bin is at least 90% full after placement\n        almost_full = remaining_capacities / bins_remain_cap[feasible_bins] < almost_full_threshold\n        priorities[feasible_bins][almost_full] *= 2  # Double the priority for almost full bins\n\n    else:\n        # If no feasible bins, penalize bins with low capacity\n        priorities = -1 / (bins_remain_cap + 1e-9) # Penalize the bins. Add small constant to avoid div by 0\n\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (2nd), we see that they are identical. Comparing (1st) vs (11th), the 1st uses fill ratio after placing the item and a bonus for partially filled bins, while the 11th minimizes waste, encourages filling bins, avoids almost full bins, boosts bins with similar remaining capacity, and considers remaining capacity as a tie-breaker. Comparing (2nd worst) vs (worst), we see that they are identical. Comparing (3rd) vs (4th), the 3rd prioritizes based on wasted space and fill ratio if the item is added with division by zero protection, while the 4th gives high priority to bins that can fit, adjusts priorities based on remaining capacity ratio, and bonuses almost full bins. Comparing (second best) vs (second worst), they are identical. Comparing (1st) vs (3rd), the first uses fill ratio after placing item while the 3rd uses wasted space.\nOverall: The better heuristics utilize a fill-ratio based approach calculated *after* placing the item, combined with bonuses for already-partially-filled bins to avoid starting new bins. They also include a tie-breaker based on minimizing remaining capacity. The worse heuristics either overly penalize infeasible bins or combine too many different factors without clear weighting. Some heuristics also fail to normalize or scale certain components appropriately. Also, remember to consider edge cases (e.g. division by zero).\n- \nOkay, I'm ready to help you redefine 'Current self-reflection' to design better heuristics! Let's aim for a more effective and insightful approach.\n\nHere's a redefined 'Current self-reflection' focusing on actionable improvements:\n\n*   **Keywords:** Goal-oriented, iterative, adaptable, trade-offs, evaluation metrics, systematic exploration, assumptions, validation.\n*   **Advice:** Define clear, measurable goals *before* designing. Iteratively test and refine heuristics based on performance data. Document assumptions and limitations. Actively explore diverse heuristic structures.\n*   **Avoid:** Premature optimization, rigid adherence to initial designs, neglecting edge cases, relying solely on intuition without validation.\n*   **Explanation:** Emphasize a goal-driven, iterative design process with systematic exploration of different heuristic structures. Avoid getting stuck in initial designs by continuously validating and adapting based on concrete performance metrics. Consider and document the limitations in advance.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}