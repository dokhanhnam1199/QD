{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Infeasibility check - critical to avoid placing items into bins that are too small.\n    infeasible = item > bins_remain_cap\n    priorities[infeasible] = -np.inf\n\n    feasible = item <= bins_remain_cap\n    \n    if np.any(feasible):  # At least one feasible bin\n        remaining_capacity_after_placement = bins_remain_cap[feasible] - item\n        \n        # Prioritize tighter fits.  The reciprocal provides a strong preference for bins\n        # that are close to being full *after* the item is placed.  Adding a small constant\n        # avoids division by zero if an item perfectly fills a bin.\n        priorities[feasible] = 1.0 / (remaining_capacity_after_placement + 0.001)\n        \n        # Slightly boost priority for bins that are already relatively full.\n        # This encourages filling existing bins before opening new ones.\n        # The base is chosen to give meaningful differences in priority.\n        \n        priorities[feasible] += (bins_remain_cap[feasible].max() - bins_remain_cap[feasible]) * 0.1\n    else:\n        # All bins are infeasible.  Prioritize the emptiest bin, breaking ties by index\n        # This ensures we open a new bin when necessary.\n        # Give negative priority based on remaining capacity so bins with larger\n        # capacity are prioritized *less* negatively.  Add small noise to break ties by index\n        priorities = bins_remain_cap + np.random.rand(len(bins_remain_cap)) * 0.0001 # Use random number to avoid infinite loop when bins are all the same\n        \n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Prioritizes bins by fill ratio & normalized remaining capacity with a bonus for nearly full bins.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Infeasible bins get -inf priority\n    infeasible = item > bins_remain_cap\n    priorities[infeasible] = -np.inf\n\n    feasible = ~infeasible\n    if np.any(feasible):\n        remaining_capacity = bins_remain_cap[feasible]\n        # Fill ratio after placing the item\n        fill_ratio = (bins_remain_cap[feasible] - item) / bins_remain_cap[feasible] if np.all(bins_remain_cap[feasible] > 0) else 0 # Avoid division by zero\n\n        # Exponential decay based on normalized remaining capacity.\n        max_capacity = np.max(bins_remain_cap)\n        normalized_remaining_capacity = remaining_capacity / max_capacity if max_capacity > 0 else 0\n        priorities[feasible] = fill_ratio * np.exp(-5 * normalized_remaining_capacity)\n\n        # Bonus for nearly full bins.\n        waste = bins_remain_cap[feasible] - item\n        near_full_mask = (waste > 0) & (waste < 0.1 * max_capacity)\n        priorities[feasible][near_full_mask] += 0.2 # Slightly larger bonus\n\n    else:\n      # If no feasible bins, prioritize bins with the largest remaining capacity\n      priorities = bins_remain_cap\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see that the best heuristic prioritizes tighter fits using a reciprocal of remaining capacity, while the worst uses fill ratio combined with exponential decay of normalized remaining capacity and a bonus for nearly full bins. Also the best heuristic prioritizes the emptiest bin with random noise when no bins are feasible. The worst heuristic prioritizes the bins with the largest remaining capacity when no bins are feasible.\n\nComparing (2nd) vs (19th), the second-best heuristic uses a weighted combination of normalized fill ratio and exponential decay of remaining capacity, whereas the 19th employs fill ratio with exponential decay of normalized remaining capacity and a bonus for nearly full bins. The second-best uses negative remaining capacity for infeasible bins, the 19th uses the bins remaining capacities.\n\nComparing (1st) vs (2nd), the first uses reciprocal of remaining capacity, boosting partially full bins, and noise on infeasible bins whereas the second uses normalized fill ratio and remaining capacity with exponential decay, and negative remaining capacity if infeasible.\n\nComparing (3rd) vs (4th), the 3rd prioritizes fill ratio and exponential decay with a small bonus for nearly full bins, and negative index for infeasible bins whereas the 4th prioritizes fill ratio with exponential decay having tunnable factor, nearly full bonus, and negative index if infeasible. The 3rd normalizes remaining capacity by dividing it by max capacity and setting it to 0 if max capacity is 0. The 4th does the same.\n\nComparing (second worst) vs (worst), we observe that both prioritize fill ratio and remaining capacity with exponential decay and a near-full bonus, the difference is that the second-worse one prioritizes bins with the largest remaining capacity for infeasible, and the worst prioritizes bins by their remaining capacities directly.\n\nOverall: The best heuristics seem to focus on directly optimizing for tight fits and efficient use of partially filled bins, even using reciprocal of remaining capacity. They incorporate mechanisms to handle infeasibility gracefully, often by prioritizing opening new bins when necessary. The worst heuristics tend to rely on a combination of fill ratio, exponential decay, and near-full bonuses, which may not always lead to the most efficient packing. Normalizing the remaining capacity seems useful.\n- \nOkay, I'll help you redefine \"Current self-reflection\" to design better bin-packing heuristics, avoiding the pitfalls of \"Ineffective self-reflection.\" Here's a revised approach:\n\n*   **Keywords:** Feasibility, Bin Initialization, Remaining Capacity, Priority Function, Edge Cases, Normalization, Exploration.\n\n*   **Advice:** Rigorously test priority functions on varied datasets. Emphasize graceful infeasibility handling to encourage exploration, and efficient bin initialization strategies.\n\n*   **Avoid:** Unjustified complexity in priority calculations. Premature scaling without experimentation. Over-reliance on bonuses without clear understanding of their impact. Blindly normalizing without empirical justification.\n\n*   **Explanation:** Focus on designing priority functions based on sound mathematical principles and extensive experimentation. Understand the interplay between feasibility constraints, exploration mechanisms, and the overall heuristic's performance.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}