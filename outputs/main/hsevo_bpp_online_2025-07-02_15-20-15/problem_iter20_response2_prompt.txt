{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Prioritizes tight fits, fill ratio, and exploration with noise.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    infeasible = item > bins_remain_cap\n    priorities[infeasible] = -np.inf\n\n    feasible = ~infeasible\n    if np.any(feasible):\n        remaining_capacity = bins_remain_cap[feasible]\n        fit_priority = 1.0 / (remaining_capacity - item + 0.0001)\n        fill_ratio = item / (bins_remain_cap[feasible] + 0.0001)\n        priorities[feasible] = 0.7 * fit_priority + 0.3 * fill_ratio\n    else:\n        priorities = bins_remain_cap + np.random.rand(len(bins_remain_cap)) * 0.0001\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Enhanced heuristic: Combines tight-fit reciprocal with fill ratio and controlled exploration.\n    Prioritizes tighter fits and higher fill ratios, with a small chance to explore new bins.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Handle infeasible bins (item larger than remaining capacity)\n    infeasible = item > bins_remain_cap\n    priorities[infeasible] = -np.inf\n\n    feasible = ~infeasible\n    if np.any(feasible):\n        remaining_capacity = bins_remain_cap[feasible]\n\n        # Tight-fit component: Reciprocal of remaining capacity after placing the item\n        tight_fit = 1.0 / (remaining_capacity - item + 0.001)\n\n        # Fill ratio component: How full the bin would be after placing the item\n        fill_ratio = (bins_remain_cap[feasible] - item) / bins_remain_cap[feasible]\n\n        # Combine components: Weighted sum of tight-fit and fill ratio\n        priorities[feasible] = tight_fit * 0.7 + fill_ratio * 0.3\n\n        # Exploration component: Small probability to choose a less-filled bin\n        exploration_prob = 0.01  # Probability of exploring a less filled bin\n        if np.random.rand() < exploration_prob:\n            priorities[feasible] += np.random.rand(np.sum(feasible)) * 0.01  # Add small random value\n    else:\n          # If no feasible bin, prioritize bins with more capacity (or small random if all are effectively equal).\n          priorities = bins_remain_cap + np.random.rand(len(bins_remain_cap)) * 0.0001\n\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see the best heuristic uses a simple combination of tight-fit and fill ratio, while the worst attempts to add a conditional empty bin bonus during exploration, which may overcomplicate the priority calculation. Also the exploration probability may increase the calculation complexity and cause worse performance.\n(2nd best) vs (2nd worst): The second-best emphasizes a straightforward combination of tight fit and fill ratio while penalizing infeasible bins, whereas the second worst focuses on just tight fits, fill ratio, and exploration with noise, which might be insufficient to ensure efficient bin usage.\nComparing (1st) vs (2nd), we see that they are identical.\n(3rd) vs (4th): The heuristics are identical.\nComparing (second worst) vs (worst), we see that the exploration component in the worst heuristic may not be as effective as the simple combination of tight-fit and fill ratio in the second worst. Overall: The better heuristics emphasize a balanced combination of tight-fit and fill ratio with simpler exploration strategies, while the worse ones introduce more complex conditional logic and exploration which may not be effective and can be detrimental to performance. Better heuristics consistently prioritize simplicity and balance. Weights also appear to matter.\n- \nOkay, here's a refined view of self-reflection for designing better bin-packing heuristics, focusing on actionable improvements and avoiding common pitfalls:\n\n*   **Keywords:** Core logic, controlled exploration, tunable weights, graceful infeasibility.\n*   **Advice:** Focus on simple, well-defined priority calculations. Experiment with normalization and reciprocal remaining capacity *early* in the design process. Explicitly handle edge cases related to infeasibility.\n*   **Avoid:** Overly complex conditional logic, excessive bonuses/penalties without justification, premature optimization of secondary factors.\n*   **Explanation:** Prioritize clear, tunable core logic. Controlled exploration is essential, not an afterthought. Tune weights systematically, not randomly. Infeasibility handling should be part of the *initial* design.\n\nThis approach emphasizes a simpler, more structured, and testable heuristic development process.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}