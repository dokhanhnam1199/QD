{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Prioritizes bins based on fill ratio and remaining capacity (exponential decay).\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    infeasible = item > bins_remain_cap\n    priorities[infeasible] = -np.inf\n    feasible = item <= bins_remain_cap\n\n    if np.any(feasible):\n        remaining_capacity_after_placement = bins_remain_cap[feasible] - item\n        fill_ratio = item / bins_remain_cap[feasible]\n        priorities[feasible] = fill_ratio * np.exp(-remaining_capacity_after_placement / np.max(bins_remain_cap)) if np.max(bins_remain_cap) > 0 else fill_ratio\n\n        close_to_full = (remaining_capacity_after_placement > 0) & (remaining_capacity_after_placement <= 0.1 * np.max(bins_remain_cap))\n        priorities[feasible][close_to_full] += 0.5\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Prioritizes bins based on fill ratio and exponential decay of remaining capacity.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float) - np.inf\n    valid_bins = bins_remain_cap >= item\n\n    if not np.any(valid_bins):\n        return priorities\n\n    fill_ratios = item / bins_remain_cap\n    priorities[valid_bins] = fill_ratios[valid_bins] * np.exp(-bins_remain_cap[valid_bins])\n    # Bonus for bins that are nearly full\n    waste = bins_remain_cap - item\n    nearly_full = (waste > 0) & (waste < 0.1 * bins_remain_cap)\n    priorities[nearly_full] += 0.5\n\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see the best heuristic normalizes remaining capacity in the exponential decay calculation using `np.max(bins_remain_cap)`, while the worst directly uses `bins_remain_cap`. The best heuristic also multiplies the exponential decay by the `fill_ratio`, whereas the worst only uses the exponential decay. The best also handles the edge case where no bins are feasible by assigning negative priorities. The worst fills the entire `priorities` array with `-np.inf` if no valid bins exist.\n\nComparing (2nd) vs (3rd), the second-best heuristic includes a bonus for bins that are nearly full, and uses exponential decay without multiplying with the `fill_ratio`, while the third-best does not explicitly include a bonus for nearly full bins but multiplies exponential decay by the `fill_ratio`. The second-best heuristic's exponent is dependent on `np.max(bins_remain_cap)` to normalize remaining capacity, while the third-best does.\n\nComparing (1st) vs (4th), the first multiplies the exponential decay by the `fill_ratio`, whereas the fourth does not. Also, the first one only adds negative priorities if `feasible` is false, the second always does.\n\nComparing (19th) vs (20th), no differences exist between the two heuristics.\n\nOverall: The better heuristics normalize the remaining capacity to the max capacity when calculating the exponential decay. Multiplying the exponential decay with `fill_ratio` seems to improve results. Adding a bonus to nearly full bins has a slightly positive impact. Properly handling edge cases where no bins are feasible (assigning negative values based on the bin index) is also important.\n- \nOkay, I understand the task. Let's refine \"Current self-reflection\" to be more effective in designing heuristics, based on avoiding the pitfalls of \"Ineffective self-reflection.\"\n\nHere's a revised approach:\n\n*   **Keywords:** Feasibility, Exploration, Normalization, Simplicity, Edge Cases.\n*   **Advice:** Prioritize exploring *feasible* solutions. Focus on normalizing key factors (e.g., fill ratio, remaining capacity) before combining them. Explicitly design for edge cases (no feasible bins).\n*   **Avoid:** Overly complex formulas, adding bonuses/penalties without strong justification.\n*   **Explanation:** Heuristics should focus on creating *feasible* assignments. Simpler, normalized factor combinations help maintain control and avoid unintended consequences. Edge case handling ensures robustness.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}