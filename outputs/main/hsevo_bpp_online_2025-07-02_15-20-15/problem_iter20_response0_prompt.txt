{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Prioritizes bins based on tightness of fit and fill ratio,\n    with controlled randomness for exploration.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    infeasible = item > bins_remain_cap\n\n    if np.any(~infeasible):\n        feasible = ~infeasible\n        remaining_capacity = bins_remain_cap[feasible]\n\n        # Tightness of fit\n        fit_priority = 1.0 / (remaining_capacity - item + 0.0001)\n\n        # Fill ratio\n        fill_ratio = item / (bins_remain_cap[feasible] + 0.0001)\n\n        priorities[feasible] = 0.7 * fit_priority + 0.3 * fill_ratio\n\n        # Boost partially full bins\n        waste = bins_remain_cap[feasible] - item\n        partially_full = (waste > 0) & (waste < 0.2 * bins_remain_cap[feasible])\n        priorities[feasible][partially_full] += 0.5\n    else:\n        # Exploration when no feasible bin exists\n        priorities = bins_remain_cap + np.random.rand(len(bins_remain_cap)) * 0.0001\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Improved heuristic: Combines tight-fit with fill ratio, controlled randomness for exploration,\n    and emphasizes a balance between bin utilization and avoiding excessive fragmentation.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Handle infeasible bins\n    infeasible = item > bins_remain_cap\n    priorities[infeasible] = -np.inf\n\n    # Calculate priorities for feasible bins\n    feasible = ~infeasible\n    if np.any(feasible):\n        remaining_capacity = bins_remain_cap[feasible]\n\n        # Tight-fit component: Reciprocal of remaining capacity after packing\n        tight_fit = 1.0 / (remaining_capacity - item + 0.001)\n\n        # Fill ratio component: Encourages better bin utilization\n        fill_ratio = (bins_remain_cap[feasible] - item) / bins_remain_cap[feasible]\n\n        # Combine tight-fit and fill ratio.  Adjust weights as needed.\n        priorities[feasible] = tight_fit * 0.7 + fill_ratio * 0.3\n\n        # Controlled randomness for exploration:  Preferentially explore empty/near-empty bins.\n        # Only apply to feasible bins and with low probability\n        if np.random.rand() < 0.01: #Exploration probability, adjustable.\n            empty_bin_bonus = (bins_remain_cap[feasible] == bins_remain_cap[feasible].max()) * 0.1 # Prefer largest bin if one exits\n\n            priorities[feasible] += empty_bin_bonus\n\n    else:\n        # If no feasible bins, prioritize bins with highest capacity (for creating new bins)\n        # Add a small amount of randomness to break ties.\n        priorities = bins_remain_cap + np.random.rand(len(bins_remain_cap)) * 0.0001\n\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see the best heuristic uses a simple combination of tight-fit and fill ratio, while the worst attempts to add a conditional empty bin bonus during exploration, which may overcomplicate the priority calculation. Also the exploration probability may increase the calculation complexity and cause worse performance.\n(2nd best) vs (2nd worst): The second-best emphasizes a straightforward combination of tight fit and fill ratio while penalizing infeasible bins, whereas the second worst focuses on just tight fits, fill ratio, and exploration with noise, which might be insufficient to ensure efficient bin usage.\nComparing (1st) vs (2nd), we see that they are identical.\n(3rd) vs (4th): The heuristics are identical.\nComparing (second worst) vs (worst), we see that the exploration component in the worst heuristic may not be as effective as the simple combination of tight-fit and fill ratio in the second worst. Overall: The better heuristics emphasize a balanced combination of tight-fit and fill ratio with simpler exploration strategies, while the worse ones introduce more complex conditional logic and exploration which may not be effective and can be detrimental to performance. Better heuristics consistently prioritize simplicity and balance. Weights also appear to matter.\n- \nOkay, here's a refined view of self-reflection for designing better bin-packing heuristics, focusing on actionable improvements and avoiding common pitfalls:\n\n*   **Keywords:** Core logic, controlled exploration, tunable weights, graceful infeasibility.\n*   **Advice:** Focus on simple, well-defined priority calculations. Experiment with normalization and reciprocal remaining capacity *early* in the design process. Explicitly handle edge cases related to infeasibility.\n*   **Avoid:** Overly complex conditional logic, excessive bonuses/penalties without justification, premature optimization of secondary factors.\n*   **Explanation:** Prioritize clear, tunable core logic. Controlled exploration is essential, not an afterthought. Tune weights systematically, not randomly. Infeasibility handling should be part of the *initial* design.\n\nThis approach emphasizes a simpler, more structured, and testable heuristic development process.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}