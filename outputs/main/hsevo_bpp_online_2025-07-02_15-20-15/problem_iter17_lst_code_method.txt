{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Hybrid heuristic: Tighter fit (reciprocal) with fill ratio consideration.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    infeasible = item > bins_remain_cap\n    priorities[infeasible] = -np.inf\n\n    feasible = ~infeasible\n    if np.any(feasible):\n        remaining_capacity = bins_remain_cap[feasible]\n        fill_ratio = (bins_remain_cap[feasible] - item) / bins_remain_cap[feasible]\n        priorities[feasible] = (1.0 / (remaining_capacity - item + 0.001)) + fill_ratio * 0.1\n    else:\n        priorities = bins_remain_cap + np.random.rand(len(bins_remain_cap)) * 0.0001\n    return priorities\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Hybrid heuristic: Tighter fit (reciprocal) with fill ratio consideration.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    infeasible = item > bins_remain_cap\n    priorities[infeasible] = -np.inf\n\n    feasible = ~infeasible\n    if np.any(feasible):\n        remaining_capacity = bins_remain_cap[feasible]\n        fill_ratio = (bins_remain_cap[feasible] - item) / bins_remain_cap[feasible]\n        priorities[feasible] = (1.0 / (remaining_capacity - item + 0.001)) + fill_ratio * 0.1\n    else:\n        priorities = bins_remain_cap + np.random.rand(len(bins_remain_cap)) * 0.0001\n    return priorities\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Hybrid heuristic: Tighter fit (reciprocal) with fill ratio consideration.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    infeasible = item > bins_remain_cap\n    priorities[infeasible] = -np.inf\n\n    feasible = ~infeasible\n    if np.any(feasible):\n        remaining_capacity = bins_remain_cap[feasible]\n        fill_ratio = (bins_remain_cap[feasible] - item) / bins_remain_cap[feasible]\n        priorities[feasible] = (1.0 / (remaining_capacity - item + 0.001)) + fill_ratio * 0.1\n    else:\n        priorities = bins_remain_cap + np.random.rand(len(bins_remain_cap)) * 0.0001\n    return priorities\n\n[Heuristics 4th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Hybrid heuristic: Tighter fit (reciprocal) with fill ratio consideration.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    infeasible = item > bins_remain_cap\n    priorities[infeasible] = -np.inf\n\n    feasible = ~infeasible\n    if np.any(feasible):\n        remaining_capacity = bins_remain_cap[feasible]\n        fill_ratio = (bins_remain_cap[feasible] - item) / bins_remain_cap[feasible]\n        priorities[feasible] = (1.0 / (remaining_capacity - item + 0.001)) + fill_ratio * 0.1\n    else:\n        priorities = bins_remain_cap + np.random.rand(len(bins_remain_cap)) * 0.0001\n    return priorities\n\n[Heuristics 5th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Hybrid approach prioritizing tight fits and exploration.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    infeasible = item > bins_remain_cap\n    priorities[infeasible] = -np.inf\n\n    feasible = ~infeasible\n    if np.any(feasible):\n        remaining_capacity = bins_remain_cap[feasible]\n        fill_ratio = item / remaining_capacity\n        max_cap = np.max(bins_remain_cap)\n        normalized_remaining_capacity = remaining_capacity / max_cap if max_cap > 0 else 0\n        priorities[feasible] = fill_ratio * np.exp(-5 * normalized_remaining_capacity)\n        waste = remaining_capacity - item\n        near_full = (waste > 0) & (waste < 0.1 * max_cap)\n        priorities[feasible][near_full] += 0.2\n    else:\n        #Prioritize emptiest bin\n        priorities = bins_remain_cap\n    return priorities\n\n[Heuristics 6th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Hybrid approach prioritizing tight fits and exploration.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    infeasible = item > bins_remain_cap\n    priorities[infeasible] = -np.inf\n\n    feasible = ~infeasible\n    if np.any(feasible):\n        remaining_capacity = bins_remain_cap[feasible]\n        fill_ratio = item / remaining_capacity\n        max_cap = np.max(bins_remain_cap)\n        normalized_remaining_capacity = remaining_capacity / max_cap if max_cap > 0 else 0\n        priorities[feasible] = fill_ratio * np.exp(-5 * normalized_remaining_capacity)\n        waste = remaining_capacity - item\n        near_full = (waste > 0) & (waste < 0.1 * max_cap)\n        priorities[feasible][near_full] += 0.2\n    else:\n        #Prioritize emptiest bin\n        priorities = bins_remain_cap\n    return priorities\n\n[Heuristics 7th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Enhanced heuristic for online bin packing, combining remaining capacity,\n    fill ratio, and a touch of exploration to improve bin utilization.\n\n    Args:\n        item (float): The size of the item to be packed.\n        bins_remain_cap (np.ndarray): An array containing the remaining capacity of each bin.\n\n    Returns:\n        np.ndarray: An array of priority scores for each bin.  Higher score = higher priority.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Mark infeasible bins with a very low priority. Adding a tiny random number\n    # ensures we still explore new bins if all bins are initially infeasible.\n    infeasible = item > bins_remain_cap\n    priorities[infeasible] = -np.inf + np.random.rand(np.sum(infeasible)) * 0.00001\n\n    # Calculate priorities for feasible bins. The goal is to find a bin that\n    # can accommodate the item without wasting too much space.\n    feasible = ~infeasible\n    if np.any(feasible):\n        remaining_capacity = bins_remain_cap[feasible]\n        space_waste = remaining_capacity - item  # positive, smaller is better\n\n        # A small constant is added to prevent division by zero or extreme values\n        # when bins are almost full or exactly full.\n        epsilon = 0.001\n\n        # Fill ratio aims to pack bins tightly.\n        fill_ratio = item / remaining_capacity # closer to 1 is better\n\n        # Combine the space waste and fill ratio to create a balanced priority.\n        # Reciprocal of space waste favors bins with smaller waste.\n        # Fill ratio encourages efficient packing.\n        priorities[feasible] = (1.0 / (space_waste + epsilon)) + fill_ratio * 0.5\n\n        # Normalize priorities to prevent domination by one factor\n        max_priority = np.max(priorities[feasible])\n        min_priority = np.min(priorities[feasible])\n        if max_priority - min_priority > 0:\n            priorities[feasible] = (priorities[feasible] - min_priority) / (max_priority - min_priority)\n\n        # Add a small random component to encourage exploration.\n        priorities[feasible] += np.random.rand(np.sum(feasible)) * 0.01\n\n    # If no bin is feasible, initialize new bins implicitly by giving all existing bins a small random priority.\n    # This helps exploration when all bins are near full.\n    else:\n        priorities = np.random.rand(len(bins_remain_cap)) * 0.0001\n\n\n    return priorities\n\n[Heuristics 8th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on feasibility, fill ratio, and encourages new bins if needed.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    infeasible = item > bins_remain_cap\n    priorities[infeasible] = -np.inf\n\n    feasible = ~infeasible\n    if np.any(feasible):\n        priorities[feasible] = item / bins_remain_cap[feasible] # reciprocal of remain_cap\n\n        remaining_capacity = bins_remain_cap[feasible] - item\n        max_capacity = np.max(bins_remain_cap)\n        near_full_mask = (remaining_capacity > 0) & (remaining_capacity < 0.1 * max_capacity)\n        priorities[feasible][near_full_mask] += 0.1\n    else:\n        priorities = np.random.rand(len(bins_remain_cap)) / 1000 - bins_remain_cap/ np.max(bins_remain_cap)\n    return priorities\n\n[Heuristics 9th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Enhanced heuristic: Combines tighter fit, fill ratio, and bin utilization\n    with exploration. Addresses edge cases and normalizes priorities.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Mark infeasible bins with a very low priority but not -inf to allow for some exploration\n    infeasible = item > bins_remain_cap\n    priorities[infeasible] = -1e9 + np.random.rand(np.sum(infeasible)) * 0.0001  # slight randomization for exploration\n\n    feasible = ~infeasible\n    if np.any(feasible):\n        remaining_capacity = bins_remain_cap[feasible]\n\n        # Tighter Fit: Reciprocal of remaining space after placing the item\n        fit_priority = 1.0 / (remaining_capacity - item + 0.001)\n\n        # Fill Ratio: How much of the bin will be filled by the item\n        fill_ratio = item / bins_remain_cap[feasible]\n\n        # Bin Utilization: Encourage filling bins that are already somewhat full.\n        utilization = 1 - remaining_capacity / np.max(bins_remain_cap) # normalized remaining cap\n\n        # Combine the factors with weights.  Experiment with these weights.\n        combined_priority = (\n            0.6 * fit_priority +  # Tighter fit is important\n            0.3 * fill_ratio +  # Fill ratio encourages using available space\n            0.1 * utilization # Utilization encourages filling up almost empty bins\n        )\n        priorities[feasible] = combined_priority\n\n        # Normalize the priorities to be between 0 and 1\n        min_priority = np.min(priorities[feasible])\n        max_priority = np.max(priorities[feasible])\n\n        if max_priority > min_priority:\n            priorities[feasible] = (priorities[feasible] - min_priority) / (max_priority - min_priority)\n\n    else:\n        # If no bin is feasible, prioritize bins based on remaining capacity with small random component for exploration.\n        priorities = bins_remain_cap + np.random.rand(len(bins_remain_cap)) * 0.0001\n\n    return priorities\n\n[Heuristics 10th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritize tight fits, penalize infeasibility, and add tie-breaker.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    infeasible = item > bins_remain_cap\n    priorities[infeasible] = -np.inf\n\n    if np.all(infeasible):\n        priorities = -np.arange(len(bins_remain_cap))\n        return priorities\n\n    feasible = item <= bins_remain_cap\n    remaining_capacity_after_placement = bins_remain_cap[feasible] - item\n    \n    priorities[feasible] = 1 / (remaining_capacity_after_placement + 1e-9)\n    \n    priorities[feasible] += -np.arange(np.sum(feasible)) * 1e-6\n\n    return priorities\n\n[Heuristics 11th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritize tight fits, penalize infeasibility, and add tie-breaker.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    infeasible = item > bins_remain_cap\n    priorities[infeasible] = -np.inf\n\n    if np.all(infeasible):\n        priorities = -np.arange(len(bins_remain_cap))\n        return priorities\n\n    feasible = item <= bins_remain_cap\n    remaining_capacity_after_placement = bins_remain_cap[feasible] - item\n    \n    priorities[feasible] = 1 / (remaining_capacity_after_placement + 1e-9)\n    \n    priorities[feasible] += -np.arange(np.sum(feasible)) * 1e-6\n\n    return priorities\n\n[Heuristics 12th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on reciprocal remaining capacity and noise for infeasible bins.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    infeasible = item > bins_remain_cap\n    priorities[infeasible] = -np.random.rand(np.sum(infeasible)) # Noise for infeasible\n\n    feasible = ~infeasible\n    if np.any(feasible):\n        remaining_capacity = bins_remain_cap[feasible]\n        priorities[feasible] = 1 / remaining_capacity  # Reciprocal of remaining capacity\n\n        # Boost partially full bins.\n        waste = bins_remain_cap[feasible] - item\n        partially_full = (waste > 0) & (waste < 0.2 * bins_remain_cap[feasible])\n        priorities[feasible][partially_full] += 0.5  # Larger boost for partially full.\n    else:\n        priorities = -np.arange(len(bins_remain_cap)) # Prioritize emptiest if no feasible\n\n    return priorities\n\n[Heuristics 13th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on reciprocal remaining capacity.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    infeasible = item > bins_remain_cap\n    feasible = ~infeasible\n\n    if np.any(feasible):\n        remaining_capacity = bins_remain_cap[feasible]\n        priorities[feasible] = 1.0 / remaining_capacity  # Reciprocal of remaining capacity\n\n        # Boost partially full bins with noise (exploration)\n        waste = bins_remain_cap[feasible] - item\n        partially_full = (waste > 0) & (waste < 0.2 * bins_remain_cap[feasible]) # adjust constant 0.2\n        if np.any(partially_full):\n          priorities[feasible][partially_full] += np.random.normal(0, 0.1, size=np.sum(partially_full))\n\n    else:\n        # Prioritize emptiest bins with random noise (encourage new bin usage)\n        # avoid -np.inf\n        priorities = np.random.rand(len(bins_remain_cap)) #random exploration if all bins are infeasible\n\n    return priorities\n\n[Heuristics 14th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Enhanced heuristic: Considers tightness of fit, fill ratio, and bin utilization with a balanced approach.\n\n    This heuristic prioritizes bins based on a combination of factors:\n    1. Tightness of fit: Favors bins where the item fits snugly (small remaining capacity).\n    2. Fill ratio: Encourages filling bins reasonably well without overfilling.\n    3. Bin utilization: Gives a slight preference to bins that are already partially filled,\n       promoting better overall bin usage.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    infeasible = item > bins_remain_cap\n    priorities[infeasible] = -np.inf  # Mark infeasible bins with negative infinity\n\n    feasible = ~infeasible\n    if np.any(feasible):\n        remaining_capacity = bins_remain_cap[feasible]\n\n        # Tightness of fit: Reciprocal of remaining capacity after placing the item\n        fit_priority = 1.0 / (remaining_capacity - item + 0.0001)\n\n        # Fill ratio: How well the item fills the bin\n        fill_ratio = (item) / (bins_remain_cap[feasible] + 0.0001)  # fill ratio with respect to the current bin cap\n\n        # Bin utilization: Encourages filling partially filled bins\n        utilization_priority = (bins_remain_cap[feasible] - item) / np.max(bins_remain_cap)\n        # Combine the priorities with carefully chosen weights\n        priorities[feasible] = 0.6 * fit_priority + 0.3 * fill_ratio + 0.1 * utilization_priority\n\n    else:\n        # If no bin can fit the item, create a new bin if applicable/possible,\n        # or select a bin randomly with a small priority to avoid infinite loops or unhandled exceptions\n        priorities = bins_remain_cap + np.random.rand(len(bins_remain_cap)) * 0.0001\n    return priorities\n\n[Heuristics 15th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Enhanced heuristic: Considers tightness of fit, fill ratio, and bin utilization with a balanced approach.\n\n    This heuristic prioritizes bins based on a combination of factors:\n    1. Tightness of fit: Favors bins where the item fits snugly (small remaining capacity).\n    2. Fill ratio: Encourages filling bins reasonably well without overfilling.\n    3. Bin utilization: Gives a slight preference to bins that are already partially filled,\n       promoting better overall bin usage.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    infeasible = item > bins_remain_cap\n    priorities[infeasible] = -np.inf  # Mark infeasible bins with negative infinity\n\n    feasible = ~infeasible\n    if np.any(feasible):\n        remaining_capacity = bins_remain_cap[feasible]\n\n        # Tightness of fit: Reciprocal of remaining capacity after placing the item\n        fit_priority = 1.0 / (remaining_capacity - item + 0.0001)\n\n        # Fill ratio: How well the item fills the bin\n        fill_ratio = (item) / (bins_remain_cap[feasible] + 0.0001)  # fill ratio with respect to the current bin cap\n\n        # Bin utilization: Encourages filling partially filled bins\n        utilization_priority = (bins_remain_cap[feasible] - item) / np.max(bins_remain_cap)\n        # Combine the priorities with carefully chosen weights\n        priorities[feasible] = 0.6 * fit_priority + 0.3 * fill_ratio + 0.1 * utilization_priority\n\n    else:\n        # If no bin can fit the item, create a new bin if applicable/possible,\n        # or select a bin randomly with a small priority to avoid infinite loops or unhandled exceptions\n        priorities = bins_remain_cap + np.random.rand(len(bins_remain_cap)) * 0.0001\n    return priorities\n\n[Heuristics 16th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Enhanced heuristic: Considers tightness of fit, fill ratio, and bin utilization with a balanced approach.\n\n    This heuristic prioritizes bins based on a combination of factors:\n    1. Tightness of fit: Favors bins where the item fits snugly (small remaining capacity).\n    2. Fill ratio: Encourages filling bins reasonably well without overfilling.\n    3. Bin utilization: Gives a slight preference to bins that are already partially filled,\n       promoting better overall bin usage.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    infeasible = item > bins_remain_cap\n    priorities[infeasible] = -np.inf  # Mark infeasible bins with negative infinity\n\n    feasible = ~infeasible\n    if np.any(feasible):\n        remaining_capacity = bins_remain_cap[feasible]\n\n        # Tightness of fit: Reciprocal of remaining capacity after placing the item\n        fit_priority = 1.0 / (remaining_capacity - item + 0.0001)\n\n        # Fill ratio: How well the item fills the bin\n        fill_ratio = (item) / (bins_remain_cap[feasible] + 0.0001)  # fill ratio with respect to the current bin cap\n\n        # Bin utilization: Encourages filling partially filled bins\n        utilization_priority = (bins_remain_cap[feasible] - item) / np.max(bins_remain_cap)\n        # Combine the priorities with carefully chosen weights\n        priorities[feasible] = 0.6 * fit_priority + 0.3 * fill_ratio + 0.1 * utilization_priority\n\n    else:\n        # If no bin can fit the item, create a new bin if applicable/possible,\n        # or select a bin randomly with a small priority to avoid infinite loops or unhandled exceptions\n        priorities = bins_remain_cap + np.random.rand(len(bins_remain_cap)) * 0.0001\n    return priorities\n\n[Heuristics 17th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Enhanced heuristic: Considers tightness of fit, fill ratio, and bin utilization with a balanced approach.\n\n    This heuristic prioritizes bins based on a combination of factors:\n    1. Tightness of fit: Favors bins where the item fits snugly (small remaining capacity).\n    2. Fill ratio: Encourages filling bins reasonably well without overfilling.\n    3. Bin utilization: Gives a slight preference to bins that are already partially filled,\n       promoting better overall bin usage.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    infeasible = item > bins_remain_cap\n    priorities[infeasible] = -np.inf  # Mark infeasible bins with negative infinity\n\n    feasible = ~infeasible\n    if np.any(feasible):\n        remaining_capacity = bins_remain_cap[feasible]\n\n        # Tightness of fit: Reciprocal of remaining capacity after placing the item\n        fit_priority = 1.0 / (remaining_capacity - item + 0.0001)\n\n        # Fill ratio: How well the item fills the bin\n        fill_ratio = (item) / (bins_remain_cap[feasible] + 0.0001)  # fill ratio with respect to the current bin cap\n\n        # Bin utilization: Encourages filling partially filled bins\n        utilization_priority = (bins_remain_cap[feasible] - item) / np.max(bins_remain_cap)\n        # Combine the priorities with carefully chosen weights\n        priorities[feasible] = 0.6 * fit_priority + 0.3 * fill_ratio + 0.1 * utilization_priority\n\n    else:\n        # If no bin can fit the item, create a new bin if applicable/possible,\n        # or select a bin randomly with a small priority to avoid infinite loops or unhandled exceptions\n        priorities = bins_remain_cap + np.random.rand(len(bins_remain_cap)) * 0.0001\n    return priorities\n\n[Heuristics 18th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on tight fit and remaining capacity.\n    Handles infeasible bins and encourages exploration.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    infeasible = item > bins_remain_cap\n    priorities[infeasible] = -np.inf\n\n    feasible = item <= bins_remain_cap\n\n    if np.any(feasible):\n        remaining_capacity = bins_remain_cap[feasible] - item\n        priorities[feasible] = (1 / remaining_capacity) if np.all(remaining_capacity != 0) else 0\n\n        # Boost partially full bins\n        current_fill_ratio = (bins_remain_cap[feasible] - remaining_capacity) / np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else 0\n        priorities[feasible] += 0.2 * current_fill_ratio  # Reduced boost\n\n    else:\n        # Prioritize emptiest bin with noise if no feasible bins\n        priorities = np.random.rand(len(bins_remain_cap)) * 0.001 - bins_remain_cap\n\n    return priorities\n\n[Heuristics 19th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on tight fit and remaining capacity.\n    Handles infeasible bins and encourages exploration.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    infeasible = item > bins_remain_cap\n    priorities[infeasible] = -np.inf\n\n    feasible = item <= bins_remain_cap\n\n    if np.any(feasible):\n        remaining_capacity = bins_remain_cap[feasible] - item\n        priorities[feasible] = (1 / remaining_capacity) if np.all(remaining_capacity != 0) else 0\n\n        # Boost partially full bins\n        current_fill_ratio = (bins_remain_cap[feasible] - remaining_capacity) / np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else 0\n        priorities[feasible] += 0.2 * current_fill_ratio  # Reduced boost\n\n    else:\n        # Prioritize emptiest bin with noise if no feasible bins\n        priorities = np.random.rand(len(bins_remain_cap)) * 0.001 - bins_remain_cap\n\n    return priorities\n\n[Heuristics 20th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on tight fit and remaining capacity.\n    Handles infeasible bins and encourages exploration.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    infeasible = item > bins_remain_cap\n    priorities[infeasible] = -np.inf\n\n    feasible = item <= bins_remain_cap\n\n    if np.any(feasible):\n        remaining_capacity = bins_remain_cap[feasible] - item\n        priorities[feasible] = (1 / remaining_capacity) if np.all(remaining_capacity != 0) else 0\n\n        # Boost partially full bins\n        current_fill_ratio = (bins_remain_cap[feasible] - remaining_capacity) / np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else 0\n        priorities[feasible] += 0.2 * current_fill_ratio  # Reduced boost\n\n    else:\n        # Prioritize emptiest bin with noise if no feasible bins\n        priorities = np.random.rand(len(bins_remain_cap)) * 0.001 - bins_remain_cap\n\n    return priorities\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}