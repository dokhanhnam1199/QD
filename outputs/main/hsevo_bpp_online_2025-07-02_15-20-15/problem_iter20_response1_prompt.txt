{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Hybrid heuristic: Tight fit, fill ratio, and controlled exploration.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    infeasible = item > bins_remain_cap\n    priorities[infeasible] = -1e-6 + np.random.rand(np.sum(infeasible)) * 0.0001\n\n    feasible = ~infeasible\n    if np.any(feasible):\n        remaining_capacity = bins_remain_cap[feasible]\n        fit_priority = 1.0 / (remaining_capacity - item + 0.001)\n        fill_ratio = item / bins_remain_cap[feasible]\n        priorities[feasible] = 0.7 * fit_priority + 0.3 * fill_ratio\n    else:\n        priorities = bins_remain_cap + np.random.rand(len(bins_remain_cap)) * 0.0001\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Enhanced heuristic for online bin packing. Prioritizes tighter fits with a controlled fill ratio,\n    and incorporates a small amount of randomness for exploration when no suitable bin is found.\n\n    This version aims to improve upon priority_v1 by:\n    1.  Using reciprocal remaining capacity for a sharper preference for tight fits.\n    2.  Employing a fill ratio that encourages efficient bin utilization.\n    3.  Adding a small exploration factor when no bin can accommodate the item to avoid getting trapped.\n    4.  Explicitly handling infeasible bins by assigning negative infinity priority.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Mark infeasible bins with negative infinity priority\n    infeasible = item > bins_remain_cap\n    priorities[infeasible] = -np.inf\n\n    # Calculate priorities for feasible bins\n    feasible = ~infeasible\n    if np.any(feasible):\n        remaining_capacity = bins_remain_cap[feasible]\n        fill_ratio = (remaining_capacity - item) / remaining_capacity  # Calculate fill ratio\n        priorities[feasible] = (1.0 / (remaining_capacity - item + 0.0001)) + fill_ratio * 0.2  # Combine tightness and fill ratio\n    else:\n        # If no feasible bin, introduce a small amount of randomness for exploration\n        priorities = bins_remain_cap + np.random.rand(len(bins_remain_cap)) * 0.0001\n\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see the best heuristic uses a simple combination of tight-fit and fill ratio, while the worst attempts to add a conditional empty bin bonus during exploration, which may overcomplicate the priority calculation. Also the exploration probability may increase the calculation complexity and cause worse performance.\n(2nd best) vs (2nd worst): The second-best emphasizes a straightforward combination of tight fit and fill ratio while penalizing infeasible bins, whereas the second worst focuses on just tight fits, fill ratio, and exploration with noise, which might be insufficient to ensure efficient bin usage.\nComparing (1st) vs (2nd), we see that they are identical.\n(3rd) vs (4th): The heuristics are identical.\nComparing (second worst) vs (worst), we see that the exploration component in the worst heuristic may not be as effective as the simple combination of tight-fit and fill ratio in the second worst. Overall: The better heuristics emphasize a balanced combination of tight-fit and fill ratio with simpler exploration strategies, while the worse ones introduce more complex conditional logic and exploration which may not be effective and can be detrimental to performance. Better heuristics consistently prioritize simplicity and balance. Weights also appear to matter.\n- \nOkay, here's a refined view of self-reflection for designing better bin-packing heuristics, focusing on actionable improvements and avoiding common pitfalls:\n\n*   **Keywords:** Core logic, controlled exploration, tunable weights, graceful infeasibility.\n*   **Advice:** Focus on simple, well-defined priority calculations. Experiment with normalization and reciprocal remaining capacity *early* in the design process. Explicitly handle edge cases related to infeasibility.\n*   **Avoid:** Overly complex conditional logic, excessive bonuses/penalties without justification, premature optimization of secondary factors.\n*   **Explanation:** Prioritize clear, tunable core logic. Controlled exploration is essential, not an afterthought. Tune weights systematically, not randomly. Infeasibility handling should be part of the *initial* design.\n\nThis approach emphasizes a simpler, more structured, and testable heuristic development process.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}