```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # First-Fit-Decreasing-inspired priority:
    #   Prioritize bins that can fit the item with minimal wasted space.
    #   Give a higher priority to bins with remaining capacity slightly greater than the item size.
    #   Bins that cannot fit the item get a very low priority.

    can_fit = bins_remain_cap >= item

    if np.any(can_fit):
        waste = bins_remain_cap - item
        priorities[can_fit] = 1.0 / (waste[can_fit] + 0.00001)  # Avoid division by zero. Smaller waste, higher priority
        
        # Boost priority if the item fits perfectly
        perfect_fit = (waste == 0) & can_fit
        priorities[perfect_fit] += 10  # Significantly boost perfect fit

    else:
        priorities[:] = -1000  # Very low priority if item cannot fit.

    # Adjust priorities based on how full the bin already is
    # Partially full bins get a small penalty

    fill_ratio = (bins_remain_cap - np.clip(bins_remain_cap - item, a_min=0, a_max=None)) / bins_remain_cap
    
    # Moderate penalty if the fill ratio isn't great and it CAN fit.
    if np.any(can_fit): #avoid case when no bins can fit
        penalty_mask = (fill_ratio < 0.9) & (fill_ratio > 0.1) & can_fit
        priorities[penalty_mask] -= 0.1  # Mild penalty

    return priorities
```
