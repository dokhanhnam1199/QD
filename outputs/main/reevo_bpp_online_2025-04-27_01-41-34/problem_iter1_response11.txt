```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Very large items can be packed in only a few bins. Let us give high priority to those.
    # Small items should not crowd bins that may accept larger items in future

    # First Feasible (FF) score: Assign higher priority to bins that can accommodate the item.
    feasible_bins = bins_remain_cap >= item
    priorities[feasible_bins] += 1

    # Remaining Capacity (RC) score: Prioritize bins with less remaining capacity if item fits
    # Goal: Reduce fragmentation
    remaining_capacity_score = np.where(feasible_bins, 1 - (bins_remain_cap - item) / np.max(bins_remain_cap), 0)
    priorities += remaining_capacity_score

    # Best Fit (BF) score: Prioritize bins where item fits best
    best_fit_score = np.where(feasible_bins, 1 / (bins_remain_cap - item + 1e-6), 0) # avoid division by zero
    priorities += best_fit_score

    # Worst Fit (WF) penalty: Discourage filling nearly-empty bins with small items
    worst_fit_penalty = np.where(~feasible_bins, -bins_remain_cap/np.max(bins_remain_cap),0) # negative values for bins with insuficient cap.
    priorities += worst_fit_penalty

    # Introduce some randomness to avoid local optima
    randomness = np.random.rand(len(bins_remain_cap)) * 0.01
    priorities += randomness

    return priorities
```
