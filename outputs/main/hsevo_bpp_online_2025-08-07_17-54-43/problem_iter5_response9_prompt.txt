{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code only and do not add comments into the code. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Best-fit priority with \u03b5\u2011greedy adaptive exploration. Feasible bins get -slack; with probability \u03b5 random scores are used. \u03b5 decays each call toward a minimum.\"\"\"\n    if not hasattr(priority_v2, 'epsilon'):\n        priority_v2.epsilon = 0.2\n        priority_v2.min_epsilon = 0.01\n        priority_v2.decay = 0.995\n    eps = priority_v2.epsilon\n    n = bins_remain_cap.size\n    priorities = np.full(n, -np.inf, dtype=float)\n    valid = bins_remain_cap >= item\n    priorities[valid] = -(bins_remain_cap[valid] - item)\n    if np.random.rand() < eps:\n        rand_scores = np.random.random(n)\n        priorities[valid] = rand_scores[valid]\n    priority_v2.epsilon = max(priority_v2.min_epsilon, eps * priority_v2.decay)\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Best\u2011fit priority with \u03b5\u2011greedy exploration.\"\"\"\n    feasible = bins_remain_cap >= item\n    waste = bins_remain_cap - item\n    base_priority = np.where(feasible, 1.0/(waste + 1e-12), -np.inf)\n    random_priority = np.random.rand(bins_remain_cap.size)\n    return np.where(feasible, (1 - epsilon) * base_priority + epsilon * random_priority, -np.inf)\n\n### Analyze & experience\n- - **Comparing (best) Heuristic\u202f1 vs (worst) Heuristic\u202f20:** 1\ufe0f\u20e3\u2019s docstring emphasizes \u201cadaptive epsilon\u2011greedy\u2026near\u2011full boost and infeasibility handling.\u201d Its code stores `_epsilon`, `_epsilon_min`, `decay`, and a step counter, decays \u03b5 each call, adds a 0.5 boost when slack \u2264\u202fnear_full_thresh, and returns `\u2011inf` for infeasible bins. 2\ufe0f\u20e30\ufe0f\u20e3\u2019s docstring mentions \u201ccombines best\u2011fit and worst\u2011fit\u2026optional epsilon\u2011greedy exploration.\u201d It uses fixed `epsilon=0.1`, static `alpha=0.1`, no decay, no boost, and simply adds a small noise term. Thus the best version adapts exploration, exploits near\u2011full bins, and guards infeasibility, while the worst is static, duplicated, and lacks these refinements.  \n\n- **Comparing (second best) Heuristic\u202f2 vs (second worst) Heuristic\u202f19:** 2\ufe0f\u20e3 is identical to 1\ufe0f\u20e3 (same adaptive \u03b5, near\u2011full boost, `\u2011inf` handling). 1\ufe0f\u20e39\ufe0f\u20e3 mixes best\u2011fit (`1/(waste+1e\u201112)`) with a worst\u2011fit bias (`+\u202f\u03b1\u00b7waste`) and adds additive noise (`\u03b5\u00b7rand`). It has fixed hyper\u2011parameters and no stateful decay. The adaptive, boost\u2011oriented design of 2\ufe0f\u20e3 gives more focused exploitation and controlled exploration than the static blend of 1\ufe0f\u20e39\ufe0f\u20e3.  \n\n- **Comparing (1st) vs (2nd):** Both functions are byte\u2011for\u2011byte copies: identical docstring, attribute initialization, \u03b5\u2011decay, near\u2011full boost, and infeasibility handling. No observable difference.  \n\n- **Comparing (3rd) vs (4th):** Again exact duplicates. Both use a fixed `eps=0.1`, choose random scores with probability `eps`, otherwise rank by `1/(slack+\u03b5)`. They lack adaptive \u03b5, near\u2011full boost, and any explicit handling beyond `\u2011inf` for infeasible bins.  \n\n- **Comparing (second worst) Heuristic\u202f19 vs (worst) Heuristic\u202f20:** Identical implementations; same docstring, same static parameters, and same scoring formula. No distinction.  \n\n- **Overall:** The ranking rewards heuristics that maintain internal state (adaptive \u03b5 decay, step counter), apply domain\u2011specific boosts (near\u2011full bins), and rigorously mark infeasible bins with `\u2011inf`. Static, duplicated implementations without adaptation or specialized scoring occupy the lower ranks. Adaptive exploration and targeted exploitation consistently separate higher\u2011ranked heuristics from lower\u2011ranked ones.\n- \n- **Keywords:** dynamic \u03b5\u2011decay, stateful parameters, explicit infeasibility, problem\u2011specific boosts, best\u2011fit slack minimization, \u03b5\u2011greedy exploration.  \n- **Advice:** adopt adaptive, state\u2011aware parameters; document intent; prioritize slack\u2011minimizing best\u2011fit; apply \u03b5\u2011greedy; use infeasibility marking.  \n- **Avoid:** static duplicated code, naive worst\u2011fit, unnormalized random scoring, ignoring infeasibility, blind best\u2011fit.  \n- **Explanation:** Adaptive parameters tailor the search; statefulness avoids redundancy; slack minimization tightens solutions; \u03b5\u2011greedy balances exploitation/exploration; infeasibility marking improves feasibility handling; static code reduces flexibility.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}