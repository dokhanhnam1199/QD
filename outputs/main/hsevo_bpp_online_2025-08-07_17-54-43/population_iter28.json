[
  {
    "stdout_filepath": "problem_iter26_response0.txt_stdout.txt",
    "code_path": "problem_iter26_code0.py",
    "code": "import numpy as np\n\n# Adaptive epsilon\u2011greedy best\u2011fit with near\u2011full boost and ratio penalty\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Score bins using negative slack, a small ratio penalty, and a near\u2011full boost. Occasionally explore random bins with decaying epsilon.\"\"\"\n    if not hasattr(priority_v2, \"_epsilon\"):\n        priority_v2._epsilon = 0.2\n        priority_v2._epsilon_min = 0.01\n        priority_v2._epsilon_decay = 0.995\n        priority_v2._step = 0\n    priority_v2._step += 1\n    priority_v2._epsilon = max(\n        priority_v2._epsilon_min,\n        priority_v2._epsilon * priority_v2._epsilon_decay,\n    )\n    eps = priority_v2._epsilon\n    scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        return scores\n    slack, base = bins_remain_cap[feasible] - item, None\n    slack = bins_remain_cap[feasible] - item\n    base = -slack\n    ratio = item / bins_remain_cap[feasible]\n    ratio_weight = 0.02\n    near_full_thresh = max(0.02, 0.05 * item)\n    boost = 0.5\n    bonus = np.where(slack <= near_full_thresh, boost, 0.0)\n    deterministic = base + ratio_weight * ratio + bonus\n    if np.random.rand() < eps:\n        scores[feasible] = np.random.rand(feasible.sum())\n    else:\n        jitter = np.random.rand(feasible.sum()) * 1e-6\n        scores[feasible] = deterministic + jitter\n    return scores",
    "response_id": 0,
    "tryHS": true,
    "obj": 4.048663741523748,
    "SLOC": 31.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter26_response1.txt_stdout.txt",
    "code_path": "problem_iter26_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Simple best\u2011fit with \u03b5\u2011greedy, ratio tie\u2011breaker and capped near\u2011full boost.\"\"\"\n    feasible = bins_remain_cap >= item\n    scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    if not np.any(feasible):\n        return scores\n    slack = bins_remain_cap[feasible] - item\n    base = -slack\n    ratio = item / bins_remain_cap[feasible]\n    ratio_weight = 0.02\n    near_full_threshold = 0.05\n    near_full_boost = np.where(slack <= near_full_threshold * bins_remain_cap[feasible], 0.1, 0.0)\n    boost = np.minimum(near_full_boost, 0.2)\n    deterministic = base + ratio_weight * ratio + boost\n    epsilon = 0.05\n    if np.random.rand() < epsilon:\n        scores[feasible] = np.random.rand(feasible.sum())\n    else:\n        jitter = np.random.uniform(0, 1e-6, size=deterministic.shape)\n        scores[feasible] = deterministic + jitter\n    return scores",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.15835660151576,
    "SLOC": 20.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter26_response2.txt_stdout.txt",
    "code_path": "problem_iter26_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    n = bins_remain_cap.size\n    priorities = np.full(n, -np.inf, dtype=float)\n    feasible = bins_remain_cap >= item\n    if not feasible.any():\n        return priorities\n    idx_feas = np.where(feasible)[0]\n    slack = bins_remain_cap[feasible] - item\n    near_full_threshold = 0.1 * bins_remain_cap.max()\n    near_full_bonus = 0.5\n    jitter_scale = 1e-3\n    epsilon = 0.05\n    tie_break = idx_feas[::-1] * 1e-6\n    bonus = np.where(slack <= near_full_threshold, near_full_bonus, 0.0)\n    jitter = (np.random.rand(len(slack)) - 0.5) * jitter_scale\n    base = -slack + bonus + jitter + tie_break\n    if np.random.rand() < epsilon:\n        priorities[feasible] = np.random.rand(len(slack))\n    else:\n        priorities[feasible] = base\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 21.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter26_response3.txt_stdout.txt",
    "code_path": "problem_iter26_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    feasible = bins_remain_cap >= item\n    scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    if not np.any(feasible):\n        return scores\n    slack = bins_remain_cap[feasible] - item\n    base = -slack\n    idx = np.flatnonzero(feasible)\n    base += 1e-9 * idx\n    scores[feasible] = base\n    eps = 0.07\n    if np.random.rand() < eps:\n        chosen = np.random.choice(idx)\n        scores[chosen] += 1.0\n    return scores",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter26_response4.txt_stdout.txt",
    "code_path": "problem_iter26_code4.py",
    "code": "import numpy as np\n\n# Simple deterministic priority for online bin packing\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Score bins by negative slack after placement, add a small ratio term, and deterministic index offset for tie-breaking. Infeasible bins get -inf.\n    \"\"\"\n    n = bins_remain_cap.size\n    scores = np.full(n, -np.inf, dtype=float)\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        return scores\n    slack = bins_remain_cap[feasible] - item\n    ratio = item / bins_remain_cap[feasible]\n    ratio_weight = 0.1\n    base = -slack\n    combined = base + ratio_weight * ratio\n    idx = np.flatnonzero(feasible)\n    tie_break = 1e-9 / (idx + 1)\n    combined += tie_break\n    scores[feasible] = combined\n    return scores",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 16.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter26_response5.txt_stdout.txt",
    "code_path": "problem_iter26_code5.py",
    "code": "import numpy as np\n\n# Simple deterministic best\u2011fit priority for online bin packing.\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Deterministic best\u2011fit: prioritize smallest remaining capacity; tie\u2011break by index.\"\"\"\n    n = bins_remain_cap.size\n    scores = np.full(n, -np.inf, dtype=float)\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        return scores\n    slack = bins_remain_cap[feasible] - item\n    base = -slack\n    idx = np.flatnonzero(feasible)\n    base += idx * 1e-9  # tiny index bias for deterministic tie\u2011breaking\n    scores[feasible] = base\n    return scores",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter26_response6.txt_stdout.txt",
    "code_path": "problem_iter26_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Best-fit with near-full boost, static \u03b5\u2011greedy exploration, and deterministic tie\u2011breaking.\"\"\"\n    epsilon = 0.05\n    scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        return scores\n    slack = bins_remain_cap[feasible] - item\n    base = -slack\n    near_full_thresh = max(0.02, 0.05 * item)\n    boost = 0.5\n    base[slack <= near_full_thresh] += boost\n    idx = np.where(feasible)[0]\n    deterministic = base + 1e-9 * idx\n    if np.random.rand() < epsilon:\n        scores[feasible] = np.random.rand(slack.size)\n    else:\n        scores[feasible] = deterministic\n    return scores",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.188272836059035,
    "SLOC": 18.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter26_response7.txt_stdout.txt",
    "code_path": "problem_iter26_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Hybrid best\u2011fit priority: negative slack, capped boost, near\u2011full bonus, ratio penalty, deterministic tie\u2011break, occasional \u03b5\u2011greedy exploration.\"\"\"\n    # Identify bins that can accommodate the item\n    valid = bins_remain_cap >= item\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    if not np.any(valid):\n        return priorities\n\n    # Slack (unused space) after placing the item\n    slack = bins_remain_cap[valid] - item\n    # Base: prefer smallest slack (best\u2011fit)\n    base = -slack\n\n    # Capped boost inversely proportional to slack\n    boost_factor, max_boost, tiny = 0.5, 3.0, 1e-6\n    boost = np.minimum(boost_factor / (slack + tiny), max_boost)\n    base += boost\n\n    # Bonus for exact fit\n    base += np.isclose(slack, 0.0, atol=1e-9) * 1.0\n\n    # Near\u2011full bonus (slack \u2264 5\u202f% of bin capacity)\n    bin_capacity = np.max(bins_remain_cap)  # assumes at least one empty bin exists\n    near_full_thr, near_full_bonus = 0.05, 0.5\n    base += (slack <= near_full_thr * bin_capacity) * near_full_bonus\n\n    # Ratio penalty to discourage using bins with large free space\n    ratio_weight = 0.2\n    base -= ratio_weight * (bins_remain_cap[valid] / bin_capacity)\n\n    # Deterministic jitter based on bin index for tie\u2011breaking\n    jitter_scale = 1e-4\n    idxs = np.flatnonzero(valid)\n    base += idxs * jitter_scale\n\n    priorities[valid] = base\n\n    # Adaptive \u03b5\u2011greedy: occasionally boost a random feasible bin\n    epsilon_base = 0.1\n    feasible, total = valid.sum(), bins_remain_cap.size\n    epsilon = epsilon_base * (1 - feasible / total)\n    if feasible and np.random.rand() < epsilon:\n        rand_idx = np.random.choice(idxs)\n        priorities[rand_idx] += 0.5  # exploration bonus\n\n    return priorities",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 27.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter26_response8.txt_stdout.txt",
    "code_path": "problem_iter26_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Score bins by negative slack, near\u2011full & exact\u2011fit boosts, ratio penalty, dead\u2011space filter, and capped inverse slack.\"\"\"\n    n = bins_remain_cap.size\n    scores = np.full(n, -np.inf, dtype=float)\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        return scores\n    slack = bins_remain_cap[feasible] - item\n    base = -slack\n    near_full_thr = max(0.01, 0.03 * item)\n    near_full_boost = np.where(slack <= near_full_thr, 0.5, 0.0)\n    exact_boost = np.where(np.isclose(slack, 0.0, atol=1e-9), 1.0, 0.0)\n    ratio = item / bins_remain_cap[feasible]\n    ratio_penalty = 0.3 * ratio\n    max_cap = bins_remain_cap.max()\n    dead_thr = max_cap * 0.01\n    dead_space = (slack > 0) & (slack < dead_thr)\n    dead_penalty = np.where(dead_space, -2.0, 0.0)\n    smooth_boost = np.minimum(0.5 / (slack + 1e-12), 5.0)\n    scores[feasible] = base + near_full_boost + exact_boost = base + near_full_boost + exact_boost - ratio_penalty + dead_penalty + smooth_boost\n    return scores",
    "response_id": 8,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 9, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 22\n    scores[feasible] = base + near_full_boost + exact_boost = base + near_full_boost + exact_boost - ratio_penalty + dead_penalty + smooth_boost\n                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: cannot assign to expression\nTraceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/SLOC.py\", line 7, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 22\n    scores[feasible] = base + near_full_boost + exact_boost = base + near_full_boost + exact_boost - ratio_penalty + dead_penalty + smooth_boost\n                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: cannot assign to expression\nTraceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/cyclomatic_complexity.py\", line 7, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 22\n    scores[feasible] = base + near_full_boost + exact_boost = base + near_full_boost + exact_boost - ratio_penalty + dead_penalty + smooth_boost\n                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: cannot assign to expression\n"
  },
  {
    "stdout_filepath": "problem_iter26_response9.txt_stdout.txt",
    "code_path": "problem_iter26_code9.py",
    "code": "import numpy as np\n\n# deterministic best\u2011fit scoring with slack, ratio penalty, near\u2011full boost and index tie\u2011breaker\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Deterministic best\u2011fit scoring with negative slack base, item/remaining ratio penalty, near\u2011full boost, and index offset tie\u2011breaker.\"\"\"\n    valid = bins_remain_cap >= item\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    if not np.any(valid):\n        return priorities\n    slack = bins_remain_cap[valid] - item\n    base = -slack\n    ratio = item / bins_remain_cap[valid]\n    base += 0.05 * ratio\n    base += (slack <= 0.05 * bins_remain_cap[valid]) * 0.5\n    idx = np.flatnonzero(valid)\n    base += 1e-6 * idx\n    priorities[valid] = base\n    return priorities",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 14.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter27_response0.txt_stdout.txt",
    "code_path": "problem_iter27_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    slack = bins_remain_cap - item\n    eps = 1e-12\n    tie_break = eps * np.arange(bins_remain_cap.size)\n    return np.where(slack >= 0, -slack - tie_break, -np.inf)",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter28_response0.txt_stdout.txt",
    "code_path": "problem_iter28_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    epsilon_initial: float = 0.9756100440469143,\n    epsilon_min: float = 0.3969712981652447,\n    epsilon_decay: float = 0.9946724161595234,\n    ratio_weight: float = 0.028269689818119448,\n    near_full_thresh_const: float = 0.08392783746092114,\n    near_full_thresh_factor: float = 0.17790197457083207,\n    boost: float = 1.1754640891512518,\n    jitter_scale: float = 8.633295903113424e-05,\n) -> np.ndarray:\n    \"\"\"Score bins using negative slack, a small ratio penalty, and a near\u2011full boost.\n    Occasionally explore random bins with decaying epsilon.\"\"\"\n    # Initialise epsilon state on first call\n    if not hasattr(priority_v2, \"_epsilon\"):\n        priority_v2._epsilon = epsilon_initial\n        priority_v2._epsilon_min = epsilon_min\n        priority_v2._epsilon_decay = epsilon_decay\n        priority_v2._step = 0\n    priority_v2._step += 1\n\n    # Decay epsilon\n    priority_v2._epsilon = max(\n        priority_v2._epsilon_min,\n        priority_v2._epsilon * priority_v2._epsilon_decay,\n    )\n    eps = priority_v2._epsilon\n\n    scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        return scores",
    "response_id": 0,
    "tryHS": true,
    "obj": 4.487435181491823,
    "SLOC": 27.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  }
]