[
  {
    "stdout_filepath": "problem_iter1_response0.txt_stdout.txt",
    "code_path": "problem_iter1_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"First Fit priority: higher score for earlier feasible bins.\"\"\"\n    idx = np.arange(bins_remain_cap.shape[0])\n    feasible = bins_remain_cap >= item\n    priorities = np.where(feasible, -idx, -np.inf)\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response1.txt_stdout.txt",
    "code_path": "problem_iter1_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    fit = bins_remain_cap - item\n    priorities = np.where(fit >= 0, -fit, -np.inf)\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response2.txt_stdout.txt",
    "code_path": "problem_iter1_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority for each bin using the Worst Fit strategy.\"\"\"\n    fit = bins_remain_cap >= item\n    return np.where(fit, bins_remain_cap, -np.inf)",
    "response_id": 2,
    "tryHS": false,
    "obj": 149.30195452732352,
    "SLOC": 3.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response3.txt_stdout.txt",
    "code_path": "problem_iter1_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Almost Full Fit: prioritize bins that leave the smallest slack after adding the item.\"\"\"\n    fits = bins_remain_cap >= item\n    slack = bins_remain_cap - item\n    priorities = np.where(fits, -slack, -np.inf)\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response4.txt_stdout.txt",
    "code_path": "problem_iter1_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Exact Fit First priority for online bin packing.\"\"\"\n    diff = bins_remain_cap - diff? Let's correct:",
    "response_id": 4,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 9, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 5\n    diff = bins_remain_cap - diff? Let's correct:\n                                      ^\nSyntaxError: unterminated string literal (detected at line 5)\nTraceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/SLOC.py\", line 7, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 5\n    diff = bins_remain_cap - diff? Let's correct:\n                                      ^\nSyntaxError: unterminated string literal (detected at line 5)\nTraceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/cyclomatic_complexity.py\", line 7, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 5\n    diff = bins_remain_cap - diff? Let's correct:\n                                      ^\nSyntaxError: unterminated string literal (detected at line 5)\n"
  },
  {
    "stdout_filepath": "problem_iter1_response5.txt_stdout.txt",
    "code_path": "problem_iter1_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    eps = 1e-9\n    capacities = bins_remain_cap.astype(float) - item\n    return np.where(capacities >= 0, 1.0 / (capacities + eps), 0.0)",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response6.txt_stdout.txt",
    "code_path": "problem_iter1_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    mask = bins_remain_cap >= item\n    ratio = np.empty_like(bins_remain_cap, dtype=np.float64)\n    ratio.fill(0.0)\n    ratio[mask] = item / bins_remain_cap[mask]\n    if mask.any():\n        t = np.percentile(ratio[mask], 80)\n    else:\n        t = 0.5\n    k = 15.0\n    priority = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)\n    priority[mask] = 1.0 / (1.0 + np.exp(-k * (ratio[mask] - t)))\n    return priority",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response7.txt_stdout.txt",
    "code_path": "problem_iter1_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Random Fit priority: assign equal random priority to all bins that can accommodate the item.\"\"\"\n    feasible = bins_remain_cap >= item\n    priorities = np.where(feasible, np.random.random(random_state=None, size=bins_remain_cap.shape), -np.inf)\n    return priorities",
    "response_id": 7,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 6, in priority_v2\n    if np.random.rand() < eps:\n  File \"numpy/random/mtrand.pyx\", line 443, in numpy.random.mtrand.RandomState.random\nTypeError: random() got an unexpected keyword argument 'random_state'\n4\n1\n"
  },
  {
    "stdout_filepath": "problem_iter1_response8.txt_stdout.txt",
    "code_path": "problem_iter1_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    eps = 0.1\n    n = bins_remain_cap.size\n    if np.random.rand() < eps:\n        return np.random.random(n)\n    priorities = -np.inf * np.ones_like(bins_remain_cap, dtype=float)\n    valid = bins_remain_cap >= item\n    priorities[valid] = -(bins_remain_cap[valid] - item)\n    return priorities",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.038691663342641,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response9.txt_stdout.txt",
    "code_path": "problem_iter1_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, temperature: float = 0.5) -> np.ndarray:\n    \"\"\"Softmax-based fit priority for online bin packing.\n\n    Args:\n        item: Size of the incoming item.\n        bins_remain_cap: Remaining capacities of each bin.\n        temperature: Softmax temperature controlling exploration vs exploitation.\n\n    Returns:\n        Priority scores for each bin, summing to 1 if any bin can accommodate the item.\n    \"\"\"\n    can_fit = bins_remain_cap >= item\n    leftover = bins_remain_cap - item\n    safe_temp = max(temperature, 1e-8)\n    scores = np.exp(-leftover / safe_temp) * can_fit\n    total = scores.sum()\n    priorities = scores / total if total > 0 else scores\n    return priorities",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response10.txt_stdout.txt",
    "code_path": "problem_iter1_code10.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    n = bins_remain_cap.shape[0]\n    idx = np.arange(n, dtype=float)\n    scores = -idx\n    return np.where(bins_remain_cap >= item, scores, -np.inf)",
    "response_id": 10,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response11.txt_stdout.txt",
    "code_path": "problem_iter1_code11.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    residual = bins_remain_cap - item\n    feasible = residual >= 0\n    priority = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    priority[feasible] = -residual[feasible]\n    return priority",
    "response_id": 11,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response12.txt_stdout.txt",
    "code_path": "problem_iter1_code12.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    valid = bins_remain_cap >= item\n    priorities = np.where(valid, bins_remain_cap, -np.inf)\n    return priorities",
    "response_id": 12,
    "tryHS": false,
    "obj": 149.30195452732352,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response13.txt_stdout.txt",
    "code_path": "problem_iter1_code13.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    fit = bins_remain_cap >= item\n    return np.where(fit, -(bins_remain_cap - item), -np.inf)",
    "response_id": 13,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 3.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response14.txt_stdout.txt",
    "code_path": "problem_iter1_code14.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\"\"\"\n    feasible = bins_remain_cap >= item\n    waste = bins_remain_cap - item\n    priorities = np.where(feasible, 1.0/(waste + 1e-12), -np.inf)\n    return priorities",
    "response_id": 14,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response15.txt_stdout.txt",
    "code_path": "problem_iter1_code15.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    eps = np.finfo(float).eps\n    can_fit = bins_remain_cap >= item\n    diff = np.where(can_fit, bins_remain_cap - item, np.inf)\n    priorities = np.where(can_fit, 1.0 / (diff + eps), 0.0)\n    return priorities",
    "response_id": 15,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response16.txt_stdout.txt",
    "code_path": "problem_iter1_code16.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    free = bins_remain_cap - item\n    fit = free >= 0\n    priorities = np.zeros_like(bins_remain_cap)\n    if fit.any():\n        f = free[fit]\n        max_f = f.max()\n        norm = (max_f - f) / (max_f + 1e-9)\n        priorities[fit] = 1.0 / (1.0 + np.exp(-12.0 * norm))\n        priorities[(fit) & (free == 0)] = 1.0\n    return priorities",
    "response_id": 16,
    "tryHS": false,
    "obj": 4.198244914240141,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response17.txt_stdout.txt",
    "code_path": "problem_iter1_code17.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Random Fit priority: assign random scores to bins that can accommodate the item.\"\"\"\n    feasible = bins_remain_cap >= item\n    priorities = np.full(bins_remain_cap.shape, -np.inf, dtype=float)\n    priorities[feasible] = np.random.rand(feasible.sum())\n    return priorities",
    "response_id": 17,
    "tryHS": false,
    "obj": 73.48424411647389,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response18.txt_stdout.txt",
    "code_path": "problem_iter1_code18.py",
    "code": "import numpy as np\n\nEPSILON = 0.05\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.full(bins_remain_cap.shape, -np.inf, dtype=float)\n    fit_mask = bins_remain_cap >= item\n    if np.random.random() < EPSILON:\n        rand_scores = np.random.rand(np.count_nonzero(fit_mask))\n        priorities[fit_mask] = rand_scores\n    else:\n        waste = bins_remain_cap[fit_mask] - item\n        priorities[fit_mask] = -waste\n    return priorities",
    "response_id": 18,
    "tryHS": false,
    "obj": 4.078579976067022,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response19.txt_stdout.txt",
    "code_path": "problem_iter1_code19.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    slack = bins_remain_cap - item\n    mask = slack >= 0\n    weights = np.full(bins_remain_cap.shape, -np.inf, dtype=float)\n    weights[mask] = -slack[mask]\n    if not mask.any():\n        return np.zeros_like(bins_remain_cap, dtype=float)\n    max_w = np.max(weights)\n    exp_w = np.exp(weights - max_w)\n    return exp_w / exp_w.sum()",
    "response_id": 19,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response20.txt_stdout.txt",
    "code_path": "problem_iter1_code20.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    fits = bins_remain_cap >= item\n    idx = np.arange(bins_remain_cap.shape[0])\n    priorities = np.where(fits, 1.0/(idx + 1), 0.0)\n    return priorities",
    "response_id": 20,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response21.txt_stdout.txt",
    "code_path": "problem_iter1_code21.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority for each bin using a Best Fit strategy.\"\"\"\n    overflow = bins_remain_cap - item\n    mask = overflow >= 0\n    priority = np.full(bins_remain_cap.shape, -np.inf, dtype=float)\n    idx = np.arange(bins_remain_cap.shape[0])\n    priority[mask] = -overflow[mask] - 1e-9 * idx[mask]\n    return priority",
    "response_id": 21,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response22.txt_stdout.txt",
    "code_path": "problem_iter1_code22.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority scores for worst-fit bin packing.\"\"\"\n    mask = bins_remain_cap >= item\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    priorities[mask] = bins_remain_cap[mask] - item\n    return priorities",
    "response_id": 22,
    "tryHS": false,
    "obj": 149.30195452732352,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response23.txt_stdout.txt",
    "code_path": "problem_iter1_code23.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    residual = bins_remain_cap - item\n    feasible = residual >= 0\n    priorities = np.where(feasible, -residual, -np.inf)\n    return priorities",
    "response_id": 23,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response24.txt_stdout.txt",
    "code_path": "problem_iter1_code24.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    waste = bins_remain_cap - item\n    priorities = np.where(waste >= 0, -waste, -np.inf)\n    return priorities",
    "response_id": 24,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response25.txt_stdout.txt",
    "code_path": "problem_iter1_code25.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Inverse Distance (Proximity Fit) priority for online bin packing.\"\"\"\n    eps = 1e-12\n    residual = bins_remain_cap - item\n    feasible = residual >= 0\n    priorities = np.where(feasible, 1.0 / (residual + eps), -np.inf)\n    return priorities",
    "response_id": 25,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response26.txt_stdout.txt",
    "code_path": "problem_iter1_code26.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin using a sigmoid fit.\n    \"\"\"\n    k = 1.0\n    eligible = bins_remain_cap >= item\n    residual = bins_remain_cap - item\n    scores = np.full_like(bins_remain_cap, -1e6, dtype=float)\n    scores[eligible] = np.exp(-k * residual[eligible])\n    return scores",
    "response_id": 26,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response27.txt_stdout.txt",
    "code_path": "problem_iter1_code27.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    mask = bins_remain_cap >= item\n    priorities = np.where(mask, np.random.rand(bins_remain_cap.shape[0]), -np.inf)\n    return priorities",
    "response_id": 27,
    "tryHS": false,
    "obj": 73.71360191463901,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response28.txt_stdout.txt",
    "code_path": "problem_iter1_code28.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.1) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using epsilon-greedy.\"\"\"\n    n = bins_remain_cap.shape[0]\n    priorities = np.full(n, -np.inf, dtype=float)\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        return priorities\n    waste = bins_remain_cap[feasible] - item\n    bestfit = -waste\n    rand_vals = np.random.rand(bestfit.size)\n    explore = np.random.rand(bestfit.size) < epsilon\n    combined = np.where(explore, rand_vals, bestfit)\n    priorities[feasible] = combined\n    return priorities",
    "response_id": 28,
    "tryHS": false,
    "obj": 73.06541683286798,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response29.txt_stdout.txt",
    "code_path": "problem_iter1_code29.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Softmax-based priority for online BPP.\n\n    Feasible bins receive a score proportional to the exponential of the\n    remaining capacity after placing the item, then normalised by softmax.\n    Infeasible bins receive a priority of zero.\n    \"\"\"\n    bin_arr = np.asarray(bins_remain_cap, dtype=float)\n    delta = bin_arr - item\n    feasible = delta >= 0\n    scores = np.zeros_like(bin_arr)\n    if np.any(feasible):\n        shift = np.max(delta[feasible])\n        exp_vals = np.exp(delta[feasible] - shift)\n        probs = exp_vals / exp_vals.sum()\n        scores[feasible] = probs\n    return scores",
    "response_id": 29,
    "tryHS": false,
    "obj": 149.30195452732352,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  }
]