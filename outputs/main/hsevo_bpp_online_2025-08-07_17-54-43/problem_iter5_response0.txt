```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Adaptive ε‑greedy best‑fit with worst‑fit bias and near‑full boost."""
    # initialize static parameters
    if not hasattr(priority_v2, "epsilon"):
        priority_v2.epsilon = 0.2          # initial exploration rate
        priority_v2.epsilon_min = 0.01    # lower bound
        priority_v2.decay = 0.99          # exponential decay factor
        priority_v2.near_full_thresh = 0.05   # slack threshold for boost
        priority_v2.near_full_boost = 0.5     # extra score for near‑full bins
        priority_v2.worst_fit_weight = 0.01  # bias toward larger remaining capacity

    # decay exploration rate
    priority_v2.epsilon = max(priority_v2.epsilon_min,
                              priority_v2.epsilon * priority_v2.decay)

    slack = bins_remain_cap - item
    feasible = slack >= 0
    scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    if np.random.rand() < priority_v2.epsilon:
        # exploration: random scores for feasible bins
        scores[feas] = np.random.rand(np.count_nonzero(feasible))
    else:
        # exploitation: best‑fit (-slack) + worst‑fit bias
        scores[feasible] = -slack[feasible] + priority_v2.worst_fit_weight * bins_remain_cap[feasible]
        # near‑full boost
        near_full = feasible & (slack <= priority_v2.near_full_thresh)
        scores[near_full] += priority_v2.near_full_boost

    return scores
```
