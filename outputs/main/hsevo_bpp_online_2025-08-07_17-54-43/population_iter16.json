[
  {
    "stdout_filepath": "problem_iter14_response0.txt_stdout.txt",
    "code_path": "problem_iter14_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Scores bins by best-fit with inverse slack, near-full and exact-fit boosts, epsilon-greedy exploration, and jitter.\n    \"\"\"\n    eps = 0.1\n    scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    feasible = bins_remain_cap >= item\n    if not feasible.any():\n        return scores\n    if np.random.rand() < eps:\n        scores[feasible] = np.random.rand(feasible.sum())\n        return scores\n    slack = bins_remain_cap[feasible] - item\n    base = 1.0 / (slack + 1e-9)\n    near_full = slack <= 0.05 * item\n    base[near_full] += 0.5\n    exact = np.isclose(slack, 0, atol=1e-9)\n    base[exact] += 1.0\n    base += 0.01 * np.random.rand(len(base))\n    scores[feasible] = base\n    return scores",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.1284403669724865,
    "SLOC": 18.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response1.txt_stdout.txt",
    "code_path": "problem_iter14_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Best\u2011fit scoring with inverse\u2011slack boost and adaptive \u03b5\u2011greedy tie\u2011breaker.\"\"\"\n    n = bins_remain_cap.size\n    feasible = bins_remain_cap >= item\n    scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    if not np.any(feasible):\n        return scores\n    slack = bins_remain_cap - item\n    base = -slack[feasible]\n    tiny = 1e-6\n    boost_factor = 0.5\n    max_boost = 5.0\n    boost = boost_factor / (slack[feasible] + tiny)\n    boost = np.minimum(boost, max_boost)\n    scores[feasible] = base + boost\n    eps = 0.05 * (1 - np.count_nonzero(feasible) / n)\n    if np.random.rand() < eps:\n        idx = np.random.choice(np.flatnonzero(feasible))\n        scores[idx] += 1e-3\n    return scores",
    "response_id": 1,
    "tryHS": true,
    "obj": 4.048663741523748,
    "SLOC": 19.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response2.txt_stdout.txt",
    "code_path": "problem_iter14_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Inverse\u2011slack scoring with \u03b5\u2011greedy random exploration and softmax normalization.\"\"\"\n    epsilon = 0.05\n    n = bins_remain_cap.shape[0]\n    scores = np.full(n, -np.inf, dtype=float)\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        return scores\n    slack = bins_remain_cap[feasible] - item\n    base = 1.0 / (slack + 1e-12)\n    if np.random.rand() < epsilon:\n        base = np.random.rand(base.shape[0])\n    max_val = np.max(base)\n    exp_vals = np.exp(base - max_val)\n    probs = exp_vals / np.sum(exp_vals)\n    scores[feasible] = probs\n    return scores",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.208216992421225,
    "SLOC": 16.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response3.txt_stdout.txt",
    "code_path": "problem_iter14_code3.py",
    "code": "import numpy as np\n\n# Priority function for online bin packing: best\u2011fit with \u03b5\u2011greedy fallback and softmax.\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Score bins by item/remaining capacity, occasional \u03b5\u2011greedy random pick, softmax output.\"\"\"\n    eps = 0.05\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        return np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    if np.random.rand() < eps:\n        scores = np.random.rand(bins_remain_cap.shape[0])\n        scores[~feasible] = -np.inf\n        return scores\n    raw = np.where(feasible, item / bins_remain_cap, -np.inf)\n    max_raw = np.max(raw)\n    exp_vals = np.exp(raw - max_raw)\n    probs = exp_vals / np.sum(exp_vals)\n    return probs",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.178300757877951,
    "SLOC": 14.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response4.txt_stdout.txt",
    "code_path": "problem_iter14_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Best\u2011fit: negative slack + inverse\u2011slack boost, adaptive \u03b5\u2011greedy tie\u2011break.\"\"\"\n    valid = bins_remain_cap >= item\n    n = bins_remain_cap.size\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    if not np.any(valid):\n        return priorities\n\n    slack = bins_remain_cap[valid] - item\n    base = -slack\n\n    boost_factor = 0.5\n    tiny = 1e-6\n    max_boost = 5.0\n    boost = boost_factor / (slack + tiny)\n    boost = np.minimum(boost, max_boost)\n\n    priorities[valid] = base + boost\n\n    epsilon_factor = 0.1\n    epsilon = epsilon_factor * (1 - np.count_nonzero(valid) # wait, bug.\n\nWe need to fix that.\n\nActually:\n\nepsilon = epsilon_factor * (1 - np.count_nonzero(valid) / n)\n\nOk.\n\nNow if random < epsilon, tie break: select random valid bin, add small tie_breaker.\n\nAdd:\n\ntie_breaker = 1e-3\n\nif np.random.rand() < epsilon:\n    idx = np.random.choice(np.flatnonzero(valid))\n    priorities[idx] += tie_breaker\n\nReturn priorities.\n\nLet's produce final correct code.",
    "response_id": 4,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 9, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 46\n    Let's produce final correct code.\n       ^\nSyntaxError: unterminated string literal (detected at line 46)\nTraceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/SLOC.py\", line 7, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 46\n    Let's produce final correct code.\n       ^\nSyntaxError: unterminated string literal (detected at line 46)\nTraceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/cyclomatic_complexity.py\", line 7, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 46\n    Let's produce final correct code.\n       ^\nSyntaxError: unterminated string literal (detected at line 46)\n"
  },
  {
    "stdout_filepath": "problem_iter14_response5.txt_stdout.txt",
    "code_path": "problem_iter14_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Best\u2011fit heuristic: fill ratio + small inverse\u2011slack boost, \u03b5\u2011greedy, softmax probabilities.\"\"\"\n    epsilon = 0.05\n    scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        return scores\n    slack = bins_remain_cap[feasible] - item\n    fill_ratio = item / bins_remain_cap[feasible]\n    inv_slack = 1.0 / (slack + 1e-12)\n    inv_norm = inv_slack / (inv_slack.max() + 1e-12)\n    alpha = 0.1\n    base = fill_ratio + alpha * inv_norm\n    scores[feasible] = base\n    if np.random.rand() < epsilon:\n        scores[feasible] = np.random.rand(feasible.sum())\n    max_score = np.max(scores[feasible])\n    exp_scores = np.zeros_like(scores)\n    exp_scores[feasible] = np.exp and np.exp(scores[feasible] - max_score)\n    total = exp_scores.sum()\n    if total > 0:\n        exp_scores /= total\n    return exp_scores",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.068607897885915,
    "SLOC": 22.0,
    "cyclomatic_complexity": 5.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response6.txt_stdout.txt",
    "code_path": "problem_iter14_code6.py",
    "code": "import numpy as np\n\n# best\u2011fit with slack, exact\u2011fit boost, jitter, and adaptive epsilon\u2011greedy\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best\u2011fit, exact\u2011fit boost, near\u2011full boost, jitter, and adaptive epsilon\u2011greedy.\"\"\"\n    valid = bins_remain_cap >= item\n    n = bins_remain_cap.size\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    if np.any(valid):\n        slack = bins_remain_cap[valid] - item\n        base = -slack / bins_remain_cap[valid]\n        base[np.isclose(slack, 0.0, atol=1e-9)] += 1.0\n        base[slack <= 0.05 * bins_remain_cap[valid]] += 0.5\n        base += (np.random.rand(valid.sum()) - 0.5) * 0.01\n        priorities[valid] = base\n        valid_count = np.count_nonzero(valid)\n        epsilon = 0.05 * (1 - valid_count / n)\n        if np.random.rand() < epsilon:\n            idx = np.random.choice(np.flatnonzero(valid))\n            priorities[idx] += 1.0\n    return priorities",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 17.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response7.txt_stdout.txt",
    "code_path": "problem_iter14_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Normalized fill ratio scoring with static \u03b5\u2011greedy random fallback and softmax.\"\"\"\n    feasible = bins_remain_cap >= item\n    scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    if not feasible.any():\n        return scores\n    scores[feasible] = item / bins_remain_cap[feasible]\n    epsilon = 0.05\n    if np.random.rand() < epsilon:\n        rand = np.random.rand(bins_remain_cap.size)\n        rand[~feasible] = -np.inf\n        scores = rand\n    max_score = np.max(scores[feasible])\n    exp_scores = np.exp(scores - max_score)\n    probs = exp_scores / np.sum(exp_scores)\n    return probs",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.1284403669724865,
    "SLOC": 15.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response8.txt_stdout.txt",
    "code_path": "problem_iter14_code8.py",
    "code": "import numpy as np\n\n# Priority function for online bin packing\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Return priority scores combining best-fit, smooth near\u2011full boost,\n    exact\u2011fit bonus, and adaptive \u03b5\u2011greedy exploration.\n    \"\"\"\n    n = bins_remain_cap.size\n    valid = bins_remain_cap >= item\n    scores = np.full(n, -np.inf, dtype=float)\n    if not valid.any():\n        return scores\n\n    slack = bins_remain_cap[valid] - item\n    tiny = 1e-6\n    smooth_boost = 0.5 / (slack + tiny)\n    smooth_boost = np.minimum(smooth_boost, 5.0)\n\n    base = -slack\n    threshold = max(0.02, 0.05 * item)\n    near_full_mask = slack <= threshold\n    exact_mask = np.isclose(slack, 0.0, atol=1e-9)\n\n    near_full_boost = 0.5\n    exact_fit_boost = 1.0\n    scores[valid] = base + smooth_boost + near_full_boost * near_full_mask + exact_fit_boost * exact_mask\n\n    # adaptive epsilon-greedy exploration\n    epsilon_factor = 0.5\n    tie_breaker = 1.0\n    epsilon = epsilon_factor * (1 - np.count_nonzero(valid) / n)\n    if np.random.rand() < epsilon:\n        idx = np.random.choice(np.flatnonzero(valid))\n        scores[idx] += tie_breaker\n\n    return scores",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 24.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response9.txt_stdout.txt",
    "code_path": "problem_iter14_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Static epsilon\u2011greedy best\u2011fit using occupancy fraction and softmax.\"\"\"\n    epsilon = 0.05\n    capacity = 1.0\n    n = bins_remain_cap.shape[0]\n    priorities = np.full(n, -np.inf, dtype=float)\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        return priorities\n    if np.random.rand() < epsilon:\n        rand_scores = np.full(n, -np.inf, dtype=float)\n        rand_scores[...]? Wait\n\nWe need to correct the code. Let's write final version correctly.",
    "response_id": 9,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 9, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 16\n    We need to correct the code. Let's write final version correctly.\n                                    ^\nSyntaxError: unterminated string literal (detected at line 16)\nTraceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/SLOC.py\", line 7, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 16\n    We need to correct the code. Let's write final version correctly.\n                                    ^\nSyntaxError: unterminated string literal (detected at line 16)\nTraceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/cyclomatic_complexity.py\", line 7, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 16\n    We need to correct the code. Let's write final version correctly.\n                                    ^\nSyntaxError: unterminated string literal (detected at line 16)\n"
  },
  {
    "stdout_filepath": "problem_iter15_response0.txt_stdout.txt",
    "code_path": "problem_iter15_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    epsilon = 0.05\n    n = bins_remain_cap.size\n    valid = bins_remain_cap >= item\n    if not np.any(valid):\n        return np.full(n, -np.inf, dtype=float)\n    if np.random.rand() < epsilon:\n        rand = np.random.rand(n)\n        rand[~valid] = 0.0\n        return rand / np.sum(rand)\n    scores = np.full(n, -np.inf, dtype=float)\n    scores[valid] = 1.0 - bins_remain_cap[valid] + item\n    max_score = np.max(scores[valid])\n    exp_scores = np.exp(scores - max_score)\n    probs = exp_scores / np.sum(exp_scores)\n    return probs",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.15835660151576,
    "SLOC": 16.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter16_response0.txt_stdout.txt",
    "code_path": "problem_iter16_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float,\n                bins_remain_cap: np.ndarray,\n                tiny: float = 0.0007848497650477602,\n                boost_factor: float = 1.3967578901660225,\n                max_boost: float = 7.106616957581014,\n                eps_factor: float = 0.23908247190719145,\n                tie_break_boost: float = 0.07221130143884012) -> np.ndarray:\n    \"\"\"Best\u2011fit scoring with inverse\u2011slack boost and adaptive \u03b5\u2011greedy tie\u2011breaker.\n\n    Parameters\n    ----------\n    item : float\n        Size of the item to pack.\n    bins_remain_cap : np.ndarray\n        Remaining capacities of the bins.\n    tiny : float, optional\n        Small constant to avoid division by zero in the boost term.\n    boost_factor : float, optional\n        Multiplicative factor for the inverse\u2011slack boost.\n    max_boost : float, optional\n        Upper bound for the boost term.\n    eps_factor : float, optional\n        Scaling factor for the adaptive epsilon\u2011greedy exploration probability.\n    tie_break_boost : float, optional\n        Small deterministic boost added to a randomly chosen feasible bin\n        when the epsilon\u2011greedy condition is triggered.\n    \"\"\"\n    n = bins_remain_cap.size\n    feasible = bins_remain_cap >= item\n    scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    if not np.any(feasible):\n        return scores",
    "response_id": 0,
    "tryHS": true,
    "obj": 4.487435181491823,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  }
]