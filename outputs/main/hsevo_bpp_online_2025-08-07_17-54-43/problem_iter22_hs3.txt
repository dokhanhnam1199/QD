import numpy as np

def priority_v2(item: float,
                bins_remain_cap: np.ndarray,
                ratio_weight: float = 1.088817546582848,
                jitter_scale: float = 0.0008386746772738066,
                epsilon: float = 0.01600904441689499) -> np.ndarray:
    """Score bins by tightness (best‑fit) plus capacity‑ratio; optional ε‑greedy exploration.

    Parameters
    ----------
    item : float
        Size of the item to place.
    bins_remain_cap : np.ndarray
        Remaining capacities of bins.
    ratio_weight : float, optional
        Weight applied to the capacity‑ratio component of the score.
    jitter_scale : float, optional
        Scale of the random jitter added to break ties.
    epsilon : float, optional
        Probability of performing random exploration (ε‑greedy).
    """
    n = bins_remain_cap.size
    feasible = bins_remain_cap >= item
    priorities = np.full(n, -np.inf, dtype=float)   # infeasible bins get -inf
    if not np.any(feasible):
        return priorities

    slack = bins_remain_cap[feasible] - item       # remaining space after placing
    base = -slack                                   # best‑fit: smaller slack → higher score
    ratio = item / bins_remain_cap[feasible]       # capacity‑ratio: tighter fit → higher score

    scores = base + ratio_weight * ratio           # combine both components
    scores += np.random.rand(scores.shape[0]) * jitter_scale  # tiny jitter to break ties

    priorities[feasible] = scores

    if np.random.rand() < epsilon:
        priorities[feasible] = np.random.rand(scores.shape[0])

    return priorities
