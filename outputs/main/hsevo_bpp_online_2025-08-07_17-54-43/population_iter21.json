[
  {
    "stdout_filepath": "problem_iter20_response0.txt_stdout.txt",
    "code_path": "problem_iter20_code0.py",
    "code": "import numpy as np\n\n# Priority for online bin packing: best\u2011fit core, ratio weight, near\u2011full & exact\u2011fit boosts,\n# static \u03b5\u2011greedy exploration, and tiny jitter for tie\u2011breaking.\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Best\u2011fit priority using negative slack, ratio weighting, near\u2011full & exact\u2011fit boosts, static \u03b5\u2011greedy, jitter.\"\"\"\n    feasible = bins_remain_cap >= item\n    priorities = np.full(bins_remain_cap.shape, -np.inf, dtype=float)\n    if not np.any(feasible):\n        return priorities\n    slack = bins_remain_cap[feasible] - item\n    base = -slack\n    ratio = item / bins_remain_cap[feasible]\n    ratio_weight = 0.1\n    near_full_thresh = max(0.02, 0.05 * item)\n    boost = np.zeros_like(base)\n    boost[slack <= near_full_thresh] += 0.5\n    boost[slack <= 1e-9] += 1.0\n    deterministic = base + ratio_weight * ratio + boost\n    deterministic += 1e-6 * np.random.rand(deterministic.size)\n    epsilon = 0.05\n    if np.random.rand() < epsilon:\n        rand_scores = np.random.rand(bins_remain_cap.size)\n        rand_scores[~feasible] = -np.inf\n        priorities = rand_scores\n    else:\n        priorities[feasible] = deterministic\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.11846828879138,
    "SLOC": 23.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response1.txt_stdout.txt",
    "code_path": "problem_iter20_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Best\u2011fit slack with capped boost, exact/near\u2011full bonuses, jitter, \u03b5\u2011greedy.\"\"\"\n    # Feasibility mask\n    valid = bins_remain_cap >= item\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    if not np.any(valid):\n        return priorities\n\n    # Slack and base score (prefer smaller slack)\n    slack = bins_remain_cap[valid] - item\n    base = -slack\n\n    # Capped boost inversely proportional to slack\n    boost_factor = 0.5\n    max_boost = 3.0\n    tiny = 1e-6\n    boost = np.minimum(boost_factor / (slack + tiny), max_boost)\n    base += boost\n\n    # Exact\u2011fit and near\u2011full bonuses\n    base += np.isclose(slack, 0.0, atol=1e-9) * 1.0\n    base += (slack <= 0.05 * bins_remain_cap[valid]) * 0.5\n\n    # Tiny jitter for tie\u2011breaking\n    base += (np.random.rand(valid.sum()) - 0.5) * 1e-6\n\n    priorities[valid] = base\n\n    # Adaptive \u03b5\u2011greedy exploration\n    n = bins_remain_cap.size\n    feasible = valid.sum()\n    epsilon = 0.05 * (1 - feasible / n)\n    if feasible and np.random.rand() < epsilon:\n        idx = np.random.choice(np.flatnonzero(valid))\n        priorities[idx] += 1.0\n\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 23.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response2.txt_stdout.txt",
    "code_path": "problem_iter20_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Best-fit slack with capped boost and ratio weighting for online bin packing.\"\"\"\n    n = bins_remain_cap.size\n    feasible = bins_remain_cap >= item\n    scores = np.full(n, -np.inf, dtype=float)\n    if not np.any(feasible):\n        return scores\n    slack = bins_remain_cap[feasible] - item\n    base = -slack\n    boost_factor = 0.5\n    max_boost = 5.0\n    tiny = 1e-6\n    boost = np.minimum(boost_factor / (slack + tiny), max_boost)\n    ratio = item / bins_remain_cap[feasible]\n    combined = base + boost + 0.1 * ratio\n    idx = np.flatnonzero(feasible)\n    combined += 1e-9 * idx\n    scores[feasible] = combined\n    return scores",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 18.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response3.txt_stdout.txt",
    "code_path": "problem_iter20_code3.py",
    "code": "import numpy as np\n\n# Priority function for online bin packing: combines best\u2011fit slack, capacity ratio,\n# a near\u2011full bonus, and a tiny deterministic tie\u2011breaker.\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Score bins using best\u2011fit slack and capacity\u2011ratio, plus near\u2011full bonus and tiny tie\u2011breaker.\"\"\"\n    feasible = bins_remain_cap >= item\n    slack = bins_remain_cap - item\n    score = -slack\n    ratio = item / bins_remain_cap\n    score += 0.2 * ratio\n    near_full = (slack <= 0.02 * item) & feasible\n    score[near_full] += 0.5\n    indices = np.arange(bins_remain_cap.size)\n    score[feasible] -= indices[feasible] * 1e-9\n    score[~feasible] = -np.inf\n    return score",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response4.txt_stdout.txt",
    "code_path": "problem_iter20_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Hybrid best\u2011fit with ratio bias, near\u2011full/exact\u2011fit boosts, and adaptive \u03b5\u2011greedy jitter.\n    \"\"\"\n    # Initialize adaptive \u03b5\u2011greedy parameters\n    if not hasattr(priority_v2, \"_epsilon\"):\n        priority_v2._epsilon = 0.2\n        priority_v2._epsilon_min = 0.01\n        priority_v2._epsilon_decay = 0.995\n        priority_v2._step = 0\n    priority_v2._step += 1\n    priority_v2._epsilon = max(priority_v2._epsilon_min, priority_v2._epsilon * priority_v2._epsilon_decay)\n\n    n = bins_remain_cap.size\n    priorities = np.full(n, -np.inf, dtype=float)\n\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        return priorities\n\n    slack = bins_remain_cap[feasible] - item\n\n    # Best\u2011fit core with a mild ratio bias\n    base = -slack + 0.2 * (item / bins_remain_cap[feasible])\n\n    # Near\u2011full boost\n    near_full_thresh = max(0.02, 0.05 * item)\n    base[slack <= near_full_thresh] += 0.5\n\n    # Exact\u2011fit boost\n    base[slack <= 1e-9] += 0.7\n\n    priorities[feasible] = base\n\n    # Random exploration with decaying \u03b5\n    if np.random.rand() < priority_v2._epsilon:\n        priorities[feasible] = np.random.rand(np.sum(feasible))\n\n    # Tiny jitter to break ties\n    priorities[feasible] += 1e-6 * np.random.rand(np.sum(feasible))\n\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.058635819704831,
    "SLOC": 23.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response5.txt_stdout.txt",
    "code_path": "problem_iter20_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Score bins by tightness (best\u2011fit) plus capacity\u2011ratio; optional \u03b5\u2011greedy exploration.\"\"\"\n    n = bins_remain_cap.size\n    feasible = bins_remain_cap >= item\n    priorities = np.full(n, -np.inf, dtype=float)   # infeasible bins get -inf\n    if not np.any(feasible):\n        return priorities\n    slack = bins_remain_cap[feasible] - item       # remaining space after placing\n    base = -slack                                   # best\u2011fit: smaller slack \u2192 higher score\n    ratio = item / bins_remain_cap[feasible]       # capacity\u2011ratio: tighter fit \u2192 higher score\n    scores = base + 0.2 * ratio                     # combine both components\n    scores += np.random.rand(scores.shape[0]) * 1e-6  # tiny jitter to break ties\n    priorities[feasible] = scores\n    epsilon = 0.02                                 # small chance to explore randomly\n    if np.random.rand() < epsilon:\n        priorities[feasible] = np.random.rand(scores.shape[0])\n    return priorities",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.01874750698045,
    "SLOC": 16.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response6.txt_stdout.txt",
    "code_path": "problem_iter20_code6.py",
    "code": "import numpy as np\n\n# Computes priority for online bin packing: best\u2011fit core with ratio tie\u2011breaker, bonuses, and jitter.\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Score bins using best-fit (-slack) with ratio tie\u2011breaker, near\u2011full and exact\u2011fit bonuses, and jitter.\n    \"\"\"\n    feasible = bins_remain_cap >= item\n    scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    if not np.any(feasible):\n        return scores\n    slack = bins_remain_cap[feasible] - item\n    base = -slack\n    near_full_thresh = 0.05 * item\n    near_full_boost = 0.5\n    exact_fit_thresh = 1e-9\n    exact_fit_boost = 1.0\n    boost = np.zeros_like(base)\n    boost[slack <= near_full_thresh] += near_full_boost\n    boost[slack <= exact_fit_thresh] += exact_fit_boost\n    ratio = item / bins_remain_cap[feasible]\n    deterministic = base + boost + 0.01 * ratio\n    deterministic += 1e-6 * np.random.rand(deterministic.size)\n    scores[feasible] = deterministic\n    return scores",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 19.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response7.txt_stdout.txt",
    "code_path": "problem_iter20_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Best-fit scoring with near-full/exact-fit boosts, ratio weighting, capped smooth boost, epsilon-greedy exploration, and jitter.\"\"\"\n    n = bins_remain_cap.size\n    feasible = bins_remain_cap >= item\n    scores = np.full(n, -np.inf, dtype=float)\n    if not np.any(feasible):\n        return scores\n    slack = bins_remain_cap[feasible] - item\n    base = -slack\n    threshold = max(0.02, 0.05 * item)\n    near_full = slack <= threshold\n    exact = np.isclose(slack, 0.0, atol=1e-9)\n    ratio = item / bins_remain_cap[feasible]\n    smooth_boost = 0.5 / (slack + 1e-12)\n    smooth_boost = np.minimum(smooth_boost, 5.0)\n    scores[feasible] = base + 0.5 * near_full + 1.0 * exact + smooth_boost + 0.1 * ratio\n    scores[feasible] += 1e-6 * np.random.rand(feasible.sum())\n    if not hasattr(priority_v2, \"_epsilon\"):\n        priority_v2._epsilon = 0.5\n        priority_v2._epsilon_min = 0.05\n        priority_v2._epsilon_decay = 0.99\n    priority_v2._epsilon = max(priority_v2._epsilon_min, priority_v2._epsilon * priority_v2._epsilon_decay)\n    epsilon = priority_v2._epsilon\n    if np.random.rand() < epsilon:\n        idx = np.random.choice(np.flatnonzero(feasible))\n        scores[idx] += 10.0\n    return scores",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 26.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response8.txt_stdout.txt",
    "code_path": "problem_iter20_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best\u2011fit with ratio, near\u2011full/exact\u2011fit boosts, epsilon\u2011greedy exploration, and jitter.\"\"\"\n    if not hasattr(priority_v2, \"_epsilon\"):\n        priority_v2._epsilon = 0.2\n        priority_v2._epsilon_min = 0.01\n        priority_v2._epsilon_decay = 0.995\n        priority_v2._step = 0\n    priority_v2._step += 1\n    priority_v2._epsilon = max(priority_v2._epsilon_min, priority_v2._epsilon * priority_v2._epsilon_decay)\n    n = bins_remain_cap.size\n    priorities = np.full(n, -np.inf, dtype=float)\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        return priorities\n    slack = bins_remain_cap[feasible] - item\n    base = -slack\n    near_full_thresh = max(0.02, 0.05 * item)\n    base[slack <= near_full_thresh] += 0.5\n    base[slack <= 1e-9] += 1.0\n    ratio_weight = 0.1\n    base += ratio_weight * (item / bins_remain_cap[feasible])\n    base += 1e-6 * np.random.rand(base.size)\n    priorities[feasible] = base\n    if np.random.rand() < priority_v2._epsilon:\n        rand_scores = np.random.rand(n)\n        rand_scores[~feasible] = -np.inf\n        priorities = rand_scores\n    return priorities",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.068607897885915,
    "SLOC": 27.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response9.txt_stdout.txt",
    "code_path": "problem_iter20_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Best-fit with smooth near\u2011full boost, exact\u2011fit bonus, capacity ratio weight, and decaying epsilon\u2011greedy exploration.\"\"\"\n    if not hasattr(priority_v2, \"_epsilon\"):\n        priority_v2._epsilon = 0.2\n        priority_v2._epsilon_min = 0.01\n        priority_v2._epsilon_decay = 0.995\n    n = bins_remain_cap.size\n    scores = np.full(n, -np.inf, dtype=float)\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        return scores\n    slack = bins_remain_cap[feasible] - item\n    base = -slack\n    tiny = 1e-8\n    smooth_boost = 0.5 / (slack + tiny)\n    smooth_boost = np.minimum(smooth_boost, 5.0)\n    near_full_threshold = max(0.02, 0.05 * item)\n    near_full_bonus = np.where(slack <= near_full_threshold, 0.5, 0.0)\n    exact_fit_bonus = np.where(np.isclose(slack, 0.0, atol=1e-9), 1.0, 0.0)\n    ratio = item / bins_remain_cap[feasible]\n    scores[feasible] = base + smooth_boost + near_full_bonus + exact_fit_bonus + 0.1 * ratio\n    scores[feasible] += 1e-6 * np.random.rand(scores[feasible].size)\n    priority_v2._epsilon = max(priority_v2._epsilon_min, priority_v2._epsilon * priority_v2._epsilon_decay)\n    if np.random.rand() < priority_v2._epsilon:\n        idx = np.random.choice(np.flatnonzero(feasible))\n        scores[idx] = np.max(scores) + 1.0\n    return scores",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 26.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter21_response0.txt_stdout.txt",
    "code_path": "problem_iter21_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    n = bins_remain_cap.size\n    priorities = np.full(n, -np.inf, dtype=float)\n    feasible = bins_remain_cap >= item\n    if not feasible.any():\n        return priorities\n    slack = bins_remain_cap - item\n    dead_space_ratio = 0.01\n    bin_capacity = bins_remain_cap.max()\n    dead_space_thr = bin_capacity * dead_space_ratio\n    dead_space = (slack > 0) & (slack < dead_space_thr)\n    usable = feasible & ~dead_space\n    if not usable.any():\n        return priorities\n    ratio = item / bins_remain_cap[usable]\n    eps = np.finfo(float).eps\n    priorities[usable] = ratio + eps * (-slack[usable])\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 18.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  }
]