[
  {
    "stdout_filepath": "problem_iter11_response0.txt_stdout.txt",
    "code_path": "problem_iter11_code0.py",
    "code": "import numpy as np\n\n# Priority function using best\u2011fit, smooth tightness boost, jitter, and fixed \u03b5\u2011greedy.\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Score bins by negative slack plus smooth boost for tight fits; penalize infeasibility; add jitter; \u03b5\u2011greedy random fallback.\"\"\"\n    eps = 0.05\n    if np.random.rand() < eps:\n        rand = np.random.rand(bins_remain_cap.shape[0])\n        rand[bins_remain_cap < item] = -1e9\n        return rand\n    slack = bins_remain_cap - item\n    feasible = slack >= 0\n    scores = np.full(bins_remain_cap.shape, -1e9, dtype=float)\n    if not np.any(feasible):\n        return scores\n    base = -slack[feasible]\n    tiny = 1e-6\n    boost_factor = 0.5\n    max_boost = 5.0\n    boost = boost_factor / (slack[feasible] + tiny)\n    boost = np.minimum(boost, max_boost)\n    scores[feasible] = base + boost\n    jitter = 0.01 * item\n    if jitter > 0:\n        scores[feasible] += np.random.uniform(-jitter, jitter, size=feasible.sum())\n    return scores",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.098524132429212,
    "SLOC": 22.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response1.txt_stdout.txt",
    "code_path": "problem_iter11_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item, bins_remain_cap):\n    \"\"\"Inverse\u2011slack best\u2011fit with near\u2011full & exact\u2011fit boosts and \u03b5\u2011greedy exploration.\"\"\"\n    n = bins_remain_cap.size\n    priorities = np.full(n, -np.inf, dtype=float)\n    feasible = bins_remain_cap >= item\n    if not feasible.any():\n        return priorities\n    slack = bins_remain_cap[feasible] - item\n    eps = np.finfo(float).eps\n    scores = 1.0 / (slack + eps)\n    near_full_thresh = max(0.02, 0.05 * item)\n    scores[slack <= near_full_thresh] += 0.5\n    scores[slack <= eps] += 3.0\n    priorities[feasible] = scores\n    exploration_prob = 0.1\n    if np.random.rand() < exploration_prob:\n        rand = np.random.rand(n)\n        rand[~feasible] = -np.inf\n        priorities = rand\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.168328679696844,
    "SLOC": 19.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response2.txt_stdout.txt",
    "code_path": "problem_iter11_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Score bins by negative slack with inverse slack term, near\u2011full boost, and \u03b5\u2011greedy exploration.\"\"\"\n    eps = 1e-12\n    epsilon = 0.1\n    n = bins_remain_cap.size\n    scores = np.full(n, -np.inf, dtype=float)\n    slack = bins_remain_cap - item\n    feasible = slack >= 0\n    if not np.any(feasible):\n        return scores\n    base = -slack[feasible]\n    inv = 1.0 / (slack[feasible] + eps)\n    base = base +  # combine best\u2011fit with inverse slack term\n    0.1 * inv\n    near_full_thresh = max(0.02, 0.05 * item)\n    boost = np.zeros_like(base)\n    exact_fit = slack[feasible] == 0\n    near_full = slack[feasible] <= near_full_thresh\n    boost[exact_fit] = 10.0\n    boost[near_full] += 3.0\n    scores[feasible] = base + boost\n    if np.random.rand() < epsilon:\n        rand = np.random.rand(n)\n        rand[~feasible] = -np.inf\n        return rand\n    return scores",
    "response_id": 2,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 9, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 15\n    base = base +  # combine best\u2011fit with inverse slack term\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax\nTraceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/SLOC.py\", line 7, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 15\n    base = base +  # combine best\u2011fit with inverse slack term\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax\nTraceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/cyclomatic_complexity.py\", line 7, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 15\n    base = base +  # combine best\u2011fit with inverse slack term\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax\n"
  },
  {
    "stdout_filepath": "problem_iter11_response3.txt_stdout.txt",
    "code_path": "problem_iter11_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Best\u2011fit with small \u03b5\u2011greedy exploration and item\u2011scaled near\u2011full boost.\"\"\"\n    epsilon = 0.1\n    boost = 0.5\n    near_full_thresh = max(0.02, 0.05 * item)\n    feasible = bins_remain_cap >= item\n    n = bins_remain_cap.shape[0]\n    scores = np.full(n, -np.inf, dtype=float)\n    if not np.any(feasible):\n        return scores\n    slack = bins_remain_cap[feasible] - item\n    base = -slack\n    near_full = slack <= near_full_thresh\n    base[near_full] += boost\n    scores[feasible] = base\n    if np.random.rand() < epsilon:\n        rand_scores = np.random.rand(n)\n        rand_scores[~feasible] = -np.inf\n        scores = rand_scores\n    return scores",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.188272836059035,
    "SLOC": 19.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response4.txt_stdout.txt",
    "code_path": "problem_iter11_code4.py",
    "code": "import numpy as np\n\n# Best-fit scoring with \u03b5\u2011greedy exploration and near\u2011full/exact\u2011fit boosts\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Best-fit scoring with \u03b5\u2011greedy exploration and near\u2011full/exact\u2011fit boosts, prioritizing bins with minimal slack while exploring occasionally.\n    \"\"\"\n    if not hasattr(priority_v2, \"epsilon\"):\n        priority_v2.epsilon = 0.1\n        priority_v2.near_full_thresh = 0.05\n        priority_v2.near_full_boost = 0.5\n        priority_v2.exact_fit_boost = 1.0\n    eps = priority_v2.epsilon\n    feasible = bins_remain_cap >= item\n    n = bins_remain_cap.size\n    scores = np.full(n, -np.inf, dtype=float)\n    if not np.any(feasible):\n        return scores\n    if np.random.rand() < eps:\n        scores[feasible] = np.random.rand(feasible.sum())\n    else:\n        slack = bins_remain_cap[feasible] - item\n        base = -slack\n        near_full = slack <= priority_v2.near_full_thresh\n        base[near_full] += priority_v2.near_full_boost\n        exact_fit = slack == 0\n        base[exact_fit] += priority_v2.exact_fit_boost\n        scores[feasible] = base\n    return scores",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.13841244515357,
    "SLOC": 23.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response5.txt_stdout.txt",
    "code_path": "problem_iter11_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    epsilon = 0.08\n    n = bins_remain_cap.size\n    scores = np.full(n, -np.inf, dtype=float)\n    valid = bins_remain_cap >= item\n    if np.random.rand() < epsilon:\n        scores[valid] = np.random.rand(np.count_nonzero(valid))\n        return scores\n    = bins_remain_cap.max()\n    slack = bins_remain_cap[valid] - item\n    scores[valid] = -slack\n    exact = slack == 0\n    scores[valid][exact] += 0.5\n    thresh = 0.05 * bins_remain_cap.max()\n    near_full = slack <= thresh\n    scores[valid][near_full] += 0.2\n    return scores",
    "response_id": 5,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 9, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 11\n    = bins_remain_cap.max()\n    ^\nSyntaxError: invalid syntax\nTraceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/SLOC.py\", line 7, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 11\n    = bins_remain_cap.max()\n    ^\nSyntaxError: invalid syntax\nTraceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/cyclomatic_complexity.py\", line 7, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 11\n    = bins_remain_cap.max()\n    ^\nSyntaxError: invalid syntax\n"
  },
  {
    "stdout_filepath": "problem_iter11_response6.txt_stdout.txt",
    "code_path": "problem_iter11_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray,\n                epsilon: float = 0.05,\n                near_full_frac: float = 0.05,\n                boost: float = 0.5) -> np.ndarray:\n    \"\"\"Best\u2011fit scoring with near\u2011full boost and \u03b5\u2011greedy random exploration.\"\"\"\n    feasible = bins_remain_cap >= item\n    n = bins_remain_cap.shape[0]\n    scores = np.full(n, -np.inf, dtype=float)\n    if not np.any(feasible):\n        return.\n\n    slack = bins_remain_cap[feasible] - item\n    base = -slack\n    near_full_thresh = near_full_frac * item\n    base[slack <= near_full_thresh] += boost\n    scores[feasible] = base\n    if np.random.rand() < epsilon:\n        scores[feasible] = np.random.rand(feasible.sum())\n    return scores",
    "response_id": 6,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 9, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 12\n    return.\n          ^\nSyntaxError: invalid syntax\nTraceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/SLOC.py\", line 7, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 12\n    return.\n          ^\nSyntaxError: invalid syntax\nTraceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/cyclomatic_complexity.py\", line 7, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 12\n    return.\n          ^\nSyntaxError: invalid syntax\n"
  },
  {
    "stdout_filepath": "problem_iter11_response7.txt_stdout.txt",
    "code_path": "problem_iter11_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    epsilon = 0.05\n    scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        return scores\n    slack = bins_remain_cap[feasible] - item\n    base = 1.0 / (slack + 1e-12)\n    near_full_thresh = max(0.02, 0.05 * item)\n    base += np.where(slack <= near_full_thresh, 0.5, 0.0)\n    base += np.where(slack <= 1e-12, 2.0, 0.0)\n    scores[feasible] = base\n    if np.random.rand() < epsilon:\n        scores[feasible] = np.random.rand(feasible.sum())\n    return scores",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.098524132429212,
    "SLOC": 15.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response8.txt_stdout.txt",
    "code_path": "problem_iter11_code8.py",
    "code": "import numpy as np\n\n# Inverse\u2011slack priority with simple \u03b5\u2011greedy exploration.\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Score bins by inverse slack, using fixed \u03b5\u2011greedy random fallback.\"\"\"\n    eps = 1e-9\n    explore_prob = 0.1\n    scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    feasible = bins_remain_cap >= item\n    if not feasible.any():\n        return scores\n    slack = bins_remain_cap[feasible] - item\n    scores[feasible] = 1.0 / (slack + eps)\n    if np.random.rand() < explore_prob:\n        scores[feasible] = np.random.rand(feasible.sum())\n    return scores",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.078579976067022,
    "SLOC": 12.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response9.txt_stdout.txt",
    "code_path": "problem_iter11_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Static epsilon\u2011greedy best\u2011fit: negative slack, +boost for near\u2011full and exact fits.\"\"\"\n    epsilon = 0.1\n    near_full_factor = 0.05\n    near_full_abs_thresh = 0.02\n    near_full_boost = 0.5\n    exact_fit_boost = 1.0\n    n = bins_remain_cap.size\n    scores = np.full(n, -np.inf, dtype=float)\n    feasible = bins_remain_cap >= item\n    if not feasible.any():\n        return scores\n    # Compute slack for feasible bins\n    slack = bins_remain_cap[feasible] - item\n    base = -slack\n    # Apply near\u2011full boost\n    near_full_thresh = max(near_full_abs_thresh, near_full_factor * item)\n    base[slack <= near_full_thresh] += near_full_boost\n    # Apply exact\u2011fit boost\n    base[np.isclose(slack, 0.0, atol=1e-9)] += exact_fit_boost\n    scores[feasible] = base\n    # \u03b5\u2011greedy exploration\n    if np.random.rand() < epsilon:\n        rand = np.random.rand(n)\n        rand[~feasible] = -np.inf\n        scores = rand\n    return scores",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.178300757877951,
    "SLOC": 22.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response0.txt_stdout.txt",
    "code_path": "problem_iter12_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    n = bins_remain_cap.size\n    valid = bins_remain_cap >= item\n    priorities = np.full_like(bins_remain_cap, -1e9, dtype=float)\n    if np.any(valid):\n        slack = bins_remain_cap[valid] - item\n        priorities[valid] = -slack\n        valid_count = np.count_nonzero(valid)\n        epsilon = 0.05 * (1 - valid_count / n)\n        if np.random.rand() < epsilon:\n            idx = np.random.choice(np.flatnonzero(valid))\n            priorities[idx] += 1e-3\n    return priorities",
    "response_id": 0,
    "tryHS": true,
    "obj": 4.048663741523748,
    "SLOC": 13.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter13_response0.txt_stdout.txt",
    "code_path": "problem_iter13_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    default_priority: float = -585775408519.5737,\n    epsilon_factor: float = 0.8199524253832372,\n    tie_breaker: float = 0.003761928048808475,\n) -> np.ndarray:\n    \"\"\"\n    Compute priorities for bins based on remaining capacity and item size.\n\n    Parameters\n    ----------\n    item : float\n        Size of the item to be placed.\n    bins_remain_cap : np.ndarray\n        Remaining capacities of the bins.\n    default_priority : float, optional\n        Sentinel priority assigned to all bins initially (default: -1e9).\n    epsilon_factor : float, optional\n        Base factor used to compute epsilon for random tie\u2011breaking (default: 0.05).\n    tie_breaker : float, optional\n        Small positive increment added to break ties when the random condition is met (default: 1e-3).\n\n    Returns\n    -------\n    np.ndarray\n        Array of priority values for each bin.\n    \"\"\"\n    n = bins_remain_cap.size\n    valid = bins_remain_cap >= item\n    priorities = np.full_like(bins_remain_cap, default_priority, dtype=float)\n\n    if np.any(valid):\n        slack = bins_remain_cap[valid] - item\n        priorities[valid] = -slack\n        valid_count = np.count_nonzero(valid)\n        epsilon = epsilon_factor * (1 - valid_count / n)\n\n        if np.random.rand() < epsilon:\n            idx = np.random.choice(np.flatnonzero(valid))\n            priorities[idx] += tie_breaker\n\n    return priorities",
    "response_id": 0,
    "tryHS": true,
    "obj": 4.048663741523748,
    "SLOC": 19.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  }
]