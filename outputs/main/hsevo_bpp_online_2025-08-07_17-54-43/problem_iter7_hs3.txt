import numpy as np

def priority_v2(item: float,
                bins_remain_cap: np.ndarray,
                epsilon: float = 0.011953678317922267,
                epsilon_min: float = 0.08953191592865475,
                epsilon_decay: float = 0.9379694931919165,
                near_full_thresh_base: float = 0.06244361354635141,
                near_full_thresh_multiplier: float = 0.05249682954368101,
                base_priority_increment: float = 0.8023342883212417,
                small_eps: float = 9.582396953325064e-09) -> np.ndarray:
    """
    Adaptive epsilon‑greedy best‑fit with slack inverse, near‑full boost, and infeasibility handling.
    """
    # Initialize static attributes on first call
    if not hasattr(priority_v2, "_epsilon"):
        priority_v2._epsilon = epsilon
        priority_v2._epsilon_min = epsilon_min
        priority_v2._epsilon_decay = epsilon_decay
        priority_v2._step = 0

    priority_v2._step += 1
    priority_v2._epsilon = max(priority_v2._epsilon_min,
                               priority_v2._epsilon * priority_v2._epsilon_decay)

    n = bins_remain_cap.size
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    valid = bins_remain_cap >= item
    if not np.any(valid):
        return priorities

    slack = bins_remain_cap[valid] - item
    base_priority = 1.0 / (slack + small_eps)

    near_full_thresh = max(near_full_thresh_base, near_full_thresh_multiplier * item)
    base_priority[slack <= near_full_thresh] += base_priority_increment

    priorities[valid] = base_priority

    if np.random.rand() < priority_v2._epsilon:
        rand_scores = np.random.rand(n)
        rand_scores[~valid] = -np.inf
        priorities = rand_scores

    return priorities
