[
  {
    "stdout_filepath": "problem_iter29_response0.txt_stdout.txt",
    "code_path": "problem_iter29_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Adaptive epsilon\u2011greedy best\u2011fit with near\u2011full and exact fit boosts, jitter, and index bias.\"\"\"\n    if not hasattr(priority_v2, \"_epsilon\"):\n        priority_v2._epsilon = 0.2\n        priority_v2._epsilon_min = 0.01\n        priority_v2._epsilon_decay = 0.995\n        priority_v2._step = 0\n    priority_v2._step += 1\n    priority_v2._epsilon = max(priority_v2._epsilon_min, priority_v2._epsilon * priority_v2._epsilon_decay)\n    n = bins_remain_cap.size\n    priorities = np.full(n, -np.inf, dtype=float)\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        return priorities\n    slack = bins_remain_cap[feasible] - item\n    base = -slack\n    near_full_thresh = max(0.02, 0.05 * item)\n    near_full_boost = 0.5\n    exact_fit_boost = 1.0\n    base[slack <= near_full_thresh] += near_full_boost\n    base[slack == 0] += exact_fit_boost\n    jitter = (np.random.rand(base.size) - 0.5) * 1e-9\n    base += jitter\n    indices = np.arange(n)[feasible]\n    base += indices * 1e-12\n    priorities[feasible] = base\n    if np.random.rand() < priority_v2._epsilon:\n        rand_scores = np.random.rand(n)\n        rand_scores[~feasible] = -np.inf\n        priorities = rand_scores\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 3.9888312724371757,
    "SLOC": 30.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter29_response1.txt_stdout.txt",
    "code_path": "problem_iter29_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Adaptive best\u2011fit priority with epsilon\u2011greedy, near\u2011full boost, jitter, and tie\u2011breaking.\"\"\"\n    if not hasattr(priority_v2, \"_epsilon\"):\n        priority_v2._epsilon = 0.2\n        priority_v2._epsilon_min = 0.01\n        priority_v2._epsilon_decay = 0.995\n        priority_v2._step = 0\n    priority_v2._step += 1\n    priority_v2._epsilon = max(priority_v2._epsilon_min, priority_v2._epsilon * priority_v2._epsilon_decay)\n    n = bins_remain_cap.size\n    priorities = np.full(n, -np.inf, dtype=float)\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        return priorities\n    slack = bins_remain_cap[feasible] - item\n    base = -slack\n    max_remain = bins_remain_cap.max()\n    near_full_thresh = max(0.02, 0.05 * item, 0.1 * max_remain)\n    boost = 0.5\n    base[slack <= near_full_thresh] += boost\n    jitter_scale = 1e-3\n    jitter = (np.random.rand(len(slack)) - 0.5) * jitter_scale\n    tie_break = np.arange(np.sum(feasible))[::-1] * 1e-6\n    priorities[feasible] = base + jitter + tie_break\n    if np.random.rand() < priority_v2._epsilon:\n        rand_scores = np.random.rand(n)\n        rand_scores[~feasible] = -np.inf\n        priorities = rand_scores\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.13841244515357,
    "SLOC": 28.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter29_response2.txt_stdout.txt",
    "code_path": "problem_iter29_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Best\u2011fit scoring with ratio penalty, near\u2011full boost, tie\u2011breaker, and decaying epsilon jitter.\"\"\"\n    if not hasattr(priority_v2, \"_epsilon\"):\n        priority_v2._epsilon = 0.5\n        priority_v2._epsilon_min = 0.01\n        priority_v2._epsilon_decay = 0.995\n    priority_v2._epsilon = max(priority_v2._epsilon_min, priority_v2._epsilon * priority_v2._epsilon_decay)\n    eps = priority_v2._epsilon\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        return priorities\n    cap_feas = bins_remain_cap[feasible]\n    slack = cap_feas - item\n    base = -slack\n    base += 0.05 * (item / cap_feas)\n    base += 0.5 * (slack <= 0.05 * cap_feas)\n    idx = np.flatnonzero(feasible)\n    base += 1e-6 * idx\n    if eps > 0:\n        base += eps * 1e-4 * np.random.rand(base.shape[0])\n    priorities[feasible] = base\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 22.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter29_response3.txt_stdout.txt",
    "code_path": "problem_iter29_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    if not hasattr(priority_v2, \"_epsilon\"):\n        priority_v2._epsilon = 0.2\n        priority_v2._epsilon_min = 0.01\n        priority_v2._epsilon_decay = 0.995\n        priority_v2._step = 0\n    priority_v2._step += 1\n    priority_v2._epsilon = max(priority_v2._epsilon_min, priority_v2._epsilon * priority_v2._epsilon_decay)\n    n = bins_remain_cap.size\n    scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        return scores\n    slack = bins_remain_cap[feasible] - item\n    base = -slack\n    ratio = item / bins_remain_cap[feasible]\n    ratio_weight = 0.02\n    near_full_thresh = max(0.02, 0.05 * item)\n    boost = 0.5\n    bonus = np.where(slack <= near_full_thresh, boost, 0.0)\n    deterministic = base + ratio_weight * ratio + (bonus if isinstance(bonus, np.ndarray) else 0)\n    jitter = np.random.rand(deterministic.size) * 1e-6\n    deterministic += jitter\n    if np.random.rand() < priority_v2._epsilon:\n        rand_scores = np.random.rand(n)\n        rand_scores[~feasible] = -np.inf\n        scores = rand_scores\n    else:\n        scores[feasible] = deterministic\n    return scores",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.1284403669724865,
    "SLOC": 30.0,
    "cyclomatic_complexity": 5.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter29_response4.txt_stdout.txt",
    "code_path": "problem_iter29_code4.py",
    "code": "import numpy as np\n\n# priority_v2: epsilon\u2011greedy best\u2011fit with ratio penalty, near\u2011full boost, jitter, and decay.\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Epsilon\u2011greedy best\u2011fit heuristic: score bins by negative slack, apply small ratio penalty,\n    boost near\u2011full bins, add jitter, decay epsilon for exploration. Infeasible bins get -inf.\"\"\"\n    if not hasattr(priority_v2, \"_epsilon\"):\n        priority_v2._epsilon = 0.2\n        priority_v2._epsilon_min = 0.01\n        priority_v2._epsilon_decay = 0.995\n        priority_v2._step = 0\n    priority_v2._step += 1\n    priority_v2._epsilon = max(priority_v2._epsilon_min,\n                               priority_v2._epsilon * priority_v2._epsilon_decay)\n    eps = priority_v2._epsilon\n    feasible = bins_remain_cap >= item\n    scores = np.full_like(bins_remain, -np.inf, dtype=float)\n    if not np.any(feasible):\n        return scores\n    slack = bins_remain_cap[feasible] - item\n    base = -slack\n    ratio = item / bins_remain_cap[feasible]\n    ratio_weight = 0.02\n    base -= ratio_weight * ratio\n    near_full_thresh = max(0.02, 0.05 * item)\n    boost = 0.5\n    base[slack <= near_full_thresh] += boost\n    base += np.random.rand(feasible.sum()) * 1e-6\n    scores[feasible] = base\n    if np.random.rand() < eps:\n        rand_scores = np.random.rand(bins_remain_cap.size)\n        rand_scores[~feasible] = -np.inf\n        scores = rand_scores\n    return scores",
    "response_id": 4,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 17, in priority_v2\n    slack = bins_remain_cap[feasible] - item\nNameError: name 'bins_remain' is not defined. Did you mean: 'bins_remain_cap'?\n29\n4\n"
  },
  {
    "stdout_filepath": "problem_iter29_response5.txt_stdout.txt",
    "code_path": "problem_iter29_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Adaptive \u03b5\u2011greedy best\u2011fit with near\u2011full/exact\u2011fit boost and deterministic jitter.\"\"\"\n    if not hasattr(priority_v2, \"epsilon\"):\n        priority_v2.epsilon = 0.2\n        priority_v2.epsilon_min = 0.01\n        priority_v2.epsilon_decay = 0.995\n        priority_v2.step = 0\n    priority_v2.step += 1\n    priority_v2.epsilon = max(priority_v2.epsilon_min, priority_v2.epsilon * priority_v2.epsilon_decay)\n    n = bins_remain_cap.size\n    scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        return scores\n    slack = bins_remain_cap[feasible] - item\n    base = -slack\n    near_full_thresh = max(0.02, 0.05 * item)\n    base[slack <= near_full_thresh] += 0.5\n    base[slack <= 1e-9] += 0.3\n    idx = np.where(feasible)[0]\n    base += 1e-9 * idx\n    if np.random.rand() < priority_v2.epsilon:\n        scores[feasible] = np.random.rand(slack.size)\n    else:\n        scores[feasible] = base\n    return scores",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.028719585161557,
    "SLOC": 25.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter29_response6.txt_stdout.txt",
    "code_path": "problem_iter29_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Adaptive epsilon\u2011greedy scoring with near\u2011full and exact\u2011fit bonuses, ratio penalty, jitter, and tie\u2011break.\"\"\"\n    if not hasattr(priority_v2, \"_epsilon\"):\n        priority_v2._epsilon = 0.4\n        priority_v2._epsilon_min = 0.05\n        priority_v2._epsilon_decay = 0.995\n    priority_v2._epsilon = max(priority_v2._epsilon_min, priority_v2._epsilon * priority_v2._epsilon_decay)\n    eps = priority_v2._epsilon\n    feasible = bins_remain_cap >= item\n    priorities = np.full(bins_remain_cap.shape, -np.inf, dtype=float)\n    if not np.any(feasible):\n        return priorities\n    slack = bins_remain_cap[feasible] - item\n    base = -slack\n    near_full_thresh = 0.1 * bins_remain_cap.max()\n    near_full_bonus = 0.5\n    base += np.where(slack <= near_full_thresh, near_full_bonus, 0.0)\n    exact_fit_bonus = 1.0\n    base += np.where(slack == 0, exact_fit_bonus, 0.0)\n    ratio_penalty = 0.05 * (item / bins_remain_cap[feasible])\n    base -= ratio_penalty\n    jitter_scale = 1e-4\n    jitter = (np.random.rand(len(slack)) - 0.5) * jitter_scale\n    tie_break = np.arange(bins_remain_cap.size)[feasible] * 1e-6\n    scores = base + jitter + tie_break\n    if np.random.rand() < eps:\n        scores = np.random.rand(len(slack))\n    priorities[feasible] = scores\n    return priorities",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.15835660151576,
    "SLOC": 28.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter29_response7.txt_stdout.txt",
    "code_path": "problem_iter29_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Best\u2011fit with epsilon\u2011greedy, ratio tie\u2011breaker, and near\u2011full boost.\"\"\"\n    n = bins_remain_cap.size\n    scores = np.full(n, -np.inf, dtype=float)\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        return scores\n    slack = bins_remain_cap[feasible] - item\n    base = -slack\n    ratio = item / bins_remain_cap[feasible]\n    ratio_weight = 0.02\n    near_full_threshold = 0.05\n    near_full_bonus = 0.1\n    near_full = np.where(slack <= near_full_threshold * bins_remain_cap[feasible], near_full_bonus, 0.0)\n    deterministic = base + ratio_weight * ratio + near_full\n    idx = np.flatnonzero(feasible)\n    deterministic += idx * 1e-9\n    epsilon = 0.05\n    if np.random.rand() < epsilon:\n        scores[feasible] = np.random.rand(deterministic.shape[0])\n    else:\n        jitter = np.random.uniform(0, 1e-6, size=deterministic.shape)\n        scores[feasible] = deterministic + jitter\n    return scores",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.098524132429212,
    "SLOC": 23.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter29_response8.txt_stdout.txt",
    "code_path": "problem_iter29_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Adaptive \u03b5\u2011greedy best\u2011fit: favors smallest slack, boosts near\u2011full bins, adds jitter, infeasibility = -inf.\"\"\"\n    if not hasattr(priority_v2, \"_epsilon\"):\n        priority_v2._epsilon = 0.2          # initial exploration rate\n        priority_v2._epsilon_min = 0.01    # floor for \u03b5\n        # decay factor per item\n        priority_v2._epsilon_decay = 0.995\n        priority_v2._step = 0\n    priority_v2._step += 1\n    # exponential decay of \u03b5\n    priority_v2._epsilon = max(priority_v2._epsilon_min,\n                               priority_v2._epsilon * priority_v2._epsilon_decay)\n    n = bins_remain_cap.shape[0]\n    scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        return scores\n    slack = bins_remain_cap[feasible] - item\n    base = -slack                         # best\u2011fit core (smaller slack \u2192 higher score)\n    near_full_thresh = max(0.02, 0.05 * item)\n    base[slack <= near_full_thresh] += 0.5   # boost bins that are almost full\n    idx = np.flatnonzero(feasible)\n    base += 1e-9 * idx                    # tiny tie\u2011breaker by bin index\n    base += np.random.rand(base.size) * 1e-6   # jitter to break exact ties\n    scores[feasible] = base\n    if np.random.rand() < priority_v2._epsilon:\n        rand_scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n        rand_scores[feasible] = np.random.rand(feasible.sum())\n        scores = rand_scores               # \u03b5\u2011greedy random exploration\n    return scores",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.15835660151576,
    "SLOC": 27.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter29_response9.txt_stdout.txt",
    "code_path": "problem_iter29_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    epsilon = 0.05\n    scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        return scores\n    slack = bins_remain_cap[feasible] - item\n    base = -slack\n    base += 0.05 * (item / bins_remain_cap[feasible])\n    near_full = slack <= 0.05 * bins_remain_cap[feasible]\n    base[near_full] += 0.5\n    idx = np.flatnonzero(feasible)\n    base += 1e-6 * idx\n    if np.random.rand() < epsilon:\n        scores[feasible] = np.random.rand(slack.size)\n    else:\n        scores[feasible] = base\n    return scores",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.13841244515357,
    "SLOC": 18.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter30_response0.txt_stdout.txt",
    "code_path": "problem_iter30_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    if not hasattr(priority_v2, \"_epsilon\"):\n        priority_v2._epsilon = 0.15\n        priority_v2._epsilon_min = 0.01\n        priority_v2._epsilon_decay = 0.99\n        priority_v2._step = 0\n    priority_v2._step += 1\n    priority_v2._epsilon = max(priority_v2._epsilon_min, priority_v2._epsilon * priority_v2._epsilon_decay)\n    n = bins_remain_cap.size\n    priorities = np.full(n, -np.inf, dtype=float)\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        return priorities\n    if np.random.rand() < priority_v2._epsilon:\n        rand_scores = np.random.rand(n)\n        rand_scores[~feasible] = -np.inf\n        return rand_scores\n    slack = bins_remain_cap[feasible] - item\n    base = -slack\n    near_full_thresh = max(0.02, 0.05 * item)\n    near_full_boost = 0.3\n    exact_fit_boost = 0.6\n    base[slack <= near_full_thresh] += near_full_boost\n    base[slack <= 1e-12] += exact_fit_boost\n    jitter = (np.random.rand(base.size) - 0.5) * 1e-9\n    base += jitter\n    idx = np.arange(n)[feasible]\n    base += idx * 1e-12\n    priorities[feasible] = base\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.058635819704831,
    "SLOC": 30.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  }
]