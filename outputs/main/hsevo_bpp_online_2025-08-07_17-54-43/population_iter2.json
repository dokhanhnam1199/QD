[
  {
    "stdout_filepath": "problem_iter2_response0.txt_stdout.txt",
    "code_path": "problem_iter2_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Best-fit priority with \u03b5\u2011greedy adaptive exploration. Feasible bins get -slack; with probability \u03b5 random scores are used. \u03b5 decays each call toward a minimum.\"\"\"\n    if not hasattr(priority_v2, 'epsilon'):\n        priority_v2.epsilon = 0.2\n        priority_v2.min_epsilon = 0.01\n        priority_v2.decay = 0.995\n    eps = priority_v2.epsilon\n    n = bins_remain_cap.size\n    priorities = np.full(n, -np.inf, dtype=float)\n    valid = bins_remain_cap >= item\n    priorities[valid] = -(bins_remain_cap[valid] - item)\n    if np.random.rand() < eps:\n        rand_scores = np.random.random(n)\n        priorities[valid] = rand_scores[valid]\n    priority_v2.epsilon = max(priority_v2.min_epsilon, eps * priority_v2.decay)\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.078579976067022,
    "SLOC": 15.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response1.txt_stdout.txt",
    "code_path": "problem_iter2_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Epsilon\u2011greedy best\u2011fit heuristic with softmax weighting for online bin packing. Uses adaptive epsilon for exploration, marking infeasible bins with -inf and applying softmax to negative slack for exploitation.\"\"\"\n    if not hasattr(priority_v2, \"_calls\"):\n        priority_v2._calls = 0\n    priority_v2._calls += 1\n    eps = max(0.01, 0.2 / np.sqrt(priority_v2._calls))\n    n = bins_remain_cap.size\n    if np.random.rand() < eps:\n        return np.random.rand(n)\n    slack = bins_remain_cap - item\n    feasible = slack >= 0\n    scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    scores[feasible] = -slack[feasible]\n    if feasible.any():\n        max_score = scores[feasible].max()\n        exp_scores = np.exp(scores - max_score)\n        exp_scores[~feasible] = 0.0\n        total = exp_scores.sum()\n        if total > 0:\n            return exp_scores / total\n    return np.full_like(bins_remain_cap, -np.inf, dtype=float)",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.068607897885915,
    "SLOC": 20.0,
    "cyclomatic_complexity": 5.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response2.txt_stdout.txt",
    "code_path": "problem_iter2_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Best-fit with a small worst\u2011fit bias and \u03b5\u2011greedy exploration.\n    \"\"\"\n    eps = 0.05\n    if np.random.rand() < eps:\n        return np.random.random(bins_remain_cap.shape)\n    slack = bins_remain_cap - item\n    valid = slack >= 0\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    priorities[valid] = -slack[valid] + 0.01 * bins_remain_cap[valid]\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.1284403669724865,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response3.txt_stdout.txt",
    "code_path": "problem_iter2_code3.py",
    "code": "import numpy as np\n\n# Best\u2011fit with inverse slack, -inf for infeasible, \u03b5\u2011greedy exploration and decaying \u03b5.\n_EPS = 0.2          # initial exploration rate\n_EPS_DECAY = 0.99   # decay factor per call\n_EPS_MIN = 0.01     # lower bound\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Best\u2011fit inverse\u2011slack scoring, infeasible bins get -inf, \u03b5\u2011greedy exploration (\u03b5 decays).\"\"\"\n    slack = bins_remain_cap - item\n    feasible = slack >= 0\n    eps = 1e-9\n    best_fit = np.where(feasible, 1.0 / (slack + eps), -np.inf)\n    rand = np.random.rand(bins_remain_cap.size)\n    scores = np.where(feasible, (1 - _EPS) * best_fit + _EPS * rand, -np.inf)\n    global _EPS\n    _EPS = max(_EPS_MIN, _EPS * _EPS_DECAY)\n    return scores",
    "response_id": 3,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 9, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 16\n    global _EPS\n    ^^^^^^^^^^^\nSyntaxError: name '_EPS' is used prior to global declaration\nTraceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/SLOC.py\", line 7, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 16\n    global _EPS\n    ^^^^^^^^^^^\nSyntaxError: name '_EPS' is used prior to global declaration\nTraceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/cyclomatic_complexity.py\", line 7, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 16\n    global _EPS\n    ^^^^^^^^^^^\nSyntaxError: name '_EPS' is used prior to global declaration\n"
  },
  {
    "stdout_filepath": "problem_iter2_response4.txt_stdout.txt",
    "code_path": "problem_iter2_code4.py",
    "code": "import numpy as np\n\n# Combined best-fit with \u03b5\u2011greedy exploration and adaptive \u03b5 based on feasible bin count.\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.1) -> np.ndarray:\n    \"\"\"Best\u2011fit score with \u03b5\u2011greedy exploration; infeasible bins receive -inf.\"\"\"\n    n = bins_remain_cap.shape[0]\n    priorities = np.full(n, -np.inf, dtype=float)\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        return priorities\n    waste = bins_remain_cap[feasible] - item\n    bestfit = -waste\n    adapt_eps = epsilon / (1.0 + np.log1p(feasible.sum()))\n    explore = np.random.rand(bestfit.size) < adapt_eps\n    random_score = np.random.rand(bestfit.size)\n    priorities[feasible] = np.where(explore, random_score, bestfit)\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 74.00279218189073,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response5.txt_stdout.txt",
    "code_path": "problem_iter2_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.05) -> np.ndarray:\n    slack = bins_remain_cap.astype(float) - item\n    eps = 1e-9\n    feasible = slack >= 0\n    base = np.where(feasible, 1.0 / (slack + eps), -np.inf)\n    rand = np.random.rand(bins_remain_cap.shape[0])\n    scores = np.where(feasible, (1 - epsilon) * base + epsilon * rand, -np.inf)\n    return scores",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.437574790586359,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response6.txt_stdout.txt",
    "code_path": "problem_iter2_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.1) -> np.ndarray:\n    \"\"\"Best\u2011fit priority with \u03b5\u2011greedy exploration.\"\"\"\n    feasible = bins_remain_cap >= item\n    waste = bins_remain_cap - item\n    base_priority = np.where(feasible, 1.0/(waste + 1e-12), -np.inf)\n    random_priority = np.random.rand(bins_remain_cap.size)\n    return np.where(feasible, (1 - epsilon) * base_priority + epsilon * random_priority, -np.inf)",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.168328679696844,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response7.txt_stdout.txt",
    "code_path": "problem_iter2_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines best\u2011fit and epsilon\u2011greedy random exploration.\n    \"\"\"\n    eps = 0.1\n    can_fit = bins_remain_cap >= item\n    if np.random.rand() < eps:\n        scores = np.where(can_fit, np.random.rand(len(bins_remain_cap)), -np.inf)\n    else:\n        slack = bins_remain_cap - item\n        eps_num = np.finfo(float).eps\n        scores = np.where(can_fit, 1.0/(slack + eps_num), -np.inf)\n    return scores",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response8.txt_stdout.txt",
    "code_path": "problem_iter2_code8.py",
    "code": "import numpy as np\n_EPSILON = 0.1\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    n = bins_remain_cap.shape[0]\n    scores = np.full(n, -np.inf, dtype=float)\n    feasible = bins_remain_cap >= item\n    if not feasible.any():\n        return scores\n    waste = bins_remain_cap[feasible] - item\n    best_fit = -waste\n    rand_vals = np.random.rand(best_fit.size)\n    explore = np.random.rand(best_fit.size) < _EPSILON\n    combined = np.where(explore, rand_vals, best_fit)\n    idx = np.where(feasible)[0]\n    tie_penalty = -idx * 1e-6\n    final = combined + tie_penalty\n    scores[feasible] = final\n    return scores",
    "response_id": 8,
    "tryHS": false,
    "obj": 68.08934982050259,
    "SLOC": 16.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response9.txt_stdout.txt",
    "code_path": "problem_iter2_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.1, alpha: float = 0.1) -> np.ndarray:\n    \"\"\"\n    Combines best\u2011fit (inverse slack) with worst\u2011fit (slack) scoring and optional epsilon\u2011greedy exploration for flexible bin selection.\n    \"\"\"\n    feasible = bins_remain_cap >= item\n    waste = bins_remain_cap - item\n    priorities = np.full(bins_remain_cap.shape, -np.inf, dtype=float)\n    priorities[feasible] = 1.0 / (waste[feasible] + 1e-12) + alpha * waste[feasible]\n    if epsilon > 0:\n        noise = epsilon * np.random.rand(np.count_nonzero(feasible))\n        priorities[feasible] += noise\n    return priorities",
    "response_id": 9,
    "tryHS": false,
    "obj": 86.58755484643,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  }
]