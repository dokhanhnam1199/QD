```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Adaptive epsilon‑greedy best‑fit with near‑full boost; infeasible bins get -inf."""
    # stateful parameters for epsilon decay and near‑full boost
    if not hasattr(priority_v2, "exploration_epsilon"):
        priority_v2.exploration_epsilon = 0.3
        priority_v2.epsilon_min = 0.01
        priority_v2.decay = 0.995
        priority_v2.step = 0
        priority_v2.near_full_threshold = 0.1
        priority_v2.near_full_boost = 2.0
        priority_v2.eps_small = 1e-12
    # decay exploration epsilon
    priority_v2.exploration_epsilon = max(
        priority_v2.epsilon_min,
        priority_v2.exploration_epsilon * priority_v2.decay,
    )
    eps = priority_v2.exploration_epsilon
    priority_v2.step += 1
    slack = bins_remain_cap.astype(float) - item
    feasible = slack >= 0
    n = bins_remain_cap.shape[0]
    scores = np.full(n, -np.inf, dtype=float)
    if not feasible.any():
        return scores
    base = 1.0 / (slack[feasible] + priority_v2.eps_small)
    near_full = slack[feasible] <= priority_v2.near_full_threshold
    if near_full.any():
        base[near_full] *= priority_v2.near_full_boost
    rand_vals = np.random.rand(base.size)
    explore = np.random.rand(base.size) < eps
    bin_scores = np.where(explore, rand_vals, base)
    idx = np.where(feasible)[0]
    bin_scores += -idx * 1e-6
    scores[feasible] = bin_scores
    return scores
```
