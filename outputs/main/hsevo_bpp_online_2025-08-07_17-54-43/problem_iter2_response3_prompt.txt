{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code only and do not add comments into the code. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    eps = 1e-9\n    capacities = bins_remain_cap.astype(float) - item\n    return np.where(capacities >= 0, 1.0 / (capacities + eps), 0.0)\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority for each bin using the Worst Fit strategy.\"\"\"\n    fit = bins_remain_cap >= item\n    return np.where(fit, bins_remain_cap, -np.inf)\n\n### Analyze & experience\n- - **Heuristic\u202f\u2013\u202f1st vs\u202f20th:** The 1st uses \u03b5\u2011greedy randomness, scores feasible bins by negative slack (best\u2011fit) and marks infeasible bins with\u202f\u2011\u221e. The 20th simply returns remaining capacity (worst\u2011fit) for feasible bins, no exploration, and no explicit handling of infeasibility beyond\u202f\u2011\u221e.  \n- **Heuristic\u202f\u2013\u202f2nd vs\u202f19th:** The 2nd mirrors the 1st (identical code), while the 19th mirrors the 20th (worst\u2011fit). The same strengths/weaknesses apply.  \n- **Heuristic\u202f\u2013\u202f1st vs\u202f2nd:** Identical implementation; no observable difference.  \n- **Heuristic\u202f\u2013\u202f3rd vs\u202f4th:** The 3rd retains the \u03b5\u2011greedy random exploration of the 1st, whereas the 4th drops randomness and only applies deterministic best\u2011fit scoring. The added exploration gives the 3rd a slight edge.  \n- **Heuristic\u202f\u2013\u202f19th vs\u202f20th:** Both implement the same worst\u2011fit strategy; differences are only naming conventions, yielding equivalent performance.  \n- **Overall:** Top heuristics combine best\u2011fit scoring, explicit infeasibility handling (\u2011\u221e), and controlled randomness (\u03b5\u2011greedy). Mid\u2011range variants add softmax or inverse\u2011slack but often lack clear documentation. Bottom heuristics rely on naive worst\u2011fit or pure random scores, missing both exploitation and robust infeasibility checks.\n- \n- **Keywords**: Intent\u2011driven, infeasibility handling, slack minimization (best\u2011fit), \u03b5\u2011greedy exploration, adaptive decay.  \n- **Advice**: Step\u202f1: Document intent. Step\u202f2: Adaptive \u03b5\u2011decay. Step\u202f3: Local slack repair. Step\u202f4: Scenario validation.  \n- **Avoid**: Fixed greedy orders, static \u03b5, naive worst\u2011fit, unnormalized random scoring, ignoring infeasible states, one\u2011size\u2011fits\u2011all callbacks.  \n- **Explanation**: Adaptive \u03b5 balances exploration/exploitation, local repair fixes slack, scenario testing uncovers corner cases, clear documentation supports reproducibility and tuning.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}