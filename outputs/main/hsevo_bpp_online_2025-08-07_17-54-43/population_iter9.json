[
  {
    "stdout_filepath": "problem_iter8_response0.txt_stdout.txt",
    "code_path": "problem_iter8_code0.py",
    "code": "import numpy as np\n\n# Fixed exploration probability (static \u03b5\u2011greedy)\n_EPSILON = 0.2\n_EPS = 1e-12\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Inverse\u2011slack best\u2011fit with near\u2011full/exact\u2011fit boost and static \u03b5\u2011greedy exploration.\"\"\"\n    slack = bins_remain_cap - item\n    feasible = slack >= 0\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    if not np.any(feasible):\n        return priorities\n    base = 1.0 / (slack[feasible] + _EPS)\n    near_full_thresh = max(0.02, 0.05 * item)\n    near_full = slack[feasible] <= near_full_thresh\n    base[near_full] += 0.5\n    exact_fit = slack[feasible] <= _EPS\n    base[exact_fit] += 3.0\n    priorities[feasible] = base\n    if np.random.rand() < _EPSILON:\n        rand_scores = np.random.rand(bins_remain_cap.size)\n        rand_scores[~feasible] = -np.inf\n        priorities = rand_scores\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.357798165137619,
    "SLOC": 18.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response1.txt_stdout.txt",
    "code_path": "problem_iter8_code1.py",
    "code": "import numpy as np\n\n# Inverse\u2011slack best\u2011fit with additive near\u2011full/exact\u2011fit boost and fixed \u03b5\u2011greedy.\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Best\u2011fit (inverse slack) with modest near\u2011full boost and fixed \u03b5\u2011greedy.\"\"\"\n    if not hasattr(priority_v2, \"epsilon\"):\n        priority_v2.epsilon = 0.15               # exploration probability\n        priority_v2.near_full_thresh = 0.1       # slack \u2264 this is \u201cnear full\u201d\n        priority_v2.near_full_boost = 0.5        # additive boost for near\u2011full bins\n        priority_v2.exact_fit_boost = 3.0        # large boost for exact fits\n    eps = np.finfo(float).eps\n    can_fit = bins_remain_cap >= item\n    slack = bins_remain_cap - item\n    scores = np.where(can_fit, 1.0 / (slack + eps), -np.inf)\n    near_full = (slack <= priority_v2.near_full_thresh) & can_fit\n    scores[near_full] += priority_v2.near_full_boost\n    exact_fit = (slack <= eps) & can_fit\n    scores[exact_fit] += priority_v2.exact_fit_boost\n    if np.random.rand() < priority_v2.epsilon:\n        scores = np.where(can_fit, np.random.rand(len(bins_remain_cap)), -np.inf)\n    return scores",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.337854008775429,
    "SLOC": 17.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response2.txt_stdout.txt",
    "code_path": "problem_iter8_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Best\u2011fit with fixed \u03b5\u2011greedy exploration and near\u2011full boost.\"\"\"\n    if not hasattr(priority_v2, \"epsilon\"):\n        priority_v2.epsilon = 0.1\n        priority_v2.near_full_thresh = 0.05\n        priority_v2.boost = 0.5\n    eps = priority_v2.epsilon\n    feasible = bins_remain_cap >= item\n    n = bins_remain_cap.shape[0]\n    scores = np.full(n, -np.inf, dtype=float)\n    if np.random.rand() < eps:\n        scores[feasible] = np.random.rand(feasible.sum())\n    else:\n        slack = bins_remain_cap[feasible] - item\n        base = -slack\n        near_full = slack <= priority_v2.near_full_thresh\n        base[near_full] += priority_v2.boost\n        scores[feasible] = base\n    return scores",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.188272836059035,
    "SLOC": 18.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response3.txt_stdout.txt",
    "code_path": "problem_iter8_code3.py",
    "code": "def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Best\u2011fit priority with epsilon\u2011greedy exploration and near\u2011full boost.\n    \"\"\"\n    import numpy as np\n    epsilon = 0.1\n    eps_small = np.finfo(float).eps\n    slack = bins_remain_cap - item\n    feasible = slack >= 0\n    base = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    base[feasible] = 1.0 / (slack[feasible] + eps_small)\n    if np.max(bins_remain_cap) > 0:\n        near_full_thresh = 0.05 * np.max(bins_remain_cap)\n    else:\n        near_full_thresh = 0.0\n    near_full_mask = (slack <= near_full_thresh) & feasible\n    base[near_full_mask] += 0.5\n    exact_fit_mask = (slack == 0) & feasible\n    base[exact_fit_mask] += 3.0\n    rand_scores = np.random.rand(len(bins_remain_cap))\n    if np.random.rand() < epsilon:\n        scores = np.where(feasible, rand_scores, -np.inf)\n    else:\n        scores = np.where(feasible, base, -np.inf)\n    return scores",
    "response_id": 3,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 9, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 1, in <module>\n    def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\nNameError: name 'np' is not defined\nTraceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/SLOC.py\", line 7, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 1, in <module>\n    def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\nNameError: name 'np' is not defined\nTraceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/cyclomatic_complexity.py\", line 7, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 1, in <module>\n    def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\nNameError: name 'np' is not defined\n"
  },
  {
    "stdout_filepath": "problem_iter8_response4.txt_stdout.txt",
    "code_path": "problem_iter8_code4.py",
    "code": "import numpy as np\n\n# Priority function for online bin packing using simple best-fit and fixed \u03b5\u2011greedy.\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Best\u2011fit scoring with fixed \u03b5\u2011greedy exploration and near\u2011full, exact\u2011fit boosts.\"\"\"\n    if not hasattr(priority_v2, \"_epsilon\"):\n        priority_v2._epsilon = 0.1  # constant exploration probability\n    n = bins_remain_cap.size\n    scores = np.full(n, -np.inf, dtype=float)               # infeasible bins get -inf\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        return scores\n    # base best\u2011fit score (higher is better)\n    slack = bins_remain_cap[feasible] - item\n    base = -slack\n    # near\u2011full and exact\u2011fit boosts\n    near_full_thresh = max(0.02, 0.05 * item)\n    boost = np.zeros_like(slack)\n    boost[slack == 0] = 10.0\n    boost[slack <= near_full_thresh] += 3.0\n    base += boost\n    scores[feasible] = base\n    # \u03b5\u2011greedy: replace with pure random scores with probability \u03b5\n    if np.random.rand() < priority_v2._epsilon:\n        rand = np.random.rand(n)\n        rand[~feasible] = -np.inf\n        return rand\n    return scores",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.13841244515357,
    "SLOC": 21.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response5.txt_stdout.txt",
    "code_path": "problem_iter8_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item, bins_remain_cap):\n    \"\"\"Adaptive best-fit with near\u2011full and exact fit boosts, epsilon\u2011greedy exploration.\"\"\"\n    if not hasattr(priority_v2, \"epsilon\"):\n        priority_v2.epsilon = 0.3\n        priority_v2.near_full_threshold_factor = 0.05\n        priority_v2.alpha = 0.01\n        priority_v2.exact_fit_boost = 3.0\n        priority_v2.near_full_boost = 0.5\n    if np.random.rand() < priority_v2.epsilon:\n        return np.random.random(bins_remain_cap.shape)\n    slack = bins_remain_cap - item\n    valid = slack >= 0\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    priorities[valid] = -slack[valid] + priority_v2.alpha * slack[valid]\n    priorities[valid & (slack == 0)] += priority_v2.exact_fit_boost\n    threshold = min(0.1, priority_v2.near_full_threshold_factor * np.max(bins_remain_cap))\n    near_full = (slack <= threshold) & valid\n    priorities[near_full] += priority_v2.near_full_boost\n    return priorities",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.666932588751491,
    "SLOC": 18.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response6.txt_stdout.txt",
    "code_path": "problem_iter8_code6.py",
    "code": "import numpy as np\n\n# This priority function uses best-fit scoring with a small near-full boost and\n# a static epsilon-greedy exploration step.\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Simple best-fit priority with near-full boost and epsilon-greedy exploration.\"\"\"\n    if not hasattr(priority_v2, \"_epsilon\"):\n        priority_v2._epsilon = 0.2\n    n = bins_remain_cap.size\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        return priorities\n    slack = bins_remain_cap[feasible] - item\n    base = -slack\n    near_full_thresh = max(0.02, 0.05 * item)\n    boost = 0.5\n    base[slack <= near_full_thresh] += boost\n    priorities[feasible] = base\n    if np.random.rand() < priority_v2._epsilon:\n        rand_scores = np.random.rand(n)\n        rand_scores[~feasible] = -np.inf\n        priorities = rand_scores\n    return priorities",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.198244914240141,
    "SLOC": 19.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response7.txt_stdout.txt",
    "code_path": "problem_iter8_code7.py",
    "code": "import numpy as np\n\n# Fixed \u03b5\u2011greedy best\u2011fit with modest near\u2011full boost.\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Score bins by -slack, boost near\u2011full bins; \u03b5\u2011greedy random fallback.\"\"\"\n    if not hasattr(priority_v2, \"epsilon\"):\n        priority_v2.epsilon = 0.2          # exploration probability\n        priority_v2.near_full_factor = 0.05\n        priority_v2.boost = 0.5            # additive boost for tight fits\n    n = bins_remain_cap.size\n    scores = np.full(n, -np.inf, dtype=float)\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        return scores\n    slack = bins_remain_cap[feasible] - item\n    base = -slack\n    near_full_thresh = max(0.02, priority_v2.near_full_factor * item)\n    base[slack <= near_full_thresh] += priority_v2.boost\n    scores[feasible] = base\n    if np.random.rand() < priority_v2.epsilon:\n        rand = np.random.rand(n)\n        rand[~feasible] = -np.inf\n        scores = rand\n    return scores",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.248105305145606,
    "SLOC": 20.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response8.txt_stdout.txt",
    "code_path": "problem_iter8_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Adaptive epsilon\u2011greedy best\u2011fit with inverse\u2011slack base, exact\u2011fit and near\u2011full boosts.\"\"\"\n    if not hasattr(priority_v2, \"_epsilon\"):\n        priority_v2._epsilon = 0.2\n        priority_v2._epsilon_min = 0.01\n        priority_v2._epsilon_decay = 0.995\n        priority_v2._step = 0\n    priority_v2._step += 1\n    priority_v2._epsilon = max(priority_v2._epsilon_min, priority_v2._epsilon * priority_v2._epsilon_decay)\n    n = bins_remain_cap.size\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    valid = bins_remain_cap >= item\n    if not np.any(valid):\n        return priorities\n    slack = bins_remain_cap[valid] - item\n    base_priority = 1.0 / (slack + 1e-12)\n    near_full_thresh = max(0.02, 0.05 * item)\n    base_priority += np.where(slack <= near_full_thresh, 0.5, 0.0)\n    base_priority += np.where(slack <= 1e-12, 3.0, 0.0)\n    priorities[valid] = base_priority\n    if np.random.rand() < priority_v2._epsilon:\n        rand_scores = np.random.rand(n)\n        rand_scores[~valid] = -np.inf\n        priorities = rand_scores\n    return priorities",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.11846828879138,
    "SLOC": 24.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response9.txt_stdout.txt",
    "code_path": "problem_iter8_code9.py",
    "code": "import numpy as np\n\n# Simple epsilon\u2011greedy best\u2011fit with additive near\u2011full boost.\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Static epsilon\u2011greedy best\u2011fit priority with near\u2011full boost and -inf for infeasible bins.\"\"\"\n    epsilon = 0.1\n    n = bins_remain_cap.size\n    priorities = np.full(n, -np.inf, dtype=float)\n    feasible = bins_remain_cap >= item\n    if not feasible.any():\n        return priorities\n    slack = bins_remain_cap[feasible] - item\n    scores = -slack\n    near_full_thresh = max(0.02, 0.05 * item)\n    boost = 0.5\n    scores[slack <= near_full_thresh] += boost\n    priorities[feasible] = scores\n    if np.random.rand() < epsilon:\n        rand = np.random.rand(n)\n        rand[~feasible] = -np.inf\n        priorities = rand\n    return priorities",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.198244914240141,
    "SLOC": 18.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response0.txt_stdout.txt",
    "code_path": "problem_iter9_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    epsilon = 0.1\n    n = bins_remain_cap.size\n    priorities = np.full(n, -np.inf, dtype=float)\n    valid = bins_remain_cap >= item\n    if np.any(valid):\n        priorities[valid] = item / bins_remain_cap[valid]\n    if np.random.rand() < epsilon:\n        random_scores = np.random.rand(n)\n        random_scores[~valid] = -np.inf\n        priorities = random_scores\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.178300757877951,
    "SLOC": 12.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  }
]