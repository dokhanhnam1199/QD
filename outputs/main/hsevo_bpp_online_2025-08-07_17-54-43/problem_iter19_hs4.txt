import numpy as np

def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    boost_factor: float = 0.12530222218803622,
    max_boost: float = 7.567794531848269,
    tiny: float = 0.0007417519602669664,
    ratio_weight: float = 0.375207866020941,
    eps_base: float = 0.08910089058926503,
    tie_breaker_boost: float = 0.0021698270310691594,
) -> np.ndarray:
    """Combines best‑fit slack with item‑to‑bin ratio, adaptive ε‑greedy, and tie‑breaker.

    Parameters
    ----------
    item : float
        Size of the item to place.
    bins_remain_cap : np.ndarray
        Remaining capacity of each bin.
    boost_factor : float, optional
        Weight for the slack‑based boost (default 0.5).
    max_boost : float, optional
        Upper bound for the boost term (default 5.0).
    tiny : float, optional
        Small constant to avoid division‑by‑zero (default 1e-6).
    ratio_weight : float, optional
        Weight applied to the item‑to‑bin ratio term (default 0.1).
    eps_base : float, optional
        Base factor for the adaptive ε‑greedy probability (default 0.05).
    tie_breaker_boost : float, optional
        Small boost added when the ε‑greedy path is taken (default 1e-3).

    Returns
    -------
    np.ndarray
        Scores for each bin (``-inf`` for infeasible bins).
    """
    n = bins_remain_cap.size
    feasible = bins_remain_cap >= item
    scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    if not np.any(feasible):
        return scores

    slack = bins_remain_cap[feasible] - item
    base = -slack

    # slack‑based boost, limited by max_boost
    boost = np.minimum(boost_factor / (slack + tiny), max_boost)

    # ratio term
    ratio = item / bins_remain_cap[feasible]

    scores[feasible] = base + boost + ratio_weight * ratio

    # count calls for adaptive ε‑greedy
    if not hasattr(priority_v2, "_call_count"):
        priority_v2._call_count = 0
    priority_v2._call_count += 1

    # adaptive ε‑greedy exploration
    eps = eps_base * (1 - np.count_nonzero(feasible) / n)
    if np.random.rand() < eps:
        idx = np.random.choice(np.flatnonzero(feasible))
        scores[idx] += tie_breaker_boost

    return scores
