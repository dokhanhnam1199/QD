{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code only and do not add comments into the code. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    return np.where(bins_remain_cap >= item, item / bins_remain_cap, -np.inf)\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Best-fit scoring with negative slack, near\u2011full and exact\u2011fit boosts, decaying \u03b5\u2011greedy exploration, and tiny jitter for tie\u2011breaking.\"\"\"\n    if not hasattr(priority_v2, \"_epsilon\"):\n        priority_v2._epsilon = 0.2\n        priority_v2._epsilon_min = 0.01\n        priority_v2._epsilon_decay = 0.995\n        priority_v2._step = 0\n    priority_v2._step += 1\n    priority_v2._epsilon = max(priority_v2._epsilon_min,\n                               priority_v2._epsilon * priority_v2._epsilon_decay)\n\n    n = bins_remain_cap.size\n    scores = np.full(n, -np.inf, dtype=float)\n\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        return scores\n\n    slack = bins_remain_cap[feasible] - item\n    base = -slack\n\n    near_full_thresh = max(0.02, 0.05 * item)\n    near_full_boost = 0.5\n    exact_fit_thresh = 1e-9\n    exact_fit_boost = 1.0\n\n    boost = np.zeros_like(base)\n    boost[slack <= near_full_thresh] += near_full_boost\n    boost[slack <= exact_fit_thresh] += exact_fit_boost\n\n    deterministic = base + boost\n    deterministic += 1e-6 * np.random.rand(deterministic.size)  # tiny jitter\n\n    if np.random.rand() < priority_v2._epsilon:\n        rand_vals = np.random.rand(n)\n        rand_vals[~feasible] = -np.inf\n        scores = rand_vals\n    else:\n        scores[feasible] = deterministic\n\n    return scores\n\n### Analyze & experience\n- - **(Best) vs (Worst) \u2013 #1 vs #5**  \n  *#1* implements an *adaptive \u03b5\u2011greedy best\u2011fit* policy: it initializes static \u03b5 parameters, decays \u03b5 each call, computes `-slack` as the deterministic score, adds a `+0.5` boost for bins whose slack \u2264\u202f`max(0.02,\u202f0.05\u00b7item)`, and falls back to a full\u2011random ranking with probability\u202f\u03b5. It also returns `-inf` for infeasible bins.  \n  *#5* merely returns `item / bins_remain_cap` (or `-inf`) \u2013 no slack, no near\u2011full or exact\u2011fit bonuses, no exploration, and no tie\u2011breaking. The scoring is far less discriminative.\n\n- **(Second best) vs (Second worst) \u2013 #2 vs #8**  \n  *#2* is a verbatim copy of #1, inheriting the same robust design.  \n  *#8* repeats #5\u2019s naive ratio heuristic, offering no adaptive behavior or bonuses, thus clearly inferior.\n\n- **(1st) vs (2nd) \u2013 #1 vs #2**  \n  The two functions are byte\u2011for\u2011byte identical; there is no functional improvement, indicating redundancy rather than a true progression.\n\n- **(3rd) vs (4th) \u2013 #3 vs #4**  \n  *#3* normalizes slack (`-slack / bins_remain_cap`), adds a tiny random noise term, uses `np.isclose` for exact fits, and computes \u03b5 as `0.05\u00b7(1\u2011feasible/n)`. It contains dead code (`np.random0`) and a convoluted epsilon scheme, making it brittle.  \n  *#4* cleanly computes `-slack`, applies a capped boost `min(boost_factor/(slack+tiny), max_boost)`, adds a modest ratio weight (`0.1\u00b7ratio`), and sets \u03b5 based on the feasible\u2011bin proportion. The implementation is clearer, more stable, and mathematically grounded.\n\n- **(Second worst) vs (Worst) \u2013 #8 vs #18**  \n  *#8* repeats the simple ratio approach of #5.  \n  *#18* defines many hyper\u2011parameters and a detailed docstring but aborts after checking feasibility, never assigning scores. It is the least functional of the set.\n\n- **Overall**  \n  The top\u2011ranked heuristics (#1, #2, #4, #6, #9\u2011#17) share key strengths:  \n  1. **Feasibility masking** (`bins_remain_cap >= item`) with `-inf` for infeasible bins.  \n  2. **Deterministic best\u2011fit core** (`-slack`).  \n  3. **Near\u2011full / exact\u2011fit bonuses** (e.g., `+0.5` for small slack, `+1.0` for exact fits).  \n  4. **Adaptive \u03b5\u2011greedy exploration**, often with decay (`\u03b5 = max(\u03b5_min, \u03b5\u00b7decay)`).  \n  5. **Tiny jitter** (`1e\u20116\u00b7rand`) to break ties.  \n  Lower\u2011ranked versions either omit these mechanisms, contain bugs (dead code, undefined symbols), or are incomplete.\n- \n- **Keywords:** best\u2011fit core, capacity\u2011ratio scoring, deterministic selection, look\u2011ahead pruning, vectorized updates, clear documentation.  \n- **Advice:** Use a static capacity\u2011ratio score (item size\u202f/\u202fremaining bin space), apply a simple deterministic tie\u2011breaker, incorporate a one\u2011step look\u2011ahead to reject moves that create dead\u2011space, keep implementation fully vectorized the code and comment intent.  \n- **Avoid:** Adaptive \u03b5\u2011decay, jitter, near\u2011full/exact\u2011fit bonuses, multiplicative boosts, per\u2011item random mixing, stateful parameters, explicit infeasibility masks, heavy softmax, over\u2011parameterization.  \n- **Explanation:** This yields transparent, fast heuristics with minimal hyper\u2011parameters, reduces hidden bias, and eases maintenance while still guiding items toward tight fits.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}