import numpy as np

def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    epsilon_init: float = 0.33155623713315663,
    epsilon_min: float = 0.1728224083260953,
    epsilon_decay: float = 0.9408619477253204,
    near_full_abs_thresh: float = 0.04017901633165899,
    near_full_rel_factor: float = 0.18673070549098608,
    boost: float = 0.7185336282429251,
) -> np.ndarray:
    """Adaptive epsilon‑greedy best‑fit priority with near‑full boost and infeasibility handling."""
    # Initialise static epsilon state on first call
    if not hasattr(priority_v2, "_epsilon"):
        priority_v2._epsilon = epsilon_init
        priority_v2._epsilon_min = epsilon_min
        priority_v2._epsilon_decay = epsilon_decay
        priority_v2._step = 0

    # Update step counter and epsilon value
    priority_v2._step += 1
    priority_v2._epsilon = max(
        priority_v2._epsilon_min,
        priority_v2._epsilon * priority_v2._epsilon_decay,
    )

    n = bins_remain_cap.size
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Identify bins that can accommodate the item
    valid = bins_remain_cap >= item
    if not np.any(valid):
        return priorities

    # Compute slack and base priority (negative slack)
    slack = bins_remain_cap[valid] - item
    base_priority = -slack

    # Near‑full boost
    near_full_thresh = max(near_full_abs_thresh, near_full_rel_factor * item)
    base_priority[slack <= near_full_thresh] += boost

    priorities[valid] = base_priority

    # Epsilon‑greedy exploration
    if np.random.rand()0 < priority_v2._epsilon:
        rand_scores = np.random.rand(n)
        rand_scores[~valid] = -np.inf
        priorities = rand_scores

    return priorities
