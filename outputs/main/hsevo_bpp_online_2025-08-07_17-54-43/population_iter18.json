[
  {
    "stdout_filepath": "problem_iter17_response0.txt_stdout.txt",
    "code_path": "problem_iter17_code0.py",
    "code": "import numpy as np\n\n# Combines slack-based best fit with ratio scoring and adaptive \u03b5\u2011greedy exploration\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best\u2011fit slack with item\u2011to\u2011bin ratio, adaptive \u03b5\u2011greedy, and tie\u2011breaker.\"\"\"\n    n = bins_remain_cap.size\n    feasible = bins_remain_cap >= item\n    scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    if not np.any(feasible):\n        return scores\n    slack = bins_remain_cap[feasible] - item\n    base = -slack\n    boost_factor = 0.5\n    max_boost = 5.0\n    tiny = 1e-6\n    boost = np.minimum(boost_factor / (slack + tiny), max_boost)\n    ratio = item / bins_remain_cap[feasible]\n    scores[feasible] = base + boost + 0.1 * ratio\n    if not hasattr(priority_v2, \"_call_count\"):\n        priority_v2._call_count = 0\n    priority_v2._call_count += 1\n    eps = 0.05 * (1 - np.count_nonzero(feasible) / n)\n    if np.random.rand() < eps:\n        idx = np.random.choice(np.flatnonzero(feasible))\n        scores[idx] += 1e-3\n    return scores",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 22.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter17_response1.txt_stdout.txt",
    "code_path": "problem_iter17_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Best\u2011fit priority with smooth near\u2011full boost, exact\u2011fit bonus, fill\u2011ratio weighting, and adaptive \u03b5\u2011greedy tie\u2011breaker.\"\"\"\n    n = bins_remain_cap.size\n    feasible = bins_remain_cap >= item\n    scores = np.full(n, -np.inf, dtype=float)\n    if not feasible.any():\n        return scores\n    slack = bins_remain_cap[feasible] - item\n    base = -slack\n    tiny = 1e-6\n    smooth_boost = 0.5 / (slack + tiny)\n    smooth_boost = np.minimum(smooth_boost, 5.0)\n    threshold = max(0.02, 0.05 * item)\n    near_full = slack <= threshold\n    exact = np.isclose(slack, 0.0, atol=1e-9)\n    fill_ratio = item / bins_remain_cap[feasible]\n    scores[feasible] = base + smooth_boost + 0.5 * near_full + 1.0 * exact + 0.1 * fill_ratio\n    epsilon_factor = 0.5\n    epsilon = epsilon_factor * (1 - feasible.sum() / n)\n    if np.random.rand() < epsilon:\n        idx = np.random.choice(np.flatnonzero(feasible))\n        scores[idx] += 1.0\n    return scores",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 22.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter17_response2.txt_stdout.txt",
    "code_path": "problem_iter17_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Best\u2011fit priority with exact/near\u2011full bonuses, tiny jitter, and adaptive \u03b5\u2011greedy.\"\"\"\n    # Feasibility mask\n    valid = bins_remain_cap >= item\n    n = bins_remain_cap.size\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    if not np.any(valid):\n        return priorities\n\n    # Slack and base priority (smaller slack \u2192 higher score)\n    slack = bins_remain_cap[valid] - item\n    base = -slack\n\n    # Exact\u2011fit boost\n    base[np.isclose(slack, 0.0, atol=1e-9)] += 1.0\n    # Near\u2011full boost (\u22645\u202f% of bin capacity left)\n    base[slack <= 0.05 * bins_remain_cap[valid]] += 0.5? Actually we need to add 0.5.\n\nI realize there's a mistake in the last line. The correct code should be:",
    "response_id": 2,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 9, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 21\n    I realize there's a mistake in the last line. The correct code should be:\n                   ^\nSyntaxError: unterminated string literal (detected at line 21)\nTraceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/SLOC.py\", line 7, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 21\n    I realize there's a mistake in the last line. The correct code should be:\n                   ^\nSyntaxError: unterminated string literal (detected at line 21)\nTraceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/cyclomatic_complexity.py\", line 7, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 21\n    I realize there's a mistake in the last line. The correct code should be:\n                   ^\nSyntaxError: unterminated string literal (detected at line 21)\n"
  },
  {
    "stdout_filepath": "problem_iter17_response3.txt_stdout.txt",
    "code_path": "problem_iter17_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Deterministic best\u2011fit: fill ratio + inverse slack with near\u2011full/exact\u2011fit bonuses.\"\"\"\n    # Constants for scoring\n    INF_NEG = -np.inf\n    eps = 1e-9               # avoid division by zero\n    alpha = 0.1              # weight of inverse\u2011slack term\n    near_full_thr = 0.05 * item\n    near_full_bonus = 0.5\n    exact_fit_thr = eps\n    exact_fit_bonus = 1.0\n\n    scores = np.full_like(bins_remain_cap, INF_NEG, dtype=float)\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        return scores\n\n    cap_feas = bins_remain_cap[feasible]\n    slack = cap_feas - item\n    fill_ratio = item / cap_feas\n    inv_slack = 1.0 / (slack + eps)\n    base = fill_ratio + alpha * inv_slack\n\n    # deterministic bonuses\n    base[slack <= near_full_thr] += near_full_bonus\n    base[slack <= exact_fit_thr] += exact_fit_bonus\n\n    scores[feasible] = base\n    return scores",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 21.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter17_response4.txt_stdout.txt",
    "code_path": "problem_iter17_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Deterministic score: ratio + inverse\u2011slack, exact\u2011fit/near\u2011full bonuses, tiny index tie\u2011breaker.\"\"\"\n    feasible = bins_remain_cap >= item\n    scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    if not np.any(feasible):\n        return scores\n    slack = bins_remain_cap[feasible] - item\n    ratio = item / bins_remain_cap[feasible]\n    inv_slack = 1.0 / (slack + 1e-12)\n    base = ratio + 0.01 * inv_slack\n    base[slack == 0] += 1.0\n    near_full = slack <= 0.05 * item\n    base[near_full] += 0.5\n    idx = np.flatnonzero(feasible)\n    base += idx * 1\n    scores[feasible] = base\n    return scores",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.178300757877951,
    "SLOC": 16.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter17_response5.txt_stdout.txt",
    "code_path": "problem_iter17_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Best-fit scoring with negative slack, near\u2011full and exact\u2011fit boosts, decaying \u03b5\u2011greedy exploration, and tiny jitter for tie\u2011breaking.\"\"\"\n    if not hasattr(priority_v2, \"_epsilon\"):\n        priority_v2._epsilon = 0.2\n        priority_v2._epsilon_min = 0.01\n        priority_v2._epsilon_decay = 0.995\n        priority_v2._step = 0\n    priority_v2._step += 1\n    priority_v2._epsilon = max(priority_v2._epsilon_min,\n                               priority_v2._epsilon * priority_v2._epsilon_decay)\n\n    n = bins_remain_cap.size\n    scores = np.full(n, -np.inf, dtype=float)\n\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        return scores\n\n    slack = bins_remain_cap[feasible] - item\n    base = -slack\n\n    near_full_thresh = max(0.02, 0.05 * item)\n    near_full_boost = 0.5\n    exact_fit_thresh = 1e-9\n    exact_fit_boost = 1.0\n\n    boost = np.zeros_like(base)\n    boost[slack <= near_full_thresh] += near_full_boost\n    boost[slack <= exact_fit_thresh] += exact_fit_boost\n\n    deterministic = base + boost\n    deterministic += 1e-6 * np.random.rand(deterministic.size)  # tiny jitter\n\n    if np.random.rand() < priority_v2._epsilon:\n        rand_vals = np.random.rand(n)\n        rand_vals[~feasible] = -np.inf\n        scores = rand_vals\n    else:\n        scores[feasible] = deterministic\n\n    return scores",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.108496210610296,
    "SLOC": 32.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter17_response6.txt_stdout.txt",
    "code_path": "problem_iter17_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Best-fit with near-full/exact-fit boost, ratio bias, and decaying epsilon-greedy jitter.\"\"\"\n    if not hasattr(priority_v2, \"_epsilon\"):\n        priority_v2._epsilon = 0.2\n        priority_v2._epsilon_min = 0.01\n        priority_v2._epsilon_decay = 0.995\n        priority_v2._step = 0\n    priority_v2._step += 1\n    priority_v2._epsilon = max(priority_v2._epsilon_min, priority_v2._epsilon * priority_v2._epsilon_decay)\n    n = bins_remain_cap.size\n    priorities = np.full(n, -np.inf, dtype=float)\n    feasible = bins_remain_cap >= item\n    # The above line is redundant; no comments allowed\n    if not np.any(feasible):\n        return priorities\n    slack = bins_remain_cap[feasible] - item\n    base = -slack\n    ratio = item / bins_remain_cap[feasible]\n    base += 0.3 * ratio\n    near_full_thresh = max(0.02, 0.05 * item)\n    base[slack <= near_full_thresh] += 0.5\n    exact_fit_thresh = 1e-9\n    base[slack <= exact_fit_thresh] += 0.7\n    priorities[feasible] = base\n    if np.random.rand() < priority_v2._epsilon:\n        jitter = np.random.rand(np.sum(feasible)) * 0.01\n        priorities[feasible] += jitter\n    return priorities",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 26.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter17_response7.txt_stdout.txt",
    "code_path": "problem_iter17_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    valid = bins_remain_cap >= item\n    n = bins_remain_cap.size\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    if not np.any(valid):\n        return priorities\n    slack = bins_remain_cap[valid] - item\n    base = -slack / bins_remain_cap[valid]\n    base += np.isclose(slack, 0.0, atol=1e-9) * 1.0\n    base += (slack <= 0.05 * bins_remain_cap[valid]) * 0.5\n    base += (np.random0 if False else (np.random.rand(valid.sum()) - 0.5) * 1e-6)\n    priorities[valid] = base\n    feasible = np.count_nonzero(valid)\n    epsilon = 0.05 * (1 - feasible / n)\n    if np.random.rand() < epsilon:\n        idx = np.random.choice(np.flatnonzero(valid))\n        priorities[idx] += 1.0\n    return priorities",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 18.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter17_response8.txt_stdout.txt",
    "code_path": "problem_iter17_code8.py",
    "code": "def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Adaptive \u03b5\u2011greedy priority: exact\u2011fit and near\u2011full bonuses, minimal jitter.\"\"\"\n    import numpy as np\n    n = bins_remain_cap.size\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        return np.full(n, -np.inf, dtype=float)\n    feasible_ratio = np.mean(feasible)\n    epsilon = max(0.05, min(0.5, 0.5 * (1 - feasible_ratio) + 0.05))\n    if np.random.rand() < epsilon:\n        scores = np.random.rand(n)\n        scores[~feasible] = -np.inf\n        return scores\n    slack = bins_remain_cap - item\n    scores = np.full(n, -np.inf, dtype=float)\n    scores[feasible] = slack[feasible]\n    exact_mask = np.isclose(slack, 0)\n    scores[exact_mask] += 1.0\n    near_mask = np.full_like(bins_remain_cap, False, dtype=bool)\n    near_mask[feasible] = (slack[feasible] > 0) & (slack[feasible] <= 0.05 * bins_remain_cap[feasible])\n    scores[near_mask] += 0.5\n    scores[feasible] += np.random.uniform(0, 1e-6, size=feasible.sum())\n    return scores",
    "response_id": 8,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 9, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 1, in <module>\n    def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\nNameError: name 'np' is not defined\nTraceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/SLOC.py\", line 7, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 1, in <module>\n    def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\nNameError: name 'np' is not defined\nTraceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/cyclomatic_complexity.py\", line 7, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 1, in <module>\n    def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\nNameError: name 'np' is not defined\n"
  },
  {
    "stdout_filepath": "problem_iter17_response9.txt_stdout.txt",
    "code_path": "problem_iter17_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Compute priority scores for bins: best\u2011fit (-slack) with near\u2011full and exact\u2011fit bonuses, decaying \u03b5\u2011greedy exploration and tiny jitter.\"\"\"\n    # Initialize static \u03b5\u2011greedy parameters on first call\n    if not hasattr(priority_v2, \"_epsilon\"):\n        priority_v2._epsilon = 0.2\n        priority_v2._epsilon_min = 0.01\n        priority_v2._epsilon_decay = 0.995\n        priority_v2._step = 0\n    # Update \u03b5\n    priority_v2._step += 1\n    priority_v2._epsilon = max(priority_v2._epsilon_min,\n                               priority_v2._epsilon * priority_v2._epsilon_decay)\n    n = bins_remain_cap.size\n    # Default to -inf for infeasible bins\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        return priorities\n    slack = bins_remain_cap[feasible] - item\n    base = -slack\n    # Near\u2011full boost\n    near_full_thresh = max(0.02, 0.05 * item)\n    base[slack <= near_full_thresh] += 0.5\n    # Exact\u2011fit boost\n    base[slack <= 1e-9] += 1.0\n    # Tiny jitter to break ties\n    base += 1e-6 * np.random.rand(base.size)\n    priorities[feasible] = base\n    # \u03b5\u2011greedy random exploration\n    if np.random.rand() < priority_v2._epsilon:\n        rand_scores = np.random.rand(n)\n        rand_scores[~feasible] = -np.inf\n        priorities = rand_scores\n    return priorities",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.058635819704831,
    "SLOC": 26.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter18_response0.txt_stdout.txt",
    "code_path": "problem_iter18_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    return np.where(bins_remain_cap >= item, item / bins_remain_cap, -np.inf)",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 2.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  }
]