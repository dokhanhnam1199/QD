import numpy as np

def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    bin_capacity: float = 2.3738889829241523,
    ratio_weight: float = 0.27407223159946537,
    jitter_scale: float = 0.004318694811643328,
    epsilon_base: float = 0.21878084854909519,
    boost_factor: float = 0.1282509253399977,
    max_boost: float = 2.7615398557983806,
    slack_epsilon: float = 0.0004456493816920627,
    slack_atol: float = 0.0005295947482075188,
    zero_slack_bonus: float = 0.03243062511692485,
    near_full_threshold: float = 0.09241401726804838,
    near_full_bonus: float = 2.6861887868064653,
    epsilon_greedy_bonus: float = 4.22496625758708,
) -> np.ndarray:
    """
    Best‑fit with capped boost, near‑full bonuses, ratio penalty, jitter, adaptive ε‑greedy.
    All tunable constants are exposed as parameters.
    """
    valid = bins_remain_cap >= item
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)
    if not np.any(valid):
        return priorities

    slack = bins_remain_cap[valid] - item
    base = -slack

    # Boost computation (capped)
    boost = np.minimum(boost_factor / (slack + slack_epsilon), max_boost)
    base += boost

    # Exact‑zero slack bonus
    base += np.isclose(slack, 0.0, atol=slack_atol) * zero_slack_bonus

    # Near‑full (almost‑full) bonus
    base += (slack <= near_full_threshold * bins_remain_cap[valid]) * near_full_bonus

    # Ratio penalty (larger bins penalized)
    base -= ratio_weight * (bins_remain_cap[valid] / bin_capacity)

    # Jitter to break ties
    base += (np.random.rand(valid.sum()) - 0.5) * jitter_scale

    priorities[valid] = base

    feasible = valid.sum()
    epsilon = epsilon_base * (1 - feasible / bins_remain_cap.size)

    # ε‑greedy random boost
    if feasible and np.random.rand() < epsilon:
        idx = np.random.choice(np.flatnonzero(valid))
        priorities[idx] += epsilon_greedy_bonus

    return priorities
