```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray, bin_capacity: float = 1.0, ratio_weight: float = 0.2, jitter_scale: float = 1e-6, epsilon_base: float = 0.05) -> np.ndarray:
    """Best‑fit with capped boost, near‑full bonuses, ratio penalty, jitter, adaptive ε‑greedy."""
    valid = bins_remain_cap >= item
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)
    if not np.any(valid):
        return priorities
    slack = bins_remain_cap[valid] - item
    base = -slack
    boost_factor = 0.5
    max_boost = 3.0
    tiny = 1e-6
    boost = np.minimum(boost_factor / (slack + tiny), max_boost)
    base += boost
    base += np.isclose(slack, 0.0, atol=1e-9) * 1.0
    base += (slack <= 0.05 * bins_remain_cap[valid]) * 0.5
    base -= ratio_weight * (bins_remain_cap[valid] / bin_capacity)
    base += (np.random.rand(valid.sum()) - 0.5) * jitter_scale
    priorities[valid] = base
    feasible = valid.sum()
    epsilon = epsilon_base * (1 - feasible / bins_remain_cap.size)
    if feasible and np.random.rand() < epsilon:
        idx = np.random.choice(np.flatnonzero(valid))
        priorities[idx] += 1.0
    return priorities
```
