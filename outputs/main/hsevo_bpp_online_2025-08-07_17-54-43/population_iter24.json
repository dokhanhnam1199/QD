[
  {
    "stdout_filepath": "problem_iter23_response0.txt_stdout.txt",
    "code_path": "problem_iter23_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    ratio_weight: float = 0.5,\n    dead_space_ratio: float = 0.01,\n    epsilon: float = 0.1,\n    jitter_scale: float = 1e-6,\n) -> np.ndarray:\n    \"\"\"Combine ratio, dead\u2011space filter and \u03b5\u2011greedy jitter for online BPP.\"\"\"\n    n = bins_remain_cap.size\n    priorities = np.full(n, -np.inf, dtype=float)\n    feasible = bins_remain_cap >= item\n    if not feasible.any():\n        return priorities\n    slack = bins_remain_cap - item\n    max_cap = bins_remain_cap.max()\n    dead_thr = max_cap * dead_space_ratio\n    dead_space = (slack > 0) & (slack < dead_thr)\n    usable = feasible & ~dead_space\n    mask = usable if usable.any() else feasible\n    ratio = item / bins_remain_cap[mask]\n    slack_norm = slack[mask] / max_cap\n    base_score = ratio_weight * ratio - (1.0 - ratio_weight) * slack_norm\n    random_jitter = epsilon * np.random.rand(mask.sum())\n    if jitter_scale:\n        random_jitter += jitter_scale * np.random.rand(mask.sum())\n    priorities[mask] = base_score + random_jitter\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.1284403669724865,
    "SLOC": 27.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter23_response1.txt_stdout.txt",
    "code_path": "problem_iter23_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, bin_capacity: float = 1.0, ratio_weight: float = 0.2, jitter_scale: float = 1e-6, epsilon_base: float = 0.05) -> np.ndarray:\n    \"\"\"Best\u2011fit with capped boost, near\u2011full bonuses, ratio penalty, jitter, adaptive \u03b5\u2011greedy.\"\"\"\n    valid = bins_remain_cap >= item\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    if not np.any(valid):\n        return priorities\n    slack = bins_remain_cap[valid] - item\n    base = -slack\n    boost_factor = 0.5\n    max_boost = 3.0\n    tiny = 1e-6\n    boost = np.minimum(boost_factor / (slack + tiny), max_boost)\n    base += boost\n    base += np.isclose(slack, 0.0, atol=1e-9) * 1.0\n    base += (slack <= 0.05 * bins_remain_cap[valid]) * 0.5\n    base -= ratio_weight * (bins_remain_cap[valid] / bin_capacity)\n    base += (np.random.rand(valid.sum()) - 0.5) * jitter_scale\n    priorities[valid] = base\n    feasible = valid.sum()\n    epsilon = epsilon_base * (1 - feasible / bins_remain_cap.size)\n    if feasible and np.random.rand() < epsilon:\n        idx = np.random.choice(np.flatnonzero(valid))\n        priorities[idx] += 1.0\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 23.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter23_response2.txt_stdout.txt",
    "code_path": "problem_iter23_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Best\u2011fit scoring with static \u03b5\u2011greedy; tie\u2011breaks with tiny index offset.\"\"\"\n    epsilon = 0.05\n    scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        return scores\n    slack = bins_remain_cap[feasible] - item\n    base = -slack\n    boost = 1e-3\n    idx = np.where(feasible)[0]\n    deterministic = base + boost + 1e-9 * idx\n    if np.random.rand() < epsilon:\n        scores[feasible] = np.random.rand(np.sum(feasible))\n    else:\n        scores[feasible] = deterministic\n    return scores",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.028719585161557,
    "SLOC": 16.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter23_response3.txt_stdout.txt",
    "code_path": "problem_iter23_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Best-fit priority with static \u03b5\u2011greedy, ratio tie\u2011breaker, and capped boost.\"\"\"\n    feasible = bins_remain_cap >= item\n    scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    if not np.any(feasible):\n        return scores\n    slack = bins_remain_cap[feasible] - item\n    base = -slack\n    ratio = item / bins_remain_cap[feasible]\n    ratio_weight = 0.01\n    boost = np.minimum(0.05, 0.1 / (slack + 1.0))\n    deterministic = base + ratio_weight * ratio + boost\n    epsilon = 0.05\n    if np.random.rand() < epsilon:\n        scores[feasible] = np.random.rand(feasible.sum())\n    else:\n        scores[feasible] = deterministic\n    return scores",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 17.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter23_response4.txt_stdout.txt",
    "code_path": "problem_iter23_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best\u2011fit with capped inverse slack, near\u2011full/exact bonuses, ratio weighting, jitter, and adaptive \u03b5\u2011greedy exploration.\"\"\"\n    n = bins_remain_cap.size\n    feasible = bins_remain_cap >= item\n    scores = np.full(n, -np.inf, dtype=float)\n    if not np.any(feasible):\n        return scores\n    slack = bins_remain_cap[feasible] - item\n    base = -slack\n    threshold = max(0.01, 0.03 * item)\n    near_full = slack <= threshold\n    exact = np.isclose(slack, 0.0, atol=1e-9)\n    ratio = item / bins_remain_cap[feasible]\n    smooth_boost = 0.5 / (slack + 1e-12)\n    smooth_boost = np.minimum(smooth_boost, 5.0)\n    scores[feasible] = base + 0.4 * near_full + 1.2 * exact + smooth_boost + 0.15 * ratio\n    scores[feasible] += 1e-7 * np.random.rand(feasible.sum())\n    if not hasattr(priority_v2, \"_epsilon\"):\n        priority_v2._epsilon = 0.6\n        priority_v2._epsilon_min = 0.05\n        priority_v2._epsilon_decay = 0.995\n    priority_v2._epsilon = max(priority_v2._epsilon_min, priority_v2._epsilon * priority_v2._epsilon_decay)\n    if np.random.rand() < priority_v2._epsilon:\n        idx = np.random.choice(np.flatnonzero(feasible))\n        scores[idx] += 20.0\n    return scores",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 25.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter23_response5.txt_stdout.txt",
    "code_path": "problem_iter23_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Best\u2011fit priority using negative slack, static \u03b5\u2011greedy exploration, and index tie\u2011breaker.\"\"\"\n    epsilon = 0.05\n    n = bins_remain_cap.size\n    priorities = np.full(n, -np.inf, dtype=float)\n    feasible = bins_remain_cap >= item\n    if not feasible.any():\n        return priorities\n    slack = bins_remain_cap[feasible] - item\n    base = -slack\n    tie_break = np.arange(n)[feasible][::-1] * 1e-6\n    base += tie_break\n    if np.random.rand() < epsilon:\n        rand = np.random.rand(n)\n        rand[~feasible] = -np.inf\n        priorities = rand\n    else:\n        priorities[feasible] = base\n    return priorities",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 18.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter23_response6.txt_stdout.txt",
    "code_path": "problem_iter23_code6.py",
    "code": "import numpy as np\n\n    def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n        \"\"\"Negative slack best\u2011fit with constant \u03b5\u2011greedy, capped boost, dead\u2011space filter.\"\"\"\n        n = bins_remain_cap.size\n        priorities = np.full(n, -np.inf, dtype=float)\n        feasible_mask = bins_remain_cap >= item\n        if not feasible_mask.any():\n            return priorities\n        feasible_idx = np.flatnonzero(feasible_mask)\n        slack_all = bins_remain_cap[feasible_mask] - item\n        dead_thresh = 0.5 * bins_remain_cap[feasible_mask]\n        keep_mask = slack_all <= dead_thresh\n        if not keep_mask.any():\n            keep_mask = np.ones_like(slack_all, dtype=bool)\n        selected_idx = feasible_idx[keep_mask]\n        slack_selected = slack_all[keep_mask]\n        base = -slack_selected\n        boost = np.minimum(0.1, 0.5 / (slack_selected + 1e-9))\n        priorities[selected_idx] = base + boost\n        epsilon = 0.05\n        if np.random.rand() < epsilon:\n            rand_idx = np.random.choice(feasible_mask.nonzero()[0])\n            priorities[rand_idx] = priorities.max() + 1.0\n        return priorities",
    "response_id": 6,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 9, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 3\n    def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\nIndentationError: unexpected indent\nTraceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/SLOC.py\", line 7, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 3\n    def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\nIndentationError: unexpected indent\nTraceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/cyclomatic_complexity.py\", line 7, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 3\n    def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\nIndentationError: unexpected indent\n"
  },
  {
    "stdout_filepath": "problem_iter23_response7.txt_stdout.txt",
    "code_path": "problem_iter23_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Best\u2011fit slack + capped inverse\u2011slack boost + ratio, with \u03b5\u2011greedy and jitter.\"\"\"\n    n = bins_remain_cap.size\n    feasible = bins_remain_cap >= item\n    priorities = np.full(n, -np.inf, dtype=float)\n    if not np.any(feasible):\n        return priorities\n    slack = bins_remain_cap[feasible] - item\n    base = -slack\n    ratio = item / bins_remain_cap[feasible]\n    tiny = 1e-8\n    boost_factor = 0.5\n    max_boost = 3.0\n    boost = np.minimum(boost_factor / (slack + tiny), max_boost)\n    scores = base + boost + 0.2 * ratio\n    scores += np.random.rand(scores.shape[0]) * 1e-6\n    priorities[feasible] = scores\n    epsilon = 0.02\n    if np.random.rand() < epsilon:\n        priorities[feasible] = np.random.rand(scores.shape[0])\n    return priorities",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.0885520542481055,
    "SLOC": 20.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter23_response8.txt_stdout.txt",
    "code_path": "problem_iter23_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Best\u2011fit with static \u03b5\u2011greedy exploration, ratio tie\u2011breaker, and index jitter.\"\"\"\n    # constant exploration probability\n    epsilon = 0.08\n    n = bins_remain_cap.size\n    scores = np.full(n, -np.inf, dtype=float)\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        return scores\n    slack = bins_remain_cap[feasible] - item\n    base = -slack\n    ratio = item / bins_remain_cap[feasible]\n    base += 0.05 * ratio\n    idx = np.flatnonzero(feasible)\n    base += 1e-6 * idx\n    scores[feasible] = base\n    if np.random.rand() < epsilon:\n        rand = np.random.rand(n)\n        rand[~feasible] = -np.inf\n        scores = rand\n    return scores",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.1284403669724865,
    "SLOC": 19.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter23_response9.txt_stdout.txt",
    "code_path": "problem_iter23_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray,\n                epsilon: float = 0.05,\n                boost_factor: float = 0.5,\n                max_boost: float = 5.0,\n                ratio_weight: float = 0.1,\n                jitter: float = 1e-12) -> np.ndarray:\n    \"\"\"Score bins for online BPP: best\u2011fit (negative slack), capped boost, ratio weight, \u03b5\u2011greedy, tiny jitter.\"\"\"\n    n = bins_remain_cap.size\n    feasible = bins_remain_cap >= item\n    scores = np.full(n, -np.inf, dtype=float)\n    if not np.any(feasible):\n        return scores\n    slack = bins_remain_cap[feasible] - item\n    base = -slack\n    tiny = 1e-6\n    boost = np.minimum(boost_factor / (slack + tiny), max_boost)\n    ratio = item / bins_remain_cap[feasible]\n    combined = base + boost + ratio_weight * ratio\n    if epsilon > 0:\n        rand = np.random.rand(combined.size)\n        combined = (1 - epsilon) * combined + epsilon * rand\n    idx = np.flatnonzero(feasible)\n    combined += jitter * idx\n    scores[feasible] = combined\n    return scores",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 24.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter24_response0.txt_stdout.txt",
    "code_path": "problem_iter24_code0.py",
    "code": "import numpy as np\n\n_EPSILON = 0.05\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    n = bins_remain_cap.size\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    valid = bins_remain_cap >= item\n    if not np.any(valid):\n        return priorities\n    slack = bins_remain_cap[valid] - item\n    base_score = -slack\n    boost = (np.arange(n) / n) * 0.001\n    priorities[valid] = base_score + boost[valid]\n    max_remain = bins_remain_cap.max()\n    if np.any(bins_remain_cap[valid] < max_remain):\n        empty_bins = (bins_remain_cap == max_remain) & valid\n        priorities[empty_bins] = -np.inf\n    if np.random.rand() < _EPSILON:\n        rand_scores = np.random.rand(n)\n        rand_scores[~valid] = -np.inf\n        priorities = rand_scores\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.188272836059035,
    "SLOC": 19.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  }
]