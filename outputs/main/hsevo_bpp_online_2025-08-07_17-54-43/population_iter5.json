[
  {
    "stdout_filepath": "problem_iter5_response0.txt_stdout.txt",
    "code_path": "problem_iter5_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Adaptive \u03b5\u2011greedy best\u2011fit with worst\u2011fit bias and near\u2011full boost.\"\"\"\n    # initialize static parameters\n    if not hasattr(priority_v2, \"epsilon\"):\n        priority_v2.epsilon = 0.2          # initial exploration rate\n        priority_v2.epsilon_min = 0.01    # lower bound\n        priority_v2.decay = 0.99          # exponential decay factor\n        priority_v2.near_full_thresh = 0.05   # slack threshold for boost\n        priority_v2.near_full_boost = 0.5     # extra score for near\u2011full bins\n        priority_v2.worst_fit_weight = 0.01  # bias toward larger remaining capacity\n\n    # decay exploration rate\n    priority_v2.epsilon = max(priority_v2.epsilon_min,\n                              priority_v2.epsilon * priority_v2.decay)\n\n    slack = bins_remain_cap - item\n    feasible = slack >= 0\n    scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    if np.random.rand() < priority_v2.epsilon:\n        # exploration: random scores for feasible bins\n        scores[feas] = np.random.rand(np.count_nonzero(feasible))\n    else:\n        # exploitation: best\u2011fit (-slack) + worst\u2011fit bias\n        scores[feasible] = -slack[feasible] + priority_v2.worst_fit_weight * bins_remain_cap[feasible]\n        # near\u2011full boost\n        near_full = feasible & (slack <= priority_v2.near_full_thresh)\n        scores[near_full] += priority_v2.near_full_boost\n\n    return scores",
    "response_id": 0,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 24, in priority_v2\n    scores[feasible] = exp_scores\nNameError: name 'feas' is not defined\n20\n3\n"
  },
  {
    "stdout_filepath": "problem_iter5_response1.txt_stdout.txt",
    "code_path": "problem_iter5_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Adaptive \u03b5\u2011greedy best\u2011fit with near\u2011full boost and softmax weighting for online bin packing.\"\"\"\n    if not hasattr(priority_v2, \"_epsilon\"):\n        priority_v2._epsilon = 0.2\n        priority_v2._epsilon_min = 0.01\n        priority_v2._epsilon_decay = 0.995\n        priority_v2._step = 0\n    priority_v2._step += 1\n    priority_v2._epsilon = max(priority_v2._epsilon_min, priority_v2._epsilon * priority_v2._epsilon_decay)\n    n = bins_remain_cap.size\n    scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        return scores\n    slack = bins_remain_cap[feasible] - item\n    base = -slack\n    near_full_thresh = max(0.02, 0.05 * item)\n    boost = 0.5\n    base[slack <= near_full_thresh] += boost\n    max_base = base.max()\n    exp_scores = np.exp(base - max_base)\n    scores[feasible] = exp_scores\n    total = scores[feasible].sum()\n    if total > 0:\n        scores[feasible] = scores[feasible] / total\n    if np.random.rand() < priority_v2._epsilon:\n        rand = np.random.rand(n)\n        rand[~feasible] = -np.inf\n        return rand\n    return scores",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.108496210610296,
    "SLOC": 29.0,
    "cyclomatic_complexity": 5.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response2.txt_stdout.txt",
    "code_path": "problem_iter5_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Adaptive epsilon\u2011greedy best\u2011fit with slack inverse, near\u2011full boost, and infeasibility handling.\n    \"\"\"\n    if not hasattr(priority_v2, \"_epsilon\"):\n        priority_v2._epsilon = 0.2\n        priority_v2._epsilon_min = 0.01\n        priority_v2._epsilon_decay = 0.995\n        priority_v2._step = 0\n    priority_v2._step += 1\n    priority_v2._epsilon = max(priority_v2._epsilon_min, priority_v2._epsilon * priority_v2._epsilon_decay)\n    n = bins_remain_cap.size\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    valid = bins_remain_cap >= item\n    if not np.any(valid):\n        return priorities\n    slack = bins_remain_cap[valid] - item\n    base_priority = 1.0 / (slack + 1e-12)\n    near_full_thresh = max(0.02, 0.05 * item)\n    base_priority[slack <= near_full_thresh] += 0.5\n    priorities[valid] = base_priority\n    if np.random.rand() < priority_v2._epsilon:\n        rand_scores = np.random.rand(n)\n        rand_scores[~valid] = -np.inf\n        priorities = rand_scores\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 23.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response3.txt_stdout.txt",
    "code_path": "problem_iter5_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Adaptive epsilon\u2011greedy best\u2011fit with near\u2011full boost; infeasible bins get -inf.\"\"\"\n    # stateful parameters for epsilon decay and near\u2011full boost\n    if not hasattr(priority_v2, \"exploration_epsilon\"):\n        priority_v2.exploration_epsilon = 0.3\n        priority_v2.epsilon_min = 0.01\n        priority_v2.decay = 0.995\n        priority_v2.step = 0\n        priority_v2.near_full_threshold = 0.1\n        priority_v2.near_full_boost = 2.0\n        priority_v2.eps_small = 1e-12\n    # decay exploration epsilon\n    priority_v2.exploration_epsilon = max(\n        priority_v2.epsilon_min,\n        priority_v2.exploration_epsilon * priority_v2.decay,\n    )\n    eps = priority_v2.exploration_epsilon\n    priority_v2.step += 1\n    slack = bins_remain_cap.astype(float) - item\n    feasible = slack >= 0\n    n = bins_remain_cap.shape[0]\n    scores = np.full(n, -np.inf, dtype=float)\n    if not feasible.any():\n        return scores\n    base = 1.0 / (slack[feasible] + priority_v2.eps_small)\n    near_full = slack[feasible] <= priority_v2.near_full_threshold\n    if near_full.any():\n        base[near_full] *= priority_v2.near_full_boost\n    rand_vals = np.random.rand(base.size)\n    explore = np.random.rand(base.size) < eps\n    bin_scores = np.where(explore, rand_vals, base)\n    idx = np.where(feasible)[0]\n    bin_scores += -idx * 1e-6\n    scores[feasible] = bin_scores\n    return scores",
    "response_id": 3,
    "tryHS": false,
    "obj": 36.806940566414056,
    "SLOC": 32.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response4.txt_stdout.txt",
    "code_path": "problem_iter5_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Adaptive \u03b5\u2011greedy best\u2011fit with near\u2011full boost; -inf for infeasible bins.\"\"\"\n    if not hasattr(priority_v2, \"epsilon\"):\n        priority_v2.epsilon = 0.2\n        priority_v2.epsilon_min = 0.01\n        priority_v2.decay = 0.995\n        priority_v2.near_full_thresh = 0.05\n        priority_v2.boost = 0.5\n    eps = priority_v2.epsilon\n    n = bins_remain_cap.shape[0]\n    feasible = bins_remain_cap >= item\n    scores = np.full(n, -np.inf, dtype=float)\n    if np.random.rand() < eps:\n        scores[feasible] = np.random.rand(feasible.sum())\n    else:\n        slack = bins_remain_cap[feasible] - item\n        near_full = slack <= priority_v2.near_full_thresh\n        base = 1.0 / (slack + np.finfo(float).eps)\n        base[near_full] += priority_v2.boost\n        scores[feasible] = base\n    priority_v2.epsilon = max(priority_v2.epsilon_min, eps * priority_v2.decay)\n    return scores",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.13841244515357,
    "SLOC": 21.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response5.txt_stdout.txt",
    "code_path": "problem_iter5_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Adaptive \u03b5\u2011greedy best\u2011fit with near\u2011full boost and slight worst\u2011fit bias.\"\"\"\n    # Initialize static parameters on first call\n    if not hasattr(priority_v2, \"epsilon\"):\n        priority_v2.epsilon = 0.2          # initial exploration rate\n        priority_v2.epsilon_min = 0.01    # floor for exploration\n        priority_v2.decay = 0.995         # exponential decay factor\n        priority_v2.near_full_thresh = 0.1  # slack threshold for near\u2011full bins\n        priority_v2.beta = 0.05           # worst\u2011fit bias coefficient\n        priority_v2.boost = 0.5           # boost added to near\u2011full bins\n    # Decay epsilon after each call\n    priority_v2.epsilon = max(priority_v2.epsilon_min,\n                              priority_v2.epsilon * priority_v2.decay)\n    # Feasibility mask\n    can_fit = bins_remain_cap >= item\n    slack = bins_remain_cap - item\n    eps = np.finfo(float).eps\n    # Base score: inverse slack (best\u2011fit) with a small worst\u2011fit bias\n    base_score = np.where(can_fit,\n                          1.0 / (slack + eps) - priority_v2.beta * slack,\n                          -np.inf)\n    # Add boost for bins that are nearly full\n    near_full = (slack <= priority_v2.near_full_thresh) & can_fit\n    base_score[near_full] += priority_v2.boost\n    # \u03b5\u2011greedy exploration: random scores with probability epsilon\n    if np.random.rand() < priority_v2.epsilon:\n        scores = np.where(can_fit, np.random.rand(len(bins_remain_cap)), -np.inf)\n    else:\n        scores = base_score\n    return scores",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.0885520542481055,
    "SLOC": 23.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response6.txt_stdout.txt",
    "code_path": "problem_iter5_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Adaptive epsilon\u2011greedy best\u2011fit: prioritize minimal slack, boost near\u2011full bins, decay epsilon, mark infeasible as -inf.\"\"\"\n    if not hasattr(priority_v2, \"epsilon\"):\n        priority_v2.epsilon = 0.2\n        priority_v2.min_epsilon = 0.0\n        priority_v2.decay = 0.995\n        priority_v2.near_full_thresh = 0.05\n        priority_v2.near_full_boost = 0.5\n    eps = priority_v2.epsilon\n    n = bins_remain_cap.size\n    priorities = np.full(n, -np.inf, dtype=float)\n    feasible = bins_remain_cap >= item\n    slack = bins_remain_cap[feasible] - item\n    base = -slack\n    near_full = slack <= priority_v2.near_full_thresh\n    base[near_full] += priority_v2.near_full_boost\n    if np.random.rand() < eps:\n        rand_scores = np.random.rand(feasible.sum())\n        priorities[feasible] = rand_scores\n    else:\n        priorities[feasible] = base\n    priority_v2.epsilon = max(priority_v2.min_epsilon, eps * priority_v2.decay)\n    return priorities",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.058635819704831,
    "SLOC": 22.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response7.txt_stdout.txt",
    "code_path": "problem_iter5_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Adaptive best-fit with worst\u2011fit bias, near\u2011full boost and \u03b5\u2011greedy.\"\"\"\n    if not hasattr(priority_v2, \"epsilon\"):\n        priority_v2.epsilon = 0.5\n        priority_v2.epsilon_min = 0.05\n        priority_v2.decay = 0.995\n        priority_v2.step = 0\n        priority_v2.near_full_thresh = 0.1\n        priority_v2.alpha = 0.01\n    if np.random.rand() < priority_v2.epsilon:\n        return np.random.random(bins_remain_cap.shape)\n    slack = bins_remain_cap - item\n    valid = slack >= 0\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    priorities[valid] = -slack[valid] + priority_v2.alpha * slack[valid]\n    near_full = slack <= priority_v2.near_full_thresh\n    priorities[valid & near_full] += 0.5\n    priority_v2.epsilon = max(priority_v2.epsilon_min, priority_v2.epsilon * priority_v2.decay)\n    priority_v2.step += 1\n    return priorities",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.188272836059035,
    "SLOC": 19.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response8.txt_stdout.txt",
    "code_path": "problem_iter5_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Adaptive epsilon\u2011greedy best\u2011fit with near\u2011full boost.\n    \"\"\"\n    if not hasattr(priority_v2, \"_epsilon\"):\n        priority_v2._epsilon = 0.3\n        priority_v2._epsilon_min = 0.05\n        priority_v2._decay = 0.99\n        priority_v2._step = 0\n        priority_v2._boost_factor = 1.5\n    priority_v2._epsilon = max(priority_v2._epsilon_min, priority_v2._epsilon * priority_v2._decay)\n    priority_v2._step += 1\n    slack = bins_remain_cap - item\n    feasible = slack >= 0\n    eps_num = np.finfo(float).eps\n    base_score = np.where(feasible, 1.0/(slack+eps_num), 0.0)\n    near_full_thresh = 0.05 * np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else 0.0\n    near_full_mask = (slack <= near_full_thresh) & feasible\n    base_score[near_full_mask] *= priority_v2._boost_factor\n    random_score = np.random.rand(len(bins_remain_cap))\n    scores = np.where(feasible, (1 - priority_v2._epsilon) * base_score + priority_v2._epsilon * random_score, -np.inf)\n    return scores",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.5073793378540135,
    "SLOC": 19.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response9.txt_stdout.txt",
    "code_path": "problem_iter5_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Adaptive best-fit: prioritize low slack, boost near-full bins, decaying epsilon-greedy exploration.\"\"\"\n    if not hasattr(priority_v2, \"epsilon\"):\n        priority_v2.epsilon = 0.2\n        priority_v2.min_epsilon = 0.01\n        priority_v2.decay = 0.995\n        priority_v2.near_full_thresh = 0.1\n        priority_v2.boost = 0.5\n    eps = priority_v2.epsilon\n    n = bins_remain_cap.size\n    priorities = np.full(n, -np.inf, dtype=float)\n    feasible = bins_remain_cap >= item\n    slack = bins_remain_cap[feasible] - item\n    base = -slack\n    boost_mask = slack <= priority_v2.near_full_thresh\n    base[boost_mask] + = priority_v2.boost\n    random_score = np.random.rand(base.shape[0])\n    priorities[feasible] = (1 - eps) * base + eps * random_score\n    priority_v2.epsilon = max(priority_v2.min_epsilon, eps * priority_v2.decay)\n    return priorities",
    "response_id": 9,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 9, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 18\n    base[boost_mask] + = priority_v2.boost\n                       ^\nSyntaxError: invalid syntax\nTraceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/SLOC.py\", line 7, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 18\n    base[boost_mask] + = priority_v2.boost\n                       ^\nSyntaxError: invalid syntax\nTraceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/cyclomatic_complexity.py\", line 7, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 18\n    base[boost_mask] + = priority_v2.boost\n                       ^\nSyntaxError: invalid syntax\n"
  }
]