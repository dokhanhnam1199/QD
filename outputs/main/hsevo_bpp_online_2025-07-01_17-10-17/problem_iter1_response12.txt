```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap)

    # 1. Feasibility check. Give 0 priority if the item doesn't fit.
    feasible_bins = bins_remain_cap >= item
    priorities[~feasible_bins] = -np.inf

    # 2. Maximize filled space while leaving some room for future items (Newton's Margin).
    #   - Encourage bins that can accommodate the item with the least wasted space,
    #     but penalize bins that get too full (avoiding near-full bins for future, potentially smaller, items).

    # Calculate wasted space
    wasted_space = bins_remain_cap - item
    wasted_space[~feasible_bins] = np.inf  # Ensure infeasible bins are effectively ignored.

    #Prioritize bins with smaller wasted space. An ideal wasted space would depend on the typical item size expected. Here we don't assume any prior on item sizes. Thus we try a sigmoid-like behavior
    priorities[feasible_bins] = np.exp(-wasted_space[feasible_bins]) #Bins with small wasted space get higher priority.

    #Enhance priorities for almost full bins to close them. Helps to complete them and reduce future bins.
    almost_full_mask = (bins_remain_cap >= item) & (bins_remain_cap < 2*item)
    priorities[almost_full_mask] +=1 #small bonus if the bin gets closed soon

    return priorities
```
