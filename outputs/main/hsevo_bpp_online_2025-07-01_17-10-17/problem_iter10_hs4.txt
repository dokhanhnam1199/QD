import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 5.9115440920611925e-09,
                  capacity_utilization_center: float = 0.6601464936882396, capacity_utilization_std: float = 0.1910770580720157,
                  best_fit_weight: float = 0.6012436488600558, capacity_weight: float = 0.2883418965595296) -> np.ndarray:
    """Assign priorities to bins based on a combination of factors,
    including best fit, remaining capacity utilization, and a penalty for
    bins that are already too full. This version tries to balance several
    objectives more explicitly.
    """
    priorities = np.zeros_like(bins_remain_cap)

    # 1. Best Fit Prioritization: Prioritize bins where the item fits best
    #    (smallest waste).

    waste = bins_remain_cap - item
    valid_bins = waste >= 0
    if not np.any(valid_bins):
        return priorities  # No suitable bins

    waste[~valid_bins] = np.inf # Set waste of invalid bins to infinity

    best_fit_priority = 1.0 / (waste + epsilon)
    best_fit_priority[~valid_bins] = 0.0  # Zero out invalid bins


    # 2. Capacity Utilization: Favor bins that are already reasonably full.
    #    This encourages filling existing bins before opening new ones.
    capacity_utilization = bins_remain_cap / np.max(bins_remain_cap)  # Normalize

    # Prioritize bins that are neither too empty nor too full.
    # Adjust the parameters to fine-tune the behavior.
    capacity_priority = np.exp(-((capacity_utilization - capacity_utilization_center)**2) / (2 * (capacity_utilization_std)**2))
    capacity_priority[~valid_bins] = 0.0

    # 3. Combine the priorities, weighting best fit more heavily initially.
    #    The weights can be adjusted based on the specific problem instance.
    priorities = best_fit_weight * best_fit_priority + capacity_weight * capacity_priority

    #Zero out invalid bins
    priorities[bins_remain_cap < item] = 0
    return priorities
