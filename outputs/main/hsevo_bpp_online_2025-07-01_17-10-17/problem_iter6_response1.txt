```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Assign priorities to bins based on remaining capacity fit, target fill, and bin utilization."""

    epsilon = 1e-9
    
    # 1. Feasibility: Only consider bins that can accommodate the item.
    feasible_bins = bins_remain_cap >= item
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    if not np.any(feasible_bins):
        return priorities # No feasible bin, all priorities remain zero.

    # 2. Waste Minimization: Prioritize bins that minimize wasted space.
    waste = bins_remain_cap - item
    waste_priority = 1 / (waste[feasible_bins] + epsilon)

    # 3. Target Fill:  Encourage bins to reach a target fill level (e.g., 75%).
    target_fill_level = 0.75
    target_capacity = target_fill_level  # Assuming bin capacity is 1.0 (normalized)
    target_diff = np.abs(bins_remain_cap[feasible_bins] - (1 - target_capacity))
    target_priority = 1 / (target_diff + epsilon)

    # 4. Bin Utilization: Slightly favor bins that are already somewhat full to consolidate items. Avoids creating many almost-empty bins.
    utilization_priority = bins_remain_cap[feasible_bins]  # Higher remaining capacity, lower priority, since smaller values are more full.
    # Invert and normalize to make smaller bin_remain_cap have higher priority
    utilization_priority = 1 - utilization_priority/np.max(bins_remain_cap)
    
    # 5. Combine Priorities (Weighted): Adjust weights as needed.  Higher weight to waste minimization
    combined_priority = (0.6 * waste_priority + 0.3 * target_priority + 0.1 * utilization_priority)
    
    # Assign combined priorities to feasible bins
    priorities[feasible_bins] = combined_priority

    return priorities
```
