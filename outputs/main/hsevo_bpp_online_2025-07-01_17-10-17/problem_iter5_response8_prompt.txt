{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Assign priorities to bins based on remaining capacity, waste, and bin fill level.\"\"\"\n\n    epsilon = 1e-9\n    \n    # 1. Waste Minimization: Prioritize bins where the item fits with minimal waste.\n    waste = bins_remain_cap - item\n    waste_priority = np.where(waste >= 0, 1 / (waste + epsilon), 0)  # Avoid inverting negative waste\n\n    # 2. Capacity Utilization: Favor bins that are already relatively full.\n    utilization = 1 - (bins_remain_cap / np.max(bins_remain_cap))  # Normalize remaining capacity\n    utilization_priority = utilization  # Higher remaining capacity = lower priority\n    \n    #3. Balance Item Size vs. Remaining Capacity\n    size_ratio = item / np.max(bins_remain_cap) #Ratio to bin max capacity\n    size_priority = np.exp(-np.abs(bins_remain_cap - item)/np.max(bins_remain_cap)) #Prioritize close values\n\n    # 4. Combine Priorities: Weighted sum of waste minimization and existing fill level.\n    priorities = 0.6 * waste_priority + 0.2 * utilization_priority + 0.2 * size_priority\n\n    # Zero out invalid bins.\n    priorities[bins_remain_cap < item] = 0\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Prioritizes bins based on waste and fill level, avoiding overfilling.\"\"\"\n\n    epsilon = 1e-9\n    distances = np.abs(bins_remain_cap - item)\n    \n    # High priority if capacity close to item size and bin fits.\n    priority = 1 / (distances + epsilon)\n    \n    # Discourage almost-full bins.\n    priority = priority * (bins_remain_cap > item * 1.1)\n\n    # Encourage bins to be closer to half-full\n    target_fill = np.max(bins_remain_cap)/2\n    fill_distances = np.abs(bins_remain_cap - target_fill)\n    priority = priority / (fill_distances + epsilon)\n    \n    priority[bins_remain_cap < item] = 0  # Zero out if bin can't fit\n\n    return priority\n\n### Analyze & experience\n- *   Comparing (1st) vs (20th), we see the best and worst heuristics are identical, suggesting that the ranking is based on external factors, not code differences.\n*   Comparing (3rd) vs (4th), we observe that both are identical. This suggests a possible issue in the ranking methodology or data. The heuristics include waste minimization, target fill (75%), and a diversity bonus based on post-fit capacity. Weights are applied to combine these factors.\n*   Comparing (5th) vs (6th) vs (7th), these functions are identical. They prioritize bins based on waste, fill level, and penalize almost-full bins. This again highlights an issue with the ranking, as identical heuristics should not have different ranks.\n*   Comparing (1st) vs (8th), the former uses numpy for vectorized operations while the latter uses a `for` loop, making the former much more efficient. The former also factors in half-full fill target, while the latter focuses on penalizing near-full bins.\n*   Comparing (1st) vs (9th), (10th), (11th), (12th), the first one focus on waste minimization and half-full target, while the others combine waste minimization, capacity utilization and balance item size vs remaining capacity.\n*   Comparing (14th) vs (15th), the codes are identical. They focuses on combining waste minimization, target fill level.\n*   Comparing (16th) vs (17th), the codes are identical. They prioritizes bins based on waste and fill level, avoiding overfilling.\n*   Comparing (18th) vs (19th) vs (20th), the codes are identical. They assigns priorities based on waste minimization, target fill level and bin utilization.\n\nOverall: The best heuristics seem to focus on a combination of waste minimization and target fill levels. Some heuristics introduce a diversity bonus or penalize almost-full bins. The use of NumPy for vectorized operations is important for efficiency. The later heuristics attempt to combine multiple factors, but the effectiveness depends on the chosen weights and the specific problem instance.\n- \nOkay, let's refine self-reflection for designing better heuristics, focusing on practicality and avoiding pitfalls.\n\n*   **Keywords:** Measurable outcomes, efficiency, adaptability, transparency.\n\n*   **Advice:** Ground heuristic design in quantifiable performance metrics (e.g., waste percentage, target satisfaction). Prioritize simple, easily understood mechanisms and favor methods that promote efficient resource use and balanced workload distribution.\n\n*   **Avoid:** Over-reliance on complex or abstract ideas. Minimize unnecessary computational overhead.\n\n*   **Explanation:** Focus on interpretable heuristics based on directly measurable factors, making it easier to understand the logic and adjust parameters effectively.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}