{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Assign priorities to bins based on multiple factors.\"\"\"\n\n    epsilon = 1e-9\n    \n    # 1. Immediate Fit: Prioritize bins where the item fits.\n    fit_priority = (bins_remain_cap >= item).astype(float)\n\n    # 2. Waste Minimization: Minimize wasted space.\n    waste = bins_remain_cap - item\n    waste_priority = np.where(waste >= 0, 1 / (waste + epsilon), 0)\n\n    # 3. Balance Fill: Favor bins nearing target fill level (e.g., 75%).\n    target_fill_level = 0.75  # Adjustable target fill level\n    target_capacity = bins_remain_cap * target_fill_level\n    balance_priority = np.abs((bins_remain_cap - item) - target_capacity)\n    balance_priority = np.where(bins_remain_cap >= item, 1 / (balance_priority + epsilon), 0)\n\n    # 4. Combination of Priorities (Weighted): Combine the priorities\n    priorities = (0.5 * fit_priority + 0.3 * waste_priority + 0.2 * balance_priority)\n    \n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n                bins_remain_cap: np.ndarray,\n                waste_epsilon: float = 0.0014920289345347385,\n                target_fill_ratio: float = 0.543580664621467,\n                fill_std_dev_factor: float = 0.2264523177966476,\n                almost_full_threshold_ratio: float = 0.8618165419074774,\n                almost_full_penalty: float = 0.6409438768761745) -> np.ndarray:\n    \"\"\"Prioritize bins based on waste minimization and target fill level.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    possible_bins = bins_remain_cap >= item\n\n    if not np.any(possible_bins):\n        return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see that both prioritize waste minimization and target fill. However, the 1st uses `half_full_priority` which is a more nuanced approach to targeting a half-full state, while the 20th calculates `fill_priority` towards 75% full. The 1st directly calculates the distance to half-full *after* placing the item.\n\nComparing (2nd) vs (3rd), the 2nd prioritizes waste and targets 75% fill, penalizing almost full bins. The 3rd incorporates a \"diversity bonus\" intended to spread items across bins and weights the priorities using fixed factors (0.6, 0.3, 0.1).\n\nComparing (4th) vs (5th), the functions are identical, indicating a potential issue in ranking or a missed difference.\n\nComparing (15th) vs (16th), these are identical and incomplete. They declare parameters like `waste_epsilon`, `target_fill_ratio`, `fill_std_dev_factor`, `almost_full_threshold_ratio`, and `almost_full_penalty` but don't implement any logic.\n\nComparing (17th) vs (18th), they both focus on waste minimization and a target fill level of 75%. They differ slightly in how the target fill distance is calculated.\n\nOverall: The best heuristics combine waste minimization with a target fill level (often around 50-75%). More successful heuristics involve a good balance in assigning the weights for each factor that is used to calculate the final priorities (e.g. waste minimization, target fill). The weaker ones tend to either omit key elements, have less refined calculations, or fail to effectively combine different factors. Some heuristics are also simply duplicates.\n- \nOkay, I understand the goal: to redefine \"Current self-reflection\" into a more actionable and effective guide for designing heuristics, explicitly avoiding pitfalls identified in \"Ineffective self-reflection.\" Let's aim for clarity, conciseness, and practical advice.\n\nHere's a revised approach:\n\n*   **Keywords:** Efficiency, accuracy, balance, directness, simplicity, validation.\n*   **Advice:** Design heuristics focusing on directly measurable objectives like waste reduction and resource utilization. Combine relevant factors with clear, justifiable weights. Thoroughly validate the heuristic's performance across diverse scenarios.\n*   **Avoid:** Over-reliance on speed optimizations (premature optimization). Abstract analogies instead of direct measurements. Unnecessarily complex calculations.\n*   **Explanation:** Emphasize fundamental objectives and validation. Prioritize understanding the problem and creating a transparent, well-justified heuristic over purely speed-focused or overly complicated approaches.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}