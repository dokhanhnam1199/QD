```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Assign priorities to bins based on waste minimization, fill target, and bin diversity."""

    epsilon = 1e-9
    distances = np.abs(bins_remain_cap - item)

    # Prioritize bins where item nearly fits, less wasted space.  Higher exponent emphasizes small distances.
    base_priority = 1 / (distances**0.5 + epsilon)

    # Encourage bins towards a fill target (e.g., 75% full).  This promotes better overall utilization.
    fill_target_ratio = 0.75
    target_capacity = bins_remain_cap * fill_target_ratio
    target_priority = 1 / (np.abs((bins_remain_cap - item) - target_capacity) + epsilon)

    # Introduce a diversity bonus: Prefer bins with higher remaining capacity *after* placing the item,
    # but only if the item fits. This encourages spreading items across bins and avoids overfilling some bins early on.
    post_fit_capacity = bins_remain_cap - item
    diversity_bonus = np.where(post_fit_capacity >= 0, post_fit_capacity / (np.sum(np.where(post_fit_capacity >= 0, post_fit_capacity,0)) + epsilon), 0)
    diversity_priority = diversity_bonus
    
    # Combine priorities with appropriate weights.  Adjust weights based on problem characteristics.
    priorities = 0.6 * base_priority + 0.3 * target_priority + 0.1 * diversity_priority

    # Zero out invalid bins.
    priorities[bins_remain_cap < item] = 0

    return priorities
```
