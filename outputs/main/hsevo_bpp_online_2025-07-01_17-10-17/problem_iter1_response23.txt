```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version prioritizes bins that can accommodate the item with minimal wasted space.
    It also discourages placing items in nearly full bins to avoid fragmentation.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Give a large negative priority if item doesn't fit
    priorities[bins_remain_cap < item] = -np.inf

    # Prioritize bins where the item fits. Higher priority for less wasted space, but also less
    # likely to cause extreme fragmentation if the remaining capacity is very low.
    fit_indices = bins_remain_cap >= item
    if np.any(fit_indices):
        waste = bins_remain_cap[fit_indices] - item
        priorities[fit_indices] = -waste + (bins_remain_cap[fit_indices] / np.max(bins_remain_cap)) # Prioritize lower waste and high cap

    # Add a small bias to use more empty bins than close to being full, unless nothing fits
    if np.any(bins_remain_cap >= item):
        priorities = priorities + (bins_remain_cap/ np.max(bins_remain_cap)) * 0.1


    return priorities
```
