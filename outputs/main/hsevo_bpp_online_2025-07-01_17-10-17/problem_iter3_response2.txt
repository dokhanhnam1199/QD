```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Assign priorities to bins based on a combined metric of waste and balance."""
    epsilon = 1e-9
    
    # 1. Waste Minimization: Prioritize bins with minimal waste after packing the item.
    waste = bins_remain_cap - item
    waste_priority = np.where(waste >= 0, 1 / (waste + epsilon), 0)  # Only consider bins where item fits
    
    # 2. Balance: Encourage filling bins to a target level (e.g., 75% full). This encourages even distribution.
    target_fill_level = 0.75
    target_capacity = target_fill_level  # Assuming bin capacity is 1.0 (normalized)
    remaining_after_fill = bins_remain_cap - item
    
    # Calculate how close the remaining capacity is to the target fill level.
    balance_distance = np.abs(remaining_after_fill - (1 - target_capacity))
    balance_priority = np.where(waste >= 0, 1 / (balance_distance + epsilon), 0)

    # 3. Bin Utilization: Preferentially use bins that are already somewhat full
    utilization_priority = bins_remain_cap / (1 + epsilon)
    utilization_priority = np.where(waste >= 0, 1 - utilization_priority, 0)


    # Combine the priorities: Emphasize waste minimization and balance, and some bin utilization.
    priorities = 0.5 * waste_priority + 0.3 * balance_priority + 0.2 * utilization_priority
    
    return priorities
```
