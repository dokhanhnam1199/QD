```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version prioritizes bins that can accommodate the item with minimal remaining space,
    but also discourages excessive fragmentation by penalizing bins where the remaining space
    after packing would be too small.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Calculate remaining capacity after packing
    remaining_after_packing = bins_remain_cap - item

    # Give a high priority to bins that can fit the item
    can_fit = remaining_after_packing >= 0
    priorities[can_fit] = 1.0

    # Further refine priority based on how well the item fits
    fit_amount = bins_remain_cap[can_fit] - item
    
    # Give higher priority to bins where the remaining space after fitting is small,
    # but not *too* small (to avoid excessive fragmentation).  Using a logistic function
    # to achieve this.
    
    fragmentation_penalty = 1 / (1 + np.exp( -5 * (fit_amount - np.mean(fit_amount))))
    priorities[can_fit] += (1 - fragmentation_penalty)  # Slightly higher weight on tightest fit
    

    # Optionally penalize bins that would leave very little space after packing,
    # as this contributes to fragmentation and difficulties later on.  This is
    # a simple, more direct fragmentation avoidance mechanism compared to the above.
    too_small = remaining_after_packing < 0.1 # e.g., less than 10% of bin size. tunable.
    priorities[too_small] = -1.0  # Negative priority to strongly discourage.

    # Bins that can't fit get zero priority, which is already set by the initialization
    # Don't let these go negative.
    priorities[priorities < 0] = 0

    return priorities
```
