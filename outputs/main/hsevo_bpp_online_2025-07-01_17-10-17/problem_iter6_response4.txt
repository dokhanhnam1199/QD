```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Assign priorities to bins based on a combination of factors:
    - Waste minimization: Prioritize bins where the item nearly fits.
    - Balance fill level: Encourage bins to be filled to a target level (e.g., 75%).
    - Avoidance of near-empty bins: Discourage placing items in bins that would leave them almost empty.
    """
    epsilon = 1e-9
    
    # 1. Waste Minimization:
    distances = np.abs(bins_remain_cap - item)
    waste_priority = 1 / (distances + epsilon)

    # 2. Target Fill Level (e.g., 75%):
    target_fill = 0.75
    target_capacity = target_fill * np.max(bins_remain_cap + item) #Assumed that all bins have same capacity, and find the capacity
    fill_level_diff = np.abs((bins_remain_cap - item) - (1-target_fill) * np.max(bins_remain_cap + item) ) # The deviation from target fill level after placing the item
    fill_level_priority = 1 / (fill_level_diff + epsilon)
    
    # 3. Avoid Near-Empty Bins (e.g., less than 25% full after placing the item):
    min_fill_threshold = 0.25
    near_empty_penalty = np.where((bins_remain_cap - item) / np.max(bins_remain_cap + item) < min_fill_threshold, 0.1, 1.0)  # Reduce priority if bin becomes near-empty

    # Combine priorities:
    priorities = waste_priority + fill_level_priority * 0.75 * near_empty_penalty #tune factors, waste is most important

    # Zero out invalid bins:
    priorities[bins_remain_cap < item] = 0

    return priorities
```
