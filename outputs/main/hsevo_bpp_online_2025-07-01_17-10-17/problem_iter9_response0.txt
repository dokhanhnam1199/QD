```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Assign priorities to bins based on a combination of factors, 
    including best fit, remaining capacity utilization, and bin diversity."""

    epsilon = 1e-9
    n_bins = len(bins_remain_cap)

    # 1. Best Fit: Prioritize bins where the item fits with minimal waste.
    waste = bins_remain_cap - item
    best_fit_priority = np.where(waste >= 0, 1 / (waste + epsilon), 0)

    # 2. Capacity Utilization: Encourage filling bins to a reasonable level.
    #    Bins close to 75% utilization after packing are favored.
    target_utilization = 0.75
    utilization_level = (bins_remain_cap - item) / (1 - target_utilization + epsilon) #scale around the target
    utilization_priority = 1 / (np.abs(utilization_level - 1) + epsilon) #higher around the target
   # utilization_priority = np.clip(utilization_priority, 0, 1) #clip between 0 and 1
    utilization_priority[bins_remain_cap < item] = 0


    # 3. Bin Diversity: Avoid over-saturating bins with similar fill levels.
    #    This encourages exploration of different bin configurations.
    
    capacity_range = np.max(bins_remain_cap) - np.min(bins_remain_cap) + epsilon
    diversity_priority = (bins_remain_cap - np.mean(bins_remain_cap)) / capacity_range
    diversity_priority = np.abs(diversity_priority) #take the absolute value
    diversity_priority = 1 - diversity_priority #invert it so diversity is encouraged.
    diversity_priority[bins_remain_cap < item] = 0
    # 4. Combine Priorities with Weights:
    #    Adjust weights based on problem characteristics.
    best_fit_weight = 0.5
    utilization_weight = 0.4
    diversity_weight = 0.1

    priorities = (best_fit_weight * best_fit_priority +
                  utilization_weight * utilization_priority +
                  diversity_weight * diversity_priority)

    # 5. Ensure Invalid Bins Have Zero Priority:
    priorities[bins_remain_cap < item] = 0

    return priorities
```
