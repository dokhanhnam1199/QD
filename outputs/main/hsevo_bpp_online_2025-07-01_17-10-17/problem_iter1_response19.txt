```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version considers several factors:
        1. Remaining capacity: Bins with capacity closer to the item size get higher priority.
        2. Avoidance of fragmentation: Bins with large remaining capacity relative to item size are penalized.
        3. Number of items already in the bin (implicitly through remaining capacity). Favors bins that are less full
           up to a point.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    for i, cap in enumerate(bins_remain_cap):
        if cap < item:
            priorities[i] = -np.inf  # Cannot fit
            continue

        # 1. Capacity closer to item size is better.  Use an exponential decay.
        capacity_score = np.exp(-abs(cap - item) / (item + 1e-9))

        # 2. Penalize large remaining capacity to avoid fragmentation.
        fragmentation_penalty = np.exp(- (cap / (item + 1e-9)) ) # Higher remaining capacity results in lower score. item acts as normalizer.

        # 3. Favor bins with less fullness, but not extremely empty.
        #  Bins that have just enough space gets a score around 1 and those with way too much get very low
        fullness_score = np.arctan(item / (cap + 1e-9))  # Arc tangent gives a smooth preference for fuller bins. Avoids favoring the extremely empty bins too much.

        priorities[i] = capacity_score * (1 - fragmentation_penalty) * (1+ fullness_score)

    return priorities
```
