```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Assign priorities to bins considering waste, balance, and bin utilization."""

    epsilon = 1e-9
    n_bins = len(bins_remain_cap)

    # 1. Waste-based Priority (Minimize Waste)
    waste = bins_remain_cap - item
    waste_priority = np.where(waste >= 0, 1 / (waste + epsilon), 0)

    # 2. Bin Utilization Priority (Encourage fuller bins, but not overfull)
    utilization = (bins_remain_cap - item) / bins_remain_cap # remaining cap after placing the item/ remaining cap before placing the item
    utilization_priority = np.where(utilization >= 0, (1 - utilization) , 0)

    # 3. Balance Priority (Balance load across bins - prevent one bin from being too full too early)
    avg_remaining_cap = np.mean(bins_remain_cap)
    balance_priority = 1 / (np.abs(bins_remain_cap - avg_remaining_cap) + epsilon)

    # 4. Empty bin priority (Use an empty bin if exists, prevent fragmentation)
    empty_bin_priority = np.where(bins_remain_cap == bins_remain_cap.max(), 1.0, 0.0)  # Prioritize bins with maximum remaining capacity
    # Combine priorities
    priorities = (
        0.5 * waste_priority +
        0.2 * utilization_priority +
        0.2 * balance_priority +
        0.1 * empty_bin_priority
    )

    # Ensure valid bins
    priorities[bins_remain_cap < item] = 0.0

    return priorities
```
