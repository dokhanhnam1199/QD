```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Inspired by gravitational potential energy and momentum.  Larger bins
    (analogous to larger mass attracting the item) and bins where the
    item would nearly fill them (like maximizing the change in momentum,
    i.e., stopping distance) are preferred.  Bins that are too small
    get a negative priority.  A small capacity is added to the denominator to prevent division by zero.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    epsilon = 1e-9  # Avoid division by zero and give a minimal preference

    # Gravitational potential: higher remaining capacity is preferred
    gravitational_priority = bins_remain_cap

    # Momentum priority: prefer to almost fill the bin
    momentum_priority = (bins_remain_cap - item) / (bins_remain_cap + epsilon)  # Smaller is better (nearly filled)
    momentum_priority = np.clip(momentum_priority, a_min=0, a_max=None) # Only consider valid bins
    momentum_priority = 1 - momentum_priority  # Higher when closer to full after packing item
    
    # Penalize bins that are too small: Newtonian constraint
    too_small = bins_remain_cap < item
    momentum_priority[too_small] = -1.0  # Very low priority for bins that can't fit the item

    priorities = gravitational_priority * momentum_priority
    return priorities
```
