```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Assign priorities to bins based on a combination of factors:
    1. Waste minimization (fitting snugly).
    2. Bin utilization (filling bins effectively).
    3. Encouraging balance across bins.
    """
    epsilon = 1e-9
    n_bins = len(bins_remain_cap)

    # 1. Waste Minimization: Prioritize bins where the item fits with minimal waste.
    waste = bins_remain_cap - item
    waste_priority = 1 / (waste + epsilon)  # Higher priority for smaller waste

    # 2. Bin Utilization: Prioritize bins that are already relatively full.
    utilization = 1 - (bins_remain_cap / np.max(bins_remain_cap)) if np.max(bins_remain_cap) > 0 else np.zeros(n_bins)
    utilization_priority = utilization

    # 3. Balance: Penalize bins that are already very full. Encourages distribution.
    balance_priority = 1 - (bins_remain_cap / np.max(bins_remain_cap)) if np.max(bins_remain_cap) > 0 else np.ones(n_bins)

    # Combine priorities with weights. These weights can be tuned.
    waste_weight = 0.6
    utilization_weight = 0.3
    balance_weight = 0.1

    priorities = (waste_weight * waste_priority +
                  utilization_weight * utilization_priority +
                  balance_weight * balance_priority)

    # Zero out invalid bins (where the item doesn't fit).
    priorities[bins_remain_cap < item] = 0

    return priorities
```
