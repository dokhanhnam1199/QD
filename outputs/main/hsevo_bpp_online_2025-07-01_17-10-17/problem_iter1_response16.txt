```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    A more nuanced approach inspired by gravitational lensing around black holes and simulated annealing.
    We want to consider:
        1.  How well the item *fits* (remaining space) -- closer to filling the bin is good, avoids fragmentation
        2.  Whether the item *fits at all* -- immediately discard bins that are too small, set to -inf
        3.  Encourage reuse of bins (explore): small bonus for bins that are not completely empty but can't fit the item perfectly, to reuse the existing active bins
        4.  Discourage use of empty bins unless absolutely necessary.
    This introduces a temperature parameter to balance exploration and exploitation.
    A low temperature (closer to 0) means the bin filling will be strongly biased towards nearly full bins, and we're exploiting.
    A high temperature (closer to 1) introduces randomness, exploring options outside the best-fit.
    And uses a soft-max-like behavior for priority.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    temperature = 0.1  # Adjust for exploration/exploitation balance (0 to 1). Lower is more greedy.

    # Start with a very negative priority for bins that are too small
    priorities = np.full_like(bins_remain_cap, -np.inf)
    can_fit = bins_remain_cap >= item
    priorities[can_fit] = 0  # Reset bins which *can* fit.

    # Calculate the ratio of the item size to the remaining capacity for the bins that *can* fit it
    fit_ratios = item / bins_remain_cap[can_fit]
    fit_scores = -np.abs(1 - fit_ratios)  # Score closer to 0 means better fill. Higher value preferred due to next exponentiation step.

    # Add these bin filling scores, scaling by a Boltzmann-like factor for stochasticity (exploration).
    priorities[can_fit] = np.exp(fit_scores / temperature) # Boltzmann Exploration. Favor bins which leave less space
    # Add a slight incentive to reuse non-empty bins if this is not the first item to pack
    almost_full_idx = (bins_remain_cap > 0) & (bins_remain_cap < item)
    priorities[almost_full_idx] += 0.01

    return priorities
```
