```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version prioritizes bins that can accommodate the item with minimal wasted space
    while also discouraging filling bins too much (to allow flexibility for future, larger items).
    It uses a combination of remaining capacity and fill ratio.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    for i, capacity in enumerate(bins_remain_cap):
        if capacity >= item:
            # Calculate wasted space:
            wasted_space = capacity - item

            # Calculate fill ratio:
            fill_ratio = item / capacity

            # Prioritize bins that have minimal wasted space relative to item size,
            # while also considering fill ratio to avoid overly full bins.

            # Example weighting:
            # Higher weight on wasted_space (negative) means lower wasted space is preferred.
            # Lower weight on fill_ratio means less full bins are preferred, but not as strongly as minimizing wasted space.
            priorities[i] = -wasted_space/item + 0.5*fill_ratio # Adjust weights as needed for optimal performance

        else:
            priorities[i] = -np.inf  # Impossible to fit: lowest priority

    return priorities
```
