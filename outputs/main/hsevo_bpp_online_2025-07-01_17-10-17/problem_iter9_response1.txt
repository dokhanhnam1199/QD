```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Assign priorities to bins, focusing on best fit and a fill target,
    while also penalizing near misses aggressively.
    """
    epsilon = 1e-9
    
    # 1. Best Fit Priority: Prioritize bins with minimal remaining space after packing.
    remaining_space = bins_remain_cap - item
    best_fit_priority = np.where(remaining_space >= 0, 1 / (remaining_space + epsilon), 0)  # Only valid bins

    # 2. Fill Target Priority: Encourage bins to reach a target fill level (e.g., 75%).
    target_fill = 0.75  # Target fill percentage (adjust as needed)
    target_capacity = bins_remain_cap * target_fill
    fill_distance = np.abs((bins_remain_cap - item) - target_capacity)
    fill_priority = np.where(bins_remain_cap >= item, 1 / (fill_distance + epsilon), 0)

    # 3. Waste Penalty: Heavily penalize bins where the item *almost* fits but doesn't.
    waste_penalty = np.where((bins_remain_cap > item * 0.9) & (bins_remain_cap < item), -100, 0)  # Significant penalty for near misses
    waste_penalty = np.where(bins_remain_cap < item, -np.inf, waste_penalty) # Ensure invalid bins are excluded

    # Combine priorities with weighted sum
    priorities = best_fit_priority + fill_priority + waste_penalty

    return priorities
```
