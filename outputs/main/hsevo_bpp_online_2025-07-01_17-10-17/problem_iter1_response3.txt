```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # 1. Feasibility: A bin must have enough remaining capacity to hold the item.
    feasible_bins = bins_remain_cap >= item

    # If no bins are feasible, return a low-priority array (all zeros). This signals that a new bin must be opened.
    if not np.any(feasible_bins):
        return priorities

    # 2. Fill Ratio: Higher fill ratio after adding the item = higher priority, but only for feasible bins.
    fill_ratios = np.zeros_like(bins_remain_cap, dtype=float)
    fill_ratios[feasible_bins] = item / bins_remain_cap[feasible_bins]

    # 3. Balance: Penalize bins that are close to full. This encourages a more balanced distribution.
    remaining_capacity_ratios = bins_remain_cap / bins_remain_cap.max() #normalized remaining capacity ratios
    balance_penalty = np.where(feasible_bins, np.exp(-5 * remaining_capacity_ratios),0)

    # 4. Reward fuller bins with higher priority to encourage filling existing ones before opening new ones.
    current_fill_ratio = (bins_remain_cap.max() - bins_remain_cap)/bins_remain_cap.max() #current fill ratio

    #5. Avoid bins that are almost exactly full to reduce fragmentation
    exact_fit_reward = np.isclose(item, bins_remain_cap) * 1.5 #A small extra bonus for "perfect" fits

    priorities = fill_ratios  + balance_penalty + current_fill_ratio + exact_fit_reward

    return priorities
```
