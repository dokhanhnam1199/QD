{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Higher values indicate better fit.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    possible_bins = bins_remain_cap >= item\n\n    if not np.any(possible_bins):\n        return priorities  # No bin can fit the item, so no priority. All zero\n\n    # Calculate waste if item is placed in each possible bin\n    waste = bins_remain_cap - item\n\n    # Prioritize bins with the least waste. Add some constants to scale values\n    priorities[possible_bins] = 1.0 / (waste[possible_bins] + 0.001) # Avoid divide by zero. Smaller waste -> larger priority.\n\n    # Give a bonus for bins that are closer to half full AFTER packing the item. This encourages filling bins efficiently.\n    half_full = (bins_remain_cap[possible_bins] - item) - (0.5 * np.max(bins_remain_cap)) # Deviation from the middle\n    priorities[possible_bins] += np.exp(-0.5 * (half_full/np.max(bins_remain_cap))**2)\n\n    # Add a small penalty for almost full bins to encourage a balanced distribution. Prevents clustering near full capacity.\n    almost_full = bins_remain_cap > 0.9*np.max(bins_remain_cap)\n    priorities[almost_full] *= 0.9\n\n\n    return priorities\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Higher values indicate better fit.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    possible_bins = bins_remain_cap >= item\n\n    if not np.any(possible_bins):\n        return priorities  # No bin can fit the item, so no priority. All zero\n\n    # Calculate waste if item is placed in each possible bin\n    waste = bins_remain_cap - item\n\n    # Prioritize bins with the least waste. Add some constants to scale values\n    priorities[possible_bins] = 1.0 / (waste[possible_bins] + 0.001) # Avoid divide by zero. Smaller waste -> larger priority.\n\n    # Give a bonus for bins that are closer to half full AFTER packing the item. This encourages filling bins efficiently.\n    half_full = (bins_remain_cap[possible_bins] - item) - (0.5 * np.max(bins_remain_cap)) # Deviation from the middle\n    priorities[possible_bins] += np.exp(-0.5 * (half_full/np.max(bins_remain_cap))**2)\n\n    # Add a small penalty for almost full bins to encourage a balanced distribution. Prevents clustering near full capacity.\n    almost_full = bins_remain_cap > 0.9*np.max(bins_remain_cap)\n    priorities[almost_full] *= 0.9\n\n\n    return priorities\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Uses a heuristic inspired by black hole accretion disks: items\n    are more likely to be drawn to bins with remaining capacity close\n    to the item size, but a small probabilistic component prevents\n    getting stuck in local minima, simulating Hawking radiation.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Avoid division by zero and negative values in log\n    epsilon = 1e-9  # small constant\n\n    # Distance from remaining capacity to item size\n    distances = np.abs(bins_remain_cap - item)\n\n    # Inverse distance, scaled and shifted - \"accretion disk\"\n    base_priority = 1 / (distances + epsilon)\n\n    # Probabilistic component (\"Hawking radiation\") - uniform random\n    random_component = np.random.rand(len(bins_remain_cap)) * 0.01 # Small random component\n\n    # Combine the components\n    priorities = base_priority + random_component\n    \n    #Zero out priorities of bins that can't fit\n    priorities[bins_remain_cap < item] = 0\n\n    return priorities\n\n[Heuristics 4th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Uses a heuristic inspired by black hole accretion disks: items\n    are more likely to be drawn to bins with remaining capacity close\n    to the item size, but a small probabilistic component prevents\n    getting stuck in local minima, simulating Hawking radiation.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Avoid division by zero and negative values in log\n    epsilon = 1e-9  # small constant\n\n    # Distance from remaining capacity to item size\n    distances = np.abs(bins_remain_cap - item)\n\n    # Inverse distance, scaled and shifted - \"accretion disk\"\n    base_priority = 1 / (distances + epsilon)\n\n    # Probabilistic component (\"Hawking radiation\") - uniform random\n    random_component = np.random.rand(len(bins_remain_cap)) * 0.01 # Small random component\n\n    # Combine the components\n    priorities = base_priority + random_component\n    \n    #Zero out priorities of bins that can't fit\n    priorities[bins_remain_cap < item] = 0\n\n    return priorities\n\n[Heuristics 5th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Uses a heuristic inspired by black hole accretion disks: items\n    are more likely to be drawn to bins with remaining capacity close\n    to the item size, but a small probabilistic component prevents\n    getting stuck in local minima, simulating Hawking radiation.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Avoid division by zero and negative values in log\n    epsilon = 1e-9  # small constant\n\n    # Distance from remaining capacity to item size\n    distances = np.abs(bins_remain_cap - item)\n\n    # Inverse distance, scaled and shifted - \"accretion disk\"\n    base_priority = 1 / (distances + epsilon)\n\n    # Probabilistic component (\"Hawking radiation\") - uniform random\n    random_component = np.random.rand(len(bins_remain_cap)) * 0.01 # Small random component\n\n    # Combine the components\n    priorities = base_priority + random_component\n    \n    #Zero out priorities of bins that can't fit\n    priorities[bins_remain_cap < item] = 0\n\n    return priorities\n\n[Heuristics 6th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Uses a heuristic inspired by black hole accretion disks: items\n    are more likely to be drawn to bins with remaining capacity close\n    to the item size, but a small probabilistic component prevents\n    getting stuck in local minima, simulating Hawking radiation.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Avoid division by zero and negative values in log\n    epsilon = 1e-9  # small constant\n\n    # Distance from remaining capacity to item size\n    distances = np.abs(bins_remain_cap - item)\n\n    # Inverse distance, scaled and shifted - \"accretion disk\"\n    base_priority = 1 / (distances + epsilon)\n\n    # Probabilistic component (\"Hawking radiation\") - uniform random\n    random_component = np.random.rand(len(bins_remain_cap)) * 0.01 # Small random component\n\n    # Combine the components\n    priorities = base_priority + random_component\n    \n    #Zero out priorities of bins that can't fit\n    priorities[bins_remain_cap < item] = 0\n\n    return priorities\n\n[Heuristics 7th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Give high priority to bins where the item fits and the remaining space is minimized\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            priorities[i] = 1 / (cap - item + 0.00001)  # Add a small constant to avoid division by zero\n\n    # Optionally penalize bins that become too full\n    fullness_threshold = 0.95  # Adjust this threshold as needed\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item and (1 - (cap - item) / cap) > fullness_threshold:  #if after adding the item the bin utilization rate > threshold\n            priorities[i] *= 0.5  # Reduce priority for near-full bins\n\n    return priorities\n\n[Heuristics 8th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Give high priority to bins where the item fits and the remaining space is minimized\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            priorities[i] = 1 / (cap - item + 0.00001)  # Add a small constant to avoid division by zero\n\n    # Optionally penalize bins that become too full\n    fullness_threshold = 0.95  # Adjust this threshold as needed\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item and (1 - (cap - item) / cap) > fullness_threshold:  #if after adding the item the bin utilization rate > threshold\n            priorities[i] *= 0.5  # Reduce priority for near-full bins\n\n    return priorities\n\n[Heuristics 9th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Give high priority to bins where the item fits and the remaining space is minimized\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            priorities[i] = 1 / (cap - item + 0.00001)  # Add a small constant to avoid division by zero\n\n    # Optionally penalize bins that become too full\n    fullness_threshold = 0.95  # Adjust this threshold as needed\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item and (1 - (cap - item) / cap) > fullness_threshold:  #if after adding the item the bin utilization rate > threshold\n            priorities[i] *= 0.5  # Reduce priority for near-full bins\n\n    return priorities\n\n[Heuristics 10th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins that can accommodate the item with minimal wasted space.\n    It also discourages placing items in nearly full bins to avoid fragmentation.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Give a large negative priority if item doesn't fit\n    priorities[bins_remain_cap < item] = -np.inf\n\n    # Prioritize bins where the item fits. Higher priority for less wasted space, but also less\n    # likely to cause extreme fragmentation if the remaining capacity is very low.\n    fit_indices = bins_remain_cap >= item\n    if np.any(fit_indices):\n        waste = bins_remain_cap[fit_indices] - item\n        priorities[fit_indices] = -waste + (bins_remain_cap[fit_indices] / np.max(bins_remain_cap)) # Prioritize lower waste and high cap\n\n    # Add a small bias to use more empty bins than close to being full, unless nothing fits\n    if np.any(bins_remain_cap >= item):\n        priorities = priorities + (bins_remain_cap/ np.max(bins_remain_cap)) * 0.1\n\n\n    return priorities\n\n[Heuristics 11th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins that can accommodate the item with minimal wasted space.\n    It also discourages placing items in nearly full bins to avoid fragmentation.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Give a large negative priority if item doesn't fit\n    priorities[bins_remain_cap < item] = -np.inf\n\n    # Prioritize bins where the item fits. Higher priority for less wasted space, but also less\n    # likely to cause extreme fragmentation if the remaining capacity is very low.\n    fit_indices = bins_remain_cap >= item\n    if np.any(fit_indices):\n        waste = bins_remain_cap[fit_indices] - item\n        priorities[fit_indices] = -waste + (bins_remain_cap[fit_indices] / np.max(bins_remain_cap)) # Prioritize lower waste and high cap\n\n    # Add a small bias to use more empty bins than close to being full, unless nothing fits\n    if np.any(bins_remain_cap >= item):\n        priorities = priorities + (bins_remain_cap/ np.max(bins_remain_cap)) * 0.1\n\n\n    return priorities\n\n[Heuristics 12th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: A bin must have enough remaining capacity to hold the item.\n    feasible_bins = bins_remain_cap >= item\n\n    # If no bins are feasible, return a low-priority array (all zeros). This signals that a new bin must be opened.\n    if not np.any(feasible_bins):\n        return priorities\n\n    # 2. Fill Ratio: Higher fill ratio after adding the item = higher priority, but only for feasible bins.\n    fill_ratios = np.zeros_like(bins_remain_cap, dtype=float)\n    fill_ratios[feasible_bins] = item / bins_remain_cap[feasible_bins]\n\n    # 3. Balance: Penalize bins that are close to full. This encourages a more balanced distribution.\n    remaining_capacity_ratios = bins_remain_cap / bins_remain_cap.max() #normalized remaining capacity ratios\n    balance_penalty = np.where(feasible_bins, np.exp(-5 * remaining_capacity_ratios),0)\n\n    # 4. Reward fuller bins with higher priority to encourage filling existing ones before opening new ones.\n    current_fill_ratio = (bins_remain_cap.max() - bins_remain_cap)/bins_remain_cap.max() #current fill ratio\n\n    #5. Avoid bins that are almost exactly full to reduce fragmentation\n    exact_fit_reward = np.isclose(item, bins_remain_cap) * 1.5 #A small extra bonus for \"perfect\" fits\n\n    priorities = fill_ratios  + balance_penalty + current_fill_ratio + exact_fit_reward\n\n    return priorities\n\n[Heuristics 13th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # First, consider only bins that can actually hold the item\n    valid_bins = bins_remain_cap >= item\n    \n    if not np.any(valid_bins):\n        # If no bin can hold the item, prioritize bins with the most remaining capacity.  A small penalty is added to each bin with already used capacity\n        penalties = 0.1*(1 - bins_remain_cap/np.max(bins_remain_cap))\n        return bins_remain_cap - penalties\n        \n\n    # For valid bins, prioritize based on a combination of factors:\n    # 1. Remaining capacity: Bins with capacity closest to the item size are preferred (minimize waste).\n    # 2. Fill ratio:  Prefer bins with a higher fill ratio *after* placing the current item.\n\n    remaining_after_fit = bins_remain_cap[valid_bins] - item\n    \n    # Calculate absolute difference between remaining capacity and item size. Smaller is better.\n    capacity_diff = np.abs(remaining_after_fit)\n    \n    # Invert the difference (smaller difference -> larger value), and normalize.\n    capacity_priority = 1.0 / (capacity_diff + 1e-9)  # Add small epsilon to avoid division by zero\n\n    #calculate bin utilization after putting the current item in\n    utilization = (bins_remain_cap[valid_bins] - remaining_after_fit)/bins_remain_cap[valid_bins]\n\n\n    # Combine priorities (weighted sum). Experiment with weights to fine-tune.\n    combined_priority = 0.7 * capacity_priority + 0.3 * utilization\n    \n    priorities[valid_bins] = combined_priority\n\n    return priorities\n\n[Heuristics 14th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins that can accommodate the item with minimal wasted space\n    while also discouraging filling bins too much (to allow flexibility for future, larger items).\n    It uses a combination of remaining capacity and fill ratio.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    for i, capacity in enumerate(bins_remain_cap):\n        if capacity >= item:\n            # Calculate wasted space:\n            wasted_space = capacity - item\n\n            # Calculate fill ratio:\n            fill_ratio = item / capacity\n\n            # Prioritize bins that have minimal wasted space relative to item size,\n            # while also considering fill ratio to avoid overly full bins.\n\n            # Example weighting:\n            # Higher weight on wasted_space (negative) means lower wasted space is preferred.\n            # Lower weight on fill_ratio means less full bins are preferred, but not as strongly as minimizing wasted space.\n            priorities[i] = -wasted_space/item + 0.5*fill_ratio # Adjust weights as needed for optimal performance\n\n        else:\n            priorities[i] = -np.inf  # Impossible to fit: lowest priority\n\n    return priorities\n\n[Heuristics 15th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if item <= cap:\n            # Prioritize bins that can fit the item, and prefer bins with smaller remaining capacity after packing (more full bins).\n            remaining_after_pack = cap - item\n            if remaining_after_pack == 0:\n                priorities[i] = 1000  # High priority if bin is filled completely\n            else:\n                priorities[i] = 1 / remaining_after_pack  # Inverse of remaining capacity after packing\n        else:\n            priorities[i] = -1e9 #Very low priority if the bin can't fit the item\n\n    return priorities\n\n[Heuristics 16th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins that can accommodate the item with minimal remaining space,\n    but also discourages excessive fragmentation by penalizing bins where the remaining space\n    after packing would be too small.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Calculate remaining capacity after packing\n    remaining_after_packing = bins_remain_cap - item\n\n    # Give a high priority to bins that can fit the item\n    can_fit = remaining_after_packing >= 0\n    priorities[can_fit] = 1.0\n\n    # Further refine priority based on how well the item fits\n    fit_amount = bins_remain_cap[can_fit] - item\n    \n    # Give higher priority to bins where the remaining space after fitting is small,\n    # but not *too* small (to avoid excessive fragmentation).  Using a logistic function\n    # to achieve this.\n    \n    fragmentation_penalty = 1 / (1 + np.exp( -5 * (fit_amount - np.mean(fit_amount))))\n    priorities[can_fit] += (1 - fragmentation_penalty)  # Slightly higher weight on tightest fit\n    \n\n    # Optionally penalize bins that would leave very little space after packing,\n    # as this contributes to fragmentation and difficulties later on.  This is\n    # a simple, more direct fragmentation avoidance mechanism compared to the above.\n    too_small = remaining_after_packing < 0.1 # e.g., less than 10% of bin size. tunable.\n    priorities[too_small] = -1.0  # Negative priority to strongly discourage.\n\n    # Bins that can't fit get zero priority, which is already set by the initialization\n    # Don't let these go negative.\n    priorities[priorities < 0] = 0\n\n    return priorities\n\n[Heuristics 17th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    This version attempts to mimic quantum tunneling behavior: bins\n    with capacity close to item size have higher tunneling probability\n    and therefore higher priority. It also adds some \"potential well\"\n    shape through the remaining capacity itself.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    delta = np.abs(bins_remain_cap - item)\n    tunneling = np.exp(-delta**2 / (2 * (0.1 * item)**2))  # Gaussian centered at item size. Small sigma for 'tunneling'\n    potential_well = bins_remain_cap / np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else np.zeros_like(bins_remain_cap)  # try to fill bigger cap bins if no good 'tunnel' match exist\n\n    #Prioritize bins that fit (delta <=0), then \"tunneling\", then using all avaiable sapce\n    priorities = np.where(bins_remain_cap >= item, tunneling + potential_well, -np.inf)\n\n    # To avoid all bins having -inf when no bin fits the item, try to pick the best option among those that cannot fit.\n    # It's crucial to prevent returning array of -inf and make a choice!\n    if np.all(priorities == -np.inf):\n        priorities = -delta  # minimize the difference; closer is better when no bin can contain\n        priorities = priorities - np.max(priorities)\n    return priorities\n\n[Heuristics 18th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Inspired by gravitational potential energy and momentum.  Larger bins\n    (analogous to larger mass attracting the item) and bins where the\n    item would nearly fill them (like maximizing the change in momentum,\n    i.e., stopping distance) are preferred.  Bins that are too small\n    get a negative priority.  A small capacity is added to the denominator to prevent division by zero.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    epsilon = 1e-9  # Avoid division by zero and give a minimal preference\n\n    # Gravitational potential: higher remaining capacity is preferred\n    gravitational_priority = bins_remain_cap\n\n    # Momentum priority: prefer to almost fill the bin\n    momentum_priority = (bins_remain_cap - item) / (bins_remain_cap + epsilon)  # Smaller is better (nearly filled)\n    momentum_priority = np.clip(momentum_priority, a_min=0, a_max=None) # Only consider valid bins\n    momentum_priority = 1 - momentum_priority  # Higher when closer to full after packing item\n    \n    # Penalize bins that are too small: Newtonian constraint\n    too_small = bins_remain_cap < item\n    momentum_priority[too_small] = -1.0  # Very low priority for bins that can't fit the item\n\n    priorities = gravitational_priority * momentum_priority\n    return priorities\n\n[Heuristics 19th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Inspired by gravitational potential energy and momentum.  Larger bins\n    (analogous to larger mass attracting the item) and bins where the\n    item would nearly fill them (like maximizing the change in momentum,\n    i.e., stopping distance) are preferred.  Bins that are too small\n    get a negative priority.  A small capacity is added to the denominator to prevent division by zero.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    epsilon = 1e-9  # Avoid division by zero and give a minimal preference\n\n    # Gravitational potential: higher remaining capacity is preferred\n    gravitational_priority = bins_remain_cap\n\n    # Momentum priority: prefer to almost fill the bin\n    momentum_priority = (bins_remain_cap - item) / (bins_remain_cap + epsilon)  # Smaller is better (nearly filled)\n    momentum_priority = np.clip(momentum_priority, a_min=0, a_max=None) # Only consider valid bins\n    momentum_priority = 1 - momentum_priority  # Higher when closer to full after packing item\n    \n    # Penalize bins that are too small: Newtonian constraint\n    too_small = bins_remain_cap < item\n    momentum_priority[too_small] = -1.0  # Very low priority for bins that can't fit the item\n\n    priorities = gravitational_priority * momentum_priority\n    return priorities\n\n[Heuristics 20th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Inspired by gravitational potential energy and momentum.  Larger bins\n    (analogous to larger mass attracting the item) and bins where the\n    item would nearly fill them (like maximizing the change in momentum,\n    i.e., stopping distance) are preferred.  Bins that are too small\n    get a negative priority.  A small capacity is added to the denominator to prevent division by zero.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    epsilon = 1e-9  # Avoid division by zero and give a minimal preference\n\n    # Gravitational potential: higher remaining capacity is preferred\n    gravitational_priority = bins_remain_cap\n\n    # Momentum priority: prefer to almost fill the bin\n    momentum_priority = (bins_remain_cap - item) / (bins_remain_cap + epsilon)  # Smaller is better (nearly filled)\n    momentum_priority = np.clip(momentum_priority, a_min=0, a_max=None) # Only consider valid bins\n    momentum_priority = 1 - momentum_priority  # Higher when closer to full after packing item\n    \n    # Penalize bins that are too small: Newtonian constraint\n    too_small = bins_remain_cap < item\n    momentum_priority[too_small] = -1.0  # Very low priority for bins that can't fit the item\n\n    priorities = gravitational_priority * momentum_priority\n    return priorities\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}