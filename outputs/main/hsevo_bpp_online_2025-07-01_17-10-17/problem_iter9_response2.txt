```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Assign priorities to bins based on a combination of best fit,
    fill level target, and a penalty for excessive fragmentation.
    """
    epsilon = 1e-9
    
    # 1. Best Fit: Prioritize bins where the remaining capacity after placing the item is small.
    best_fit_priority = 1 / (np.abs(bins_remain_cap - item) + epsilon)
    
    # 2. Target Fill Level: Encourage filling bins to a target level (e.g., 75% full).
    target_fill_level = 0.75
    target_capacity = target_fill_level * np.max(bins_remain_cap)  # Assuming bins are of same size.
    fill_level_diff = np.abs((bins_remain_cap - item) - target_capacity)
    fill_level_priority = 1 / (fill_level_diff + epsilon)
    
    # 3. Fragmentation Penalty: Discourage placing items in bins that will result in small remaining spaces,
    #    as these small spaces are hard to fill later.
    remaining_after_fit = bins_remain_cap - item
    fragmentation_threshold = 0.1 * np.max(bins_remain_cap) # Adjust the threshold as needed. Max cap of bins.
    fragmentation_penalty = np.where(remaining_after_fit > 0, np.where(remaining_after_fit < fragmentation_threshold, -10, 0), 0) #High negative value if fragmented.

    # 4. Combine priorities with weights.  Experiment with these weights.
    priorities = (0.6 * best_fit_priority +
                  0.3 * fill_level_priority +
                  0.1 * fragmentation_penalty)

    # Zero out invalid bins.
    priorities[bins_remain_cap < item] = -np.inf

    return priorities
```
