```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristic function for the Capacitated Vehicle Routing Problem (CVRP) using stochastic solution sampling.

    Emphasizes depot proximity, normalized demand, angle to depot and adaptive sparsification based on vehicle capacity and distance.
    Refined parameter tuning and normalization are employed for improved CVRP heuristics.

    Args:
        distance_matrix (np.ndarray): Distance matrix (shape: n by n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n by 2).
        demands (np.ndarray): Customer demands (shape: n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution
                    (shape: same as distance_matrix).
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)

    # Parameters (tunable)
    alpha = 1.2  # Weight for distance influence
    beta = 0.9  # Weight for demand attraction
    gamma = 0.7  # Weight for depot proximity
    delta = 0.6  # Weight for angle towards depot

    # Calculate depot proximity (normalized distance to depot)
    depot_distances = distance_matrix[0, :] / np.max(distance_matrix[0, :])
    depot_proximity = 1 - depot_distances

    # Normalized demand
    normalized_demands = demands / capacity  # Normalize with respect to capacity.

    # Calculate angle to depot
    angle_to_depot = np.zeros((n, n))
    for i in range(1, n):
        for j in range(1, n):
            if i != j:
                vector_i = coordinates[i] - coordinates[0]
                vector_j = coordinates[j] - coordinates[0]
                dot_product = np.dot(vector_i, vector_j)
                magnitudes = np.linalg.norm(vector_i) * np.linalg.norm(vector_j)
                angle = np.arccos(np.clip(dot_product / (magnitudes + 1e-6), -1.0, 1.0))
                angle_to_depot[i, j] = 1 - (angle / np.pi)

    for i in range(n):
        for j in range(n):
            if i == j:
                heuristics[i, j] = 0  # No self-loops
            else:
                # Encourage trips to depot more strongly
                if i == 0:
                    depot_prox_factor_i = 1.0
                else:
                    depot_prox_factor_i = depot_proximity[i]

                if j == 0:
                    depot_prox_factor_j = 1.0
                else:
                    depot_prox_factor_j = depot_proximity[j]

                heuristics[i, j] = (
                    (1 / distance_matrix[i, j])**alpha *  # Distance factor
                    (normalized_demands[i] + normalized_demands[j])**beta *  # Demand factor, favoring larger demands
                    (depot_prox_factor_i * depot_prox_factor_j)**gamma *  # Depot Proximity - more important if a node is far from the depot
                    (angle_to_depot[i, j])**delta
                )

    # Dynamic Sparsification based on Distance (more aggressive)
    distance_threshold = np.mean(distance_matrix) + 0.75 * np.std(distance_matrix)
    heuristics[distance_matrix > distance_threshold] = 0

    # Dynamic Sparsification based on Demand relative to Capacity
    demand_threshold = 0.9  # Cap on demand (as proportion of capacity). Adjusted aggressiveness
    for i in range(1, n):  # Exclude depot connections
        for j in range(1, n):
            if i != j and normalized_demands[i] + normalized_demands[j] > demand_threshold:
                heuristics[i, j] = 0
                heuristics[j, i] = 0  # Ensure symmetry

    # Adaptive Sparsification: keep only top k edges for each node. Increased aggressiveness.
    k = max(1, int(np.log(n)))  # Adaptive k depending on problem size, logarithmic scaling

    for i in range(n):
        # Compute a combined score from the matrix *excluding* the link to itself
        row = heuristics[i, :]
        idx = np.argpartition(row, -k)[-k:] #Indices of the k largest elements
        mask = np.zeros(row.shape, dtype=bool)
        mask[idx] = True
        heuristics[i, :] = 0 #Reset
        heuristics[i, mask] = 1 #Keep the best ones
        heuristics[i,i] = 0 #Remove self loops.

    return heuristics
```
