```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics for CVRP using a combination of factors and sparsification.

    Args:
        distance_matrix: Distance matrix between nodes.
        coordinates: Euclidean coordinates of nodes.
        demands: Demand of each node.
        capacity: Vehicle capacity.

    Returns:
        A matrix of the same shape as distance_matrix, indicating the
        promise of each edge.
    """
    n = distance_matrix.shape[0]
    promise = np.zeros((n, n))

    # Heuristic factors:
    # 1. Distance: Shorter distances are preferred.
    distance_factor = 1 / (distance_matrix + 1e-6)  # Avoid division by zero

    # 2. Demand proximity: Nodes with related demands might be grouped.
    #    (This part could be refined based on domain knowledge)
    demand_similarity = np.zeros((n, n))
    for i in range(n):
        for j in range(n):
            demand_similarity[i, j] = 1 - abs(demands[i] - demands[j]) / capacity

    # 3. Angle to depot: Avoid sharp turns relative to the depot.  Penalize edges that lead away from returning to depot
    depot_angle_factor = np.zeros((n, n))
    for i in range(1, n):  # skip depot as origin
        for j in range(1, n):
            if i == j:
                depot_angle_factor[i,j] = 0
                continue

            vec_i = coordinates[i] - coordinates[0]
            vec_j = coordinates[j] - coordinates[0]

            norm_i = np.linalg.norm(vec_i)
            norm_j = np.linalg.norm(vec_j)

            if norm_i > 0 and norm_j > 0:
                cos_angle = np.dot(vec_i, vec_j) / (norm_i * norm_j)
                #Higher the cos the more similar the directions, penalizing angles that deviate
                depot_angle_factor[i, j] = (cos_angle + 1) / 2 # normalize to [0,1]
            else:
                depot_angle_factor[i, j] = 0

    # Combine factors (weighted): Experiment with different weights
    promise = (
        0.5 * distance_factor +
        0.2 * demand_similarity +
        0.3 * depot_angle_factor
    )

    # Sparsification: Remove unpromising edges
    threshold = np.percentile(promise[promise > 0], 20)  # Keep top 80% non-zero
    promise[promise < threshold] = 0


    #Ensure that edges back to the depot are more favored. This helps with forming routes.
    for i in range(1,n):
        promise[i,0] = promise[i,0] * 1.5
        promise[0,i] = promise[0,i] * 1.5 #Favor edges back to depot


    return promise
```
