```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    A heuristic function for solving the Capacitated Vehicle Routing Problem (CVRP)
    via stochastic solution sampling.

    This version combines distance, demand, and geometric factors to create a
    prior indicator matrix.  It also sparsifies the matrix by zeroing out
    unpromising edges.

    Args:
        distance_matrix: A numpy array representing the distance between nodes.
                         Shape: (n, n)
        coordinates: A numpy array representing the (x, y) coordinates of the nodes.
                     Shape: (n, 2)
        demands: A numpy array representing the demand of each node. Shape: (n,)
        capacity: The capacity of each vehicle.

    Returns:
        A numpy array of the same shape as distance_matrix, representing the
        prior indicators of how promising it is to include each edge in a solution.
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Parameters to control the influence of each factor. Tune these.
    distance_weight = 1.0
    demand_weight = 0.5
    angle_weight = 0.2
    depot_proximity_weight = 0.3

    for i in range(n):
        for j in range(n):
            if i == j:
                heuristic_matrix[i, j] = 0  # No self-loops
                continue

            # Distance factor (favor shorter distances)
            distance_factor = 1 / (distance_matrix[i, j] + 1e-6) # Avoid division by zero

            # Demand factor (penalize edges that would quickly fill a vehicle)
            demand_factor = 1 / (demands[i] + demands[j] + 1e-6)

            # Angle factor (favor edges that don't cause sharp turns away from the depot. Penalize sharp turns)
            #  Dot product to determine how much a step i -> j points in the right direction
            # First calculate direction to depot:
            depot_direction_i = coordinates[0] - coordinates[i]
            depot_direction_j = coordinates[0] - coordinates[j]
            # Normalize:
            depot_direction_i = depot_direction_i / (np.linalg.norm(depot_direction_i) + 1e-6)
            depot_direction_j = depot_direction_j / (np.linalg.norm(depot_direction_j) + 1e-6)
            # Step direction:
            step_direction = coordinates[j] - coordinates[i]
            step_direction = step_direction / (np.linalg.norm(step_direction) + 1e-6)
            angle_factor_i = np.dot(step_direction, depot_direction_i) # How much node i heads towards depot.
            angle_factor_j = np.dot(-step_direction, depot_direction_j) # And for node j. Note the inverse.
            angle_factor = (angle_factor_i + angle_factor_j) / 2 # Take the average
            angle_factor = (angle_factor + 1) / 2 # Scales to between 0 and 1. Better since it handles the negatives correctly.
            angle_factor = np.clip(angle_factor, 0, 1) # Ensure the clip for robustness

            # Proximity to Depot factor (favor connections with nodes farther from the depot), only when it's not the starting depot.
            depot_proximity_i = distance_matrix[0, i] / (np.max(distance_matrix[0, :]) + 1e-6) # Normalized distance to depot
            depot_proximity_j = distance_matrix[0, j] / (np.max(distance_matrix[0, :]) + 1e-6)
            depot_proximity_factor = np.sqrt(depot_proximity_i * depot_proximity_j) # Geometric mean.

            heuristic_matrix[i, j] = (
                distance_weight * distance_factor +
                demand_weight * demand_factor +
                angle_weight * angle_factor +
                depot_proximity_weight * depot_proximity_factor
            )

    # Sparsify the matrix:  Zero out edges that are deemed very unpromising.

    # Option 1: Threshold based on heuristic value.
    threshold = np.mean(heuristic_matrix[heuristic_matrix > 0]) * 0.2  # Example threshold
    heuristic_matrix[heuristic_matrix < threshold] = 0

    # Option 2: Keep only the k-nearest neighbors for each node
    # for i in range(n):
    #     row = heuristic_matrix[i, :].copy()
    #     indices = np.argsort(row)[::-1] # Sort in descending order
    #     k = 5 # Keep top 5 neighbors
    #     heuristic_matrix[i, indices[k:]] = 0 # Clear the others
    #     heuristic_matrix[i, i] = 0 # Clears the self-loops if not manually handled before

    return heuristic_matrix
```
