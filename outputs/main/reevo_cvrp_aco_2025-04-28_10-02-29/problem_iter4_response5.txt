```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristic function for the Capacitated Vehicle Routing Problem (CVRP) using stochastic solution sampling.

    This version incorporates feature normalization, prioritization of depot connections,
    dynamic threshold adaptation, and angle considerations. It aims to balance exploration
    and exploitation for improved performance.

    Args:
        distance_matrix (np.ndarray): Distance matrix (shape: n by n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n by 2).
        demands (np.ndarray): Customer demands (shape: n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution
                    (shape: same as distance_matrix).
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)

    # Parameters (tunable)
    alpha = 1.0  # Weight for distance
    beta = 1.0   # Weight for demand
    gamma = 0.5  # Weight for depot proximity
    theta = 0.2  # Weight for angle

    # Feature Normalization
    max_distance = np.max(distance_matrix)
    normalized_distance_matrix = distance_matrix / max_distance if max_distance > 0 else np.zeros_like(distance_matrix)

    max_demand = np.max(demands[1:])  # Exclude depot demand
    normalized_demands = demands / max_demand if max_demand > 0 else np.zeros(n)

    max_depot_distance = np.max(distance_matrix[0, 1:])
    depot_distances = distance_matrix[0, :] / max_depot_distance if max_depot_distance > 0 else np.zeros(n)
    depot_proximity = 1 - depot_distances

    # Angle Calculation (penalize sharp turns)
    angle_matrix = np.zeros_like(distance_matrix)
    for i in range(1, n):
        for j in range(1, n):
            if i != j:
                vec_ji = coordinates[i] - coordinates[j]
                vec_0i = coordinates[i] - coordinates[0]
                norm_ji = np.linalg.norm(vec_ji)
                norm_0i = np.linalg.norm(vec_0i)

                if norm_ji > 0 and norm_0i > 0:
                    cos_angle = np.dot(vec_ji, vec_0i) / (norm_ji * norm_0i)
                    angle_matrix[i, j] = 0.5 + 0.5 * cos_angle  # Scale to [0, 1]
                else:
                    angle_matrix[i,j] = 1.0  # No angle penalty if nodes are at the same spot

    # Heuristic Calculation
    for i in range(n):
        for j in range(n):
            if i == j:
                heuristics[i, j] = 0  # No self-loops
            else:
                depot_prox_factor_i = depot_proximity[i] if i != 0 else 1.0
                depot_prox_factor_j = depot_proximity[j] if j != 0 else 1.0

                demand_factor = (normalized_demands[i] + normalized_demands[j])**beta
                distance_factor = (1 / normalized_distance_matrix[i, j])**alpha
                depot_factor = (depot_prox_factor_i * depot_prox_factor_j)**gamma
                angle_factor = angle_matrix[i,j]**theta

                heuristics[i, j] = distance_factor * demand_factor * depot_factor * angle_factor

    # Dynamic Threshold Adaptation (Sparsification)
    distance_threshold = np.mean(normalized_distance_matrix) + np.std(normalized_distance_matrix)
    demand_threshold = 0.75  # Cap on demand as proportion of total capacity

    for i in range(n):
        for j in range(n):
            if normalized_distance_matrix[i, j] > distance_threshold:
                heuristics[i, j] = 0
            elif demands[i] + demands[j] > demand_threshold * capacity and i != 0 and j != 0:
                heuristics[i, j] = 0

    # Normalize heuristics
    max_heuristic = np.max(heuristics)
    if max_heuristic > 0:
        heuristics = heuristics / max_heuristic

    return heuristics
```
