```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    A heuristics function for solving Capacitated Vehicle Routing Problem (CVRP)
    via stochastic solution sampling. It combines several factors to determine
    how promising it is to select an edge, and sparsifies the matrix.

    Args:
        distance_matrix (np.ndarray): Distance matrix (shape: n by n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n by 2).
        demands (np.ndarray): Customer demands (shape: n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution
                   (shape: same as distance_matrix).
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # 1. Distance factor: Shorter distances are more promising.
    distance_factor = 1 / (distance_matrix + 1e-6)  # Add a small constant to avoid division by zero

    # 2. Demand factor: Penalize edges that would likely lead to capacity violations.
    demand_factor = np.ones((n, n))
    for i in range(n):
        for j in range(n):
            if i != j and i != 0 and j != 0:
                # Rough estimate of whether adding this edge will violate capacity.
                # Assuming that the nodes i and j will belong to the same route.
                if demands[i] + demands[j] > capacity / 3:  # Dividing by 3 allows room for other potential nodes
                    demand_factor[i, j] = 0.1  # Significantly penalize
                elif demands[i] + demands[j] > capacity / 2:
                    demand_factor[i, j] = 0.5
            elif i == 0 or j == 0:
                # Connections with the depot are always important
                demand_factor[i, j] = 1.0

    # 3. Depot proximity factor: Favor connections closer to the depot (node 0).
    depot_proximity_factor = np.zeros((n, n))
    for i in range(n):
      for j in range(n):
        if i!=j:
          depot_proximity_factor[i,j] = 1/((distance_matrix[0,i] + distance_matrix[0,j]) + 1e-6)


    # 4. Combine the factors.  Experiment with weights.
    heuristic_matrix = (
        0.6 * distance_factor
        + 0.2 * demand_factor
        + 0.2 * depot_proximity_factor
    )


    # 5. Sparsify the matrix: Set unpromising elements to zero.
    #    Keep only the k-nearest neighbors for each node.
    k = int(np.sqrt(n))  # Adjust k based on problem size.

    for i in range(n):
        # Get indices of the k largest values in the row.
        indices = np.argpartition(heuristic_matrix[i, :], -k)[-k:]

        # Zero out all other elements in the row.
        row = np.zeros(n)
        row[indices] = heuristic_matrix[i, indices]
        heuristic_matrix[i, :] = row


    # Ensure depot connections are always considered, even if sparsified
    for i in range(n):
        heuristic_matrix[0, i] = max(heuristic_matrix[0,i], 0.1 * np.max(heuristic_matrix))  # small non-zero value
        heuristic_matrix[i, 0] = max(heuristic_matrix[i, 0], 0.1 * np.max(heuristic_matrix))


    return heuristic_matrix
```
