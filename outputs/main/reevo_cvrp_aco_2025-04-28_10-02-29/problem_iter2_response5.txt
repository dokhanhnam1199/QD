```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristic function for the Capacitated Vehicle Routing Problem (CVRP) using stochastic solution sampling.

    Combines several factors to determine how promising it is to select an edge,
    and sparsifies the matrix by setting unpromising elements to zero. Normalizes features,
    adapts thresholds, and prioritizes trips to/from the depot for improved performance.

    Args:
        distance_matrix (np.ndarray): Distance matrix (shape: n by n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n by 2).
        demands (np.ndarray): Customer demands (shape: n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution
                    (shape: same as distance_matrix).
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)

    # Parameters (can be tuned)
    alpha = 1.0  # Weight for distance
    beta = 1.0   # Weight for demand attraction
    gamma = 0.5  # Weight for depot proximity

    # Calculate depot proximity (normalized distance to depot)
    max_depot_distance = np.max(distance_matrix[0, 1:])
    depot_distances = distance_matrix[0, :] / max_depot_distance if max_depot_distance > 0 else np.zeros(n)
    depot_proximity = 1 - depot_distances

    # Normalized demand
    max_demand = np.max(demands[1:])
    normalized_demands = demands / max_demand if max_demand > 0 else np.zeros(n)


    # Normalize Distance Matrix
    max_distance = np.max(distance_matrix)
    normalized_distance_matrix = distance_matrix / max_distance if max_distance > 0 else np.zeros_like(distance_matrix)

    for i in range(n):
        for j in range(n):
            if i == j:
                heuristics[i, j] = 0  # No self-loops
            else:
                # Encourage trips to depot more strongly
                depot_prox_factor_i = depot_proximity[i] if i != 0 else 1.0
                depot_prox_factor_j = depot_proximity[j] if j != 0 else 1.0

                heuristics[i, j] = (
                    (1 / normalized_distance_matrix[i, j])**alpha *  # Distance factor
                    (normalized_demands[i] + normalized_demands[j])**beta * # Demand factor, favoring larger demands
                    (depot_prox_factor_i * depot_prox_factor_j)**gamma  #Depot Proximity - more important if a node is far from the depot
                )

    # Sparsify the matrix: remove edges that are too long or connect nodes with high demand that would likely overload a vehicle early on
    distance_threshold = np.mean(normalized_distance_matrix) + np.std(normalized_distance_matrix)  # Dynamic threshold
    demand_threshold = 0.75 # Cap on demand (as proportion of total capacity)

    for i in range(n):
        for j in range(n):
            if normalized_distance_matrix[i, j] > distance_threshold:
                heuristics[i, j] = 0
            # Disincentivize immediate connections that violate capacity too easily, excluding depot connections
            elif demands[i] + demands[j] > demand_threshold * capacity and i != 0 and j !=0:
               heuristics[i,j] = 0

    return heuristics
```
