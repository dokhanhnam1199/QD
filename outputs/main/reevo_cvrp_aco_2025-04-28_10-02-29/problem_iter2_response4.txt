```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:

    """
    Heuristics function for Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.

    This version combines distance, demand, and angle considerations to create a more informed prior
    for edge selection. It also sparsifies the matrix using an adaptive threshold.  It refines the angle calculation.

    Args:
        distance_matrix (np.ndarray): Distance matrix (shape: n by n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n by 2).
        demands (np.ndarray): Vector of customer demands (shape: n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n by n).
    """

    n = distance_matrix.shape[0]
    heuristics = np.zeros((n, n))

    # Parameters to control the influence of each factor
    distance_factor = 1.0
    demand_factor = 1.0
    angle_factor = 0.5

    for i in range(n):
        for j in range(n):
            if i != j:
                # Distance consideration: closer nodes are more promising
                distance_penalty = distance_factor / distance_matrix[i, j]

                # Demand consideration: avoid connecting nodes with high combined demand
                demand_penalty = 1.0 - demand_factor * (demands[i] + demands[j]) / (2 * capacity)  # Scale to [0, 1]
                demand_penalty = np.clip(demand_penalty, 0.0, 1.0) #Ensure it is within range [0,1]


                # Angle consideration: penalize sharp turns (encourages smoother routes)
                angle_penalty = 1.0
                if i != 0 and j != 0: # Depot is not counted for angle penalty

                    vec_ji = coordinates[i] - coordinates[j]
                    vec_0i = coordinates[i] - coordinates[0] # Angle between origin (depot) and node i
                    norm_ji = np.linalg.norm(vec_ji)
                    norm_0i = np.linalg.norm(vec_0i)

                    if norm_ji > 0 and norm_0i > 0:
                      cos_angle = np.dot(vec_ji, vec_0i) / (norm_ji * norm_0i) # Cosine angle
                      angle_penalty = 0.5 + 0.5* cos_angle # Scale the angle, range from [0, 1]

                heuristics[i, j] = distance_penalty * demand_penalty * (angle_penalty ** angle_factor)

    # Sparsify the matrix: remove unpromising edges
    threshold = np.mean(heuristics[heuristics > 0]) * 0.2  # Adaptive threshold based on mean
    heuristics[heuristics < threshold] = 0

    # Normalize the heuristic matrix
    max_heuristic = np.max(heuristics)
    if max_heuristic > 0:
        heuristics = heuristics / max_heuristic

    return heuristics
```
