```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristic function for the Capacitated Vehicle Routing Problem (CVRP) using stochastic solution sampling.

    Emphasizes adaptive sparsification, depot influence, and tuned, normalized factors.
    This version prioritizes aggressive sparsification and depot connections.

    Args:
        distance_matrix (np.ndarray): Distance matrix (shape: n by n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n by 2).
        demands (np.ndarray): Customer demands (shape: n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution
                    (shape: same as distance_matrix).
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)

    # Parameters (tunable - adjust based on problem instance)
    alpha = 1.5  # Weight for distance influence (higher = more importance)
    beta = 0.8  # Weight for demand attraction
    gamma = 1.0 # Weight for depot proximity (higher = more importance)
    delta = 0.5  # Weight for angle towards depot

    # Normalize demands with respect to capacity.
    normalized_demands = demands / capacity

    # Depot Proximity:  Distance to depot, normalized
    depot_distances = distance_matrix[0, :] / np.max(distance_matrix[0, :])
    depot_proximity = 1 - depot_distances

    # Angle to depot calculation
    angle_to_depot = np.zeros((n, n))
    for i in range(1, n):
        for j in range(1, n):
            if i != j:
                vector_i = coordinates[i] - coordinates[0]
                vector_j = coordinates[j] - coordinates[0]
                dot_product = np.dot(vector_i, vector_j)
                magnitudes = np.linalg.norm(vector_i) * np.linalg.norm(vector_j)
                angle = np.arccos(np.clip(dot_product / (magnitudes + 1e-6), -1.0, 1.0))
                angle_to_depot[i, j] = 1 - (angle / np.pi)

    # Heuristic Calculation
    for i in range(n):
        for j in range(n):
            if i == j:
                heuristics[i, j] = 0  # No self-loops
            else:
                # Stronger emphasis on depot connections
                if i == 0:
                    depot_prox_factor_i = 1.0
                else:
                    depot_prox_factor_i = depot_proximity[i]

                if j == 0:
                    depot_prox_factor_j = 1.0
                else:
                    depot_prox_factor_j = depot_proximity[j]

                heuristics[i, j] = (
                    (1 / distance_matrix[i, j])**alpha *  # Distance factor
                    (normalized_demands[i] + normalized_demands[j])**beta *  # Demand factor, favoring larger demands
                    (depot_prox_factor_i * depot_prox_factor_j)**gamma *  # Depot Proximity - more important if a node is far from the depot
                    (angle_to_depot[i, j])**delta
                )

    # Aggressive Sparsification:

    # 1. Distance-based sparsification (more aggressive threshold)
    distance_threshold = np.mean(distance_matrix) + 0.5 * np.std(distance_matrix) # Reduce standard deviation multiplier
    heuristics[distance_matrix > distance_threshold] = 0

    # 2. Demand-based sparsification
    demand_threshold = 0.8 # Adjusted
    for i in range(1, n):  # Exclude depot connections for this rule.
        for j in range(1, n):
            if i != j and normalized_demands[i] + normalized_demands[j] > demand_threshold:
                heuristics[i, j] = 0
                heuristics[j, i] = 0  # Symmetry

    # 3. Adaptive sparsification:  Keep only top k edges per node. More aggressive
    k = max(1, int(np.log(n))) # Reduced k to force more sparsity

    for i in range(n):
        row = heuristics[i, :]
        indices = np.argpartition(row, -k)[-k:]  # Indices of the k largest elements
        mask = np.zeros(row.shape, dtype=bool)
        mask[indices] = True
        heuristics[i, :] = 0 # Reset.
        heuristics[i, mask] = 1 # Keep only the best
        heuristics[i, i] = 0 # No self loops
    return heuristics
```
