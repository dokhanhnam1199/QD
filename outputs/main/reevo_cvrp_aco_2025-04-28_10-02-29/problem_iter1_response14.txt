```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristic function for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.

    This function combines several factors to determine how promising it is to select an edge,
    including distance, demand, and angular considerations. It also sparsifies the matrix by setting
    unpromising elements to zero.

    Args:
        distance_matrix (np.ndarray): Distance matrix (shape: n by n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n by 2).
        demands (np.ndarray): Vector of customer demands (shape: n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n by n).
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix)

    # Parameters (can be tuned)
    distance_weight = 0.5
    demand_weight = 0.3
    angle_weight = 0.2
    sparsification_threshold = 2.0 # tune this

    # Calculate the average demand (excluding the depot)
    avg_demand = np.mean(demands[1:])

    for i in range(n):
        for j in range(n):
            if i == j:
                heuristic_matrix[i, j] = 0  # No self-loops
                continue

            # Distance factor (normalized)
            distance_factor = distance_matrix[i, j] / np.max(distance_matrix)  if np.max(distance_matrix) > 0 else 0

            # Demand factor: Favor edges connecting nodes with small demands to better fit vehicles.  Also prefer connecting depot to nodes that have high demands
            if i == 0:  # Depot connection
              demand_factor = 1 - (demands[j] / capacity) # Higher demand connection is better from depot.  Scale it down from 0-1
            else:
              demand_factor = demands[i] / (avg_demand * n) # the larger it is, the least promising it is. scale from 0-1 based on average demand of node multiplied by number of nodes

            # Angle factor:  Penalize sharp turns to favor smoother routes.
            # Calculate the angle between the lines (i -> j) and (j -> 0). Closer to 180 is better
            if i != 0 and j != 0:
              vector_ij = coordinates[j] - coordinates[i]
              vector_j0 = coordinates[0] - coordinates[j]

              # Calculate cosine of the angle
              norm_ij = np.linalg.norm(vector_ij)
              norm_j0 = np.linalg.norm(vector_j0)

              if norm_ij > 0 and norm_j0 > 0:
                  cos_angle = np.dot(vector_ij, vector_j0) / (norm_ij * norm_j0)
                  # Convert cosine to angle in degrees.  Map 180 to 1 and 0 to 0.
                  angle = np.degrees(np.arccos(np.clip(cos_angle, -1.0, 1.0)))
                  angle_factor = 1 - (np.abs(angle - 180) / 180)
              else:
                  angle_factor = 0  # Handle cases where one or both vectors are zero
            else:
                angle_factor = 0.5 # Neutral angle

            # Combine the factors
            heuristic_value = (
                (1 - distance_factor) * distance_weight +  # Lower distance is better
                (1 - demand_factor) * demand_weight +  # Lower demand is better, depot is exception
                angle_factor * angle_weight # flatter turn better
            )

            heuristic_matrix[i, j] = heuristic_value

    # Sparsify the matrix: set low-promise edges to zero
    mean_heuristic = np.mean(heuristic_matrix[heuristic_matrix > 0])
    heuristic_matrix[heuristic_matrix < mean_heuristic / sparsification_threshold] = 0

    return heuristic_matrix
```
