```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristic function for Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.
    Incorporates geometric mean demand, inverse angle, distance penalization, enhanced sparsification,
    capacity awareness, and route diversity encouragement, with focus on robust implementation.

    Args:
        distance_matrix (np.ndarray): Distance matrix between nodes (n x n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (n x 2).
        demands (np.ndarray): Vector of customer demands (n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (n x n).
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros((n, n))

    # Calculate savings matrix (Clarke-Wright Savings)
    savings_matrix = np.zeros((n, n))
    for i in range(1, n):
        for j in range(i + 1, n):
            savings_matrix[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]
            savings_matrix[j, i] = savings_matrix[i, j]

    # Node proximity to depot
    depot_proximity = np.zeros(n)
    for i in range(1, n):
        depot_proximity[i] = 1 / (distance_matrix[0, i] + 1e-6)

    # Demand factor (geometric mean and capacity awareness)
    demand_factor = np.zeros((n, n))
    for i in range(1, n):
        for j in range(1, n):
            if i != j:
                combined_demand = demands[i] + demands[j]
                if combined_demand > capacity:
                    demand_factor[i, j] = 0.0  # Heavily penalize if exceeding capacity
                else:
                    demand_factor[i, j] = 1 / (np.sqrt(demands[i] * demands[j]) + 1e-6)
                    demand_factor[i, j] *= (1 - (combined_demand / capacity))**0.75  # Scale by how much capacity is left, using a power

    # Angle Factor (angle between nodes i and j w.r.t the depot)
    angle_factor = np.zeros((n, n))
    for i in range(1, n):
        for j in range(i + 1, n):
            vector_i = coordinates[i] - coordinates[0]
            vector_j = coordinates[j] - coordinates[0]
            norm_i = np.linalg.norm(vector_i)
            norm_j = np.linalg.norm(vector_j)
            if norm_i > 0 and norm_j > 0:
                cos_angle = np.dot(vector_i, vector_j) / (norm_i * norm_j)
                angle = np.arccos(np.clip(cos_angle, -1.0, 1.0))  # Clip to avoid domain errors
                angle_factor[i, j] = 1 / (angle + 0.05)  # Inverse angle
                angle_factor[j, i] = angle_factor[i, j]

    # Normalize factors
    savings_matrix = (savings_matrix - np.min(savings_matrix)) / (np.max(savings_matrix) - np.min(savings_matrix) + 1e-6)
    depot_proximity = (depot_proximity - np.min(depot_proximity)) / (np.max(depot_proximity) - np.min(depot_proximity) + 1e-6)
    demand_factor = (demand_factor - np.min(demand_factor)) / (np.max(demand_factor) - np.min(demand_factor) + 1e-6)
    angle_factor = (angle_factor - np.min(angle_factor)) / (np.max(angle_factor) - np.min(angle_factor) + 1e-6)

    # Combine factors with weights and distance penalization
    alpha = 0.3
    beta = 0.15
    gamma = 0.35
    delta = 0.2
    for i in range(n):
        for j in range(n):
            if i != j:
                heuristics_matrix[i, j] = (
                    alpha * savings_matrix[i, j]
                    + beta * (depot_proximity[i] + depot_proximity[j])
                    + gamma * demand_factor[i, j]
                    + delta * angle_factor[i, j]
                ) / (distance_matrix[i, j] + 1e-6)

    # Prioritize depot connections, less aggressively
    for i in range(1, n):
        heuristics_matrix[0, i] *= 1.05  # Boost depot edges
        heuristics_matrix[i, 0] *= 1.05

    # Dynamic Sparsification using a more robust percentile calculation
    non_zero_values = heuristics_matrix[heuristics_matrix > 0]
    if non_zero_values.size > 0:  # Ensure there are non-zero values
        sparsification_threshold = max(10, min(60, int(100 - np.log(n) * 10)))  # Dynamic adjustment of sparsification
        threshold = np.percentile(non_zero_values, sparsification_threshold)  # Increased percentile for more sparsification
        heuristics_matrix[heuristics_matrix < threshold] = 0
    else:
        # If all values are zero, skip sparsification
        pass

    # Route Diversity Encouragement
    for i in range(1, n):
        for j in range(1, n):
            if i != j:
                # Encourage connections between nodes with different demands (helps balance routes)
                demand_difference = abs(demands[i] - demands[j])
                heuristics_matrix[i, j] += 0.1 * (demand_difference / capacity)  # Scale by capacity
                heuristics_matrix[j, i] += 0.1 * (demand_difference / capacity)


    # Set diagonal to zero
    for i in range(n):
        heuristics_matrix[i, i] = 0

    return heuristics_matrix
```
