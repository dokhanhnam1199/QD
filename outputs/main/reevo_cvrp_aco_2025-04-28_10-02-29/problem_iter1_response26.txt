```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    A heuristic function for the Capacitated Vehicle Routing Problem (CVRP) that combines
    distance, demand, and angular considerations to estimate the promise of each edge.

    Args:
        distance_matrix (np.ndarray): A matrix of pairwise distances between nodes.
        coordinates (np.ndarray):  Euclidean coordinates of nodes.
        demands (np.ndarray): A vector of customer demands.
        capacity (int): The vehicle capacity.

    Returns:
        np.ndarray: A matrix of the same shape as distance_matrix, where each element
                  indicates the heuristic promise of including the corresponding edge
                  in a solution.  Higher values indicate more promising edges.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Calculate savings matrix (Clark-Wright savings heuristic component)
    savings_matrix = np.zeros((n, n))
    for i in range(1, n):
        for j in range(i + 1, n):
            savings_matrix[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]
            savings_matrix[j, i] = savings_matrix[i, j]

    # Angular penalty (penalize sharp turns away from the depot)
    angular_penalty = np.zeros((n, n))
    depot_x, depot_y = coordinates[0]
    for i in range(1, n):
        for j in range(1,n):
             if i == j:
                angular_penalty[i, j] = 0
             else:
                x_i, y_i = coordinates[i]
                x_j, y_j = coordinates[j]

                angle_i = np.arctan2(y_i - depot_y, x_i - depot_x)
                angle_j = np.arctan2(y_j - depot_y, x_j - depot_x)

                angular_diff = np.abs(angle_i - angle_j)
                angular_diff = np.min([angular_diff, 2 * np.pi - angular_diff]) # Make sure it's the smaller angle
                angular_penalty[i,j] = angular_diff
                angular_penalty[j,i] = angular_penalty[i,j]


    # Demand penalty: Higher demand between two customers makes an edge less desirable,
    # as the edge limits flexibility in filling the vehicle

    demand_penalty = np.zeros((n, n))
    for i in range(1,n):
        for j in range(1,n):
            if i ==j:
                demand_penalty[i,j] = 0
            else:
                demand_penalty[i, j] = demands[i] + demands[j]
                demand_penalty[j, i] = demand_penalty[i, j]
    demand_penalty = demand_penalty / (2*capacity)  #Scaled by vehicle capacity to keep values from dominating

    # Combine factors. Distance should be the biggest determinant; otherwise, shortest paths are not found
    # Consider savings matrix as secondary objective after distance
    # Angular penalty to avoid sharp turns away from the depot
    # Demand penalty reduces the probability that edges between large demand nodes are used in shortest paths

    heuristic_matrix = (1 / (distance_matrix + 1e-9)) + (0.5 * savings_matrix / np.max(savings_matrix + 1e-9)) - (0.2 * angular_penalty / np.max(angular_penalty + 1e-9)) - (0.1 * demand_penalty)

    # Sparsify: set less promising edges to zero
    threshold = np.percentile(heuristic_matrix[heuristic_matrix > 0], 20)  #Keep the top 80%
    heuristic_matrix[heuristic_matrix < threshold] = 0

    #Ensure diagonal is zero
    for i in range(n):
        heuristic_matrix[i,i] = 0
    return heuristic_matrix
```
