```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristic function for the Capacitated Vehicle Routing Problem (CVRP) using stochastic solution sampling.

    Emphasizes depot proximity, normalized demand, and dynamic sparsification thresholds for improved CVRP heuristics.

    Args:
        distance_matrix (np.ndarray): Distance matrix (shape: n by n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n by 2).
        demands (np.ndarray): Customer demands (shape: n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution
                    (shape: same as distance_matrix).
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)

    # Parameters (can be tuned)
    alpha = 1.0  # Weight for distance
    beta = 1.0   # Weight for demand attraction
    gamma = 1.0  # Weight for depot proximity

    # Calculate depot proximity (normalized distance to depot)
    depot_distances = distance_matrix[0, :] / np.max(distance_matrix[0, :])
    depot_proximity = 1 - depot_distances

    # Normalized demand
    normalized_demands = demands / np.max(demands[1:]) if np.max(demands[1:]) > 0 else np.zeros_like(demands) #exclude depot demand from normalizing

    for i in range(n):
        for j in range(n):
            if i == j:
                heuristics[i, j] = 0  # No self-loops
            else:
                # Encourage trips to depot more strongly
                if i == 0:
                    depot_prox_factor_i = 1.0
                else:
                    depot_prox_factor_i = depot_proximity[i]

                if j == 0:
                    depot_prox_factor_j = 1.0
                else:
                    depot_prox_factor_j = depot_proximity[j]

                heuristics[i, j] = (
                    (1 / (distance_matrix[i, j] + 1e-9))**alpha *  # Distance factor
                    (normalized_demands[i] + normalized_demands[j])**beta * # Demand factor, favoring larger demands
                    (depot_prox_factor_i * depot_prox_factor_j)**gamma  #Depot Proximity - more important if a node is far from the depot
                )

    # Dynamic Sparsification based on Distance
    distance_threshold = np.mean(distance_matrix) + np.std(distance_matrix)
    heuristics[distance_matrix > distance_threshold] = 0

    # Dynamic Sparsification based on Demand
    demand_threshold = 0.9  # Cap on demand (as proportion of total capacity)
    for i in range(1, n):  # Exclude depot connections
        for j in range(1, n):
            if i != j and demands[i] + demands[j] > demand_threshold * capacity:
                heuristics[i, j] = 0
                heuristics[j, i] = 0  # Ensure symmetry

    # Further Sparsification: keep only top k edges for each node based on heuristics value
    k = 7  # Number of edges to keep per node
    for i in range(n):
        # Get indices of top k edges
        row = heuristics[i, :].copy()
        row[i] = -np.inf  # Exclude self-loop
        top_k_indices = np.argsort(row)[::-1][:k]

        # Zero out all other edges
        for j in range(n):
            if j not in top_k_indices:
                heuristics[i, j] = 0

    return heuristics
```
