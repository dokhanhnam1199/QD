```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics function for solving Capacitated Vehicle Routing Problem (CVRP)
    via stochastic solution sampling.

    This version combines distance, demand, and angular information to
    estimate the desirability of including an edge in a route.  It also
    sparsifies the matrix by zeroing out less promising edges.

    Args:
        distance_matrix (np.ndarray): Distance matrix (shape: n by n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n by 2).
        demands (np.ndarray): Vector of customer demands (shape: n).
        capacity (int): Capacity of each vehicle.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge
                  in a solution (same shape as distance_matrix).
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)

    # Parameters (can be tuned)
    alpha = 1.0  # Distance importance
    beta = 0.5   # Demand importance
    gamma = 0.2   # Angle importance
    sparsity_threshold = 0.1 # Edges with heuristic value < threshold will be pruned.

    for i in range(n):
        for j in range(n):
            if i == j:
                heuristics[i, j] = 0  # No self-loops
            else:
                # 1. Distance factor (shorter distances are better)
                distance_factor = 1 / distance_matrix[i, j] if distance_matrix[i,j] > 0 else 0

                # 2. Demand factor (edges connecting low-demand nodes are better)
                demand_factor = 1 / (demands[i] + demands[j] + 1e-6) # Avoid division by zero
                
                # 3. Angle factor (try to avoid sharp turns by using angle between depot)
                #    nodes i, j and depot.
                depot_index = 0 # Depot index is 0

                # Check if the points are identical to avoid division by zero.
                if np.all(coordinates[i] == coordinates[depot_index]) or np.all(coordinates[j] == coordinates[depot_index]):
                    angle_factor = 0.0
                else:
                    vector_i = coordinates[i] - coordinates[depot_index]
                    vector_j = coordinates[j] - coordinates[depot_index]

                    # Calculate the cosine of the angle
                    norm_i = np.linalg.norm(vector_i)
                    norm_j = np.linalg.norm(vector_j)

                    if norm_i == 0 or norm_j == 0: # Handle zero vectors
                        cos_angle = 0.0  # Or any other reasonable default
                    else:
                        cos_angle = np.dot(vector_i, vector_j) / (norm_i * norm_j)
                        cos_angle = np.clip(cos_angle, -1.0, 1.0)

                    angle = np.arccos(cos_angle)

                    # Smaller angles towards the depot are better - this makes a route heading towards
                    # the depot a little more likely and makes very sharp turns (away then immediately
                    # back) less likely
                    angle_factor = 1 / (angle + 0.001) # Avoid division by zero
                    

                # Combine the factors
                heuristics[i, j] = (alpha * distance_factor +
                                     beta * demand_factor +
                                     gamma * angle_factor)
                                    
    # Normalize the heuristics values.
    max_val = np.max(heuristics)
    if max_val > 0:
        heuristics = heuristics / max_val

    # Sparsify the matrix.
    heuristics[heuristics < sparsity_threshold] = 0

    return heuristics
```
