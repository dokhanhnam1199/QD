```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics function for Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.

    This version combines several factors to determine how promising it is to select an edge,
    including distance, demand, and angular proximity to the depot.  It also sparsifies the
    matrix by setting unpromising elements to zero.

    Args:
        distance_matrix (np.ndarray): Distance matrix (shape: n by n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n by 2).
        demands (np.ndarray): Vector of customer demands (shape: n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution
                  (same shape as distance_matrix).
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # Parameters (tune these for better performance)
    distance_weight = 1.0  # Weight for the inverse of distance
    demand_weight = 0.5  # Weight for demand-based penalty
    angle_weight = 0.2   # Weight for angular proximity to depot
    sparsification_threshold = 0.1 #Edges with scores lower than this become 0.

    # Calculate angles relative to the depot (node 0)
    depot_x, depot_y = coordinates[0]
    angles = np.arctan2(coordinates[:, 1] - depot_y, coordinates[:, 0] - depot_x)

    for i in range(n):
        for j in range(n):
            if i == j:
                heuristic_matrix[i, j] = 0  # No self-loops
                continue

            # Distance factor (inverse of distance)
            distance_factor = 1 / (distance_matrix[i, j] + 1e-9)  # Add small value to avoid division by zero

            # Demand factor (penalty for high demand nodes)
            demand_factor = 1 - (demands[i] + demands[j]) / (2 * capacity)
            demand_factor = max(0, demand_factor)  # Ensure non-negative

            # Angle factor (favor nodes closer to the depot)
            angle_diff = min(abs(angles[i] - angles[j]), 2 * np.pi - abs(angles[i] - angles[j])) #account for wraparound

            angle_factor = np.exp(-angle_diff)  # Exponential decay with angle difference

            # Combine factors
            heuristic_matrix[i, j] = (
                distance_weight * distance_factor +
                demand_weight * demand_factor +
                angle_weight * angle_factor
            )

    # Normalize the heuristic matrix (optional, but can improve sampling)
    heuristic_matrix = heuristic_matrix / np.max(heuristic_matrix) if np.max(heuristic_matrix) > 0 else heuristic_matrix

    # Sparsify the matrix: set values below the threshold to 0
    heuristic_matrix[heuristic_matrix < sparsification_threshold] = 0
    return heuristic_matrix
```
