```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristic function for the Capacitated Vehicle Routing Problem (CVRP) using stochastic solution sampling.

    Emphasizes depot proximity, normalized demand, and dynamic sparsification thresholds for improved CVRP heuristics.

    Args:
        distance_matrix (np.ndarray): Distance matrix (shape: n by n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n by 2).
        demands (np.ndarray): Customer demands (shape: n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution
                    (shape: same as distance_matrix).
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)

    # Parameters (can be tuned)
    alpha = 1.0  # Weight for distance
    beta = 1.0   # Weight for demand attraction
    gamma = 1.0  # Weight for depot proximity

    # Calculate depot proximity (normalized distance to depot)
    depot_distances = distance_matrix[0, :]
    max_depot_distance = np.max(depot_distances[1:]) # Avoid division by zero if all nodes are at depot.
    depot_proximity = np.zeros(n)
    for i in range(1,n):
         depot_proximity[i] = 1 - (depot_distances[i] / (max_depot_distance + 1e-9)) # Normalize, avoid division by zero.

    # Normalized demand
    total_demand = np.sum(demands[1:]) #sum of all customer demands
    normalized_demands = demands / total_demand #relative size of each demand.


    for i in range(n):
        for j in range(n):
            if i == j:
                heuristics[i, j] = 0  # No self-loops
            else:
                # Encourage trips to depot more strongly
                depot_prox_factor = (depot_proximity[i] + depot_proximity[j])  # Combine proximities

                heuristics[i, j] = (
                    (1 / distance_matrix[i, j])**alpha *  # Distance factor
                    (normalized_demands[i] + normalized_demands[j])**beta * # Demand factor, favoring larger demands
                    (depot_prox_factor)**gamma  #Depot Proximity - more important if a node is far from the depot
                )

    # Dynamic Sparsification based on Distance
    distance_threshold = np.mean(distance_matrix) + np.std(distance_matrix)
    heuristics[distance_matrix > distance_threshold] = 0

    # Dynamic Sparsification based on Demand
    demand_threshold = 0.7  # Cap on demand (as proportion of vehicle capacity)
    for i in range(1, n):  # Exclude depot connections
        for j in range(1, n):
            if i != j and demands[i] + demands[j] > demand_threshold * capacity:
                heuristics[i, j] = 0
                heuristics[j, i] = 0  # Ensure symmetry

    # Further Sparsification: keep only top k edges for each node based on heuristics value
    k = 6  # Number of edges to keep per node
    for i in range(n):
        # Get indices of top k edges
        top_k_indices = np.argsort(heuristics[i, :])[::-1][:k]
        # Zero out all other edges
        for j in range(n):
            if j not in top_k_indices:
                heuristics[i, j] = 0

    return heuristics
```
