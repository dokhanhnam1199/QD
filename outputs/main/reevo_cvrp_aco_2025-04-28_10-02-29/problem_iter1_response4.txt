```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristic function for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.

    This function calculates a heuristic matrix indicating the "promise" of including each edge in a CVRP solution.
    It considers distance, demand, angular proximity, and sparsifies the matrix by setting unpromising elements to zero.

    Args:
        distance_matrix (np.ndarray): A square matrix (n x n) representing the distances between nodes.
        coordinates (np.ndarray): A matrix (n x 2) representing the Euclidean coordinates of the nodes.
        demands (np.ndarray): A vector (n) representing the demands of each node.
        capacity (int): The capacity of each vehicle.

    Returns:
        np.ndarray: A matrix (n x n) of heuristic values indicating the promise of each edge.  Values near 0 mean this is not a promising edge.
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Parameters (tune these for optimal performance)
    alpha = 1.0   # Distance factor (higher = prioritize shorter distances)
    beta = 0.5   # Demand factor (higher = penalize edges connecting high-demand nodes)
    gamma = 0.8 # Angular proximity factor (higher = prioritize edges that create smoother routes)
    sparsity_threshold = 0.1 # Threshold for sparsifying the matrix. Set smaller to eliminate more edges.

    # Depot coordinates
    depot_x, depot_y = coordinates[0]

    for i in range(n):
        for j in range(n):
            if i != j:
                # Distance component (encourage shorter edges)
                distance_component = (1 / distance_matrix[i, j])**alpha

                # Demand component (penalize edges connecting large demands)
                demand_component = (1 / (demands[i] + demands[j] + 1e-6))**beta #Adding a small number to prevent dividing by zero

                # Angular proximity component (encourage edges that make smoother turns)
                # Calculate angle between vector from depot to i and vector from i to j.
                x_i, y_i = coordinates[i]
                x_j, y_j = coordinates[j]
                
                #Handle special case when i is the depot itself to prevent numerical issues with arc tangents
                if i == 0:
                    angle_component = 1.0 #Do not penalize edges leaving the depot in the same manner.
                else:
                    angle_depot_i = np.arctan2(y_i - depot_y, x_i - depot_x)
                    angle_i_j = np.arctan2(y_j - y_i, x_j - x_i)
                    angle_diff = np.abs(angle_i_j - angle_depot_i)
                    angle_diff = np.minimum(angle_diff, 2 * np.pi - angle_diff)  # Ensure angle difference is between 0 and pi

                    # Penalize large angle changes (steeper turns)
                    angle_component = (1 / (angle_diff + 0.1))**gamma
                    
                heuristic_matrix[i, j] = distance_component * demand_component * angle_component

    # Sparsify the matrix (remove less promising edges)
    max_heuristic = np.max(heuristic_matrix)
    if max_heuristic > 0:
          normalized_heuristic_matrix = heuristic_matrix / max_heuristic
          heuristic_matrix[normalized_heuristic_matrix < sparsity_threshold] = 0


    return heuristic_matrix
```
