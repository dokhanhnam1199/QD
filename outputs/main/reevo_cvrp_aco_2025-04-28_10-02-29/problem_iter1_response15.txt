```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristic function for the Capacitated Vehicle Routing Problem (CVRP) using stochastic solution sampling.

    Combines several factors to determine how promising it is to select an edge,
    and sparsifies the matrix by setting unpromising elements to zero.

    Args:
        distance_matrix (np.ndarray): Distance matrix (shape: n by n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n by 2).
        demands (np.ndarray): Customer demands (shape: n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution
                    (shape: same as distance_matrix).
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)

    # Parameters (can be tuned)
    alpha = 1.0  # Weight for distance
    beta = 1.0   # Weight for demand attraction
    gamma = 0.5  # Weight for depot proximity

    # Calculate depot proximity (normalized distance to depot)
    depot_distances = distance_matrix[0, :] / np.max(distance_matrix[0, :])
    depot_proximity = 1 - depot_distances

    # Node Attraction to Depot (demand-weighted)
    node_attraction = demands / capacity

    # Normalized demand
    normalized_demands = demands / np.max(demands)


    for i in range(n):
        for j in range(n):
            if i == j:
                heuristics[i, j] = 0  # No self-loops
            else:
                # Encourage trips to depot more strongly
                if i == 0:
                    depot_prox_factor_i = 1
                else:
                    depot_prox_factor_i = depot_proximity[i]

                if j == 0:
                    depot_prox_factor_j = 1
                else:
                    depot_prox_factor_j = depot_proximity[j]


                heuristics[i, j] = (
                    (1 / distance_matrix[i, j])**alpha *  # Distance factor
                    (normalized_demands[i] + normalized_demands[j])**beta * # Demand factor, favoring larger demands
                    (depot_prox_factor_i + depot_prox_factor_j)**gamma  #Depot Proximity - more important if a node is far from the depot
                )

    # Sparsify the matrix: remove edges that are too long or connect nodes with high demand that would likely overload a vehicle early on
    distance_threshold = np.mean(distance_matrix) + np.std(distance_matrix)  # Dynamic threshold
    demand_threshold = 0.8 # Cap on demand (as proportion of total capacity)

    for i in range(n):
        for j in range(n):
            if distance_matrix[i, j] > distance_threshold:
                heuristics[i, j] = 0
            # Disincentivize immediate connections that violate capacity too easily
            elif demands[i] + demands[j] > demand_threshold * capacity and i != 0 and j !=0:
               heuristics[i,j] = 0

    return heuristics
```
