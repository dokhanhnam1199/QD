```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristic function for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.

    Args:
        distance_matrix (np.ndarray): Distance matrix (shape: n by n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n by 2).
        demands (np.ndarray): Vector of customer demands (shape: n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (same shape as distance_matrix).
    """
    n = distance_matrix.shape[0]

    # Initialize the heuristic matrix with zeros
    heuristic_matrix = np.zeros_like(distance_matrix)

    # Parameters to control the influence of each factor
    distance_weight = 1.0
    demand_weight = 0.5
    angle_weight = 0.3 # Increased the weight, potentially crucial to avoid unnecessary backtracking
    capacity_weight = 0.1 # Penalize edges that connect to nodes exceeding the vehicle capacity

    # Depot index
    depot_index = 0

    # Calculate the heuristic value for each edge
    for i in range(n):
        for j in range(n):
            if i != j:
                # Distance factor: favor shorter distances
                distance_factor = 1 / distance_matrix[i, j]

                # Demand factor: penalize edges connecting nodes with large demands relative to capacity. Make sure to penalize going back to depot, and do not penalize depot origin edges
                demand_factor = 1.0
                if i != depot_index and j != depot_index:
                   demand_factor = np.exp(-demands[i] / capacity - demands[j] / capacity)
                elif j== depot_index and i != depot_index:
                   demand_factor = np.exp(-demands[i] / capacity)

                # Angle factor: Penalize sharp turns. The lower the absolute angle, the better. It helps smoothing paths, which gives better results.
                angle_factor = 1.0
                if i != depot_index and j != depot_index:
                    # Get vectors from i and j to depot, and make them unit vectors
                    vector_i_depot = coordinates[depot_index] - coordinates[i]
                    vector_j_depot = coordinates[depot_index] - coordinates[j]
                    vector_i_depot = vector_i_depot / np.linalg.norm(vector_i_depot)
                    vector_j_depot = vector_j_depot / np.linalg.norm(vector_j_depot)

                    # angle
                    angle = np.arccos(np.dot(vector_i_depot, vector_j_depot))
                    angle_factor = np.exp(-np.abs(angle)) # exponential penalization of bad angles

                # Capacity factor (heuristic): Further penalize edges based on exceeding the remaining vehicle capacity (more sophisticated capacity handling)
                capacity_factor = 1.0 #Initial value

                # Combine the factors, making sure that depot connections are heavily favored.
                heuristic_matrix[i, j] = (
                    distance_weight * distance_factor +
                    demand_weight * demand_factor +
                    angle_weight * angle_factor +
                    capacity_weight * capacity_factor
                )

    # Sparsify the matrix by setting low heuristic values to zero.
    # This encourages the algorithm to explore only the most promising edges.

    threshold = np.quantile(heuristic_matrix[heuristic_matrix > 0], 0.2)  # Keep top 80% of edges
    heuristic_matrix[heuristic_matrix < threshold] = 0


    return heuristic_matrix
```
