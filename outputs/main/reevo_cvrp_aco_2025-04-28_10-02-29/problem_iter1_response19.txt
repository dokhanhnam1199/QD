```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristic function for CVRP based on stochastic solution sampling principles.

    Args:
        distance_matrix: Distance matrix between nodes.
        coordinates: Euclidean coordinates of nodes.
        demands: Demand of each customer.
        capacity: Vehicle capacity.

    Returns:
        A matrix of the same shape as distance_matrix, indicating the
        "promise" of each edge.  Higher values indicate more promising edges.
    """

    n = distance_matrix.shape[0]
    promise = np.zeros_like(distance_matrix)

    # Parameters to control the influence of different factors
    alpha = 0.5  # Distance factor
    beta = 0.3   # Demand factor
    gamma = 0.2  # Location factor (avoid distant nodes)

    # Calculate distance-based promise (shorter distances are better)
    promise = 1 / (distance_matrix + 1e-6)  # Adding a small constant to avoid division by zero
    promise = promise / np.max(promise)  # Normalize to [0, 1]

    # Incorporate demand information.  Edges connecting to nodes with high
    # demand *could* be less promising if they lead to exceeding capacity,
    # but we want to bias towards *visiting* nodes with high demand, 
    # especially when far from depot, so we do not use simple penalty based on demand magnitude.
    # A better way is to reduce the promise for links between two high-demand nodes

    for i in range(n):
        for j in range(n):
            if i != j:
                promise[i, j] = promise[i,j] - beta*demands[i]*demands[j]/np.max(demands)**2 # penalize edges connecting nodes with high demand

    promise = np.clip(promise,0,1) #ensure promise within bounds

    # Incorporate location information.  Nodes far from the depot are risky,
    # since they may lead to routes which require large distances to complete.
    # Penalize edges connecting to distant nodes from depot.
    depot_distances = distance_matrix[0, :] / np.max(distance_matrix[0, :]) # normalized distances to depot
    for i in range(n):
        for j in range(n):
          if i!=j:
             promise[i, j] = promise[i, j] - gamma*(depot_distances[i]+depot_distances[j])/2
    promise = np.clip(promise,0,1)

    # Sparsify the matrix: set unpromising edges to zero. This reduces the
    # search space for stochastic sampling. Can significantly improve
    # running time.
    threshold = np.quantile(promise[promise > 0], 0.2)  # Keep top 80% of edges

    promise[promise < threshold] = 0

    # Ensure diagonal elements are zero (no self-loops)
    for i in range(n):
        promise[i, i] = 0

    return promise
```
