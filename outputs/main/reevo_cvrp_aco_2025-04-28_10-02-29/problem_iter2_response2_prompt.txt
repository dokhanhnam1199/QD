{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a heuristics function for Solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling. CVRP requires finding the shortest path that visits all given nodes and returns to the starting node. Each node has a demand and each vehicle has a capacity. The total demand of the nodes visited by a vehicle cannot exceed the vehicle capacity. When the total demand exceeds the vehicle capacity, the vehicle must return to the starting node.\nThe `heuristics` function takes as input a distance matrix (shape: n by n), Euclidean coordinates of nodes (shape: n by 2), a vector of customer demands (shape: n), and the integer capacity of vehicle capacity. It returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the distance_matrix. The depot node is indexed by 0.\n\n\n[Worse code]\ndef heuristics_v0(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n\n    \"\"\"\n    A heuristics function for solving Capacitated Vehicle Routing Problem (CVRP)\n    via stochastic solution sampling. It combines several factors to determine\n    how promising it is to select an edge, and sparsifies the matrix.\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix (shape: n by n).\n        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n by 2).\n        demands (np.ndarray): Customer demands (shape: n).\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Prior indicators of how promising it is to include each edge in a solution\n                   (shape: same as distance_matrix).\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n\n    # 1. Distance factor: Shorter distances are more promising.\n    distance_factor = 1 / (distance_matrix + 1e-6)  # Add a small constant to avoid division by zero\n\n    # 2. Demand factor: Penalize edges that would likely lead to capacity violations.\n    demand_factor = np.ones((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i != j and i != 0 and j != 0:\n                # Rough estimate of whether adding this edge will violate capacity.\n                # Assuming that the nodes i and j will belong to the same route.\n                if demands[i] + demands[j] > capacity / 3:  # Dividing by 3 allows room for other potential nodes\n                    demand_factor[i, j] = 0.1  # Significantly penalize\n                elif demands[i] + demands[j] > capacity / 2:\n                    demand_factor[i, j] = 0.5\n            elif i == 0 or j == 0:\n                # Connections with the depot are always important\n                demand_factor[i, j] = 1.0\n\n    # 3. Depot proximity factor: Favor connections closer to the depot (node 0).\n    depot_proximity_factor = np.zeros((n, n))\n    for i in range(n):\n      for j in range(n):\n        if i!=j:\n          depot_proximity_factor[i,j] = 1/((distance_matrix[0,i] + distance_matrix[0,j]) + 1e-6)\n\n\n    # 4. Combine the factors.  Experiment with weights.\n    heuristic_matrix = (\n        0.6 * distance_factor\n        + 0.2 * demand_factor\n        + 0.2 * depot_proximity_factor\n    )\n\n\n    # 5. Sparsify the matrix: Set unpromising elements to zero.\n    #    Keep only the k-nearest neighbors for each node.\n    k = int(np.sqrt(n))  # Adjust k based on problem size.\n\n    for i in range(n):\n        # Get indices of the k largest values in the row.\n        indices = np.argpartition(heuristic_matrix[i, :], -k)[-k:]\n\n        # Zero out all other elements in the row.\n        row = np.zeros(n)\n        row[indices] = heuristic_matrix[i, indices]\n        heuristic_matrix[i, :] = row\n\n\n    # Ensure depot connections are always considered, even if sparsified\n    for i in range(n):\n        heuristic_matrix[0, i] = max(heuristic_matrix[0,i], 0.1 * np.max(heuristic_matrix))  # small non-zero value\n        heuristic_matrix[i, 0] = max(heuristic_matrix[i, 0], 0.1 * np.max(heuristic_matrix))\n\n\n    return heuristic_matrix\n\n[Better code]\ndef heuristics_v1(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n\n    \"\"\"\n    A heuristic function for solving the Capacitated Vehicle Routing Problem (CVRP)\n    via stochastic solution sampling.\n\n    This version combines distance, demand, and geometric factors to create a\n    prior indicator matrix.  It also sparsifies the matrix by zeroing out\n    unpromising edges.\n\n    Args:\n        distance_matrix: A numpy array representing the distance between nodes.\n                         Shape: (n, n)\n        coordinates: A numpy array representing the (x, y) coordinates of the nodes.\n                     Shape: (n, 2)\n        demands: A numpy array representing the demand of each node. Shape: (n,)\n        capacity: The capacity of each vehicle.\n\n    Returns:\n        A numpy array of the same shape as distance_matrix, representing the\n        prior indicators of how promising it is to include each edge in a solution.\n    \"\"\"\n\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n\n    # Parameters to control the influence of each factor. Tune these.\n    distance_weight = 1.0\n    demand_weight = 0.5\n    angle_weight = 0.2\n    depot_proximity_weight = 0.3\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristic_matrix[i, j] = 0  # No self-loops\n                continue\n\n            # Distance factor (favor shorter distances)\n            distance_factor = 1 / (distance_matrix[i, j] + 1e-6) # Avoid division by zero\n\n            # Demand factor (penalize edges that would quickly fill a vehicle)\n            demand_factor = 1 / (demands[i] + demands[j] + 1e-6)\n\n            # Angle factor (favor edges that don't cause sharp turns away from the depot. Penalize sharp turns)\n            #  Dot product to determine how much a step i -> j points in the right direction\n            # First calculate direction to depot:\n            depot_direction_i = coordinates[0] - coordinates[i]\n            depot_direction_j = coordinates[0] - coordinates[j]\n            # Normalize:\n            depot_direction_i = depot_direction_i / (np.linalg.norm(depot_direction_i) + 1e-6)\n            depot_direction_j = depot_direction_j / (np.linalg.norm(depot_direction_j) + 1e-6)\n            # Step direction:\n            step_direction = coordinates[j] - coordinates[i]\n            step_direction = step_direction / (np.linalg.norm(step_direction) + 1e-6)\n            angle_factor_i = np.dot(step_direction, depot_direction_i) # How much node i heads towards depot.\n            angle_factor_j = np.dot(-step_direction, depot_direction_j) # And for node j. Note the inverse.\n            angle_factor = (angle_factor_i + angle_factor_j) / 2 # Take the average\n            angle_factor = (angle_factor + 1) / 2 # Scales to between 0 and 1. Better since it handles the negatives correctly.\n            angle_factor = np.clip(angle_factor, 0, 1) # Ensure the clip for robustness\n\n            # Proximity to Depot factor (favor connections with nodes farther from the depot), only when it's not the starting depot.\n            depot_proximity_i = distance_matrix[0, i] / (np.max(distance_matrix[0, :]) + 1e-6) # Normalized distance to depot\n            depot_proximity_j = distance_matrix[0, j] / (np.max(distance_matrix[0, :]) + 1e-6)\n            depot_proximity_factor = np.sqrt(depot_proximity_i * depot_proximity_j) # Geometric mean.\n\n            heuristic_matrix[i, j] = (\n                distance_weight * distance_factor +\n                demand_weight * demand_factor +\n                angle_weight * angle_factor +\n                depot_proximity_weight * depot_proximity_factor\n            )\n\n    # Sparsify the matrix:  Zero out edges that are deemed very unpromising.\n\n    # Option 1: Threshold based on heuristic value.\n    threshold = np.mean(heuristic_matrix[heuristic_matrix > 0]) * 0.2  # Example threshold\n    heuristic_matrix[heuristic_matrix < threshold] = 0\n\n    # Option 2: Keep only the k-nearest neighbors for each node\n    # for i in range(n):\n    #     row = heuristic_matrix[i, :].copy()\n    #     indices = np.argsort(row)[::-1] # Sort in descending order\n    #     k = 5 # Keep top 5 neighbors\n    #     heuristic_matrix[i, indices[k:]] = 0 # Clear the others\n    #     heuristic_matrix[i, i] = 0 # Clears the self-loops if not manually handled before\n\n    return heuristic_matrix\n\n[Reflection]\nThe better code adds angle factor, normalizes factors, uses weights, and applies sparsification more effectively.\n\n\n[Improved code]\nPlease write an improved function `heuristics_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}