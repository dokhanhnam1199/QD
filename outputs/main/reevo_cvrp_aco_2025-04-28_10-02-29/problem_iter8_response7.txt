```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristic function for Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.
    Refined version with enhanced savings calculation, adaptive sparsification, and prioritized depot connections.
    Incorporates distance, capacity, and normalization improvements.

    Args:
        distance_matrix (np.ndarray): Distance matrix between nodes (n x n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (n x 2).
        demands (np.ndarray): Vector of customer demands (n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (n x n).
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros((n, n))

    # Calculate savings matrix (Clarke-Wright Savings) - enhanced normalization
    savings_matrix = np.zeros((n, n))
    for i in range(1, n):
        for j in range(i + 1, n):
            savings = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]
            savings_matrix[i, j] = savings
            savings_matrix[j, i] = savings

    max_savings = np.max(savings_matrix)
    if max_savings > 0:
        savings_matrix = savings_matrix / max_savings
    else:
        savings_matrix = np.zeros((n, n))

    # Node proximity to depot
    depot_proximity = np.zeros(n)
    for i in range(1, n):
        depot_proximity[i] = 1 / (distance_matrix[0, i] + 1e-6)
    depot_proximity = (depot_proximity - np.min(depot_proximity)) / (np.max(depot_proximity) - np.min(depot_proximity) + 1e-6)

    # Demand factor - Normalized by capacity
    demand_factor = np.zeros((n, n))
    for i in range(1, n):
        for j in range(1, n):
            if i != j:
                demand_factor[i, j] = max(0, 1 - (demands[i] + demands[j]) / (2 * capacity)) # Ensure non-negative


    # Angle factor (try to avoid sharp turns)
    angle_factor = np.zeros((n, n))
    for i in range(1, n):
        for j in range(1, n):
            if i != j:
                vector_i = coordinates[i] - coordinates[0]
                vector_j = coordinates[j] - coordinates[0]
                dot_product = np.dot(vector_i, vector_j)
                magnitudes = np.linalg.norm(vector_i) * np.linalg.norm(vector_j)
                if magnitudes > 0:
                    cos_angle = np.clip(dot_product / magnitudes, -1.0, 1.0)
                    angle = np.arccos(cos_angle)
                    angle_factor[i, j] = 1 - (angle / np.pi)
                else:
                    angle_factor[i, j] = 0

    angle_factor = (angle_factor - np.min(angle_factor)) / (np.max(angle_factor) - np.min(angle_factor) + 1e-6)

    # Distance factor - inverse distance
    distance_factor = 1 / (distance_matrix + 1e-6)
    np.fill_diagonal(distance_factor, 0)

    # Combine factors with weights - incorporate distance in the combination
    for i in range(n):
        for j in range(n):
            if i != j:
                heuristics_matrix[i, j] = (
                    0.4 * savings_matrix[i, j]
                    + 0.15 * (depot_proximity[i] + depot_proximity[j])
                    + 0.1 * demand_factor[i, j]
                    + 0.15 * angle_factor[i, j]
                ) / (distance_matrix[i, j] + 1e-6) # Explicitly incorporate distance


    # Prioritize depot connections and nearby nodes
    for i in range(1, n):
        heuristics_matrix[0, i] *= 1.3  # Stronger priority for depot connections
        heuristics_matrix[i, 0] *= 1.3

    # Adaptive Sparsification based on distance and capacity
    # Adjust threshold based on capacity relative to average demand and distance
    avg_demand = np.mean(demands[1:])
    avg_distance = np.mean(distance_matrix)

    sparsification_factor = np.clip(capacity / (avg_demand * (avg_distance + 1e-6)), 0.1, 1.0)  # Scale with capacity and distance
    sparsification_threshold = 0.5 + 0.4 * sparsification_factor # dynamic threshold

    threshold = np.percentile(heuristics_matrix[heuristics_matrix > 0], 100 * sparsification_threshold)  # Adaptively remove a percentage

    heuristics_matrix[heuristics_matrix < threshold] = 0

    # Set diagonal to zero and make matrix asymmetric
    for i in range(n):
        heuristics_matrix[i, i] = 0

    return heuristics_matrix
```
