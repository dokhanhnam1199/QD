```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:

    """
    Heuristic function for CVRP via stochastic solution sampling, incorporating distance,
    normalized demand, depot proximity, angle to depot, and adaptive sparsification.

    Args:
        distance_matrix (np.ndarray): Distance matrix.
        coordinates (np.ndarray): Node coordinates.
        demands (np.ndarray): Customer demands.
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators for promising edges.
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)

    # Parameters (Tunable)
    alpha = 1.1 # Distance influence
    beta = 0.8  # Demand attraction
    gamma = 0.9 # Depot proximity
    delta = 0.5  # Angle towards depot

    # Normalized demand
    normalized_demands = demands / capacity

    # Depot Proximity
    depot_distances = distance_matrix[0, :]
    max_depot_distance = np.max(depot_distances)
    depot_proximity = (max_depot_distance - depot_distances) / (max_depot_distance + 1e-6)

    # Angle to Depot
    angle_to_depot = np.zeros((n, n))
    for i in range(1, n):
        for j in range(1, n):
            if i != j:
                vector_i = coordinates[i] - coordinates[0]
                vector_j = coordinates[j] - coordinates[0]
                dot_product = np.dot(vector_i, vector_j)
                norm_i = np.linalg.norm(vector_i)
                norm_j = np.linalg.norm(vector_j)
                cos_angle = dot_product / (norm_i * norm_j + 1e-6)
                cos_angle = np.clip(cos_angle, -1.0, 1.0)
                angle = np.arccos(cos_angle)
                angle_to_depot[i, j] = 1 - (angle / np.pi) # Normalize between 0 and 1

    for i in range(n):
        for j in range(n):
            if i == j:
                heuristics[i, j] = 0
            else:
                #Adjust depot connection heuristic
                depot_factor_i = 1.0 if i == 0 else depot_proximity[i]
                depot_factor_j = 1.0 if j == 0 else depot_proximity[j]

                heuristics[i, j] = (
                    (1 / (distance_matrix[i, j] + 1e-6))**alpha *
                    (normalized_demands[i] + normalized_demands[j])**beta *
                    (depot_factor_i * depot_factor_j)**gamma *
                    (angle_to_depot[i, j])**delta
                )
    #Sparsification based on distance
    distance_threshold = np.mean(distance_matrix) + 0.6 * np.std(distance_matrix)
    heuristics[distance_matrix > distance_threshold] = 0

    # Sparsification based on demand
    demand_threshold = 0.85  # Slightly less aggressive than before.
    for i in range(1, n):
        for j in range(1, n):
             if i != j and normalized_demands[i] + normalized_demands[j] > demand_threshold:
                heuristics[i, j] = 0
                heuristics[j, i] = 0

    # Adaptive Sparsification: Keep top k edges
    k = max(2, int(np.sqrt(n))) #Adaptive k
    for i in range(n):
        row = heuristics[i, :]
        indices = np.argpartition(row, -k)[-k:]  # Get indices of k largest elements
        mask = np.ones(row.shape, dtype=bool)
        mask[indices] = False
        row[mask] = 0
        heuristics[i, :] = row

    return heuristics
```
