```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:

    """
    Heuristic function for Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.
    Refined edge scoring with normalized, weighted factors (savings, depot proximity, demand, angle).
    Dynamically sparsify the edge matrix based on vehicle capacity and edge scores.
    Prioritize depot connections and adapt thresholds for improved efficiency.

    Args:
        distance_matrix (np.ndarray): Distance matrix between nodes (n x n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (n x 2).
        demands (np.ndarray): Vector of customer demands (n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (n x n).
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros((n, n))

    # Calculate savings matrix (Clarke-Wright Savings)
    savings_matrix = np.zeros((n, n))
    for i in range(1, n):
        for j in range(i + 1, n):
            savings_matrix[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]
            savings_matrix[j, i] = savings_matrix[i, j]

    max_savings = np.max(savings_matrix)
    if max_savings > 0:
        savings_matrix /= max_savings

    # Node proximity to depot (normalized)
    depot_proximity = np.zeros(n)
    for i in range(1, n):
        depot_proximity[i] = 1 / (distance_matrix[0, i] + 1e-6)

    max_depot_proximity = np.max(depot_proximity)
    if max_depot_proximity > 0:
        depot_proximity /= max_depot_proximity


    # Demand factor (normalized)
    demand_factor = np.zeros((n, n))
    for i in range(1, n):
        for j in range(1, n):
            if i != j:
                demand_factor[i, j] = 1 / (demands[i] + demands[j] + 1e-6)  # Avoid division by zero

    max_demand_factor = np.max(demand_factor)
    if max_demand_factor > 0:
      demand_factor /= max_demand_factor


    #Angle Factor
    angle_factor = np.zeros((n, n))
    for i in range(1, n):
        for j in range(1, n):
            if i != j:
                vector_i = coordinates[i] - coordinates[0]
                vector_j = coordinates[j] - coordinates[0]
                dot_product = np.dot(vector_i, vector_j)
                magn_i = np.linalg.norm(vector_i)
                magn_j = np.linalg.norm(vector_j)
                cos_angle = dot_product / (magn_i * magn_j + 1e-6)
                angle_factor[i, j] = cos_angle  # Closer to 1 means similar angle

    max_angle_factor = np.max(angle_factor)
    if max_angle_factor > 0:
        angle_factor /= max_angle_factor


    # Combine factors with weights
    for i in range(n):
        for j in range(n):
            if i != j:
                heuristics_matrix[i, j] = (
                    0.4 * savings_matrix[i, j]
                    + 0.3 * (depot_proximity[i] + depot_proximity[j])
                    + 0.1 * demand_factor[i, j]
                    + 0.2 * angle_factor[i,j]
                ) / (distance_matrix[i, j] + 1e-6)

    # Prioritize depot connections.  Boost score if one of the nodes is depot.
    for i in range(1,n):
        heuristics_matrix[0,i] *= 1.2
        heuristics_matrix[i,0] *= 1.2

    # Dynamic Sparsification based on capacity and heuristic score
    threshold = np.percentile(heuristics_matrix[heuristics_matrix > 0], 40)  # Adaptive threshold
    heuristics_matrix[heuristics_matrix < threshold] = 0


    # Ensure depot connections remain
    for i in range(1, n):
         if distance_matrix[0,i] > 0 and heuristics_matrix[0,i] == 0:
            heuristics_matrix[0,i] = threshold #Ensure depot connections remain if distance not zero

    #Set diagonal to zero and make matrix asymmetric
    for i in range(n):
        heuristics_matrix[i, i] = 0


    return heuristics_matrix
```
