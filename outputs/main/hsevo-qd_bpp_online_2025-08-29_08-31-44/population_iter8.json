[
  {
    "stdout_filepath": "problem_iter0_stdout0.txt",
    "code_path": "problem_iter0_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities",
    "response_id": 0,
    "obj": 4.487435181491823,
    "SLOC": 3.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 0.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response7.txt_stdout.txt",
    "code_path": "problem_iter1_code7.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if np.sum(valid_bins) == 0:\n        return priorities\n    \n    priorities[valid_bins] = 1.0 / (bins_remain_cap[valid_bins] - item + 1e-6)\n    \n    return priorities",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.198244914240141,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 57.110323830864054,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response1.txt_stdout.txt",
    "code_path": "problem_iter1_code1.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return priorities\n    \n    waste = bins_remain_cap[valid_bins] - item\n    priorities[valid_bins] = 1.0 / (waste + 1e-9)\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.198244914240141,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 51.80615605397529,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response4.txt_stdout.txt",
    "code_path": "problem_iter1_code4.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    suitable_bins = bins_remain_cap >= item\n    if np.any(suitable_bins):\n        min_waste = np.min(bins_remain_cap[suitable_bins] - item)\n        priorities[suitable_bins] = 1.0 / (min_waste + 1e-6)\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 41.51317942364757,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response6.txt_stdout.txt",
    "code_path": "problem_iter1_code6.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    remaining_capacities = bins_remain_cap[possible_bins]\n    fit_scores = 1.0 / (1.0 + np.exp(-5 * (remaining_capacities - item)))\n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[possible_bins] = fit_scores\n    return priorities",
    "response_id": 6,
    "tryHS": false,
    "obj": 13.40247307538892,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 77.66179398375645,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response9.txt_stdout.txt",
    "code_path": "problem_iter1_code9.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    temp = bins_remain_cap - item\n    priorities = np.where(temp >= 0, np.exp(temp / (item + 1e-6)), 0)\n    priorities = priorities / np.sum(priorities)\n    return priorities",
    "response_id": 9,
    "tryHS": false,
    "obj": 149.30195452732352,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 53.77443751081735,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response12.txt_stdout.txt",
    "code_path": "problem_iter1_code12.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):\n        worst_fit_capacity = np.min(bins_remain_cap[valid_bins])\n        priorities[valid_bins] = worst_fit_capacity\n    return priorities",
    "response_id": 12,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 4.754887502163469,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response13.txt_stdout.txt",
    "code_path": "problem_iter1_code13.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            priorities[i] = cap - item\n        else:\n            priorities[i] = -1\n    return priorities",
    "response_id": 13,
    "tryHS": false,
    "obj": 149.30195452732352,
    "SLOC": 8.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 20.67970000576925,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response14.txt_stdout.txt",
    "code_path": "problem_iter1_code14.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    feasible_bins = bins_remain_cap >= item\n    if np.any(feasible_bins):\n        best_fit_index = np.argmin(bins_remain_cap[feasible_bins] - item)\n        priorities[feasible_bins] = 1.0\n        priorities[np.where(bins_remain_cap >= item)[0][best_fit_index]] = 2.0\n    return priorities",
    "response_id": 14,
    "tryHS": true,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 20.89735285398626,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response16.txt_stdout.txt",
    "code_path": "problem_iter1_code16.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    possible_bins = bins_remain_cap[bins_remain_cap >= item]\n    if len(possible_bins) == 0:\n        return np.zeros_like(bins_remain_cap)\n    \n    sigmoid_scores = 1 / (1 + np.exp(-(possible_bins - item) / (np.std(bins_remain_cap) + 1e-6)))\n    \n    priorities = np.zeros_like(bins_remain_cap)\n    \n    sorted_indices = np.argsort(bins_remain_cap)\n    \n    count = 0\n    for i in sorted_indices:\n        if bins_remain_cap[i] >= item:\n            priorities[i] = sigmoid_scores[count]\n            count += 1\n            \n    return priorities",
    "response_id": 16,
    "tryHS": false,
    "obj": 4.497407259672929,
    "SLOC": 13.0,
    "cyclomatic_complexity": 4.0,
    "halstead": 127.37720526058406,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response25.txt_stdout.txt",
    "code_path": "problem_iter1_code25.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return np.zeros_like(bins_remain_cap)\n    \n    distances = bins_remain_cap[valid_bins] - item\n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[valid_bins] = 1.0 / (distances + 1e-6)\n    return priorities",
    "response_id": 25,
    "tryHS": false,
    "obj": 4.198244914240141,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 51.80615605397529,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response26.txt_stdout.txt",
    "code_path": "problem_iter1_code26.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Sigmoid Fit Score.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n    \n    fit_scores = (bins_remain_cap[possible_bins] - item) / bins_remain_cap[possible_bins]\n    sigmoid_scores = 1 / (1 + np.exp(-5 * (fit_scores - 0.5)))\n    \n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[possible_bins] = sigmoid_scores\n    \n    return priorities",
    "response_id": 26,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 109.80793556946902,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response28.txt_stdout.txt",
    "code_path": "problem_iter1_code28.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    possible_bins = bins_remain_cap[bins_remain_cap >= item]\n    if len(possible_bins) == 0:\n        return np.zeros_like(bins_remain_cap)\n    \n    priorities = np.zeros_like(bins_remain_cap)\n    for i in range(len(bins_remain_cap)):\n        if bins_remain_cap[i] >= item:\n            priorities[i] = (bins_remain_cap[i] - item) / bins_remain_cap[i] \n    \n    return priorities",
    "response_id": 28,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 9.0,
    "cyclomatic_complexity": 4.0,
    "halstead": 53.77443751081735,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response0.txt_stdout.txt",
    "code_path": "problem_iter2_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines best-fit (reciprocal of waste) with a validity check.\n    Prioritizes bins that fit the item and minimize remaining space.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if np.sum(valid_bins) == 0:\n        return priorities\n    priorities[valid_bins] = 1.0 / (bins_remain_cap[valid_bins] - item + 1e-6)\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.198244914240141,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 57.110323830864054,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response3.txt_stdout.txt",
    "code_path": "problem_iter2_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with reciprocal waste for improved bin packing.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return priorities\n    waste = bins_remain_cap[valid_bins] - item\n    priorities[valid_bins] = 1.0 / (waste + 1e-9)\n    fit_scores = (bins_remain_cap[valid_bins] - item) / bins_remain_cap[valid_bins]\n    sigmoid_scores = 1 / (1 + np.exp(-5 * (fit_scores - 0.5)))\n    priorities[valid_bins] = priorities[valid_bins] * sigmoid_scores\n    return priorities",
    "response_id": 3,
    "tryHS": true,
    "obj": 4.198244914240141,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 175.93083758004835,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response4.txt_stdout.txt",
    "code_path": "problem_iter2_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit and reciprocal waste to prioritize bins.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    suitable_bins = bins_remain_cap >= item\n    if np.any(suitable_bins):\n        waste = bins_remain_cap[suitable_bins] - item\n        min_waste = np.min(waste)\n        priorities[suitable_bins] = 1.0 / (waste + 1e-6)\n        best_fit_index = np.argmin(waste)\n        priorities[suitable_bins] = np.where(np.arange(len(suitable_bins)) == best_fit_index,\n                                            priorities[suitable_bins] + 1.0,\n                                            priorities[suitable_bins])\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 70.32403072095333,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response5.txt_stdout.txt",
    "code_path": "problem_iter2_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines best-fit (v0) with reciprocal waste (v1) for improved bin packing.\n    Prioritizes tightest fit among valid bins.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    feasible_bins = bins_remain_cap >= item\n    if not np.any(feasible_bins):\n        return priorities\n\n    waste = bins_remain_cap[feasible_bins] - item\n    priorities[feasible_bins] = 1.0 / (waste + 1e-6)\n\n    best_fit_index = np.argmin(bins_remain_cap[feasible_bins] - item)\n    priorities[np.where(feasible_bins)[0][best_fit_index]] = 2.0\n    return priorities",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 64.72503367497926,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response6.txt_stdout.txt",
    "code_path": "problem_iter2_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit and reciprocal waste for improved bin packing priority.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return priorities\n    \n    waste = bins_remain_cap[valid_bins] - item\n    priorities[valid_bins] = 1.0 / (waste + 1e-9) + 1.0 / (bins_remain_cap[valid_bins] + 1e-9)\n    return priorities",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.198244914240141,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 94.01164534875782,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response0.txt_stdout.txt",
    "code_path": "problem_iter3_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    feasible_bins = bins_remain_cap >= item\n    if not np.any(feasible_bins):\n        return priorities\n    \n    bin_utilizations = bins_remain_cap[feasible_bins] / bins_remain_cap[feasible_bins].max()\n    \n    sigmoid_scores = 1 / (1 + np.exp(-5 * (bin_utilizations - 0.5)))\n    \n    fit_scores = (bins_remain_cap[feasible_bins] - item) / item\n    \n    combined_scores = sigmoid_scores * fit_scores\n    \n    priorities[feasible_bins] = combined_scores\n    \n    best_bin_index = np.argmax(priorities[feasible_bins])\n    \n    best_bin_idx_original = np.where(feasible_bins)[0][best_bin_index]\n    \n    priorities[best_bin_idx_original] = 2.0\n    \n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 40.59633027522938,
    "SLOC": 14.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 142.13383752235586,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response1.txt_stdout.txt",
    "code_path": "problem_iter3_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    feasible_bins = bins_remain_cap >= item\n    if not np.any(feasible_bins):\n        return priorities\n    \n    fill_ratios = bins_remain_cap[feasible_bins] / bins_remain_cap[feasible_bins].max()\n    \n    sigmoid_scores = 1 / (1 + np.exp(-5 * (fill_ratios - 0.5)))\n    \n    fit_diffs = bins_remain_cap[feasible_bins] - item\n    \n    best_fit_index = np.argmin(fit_diffs)\n    \n    priorities[feasible_bins] = sigmoid_scores\n    priorities[np.where(feasible_bins)[0][best_fit_index]] += 1.0\n    \n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 124.86408532184433,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response2.txt_stdout.txt",
    "code_path": "problem_iter3_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    feasible_bins = bins_remain_cap >= item\n    if not np.any(feasible_bins):\n        return priorities\n    \n    bin_utilizations = bins_remain_cap[feasible_bins] / bins_remain_cap[feasible_bins]\n    \n    sigmoid_scores = 1 / (1 + np.exp(-5 * (bin_utilizations - 0.5)))\n    \n    fit_scores = (bins_remain_cap[feasible_bins] - item) / item\n    \n    combined_scores = 0.6 * sigmoid_scores + 0.4 * fit_scores\n    \n    priorities[feasible_bins] = combined_scores\n    \n    best_bin_index = np.argmax(priorities[feasible_bins])\n    \n    best_bin_overall_index = np.where(feasible_bins)[0][best_bin_index]\n    \n    priorities[best_bin_overall_index] = 2.0\n    \n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 22.636617471080974,
    "SLOC": 14.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 177.87213211613133,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response3.txt_stdout.txt",
    "code_path": "problem_iter3_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    feasible_bins = bins_remain_cap >= item\n    if not np.any(feasible_bins):\n        return priorities\n    \n    bin_utilizations = bins_remain_cap[feasible_bins] / bins_remain_cap[feasible_bins]\n    \n    scores = np.zeros_like(bins_remain_cap[feasible_bins])\n    \n    for i, cap in enumerate(bins_remain_cap[feasible_bins]):\n        \n        fit = item / cap\n        \n        if fit <= 0.5:\n            scores[i] = 1.0 + (1.0 - fit) * 0.5\n        elif fit <= 0.9:\n            scores[i] = 0.5 + (1.0 - fit) * 0.2\n        else:\n            scores[i] = 0.1\n            \n    best_bin_index = np.argmax(scores)\n    \n    priorities[feasible_bins] = scores\n    priorities[np.where(feasible_bins)[0][best_bin_index]] = scores[best_bin_index] + 1.0\n\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 20.971280414838446,
    "SLOC": 19.0,
    "cyclomatic_complexity": 5.0,
    "halstead": 171.8953543301665,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response4.txt_stdout.txt",
    "code_path": "problem_iter3_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    feasible_bins = bins_remain_cap >= item\n    if not np.any(feasible_bins):\n        return priorities\n    \n    bin_utilizations = bins_remain_cap[feasible_bins] / bins_remain_cap[feasible_bins].max()\n    \n    scores = 1.0 / (1.0 + np.exp(-5 * (bin_utilizations - 0.5)))\n    \n    priorities[feasible_bins] = scores\n    \n    best_fit_index = np.argmin(bins_remain_cap[feasible_bins] - item)\n    priorities[feasible_bins][best_fit_index] += 1.5\n    \n    \n    \n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 126.65973476959637,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response0.txt_stdout.txt",
    "code_path": "problem_iter4_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, weight_one: float = 4.0812197907178795, weight_best_fit: float = 8.716655398841299) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    feasible_bins = bins_remain_cap >= item\n    if np.any(feasible_bins):\n        best_fit_index = np.argmin(bins_remain_cap[feasible_bins] - item)\n        priorities[feasible_bins] = weight_one\n        priorities[np.where(bins_remain_cap >= item)[0][best_fit_index]] = weight_best_fit\n    return priorities",
    "response_id": 0,
    "tryHS": true,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 20.89735285398626,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response1.txt_stdout.txt",
    "code_path": "problem_iter5_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with a scaled fill ratio to prioritize bins.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return priorities\n\n    distances = bins_remain_cap[valid_bins] - item\n    best_fit_index = np.argmin(distances)\n    \n    fill_ratios = bins_remain_cap[valid_bins] / np.max(bins_remain_cap)\n    \n    priorities[valid_bins] = 1.0 / (distances + 1e-6) * (1 + np.tanh(fill_ratios - 0.5))\n    \n    priorities[np.where(valid_bins)[0][best_fit_index]] *= 2.0\n    \n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.198244914240141,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 131.18329672565338,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response3.txt_stdout.txt",
    "code_path": "problem_iter5_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit and waste minimization with a sigmoid scaling.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    feasible_bins = bins_remain_cap >= item\n    if not np.any(feasible_bins):\n        return priorities\n\n    waste = bins_remain_cap[feasible_bins] - item\n    reciprocal_waste = 1.0 / (waste + 1e-6)\n    fit_scores = item / bins_remain_cap[feasible_bins]\n    sigmoid_scores = 1.0 / (1.0 + np.exp(-5 * (1.0 - fit_scores)))\n    scores = 0.6 * reciprocal_waste + 0.4 * sigmoid_scores\n    best_bin_index = np.argmax(scores)\n    priorities[feasible_bins] = scores\n    priorities[np.where(feasible_bins)[0][best_bin_index]] = scores[best_bin_index] + 1.0\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 40.05783805345035,
    "SLOC": 14.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 208.89318279048564,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response6.txt_stdout.txt",
    "code_path": "problem_iter8_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with sigmoid-scaled bin fill ratio for smoother prioritization.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return priorities\n    distances = bins_remain_cap[valid_bins] - item\n    fit_scores = 1.0 / (1.0 + distances)\n    bin_utilizations = 1.0 - (bins_remain_cap[valid_bins] - item) / bins_remain_cap[valid_bins]\n    sigmoid_scores = 1.0 / (1.0 + np.exp(-5.0 * (bin_utilizations - 0.5)))\n    combined_scores = 0.7 * sigmoid_scores + 0.3 * fit_scores\n    priorities[valid_bins] = combined_scores\n    return priorities",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 227.8930302777963,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response5.txt_stdout.txt",
    "code_path": "problem_iter5_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines reciprocal waste (v0) with a sigmoid-based fit score (v1).\"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return priorities\n\n    waste = bins_remain_cap[valid_bins] - item\n    fit = item / bins_remain_cap[valid_bins]\n    sigmoid_score = 1.0 / (1.0 + np.exp(-5 * (fit - 0.5)))\n    priorities[valid_bins] = 1.0 / (waste + 1e-9) + sigmoid_score * 0.5\n    return priorities",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.198244914240141,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 173.91626957122043,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response6.txt_stdout.txt",
    "code_path": "problem_iter5_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines reciprocal waste (v0) with a sigmoid-scaled best fit (v6) for improved bin selection.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    suitable_bins = bins_remain_cap >= item\n    if np.any(suitable_bins):\n        waste = bins_remain_cap[suitable_bins] - item\n        priorities[suitable_bins] = 1.0 / (waste + 1e-6)\n        \n        fill_ratios = (bins_remain_cap[suitable_bins] - item) / bins_remain_cap[suitable_bins]\n        sigmoid_scores = 1.0 / (1.0 + np.exp(-5 * (fill_ratios - 0.5)))\n        \n        best_fit_index = np.argmin(waste)\n        priorities[suitable_bins] = np.where(np.arange(len(suitable_bins)) == best_fit_index,\n                                             priorities[suitable_bins] + sigmoid_scores,\n                                             priorities[suitable_bins])\n    return priorities",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.198244914240141,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 182.67948703818894,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response7.txt_stdout.txt",
    "code_path": "problem_iter5_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with a sigmoid function to prioritize bins.\"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n    remaining_capacities = bins_remain_cap[possible_bins]\n    fit_scores = 1.0 / (1.0 + np.exp(-5 * (remaining_capacities - item)))\n    bin_utilizations = bins_remain_cap[possible_bins] / bins_remain_cap[possible_bins].max()\n    sigmoid_scores = 1 / (1 + np.exp(-5 * (bin_utilizations - 0.5)))\n    combined_scores = fit_scores * sigmoid_scores\n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[possible_bins] = combined_scores\n    return priorities",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 185.4406125843753,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response9.txt_stdout.txt",
    "code_path": "problem_iter5_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with a sigmoid function based on bin fill ratio.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    feasible_bins = bins_remain_cap >= item\n    if not np.any(feasible_bins):\n        return priorities\n\n    bin_utilizations = bins_remain_cap[feasible_bins] / bins_remain_cap[feasible_bins]\n    sigmoid_scores = 1 / (1 + np.exp(-5 * (bin_utilizations - 0.5)))\n    fit_scores = (bins_remain_cap[feasible_bins] - item) / item\n    combined_scores = 0.7 * sigmoid_scores + 0.3 * fit_scores\n    priorities[feasible_bins] = combined_scores\n    return priorities",
    "response_id": 9,
    "tryHS": false,
    "obj": 22.008376545672125,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 177.87213211613133,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response1.txt_stdout.txt",
    "code_path": "problem_iter6_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    feasible_bins = bins_remain_cap >= item\n    if not np.any(feasible_bins):\n        return priorities\n    \n    remaining_capacities = bins_remain_cap[feasible_bins]\n    \n    \n    fit_scores = 1.0 / (remaining_capacities - item + 1e-6)\n    \n    \n    avg_remaining = np.mean(bins_remain_cap[feasible_bins])\n    \n    \n    exploration_bonus = np.where(bins_remain_cap > avg_remaining, 0.5, 0.0)\n    \n    \n    priorities[feasible_bins] = fit_scores + exploration_bonus\n    \n    \n    best_bin_index = np.argmax(priorities[feasible_bins])\n    \n    priorities[feasible_bins] = np.where(np.arange(len(feasible_bins)) == best_bin_index, 2.0, 1.0)\n    \n    \n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.198244914240141,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 99.40434618240934,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response3.txt_stdout.txt",
    "code_path": "problem_iter6_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    feasible_bins = bins_remain_cap >= item\n    if not np.any(feasible_bins):\n        return priorities\n\n    num_feasible = np.sum(feasible_bins)\n    \n    if num_feasible == 1:\n        priorities[feasible_bins] = 2.0\n        return priorities\n\n    best_fit_index = np.argmin(bins_remain_cap[feasible_bins] - item)\n    \n    priorities[feasible_bins] = 1.0\n    priorities[np.where(feasible_bins)[0][best_fit_index]] = 2.0\n\n    \n    worst_fit_index = np.argmax(bins_remain_cap[feasible_bins] - item)\n    \n    if np.random.rand() < 0.1:\n        priorities[feasible_bins] = 0.0\n        priorities[np.where(feasible_bins)[0][worst_fit_index]] = 1.0\n    \n    \n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.098524132429212,
    "SLOC": 17.0,
    "cyclomatic_complexity": 4.0,
    "halstead": 64.72503367497926,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response4.txt_stdout.txt",
    "code_path": "problem_iter6_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    feasible_bins = bins_remain_cap >= item\n    if not np.any(feasible_bins):\n        return priorities\n    \n    sorted_bins = np.argsort(bins_remain_cap[feasible_bins])\n    \n    \n    best_fit_index = sorted_bins[0]\n    \n    \n    priorities[feasible_bins] = 0.5\n    priorities[np.where(bins_remain_cap >= item)[0][best_fit_index]] = 1.0\n    \n    \n    second_best_index = sorted_bins[min(1, len(sorted_bins)-1)]\n    priorities[np.where(bins_remain_cap >= item)[0][second_best_index]] = 0.75\n\n    \n    \n    \n    \n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 42.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter7_response0.txt_stdout.txt",
    "code_path": "problem_iter7_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray,\n                epsilon: float = 1.9097344053642677e-07,\n                sigmoid_weight: float = 9.497407494184952,\n                sigmoid_threshold: float = 0.522265042161531) -> np.ndarray:\n    \"\"\"Combines best-fit with reciprocal waste for improved bin packing.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return priorities",
    "response_id": 0,
    "tryHS": true,
    "obj": 4.487435181491823,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 11.60964047443681,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response3.txt_stdout.txt",
    "code_path": "problem_iter8_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with a sigmoid-based fill ratio prioritization.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    feasible_bins = bins_remain_cap >= item\n    if not np.any(feasible_bins):\n        return priorities\n    \n    fill_ratios = (bins_remain_cap[feasible_bins] - item) / bins_remain_cap[feasible_bins]\n    \n    priorities[feasible_bins] = 1.0 / (1 + np.exp(-5 * (0.5 - fill_ratios)))\n    \n    best_fit_index = np.argmin(bins_remain_cap[feasible_bins] - item)\n    priorities[feasible_bins] = 0.0\n    priorities[np.where(feasible_bins)[0][best_fit_index]] = 2.0\n    \n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 124.86408532184433,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response5.txt_stdout.txt",
    "code_path": "problem_iter8_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with a smoothed prioritization based on fill ratio.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    feasible_bins = bins_remain_cap >= item\n    if not np.any(feasible_bins):\n        return priorities\n\n    fill_ratios = (bins_remain_cap[feasible_bins] - item) / bins_remain_cap[feasible_bins]\n    priorities[feasible_bins] = 1.0 / (fill_ratios + 1e-6)\n    best_fit_index = np.argmin(fill_ratios)\n    priorities[feasible_bins] = 0.0\n    priorities[np.where(feasible_bins)[0][best_fit_index]] = 2.0\n    return priorities",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 66.41714012534482,
    "exec_success": true
  }
]