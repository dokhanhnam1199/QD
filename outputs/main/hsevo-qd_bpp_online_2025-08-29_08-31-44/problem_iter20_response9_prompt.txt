{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code only and do not add comments into the code. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    feasible_bins = bins_remain_cap >= item\n    if not np.any(feasible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    best_fit_scores = 1.0 / (bins_remain_cap[feasible_bins] - item + 1e-6)\n    utilization_scores = bins_remain_cap[feasible_bins] / np.max(bins_remain_cap)\n\n    combined_scores = best_fit_scores + utilization_scores\n\n    def sigmoid(x):\n        return 1 / (1 + np.exp(-x))\n\n    priorities = np.zeros_like(bins_remain_cap)\n    if np.any(feasible_bins):\n        scaled_scores = sigmoid(combined_scores)\n        priorities[feasible_bins] = scaled_scores\n        best_bin_index = np.argmax(scaled_scores)\n        priorities[np.where(feasible_bins)[0][best_bin_index]] += 0.5\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Combines best-fit with a sigmoid function to prioritize bins.\"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n    remaining_capacities = bins_remain_cap[possible_bins]\n    fit_scores = 1.0 / (1.0 + np.exp(-5 * (remaining_capacities - item)))\n    bin_utilizations = bins_remain_cap[possible_bins] / bins_remain_cap[possible_bins].max()\n    sigmoid_scores = 1 / (1 + np.exp(-5 * (bin_utilizations - 0.5)))\n    combined_scores = fit_scores * sigmoid_scores\n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[possible_bins] = combined_scores\n    return priorities\n\n### Analyze & experience\n- Comparing heuristics 1st vs 2nd, the 1st uses a sigmoid function to prioritize based on fill ratio *before* applying best-fit, resulting in a smoother prioritization. The 2nd is a very basic best-fit and lacks any nuance.  Comparing 1st vs 3rd, the 3rd normalizes fill ratios and adds them to fit differences, but lacks the smoothing effect of the sigmoid.  Comparing 3rd vs 4th, both combine best-fit with waste, but 4th's simple reciprocal waste is less adaptable than 3rd\u2019s fill ratio approach.\n\nComparing 4th vs 5th, they are identical. Heuristics 6th-10th build upon the waste/fit combination, adding variations in weighting and sigmoid scaling, but often with less clear rationale. Heuristics 11th-13th are very similar to earlier approaches, adding slight modifications to the scoring. Heuristics 14th-17th generally show improvement over earlier heuristics with combinations of fit and utilization with sigmoid. Heuristics 18th-20th introduce smoothing with sigmoid function that appears to perform well. \n\nThe 1st heuristic\u2019s prioritization based on fill ratio before applying best fit seems a strong strategy. The best heuristics (1st, 14th, 18th, 20th) consistently utilize sigmoid functions to smooth the prioritization, suggesting that handling extreme values in fit or utilization scores is important.  The consistent use of `1e-6` or `1e-9` to avoid division by zero is good practice.  Heuristics 12th is a minimal/incomplete example.\n\nOverall: The most successful heuristics combine best-fit with some measure of bin utilization or waste, and importantly, smooth the prioritization using a sigmoid function. Initial prioritization by fill ratio before best-fit search also seems beneficial.\n- \nOkay, here\u2019s a refined self-reflection framework aimed at designing superior heuristics, geared toward earning that $999K tip!\n\n* **Keywords:** Smooth prioritization, utilization, balance (exploitation/exploration), robustness.\n* **Advice:** Prioritize *smooth*, sigmoid-scaled combinations of best-fit *and* bin utilization (fill ratio). Focus on minimizing waste as the core objective, dynamically adjusting prioritization based on item/bin characteristics.\n* **Avoid:** Complex weighting, arbitrary bonuses, normalization (unless demonstrably beneficial), focusing solely on worst-case scenarios, and rigid, discrete priority schemes.\n* **Explanation:** Heuristics thrive on balance. Sigmoids prevent overreaction to minor differences, creating robust prioritization. Combining fit *with* utilization guides towards globally efficient packing, not just locally optimal choices.\n\n\n\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}