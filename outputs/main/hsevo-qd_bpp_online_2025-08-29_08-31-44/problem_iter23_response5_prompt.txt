{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code only and do not add comments into the code. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    num_bins = len(bins_remain_cap)\n    priorities = np.zeros(num_bins)\n    feasible_bins = bins_remain_cap >= item\n    \n    if not np.any(feasible_bins):\n        return priorities\n    \n    fit_scores = 1.0 / (bins_remain_cap[feasible_bins] - item + 1e-6)\n    utilization_scores = bins_remain_cap[feasible_bins] / np.max(bins_remain_cap)\n    \n    smooth_fit = 1.0 / (1.0 + np.exp(-fit_scores * 5.0))\n    smooth_util = 1.0 / (1.0 + np.exp(-utilization_scores * 5.0))\n    \n    combined_scores = 0.6 * smooth_fit + 0.4 * smooth_util\n    \n    priorities[feasible_bins] = combined_scores\n    \n    best_bin_index = np.argmax(priorities[feasible_bins])\n    \n    priorities[np.where(feasible_bins)[0][best_bin_index]] += 1.0\n    \n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Combines sigmoid fit score with a reciprocal waste component.\"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n    \n    fit_scores = (bins_remain_cap[possible_bins] - item) / bins_remain_cap[possible_bins]\n    sigmoid_scores = 1 / (1 + np.exp(-5 * (fit_scores - 0.5)))\n    \n    waste_scores = 1 / (item + 1e-6)\n    \n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[possible_bins] = 0.7 * sigmoid_scores + 0.3 * waste_scores\n    \n    return priorities\n\n### Analyze & experience\n- Comparing heuristics 1st vs 2nd, the 1st is simpler, focusing on best & second best fit with fixed priorities. The 2nd is more complex, introducing a smoothed utilization score (sigmoid) alongside reciprocal waste, aiming for robustness. 1st lacks adaptive weighting. Comparing 2nd vs 3rd, 3rd is just a simplified version of 1st, removing any improvements 2nd brought. Comparing 1st vs 3rd, 1st is slightly better due to providing a second best option.\n\nComparing 4th vs 5th, they are identical. Comparing 4th/5th vs 6th, 6th employs a logarithmic transformation of fit score and a more direct weighting, attempting to refine the best-fit prioritization, while 4th/5th are less direct. Comparing 6th vs 7th, 7th reintroduces the sigmoid, adding complexity without clear benefit over 6th.\n\nComparing 8th/9th (identical) vs 10th/11th (identical), 8th/9th combine smoothed fit and utilization, but weighting towards fit (0.6). 10th/11th introduce an exploration bonus based on exceeding average remaining capacity, potentially aiding in delaying fragmentation. 8th/9th is superior in consistently applying principles.\n\nComparing 12th vs 13th/14th/15th, 12th is the most concise\u2014direct reciprocal waste. 13th is minimal (returns zeros). 14th/15th attempt combined sigmoid & fit scores, but are more convoluted. 12th's simplicity is an asset.\n\nComparing 16th vs 17th, 16th combines sigmoid and waste scores with weights, offering more nuance than 17th\u2019s basic fill ratio. 17th\u2019s linear fill ratio is less effective. 18th is unnecessarily complex with imports. 19th combines sigmoid with fit score, but less clearly defined weighting. 20th uses a similar structure to 19th.\n\nOverall: The best heuristics (1st, 2nd, 6th, 8th/9th, 12th, 16th) effectively combine best-fit principles with elements to improve bin utilization or prevent fragmentation. The worst (13th, 17th, 18th) are either minimal or overly complex with little justification. Sigmoid functions generally improve outcomes when combined with other metrics, but require careful weighting.\n- \nOkay, here's a breakdown to redefine \"Current Self-Reflection\" for superior heuristic design, aiming for that $999K tip!\n\n* **Keywords:** Simplicity, Smoothness, Utilization, Best-Fit.\n* **Advice:** Focus on combining best-fit *with* a utilization score (bin fill ratio). Use sigmoid functions to *smooth* the resulting priorities\u2014this avoids harsh jumps. Prioritize clear, explainable weighting.\n* **Avoid:** Complex calculations, arbitrary weights, reciprocal calculations (unless *very* carefully considered), and normalization if avoidable. Don\u2019t chase worst-case performance.\n* **Explanation:** Effective heuristics aren\u2019t about perfect solutions, but *consistently good* ones. Smooth prioritization via sigmoids, built on a solid best-fit/utilization foundation, delivers robust, understandable results.\n\n\n\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}