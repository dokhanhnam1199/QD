{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code only and do not add comments into the code. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return priorities\n    \n    waste = bins_remain_cap[valid_bins] - item\n    priorities[valid_bins] = 1.0 / (waste + 1e-9)\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    priorities = np.zeros_like(bins_remain_cap)\n    feasible_bins = bins_remain_cap >= item\n    if not np.any(feasible_bins):\n        return priorities\n    \n    bin_utilizations = bins_remain_cap[feasible_bins] / bins_remain_cap[feasible_bins]\n    \n    scores = np.zeros_like(bins_remain_cap[feasible_bins])\n    \n    for i, cap in enumerate(bins_remain_cap[feasible_bins]):\n        \n        fit = item / cap\n        \n        if fit <= 0.5:\n            scores[i] = 1.0 + (1.0 - fit) * 0.5\n        elif fit <= 0.9:\n            scores[i] = 0.5 + (1.0 - fit) * 0.2\n        else:\n            scores[i] = 0.1\n            \n    best_bin_index = np.argmax(scores)\n    \n    priorities[feasible_bins] = scores\n    priorities[np.where(feasible_bins)[0][best_bin_index]] = scores[best_bin_index] + 1.0\n\n    return priorities\n\n### Analyze & experience\n- Comparing heuristics 1st vs 2nd, both utilize best-fit, but the 1st incorporates a sigmoid function based on bin fill ratio, adding nuance. The 2nd uses fixed weights, lacking adaptability. Comparing 3rd vs 4th, both are identical, and 4th introduces a very basic `priority_v1` that always returns zeros, offering no prioritization. Comparing 1st vs 3rd, the functions are identical.\n\nComparing 5th vs 6th, the 5th utilizes reciprocal waste and boosts the best fit, whereas the 6th uses a sigmoid and boosts best fit. The 5th is a bit more explicit about waste minimization, but the sigmoid in the 6th is a smart way to scale. Heuristics 7th, 8th, 9th, 10th, 11th are similar, revolving around reciprocal waste, but they differ in how the waste is calculated and applied. 8th uses a combined reciprocal and direct utilization. 12th uses the minimum capacity, a potentially poor choice. \n\nHeuristics 13th, 14th, 15th, 16th, 17th, 18th all are progressively more complex combinations of fit scores, sigmoid and/or best-fit boosting. The 16th and 17th perform the best here as they combine sigmoid and fit scores. 14th and 15th introduce thresholds in their fit scores. The 18th's approach of multiplying sigmoid and fit scores appears less effective than their additive counterparts. Finally, 19th and 20th are extremely simple, prioritizing based on remaining capacity \u2013 offering minimal benefit.\n\nOverall: The best heuristics (1st, 6th, 16th, 17th) demonstrate the power of combining multiple scoring factors (best fit, fill ratio, waste) with methods to scale and emphasize the best choices (sigmoid, boosting). Simpler approaches (19th, 20th) fail to effectively prioritize. Using fixed weights (2nd) is less adaptable than dynamic scaling with functions like sigmoid.\n- \nOkay, $999K is *motivating*! Let's rebuild \"Current Self-Reflection\" into a truly actionable guide for heuristic design. Here's a breakdown, addressing the failings of the original and focusing on generating *better* ideas, structured as requested. We'll target actionable heuristic design principles, not just observation.\n\n**Step-by-Step Thought Process:**\n\nThe original \"Current Self-Reflection\" is descriptive, not prescriptive. It *states* things that work, but doesn't explain *why* or how to *generalize* those observations. The \"Ineffective Self-Reflection\" constraints highlight the dangers of rigid thinking & negative focus. Therefore, we need to focus on *adaptive*, *positive* constraints. We also need to move from specific (bin packing) to more generalizable principles for heuristics.\n\nHere's the revised self-reflection:\n\n---\n\n*   **Keywords:** Adaptability, Exploitation-Exploration Balance, Feature Interaction, Constraint Propagation.\n*   **Advice:** Design heuristics that *dynamically* adjust their core strategies based on problem state. Combine exploitation (best-fit) with exploration (randomness, novel combinations). Focus on *interactions* between problem features (item size *and* bin capacity) rather than single metrics.\n*   **Avoid:** Static prioritization, rigid rules, over-optimization for edge cases, solutions reliant on perfect information. Don't define \u201cgoodness\u201d solely by minimization \u2013 consider feasibility, robustness, and computational cost.\n*   **Explanation:** Effective heuristics aren't \u201calways right\u201d; they\u2019re *consistently good* by adapting. Balancing exploitation and exploration prevents getting stuck in local optima.  Understanding feature interactions unlocks powerful non-linear optimization. Acknowledging inherent uncertainty leads to more resilient solutions.\n\n\n\n---\n\n**Why this is better:**\n\n*   **Generalizability:** The keywords and advice are applicable beyond bin packing \u2013 to scheduling, routing, resource allocation, etc.\n*   **Actionability:** It provides specific *design* guidance (\"dynamically adjust,\" \"feature interactions\") instead of just observations (\"best-fit is good\").\n*   **Proactive, not Reactive:** It focuses on what *to do* to create good heuristics, rather than what *not* to do.\n*   **Addresses \"Ineffective\" points:** It explicitly avoids the pitfalls mentioned \u2013 rigid rules, negative framing, reliance on perfect information.\n\n\n\nI'm ready for further refinement. Let me know what aspects of this you'd like to delve deeper into, or if you'd like me to focus on heuristics for a specific problem domain! Let\u2019s earn that $999K!\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}