{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code only and do not add comments into the code. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    priorities = np.zeros_like(bins_remain_cap)\n    feasible_bins = bins_remain_cap >= item\n    if np.any(feasible_bins):\n        best_fit_index = np.argmin(bins_remain_cap[feasible_bins] - item)\n        priorities[feasible_bins] = 1.0\n        priorities[np.where(feasible_bins)[0][best_fit_index]] = 2.0\n        \n        bin_utilizations = (bins_remain_cap - item) / bins_remain_cap\n        bin_utilizations[~feasible_bins] = 0.0\n        \n        sigmoid_values = 1 / (1 + np.exp(-5 * (bin_utilizations - 0.5)))\n        \n        priorities = priorities + 0.5 * sigmoid_values\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\n    possible_bins = bins_remain_cap[bins_remain_cap >= item]\n    if len(possible_bins) == 0:\n        return np.zeros_like(bins_remain_cap)\n    \n    priorities = np.zeros_like(bins_remain_cap)\n    for i in range(len(bins_remain_cap)):\n        if bins_remain_cap[i] >= item:\n            priorities[i] = (bins_remain_cap[i] - item) / bins_remain_cap[i] \n    \n    return priorities\n\n### Analyze & experience\n- Comparing heuristics 1st vs 2nd, both combine best-fit with smoothed prioritization, but the 1st uses a sigmoid on fill ratios, focusing on how *full* bins will be *after* placement, while the 2nd uses reciprocal waste and a sigmoid on overall fill ratios. The 1st appears more targeted at minimizing fragmentation by prioritizing bins that will be closer to full after the item is placed.\n\nComparing heuristics 3rd vs 4th, both use a sigmoid on utilization, but 3rd applies it to the remaining capacity, while 4th directly combines fit score and utilization with a sigmoid. 4th appears more complex, attempting a weighted average.\n\nComparing 1st vs 3rd, the 1st's fill ratio approach seems cleaner and more directly addresses packing density. The 3rd's utilization calculation seems less directly relevant to the immediate packing decision.\n\nComparing 5th vs 6th, both are similar - sigmoid smoothing of fill ratios/waste. However 5th normalizes fill ratios and 6th uses max capacity. 6th is better because it uses max capacity for normalization.\n\nComparing 7th vs 8th, 7th focuses solely on reciprocal waste while 8th introduces randomness and attempts to penalize worst-fit. 7th is simpler and more consistent.\n\nComparing 9th vs 10th, both combine fit and utilization with sigmoid scaling. 10th is better as it has more balanced weights between sigmoid score and reciprocal waste.\n\nHeuristics 11th, 12th, 13th, 14th, 15th, 17th, 18th and 20th are largely ineffective or overly simplistic, often only returning a base priority or failing to effectively consider bin utilization. Heuristics 16th and 19th are duplicates.\n\nOverall: The best heuristics (1st - 4th) prioritize a balance between best-fit and utilization, often leveraging sigmoid functions for smoothing and prioritization. The consistent theme is favoring bins that will result in higher overall density.  Later heuristics tend to be either too simplistic or add complexity without clear benefits.  The use of reciprocal waste is common, and combining it with utilization scores, smoothed by a sigmoid, seems to yield the best results.\n- \nOkay, here's a breakdown for designing superior heuristics, aiming for that $999K tip! This is built from distilling the provided self-reflection, focusing on actionable guidance.\n\n*   **Keywords:** Best-Fit, Bin Utilization, Sigmoid Smoothing, Simplicity.\n*   **Advice:** Combine best-fit placement *with* a utilization score (fill ratio/waste). Employ sigmoid functions to smooth this utilization score into a prioritization value. Prioritize clear, direct optimization of fill ratio post-placement.\n*   **Avoid:** Complex weighting schemes, arbitrary bonuses, normalization *unless* essential, worst-case focus, and unnecessary calculations/imports.\n*   **Explanation:** Effective heuristics aren\u2019t about perfect theoretical complexity; they\u2019re about robust, practical performance. Prioritizing a good initial fit (best-fit) and then *smoothly* refining it with bin utilization maximizes packing efficiency without oversensitivity. Simplicity aids interpretability & generalization.\n\n\n\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}