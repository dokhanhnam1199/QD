[
  {
    "stdout_filepath": "problem_iter0_stdout0.txt",
    "code_path": "problem_iter0_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities",
    "response_id": 0,
    "obj": 4.487435181491823,
    "SLOC": 3.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 0.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response7.txt_stdout.txt",
    "code_path": "problem_iter1_code7.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if np.sum(valid_bins) == 0:\n        return priorities\n    \n    priorities[valid_bins] = 1.0 / (bins_remain_cap[valid_bins] - item + 1e-6)\n    \n    return priorities",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.198244914240141,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 57.110323830864054,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response1.txt_stdout.txt",
    "code_path": "problem_iter1_code1.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return priorities\n    \n    waste = bins_remain_cap[valid_bins] - item\n    priorities[valid_bins] = 1.0 / (waste + 1e-9)\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.198244914240141,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 51.80615605397529,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response4.txt_stdout.txt",
    "code_path": "problem_iter1_code4.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    suitable_bins = bins_remain_cap >= item\n    if np.any(suitable_bins):\n        min_waste = np.min(bins_remain_cap[suitable_bins] - item)\n        priorities[suitable_bins] = 1.0 / (min_waste + 1e-6)\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 41.51317942364757,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response6.txt_stdout.txt",
    "code_path": "problem_iter1_code6.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    remaining_capacities = bins_remain_cap[possible_bins]\n    fit_scores = 1.0 / (1.0 + np.exp(-5 * (remaining_capacities - item)))\n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[possible_bins] = fit_scores\n    return priorities",
    "response_id": 6,
    "tryHS": false,
    "obj": 13.40247307538892,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 77.66179398375645,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response9.txt_stdout.txt",
    "code_path": "problem_iter1_code9.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    temp = bins_remain_cap - item\n    priorities = np.where(temp >= 0, np.exp(temp / (item + 1e-6)), 0)\n    priorities = priorities / np.sum(priorities)\n    return priorities",
    "response_id": 9,
    "tryHS": false,
    "obj": 149.30195452732352,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 53.77443751081735,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response12.txt_stdout.txt",
    "code_path": "problem_iter1_code12.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):\n        worst_fit_capacity = np.min(bins_remain_cap[valid_bins])\n        priorities[valid_bins] = worst_fit_capacity\n    return priorities",
    "response_id": 12,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 4.754887502163469,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response13.txt_stdout.txt",
    "code_path": "problem_iter1_code13.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            priorities[i] = cap - item\n        else:\n            priorities[i] = -1\n    return priorities",
    "response_id": 13,
    "tryHS": false,
    "obj": 149.30195452732352,
    "SLOC": 8.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 20.67970000576925,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response14.txt_stdout.txt",
    "code_path": "problem_iter1_code14.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    feasible_bins = bins_remain_cap >= item\n    if np.any(feasible_bins):\n        best_fit_index = np.argmin(bins_remain_cap[feasible_bins] - item)\n        priorities[feasible_bins] = 1.0\n        priorities[np.where(bins_remain_cap >= item)[0][best_fit_index]] = 2.0\n    return priorities",
    "response_id": 14,
    "tryHS": true,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 20.89735285398626,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response16.txt_stdout.txt",
    "code_path": "problem_iter1_code16.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    possible_bins = bins_remain_cap[bins_remain_cap >= item]\n    if len(possible_bins) == 0:\n        return np.zeros_like(bins_remain_cap)\n    \n    sigmoid_scores = 1 / (1 + np.exp(-(possible_bins - item) / (np.std(bins_remain_cap) + 1e-6)))\n    \n    priorities = np.zeros_like(bins_remain_cap)\n    \n    sorted_indices = np.argsort(bins_remain_cap)\n    \n    count = 0\n    for i in sorted_indices:\n        if bins_remain_cap[i] >= item:\n            priorities[i] = sigmoid_scores[count]\n            count += 1\n            \n    return priorities",
    "response_id": 16,
    "tryHS": true,
    "obj": 4.497407259672929,
    "SLOC": 13.0,
    "cyclomatic_complexity": 4.0,
    "halstead": 127.37720526058406,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response25.txt_stdout.txt",
    "code_path": "problem_iter1_code25.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return np.zeros_like(bins_remain_cap)\n    \n    distances = bins_remain_cap[valid_bins] - item\n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[valid_bins] = 1.0 / (distances + 1e-6)\n    return priorities",
    "response_id": 25,
    "tryHS": true,
    "obj": 4.198244914240141,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 51.80615605397529,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response26.txt_stdout.txt",
    "code_path": "problem_iter1_code26.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Sigmoid Fit Score.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n    \n    fit_scores = (bins_remain_cap[possible_bins] - item) / bins_remain_cap[possible_bins]\n    sigmoid_scores = 1 / (1 + np.exp(-5 * (fit_scores - 0.5)))\n    \n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[possible_bins] = sigmoid_scores\n    \n    return priorities",
    "response_id": 26,
    "tryHS": true,
    "obj": 4.487435181491823,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 109.80793556946902,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response28.txt_stdout.txt",
    "code_path": "problem_iter1_code28.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    possible_bins = bins_remain_cap[bins_remain_cap >= item]\n    if len(possible_bins) == 0:\n        return np.zeros_like(bins_remain_cap)\n    \n    priorities = np.zeros_like(bins_remain_cap)\n    for i in range(len(bins_remain_cap)):\n        if bins_remain_cap[i] >= item:\n            priorities[i] = (bins_remain_cap[i] - item) / bins_remain_cap[i] \n    \n    return priorities",
    "response_id": 28,
    "tryHS": true,
    "obj": 4.487435181491823,
    "SLOC": 9.0,
    "cyclomatic_complexity": 4.0,
    "halstead": 53.77443751081735,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response0.txt_stdout.txt",
    "code_path": "problem_iter2_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines best-fit (reciprocal of waste) with a validity check.\n    Prioritizes bins that fit the item and minimize remaining space.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if np.sum(valid_bins) == 0:\n        return priorities\n    priorities[valid_bins] = 1.0 / (bins_remain_cap[valid_bins] - item + 1e-6)\n    return priorities",
    "response_id": 0,
    "tryHS": true,
    "obj": 4.198244914240141,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 57.110323830864054,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter17_response1.txt_stdout.txt",
    "code_path": "problem_iter17_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with reciprocal waste and sigmoid smoothing.\"\"\"\n    n_bins = len(bins_remain_cap)\n    priorities = np.zeros(n_bins)\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return priorities\n    waste = bins_remain_cap[valid_bins] - item\n    priorities[valid_bins] = 1.0 / (waste + 1e-9)\n    fit_scores = (bins_remain_cap[valid_bins] - item) / bins_remain_cap[valid_bins]\n    sigmoid_scores = 1 / (1 + np.exp(-5 * (fit_scores - 0.5)))\n    priorities[valid_bins] = priorities[valid_bins] * sigmoid_scores\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 175.93083758004835,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response4.txt_stdout.txt",
    "code_path": "problem_iter2_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit and reciprocal waste to prioritize bins.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    suitable_bins = bins_remain_cap >= item\n    if np.any(suitable_bins):\n        waste = bins_remain_cap[suitable_bins] - item\n        min_waste = np.min(waste)\n        priorities[suitable_bins] = 1.0 / (waste + 1e-6)\n        best_fit_index = np.argmin(waste)\n        priorities[suitable_bins] = np.where(np.arange(len(suitable_bins)) == best_fit_index,\n                                            priorities[suitable_bins] + 1.0,\n                                            priorities[suitable_bins])\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 70.32403072095333,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response5.txt_stdout.txt",
    "code_path": "problem_iter2_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines best-fit (v0) with reciprocal waste (v1) for improved bin packing.\n    Prioritizes tightest fit among valid bins.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    feasible_bins = bins_remain_cap >= item\n    if not np.any(feasible_bins):\n        return priorities\n\n    waste = bins_remain_cap[feasible_bins] - item\n    priorities[feasible_bins] = 1.0 / (waste + 1e-6)\n\n    best_fit_index = np.argmin(bins_remain_cap[feasible_bins] - item)\n    priorities[np.where(feasible_bins)[0][best_fit_index]] = 2.0\n    return priorities",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 64.72503367497926,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response6.txt_stdout.txt",
    "code_path": "problem_iter2_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit and reciprocal waste for improved bin packing priority.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return priorities\n    \n    waste = bins_remain_cap[valid_bins] - item\n    priorities[valid_bins] = 1.0 / (waste + 1e-9) + 1.0 / (bins_remain_cap[valid_bins] + 1e-9)\n    return priorities",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.198244914240141,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 94.01164534875782,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response0.txt_stdout.txt",
    "code_path": "problem_iter3_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    feasible_bins = bins_remain_cap >= item\n    if not np.any(feasible_bins):\n        return priorities\n    \n    bin_utilizations = bins_remain_cap[feasible_bins] / bins_remain_cap[feasible_bins].max()\n    \n    sigmoid_scores = 1 / (1 + np.exp(-5 * (bin_utilizations - 0.5)))\n    \n    fit_scores = (bins_remain_cap[feasible_bins] - item) / item\n    \n    combined_scores = sigmoid_scores * fit_scores\n    \n    priorities[feasible_bins] = combined_scores\n    \n    best_bin_index = np.argmax(priorities[feasible_bins])\n    \n    best_bin_idx_original = np.where(feasible_bins)[0][best_bin_index]\n    \n    priorities[best_bin_idx_original] = 2.0\n    \n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 40.59633027522938,
    "SLOC": 14.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 142.13383752235586,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response1.txt_stdout.txt",
    "code_path": "problem_iter3_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    feasible_bins = bins_remain_cap >= item\n    if not np.any(feasible_bins):\n        return priorities\n    \n    fill_ratios = bins_remain_cap[feasible_bins] / bins_remain_cap[feasible_bins].max()\n    \n    sigmoid_scores = 1 / (1 + np.exp(-5 * (fill_ratios - 0.5)))\n    \n    fit_diffs = bins_remain_cap[feasible_bins] - item\n    \n    best_fit_index = np.argmin(fit_diffs)\n    \n    priorities[feasible_bins] = sigmoid_scores\n    priorities[np.where(feasible_bins)[0][best_fit_index]] += 1.0\n    \n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 124.86408532184433,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter17_response3.txt_stdout.txt",
    "code_path": "problem_iter17_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit and sigmoid-scaled fill ratio for robust bin packing.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        return priorities\n\n    bin_utilizations = bins_remain_cap[feasible_bins] / bins_remain_cap[feasible_bins].max()\n    sigmoid_scores = 1 / (1 + np.exp(-5 * (bin_utilizations - 0.5)))\n    fit_scores = (bins_remain_cap[feasible_bins] - item) / item\n    combined_scores = 0.7 * sigmoid_scores + 0.3 * fit_scores\n    priorities[feasible_bins] = combined_scores\n    best_bin_index = np.argmax(priorities[feasible_bins])\n    best_bin_overall_index = np.where(feasible_bins)[0][best_bin_index]\n    priorities[best_bin_overall_index] = 2.0\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 18.238930993218997,
    "SLOC": 14.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 177.87213211613133,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response3.txt_stdout.txt",
    "code_path": "problem_iter3_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    feasible_bins = bins_remain_cap >= item\n    if not np.any(feasible_bins):\n        return priorities\n    \n    bin_utilizations = bins_remain_cap[feasible_bins] / bins_remain_cap[feasible_bins]\n    \n    scores = np.zeros_like(bins_remain_cap[feasible_bins])\n    \n    for i, cap in enumerate(bins_remain_cap[feasible_bins]):\n        \n        fit = item / cap\n        \n        if fit <= 0.5:\n            scores[i] = 1.0 + (1.0 - fit) * 0.5\n        elif fit <= 0.9:\n            scores[i] = 0.5 + (1.0 - fit) * 0.2\n        else:\n            scores[i] = 0.1\n            \n    best_bin_index = np.argmax(scores)\n    \n    priorities[feasible_bins] = scores\n    priorities[np.where(feasible_bins)[0][best_bin_index]] = scores[best_bin_index] + 1.0\n\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 20.971280414838446,
    "SLOC": 19.0,
    "cyclomatic_complexity": 5.0,
    "halstead": 171.8953543301665,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response4.txt_stdout.txt",
    "code_path": "problem_iter3_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    feasible_bins = bins_remain_cap >= item\n    if not np.any(feasible_bins):\n        return priorities\n    \n    bin_utilizations = bins_remain_cap[feasible_bins] / bins_remain_cap[feasible_bins].max()\n    \n    scores = 1.0 / (1.0 + np.exp(-5 * (bin_utilizations - 0.5)))\n    \n    priorities[feasible_bins] = scores\n    \n    best_fit_index = np.argmin(bins_remain_cap[feasible_bins] - item)\n    priorities[feasible_bins][best_fit_index] += 1.5\n    \n    \n    \n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 126.65973476959637,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response0.txt_stdout.txt",
    "code_path": "problem_iter4_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, weight_one: float = 4.0812197907178795, weight_best_fit: float = 8.716655398841299) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    feasible_bins = bins_remain_cap >= item\n    if np.any(feasible_bins):\n        best_fit_index = np.argmin(bins_remain_cap[feasible_bins] - item)\n        priorities[feasible_bins] = weight_one\n        priorities[np.where(bins_remain_cap >= item)[0][best_fit_index]] = weight_best_fit\n    return priorities",
    "response_id": 0,
    "tryHS": true,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 20.89735285398626,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response1.txt_stdout.txt",
    "code_path": "problem_iter5_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with a scaled fill ratio to prioritize bins.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return priorities\n\n    distances = bins_remain_cap[valid_bins] - item\n    best_fit_index = np.argmin(distances)\n    \n    fill_ratios = bins_remain_cap[valid_bins] / np.max(bins_remain_cap)\n    \n    priorities[valid_bins] = 1.0 / (distances + 1e-6) * (1 + np.tanh(fill_ratios - 0.5))\n    \n    priorities[np.where(valid_bins)[0][best_fit_index]] *= 2.0\n    \n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.198244914240141,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 131.18329672565338,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response3.txt_stdout.txt",
    "code_path": "problem_iter5_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit and waste minimization with a sigmoid scaling.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    feasible_bins = bins_remain_cap >= item\n    if not np.any(feasible_bins):\n        return priorities\n\n    waste = bins_remain_cap[feasible_bins] - item\n    reciprocal_waste = 1.0 / (waste + 1e-6)\n    fit_scores = item / bins_remain_cap[feasible_bins]\n    sigmoid_scores = 1.0 / (1.0 + np.exp(-5 * (1.0 - fit_scores)))\n    scores = 0.6 * reciprocal_waste + 0.4 * sigmoid_scores\n    best_bin_index = np.argmax(scores)\n    priorities[feasible_bins] = scores\n    priorities[np.where(feasible_bins)[0][best_bin_index]] = scores[best_bin_index] + 1.0\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 40.05783805345035,
    "SLOC": 14.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 208.89318279048564,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response6.txt_stdout.txt",
    "code_path": "problem_iter8_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with sigmoid-scaled bin fill ratio for smoother prioritization.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return priorities\n    distances = bins_remain_cap[valid_bins] - item\n    fit_scores = 1.0 / (1.0 + distances)\n    bin_utilizations = 1.0 - (bins_remain_cap[valid_bins] - item) / bins_remain_cap[valid_bins]\n    sigmoid_scores = 1.0 / (1.0 + np.exp(-5.0 * (bin_utilizations - 0.5)))\n    combined_scores = 0.7 * sigmoid_scores + 0.3 * fit_scores\n    priorities[valid_bins] = combined_scores\n    return priorities",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 227.8930302777963,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response5.txt_stdout.txt",
    "code_path": "problem_iter5_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines reciprocal waste (v0) with a sigmoid-based fit score (v1).\"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return priorities\n\n    waste = bins_remain_cap[valid_bins] - item\n    fit = item / bins_remain_cap[valid_bins]\n    sigmoid_score = 1.0 / (1.0 + np.exp(-5 * (fit - 0.5)))\n    priorities[valid_bins] = 1.0 / (waste + 1e-9) + sigmoid_score * 0.5\n    return priorities",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.198244914240141,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 173.91626957122043,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response6.txt_stdout.txt",
    "code_path": "problem_iter5_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines reciprocal waste (v0) with a sigmoid-scaled best fit (v6) for improved bin selection.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    suitable_bins = bins_remain_cap >= item\n    if np.any(suitable_bins):\n        waste = bins_remain_cap[suitable_bins] - item\n        priorities[suitable_bins] = 1.0 / (waste + 1e-6)\n        \n        fill_ratios = (bins_remain_cap[suitable_bins] - item) / bins_remain_cap[suitable_bins]\n        sigmoid_scores = 1.0 / (1.0 + np.exp(-5 * (fill_ratios - 0.5)))\n        \n        best_fit_index = np.argmin(waste)\n        priorities[suitable_bins] = np.where(np.arange(len(suitable_bins)) == best_fit_index,\n                                             priorities[suitable_bins] + sigmoid_scores,\n                                             priorities[suitable_bins])\n    return priorities",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.198244914240141,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 182.67948703818894,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response7.txt_stdout.txt",
    "code_path": "problem_iter5_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with a sigmoid function to prioritize bins.\"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n    remaining_capacities = bins_remain_cap[possible_bins]\n    fit_scores = 1.0 / (1.0 + np.exp(-5 * (remaining_capacities - item)))\n    bin_utilizations = bins_remain_cap[possible_bins] / bins_remain_cap[possible_bins].max()\n    sigmoid_scores = 1 / (1 + np.exp(-5 * (bin_utilizations - 0.5)))\n    combined_scores = fit_scores * sigmoid_scores\n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[possible_bins] = combined_scores\n    return priorities",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 185.4406125843753,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response9.txt_stdout.txt",
    "code_path": "problem_iter5_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with a sigmoid function based on bin fill ratio.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    feasible_bins = bins_remain_cap >= item\n    if not np.any(feasible_bins):\n        return priorities\n\n    bin_utilizations = bins_remain_cap[feasible_bins] / bins_remain_cap[feasible_bins]\n    sigmoid_scores = 1 / (1 + np.exp(-5 * (bin_utilizations - 0.5)))\n    fit_scores = (bins_remain_cap[feasible_bins] - item) / item\n    combined_scores = 0.7 * sigmoid_scores + 0.3 * fit_scores\n    priorities[feasible_bins] = combined_scores\n    return priorities",
    "response_id": 9,
    "tryHS": false,
    "obj": 22.008376545672125,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 177.87213211613133,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response1.txt_stdout.txt",
    "code_path": "problem_iter6_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    feasible_bins = bins_remain_cap >= item\n    if not np.any(feasible_bins):\n        return priorities\n    \n    remaining_capacities = bins_remain_cap[feasible_bins]\n    \n    \n    fit_scores = 1.0 / (remaining_capacities - item + 1e-6)\n    \n    \n    avg_remaining = np.mean(bins_remain_cap[feasible_bins])\n    \n    \n    exploration_bonus = np.where(bins_remain_cap > avg_remaining, 0.5, 0.0)\n    \n    \n    priorities[feasible_bins] = fit_scores + exploration_bonus\n    \n    \n    best_bin_index = np.argmax(priorities[feasible_bins])\n    \n    priorities[feasible_bins] = np.where(np.arange(len(feasible_bins)) == best_bin_index, 2.0, 1.0)\n    \n    \n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.198244914240141,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 99.40434618240934,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response3.txt_stdout.txt",
    "code_path": "problem_iter6_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    feasible_bins = bins_remain_cap >= item\n    if not np.any(feasible_bins):\n        return priorities\n\n    num_feasible = np.sum(feasible_bins)\n    \n    if num_feasible == 1:\n        priorities[feasible_bins] = 2.0\n        return priorities\n\n    best_fit_index = np.argmin(bins_remain_cap[feasible_bins] - item)\n    \n    priorities[feasible_bins] = 1.0\n    priorities[np.where(feasible_bins)[0][best_fit_index]] = 2.0\n\n    \n    worst_fit_index = np.argmax(bins_remain_cap[feasible_bins] - item)\n    \n    if np.random.rand() < 0.1:\n        priorities[feasible_bins] = 0.0\n        priorities[np.where(feasible_bins)[0][worst_fit_index]] = 1.0\n    \n    \n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.098524132429212,
    "SLOC": 17.0,
    "cyclomatic_complexity": 4.0,
    "halstead": 64.72503367497926,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response4.txt_stdout.txt",
    "code_path": "problem_iter6_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    feasible_bins = bins_remain_cap >= item\n    if not np.any(feasible_bins):\n        return priorities\n    \n    sorted_bins = np.argsort(bins_remain_cap[feasible_bins])\n    \n    \n    best_fit_index = sorted_bins[0]\n    \n    \n    priorities[feasible_bins] = 0.5\n    priorities[np.where(bins_remain_cap >= item)[0][best_fit_index]] = 1.0\n    \n    \n    second_best_index = sorted_bins[min(1, len(sorted_bins)-1)]\n    priorities[np.where(bins_remain_cap >= item)[0][second_best_index]] = 0.75\n\n    \n    \n    \n    \n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 42.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter7_response0.txt_stdout.txt",
    "code_path": "problem_iter7_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray,\n                epsilon: float = 1.9097344053642677e-07,\n                sigmoid_weight: float = 9.497407494184952,\n                sigmoid_threshold: float = 0.522265042161531) -> np.ndarray:\n    \"\"\"Combines best-fit with reciprocal waste for improved bin packing.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return priorities",
    "response_id": 0,
    "tryHS": true,
    "obj": 4.487435181491823,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 11.60964047443681,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response3.txt_stdout.txt",
    "code_path": "problem_iter8_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with a sigmoid-based fill ratio prioritization.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    feasible_bins = bins_remain_cap >= item\n    if not np.any(feasible_bins):\n        return priorities\n    \n    fill_ratios = (bins_remain_cap[feasible_bins] - item) / bins_remain_cap[feasible_bins]\n    \n    priorities[feasible_bins] = 1.0 / (1 + np.exp(-5 * (0.5 - fill_ratios)))\n    \n    best_fit_index = np.argmin(bins_remain_cap[feasible_bins] - item)\n    priorities[feasible_bins] = 0.0\n    priorities[np.where(feasible_bins)[0][best_fit_index]] = 2.0\n    \n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 124.86408532184433,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response5.txt_stdout.txt",
    "code_path": "problem_iter8_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with a smoothed prioritization based on fill ratio.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    feasible_bins = bins_remain_cap >= item\n    if not np.any(feasible_bins):\n        return priorities\n\n    fill_ratios = (bins_remain_cap[feasible_bins] - item) / bins_remain_cap[feasible_bins]\n    priorities[feasible_bins] = 1.0 / (fill_ratios + 1e-6)\n    best_fit_index = np.argmin(fill_ratios)\n    priorities[feasible_bins] = 0.0\n    priorities[np.where(feasible_bins)[0][best_fit_index]] = 2.0\n    return priorities",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 66.41714012534482,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response0.txt_stdout.txt",
    "code_path": "problem_iter9_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    feasible_bins = bins_remain_cap >= item\n    if not np.any(feasible_bins):\n        return priorities\n    \n    fill_ratios = bins_remain_cap[feasible_bins] / (np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else 1)\n    \n    fit_scores = (bins_remain_cap[feasible_bins] - item) / item\n    \n    combined_scores = fill_ratios * fit_scores\n    \n    normalized_scores = (combined_scores - np.min(combined_scores)) / (np.max(combined_scores) - np.min(combined_scores)) if np.max(combined_scores) > np.min(combined_scores) else np.ones_like(combined_scores)\n    \n    priorities[feasible_bins] = normalized_scores\n    \n    best_bin_index = np.argmax(priorities[feasible_bins])\n    \n    \n    priorities[feasible_bins] = 0.0\n    priorities[np.where(feasible_bins)[0][best_bin_index]] = 1.0\n\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 149.30195452732352,
    "SLOC": 14.0,
    "cyclomatic_complexity": 4.0,
    "halstead": 148.60339807279118,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response2.txt_stdout.txt",
    "code_path": "problem_iter9_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    feasible_bins = bins_remain_cap >= item\n    if not np.any(feasible_bins):\n        return priorities\n\n    fill_ratios = bins_remain_cap[feasible_bins] / (bins_remain_cap[feasible_bins] + item)\n    \n    priority_values = np.exp(-10 * (bins_remain_cap[feasible_bins] - item) / item) * fill_ratios\n    \n    priorities[feasible_bins] = priority_values\n    \n    best_bin_index = np.argmax(priorities[feasible_bins])\n    \n    \n    best_bin_absolute_index = np.where(feasible_bins)[0][best_bin_index]\n    priorities[best_bin_absolute_index] += 1.0\n    \n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 124.86408532184433,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response0.txt_stdout.txt",
    "code_path": "problem_iter10_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, small_value: float = 7.14190001290711e-05) -> np.ndarray:\n    \"\"\"\n    Combines best-fit (reciprocal of waste) with a validity check.\n    Prioritizes bins that fit the item and minimize remaining space.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if np.sum(valid_bins) == 0:\n        return priorities",
    "response_id": 0,
    "tryHS": true,
    "obj": 4.487435181491823,
    "SLOC": 5.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 15.509775004326936,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response6.txt_stdout.txt",
    "code_path": "problem_iter11_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with smoothed fill ratio using sigmoid.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    suitable_bins = bins_remain_cap >= item\n    if not np.any(suitable_bins):\n        return priorities\n    waste = bins_remain_cap[suitable_bins] - item\n    fill_ratios = (bins_remain_cap[suitable_bins] / np.max(bins_remain_cap)) if np.max(bins_remain_cap) > 0 else np.ones_like(bins_remain_cap[suitable_bins])\n    sigmoid_fill_ratio = 1 / (1 + np.exp(-5 * (fill_ratios - 0.5)))\n    priorities[suitable_bins] = sigmoid_fill_ratio / (waste + 1e-6)\n    best_fit_index = np.argmin(waste)\n    priorities[suitable_bins] = np.where(np.arange(len(suitable_bins)) == best_fit_index, priorities[suitable_bins] + 1.0, priorities[suitable_bins])\n    return priorities",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 200.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response7.txt_stdout.txt",
    "code_path": "problem_iter11_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with a smoothed fill ratio prioritization using a sigmoid.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    feasible_bins = bins_remain_cap >= item\n\n    if np.any(feasible_bins):\n        fill_ratios = (bins_remain_cap[feasible_bins] - item) / bins_remain_cap[feasible_bins]\n        sigmoid_values = 1 / (1 + np.exp(-10 * (1 - fill_ratios)))\n        best_fit_index = np.argmin(bins_remain_cap[feasible_bins] - item)\n        priorities[feasible_bins] = sigmoid_values\n        priorities[np.where(feasible_bins)[0][best_fit_index]] += 1.0\n    return priorities",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 125.33591475173351,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response8.txt_stdout.txt",
    "code_path": "problem_iter11_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines sigmoid fit score with a reciprocal waste component.\"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n    \n    fit_scores = (bins_remain_cap[possible_bins] - item) / bins_remain_cap[possible_bins]\n    sigmoid_scores = 1 / (1 + np.exp(-5 * (fit_scores - 0.5)))\n    \n    waste_scores = 1 / (item + 1e-6)\n    \n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[possible_bins] = 0.7 * sigmoid_scores + 0.3 * waste_scores\n    \n    return priorities",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 194.3192398051029,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response9.txt_stdout.txt",
    "code_path": "problem_iter11_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with reciprocal waste and sigmoid smoothing.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return priorities\n    waste = bins_remain_cap[valid_bins] - item\n    priorities[valid_bins] = 1.0 / (waste + 1e-9)\n    fit_scores = (bins_remain_cap[valid_bins] - item) / bins_remain_cap[valid_bins]\n    sigmoid_scores = 1 / (1 + np.exp(-5 * (fit_scores - 0.5)))\n    priorities[valid_bins] = priorities[valid_bins] * sigmoid_scores\n    best_fit_index = np.argmin(bins_remain_cap[valid_bins] - item)\n    priorities[valid_bins] = 0\n    priorities[np.where(valid_bins)[0][best_fit_index]] = 1.0\n    return priorities",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 14.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 192.29419688230416,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response0.txt_stdout.txt",
    "code_path": "problem_iter12_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    n_bins = len(bins_remain_cap)\n    priorities = np.zeros(n_bins)\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        return priorities\n\n    fit_score = 1 / (bins_remain_cap[feasible_bins] - item + 1e-6)\n    utilization_score = bins_remain_cap[feasible_bins] / np.max(bins_remain_cap)\n    \n    smooth_fit = 1 / (1 + np.exp(-fit_score))\n    smooth_utilization = 1 / (1 + np.exp(-utilization_score))\n    \n    combined_score = 0.6 * smooth_fit + 0.4 * smooth_utilization\n    \n    priorities[feasible_bins] = combined_score\n    \n    best_bin_index = np.argmax(priorities[feasible_bins])\n    \n    best_bin_idx = np.where(feasible_bins)[0][best_bin_index]\n    priorities[best_bin_idx] += 0.5\n\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 81.9206222576785,
    "SLOC": 16.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 222.9388339674094,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response1.txt_stdout.txt",
    "code_path": "problem_iter12_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    num_bins = len(bins_remain_cap)\n    priorities = np.zeros(num_bins)\n    feasible_bins = bins_remain_cap >= item\n    \n    if not np.any(feasible_bins):\n        return priorities\n    \n    fit_scores = 1.0 / (bins_remain_cap[feasible_bins] - item + 1e-6)\n    utilization_scores = bins_remain_cap[feasible_bins] / np.max(bins_remain_cap)\n    \n    smooth_fit = 1.0 / (1.0 + np.exp(-fit_scores * 5.0))\n    smooth_util = 1.0 / (1.0 + np.exp(-utilization_scores * 5.0))\n    \n    combined_scores = 0.6 * smooth_fit + 0.4 * smooth_util\n    \n    priorities[feasible_bins] = combined_scores\n    \n    best_bin_index = np.argmax(priorities[feasible_bins])\n    \n    priorities[np.where(feasible_bins)[0][best_bin_index]] += 1.0\n    \n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.178300757877951,
    "SLOC": 15.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 257.2641000872811,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response2.txt_stdout.txt",
    "code_path": "problem_iter12_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    feasible_bins = bins_remain_cap >= item\n    if not np.any(feasible_bins):\n        return priorities\n\n    fit_score = np.where(feasible_bins, 1.0 / (bins_remain_cap[feasible_bins] - item + 1e-6), 0.0)\n    utilization_score = np.where(feasible_bins, bins_remain_cap[feasible_bins] / np.max(bins_remain_cap), 0.0)\n\n    sigmoid_fit = 1 / (1 + np.exp(-fit_score * 10))\n    sigmoid_utilization = 1 / (1 + np.exp(-utilization_score * 5))\n\n    combined_score = 0.7 * sigmoid_fit + 0.3 * sigmoid_utilization\n    priorities[feasible_bins] = combined_score\n    best_bin_index = np.argmax(priorities[feasible_bins])\n    priorities[np.where(feasible_bins)[0][best_bin_index]] += 1.0\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 14.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 259.4606049037673,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response3.txt_stdout.txt",
    "code_path": "problem_iter12_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    n_bins = len(bins_remain_cap)\n    priorities = np.zeros(n_bins)\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        return priorities\n\n    fit_score = np.where(feasible_bins, (bins_remain_cap - item), np.inf)\n    waste_score = np.where(feasible_bins, item, np.inf)\n    utilization_score = np.where(feasible_bins, (bins_remain_cap - item) / bins_remain_cap, 0)\n\n    def sigmoid(x):\n        return 1 / (1 + np.exp(-x))\n\n    fit_priority = sigmoid(1 / fit_score)\n    waste_priority = sigmoid(1 / waste_score)\n    utilization_priority = sigmoid(utilization_score * 5)\n\n    priorities = 0.4 * fit_priority + 0.3 * waste_priority + 0.3 * utilization_priority\n    best_bin_index = np.argmax(priorities[feasible_bins])\n    priorities[feasible_bins] = 0.0\n    priorities[np.where(feasible_bins)[0][best_bin_index]] = 1.0\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 84.83246908655765,
    "SLOC": 19.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 223.46712577586834,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response4.txt_stdout.txt",
    "code_path": "problem_iter12_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    n_bins = len(bins_remain_cap)\n    priorities = np.zeros(n_bins)\n    feasible_bins = bins_remain_cap >= item\n    if not np.any(feasible_bins):\n        return priorities\n    \n    fit_score = 1.0 / (bins_remain_cap[feasible_bins] - item + 1e-6)\n    \n    utilization_score = bins_remain_cap[feasible_bins] / np.max(bins_remain_cap)\n    \n    waste_score = (bins_remain_cap[feasible_bins] - item) / np.max(bins_remain_cap)\n\n    \n    \n    combined_score = (0.5 * fit_score) + (0.3 * utilization_score) + (0.2 * waste_score)\n    \n    priorities[feasible_bins] = combined_score\n    \n    best_bin_index = np.argmax(priorities)\n    \n    if best_bin_index < n_bins:\n        priorities[best_bin_index] += 0.5\n        \n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 84.7726366174711,
    "SLOC": 15.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 221.95334125177195,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter13_response0.txt_stdout.txt",
    "code_path": "problem_iter13_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float = 0.274027882013571, bins_remain_cap: np.ndarray = None) -> np.ndarray:\n    \"\"\"\n    Calculates priorities for items based on remaining capacity of bins.\n\n    Args:\n        item (float, optional): The item size. Defaults to 0.0.\n        bins_remain_cap (np.ndarray, optional): Remaining capacity of bins. Defaults to None.\n\n    Returns:\n        np.ndarray: Priorities for each bin.\n    \"\"\"\n    if bins_remain_cap is None:\n        return np.array([])",
    "response_id": 0,
    "tryHS": true,
    "obj": 4.487435181491823,
    "SLOC": 3.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 4.754887502163469,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response1.txt_stdout.txt",
    "code_path": "problem_iter14_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with a sigmoid-scaled fill ratio for prioritization.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        return priorities\n\n    remaining_capacities = bins_remain_cap[feasible_bins]\n    fit_scores = 1.0 / (remaining_capacities - item + 1e-6)\n\n    fill_ratio = (bins_remain_cap - item) / bins_remain_cap\n    fill_ratio = np.clip(fill_ratio, 0.0, 1.0)\n    sigmoid_fill_ratio = 1.0 / (1.0 + np.exp(-5 * (fill_ratio - 0.5)))\n\n    priorities[feasible_bins] = fit_scores + sigmoid_fill_ratio\n    best_bin_index = np.argmax(priorities[feasible_bins])\n    priorities[feasible_bins] = np.where(np.arange(len(feasible_bins)) == best_bin_index, 2.0, 1.0)\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.198244914240141,
    "SLOC": 14.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 192.29419688230416,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response5.txt_stdout.txt",
    "code_path": "problem_iter14_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with a sigmoid-based fill ratio prioritization and reciprocal waste.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    feasible_bins = bins_remain_cap >= item\n    if not np.any(feasible_bins):\n        return priorities\n\n    fill_ratios = (bins_remain_cap[feasible_bins] - item) / bins_remain_cap[feasible_bins]\n    sigmoid_scores = 1.0 / (1 + np.exp(-5 * (0.5 - fill_ratios)))\n    waste = bins_remain_cap[feasible_bins] - item\n    reciprocal_waste = 1.0 / (waste + 1e-9)\n\n    priorities[feasible_bins] = 0.7 * sigmoid_scores + 0.3 * reciprocal_waste\n    best_fit_index = np.argmin(bins_remain_cap[feasible_bins] - item)\n    priorities[np.where(feasible_bins)[0][best_fit_index]] += 1.0\n\n    return priorities",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 247.1753118485642,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response7.txt_stdout.txt",
    "code_path": "problem_iter14_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with bin utilization (fill ratio) using a sigmoid function.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    feasible_bins = bins_remain_cap >= item\n    if not np.any(feasible_bins):\n        return priorities\n\n    fill_ratios = bins_remain_cap[feasible_bins] / (np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else 1)\n    fit_scores = 1.0 / (bins_remain_cap[feasible_bins] - item + 1e-6)\n    combined_scores = fill_ratios * fit_scores\n    \n    sigmoid_scores = 1.0 / (1.0 + np.exp(-combined_scores))\n    priorities[feasible_bins] = sigmoid_scores\n    \n    best_bin_index = np.argmax(priorities[feasible_bins])\n    priorities[feasible_bins] = 0.0\n    priorities[np.where(feasible_bins)[0][best_bin_index]] = 1.0\n    \n    return priorities",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.198244914240141,
    "SLOC": 14.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 143.95954188301644,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response1.txt_stdout.txt",
    "code_path": "problem_iter20_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with normalized utilization and smooths with sigmoid.\"\"\"\n    feasible_bins = bins_remain_cap >= item\n    if not np.any(feasible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    best_fit_score = 1.0 / (bins_remain_cap[feasible_bins] - item + 1e-6)\n    utilization_score = bins_remain_cap[feasible_bins] / bins_remain_cap.max()\n    combined_score = best_fit_score + utilization_score\n\n    def sigmoid(x):\n        return 1 / (1 + np.exp(-x))\n\n    priorities = np.zeros_like(bins_remain_cap)\n    if np.any(feasible_bins):\n        smoothed_scores = sigmoid(combined_score)\n        priorities[feasible_bins] = smoothed_scores\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.198244914240141,
    "SLOC": 14.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 124.86408532184433,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response8.txt_stdout.txt",
    "code_path": "problem_iter20_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with bin utilization (fill ratio), smoothed by a sigmoid.\"\"\"\n    n_bins = len(bins_remain_cap)\n    priorities = np.zeros(n_bins)\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        return priorities\n\n    best_fit_score = 1.0 / (bins_remain_cap[feasible_bins] - item + 1e-6)\n    utilization_score = (bins_remain_cap[feasible_bins] - item) / bins_remain_cap[feasible_bins]\n    combined_score = 0.7 * best_fit_score + 0.3 * utilization_score\n\n    def sigmoid(x):\n        return 1 / (1 + np.exp(-x))\n\n    priorities[feasible_bins] = sigmoid(combined_score)\n    return priorities",
    "response_id": 8,
    "tryHS": false,
    "obj": 79.18827283605904,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 177.87213211613133,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter15_response2.txt_stdout.txt",
    "code_path": "problem_iter15_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    n_bins = len(bins_remain_cap)\n    priorities = np.zeros(n_bins)\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        return priorities\n\n    best_fit_score = np.where(feasible_bins)[0]\n    best_fit_score = bins_remain_cap[feasible_bins] - item\n    best_fit_index = np.argmin(best_fit_score)\n    best_fit_index = np.where(feasible_bins)[0][best_fit_index]\n\n    utilization_score = bins_remain_cap[feasible_bins] / (bins_remain_cap[feasible_bins] + item)\n\n    sigmoid_scale = 5.0\n    \n    best_fit_sigmoid = 1 / (1 + np.exp(-sigmoid_scale * (best_fit_score[best_fit_index])))\n    utilization_sigmoid = 1 / (1 + np.exp(-sigmoid_scale * (1 - utilization_score)))\n    \n    combined_score = best_fit_sigmoid + utilization_sigmoid\n    \n    priorities[feasible_bins] = combined_score\n    priorities[best_fit_index] += 1.0\n\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 18.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 216.33097149259217,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter15_response3.txt_stdout.txt",
    "code_path": "problem_iter15_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    feasible_bins = bins_remain_cap >= item\n    if not np.any(feasible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    best_fit_scores = 1.0 / (bins_remain_cap[feasible_bins] - item + 1e-6)\n    utilization_scores = bins_remain_cap[feasible_bins] / np.max(bins_remain_cap)\n\n    combined_scores = best_fit_scores + utilization_scores\n\n    def sigmoid(x):\n        return 1 / (1 + np.exp(-x))\n\n    priorities = np.zeros_like(bins_remain_cap)\n    if np.any(feasible_bins):\n        scaled_scores = sigmoid(combined_scores)\n        priorities[feasible_bins] = scaled_scores\n        best_bin_index = np.argmax(scaled_scores)\n        priorities[np.where(feasible_bins)[0][best_bin_index]] += 0.5\n\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.198244914240141,
    "SLOC": 16.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 142.13383752235586,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter16_response0.txt_stdout.txt",
    "code_path": "problem_iter16_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, sigmoid_weight: float = 5.993771094392258, sigmoid_threshold: float = 0.616318835448193) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Sigmoid Fit Score.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        sigmoid_weight: Weight of the sigmoid function.\n        sigmoid_threshold: Threshold of the sigmoid function.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)",
    "response_id": 0,
    "tryHS": true,
    "obj": 4.487435181491823,
    "SLOC": 4.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 11.60964047443681,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter17_response0.txt_stdout.txt",
    "code_path": "problem_iter17_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit (reciprocal waste) with fill ratio, using a sigmoid for smoothing.\"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n    remaining_capacities = bins_remain_cap[possible_bins]\n    waste = remaining_capacities - item\n    fit_scores = 1.0 / (waste + 1e-6)\n    fill_ratios = bins_remain_cap[possible_bins] / bins_remain_cap[possible_bins].max()\n    sigmoid_scores = 1 / (1 + np.exp(-5 * (fill_ratios - 0.5)))\n    combined_scores = fit_scores * sigmoid_scores\n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[possible_bins] = combined_scores\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.198244914240141,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 159.81495041679716,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter17_response6.txt_stdout.txt",
    "code_path": "problem_iter17_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with reciprocal waste, smoothed by sigmoid, for better packing.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    feasible_bins = bins_remain_cap >= item\n    if not np.any(feasible_bins):\n        return priorities\n    waste = bins_remain_cap[feasible_bins] - item\n    fit_score = 1.0 / (waste + 1e-6)\n    sigmoid_input = np.log(1 + np.exp(fit_score))\n    priorities[feasible_bins] = sigmoid_input\n    best_fit_index = np.argmin(bins_remain_cap[feasible_bins] - item)\n    priorities[np.where(feasible_bins)[0][best_fit_index]] = 2.0\n    return priorities",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 78.13781191217038,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter17_response8.txt_stdout.txt",
    "code_path": "problem_iter17_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with a smoothed prioritization based on fill ratio.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    feasible_bins = bins_remain_cap >= item\n    if not np.any(feasible_bins):\n        return priorities\n    fill_ratios = (bins_remain_cap[feasible_bins] - item) / bins_remain_cap[feasible_bins]\n    waste = bins_remain_cap[feasible_bins] - item\n    priorities[feasible_bins] = 1.0 / (waste + 1e-6)\n    best_fit_index = np.argmin(fill_ratios)\n    priorities[feasible_bins] = 0.0\n    priorities[np.where(feasible_bins)[0][best_fit_index]] = 2.0\n    return priorities",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 80.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter19_response0.txt_stdout.txt",
    "code_path": "problem_iter19_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.0003905357804307225) -> np.ndarray:\n    \"\"\"\n    Calculates priorities based on item size and remaining capacity of bins.\n\n    Args:\n        item: The size of the item.\n        bins_remain_cap: A numpy array representing the remaining capacity of each bin.\n        epsilon: A small value to avoid division by zero.\n\n    Returns:\n        A numpy array representing the priorities of each bin.\n    \"\"\"\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return np.zeros_like(bins_remain_cap)",
    "response_id": 0,
    "tryHS": true,
    "obj": 4.487435181491823,
    "SLOC": 4.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 11.60964047443681,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response2.txt_stdout.txt",
    "code_path": "problem_iter20_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with fill ratio prioritization, smoothed by a sigmoid.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    feasible_bins = bins_remain_cap >= item\n    if not np.any(feasible_bins):\n        return priorities\n\n    fill_ratios = bins_remain_cap[feasible_bins] / (bins_remain_cap[feasible_bins] + item)\n    fit_diffs = bins_remain_cap[feasible_bins] - item\n    priority_values = np.exp(-10 * fit_diffs / item) * fill_ratios\n    priorities[feasible_bins] = priority_values\n\n    best_bin_index = np.argmax(priorities[feasible_bins])\n    best_bin_absolute_index = np.where(feasible_bins)[0][best_bin_index]\n    priorities[best_bin_absolute_index] += 1.0\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 124.86408532184433,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response4.txt_stdout.txt",
    "code_path": "problem_iter20_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with reciprocal waste and smooths priorities using a sigmoid.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    feasible_bins = bins_remain_cap >= item\n    if not np.any(feasible_bins):\n        return priorities\n    waste = bins_remain_cap[feasible_bins] - item\n    priorities[feasible_bins] = 1.0 / (waste + 1e-6)\n    best_fit_index = np.argmin(bins_remain_cap[feasible_bins] - item)\n    priorities[np.where(feasible_bins)[0][best_fit_index]] = 2.0\n    \n    fill_ratios = bins_remain_cap / np.max(bins_remain_cap)\n    \n    sigmoid_factor = 1 / (1 + np.exp(-5 * (fill_ratios - 0.5)))\n    \n    priorities = priorities * sigmoid_factor\n\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 173.91626957122043,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response5.txt_stdout.txt",
    "code_path": "problem_iter20_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with smoothed utilization score for robust bin packing.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    feasible_bins = bins_remain_cap >= item\n    if not np.any(feasible_bins):\n        return priorities\n\n    waste = bins_remain_cap[feasible_bins] - item\n    fit = item / bins_remain_cap[feasible_bins]\n    sigmoid_score = 1.0 / (1.0 + np.exp(-5 * (fit - 0.5)))\n\n    priorities[feasible_bins] = 1.0 / (waste + 1e-6) + sigmoid_score * 0.5\n    best_fit_index = np.argmin(bins_remain_cap[feasible_bins] - item)\n    priorities[np.where(feasible_bins)[0][best_fit_index]] = 2.0\n\n    return priorities",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 190.19550008653877,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter21_response0.txt_stdout.txt",
    "code_path": "problem_iter21_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    feasible_bins = bins_remain_cap >= item\n    if not np.any(feasible_bins):\n        return priorities\n    \n    bin_fill_ratios = 1.0 - (bins_remain_cap / np.maximum(bins_remain_cap[feasible_bins], 1e-9))\n    \n    best_fit_diffs = bins_remain_cap[feasible_bins] - item\n    best_fit_index = np.argmin(best_fit_diffs)\n    \n    fit_priority = np.zeros_like(bins_remain_cap)\n    fit_priority[feasible_bins] = np.exp(-best_fit_diffs / (item + 1e-9))\n    \n    utilization_priority = np.zeros_like(bins_remain_cap)\n    utilization_priority[feasible_bins] = 1.0 / (1.0 + np.exp(-5.0 * (bin_fill_ratios[feasible_bins] - 0.5)))\n    \n    priorities[feasible_bins] = 0.6 * fit_priority[feasible_bins] + 0.4 * utilization_priority[feasible_bins]\n    \n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 14.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 222.9388339674094,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter21_response2.txt_stdout.txt",
    "code_path": "problem_iter21_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    feasible_bins = bins_remain_cap >= item\n    if not np.any(feasible_bins):\n        return priorities\n    \n    fill_ratios = bins_remain_cap[feasible_bins] / bins_remain_cap[feasible_bins].max()\n    \n    best_fit_diffs = bins_remain_cap[feasible_bins] - item\n    \n    best_fit_priority = 1.0 - (best_fit_diffs / bins_remain_cap[feasible_bins].max())\n    \n    fill_ratio_priority = 1.0 / (1.0 + np.exp(-5 * (fill_ratios - 0.5)))\n    \n    combined_priority = 0.6 * best_fit_priority + 0.4 * fill_ratio_priority\n    \n    priorities[feasible_bins] = combined_priority\n    \n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 196.27562382434076,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter21_response3.txt_stdout.txt",
    "code_path": "problem_iter21_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    feasible_bins = bins_remain_cap >= item\n    if not np.any(feasible_bins):\n        return priorities\n\n    fill_ratios = bins_remain_cap[feasible_bins] / np.sum(bins_remain_cap)\n    best_fit_diff = bins_remain_cap[feasible_bins] - item\n    best_fit_index = np.argmin(best_fit_diff)\n\n    sigmoid_best_fit = 1 / (1 + np.exp(-best_fit_diff[best_fit_index]))\n    sigmoid_fill = 1 / (1 + np.exp(-fill_ratios[best_fit_index]))\n    \n    priorities[feasible_bins] = 0.5 * sigmoid_best_fit + 0.5 * sigmoid_fill\n    priorities[np.where(feasible_bins)[0][best_fit_index]] = np.max(priorities[feasible_bins])\n    \n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 167.17882283189007,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter21_response4.txt_stdout.txt",
    "code_path": "problem_iter21_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    feasible_bins = bins_remain_cap >= item\n    if not np.any(feasible_bins):\n        return priorities\n\n    fill_ratios = bins_remain_cap[feasible_bins] / bins_remain_cap[feasible_bins].max()\n    best_fit_diff = bins_remain_cap[feasible_bins] - item\n    best_fit_index = np.argmin(best_fit_diff)\n    \n    smooth_best_fit = 1 / (1 + np.exp(-best_fit_diff[best_fit_index]))\n    smooth_fill_ratio = 1 / (1 + np.exp(-fill_ratios))\n\n    combined_priority = 0.6 * smooth_best_fit + 0.4 * smooth_fill_ratio\n    \n    priorities[feasible_bins] = combined_priority\n    priorities[np.where(feasible_bins)[0][best_fit_index]] += 0.5\n    \n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 14.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 187.48684196024655,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter22_response0.txt_stdout.txt",
    "code_path": "problem_iter22_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 1.2225191528017935e-06) -> np.ndarray:\n    \"\"\"\n    Calculates priorities based on item value and remaining capacity of bins.\n\n    Args:\n        item (float): The value of the item.\n        bins_remain_cap (np.ndarray): The remaining capacity of the bins.\n        epsilon (float): A small value to prevent division by zero in the sigmoid calculation.\n\n    Returns:\n        np.ndarray: The calculated priorities for each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap[bins_remain_cap >= item]\n    if len(possible_bins) == 0:\n        return np.zeros_like(bins_remain_cap)",
    "response_id": 0,
    "tryHS": true,
    "obj": 4.487435181491823,
    "SLOC": 4.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 15.509775004326936,
    "exec_success": true
  }
]