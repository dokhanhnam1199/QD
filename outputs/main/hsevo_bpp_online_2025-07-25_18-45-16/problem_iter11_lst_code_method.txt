{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines waste minimization with normalized capacity to prioritize bins effectively.\"\"\"\n    waste = bins_remain_cap - item\n    priority_scores = np.where(waste >= 0, waste / (bins_remain_cap + 1e-6), -np.inf)\n    return -priority_scores\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This heuristic aims to minimize waste by prioritizing bins that have enough space\n    for the item and are closer to being full. It uses a simple normalization to ensure\n    that the priority score is consistent and focused on waste reduction.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Check if the bin has enough space for the item\n    can_fit = bins_remain_cap >= item\n    # Calculate the waste if the item is added to the bin\n    waste = bins_remain_cap - item\n    # Normalize the waste by the bin capacity\n    normalized_waste = waste / bins_remain_cap\n    # Priority score: prioritize bins that can fit the item and have minimal waste\n    priority_score = can_fit * (1 - normalized_waste)\n    return priority_score\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines fit availability and normalized waste minimization for efficient bin selection.\"\"\"\n    can_fit = (bins_remain_cap >= item).astype(float)\n    normalized_waste = (bins_remain_cap - item) / bins_remain_cap\n    priority_scores = can_fit * (1 - normalized_waste)\n    return priority_scores\n\n[Heuristics 4th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This heuristic aims to minimize waste by prioritizing bins that have enough space\n    for the item and are closer to being full. It uses a simple normalization to ensure\n    that the priority score is consistent and focused on waste reduction.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Check if the bin has enough space for the item\n    can_fit = bins_remain_cap >= item\n    # Calculate the waste if the item is added to the bin\n    waste = bins_remain_cap - item\n    # Normalize the waste by the bin capacity\n    normalized_waste = waste / bins_remain_cap\n    # Priority score: prioritize bins that can fit the item and have minimal waste\n    priority_score = can_fit * (1 - normalized_waste)\n    return priority_score\n\n[Heuristics 5th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This heuristic aims to minimize waste by prioritizing bins that have enough space\n    for the item and are closer to being full. It uses a simple normalization to ensure\n    that the priority score is consistent and focused on waste reduction.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Check if the bin has enough space for the item\n    can_fit = bins_remain_cap >= item\n    # Calculate the waste if the item is added to the bin\n    waste = bins_remain_cap - item\n    # Normalize the waste by the bin capacity\n    normalized_waste = waste / bins_remain_cap\n    # Priority score: prioritize bins that can fit the item and have minimal waste\n    priority_score = can_fit * (1 - normalized_waste)\n    return priority_score\n\n[Heuristics 6th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins based on minimizing waste and balancing remaining capacity.\n    Directly targets bins with least remaining capacity after adding the item.\n    Uses normalized scores to ensure consistent prioritization.\n    \"\"\"\n    can_fit = bins_remain_cap >= item\n    space_left = bins_remain_cap - item\n    # Minimize waste and balance by normalizing space left\n    priority = can_fit * (-space_left / np.max(bins_remain_cap))\n    return priority\n\n[Heuristics 7th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines waste minimization with fit availability for efficient bin packing.\"\"\"\n    can_fit = (bins_remain_cap >= item).astype(float)\n    waste = bins_remain_cap - item\n    priority_scores = np.where(waste >= 0, waste, np.inf)  # Prioritize fitting bins with least waste\n    return can_fit * (-priority_scores)  # Maximize negative waste for top priority\n\n[Heuristics 8th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines waste minimization with fit availability for efficient bin packing.\"\"\"\n    can_fit = (bins_remain_cap >= item).astype(float)\n    waste = bins_remain_cap - item\n    priority_scores = np.where(waste >= 0, waste, np.inf)  # Prioritize fitting bins with least waste\n    return can_fit * (-priority_scores)  # Maximize negative waste for top priority\n\n[Heuristics 9th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins with least waste and considers normalized remaining capacity for better decision.\"\"\"\n    can_fit = (bins_remain_cap >= item).astype(float)\n    waste = bins_remain_cap - item\n    norm_cap = bins_remain_cap / np.max(bins_remain_cap)\n    priority_scores = np.where(waste >= 0, waste + norm_cap, -np.inf)\n    return can_fit * (-priority_scores)  # Prioritize fitting bins with least waste and high remaining capacity\n\n[Heuristics 10th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This heuristic aims to minimize waste by prioritizing bins that have enough space\n    for the item and are closer to being full. It uses a simple normalization to ensure\n    that the priority score is consistent and focused on waste reduction.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Check if the bin has enough space for the item\n    can_fit = bins_remain_cap >= item\n    # Calculate the waste if the item is added to the bin\n    waste = bins_remain_cap - item\n    # Normalize the waste by the bin capacity\n    normalized_waste = waste / bins_remain_cap\n    # Priority score: prioritize bins that can fit the item and have minimal waste\n    priority_score = can_fit * (1 - normalized_waste)\n    return priority_score\n\n[Heuristics 11th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(\n    item: float, \n    bins_remain_cap: np.ndarray, \n    threshold: float = 0.04732390447842405, \n    waste_penalty: float = 581900.0772769923) -> np.ndarray:\n    \"\"\"Combines waste minimization with normalized fit availability to prioritize bins.\"\"\"\n    can_fit = (bins_remain_cap >= item).astype(float)\n    waste = bins_remain_cap - item\n    priority_scores = np.where(waste >= threshold, waste, waste_penalty)\n    normalized_scores = priority_scores / np.max(priority_scores, initial=1)\n    return can_fit * (-normalized_scores)  # Prioritize fitting bins with least normalized waste\n\n[Heuristics 12th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines waste minimization with bin balance to prioritize bins effectively.\"\"\"\n    can_fit = (bins_remain_cap >= item).astype(float)\n    waste = bins_remain_cap - item\n    balance_factor = 1 - (waste / bins_remain_cap.mean())\n    priority_scores = can_fit * (waste + balance_factor)\n    return priority_scores\n\n[Heuristics 13th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines waste minimization with bin balance to prioritize bins effectively.\"\"\"\n    can_fit = (bins_remain_cap >= item).astype(float)\n    waste = bins_remain_cap - item\n    balance_factor = 1 - (waste / bins_remain_cap.mean())\n    priority_scores = can_fit * (waste + balance_factor)\n    return priority_scores\n\n[Heuristics 14th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines waste minimization with bin balance to prioritize bins effectively.\"\"\"\n    can_fit = (bins_remain_cap >= item).astype(float)\n    waste = bins_remain_cap - item\n    balance_factor = 1 - (waste / bins_remain_cap.mean())\n    priority_scores = can_fit * (waste + balance_factor)\n    return priority_scores\n\n[Heuristics 15th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines waste minimization and normalized capacity to prioritize bins effectively.\"\"\"\n    waste = bins_remain_cap - item\n    norm_cap = bins_remain_cap / np.max(bins_remain_cap, initial=1)  # Avoid division by zero\n    priority_scores = np.where(waste >= 0, waste + norm_cap, -np.inf)\n    return priority_scores\n\n[Heuristics 16th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines waste minimization and normalized capacity to prioritize bins effectively.\"\"\"\n    waste = bins_remain_cap - item\n    norm_cap = bins_remain_cap / np.max(bins_remain_cap, initial=1)  # Avoid division by zero\n    priority_scores = np.where(waste >= 0, waste + norm_cap, -np.inf)\n    return priority_scores\n\n[Heuristics 17th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines waste minimization with bin balance to prioritize bins effectively.\"\"\"\n    can_fit = (bins_remain_cap >= item).astype(float)\n    waste = bins_remain_cap - item\n    balance_factor = 1 - (waste / bins_remain_cap.mean())\n    priority_scores = can_fit * (waste + balance_factor)\n    return priority_scores\n\n[Heuristics 18th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines waste minimization and normalized capacity to prioritize bins effectively.\"\"\"\n    waste = bins_remain_cap - item\n    norm_cap = bins_remain_cap / np.max(bins_remain_cap, initial=1)  # Avoid division by zero\n    priority_scores = np.where(waste >= 0, waste + norm_cap, -np.inf)\n    return priority_scores\n\n[Heuristics 19th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines waste minimization with bin balance to prioritize bins effectively.\"\"\"\n    can_fit = (bins_remain_cap >= item).astype(float)\n    waste = bins_remain_cap - item\n    balance_factor = 1 - (waste / bins_remain_cap.mean())\n    priority_scores = can_fit * (waste + balance_factor)\n    return priority_scores\n\n[Heuristics 20th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines waste minimization with bin balance to prioritize bins effectively.\"\"\"\n    can_fit = (bins_remain_cap >= item).astype(float)\n    waste = bins_remain_cap - item\n    balance_factor = 1 - (waste / bins_remain_cap.mean())\n    priority_scores = can_fit * (waste + balance_factor)\n    return priority_scores\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}