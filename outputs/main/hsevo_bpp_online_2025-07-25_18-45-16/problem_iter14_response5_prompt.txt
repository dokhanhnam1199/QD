{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Prioritizes bins by ensuring fit availability and minimizing normalized waste.\"\"\"\n    can_fit = (bins_remain_cap >= item).astype(float)\n    normalized_waste = np.where(bins_remain_cap > 0, (bins_remain_cap - item) / bins_remain_cap, 0)\n    priority_scores = can_fit * (1 - normalized_waste)\n    return priority_scores\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Prioritizes bins by balancing waste minimization and fit availability with robust normalization.\"\"\"\n    can_fit = (bins_remain_cap >= item).astype(float)\n    waste = bins_remain_cap - item\n    normalized_waste = waste / (bins_remain_cap + 1e-6)\n    priority_scores = can_fit * normalized_waste\n    return priority_scores\n\n### Analyze & experience\n- Comparing (best) vs (worst), we see that the best heuristic (1st) effectively balances fit availability and normalized waste, leading to well-distributed items across bins. The worst heuristic (19th) incorrectly calculates priority based on positive normalized waste, deterring optimal bin selection.\n\n(Second best) vs (second worst) showcases a stark difference in normalization and waste handling. The second best (2nd) minimizes waste using normalized scores while ignoring unavailable bins, whereas the second worst (18th) assigns priority based on positive normalized waste, similar to the worst.\n\nComparing (1st) vs (2nd), we see a nuanced difference: the best heuristic considers the availability and normalized waste, while the second best focuses solely on waste minimization after normalizing.\n\n(3rd) vs (4th) highlights that the third heuristic uses a sinusoidal function to prioritize almost full bins, while the fourth focuses on normalized waste, leading to different strategies for filling bins efficiently.\n\nComparing (second worst) vs (worst), we see repetitive logic, suggesting a lack of diversity in heuristic approaches in the bottom rankings.\n\nOverall:\n- \n- **Keywords:** Normalization, Waste Minimization, Fit Availability, Simplicity\n- **Advice:** Focus on clear, normalized logic to evaluate fit availability and directly reduce waste. Ensure robustness in normalization techniques.\n- **Avoid:** Complex inverted capacity approaches, repetitive logic, and unnecessary optimization layers.\n- **Explanation:** Simplify heuristic design by prioritizing straightforward techniques that directly address the core objective of minimizing waste while ensuring that bin fit availability is efficiently managed through normalized scoring, thereby achieving optimal performance without introducing unnecessary complexity.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}