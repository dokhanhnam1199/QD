{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Calculate priority scores by balancing normalized waste and fit availability, enhancing decision-making for Online BPP.\"\"\"\n    # Ensure no negative waste values and set to inf for bins that cannot fit the item\n    waste = bins_remain_cap - item\n    waste[waste < 0] = np.inf\n    \n    # Normalize waste\n    norm_waste = waste / (np.max(waste) + 1e-6)\n    \n    # Calculate direct fit availability (1 if item fits, 0 otherwise)\n    fit_availability = (bins_remain_cap >= item).astype(float)\n    \n    # Calculate priority scores combining normalized waste and fit availability\n    priority_scores = fit_availability / (norm_waste + 1e-6)\n    \n    return priority_scores\n\n[Heuristics 2nd]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(\n    item: float, \n    bins_remain_cap: np.ndarray, \n    weight_waste: float = 0.525600120393148, \n    epsilon: float = 7.891993987188095e-06) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins using a combination of fit availability and normalized waste minimization.\n    \"\"\"\n    can_fit = bins_remain_cap >= item\n    waste = (bins_remain_cap - item) / (np.max(bins_remain_cap) + epsilon)\n    waste[~can_fit] = 0\n    priority = can_fit * (1 - weight_waste * waste)\n    return priority\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritize bins by balancing fit availability and normalized waste minimization.\"\"\"\n    direct_fit = (bins_remain_cap >= item).astype(float)\n    waste_after_item = bins_remain_cap - item\n    normalized_waste = 1 - (waste_after_item / np.max(bins_remain_cap, initial=1))\n    normalized_waste = np.clip(normalized_waste, 0, 1)\n    priority_score = 0.7 * direct_fit + 0.3 * normalized_waste\n    return priority_score\n\n[Heuristics 4th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This heuristic focuses on minimizing waste while ensuring fit availability.\n    It normalizes the waste and balances it with fit availability to make informed decisions.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Ensure no division by zero and handle edge cases\n    bins_remain_cap = np.clip(bins_remain_cap, a_min=0, a_max=None)\n    \n    # Calculate waste for each bin if the item is added\n    waste = bins_remain_cap - item\n    \n    # Set negative waste to a high value to avoid adding items that exceed bin capacity\n    waste[waste < 0] = np.inf\n    \n    # Normalize the waste to ensure balanced decision-making\n    max_waste = np.max(waste)\n    min_waste = np.min(waste[waste != np.inf])\n    \n    if max_waste == min_waste:\n        # Avoid normalization when all values are the same\n        normalized_waste = waste\n    else:\n        normalized_waste = (waste - min_waste) / (max_waste - min_waste)\n    \n    # Prioritize bins with lower normalized waste and fit availability\n    priority_scores = 1 / (normalized_waste + 1e-6)\n    \n    return priority_scores\n\n[Heuristics 5th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Calculate priority scores by balancing normalized waste and fit availability, enhancing decision-making for Online BPP.\"\"\"\n    # Ensure no negative waste values and set to inf for bins that cannot fit the item\n    waste = bins_remain_cap - item\n    waste[waste < 0] = np.inf\n    \n    # Normalize waste\n    norm_waste = waste / (np.max(waste) + 1e-6)\n    \n    # Calculate direct fit availability (1 if item fits, 0 otherwise)\n    fit_availability = (bins_remain_cap >= item).astype(float)\n    \n    # Calculate priority scores combining normalized waste and fit availability\n    priority_scores = fit_availability / (norm_waste + 1e-6)\n    \n    return priority_scores\n\n[Heuristics 6th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(\n    item: float, \n    bins_remain_cap: np.ndarray, \n    weight_waste: float = 0.525600120393148, \n    epsilon: float = 7.891993987188095e-06) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins using a combination of fit availability and normalized waste minimization.\n    \"\"\"\n    can_fit = bins_remain_cap >= item\n    waste = (bins_remain_cap - item) / (np.max(bins_remain_cap) + epsilon)\n    waste[~can_fit] = 0\n    priority = can_fit * (1 - weight_waste * waste)\n    return priority\n\n[Heuristics 7th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This heuristic focuses on minimizing waste while ensuring fit availability.\n    It normalizes the waste and balances it with fit availability to make informed decisions.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the waste if the item is added to each bin\n    waste = bins_remain_cap - item\n\n    # Check fit availability: if item cannot fit, set priority to a low value\n    fit_availability = (waste >= 0).astype(float) * 1000  # High multiplier for available fits\n\n    # Normalize the waste to ensure it's within a reasonable range\n    max_waste = np.max(waste) if np.max(waste) != 0 else 1\n    normalized_waste = -waste / max_waste  # Minimizing waste is maximizing negative waste\n\n    # Combine fit availability and waste minimization\n    priority_scores = fit_availability + normalized_waste\n\n    return priority_scores\n\n[Heuristics 8th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins using a combination of fit availability and normalized waste minimization.\n    \"\"\"\n    can_fit = bins_remain_cap >= item\n    waste = (bins_remain_cap - item) / (np.max(bins_remain_cap) + 1e-6)\n    waste[~can_fit] = 0\n    weight_waste = 1.5\n    priority = can_fit * (1 - weight_waste * waste)\n    return priority\n\n[Heuristics 9th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins by fit availability and weighted normalized waste minimization.\n    \"\"\"\n    can_fit = bins_remain_cap >= item\n    waste = (bins_remain_cap - item) / (np.max(bins_remain_cap) + 1e-6)\n    waste[~can_fit] = 0\n    weight = 1.5562183029491476\n    priority = can_fit * (1 - weight * waste)\n    return priority\n\n[Heuristics 10th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority score for each bin combining fit availability and normalized waste minimization.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Returns:\n        Array of priority scores for each bin.\n    \"\"\"\n    # Check fit availability first\n    fit_availability = (bins_remain_cap >= item).astype(float)\n    \n    # Calculate normalized remaining capacity\n    max_cap = np.max(bins_remain_cap)\n    min_cap = np.min(bins_remain_cap)\n    if max_cap == min_cap:\n        normalized_cap = np.ones_like(bins_remain_cap)\n    else:\n        normalized_cap = (bins_remain_cap - min_cap) / (max_cap - min_cap)\n    \n    # Calculate normalized waste\n    normalized_waste = (bins_remain_cap - item) / max_cap\n    \n    # Combine fit availability with normalized capacity and waste\n    priority_score = fit_availability * (normalized_cap * (1 - normalized_waste))\n    \n    return priority_score\n\n[Heuristics 11th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority score for each bin combining fit availability and normalized waste minimization.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Returns:\n        Array of priority scores for each bin.\n    \"\"\"\n    # Check fit availability first\n    fit_availability = (bins_remain_cap >= item).astype(float)\n    \n    # Calculate normalized remaining capacity\n    max_cap = np.max(bins_remain_cap)\n    min_cap = np.min(bins_remain_cap)\n    if max_cap == min_cap:\n        normalized_cap = np.ones_like(bins_remain_cap)\n    else:\n        normalized_cap = (bins_remain_cap - min_cap) / (max_cap - min_cap)\n    \n    # Calculate normalized waste\n    normalized_waste = (bins_remain_cap - item) / max_cap\n    \n    # Combine fit availability with normalized capacity and waste\n    priority_score = fit_availability * (normalized_cap * (1 - normalized_waste))\n    \n    return priority_score\n\n[Heuristics 12th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority score for each bin combining fit availability and normalized waste minimization.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Returns:\n        Array of priority scores for each bin.\n    \"\"\"\n    # Check fit availability first\n    fit_availability = (bins_remain_cap >= item).astype(float)\n    \n    # Calculate normalized remaining capacity\n    max_cap = np.max(bins_remain_cap)\n    min_cap = np.min(bins_remain_cap)\n    if max_cap == min_cap:\n        normalized_cap = np.ones_like(bins_remain_cap)\n    else:\n        normalized_cap = (bins_remain_cap - min_cap) / (max_cap - min_cap)\n    \n    # Calculate normalized waste\n    normalized_waste = (bins_remain_cap - item) / max_cap\n    \n    # Combine fit availability with normalized capacity and waste\n    priority_score = fit_availability * (normalized_cap * (1 - normalized_waste))\n    \n    return priority_score\n\n[Heuristics 13th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority score for each bin combining fit availability and normalized waste minimization.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Returns:\n        Array of priority scores for each bin.\n    \"\"\"\n    # Check fit availability first\n    fit_availability = (bins_remain_cap >= item).astype(float)\n    \n    # Calculate normalized remaining capacity\n    max_cap = np.max(bins_remain_cap)\n    min_cap = np.min(bins_remain_cap)\n    if max_cap == min_cap:\n        normalized_cap = np.ones_like(bins_remain_cap)\n    else:\n        normalized_cap = (bins_remain_cap - min_cap) / (max_cap - min_cap)\n    \n    # Calculate normalized waste\n    normalized_waste = (bins_remain_cap - item) / max_cap\n    \n    # Combine fit availability with normalized capacity and waste\n    priority_score = fit_availability * (normalized_cap * (1 - normalized_waste))\n    \n    return priority_score\n\n[Heuristics 14th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority score for each bin combining fit availability and normalized waste minimization.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Returns:\n        Array of priority scores for each bin.\n    \"\"\"\n    # Check fit availability first\n    fit_availability = (bins_remain_cap >= item).astype(float)\n    \n    # Calculate normalized remaining capacity\n    max_cap = np.max(bins_remain_cap)\n    min_cap = np.min(bins_remain_cap)\n    if max_cap == min_cap:\n        normalized_cap = np.ones_like(bins_remain_cap)\n    else:\n        normalized_cap = (bins_remain_cap - min_cap) / (max_cap - min_cap)\n    \n    # Calculate normalized waste\n    normalized_waste = (bins_remain_cap - item) / max_cap\n    \n    # Combine fit availability with normalized capacity and waste\n    priority_score = fit_availability * (normalized_cap * (1 - normalized_waste))\n    \n    return priority_score\n\n[Heuristics 15th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins using a balanced approach of fit availability and normalized waste minimization.\n    \"\"\"\n    can_fit = bins_remain_cap >= item\n    norm_remain_cap = bins_remain_cap / (np.max(bins_remain_cap) + 1e-6)\n    waste = (bins_remain_cap - item) / (np.max(bins_remain_cap) + 1e-6)\n    waste[~can_fit] = 0  # Ensure bins that cannot fit the item have zero priority\n    priority = can_fit * (norm_remain_cap - 0.75 * waste)  # Weighted balance between fit and waste minimization\n    return priority\n\n[Heuristics 16th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority score combining fit availability and normalized waste minimization.\n    \"\"\"\n    fit_availability = bins_remain_cap >= item\n    normalized_waste = np.where(fit_availability, item / bins_remain_cap, np.inf)\n    priority_scores = np.where(fit_availability, 1 / (normalized_waste + 1e-6), -np.inf)\n    return priority_scores\n\n[Heuristics 17th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority score combining fit availability and normalized waste minimization.\n    \"\"\"\n    fit_availability = bins_remain_cap >= item\n    normalized_waste = np.where(fit_availability, item / bins_remain_cap, np.inf)\n    priority_scores = np.where(fit_availability, 1 / (normalized_waste + 1e-6), -np.inf)\n    return priority_scores\n\n[Heuristics 18th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins using a balanced approach of fit availability and normalized waste minimization.\n    \"\"\"\n    can_fit = bins_remain_cap >= item\n    norm_remain_cap = bins_remain_cap / (np.max(bins_remain_cap) + 1e-6)\n    waste = (bins_remain_cap - item) / (np.max(bins_remain_cap) + 1e-6)\n    waste[~can_fit] = 0  # Ensure bins that cannot fit the item have zero priority\n    priority = can_fit * (norm_remain_cap - 0.75 * waste)  # Weighted balance between fit and waste minimization\n    return priority\n\n[Heuristics 19th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority score combining fit availability and normalized waste minimization.\n    \"\"\"\n    fit_availability = bins_remain_cap >= item\n    normalized_waste = np.where(fit_availability, item / bins_remain_cap, np.inf)\n    priority_scores = np.where(fit_availability, 1 / (normalized_waste + 1e-6), -np.inf)\n    return priority_scores\n\n[Heuristics 20th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority score combining fit availability and normalized waste minimization.\n    \"\"\"\n    fit_availability = bins_remain_cap >= item\n    normalized_waste = np.where(fit_availability, item / bins_remain_cap, np.inf)\n    priority_scores = np.where(fit_availability, 1 / (normalized_waste + 1e-6), -np.inf)\n    return priority_scores\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}