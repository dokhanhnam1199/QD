{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This heuristic aims to minimize waste by prioritizing bins that have the best fit available for the item.\n    It uses a normalized score based on the difference between the item size and the remaining capacity,\n    ensuring that bins which can fit the item with the least leftover space are prioritized.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the waste if the item is placed in each bin\n    waste = bins_remain_cap - item\n    \n    # Set waste to a large positive value for bins that cannot fit the item\n    waste[waste < 0] = np.inf\n    \n    # Normalize waste to prioritize bins with the least leftover space\n    normalized_waste = (waste - np.min(waste)) / (np.max(waste) - np.min(waste) + 1e-6)\n    \n    # Priority is the inverse of normalized waste: lower waste means higher priority\n    priority_score = 1 - normalized_waste\n    \n    return priority_score\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Prioritizes bins based on remaining capacity and normalized waste, balancing fit availability and waste minimization.\"\"\"\n    # Calculate remaining capacity after adding the item\n    potential_remain_cap = bins_remain_cap - item\n    \n    # Calculate waste as the difference between current capacity and capacity after adding the item\n    waste = bins_remain_cap - potential_remain_cap\n    \n    # Normalize waste scores to ensure consistency across different bin capacities\n    max_bin_cap = np.max(bins_remain_cap)\n    normalized_waste = waste / (max_bin_cap + 1e-6)\n    \n    # Calculate priority using a combination of normalized waste and remaining capacity\n    priority_scores = 0.5 * (1 - normalized_waste) + 0.5 * (bins_remain_cap / max_bin_cap)\n    \n    # Set priority to zero for bins where the item cannot be added due to insufficient capacity\n    priority_scores[potential_remain_cap < 0] = 0\n    \n    return priority_scores\n\n### Analyze & experience\n- Comparing (best) vs (worst), we see that the best heuristics effectively manage to normalize waste, consider item fit availability, and aim to minimize leftover space, providing a clear priority for bin selection. In contrast, the worst heuristics prioritize bins sineoidally based on remaining capacity without considering item fit, leading to less effective waste minimization. (second best) vs (second worst) shows a similar trend, with the second-best emphasizing balanced minimization of waste and remaining capacity, while the second-worst focuses solely on fit availability without proper normalization. Comparing (1st) vs (2nd), we see minimal differences in methodology, with the second option using a sinusoidal adjustment for waste, which is not necessary. (3rd) vs (4th) illustrates a shift from direct waste normalization to sinusoidal waste consideration, decreasing effectiveness. Comparing (second worst) vs (worst), we see the worst considering sinusoidal fit without fit availability checks, rendering it ineffective. Overall: Best heuristics prioritize fit availability and normalized waste minimization effectively, whereas worst heuristics focus incorrectly on sinusoidal adjustments without considering critical item fit criteria.\n- \n- **Keywords**: Normalization, Waste Minimization, Fit Availability, Robust Logic\n- **Advice**: \n  - Focus on designing heuristics that directly minimize waste and maximize fit availability.\n  - Use normalization to create a clear and consistent scoring system for fit and waste.\n  - Simplify logic to ensure heuristics are robust and avoid unnecessary complexity.\n- **Avoid**: \n  - Complex sinusoidal adjustments and inverted capacity approaches.\n  - Unnecessary logic or processes that do not contribute to efficiency or effectiveness.\n- **Explanation**: \n  - Simplifying heuristics and focusing on clear, direct strategies ensures they are more effective and easier to implement. Normalization provides a consistent framework, preventing issues like division by zero and ensuring robust prioritization. By avoiding complex adjustments and unnecessary additions, you maintain a focus on the primary objectives, leading to better optimization outcomes.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}