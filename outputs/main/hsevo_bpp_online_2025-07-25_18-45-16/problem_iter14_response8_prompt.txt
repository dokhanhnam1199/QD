{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This heuristic emphasizes normalization, waste minimization, and simplicity.\n    It calculates priority based on the normalized remaining capacity after adding the item,\n    aiming to minimize waste and fill bins efficiently.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate remaining capacity after adding the item\n    potential_remain_cap = bins_remain_cap - item\n    \n    # Calculate waste as the difference between current capacity and capacity after adding the item\n    waste = bins_remain_cap - potential_remain_cap\n    \n    # Normalize waste scores to ensure consistency across different bin capacities\n    max_bin_cap = np.max(bins_remain_cap)\n    normalized_waste = waste / max_bin_cap\n    \n    # Prioritize bins that minimize waste when the item is added\n    priority_scores = 1 - normalized_waste  # Lower waste means higher priority\n    \n    # Set priority to zero for bins where the item cannot be added due to insufficient capacity\n    priority_scores[potential_remain_cap < 0] = 0\n    \n    return priority_scores\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This heuristic emphasizes normalization, waste minimization, and simplicity.\n    It calculates priority based on the normalized remaining capacity after adding the item,\n    aiming to minimize waste and fill bins efficiently.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate remaining capacity after adding the item\n    potential_remain_cap = bins_remain_cap - item\n    \n    # Define waste as the difference between the bin size and the potential remaining capacity\n    # Assuming bin size is the maximum capacity initially available\n    bin_size = np.max(bins_remain_cap + item)\n    waste = bin_size - potential_remain_cap\n    \n    # Normalize waste to ensure all values are between 0 and 1\n    normalized_waste = waste / bin_size\n    \n    # Calculate priority score as the inverse of normalized waste\n    # Lower waste leads to higher priority\n    priority_scores = 1.0 - normalized_waste\n    \n    # Ensure bins with negative remaining capacity (where item can't fit) get the lowest priority\n    priority_scores[potential_remain_cap < 0] = 0\n    \n    return priority_scores\n\n### Analyze & experience\n- Comparing (best) vs (worst), we see that the best heuristic (1st) effectively balances fit availability and normalized waste, leading to well-distributed items across bins. The worst heuristic (19th) incorrectly calculates priority based on positive normalized waste, deterring optimal bin selection.\n\n(Second best) vs (second worst) showcases a stark difference in normalization and waste handling. The second best (2nd) minimizes waste using normalized scores while ignoring unavailable bins, whereas the second worst (18th) assigns priority based on positive normalized waste, similar to the worst.\n\nComparing (1st) vs (2nd), we see a nuanced difference: the best heuristic considers the availability and normalized waste, while the second best focuses solely on waste minimization after normalizing.\n\n(3rd) vs (4th) highlights that the third heuristic uses a sinusoidal function to prioritize almost full bins, while the fourth focuses on normalized waste, leading to different strategies for filling bins efficiently.\n\nComparing (second worst) vs (worst), we see repetitive logic, suggesting a lack of diversity in heuristic approaches in the bottom rankings.\n\nOverall:\n- \n- **Keywords:** Normalization, Waste Minimization, Fit Availability, Simplicity\n- **Advice:** Focus on clear, normalized logic to evaluate fit availability and directly reduce waste. Ensure robustness in normalization techniques.\n- **Avoid:** Complex inverted capacity approaches, repetitive logic, and unnecessary optimization layers.\n- **Explanation:** Simplify heuristic design by prioritizing straightforward techniques that directly address the core objective of minimizing waste while ensuring that bin fit availability is efficiently managed through normalized scoring, thereby achieving optimal performance without introducing unnecessary complexity.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}