{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This design implements a heuristic based on the remaining capacity of the bins.\n    Is a priority score based on filling tighter bins first, aiming to close the \n    bins as much as possible to trigger first fit for new bins sooner.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Inverse of remaining capacity (sinusoidal function to prioritize the almost full bins)\n    return 1.0 / (bins_remain_cap + 1e-6) * np.sin(np.pi / 2 * (bins_remain_cap / (np.max(bins_remain_cap) + 1e-6)))\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # High priority if adding this item leaves minimal space in the bin\n    ifbinsfit = bins_remain_cap >= item\n    priority = np.where(ifbinsfit, bins_remain_cap - item, -np.inf)\n    # Give higher priority to bins that were less initially full (more empty space at the start)\n    relative_space_left_factor = bins_remain_cap / np.max(bins_remain_cap, initial=1.0)\n    # Combine these two factors into a priority score\n    return priority + relative_space_left_factor\n\n### Analyze & experience\n- Comparing (best) vs (worst), we see that the best heuristics focus on balancing the reduction in waste with the initial fullness of bins, ensuring items fit without penalizing overly low capacity bins. The worst heuristics prioritize overly full bins using algorithms that can lead to high wastage or infeasibility. Comparing (second best) vs (second worst), we observe that the second best uses a combination of proximity to item size and space reduction, while the second worst inverts capacity for an unnecessary sinusoidal function that does not effectively manage space or reduce waste. Comparing (1st) vs (2nd), we see the same underlying principle with minor variations in formula implementation but both aim to minimize waste effectively. (3rd) vs (4th) show that while both prioritize nearly full bins, the sinusoidal function in (3rd) adds unnecessary complexity without enhancing performance. Comparing (second worst) vs (worst), we see that both prioritize filling nearly full bins but the worst approach does so in a more convoluted manner without efficiency gains. Overall: The best heuristics efficiently manage waste and balance initial space availability without unnecessary complexity.\n- \n- **Keywords**: Waste reduction, bin availability, initial capacity, performance enhancement, simplicity\n- **Advice**: Focus on straightforward methods to enhance bin usage efficiency without introducing unnecessary complexity.\n- **Avoid**: Inverted capacity models or overly complicated algorithms that do not significantly improve system performance.\n- **Explanation**: By concentrating on basic strategies to optimize bin usage and avoid convoluted solutions, you can achieve better performance and easier implementation of your heuristics.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}