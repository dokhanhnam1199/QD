{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Prioritizes bins based on fit availability and normalized waste minimization.\n    \"\"\"\n    can_fit = bins_remain_cap >= item\n    safe_max_cap = np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else 1\n    space_left = bins_remain_cap - item\n    priority = can_fit * (-space_left / safe_max_cap)\n    return priority\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Prioritizes bins by combining fit availability and normalized waste minimization.\"\"\"\n    # Calculate remaining capacity after adding the item\n    potential_remain_cap = bins_remain_cap - item\n    \n    # Calculate waste as the difference between current capacity and capacity after adding the item\n    waste = bins_remain_cap - potential_remain_cap\n    \n    # Normalize waste scores\n    max_bin_cap = np.max(bins_remain_cap)\n    normalized_waste = waste / (max_bin_cap + 1e-6)\n    \n    # Calculate priority score based on fit availability and normalized waste\n    can_fit = (bins_remain_cap >= item).astype(float)\n    priority_score = can_fit * (1.0 - normalized_waste)\n    \n    # Ensure items are not placed into bins they cannot fit into\n    priority_score[potential_remain_cap < 0] = 0.0\n    \n    return priority_score\n\n### Analyze & experience\n- Comparing (best) vs (worst), we see that the best heuristics effectively manage to normalize waste, consider item fit availability, and aim to minimize leftover space, providing a clear priority for bin selection. In contrast, the worst heuristics prioritize bins sineoidally based on remaining capacity without considering item fit, leading to less effective waste minimization. (second best) vs (second worst) shows a similar trend, with the second-best emphasizing balanced minimization of waste and remaining capacity, while the second-worst focuses solely on fit availability without proper normalization. Comparing (1st) vs (2nd), we see minimal differences in methodology, with the second option using a sinusoidal adjustment for waste, which is not necessary. (3rd) vs (4th) illustrates a shift from direct waste normalization to sinusoidal waste consideration, decreasing effectiveness. Comparing (second worst) vs (worst), we see the worst considering sinusoidal fit without fit availability checks, rendering it ineffective. Overall: Best heuristics prioritize fit availability and normalized waste minimization effectively, whereas worst heuristics focus incorrectly on sinusoidal adjustments without considering critical item fit criteria.\n- \n- **Keywords**: Normalization, Waste Minimization, Fit Availability, Robust Logic\n- **Advice**: \n  - Focus on designing heuristics that directly minimize waste and maximize fit availability.\n  - Use normalization to create a clear and consistent scoring system for fit and waste.\n  - Simplify logic to ensure heuristics are robust and avoid unnecessary complexity.\n- **Avoid**: \n  - Complex sinusoidal adjustments and inverted capacity approaches.\n  - Unnecessary logic or processes that do not contribute to efficiency or effectiveness.\n- **Explanation**: \n  - Simplifying heuristics and focusing on clear, direct strategies ensures they are more effective and easier to implement. Normalization provides a consistent framework, preventing issues like division by zero and ensuring robust prioritization. By avoiding complex adjustments and unnecessary additions, you maintain a focus on the primary objectives, leading to better optimization outcomes.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}