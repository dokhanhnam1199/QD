{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This design implements a heuristic based on the remaining capacity of the bins.\n    Is a priority score based on filling tighter bins first, aiming to close the \n    bins as much as possible to trigger first fit for new bins sooner.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Inverse of remaining capacity (sinusoidal function to prioritize the almost full bins)\n    return 1.0 / (bins_remain_cap + 1e-6) * np.sin(np.pi / 2 * (bins_remain_cap / (np.max(bins_remain_cap) + 1e-6)))\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Combines proximity to item size and space reduction, prioritizing bins that fit item with minimal waste.\"\"\"\n    # Ensure the item can fit in the bin\n    can_fit = (bins_remain_cap >= item).astype(float)\n    # Proximity to item size\n    close_bins = np.clip(bins_remain_cap - item, 0, 1)\n    # Space efficiency after placing the item\n    space_efficiency = 1 - ((bins_remain_cap - item) / bins_remain_cap)\n    # Combine priorities\n    priority_score = can_fit * (close_bins + space_efficiency)\n    return priority_score\n\n### Analyze & experience\n- Comparing (best) vs (worst), we see that the best heuristics directly prioritizes bins with least remaining capacity after adding the item while considering fit availability, minimizing waste efficiently. The worst heuristic uses a sinusoidal function and normalization which makes it less straightforward to interpret and less effective. \n(second best) vs (second worst) \u2014 The second-best heuristic focuses on minimizing waste with normalized scores, ensuring that bins with least waste get prioritized properly, unlike the second-worst which uses random imports and thresholds inefficiently.\nComparing (1st) vs (2nd), we see minimal differences in logic, both aiming to minimize waste, but the first uses cleaner logic with a clear approach.\n(3rd) vs (4th) \u2014 Both similar, but minor optimizations in the 3rd make it slightly better in readability and effectiveness.\nComparing (second worst) vs (worst), we see a shift from somewhat rational logic combining waste minimization and normalization to an overly complicated heuristic with unnecessary imports and mathematical transforms.\nOverall: Best heuristics minimize waste, are straightforward, and prioritize fit availability efficiently; worst heuristics are overly complex or incorrect, leading to inefficient performance.\n- \n- **Keywords**: Simplicity, Clear Logic, Waste Reduction, Direct Targeting, Normalization, Resource Availability\n\n- **Advice**: Design heuristics with a direct focus on minimizing waste through straightforward logic and normalized assessments. Ensure that each component of the heuristic directly contributes to achieving the minimal waste objective.\n\n- **Avoid**: Complex algorithms, unnecessary imports, indirect waste reduction methods, and approaches that do not clearly improve performance.\n\n- **Explanation**: By focusing on simplicity and direct waste minimization, the heuristic becomes more effective and easier to fine-tune. Normalization ensures consistent scoring, while avoiding unnecessary complexity prevents overcomplication and potential inefficiencies. Direct targeting ensures that all actions contribute directly to the primary goal, improving both speed and effectiveness.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}