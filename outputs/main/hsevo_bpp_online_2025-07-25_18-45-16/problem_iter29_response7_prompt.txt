{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This heuristic focuses on minimizing waste while ensuring fit availability.\n    It normalizes the waste and balances it with fit availability to make informed decisions.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the waste if the item is added to each bin\n    waste = bins_remain_cap - item\n\n    # Check fit availability: if item cannot fit, set priority to a low value\n    fit_availability = (waste >= 0).astype(float) * 1000  # High multiplier for available fits\n\n    # Normalize the waste to ensure it's within a reasonable range\n    max_waste = np.max(waste) if np.max(waste) != 0 else 1\n    normalized_waste = -waste / max_waste  # Minimizing waste is maximizing negative waste\n\n    # Combine fit availability and waste minimization\n    priority_scores = fit_availability + normalized_waste\n\n    return priority_scores\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Returns priority score combining fit availability and normalized waste minimization.\n    \"\"\"\n    fit_availability = bins_remain_cap >= item\n    normalized_waste = np.where(fit_availability, item / bins_remain_cap, np.inf)\n    priority_scores = np.where(fit_availability, 1 / (normalized_waste + 1e-6), -np.inf)\n    return priority_scores\n\n### Analyze & experience\n- Comparing (best) vs (worst), we see that the best code effectively handles edge cases, normalizes waste in a balanced way, and includes fit availability as a key factor. The worst heuristic repeats the same flawed logic multiple times, using inverse waste without normalization correctly and assigning infinite priority values to certain cases. (Second best) vs (second worst) highlights the importance of correctly handling non-fitting items and normalizing waste to ensure reasonable priority values. Comparing (1st) vs (2nd), the first function normalizes waste by considering the maximum capacity effectively, whereas the second sometimes assigns zero waste to items that cannot fit, which is inconsistent. (3rd) vs (4th) shows that the third function applies a weighted balance between fit availability and waste normalization more intuitively. Comparing (second worst) vs (worst), both have the same issues of incorrect normalization and infinite priority assignments for non-fitting items. Overall: The best heuristics prioritize normalization correctness and balanced weighting between fit availability and waste minimization, while the worst neglect these factors and repeat inefficient code.\n- \n- **Keywords:** Normalization, Fit Availability, Edge Case Handling, Direct Waste Minimization\n- **Advice:**  \n  - Prioritize direct waste minimization using normalized metrics.\n  - Ensure robust edge case handling and flexible dynamic weighting.\n  - Incorporate explicit fit checks and parameter fine-tuning.\n  - Design for clarity and simplicity, avoiding unnecessary complexity.\n- **Avoid:**  \n  - Complex inverted capacity approaches.\n  - Sinusoidal adjustments and repetitive logic.\n  - Over-reliance on initial bin availability without considering capacity needs.\n- **Explanation:**  \n  By focusing on normalization and direct waste minimization, heuristics become more effective and efficient. Incorporating fit checks and parameter fine-tuning enhances decision-making, while robust edge case handling ensures reliability. Avoiding unnecessary complexity makes heuristics easier to understand and maintain, directly contributing to better performance in optimization problems.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}