{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This design increases priority for bins that have more remaining capacity compared to the item, but also penalizes \n    overly large empty spaces left in bins. Smaller empty spaces left after adding the item receive a higher priority score.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Ensure that the item can actually fit into the bin\n    can_fit = bins_remain_cap >= item\n    space_left = bins_remain_cap - item\n    # Penalty for too much leftover space, decreased when the remaining space is minimal\n    priority = can_fit * (1 - (space_left / bins_remain_cap))\n    return priority\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This implementation considers both the remaining capacity and the number of\n    bins used considering future placements. It calculates the reduction in\n    potential waste (as given by the difference between the remaining capacity and\n    the item size) and penalizes bins that have less room than the item.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate waste reduction if item is added to each bin\n    waste_reduction = bins_remain_cap - item\n    \n    # Items that cannot fit in the bin get a very low priority\n    priority_score = np.where(waste_reduction >= 0, waste_reduction, -1000)\n    \n    # Encourage using less full bins slightly by adding some epsilon based on current capacity\n    epsilon = 0.01\n    encouragement = (bins_remain_cap - np.max(bins_remain_cap)) * epsilon\n    priority_score_with_encouragement = priority_score + encouragement\n    \n    return priority_score_with_encouragement\n\n### Analyze & experience\n- Comparing (best) vs (worst), we see that the best heuristics focus on balancing the reduction in waste with the initial fullness of bins, ensuring items fit without penalizing overly low capacity bins. The worst heuristics prioritize overly full bins using algorithms that can lead to high wastage or infeasibility. Comparing (second best) vs (second worst), we observe that the second best uses a combination of proximity to item size and space reduction, while the second worst inverts capacity for an unnecessary sinusoidal function that does not effectively manage space or reduce waste. Comparing (1st) vs (2nd), we see the same underlying principle with minor variations in formula implementation but both aim to minimize waste effectively. (3rd) vs (4th) show that while both prioritize nearly full bins, the sinusoidal function in (3rd) adds unnecessary complexity without enhancing performance. Comparing (second worst) vs (worst), we see that both prioritize filling nearly full bins but the worst approach does so in a more convoluted manner without efficiency gains. Overall: The best heuristics efficiently manage waste and balance initial space availability without unnecessary complexity.\n- \n- **Keywords**: Waste reduction, bin availability, initial capacity, performance enhancement, simplicity\n- **Advice**: Focus on straightforward methods to enhance bin usage efficiency without introducing unnecessary complexity.\n- **Avoid**: Inverted capacity models or overly complicated algorithms that do not significantly improve system performance.\n- **Explanation**: By concentrating on basic strategies to optimize bin usage and avoid convoluted solutions, you can achieve better performance and easier implementation of your heuristics.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}