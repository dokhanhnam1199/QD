{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Calculates priority score for bins by normalizing waste and ensuring fit availability.\"\"\"\n    \n    # Calculate waste if the item is placed in each bin\n    waste = bins_remain_cap - item\n    \n    # Set waste to a large positive value for bins that cannot fit the item\n    waste[waste < 0] = np.inf\n    \n    # Normalize waste to prioritize bins with the least leftover space\n    normalized_waste = (waste - np.min(waste)) / (np.max(waste) - np.min(waste) + 1e-6)\n    \n    # Ensure bins that cannot fit the item have zero priority\n    priority_score = np.where(waste == np.inf, 0, 1 - normalized_waste)\n    \n    return priority_score\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This heuristic aims to minimize waste and maximize fit availability by considering\n    the normalization of remaining capacity and direct waste reduction.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Normalize the remaining capacities\n    norm_remain_cap = bins_remain_cap / np.max(bins_remain_cap)\n    \n    # Calculate the waste if the item is added to each bin\n    waste = norm_remain_cap - item / np.max(bins_remain_cap)\n    \n    # Ensure no negative waste values\n    waste = np.clip(waste, 0, 1)\n    \n    # Priority is higher for bins with less waste and more available capacity\n    priority_scores = norm_remain_cap - waste\n    \n    return priority_scores\n\n### Analyze & experience\n- Comparing (best) vs (worst), we see that the best heuristic (1st) incorporates additional parameters for fine-tuning and explicitly considers normalized waste minimization with a balanced weight, while the worst (20th) repeatedly calculates and normalizes waste without clearly differentiating between bins that cannot fit the item and those that can, leading to less precise prioritization.\n(Second best) vs (second worst), we see that the second best heuristic (2nd) also uses normalized waste minimization and checks item fit, but lacks the fine-tuning parameters of the best heuristic. The second worst (19th) is nearly identical to the worst, showing redundancy without added value.\nComparing (1st) vs (2nd), we see the best heuristic nuances item placement with weighted considerations, whereas the second-best uses a straightforward waste minimization approach without adjustments.\n(3rd) vs (4th), we see the third heuristic accounting for negative waste by setting it to infinity and normalizing, while the fourth improves on this by scaling normalized waste with max and min waste values for better differentiation.\nComparing (second worst) vs (worst), we see no difference, suggesting redundant efforts in both heuristics.\nOverall:\n- \n- **Keywords:** Normalization, Waste Minimization, Fit Availability, Robustness\n- **Advice:** Focus on normalized waste minimization, explicitly check fit availability, parameter tuning, and robust handling of edge cases.\n- **Avoid:** Unnecessary complexity, sinusoidal adjustments, redundant logic.\n- **Explanation:** Design heuristics with simplicity and clear logic at their core. Normalize waste to ensure balanced prioritization without overcomplicating the process. Directly assess fit availability and focus on edge cases to enhance robustness. Avoid unnecessary refinements and adjustments that do not significantly improve efficiency or effectiveness.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}