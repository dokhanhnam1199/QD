{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Combines waste minimization with normalized capacity to prioritize bins effectively.\"\"\"\n    waste = bins_remain_cap - item\n    priority_scores = np.where(waste >= 0, waste / (bins_remain_cap + 1e-6), -np.inf)\n    return -priority_scores\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Combines waste minimization with bin balance to prioritize bins effectively.\"\"\"\n    can_fit = (bins_remain_cap >= item).astype(float)\n    waste = bins_remain_cap - item\n    balance_factor = 1 - (waste / bins_remain_cap.mean())\n    priority_scores = can_fit * (waste + balance_factor)\n    return priority_scores\n\n### Analyze & experience\n- Comparing (best) Heuristics 1st vs (worst) Heuristics 20th, we see that the best avoids division by zero and properly combines waste minimization and fit availability with normalization. The worst does not account for zero division safeguard and improperly combines waste with balance, leading to inconsistent priority scores. Comparing (second best) Heuristics 2nd vs (second worst) Heuristics 19th, both minimize waste and consider fit availability but the second best consistently normalizes waste by capacity, enhancing prioritization. Overall:\n- \n- **Keywords:** Normalization, Waste Minimization, Clear Definitions, Robust Prioritization, Simplicity\n\n- **Advice:**\n  - Emphasize robust normalization techniques to ensure consistency.\n  - Design criteria for clear definitions of waste and fit to enhance heuristic decision-making.\n  - Focus on simplicity in algorithm logic to maintain clarity and efficiency.\n\n- **Avoid:**\n  - Complex inverted capacity approaches or any method that introduces unnecessary complexity.\n  - Indirect targeting of the primary objective (minimizing waste).\n\n- **Explanation:** By focusing on these elements, the heuristic design can achieve a balance between functionality and simplicity. Normalization ensures that all inputs are on the same scale, preventing bias. Clear definitions of what constitutes waste and fit allow the heuristic to make informed decisions. Simplicity ensures that the heuristic is easy to understand, implement, and maintain, reducing the risk of errors and enhancing performance. Avoiding unnecessary complexity maintains the focus on directly minimizing waste, ensuring that the heuristic remains effective and efficient.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}