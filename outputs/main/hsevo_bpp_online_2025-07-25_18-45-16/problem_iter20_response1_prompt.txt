{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    item: float, \n    bins_remain_cap: np.ndarray, \n    min_max_bin_cap: float = 1.5353042666483478,\n    fit_threshold: float = -0.11934595675780646,\n    weight_normalized_waste: float = 1.5470946865621147) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins by combining fit availability and normalized waste minimization.\n    \"\"\"\n    can_fit = bins_remain_cap >= item + fit_threshold\n    space_left = bins_remain_cap - item\n    max_bin_cap = np.max(bins_remain_cap) if np.max(bins_remain_cap) > min_max_bin_cap else min_max_bin_cap\n    normalized_waste = space_left / max_bin_cap\n    priority = can_fit * (1 - weight_normalized_waste * normalized_waste)\n    return priority\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Combines fit availability and normalized waste minimization for effective bin selection.\"\"\"\n    can_fit = (bins_remain_cap >= item).astype(float)\n    potential_remain_cap = bins_remain_cap - item\n    waste = bins_remain_cap - potential_remain_cap\n    normalized_waste = waste / (np.max(bins_remain_cap) + 1e-6)\n    priority_score = can_fit * (1.0 - normalized_waste)\n    return priority_score\n\n### Analyze & experience\n- Comparing (best) vs (worst), we see that the best heuristic (1st) incorporates additional parameters for fine-tuning and explicitly considers normalized waste minimization with a balanced weight, while the worst (20th) repeatedly calculates and normalizes waste without clearly differentiating between bins that cannot fit the item and those that can, leading to less precise prioritization.\n(Second best) vs (second worst), we see that the second best heuristic (2nd) also uses normalized waste minimization and checks item fit, but lacks the fine-tuning parameters of the best heuristic. The second worst (19th) is nearly identical to the worst, showing redundancy without added value.\nComparing (1st) vs (2nd), we see the best heuristic nuances item placement with weighted considerations, whereas the second-best uses a straightforward waste minimization approach without adjustments.\n(3rd) vs (4th), we see the third heuristic accounting for negative waste by setting it to infinity and normalizing, while the fourth improves on this by scaling normalized waste with max and min waste values for better differentiation.\nComparing (second worst) vs (worst), we see no difference, suggesting redundant efforts in both heuristics.\nOverall:\n- \n- **Keywords:** Normalization, Waste Minimization, Fit Availability, Robustness\n- **Advice:** Focus on normalized waste minimization, explicitly check fit availability, parameter tuning, and robust handling of edge cases.\n- **Avoid:** Unnecessary complexity, sinusoidal adjustments, redundant logic.\n- **Explanation:** Design heuristics with simplicity and clear logic at their core. Normalize waste to ensure balanced prioritization without overcomplicating the process. Directly assess fit availability and focus on edge cases to enhance robustness. Avoid unnecessary refinements and adjustments that do not significantly improve efficiency or effectiveness.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}