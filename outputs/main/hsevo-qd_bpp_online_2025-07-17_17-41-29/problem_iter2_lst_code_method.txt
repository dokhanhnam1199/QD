{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version incorporates a 'fitability' score and randomness\n    inspired by quantum probabilities.  We also include a preference\n    for bins that are nearly full *after* the item is placed, mimicking\n    a 'least waste' approach, and a penalty for exceeding bin capacity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Fitability Score: How well the item fits (lower is better, but small)\n    fitability = np.abs(bins_remain_cap - item)\n\n    # Remaining Capacity Ratio:  Smaller ratio means almost full bin.\n    remaining_ratio = np.clip((bins_remain_cap - item) / np.mean(bins_remain_cap), a_min=0.0, a_max=1.0)  #prevent negative and scaling issues\n    # Preference for bins that are nearly full AFTER placement. Logarithm amplifies the preference for nearly empty space after placement\n    nearly_full_priority = -np.log(remaining_ratio + 0.001)  # Avoid log(0)\n\n    # Penalty for exceeding capacity\n    overfill_penalty = np.where(item > bins_remain_cap, -1e9, 0) # Large negative penalty\n\n    # \"Quantum\" Randomness: add tiny random variations\n    randomness = np.random.rand(len(bins_remain_cap)) * 0.01\n\n    # Combining Scores: weighted sum\n    priorities = (\n        -fitability * 0.5\n        + nearly_full_priority * 1.0\n        + overfill_penalty\n        + randomness\n    )\n\n    return priorities\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Calculate waste if the item is placed in the bin\n    waste = bins_remain_cap - item\n\n    # Give high priority to bins where the item fits and waste is minimized\n    for i, w in enumerate(waste):\n        if w >= 0:\n            priorities[i] = 1 / (w + 0.00001)  # Adding a small constant to avoid division by zero\n\n    # Penalize bins where the item doesn't fit heavily\n    priorities[bins_remain_cap < item] = -1000  # or some other large negative number\n\n    #Boost the bins which has higher capacity closer to item size\n    cap_diff = np.abs(bins_remain_cap-item)\n    priorities = priorities - cap_diff/ np.max(bins_remain_cap)\n\n\n    return priorities\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priorities with a small default value to avoid division by zero and negative infinity issues.\n    priorities = np.zeros_like(bins_remain_cap, dtype=float) - 1e9 # Large negative value makes them very low priority by default.\n    \n    # Identify bins where the item can fit\n    fit_mask = bins_remain_cap >= item\n    \n    # Prioritize bins with tighter fits (minimize wasted space). Use a softmax approach for this.\n    # The idea is to assign higher priority to bins whose remaining capacity after placement will be small.\n    remaining_space = bins_remain_cap - item\n    remaining_space[~fit_mask] = np.inf # Make invalid spaces effectively infinitely large for softmax calculation\n\n    # Apply softmax after subtracting the minimum from remaining_space, which adds stability\n    remaining_space_shifted = remaining_space - np.min(remaining_space[fit_mask]) if np.any(fit_mask) else remaining_space\n    priorities[fit_mask] = np.exp(-remaining_space_shifted[fit_mask]) / np.sum(np.exp(-remaining_space_shifted[fit_mask])) if np.any(fit_mask) else 0.\n\n    # Boost the priority of bins that are nearly full to try and complete them, provided the item fits\n    nearly_full_threshold = 0.1  # e.g., Bin is considered nearly full if remaining capacity is less than 10% of item size\n    nearly_full_bins = (bins_remain_cap <= item * (1 + nearly_full_threshold)) & fit_mask\n\n    priorities[nearly_full_bins] += 1.0  # Add a boost to priority of nearly full bins\n    return priorities\n\n[Heuristics 4th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priorities with a base value (e.g., 0).\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Identify bins that can accommodate the item.\n    feasible_bins = bins_remain_cap >= item\n\n    # Give significantly higher priority to bins that can fit the item.  The smaller the remaining space after packing, the higher the priority\n    remaining_space = bins_remain_cap[feasible_bins] - item\n    priorities[feasible_bins] = 1.0 / (1e-9 + remaining_space)  # Avoid division by zero\n\n    # Penalize bins that cannot accommodate the item, making them less attractive.\n    priorities[~feasible_bins] = -np.inf\n\n    # Further refine the priority based on remaining capacity. Larger remaining cap after placing this item is preferable (up to a limit).\n    # Small penalty for unused capacity up to 50% of item size, but rapidly decreasing value if capacity > item*0.5\n    large_capacity = bins_remain_cap[feasible_bins] > item\n    remaining_over_cap = bins_remain_cap[feasible_bins][large_capacity] - item\n    priorities[feasible_bins][large_capacity] -= np.clip(remaining_over_cap**2, 0, (item * 0.5)**2) # Quadratic penalty\n\n    return priorities\n\n[Heuristics 5th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version incorporates a 'fitability' score and randomness\n    inspired by quantum probabilities.  We also include a preference\n    for bins that are nearly full *after* the item is placed, mimicking\n    a 'least waste' approach, and a penalty for exceeding bin capacity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Fitability Score: How well the item fits (lower is better, but small)\n    fitability = np.abs(bins_remain_cap - item)\n\n    # Remaining Capacity Ratio:  Smaller ratio means almost full bin.\n    remaining_ratio = np.clip((bins_remain_cap - item) / np.mean(bins_remain_cap), a_min=0.0, a_max=1.0)  #prevent negative and scaling issues\n    # Preference for bins that are nearly full AFTER placement. Logarithm amplifies the preference for nearly empty space after placement\n    nearly_full_priority = -np.log(remaining_ratio + 0.001)  # Avoid log(0)\n\n    # Penalty for exceeding capacity\n    overfill_penalty = np.where(item > bins_remain_cap, -1e9, 0) # Large negative penalty\n\n    # \"Quantum\" Randomness: add tiny random variations\n    randomness = np.random.rand(len(bins_remain_cap)) * 0.01\n\n    # Combining Scores: weighted sum\n    priorities = (\n        -fitability * 0.5\n        + nearly_full_priority * 1.0\n        + overfill_penalty\n        + randomness\n    )\n\n    return priorities\n\n[Heuristics 6th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priorities with a base value (e.g., 0).\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Identify bins that can accommodate the item.\n    feasible_bins = bins_remain_cap >= item\n\n    # Give significantly higher priority to bins that can fit the item.  The smaller the remaining space after packing, the higher the priority\n    remaining_space = bins_remain_cap[feasible_bins] - item\n    priorities[feasible_bins] = 1.0 / (1e-9 + remaining_space)  # Avoid division by zero\n\n    # Penalize bins that cannot accommodate the item, making them less attractive.\n    priorities[~feasible_bins] = -np.inf\n\n    # Further refine the priority based on remaining capacity. Larger remaining cap after placing this item is preferable (up to a limit).\n    # Small penalty for unused capacity up to 50% of item size, but rapidly decreasing value if capacity > item*0.5\n    large_capacity = bins_remain_cap[feasible_bins] > item\n    remaining_over_cap = bins_remain_cap[feasible_bins][large_capacity] - item\n    priorities[feasible_bins][large_capacity] -= np.clip(remaining_over_cap**2, 0, (item * 0.5)**2) # Quadratic penalty\n\n    return priorities\n\n[Heuristics 7th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priorities with a base value (e.g., 0).\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Identify bins that can accommodate the item.\n    feasible_bins = bins_remain_cap >= item\n\n    # Give significantly higher priority to bins that can fit the item.  The smaller the remaining space after packing, the higher the priority\n    remaining_space = bins_remain_cap[feasible_bins] - item\n    priorities[feasible_bins] = 1.0 / (1e-9 + remaining_space)  # Avoid division by zero\n\n    # Penalize bins that cannot accommodate the item, making them less attractive.\n    priorities[~feasible_bins] = -np.inf\n\n    # Further refine the priority based on remaining capacity. Larger remaining cap after placing this item is preferable (up to a limit).\n    # Small penalty for unused capacity up to 50% of item size, but rapidly decreasing value if capacity > item*0.5\n    large_capacity = bins_remain_cap[feasible_bins] > item\n    remaining_over_cap = bins_remain_cap[feasible_bins][large_capacity] - item\n    priorities[feasible_bins][large_capacity] -= np.clip(remaining_over_cap**2, 0, (item * 0.5)**2) # Quadratic penalty\n\n    return priorities\n\n[Heuristics 8th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Uses a combination of factors to determine priority:\n    - How full the bin would be after adding the item.  Favors near-full bins, avoiding fragmentation.\n    - Whether the item fits at all.  Assigns very low priority if it doesn't fit.\n    - A small bias towards bins that are already somewhat full.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    fits = item <= bins_remain_cap\n\n    # Assign very low priority to bins where the item doesn't fit.  A large negative number.\n    priorities[~fits] = -1e9\n\n    # Calculate fill ratios if the item were added\n    hypothetical_remaining = bins_remain_cap - item\n    hypothetical_fill_ratio = 1 - (hypothetical_remaining / np.max(bins_remain_cap)) # Use max bin cap to normalise\n    hypothetical_fill_ratio[~fits] = 0  # Ensure zero when the item does not fit.\n\n    # Give preference to bins that would become nearly full\n    priorities[fits] = hypothetical_fill_ratio[fits] ** 2  # Make the higher ratios more significant\n    \n    #A slight adjustment to improve the chance that the bin fits tightly\n    space_left = bins_remain_cap - item\n    close_fits = (space_left >= 0) & (space_left < 0.1) #Prioritise fits where we leave a space under 0.1\n    priorities[close_fits] += 1 #Significant Boost\n\n    # Slightly penalize bins that would become almost empty\n    nearly_empty = (hypothetical_remaining > 0) & (hypothetical_remaining < 0.1)  # if remaining under 0.1 then penalise\n    priorities[nearly_empty] -= 0.05\n\n    return priorities\n\n[Heuristics 9th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Employing heuristics inspired by physical systems:\n\n    1.  A \"force\" inversely proportional to the 'distance' (capacity difference).\n    2.  Penalize bins that would have very little space left after packing (waste).\n    3.  A 'temperature' parameter to control exploration vs. exploitation.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    temperature = 1.0  # Adjust for exploration/exploitation. Higher -> more exploration.\n    epsilon = 1e-6  # Avoid division by zero\n\n    # 1. \"Force\" component: Higher priority for bins with closer capacity\n    capacity_diff = np.abs(bins_remain_cap - item) + epsilon\n    force = 1.0 / capacity_diff\n\n    # 2. Waste penalization: Penalize bins leading to small remaining capacity.\n    remaining_after = bins_remain_cap - item\n    waste_penalty = np.exp(-10 * np.maximum(0, remaining_after))  # Exponential penalty\n\n    #3. Favor bins that can accommodate the item\n    can_accommodate = (bins_remain_cap >= item).astype(float)\n\n    #Combine\n    priorities = can_accommodate * force * waste_penalty\n\n    # \"Boltzmann distribution\" to modulate probabilities based on temperature\n    priorities = np.exp(priorities / temperature)\n\n    return priorities\n\n[Heuristics 10th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    # First, prioritize bins that can actually fit the item.\n    fit_indices = np.where(bins_remain_cap >= item)[0]\n    \n    if len(fit_indices) > 0:\n        # Among the bins that can fit, prioritize those with the smallest remaining capacity\n        # after placing the item (i.e., minimize wasted space). This is a \"best fit\" approach.\n        remaining_capacities_after_fit = bins_remain_cap[fit_indices] - item\n        priorities[fit_indices] = 1 / (remaining_capacities_after_fit + 0.00001) # Adding a small constant to avoid division by zero\n\n        # Alternatively, prioritize bins where item size is closest to half of bin capacity\n        # optimal_fill_diffs = np.abs((bins_remain_cap[fit_indices]/2) - item)\n        # priorities[fit_indices] = 1 / (optimal_fill_diffs + 0.00001)\n\n    else:\n        #If it doesnt fit, use lowest remaining\n        priorities = 1 / (bins_remain_cap + 0.00001)\n    \n    return priorities\n\n[Heuristics 11th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    # First, prioritize bins that can actually fit the item.\n    fit_indices = np.where(bins_remain_cap >= item)[0]\n    \n    if len(fit_indices) > 0:\n        # Among the bins that can fit, prioritize those with the smallest remaining capacity\n        # after placing the item (i.e., minimize wasted space). This is a \"best fit\" approach.\n        remaining_capacities_after_fit = bins_remain_cap[fit_indices] - item\n        priorities[fit_indices] = 1 / (remaining_capacities_after_fit + 0.00001) # Adding a small constant to avoid division by zero\n\n        # Alternatively, prioritize bins where item size is closest to half of bin capacity\n        # optimal_fill_diffs = np.abs((bins_remain_cap[fit_indices]/2) - item)\n        # priorities[fit_indices] = 1 / (optimal_fill_diffs + 0.00001)\n\n    else:\n        #If it doesnt fit, use lowest remaining\n        priorities = 1 / (bins_remain_cap + 0.00001)\n    \n    return priorities\n\n[Heuristics 12th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    # First, prioritize bins that can actually fit the item.\n    fit_indices = np.where(bins_remain_cap >= item)[0]\n    \n    if len(fit_indices) > 0:\n        # Among the bins that can fit, prioritize those with the smallest remaining capacity\n        # after placing the item (i.e., minimize wasted space). This is a \"best fit\" approach.\n        remaining_capacities_after_fit = bins_remain_cap[fit_indices] - item\n        priorities[fit_indices] = 1 / (remaining_capacities_after_fit + 0.00001) # Adding a small constant to avoid division by zero\n\n        # Alternatively, prioritize bins where item size is closest to half of bin capacity\n        # optimal_fill_diffs = np.abs((bins_remain_cap[fit_indices]/2) - item)\n        # priorities[fit_indices] = 1 / (optimal_fill_diffs + 0.00001)\n\n    else:\n        #If it doesnt fit, use lowest remaining\n        priorities = 1 / (bins_remain_cap + 0.00001)\n    \n    return priorities\n\n[Heuristics 13th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    # First, prioritize bins that can actually fit the item.\n    fit_indices = np.where(bins_remain_cap >= item)[0]\n    \n    if len(fit_indices) > 0:\n        # Among the bins that can fit, prioritize those with the smallest remaining capacity\n        # after placing the item (i.e., minimize wasted space). This is a \"best fit\" approach.\n        remaining_capacities_after_fit = bins_remain_cap[fit_indices] - item\n        priorities[fit_indices] = 1 / (remaining_capacities_after_fit + 0.00001) # Adding a small constant to avoid division by zero\n\n        # Alternatively, prioritize bins where item size is closest to half of bin capacity\n        # optimal_fill_diffs = np.abs((bins_remain_cap[fit_indices]/2) - item)\n        # priorities[fit_indices] = 1 / (optimal_fill_diffs + 0.00001)\n\n    else:\n        #If it doesnt fit, use lowest remaining\n        priorities = 1 / (bins_remain_cap + 0.00001)\n    \n    return priorities\n\n[Heuristics 14th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Prioritize bins that can fit the item. If not possible, assign a low score.\n    can_fit = bins_remain_cap >= item\n    priorities[~can_fit] = -np.inf # Very low priority if cannot fit\n\n    # For bins that CAN fit, prioritize based on how FULL they will be.  Aim for density.\n    remaining_after_fit = bins_remain_cap[can_fit] - item\n    fill_ratios = (bins_remain_cap[can_fit] - remaining_after_fit) / bins_remain_cap[can_fit]\n\n    # Slightly penalize nearly full bins (risk of small items not fitting later) using a log-like transform\n    # Only impact when close to full, and not if almost empty.\n    # Scale fill_ratios so max fill_ratio maps to -1 * some small scaling\n    overfill_penalty_scale = 0.1\n\n    priorities[can_fit] = fill_ratios - overfill_penalty_scale * np.exp(10*(fill_ratios-0.95))  # Add penalty that only gets large when very full\n\n    return priorities\n\n[Heuristics 15th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Considers both remaining capacity and fragmentation. A higher\n    score indicates a higher priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            # Prioritize bins that can fit the item.\n            remaining = cap - item\n            # Prioritize bins with less remaining space (better fit), but also consider\n            # if the remaining space is useful for other items (fragmentation).\n            # We use a combined score.\n            priorities[i] = (1 / (remaining + 1e-9)) + (remaining > item/2) # 1e-9 to avoid division by zero\n        else:\n            # Bin cannot fit the item, give it a negative (low) priority.\n            priorities[i] = -np.inf\n    return priorities\n\n[Heuristics 16th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Prioritizes bins that can accommodate the item with minimal waste,\n    but also avoids filling bins completely to allow for flexibility with\n    future, potentially smaller, items. Uses a sigmoid function to\n    balance waste minimization and future packing potential.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Option 1: Penalize bins that are too small\n    infeasible = bins_remain_cap < item\n    priorities[infeasible] = -np.inf  # Significantly disincentivize\n\n    #Option 2: Waste minimization (bins that fit the item with less waste gets higher priority)\n    waste = bins_remain_cap - item\n    #Avoid bins that would be filled to the brim. Encourage some flexibility for future smaller items.\n    #Use a sigmoid function to model this preference.\n    sigmoid = 1 / (1 + np.exp(-10 * (waste - 0.1))) #waste of 0.1 gets a score of ~0.5, smaller waste -> closer to 1, larger waste -> closer to 0\n    priorities[~infeasible] = sigmoid[~infeasible] # only calculate for feasible bins\n\n    # Option 3: Consider number of items already present in bin\n    # This could potentially avoid spreading single items across multiple bins,\n    # although requires additional information regarding the already present items in bins which may or may not be easy.\n\n    return priorities\n\n[Heuristics 17th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Prioritizes bins that can accommodate the item with minimal waste,\n    but also avoids filling bins completely to allow for flexibility with\n    future, potentially smaller, items. Uses a sigmoid function to\n    balance waste minimization and future packing potential.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Option 1: Penalize bins that are too small\n    infeasible = bins_remain_cap < item\n    priorities[infeasible] = -np.inf  # Significantly disincentivize\n\n    #Option 2: Waste minimization (bins that fit the item with less waste gets higher priority)\n    waste = bins_remain_cap - item\n    #Avoid bins that would be filled to the brim. Encourage some flexibility for future smaller items.\n    #Use a sigmoid function to model this preference.\n    sigmoid = 1 / (1 + np.exp(-10 * (waste - 0.1))) #waste of 0.1 gets a score of ~0.5, smaller waste -> closer to 1, larger waste -> closer to 0\n    priorities[~infeasible] = sigmoid[~infeasible] # only calculate for feasible bins\n\n    # Option 3: Consider number of items already present in bin\n    # This could potentially avoid spreading single items across multiple bins,\n    # although requires additional information regarding the already present items in bins which may or may not be easy.\n\n    return priorities\n\n[Heuristics 18th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    ratios = item / bins_remain_cap\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n[Heuristics 19th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    ratios = item / bins_remain_cap\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n[Heuristics 20th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    ratios = item / bins_remain_cap\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}