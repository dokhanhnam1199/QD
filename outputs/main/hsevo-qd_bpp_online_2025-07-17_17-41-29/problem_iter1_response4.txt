```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version prioritizes bins that can accommodate the item with minimal wasted space,
    while also considering bins that are already relatively full to encourage consolidation.
    Bins that are too small receive a very low priority.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # First, invalidate bins that are too small.  Avoid div-by-zero.
    invalid_mask = bins_remain_cap < item
    priorities[invalid_mask] = -np.inf  #Very low priority
    
    # Calculate wasted space if the item were added to each valid bin
    wasted_space = bins_remain_cap - item
    wasted_space[invalid_mask] = np.inf # Ensure these are never chosen

    # Give higher priority to bins with less wasted space (more efficient packing).  Small values map to high priorities
    priorities[~invalid_mask] += -np.abs(wasted_space[~invalid_mask])

    # Give higher priority to bins that are already relatively full, to encourage consolidation.
    # This is a "fill-up" strategy.
    fill_ratio = (bins_remain_cap - wasted_space) / bins_remain_cap
    fill_ratio[invalid_mask] = 0.  # No ratio for bins that can't fit
    priorities[~invalid_mask] += fill_ratio[~invalid_mask] * 10 # Scale fill ratio to weigh more

    #Add an additional heuristic that favors bins that are almost full (but can accomodate the item)
    almost_full_bonus = np.where((bins_remain_cap >= item) & (bins_remain_cap < (item * 1.1)), 5, 0)
    priorities += almost_full_bonus


    return priorities
```
