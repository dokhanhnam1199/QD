[
  {
    "stdout_filepath": "problem_iter0_stdout0.txt",
    "code_path": "problem_iter0_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    ratios = item / bins_remain_cap\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities",
    "response_id": 0,
    "obj": 149.30195452732352,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 11.60964047443681,
    "mi": 94.04446327225541,
    "token_count": 47.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response0.txt_stdout.txt",
    "code_path": "problem_iter1_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # 1. Feasibility: Give -inf priority if item doesn't fit\n    infeasible_mask = item > bins_remain_cap\n    priorities[infeasible_mask] = -np.inf\n    \n    # 2. Best Fit: Prioritize bins where the remaining space after placing the item is small.\n    feasible_mask = ~infeasible_mask\n    remaining_space = bins_remain_cap[feasible_mask] - item\n    priorities[feasible_mask] = -remaining_space # Smaller remaining space -> higher priority\n\n    # 3. Avoidance of very small spaces: Penalize bins leaving very small spaces, but only if other bins are more reasonable fits\n    small_space_threshold = 0.1 # Tuneable parameter: Avoid leaving spaces smaller than 10% of bin capacity\n    very_small_space_mask = (remaining_space > 0) & (remaining_space < small_space_threshold) & (np.sum(bins_remain_cap[feasible_mask] -item >small_space_threshold) > 0)\n    if np.any(very_small_space_mask): #reduce the priorities by a tiny amount only when you know more fits are feasible\n      priorities[feasible_mask][very_small_space_mask] -=0.01\n    # 4. Utilize Almost Full Bins: Reward bins that are almost full, encouraging complete filling of existing bins\n\n    almost_full_threshold = 0.9  # Define what constitutes an \"almost full\" bin after placing the item\n    almost_full_mask = (bins_remain_cap[feasible_mask] - item) / bins_remain_cap[feasible_mask] < (1- almost_full_threshold) \n    priorities[feasible_mask][almost_full_mask]+=0.02\n\n    return priorities",
    "response_id": 0,
    "tryHS": true,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 169.21582985307933,
    "mi": 76.12344793300358,
    "token_count": 176.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response0.txt_stdout.txt",
    "code_path": "problem_iter2_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines fitability, nearly-full preference, overfill penalty, and best-fit logic.\"\"\"\n    # Fitability score, penalizing bins much larger or smaller than the item.\n    fitability = np.abs(bins_remain_cap - item)\n\n    # Nearly-full priority, preferring bins nearly full after item placement.\n    remaining_ratio = np.clip((bins_remain_cap - item) / np.mean(bins_remain_cap), a_min=0.0, a_max=1.0)\n    nearly_full_priority = -np.log(remaining_ratio + 0.001)\n\n    # Overfill penalty, strongly discouraging exceeding bin capacity.\n    overfill_penalty = np.where(item > bins_remain_cap, -1e9, 0)\n\n    # Best-fit component: prioritize smallest remaining space if it fits.\n    fit_indices = np.where(bins_remain_cap >= item)[0]\n    best_fit_priority = np.zeros_like(bins_remain_cap)\n    if len(fit_indices) > 0:\n        remaining_capacities_after_fit = bins_remain_cap[fit_indices] - item\n        best_fit_priority[fit_indices] = 1 / (remaining_capacities_after_fit + 0.00001)\n\n    # Combine all components with weights.\n    priorities = (\n        -fitability * 0.3\n        + nearly_full_priority * 0.7\n        + overfill_penalty\n        + best_fit_priority * 0.5\n    )\n\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 204.46016259302917,
    "mi": 88.32939971833851,
    "token_count": 158.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response0.txt_stdout.txt",
    "code_path": "problem_iter3_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # 1. Feasibility: Give -inf priority if item doesn't fit\n    infeasible_mask = item > bins_remain_cap\n    priorities[infeasible_mask] = -np.inf\n    \n    feasible_mask = ~infeasible_mask\n    \n    if not np.any(feasible_mask):\n        return priorities\n\n    # 2. Best Fit: Prioritize bins where the remaining space after placing the item is small.\n    remaining_space = bins_remain_cap[feasible_mask] - item\n    priorities[feasible_mask] = -remaining_space # Smaller remaining space -> higher priority\n\n    # 3. Avoidance of very small spaces: Penalize bins leaving very small spaces, but only if other bins are more reasonable fits\n    small_space_threshold = 0.1 # Tuneable parameter: Avoid leaving spaces smaller than 10% of bin capacity\n    very_small_space_mask = (remaining_space > 0) & (remaining_space < small_space_threshold)\n    \n    # Only penalize very small spaces IF there's at least one other bin with a *larger* remaining space\n    # and the best fit bin after this.\n    larger_space_exists = np.any(remaining_space > small_space_threshold)\n    if larger_space_exists:\n            priorities[feasible_mask][very_small_space_mask] -= 0.01  # Small penalty\n\n\n    # 4. Utilize Almost Full Bins: Reward bins that are almost full, encouraging complete filling of existing bins\n\n    almost_full_threshold = 0.9  # Define what constitutes an \"almost full\" bin after placing the item\n    almost_full_mask = (bins_remain_cap[feasible_mask] - item) / bins_remain_cap[feasible_mask] > almost_full_threshold  # Correct the logic here. Should be GREATER than threshold\n    priorities[feasible_mask][almost_full_mask] += 0.02\n\n\n    # 5. Introduce a \"balancing\" term.  If there are many bins that *can* fit the item, slightly\n    # penalize filling the *most* full ones to allow other bins a chance to be used. This encourages\n    # better distribution, particularly early on. This helps avoid premature convergence on using\n    # only a few bins.\n    \n    num_feasible = np.sum(feasible_mask)\n    if num_feasible > 1:  # Only apply if there's a choice\n       #scale penalty depending on number of bins\n        priority_order = np.argsort(priorities[feasible_mask]) #Get order of priorities for available bins\n        #Slightly penalize the very best bin for that item so we don't fill it up immediately if we have more options\n        priorities[feasible_mask][priority_order[-1]] -=0.005\n\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 23.0,
    "cyclomatic_complexity": 4.0,
    "halstead": 385.3624125497598,
    "mi": 78.07419123597214,
    "token_count": 277.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response0.txt_stdout.txt",
    "code_path": "problem_iter4_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, small_space_threshold: float = 0.38634679648177406, small_space_penalty: float = 0.08492583169208827, almost_full_threshold: float = 0.5521618659843823, almost_full_reward: float = 0.08170959427667597) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        small_space_threshold: Threshold for considering a remaining space as very small.\n        small_space_penalty: Penalty applied to bins leaving very small spaces.\n        almost_full_threshold: Threshold for considering a bin as almost full after placing the item.\n        almost_full_reward: Reward applied to bins that are almost full.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # 1. Feasibility: Give -inf priority if item doesn't fit\n    infeasible_mask = item > bins_remain_cap\n    priorities[infeasible_mask] = -np.inf\n    \n    # 2. Best Fit: Prioritize bins where the remaining space after placing the item is small.\n    feasible_mask = ~infeasible_mask\n    remaining_space = bins_remain_cap[feasible_mask] - item\n    priorities[feasible_mask] = -remaining_space # Smaller remaining space -> higher priority\n\n    # 3. Avoidance of very small spaces: Penalize bins leaving very small spaces, but only if other bins are more reasonable fits\n    very_small_space_mask = (remaining_space > 0) & (remaining_space < small_space_threshold) & (np.sum(bins_remain_cap[feasible_mask] -item >small_space_threshold) > 0)\n    if np.any(very_small_space_mask): #reduce the priorities by a tiny amount only when you know more fits are feasible\n      priorities[feasible_mask][very_small_space_mask] -= small_space_penalty\n    # 4. Utilize Almost Full Bins: Reward bins that are almost full, encouraging complete filling of existing bins\n    almost_full_mask = (bins_remain_cap[feasible_mask] - item) / bins_remain_cap[feasible_mask] < (1- almost_full_threshold) \n    priorities[feasible_mask][almost_full_mask]+=almost_full_reward\n\n    return priorities",
    "response_id": 0,
    "tryHS": true,
    "obj": 4.048663741523748,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 259.4606049037673,
    "mi": 78.2244895937764,
    "token_count": 201.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response0.txt_stdout.txt",
    "code_path": "problem_iter5_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best fit, feasibility, and a balancing term.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Feasibility check\n    feasible_mask = item <= bins_remain_cap\n    priorities[~feasible_mask] = -np.inf\n    \n    # Best Fit: Smaller remaining space -> higher priority\n    remaining_space = bins_remain_cap - item\n    priorities[feasible_mask] = -remaining_space[feasible_mask]\n    \n    # Balancing term: Penalize filling the fullest bins\n    num_feasible = np.sum(feasible_mask)\n    if num_feasible > 1:\n        priorities[feasible_mask][np.argmax(bins_remain_cap[feasible_mask])] -= 0.005\n    \n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 14.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 88.0,
    "mi": 88.89689145596356,
    "token_count": 147.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response0.txt_stdout.txt",
    "code_path": "problem_iter6_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # 1. Feasibility: Give -inf priority if item doesn't fit\n    infeasible_mask = item > bins_remain_cap\n    priorities[infeasible_mask] = -np.inf\n    \n    # 2. Best Fit: Prioritize bins where the remaining space after placing the item is small.\n    feasible_mask = ~infeasible_mask\n    remaining_space = bins_remain_cap[feasible_mask] - item\n    priorities[feasible_mask] = -remaining_space # Smaller remaining space -> higher priority\n\n    # 3. Avoidance of very small spaces: Penalize bins leaving very small spaces, but only if other bins are more reasonable fits\n    small_space_threshold = 0.1 # Tuneable parameter: Avoid leaving spaces smaller than 10% of bin capacity\n    very_small_space_mask = (remaining_space > 0) & (remaining_space < small_space_threshold)\n    \n    # Only penalize if a significantly better fit is possible in another bin\n    if np.any(very_small_space_mask):\n        other_bins_space = bins_remain_cap[feasible_mask] - item\n        better_fit_exists = np.any(other_bins_space > small_space_threshold)\n        if better_fit_exists:\n            priorities[feasible_mask][very_small_space_mask] -= 0.01\n            \n    # 4. Utilize Almost Full Bins: Reward bins that are almost full, encouraging complete filling of existing bins\n    almost_full_threshold = 0.9  # Define what constitutes an \"almost full\" bin after placing the item\n    almost_full_mask = (bins_remain_cap[feasible_mask] - item) / bins_remain_cap[feasible_mask] > almost_full_threshold\n    priorities[feasible_mask][almost_full_mask] += 0.02\n\n    # 5. Prioritize bins close to item size (match)\n    match_threshold = 0.2 # Maximum difference from item size to be considered a \"match\"\n    match_mask = np.abs(bins_remain_cap[feasible_mask] - item) <= match_threshold\n    priorities[feasible_mask][match_mask] += 0.01 # slightly better then almost full\n\n    # 6. Introducing a small degree of randomness to escape local optima.\n    priorities[feasible_mask] += np.random.normal(0, 0.001, size=np.sum(feasible_mask))\n    \n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 19.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 339.7159976350619,
    "mi": 79.13527384584715,
    "token_count": 240.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response0.txt_stdout.txt",
    "code_path": "problem_iter8_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Hybrid heuristic: Feasibility, best fit, avoid small space,balance.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: -inf if item doesn't fit\n    infeasible_mask = item > bins_remain_cap\n    priorities[infeasible_mask] = -np.inf\n\n    feasible_mask = ~infeasible_mask\n\n    if not np.any(feasible_mask):\n        return priorities\n\n    # 2. Best Fit: Prioritize smaller remaining space.\n    remaining_space = bins_remain_cap[feasible_mask] - item\n    priorities[feasible_mask] = -remaining_space\n\n    # 3. Avoidance of very small spaces\n    small_space_threshold = 0.1\n    very_small_space_mask = (remaining_space > 0) & (remaining_space < small_space_threshold)\n    larger_space_exists = np.any(remaining_space > small_space_threshold)\n\n    if larger_space_exists:\n        priorities[feasible_mask][very_small_space_mask] -= 0.01\n\n    # 4. Balancing term\n    num_feasible = np.sum(feasible_mask)\n    if num_feasible > 1:\n        priority_order = np.argsort(priorities[feasible_mask])\n        priorities[feasible_mask][priority_order[-1]] -= 0.005\n\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 191.36873322873222,
    "mi": 88.53062161001417,
    "token_count": 156.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response0.txt_stdout.txt",
    "code_path": "problem_iter9_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: Give -inf priority if item doesn't fit\n    infeasible_mask = item > bins_remain_cap\n    priorities[infeasible_mask] = -np.inf\n\n    # 2. Best Fit: Prioritize bins where the remaining space after placing the item is small.\n    feasible_mask = ~infeasible_mask\n    remaining_space = bins_remain_cap[feasible_mask] - item\n    priorities[feasible_mask] = -remaining_space  # Smaller remaining space -> higher priority\n\n    # 3. Avoidance of very small spaces: Penalize bins leaving very small spaces, but only if other bins are more reasonable fits\n    small_space_threshold = 0.1  # Tuneable parameter: Avoid leaving spaces smaller than 10% of bin capacity\n    very_small_space_mask = (remaining_space > 0) & (remaining_space < small_space_threshold)\n    #Only apply the penalty if it's not the absolute best fit available\n    if np.any(very_small_space_mask):\n        min_remaining_space = np.min(remaining_space)\n        very_small_and_not_best = very_small_space_mask & (remaining_space > min_remaining_space)\n        priorities[feasible_mask][very_small_and_not_best] -= 0.01\n\n    # 4. Utilize Almost Full Bins: Reward bins that are almost full, encouraging complete filling of existing bins\n    almost_full_threshold = 0.9  # Define what constitutes an \"almost full\" bin after placing the item\n    almost_full_mask = (bins_remain_cap[feasible_mask] - item) / bins_remain_cap[feasible_mask] > almost_full_threshold\n    priorities[feasible_mask][almost_full_mask] += 0.02\n\n    # 5. Moderate Fit: Reward bins that have a moderate fit, reducing fragmentation\n    moderate_fit_threshold_low = 0.2\n    moderate_fit_threshold_high = 0.6\n    moderate_fit_mask = (item / bins_remain_cap[feasible_mask] >= moderate_fit_threshold_low) & (item / bins_remain_cap[feasible_mask] <= moderate_fit_threshold_high)\n    priorities[feasible_mask][moderate_fit_mask] += 0.01\n\n    #6. Prioritize bins with more remaining capacity when multiple bins can accomodate the item\n    #Helps to distribute the items to avoid filling bins too early, potentially leading to a better overall packing.\n    capacity_normalized = bins_remain_cap[feasible_mask]/np.max(bins_remain_cap)\n    priorities[feasible_mask] += 0.005*capacity_normalized #Small weight so as not to override other heuristics\n\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 20.0,
    "cyclomatic_complexity": 5.0,
    "halstead": 364.5550890997629,
    "mi": 78.18945352748321,
    "token_count": 261.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response0.txt_stdout.txt",
    "code_path": "problem_iter11_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit, avoidance of small spaces, and balancing.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    infeasible_mask = item > bins_remain_cap\n    priorities[infeasible_mask] = -np.inf\n    feasible_mask = ~infeasible_mask\n    if not np.any(feasible_mask):\n        return priorities\n\n    remaining_space = bins_remain_cap[feasible_mask] - item\n    priorities[feasible_mask] = -remaining_space\n\n    small_space_threshold = 0.1\n    very_small_space_mask = (remaining_space > 0) & (remaining_space < small_space_threshold)\n\n    larger_space_exists = np.any(remaining_space > small_space_threshold)\n    if larger_space_exists:\n        priorities[feasible_mask][very_small_space_mask] -= 0.01\n\n    almost_full_threshold = 0.9\n    almost_full_mask = (bins_remain_cap[feasible_mask] - item) / bins_remain_cap[feasible_mask] > almost_full_threshold\n    priorities[feasible_mask][almost_full_mask] += 0.02\n    \n    num_feasible = np.sum(feasible_mask)\n    if num_feasible > 1:\n        priority_order = np.argsort(priorities[feasible_mask])\n        priorities[feasible_mask][priority_order[-1]] -= 0.005\n\n    #Introduce nearly-full priority\n    nearly_full_threshold=0.8\n    nearly_full_mask = (bins_remain_cap[feasible_mask] - item) / bins_remain_cap[feasible_mask] > nearly_full_threshold\n    priorities[feasible_mask][nearly_full_mask]+=0.01\n\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 259.4606049037673,
    "mi": 84.50766132845462,
    "token_count": 200.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response0.txt_stdout.txt",
    "code_path": "problem_iter14_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins considering feasibility, best fit (ratio), and fragmentation.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: Disqualify bins that can't fit the item.\n    infeasible_mask = item > bins_remain_cap\n    priorities[infeasible_mask] = -np.inf\n\n    # 2. Best Fit (Ratio-based): Prioritize based on fill ratio (item_size / bin_capacity).\n    feasible_mask = ~infeasible_mask\n    remaining_capacity = bins_remain_cap[feasible_mask]\n    fill_ratio = item / remaining_capacity\n    priorities[feasible_mask] = fill_ratio  # Higher fill ratio is better\n\n    # 3. Fragmentation avoidance: Penalize bins that would leave small remaining space relative to bin size.\n    small_space_threshold = 0.15  # Avoid spaces smaller than 15%\n    remaining_space = remaining_capacity - item\n    frag_mask = (remaining_space > 0) & (remaining_space / remaining_capacity < small_space_threshold)\n    priorities[feasible_mask][frag_mask] -= 0.1 # Reduce priority if creates fragment\n\n    #4. Utilize almost full bins\n    almost_full_threshold = 0.85\n    almost_full_mask = (bins_remain_cap[feasible_mask] - item) / bins_remain_cap[feasible_mask] < (1- almost_full_threshold)\n    priorities[feasible_mask][almost_full_mask]+= 0.15\n\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 19.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 242.13091772920575,
    "mi": 83.017266220791,
    "token_count": 227.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter15_response0.txt_stdout.txt",
    "code_path": "problem_iter15_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # 1. Feasibility: Give -inf priority if item doesn't fit\n    infeasible_mask = item > bins_remain_cap\n    priorities[infeasible_mask] = -np.inf\n    \n    # 2. Best Fit: Prioritize bins where the remaining space after placing the item is small.\n    feasible_mask = ~infeasible_mask\n    remaining_space = bins_remain_cap[feasible_mask] - item\n    priorities[feasible_mask] = -remaining_space # Smaller remaining space -> higher priority\n\n    # 3. Avoidance of very small spaces: Penalize bins leaving very small spaces, but only if other bins are more reasonable fits\n    small_space_threshold = 0.1 # Tuneable parameter: Avoid leaving spaces smaller than 10% of bin capacity\n    very_small_space_mask = (remaining_space > 0) & (remaining_space < small_space_threshold) & (np.sum(bins_remain_cap[feasible_mask] -item >small_space_threshold) > 0)\n    if np.any(very_small_space_mask): #reduce the priorities by a tiny amount only when you know more fits are feasible\n      priorities[feasible_mask][very_small_space_mask] -=0.01\n    # 4. Utilize Almost Full Bins: Reward bins that are almost full, encouraging complete filling of existing bins\n\n    almost_full_threshold = 0.9  # Define what constitutes an \"almost full\" bin after placing the item\n    almost_full_mask = (bins_remain_cap[feasible_mask] - item) / bins_remain_cap[feasible_mask] < (1- almost_full_threshold) \n    priorities[feasible_mask][almost_full_mask]+=0.02\n\n    # 5. Moderate Space Preference: Slightly prefer bins with moderate remaining space *before* placing the item.\n    #    This encourages a balance - not too full, not too empty.\n\n    moderate_space_lower = 0.2  # Lower bound for moderate space (20% of capacity)\n    moderate_space_upper = 0.8  # Upper bound for moderate space (80% of capacity)\n\n    moderate_space_mask = (bins_remain_cap[feasible_mask] >= moderate_space_lower) & (bins_remain_cap[feasible_mask] <= moderate_space_upper)\n    priorities[feasible_mask][moderate_space_mask] += 0.005 # A small encouragement\n\n    # 6. Item Size Consideration: Give preference to bins whose remaining capacity *before* placement is closest to the item size itself\n    item_proximity = np.abs(bins_remain_cap[feasible_mask] - item)\n    # Normalize to make it comparable and invert (smaller difference = higher priority)\n    normalized_proximity = 1 / (1 + item_proximity)  # Avoid division by zero\n    priorities[feasible_mask] += 0.01 * normalized_proximity # Scale it down\n\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 21.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 411.03957502414517,
    "mi": 78.4567142817254,
    "token_count": 260.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter17_response0.txt_stdout.txt",
    "code_path": "problem_iter17_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best fit, feasibility, and avoids small remaining spaces.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: Impossible to place, lowest priority.\n    infeasible_mask = item > bins_remain_cap\n    priorities[infeasible_mask] = -np.inf\n\n    # 2. Best Fit: Prioritize bins that leave minimal space.\n    feasible_mask = ~infeasible_mask\n    remaining_space = bins_remain_cap[feasible_mask] - item\n    priorities[feasible_mask] = -remaining_space\n\n    # 3. Avoid Small Spaces: Penalize creating very small fragments.\n    small_space_threshold = 0.1\n    very_small_space_mask = (remaining_space > 0) & (remaining_space < small_space_threshold) & (np.sum(bins_remain_cap[feasible_mask] -item >small_space_threshold) > 0)\n\n    if np.any(very_small_space_mask):\n      priorities[feasible_mask][very_small_space_mask] -= 0.01\n    # 4. Utilize Almost Full Bins: Reward bins that are almost full\n    almost_full_threshold = 0.9\n    almost_full_mask = (bins_remain_cap[feasible_mask] - item) / bins_remain_cap[feasible_mask] < (1- almost_full_threshold)\n    priorities[feasible_mask][almost_full_mask]+=0.02\n\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 23.0,
    "cyclomatic_complexity": 4.0,
    "halstead": 276.9812829150282,
    "mi": 80.88247843178087,
    "token_count": 247.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter18_response0.txt_stdout.txt",
    "code_path": "problem_iter18_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: Give -inf priority if item doesn't fit\n    infeasible_mask = item > bins_remain_cap\n    priorities[infeasible_mask] = -np.inf\n\n    # 2. Best Fit: Prioritize bins where the remaining space after placing the item is small.\n    feasible_mask = ~infeasible_mask\n    remaining_space = bins_remain_cap[feasible_mask] - item\n    priorities[feasible_mask] = -remaining_space  # Smaller remaining space -> higher priority\n\n    # 3. Avoidance of very small spaces: Penalize bins leaving very small spaces, but only if other bins are more reasonable fits\n    small_space_threshold = 0.1  # Tuneable parameter: Avoid leaving spaces smaller than 10% of bin capacity\n    very_small_space_mask = (remaining_space > 0) & (remaining_space < small_space_threshold)\n    \n    # Only penalize if there are other feasible bins that don't result in very small space\n    other_feasible_bins = bins_remain_cap[feasible_mask] - item\n    if np.any(other_feasible_bins[~very_small_space_mask] > 0):\n        priorities[feasible_mask][very_small_space_mask] -= 0.01\n\n    # 4. Utilize Almost Full Bins: Reward bins that are almost full, encouraging complete filling of existing bins\n    almost_full_threshold = 0.9  # Define what constitutes an \"almost full\" bin after placing the item\n    almost_full_mask = (bins_remain_cap[feasible_mask] - item) / bins_remain_cap[feasible_mask] < (1 - almost_full_threshold)\n    priorities[feasible_mask][almost_full_mask] += 0.02\n\n    # 5. Balancing Bin Usage: Encourage using bins that are less full overall. Helps distribute items more evenly\n    bin_utilization = (1 - bins_remain_cap / np.max(bins_remain_cap))  # Normalize remaining capacity, then invert\n    avg_utilization = np.mean(bin_utilization)\n\n    # Prioritize bins with below-average utilization (more remaining capacity relative to others, inverted)\n    below_avg_utilization_mask = bin_utilization < avg_utilization\n    priorities[below_avg_utilization_mask] += 0.005 * (avg_utilization - bin_utilization[below_avg_utilization_mask]) # Smaller difference -> smaller addition\n\n    #6. Item size consideration:  If the item is large, prioritize bins with larger remaining capacity, avoiding premature fragmentation\n    large_item_threshold = 0.5 # Tuneable parameter, threshold is relative to bin capacity (which is implicitly 1)\n\n    if item > large_item_threshold:\n        # scale this bonus by the size of the item. So larger items get a larger bonus in larger bins\n        priorities[feasible_mask] += 0.01 * (bins_remain_cap[feasible_mask] - item) * item\n\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 23.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 507.4614312323326,
    "mi": 75.53619985476087,
    "token_count": 315.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response0.txt_stdout.txt",
    "code_path": "problem_iter20_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit, avoidance of small spaces, balancing, and fill ratio.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    infeasible_mask = item > bins_remain_cap\n    priorities[infeasible_mask] = -np.inf  # Infeasible bins have lowest priority\n\n    feasible_mask = ~infeasible_mask\n    if not np.any(feasible_mask):\n        return priorities\n\n    remaining_space = bins_remain_cap[feasible_mask] - item\n    # Best-fit component: prioritize bins where remaining space is minimal\n    priorities[feasible_mask] = -remaining_space\n\n    small_space_threshold = 0.1\n    very_small_space_mask = (remaining_space > 0) & (remaining_space < small_space_threshold)\n\n    larger_space_exists = np.any(remaining_space > small_space_threshold)\n    if larger_space_exists:\n        priorities[feasible_mask][very_small_space_mask] -= 0.01  # Penalize small spaces if larger exist\n\n    # Fill-ratio component: prioritize bins with higher fill ratio after adding item\n    fill_ratios = (bins_remain_cap[feasible_mask] - item) / bins_remain_cap[feasible_mask]\n    priorities[feasible_mask] += 0.02 * (1 - fill_ratios) #Prioritize higher fill ratio\n\n    # Balancing component: slightly prefer bins with more remaining capacity (before adding item)\n    priorities[feasible_mask] += 0.001 * bins_remain_cap[feasible_mask]\n    \n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 16.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 244.19821638001633,
    "mi": 81.32869666036457,
    "token_count": 186.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter21_response0.txt_stdout.txt",
    "code_path": "problem_iter21_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: Give -inf priority if item doesn't fit\n    infeasible_mask = item > bins_remain_cap\n    priorities[infeasible_mask] = -np.inf\n\n    feasible_mask = ~infeasible_mask\n    remaining_space = bins_remain_cap[feasible_mask] - item\n\n    # 2. Best Fit: Prioritize bins where the remaining space after placing the item is small.\n    priorities[feasible_mask] = -remaining_space\n\n    # 3. Avoidance of very small spaces: Penalize bins leaving very small spaces, but only if other bins are more reasonable fits\n    small_space_threshold = 0.1\n    very_small_space_mask = (remaining_space > 0) & (remaining_space < small_space_threshold)\n    \n    # Check if there is at least one bin where the item fits and the remaining space is not very small\n    better_fit_exists = np.any((bins_remain_cap[feasible_mask] - item >= small_space_threshold) & (bins_remain_cap[feasible_mask] >= item))\n    \n    if better_fit_exists:\n        priorities[feasible_mask][very_small_space_mask] -= 0.01  # Reduced penalty\n\n    # 4. Utilize Almost Full Bins: Reward bins that are almost full, encouraging complete filling of existing bins\n    almost_full_threshold = 0.9\n    almost_full_mask = (bins_remain_cap[feasible_mask] - item) / bins_remain_cap[feasible_mask] < (1 - almost_full_threshold)\n    priorities[feasible_mask][almost_full_mask] += 0.02\n\n    # 5. Introduce a tie-breaker: Prefer bins with larger original capacity if priorities are equal so far\n    # This encourages use of larger bins first, potentially leading to better packing later\n    # Only do this where priorities are nearly equal to avoid undoing best fit\n    \n    max_priority = np.max(priorities[feasible_mask], initial = -np.inf)\n    \n    tie_break_mask = np.isclose(priorities[feasible_mask], max_priority)\n\n    if np.any(tie_break_mask): #Only add tie breaker if there are ties\n        original_capacities = bins_remain_cap[feasible_mask][tie_break_mask] + item #Approximation of orignal cap\n        priorities[feasible_mask][tie_break_mask] += original_capacities * 0.00001 #Very Small number\n\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 24.0,
    "cyclomatic_complexity": 5.0,
    "halstead": 371.2413500673362,
    "mi": 79.35146592049473,
    "token_count": 268.0,
    "exec_success": true
  }
]