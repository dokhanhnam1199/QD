{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # 1. Feasibility: Give -inf priority if item doesn't fit\n    infeasible_mask = item > bins_remain_cap\n    priorities[infeasible_mask] = -np.inf\n    \n    # 2. Best Fit: Prioritize bins where the remaining space after placing the item is small.\n    feasible_mask = ~infeasible_mask\n    remaining_space = bins_remain_cap[feasible_mask] - item\n    priorities[feasible_mask] = -remaining_space # Smaller remaining space -> higher priority\n\n    # 3. Avoidance of very small spaces: Penalize bins leaving very small spaces, but only if other bins are more reasonable fits\n    small_space_threshold = 0.1 # Tuneable parameter: Avoid leaving spaces smaller than 10% of bin capacity\n    very_small_space_mask = (remaining_space > 0) & (remaining_space < small_space_threshold) & (np.sum(bins_remain_cap[feasible_mask] -item >small_space_threshold) > 0)\n    if np.any(very_small_space_mask): #reduce the priorities by a tiny amount only when you know more fits are feasible\n      priorities[feasible_mask][very_small_space_mask] -=0.01\n    # 4. Utilize Almost Full Bins: Reward bins that are almost full, encouraging complete filling of existing bins\n\n    almost_full_threshold = 0.9  # Define what constitutes an \"almost full\" bin after placing the item\n    almost_full_mask = (bins_remain_cap[feasible_mask] - item) / bins_remain_cap[feasible_mask] < (1- almost_full_threshold) \n    priorities[feasible_mask][almost_full_mask]+=0.02\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    ratios = item / bins_remain_cap\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see the best heuristic uses a combination of feasibility, best fit, avoidance of very small spaces, utilization of almost full bins, and a balancing term, while the worst only uses the ratio of item size to remaining bin capacity and its logarithm.\nComparing (2nd best) vs (second worst), 4th and 19th, we see the second-best heuristic introduces thresholds and penalties/rewards based on remaining space, whereas the second worst just uses log ratios. The 4th introduces tunable parameters.\nComparing (1st) vs (2nd), we see they are functionally identical. This suggests the ranking might be due to external factors or subtle differences not apparent in the code itself.\nComparing (3rd) vs (4th), the 4th introduces parameters and modifies the avoidance of small spaces by adding `(np.sum(bins_remain_cap[feasible_mask] -item >small_space_threshold) > 0)` condition which checks if there is at least one other bin with larger space.\nComparing (second worst) vs (worst), we see the difference lies primarily in the lack of explicit feasibility checks and best-fit prioritization in the very worst heuristics. They depend entirely on a log ratio which may not effectively capture bin filling dynamics.\nComparing (5th) vs (6th), 5th includes avoidance of very small space like 4th, and adds almost full bins like 1st, 2nd, 3rd. 6th only focuses on feasibility, best fit, and balancing term.\nComparing (7th) vs (8th), they're duplicates, this is likely a mistake.\nComparing (8th) vs (9th), is like 1st vs 5th, 9th has avoidance of very small space like 4th, and adds almost full bins like 1st, 2nd, 3rd. 8th included all components.\nComparing (10th) vs (11th), 10th combines fitability score, nearly-full priority, overfill penalty, and best-fit logic.\n\nOverall: The better heuristics incorporate multiple factors, including feasibility, best fit, avoidance of small spaces, and encouragement of filling bins completely. Tunable parameters appear beneficial. Simpler heuristics relying on single metrics (like log ratios) perform poorly. Penalizing the fullest bins can help to avoid premature convergence.\n- \nOkay, here's a refined perspective on self-reflection for designing better heuristics, focused on actionable steps and avoiding common pitfalls:\n\n*   **Keywords:** Iterative refinement, multi-objective balance, parameterized tunability, constraint satisfaction.\n\n*   **Advice:** Build a heuristic incrementally. Start with feasibility, then optimize for secondary objectives, and finally balance competing concerns.\n\n*   **Avoid:** Over-reliance on single metrics, premature optimization, and inflexible, hard-coded logic.\n\n*   **Explanation:** A strong heuristic is rarely built in one go. Begin with essential components (feasibility), layer in improvements (efficiency, balance), and allow for fine-tuning via parameters to adapt to different problem instances.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}