```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Prioritizes bins considering feasibility, best fit (ratio), and fragmentation."""

    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # 1. Feasibility: Disqualify bins that can't fit the item.
    infeasible_mask = item > bins_remain_cap
    priorities[infeasible_mask] = -np.inf

    # 2. Best Fit (Ratio-based): Prioritize based on fill ratio (item_size / bin_capacity).
    feasible_mask = ~infeasible_mask
    remaining_capacity = bins_remain_cap[feasible_mask]
    fill_ratio = item / remaining_capacity
    priorities[feasible_mask] = fill_ratio  # Higher fill ratio is better

    # 3. Fragmentation avoidance: Penalize bins that would leave small remaining space relative to bin size.
    small_space_threshold = 0.15  # Avoid spaces smaller than 15%
    remaining_space = remaining_capacity - item
    frag_mask = (remaining_space > 0) & (remaining_space / remaining_capacity < small_space_threshold)
    priorities[feasible_mask][frag_mask] -= 0.1 # Reduce priority if creates fragment

    #4. Utilize almost full bins
    almost_full_threshold = 0.85
    almost_full_mask = (bins_remain_cap[feasible_mask] - item) / bins_remain_cap[feasible_mask] < (1- almost_full_threshold)
    priorities[feasible_mask][almost_full_mask]+= 0.15

    return priorities
```
