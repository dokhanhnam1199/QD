```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version prioritizes bins that can accommodate the item with minimal waste
    but also avoids overly tight fits to leave room for future items. We incorporate
    a 'sweet spot' for remaining capacity.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    for i, capacity in enumerate(bins_remain_cap):
        if capacity >= item:
            # Calculate the remaining space after adding the item
            remaining_space = capacity - item

            # Define a "sweet spot" as a fraction of the bin size, avoid being too close to 0
            sweet_spot_lower = 0.1  # Avoid filling bins too tightly initially.
            sweet_spot_upper = 0.5

            # Normalize by remaining capacity if possible. If not, leave priorities alone.
            normalized_remaining = remaining_space / capacity

            if sweet_spot_lower <= normalized_remaining <= sweet_spot_upper:
                # Prioritize bins with remaining capacity in the sweet spot
                priorities[i] = 1 + (sweet_spot_upper - normalized_remaining)  # Higher priority the closer we are to the lower end of the sweet spot

            else:
                #If bins not in sweet spot, then prioritize bins with more space if item is smaller than average capacity or prioritize bins with less space if item is larger than average capacity to better balance filling bins.
                average_capacity = np.mean(bins_remain_cap)
                if item < average_capacity:
                  priorities[i] = 0.5 - abs(normalized_remaining - sweet_spot_lower) if normalized_remaining < sweet_spot_lower else 0.5 - abs(normalized_remaining - sweet_spot_upper) if normalized_remaining > sweet_spot_upper else 0
                else:
                  priorities[i] = 0.5 + (sweet_spot_upper - normalized_remaining) if normalized_remaining < sweet_spot_upper else 0
        else:
            priorities[i] = -1  # Assign a low priority to bins that can't fit the item

    return priorities
```
