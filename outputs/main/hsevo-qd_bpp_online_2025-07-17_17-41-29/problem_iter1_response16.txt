```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.
    Prioritizes bins that can accommodate the item with minimal waste,
    but also avoids filling bins completely to allow for flexibility with
    future, potentially smaller, items. Uses a sigmoid function to
    balance waste minimization and future packing potential.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Option 1: Penalize bins that are too small
    infeasible = bins_remain_cap < item
    priorities[infeasible] = -np.inf  # Significantly disincentivize

    #Option 2: Waste minimization (bins that fit the item with less waste gets higher priority)
    waste = bins_remain_cap - item
    #Avoid bins that would be filled to the brim. Encourage some flexibility for future smaller items.
    #Use a sigmoid function to model this preference.
    sigmoid = 1 / (1 + np.exp(-10 * (waste - 0.1))) #waste of 0.1 gets a score of ~0.5, smaller waste -> closer to 1, larger waste -> closer to 0
    priorities[~infeasible] = sigmoid[~infeasible] # only calculate for feasible bins

    # Option 3: Consider number of items already present in bin
    # This could potentially avoid spreading single items across multiple bins,
    # although requires additional information regarding the already present items in bins which may or may not be easy.

    return priorities
```
