{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: Give -inf priority if item doesn't fit\n    infeasible_mask = item > bins_remain_cap\n    priorities[infeasible_mask] = -np.inf\n\n    # 2. Best Fit: Prioritize bins where the remaining space after placing the item is small.\n    feasible_mask = ~infeasible_mask\n    remaining_space = bins_remain_cap[feasible_mask] - item\n    priorities[feasible_mask] = -remaining_space  # Smaller remaining space -> higher priority\n\n    # 3. Avoidance of very small spaces: Penalize bins leaving very small spaces, but only if other bins are more reasonable fits\n    small_space_threshold = 0.1  # Tuneable parameter: Avoid leaving spaces smaller than 10% of bin capacity\n    very_small_space_mask = (remaining_space > 0) & (remaining_space < small_space_threshold)\n    #Only apply the penalty if it's not the absolute best fit available\n    if np.any(very_small_space_mask):\n        min_remaining_space = np.min(remaining_space)\n        very_small_and_not_best = very_small_space_mask & (remaining_space > min_remaining_space)\n        priorities[feasible_mask][very_small_and_not_best] -= 0.01\n\n    # 4. Utilize Almost Full Bins: Reward bins that are almost full, encouraging complete filling of existing bins\n    almost_full_threshold = 0.9  # Define what constitutes an \"almost full\" bin after placing the item\n    almost_full_mask = (bins_remain_cap[feasible_mask] - item) / bins_remain_cap[feasible_mask] > almost_full_threshold\n    priorities[feasible_mask][almost_full_mask] += 0.02\n\n    # 5. Moderate Fit: Reward bins that have a moderate fit, reducing fragmentation\n    moderate_fit_threshold_low = 0.2\n    moderate_fit_threshold_high = 0.6\n    moderate_fit_mask = (item / bins_remain_cap[feasible_mask] >= moderate_fit_threshold_low) & (item / bins_remain_cap[feasible_mask] <= moderate_fit_threshold_high)\n    priorities[feasible_mask][moderate_fit_mask] += 0.01\n\n    #6. Prioritize bins with more remaining capacity when multiple bins can accomodate the item\n    #Helps to distribute the items to avoid filling bins too early, potentially leading to a better overall packing.\n    capacity_normalized = bins_remain_cap[feasible_mask]/np.max(bins_remain_cap)\n    priorities[feasible_mask] += 0.005*capacity_normalized #Small weight so as not to override other heuristics\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    ratios = item / bins_remain_cap\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see the first heuristic implements a detailed priority system, incorporating feasibility, best fit, avoidance of small spaces, and utilization of almost full bins, while the last one only considers the ratio of item size to remaining capacity using a log scale. Comparing (2nd best) vs (second worst), we see that the second-best heuristic attempts to combines best-fit, avoidance of small spaces, and balancing through small adjustments to priorities with an emphasis on leaving enough room, while second worst still focuses on item/bin ratio, without consideration for leaving enough room.. Comparing (1st) vs (2nd), we see (1st) emphasizes thresholds based on absolute remaining space, while (2nd) uses thresholds based on *ratio* of remaining space which may be better since it is more scalable.. (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see that second-worst to worst has the same functionality, which means there may not have been much difference between the two codes during the test. Overall: The better heuristics involve multiple factors, including feasibility, best fit, avoidance of creating extremely small spaces, and rewarding nearly full bins. The worse heuristics focus primarily on a single factor, such as the ratio between item size and remaining capacity, or have redundant code. Additionally, more successful heuristics often include tunable parameters (thresholds, penalties, rewards) and small adjustments to the priority scores.\n- \nOkay, let's refine \"Current Self-Reflection\" to design better heuristics, actively avoiding the pitfalls of \"Ineffective Self-Reflection\":\n\n*   **Keywords:** Multi-factor, iterative refinement, tunable parameters, balancing.\n*   **Advice:** Design heuristics incrementally. Start with feasibility, add best fit, and then progressively refine (e.g., avoiding fragmentation). Balance the final solution distribution.\n*   **Avoid:** Over-reliance on single metrics or hard-coded values. Generic \"experiment with combinations\" advice without a clear strategy.\n*   **Explanation:** This approach focuses on a structured design process, emphasizing iterative improvement and careful tuning, rather than vague experimentation. Balance ensures a holistic view of the problem.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}