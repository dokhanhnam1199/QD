```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This function considers several factors to determine bin priority:
    1. Remaining capacity: Bins with capacity closer to the item size are preferred.
    2. Item size relative to bin size: A bin is preferred if the item fills a significant portion of its capacity.
    3. Avoidance of near-full bins after placement: Placing into near-full bins leads to fragmentation; less desirable.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    for i, cap in enumerate(bins_remain_cap):
        if cap >= item:
            # Capacity Factor: Give preference to bins closer to the item's size
            capacity_factor = 1 / abs(cap - item + 0.00001)  # Avoid division by zero

            # Fill Ratio Factor: Favor bins where item fills significant portion of bin
            fill_ratio = item / cap
            fill_ratio_factor = fill_ratio

            # Fragmentation Penalty: Discourage near-full bin after placement
            remaining_after = cap - item
            if remaining_after < 0.1: # If not enough room for small items, avoid
                fragmentation_penalty = -10 # A high negative penalty

            elif remaining_after < 0.25 :
                fragmentation_penalty = -5  # Moderate negative penalty
            else:
                fragmentation_penalty = 0 # No penalty if adequate room remaining

            priorities[i] = capacity_factor + fill_ratio_factor + fragmentation_penalty

        else:
            priorities[i] = -np.inf  # Item doesn't fit, lowest priority

    return priorities
```
