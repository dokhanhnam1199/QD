```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version incorporates a 'fitability' score and randomness
    inspired by quantum probabilities.  We also include a preference
    for bins that are nearly full *after* the item is placed, mimicking
    a 'least waste' approach, and a penalty for exceeding bin capacity.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    # Fitability Score: How well the item fits (lower is better, but small)
    fitability = np.abs(bins_remain_cap - item)

    # Remaining Capacity Ratio:  Smaller ratio means almost full bin.
    remaining_ratio = np.clip((bins_remain_cap - item) / np.mean(bins_remain_cap), a_min=0.0, a_max=1.0)  #prevent negative and scaling issues
    # Preference for bins that are nearly full AFTER placement. Logarithm amplifies the preference for nearly empty space after placement
    nearly_full_priority = -np.log(remaining_ratio + 0.001)  # Avoid log(0)

    # Penalty for exceeding capacity
    overfill_penalty = np.where(item > bins_remain_cap, -1e9, 0) # Large negative penalty

    # "Quantum" Randomness: add tiny random variations
    randomness = np.random.rand(len(bins_remain_cap)) * 0.01

    # Combining Scores: weighted sum
    priorities = (
        -fitability * 0.5
        + nearly_full_priority * 1.0
        + overfill_penalty
        + randomness
    )

    return priorities
```
