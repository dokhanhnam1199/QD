```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version prioritizes bins that have enough space to accommodate the item,
    favoring bins with smaller remaining capacity after the item is placed.
    Bins that cannot fit the item receive a very low priority.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins that can accommodate the item
    fit_indices = bins_remain_cap >= item

    if np.any(fit_indices):
        # Calculate remaining capacity after placing the item (only for fitting bins)
        remaining_capacity = bins_remain_cap[fit_indices] - item

        # Prioritize bins with smaller remaining capacity after placement
        # Use a negative exponential to amplify the difference. A smaller remaining capacity becomes a bigger (less negative) number, therefore higher priority.
        #A smaller value of scale, e.g. 0.2, would amplify the sensitivity to small remaining capacities (high reward for tightly packing), while larger ones decrease sensitivity and smooth scores.
        scale = np.mean(bins_remain_cap) if np.mean(bins_remain_cap) > 0 else 1 #Dynamically adjust scale, if all the bins are empty, the scale would be 1, avoiding a division by 0
        priorities[fit_indices] = np.exp(-remaining_capacity / scale)

    # Non-fitting bins get a very low priority (close to zero, but not exactly zero to avoid potential division by zero errors downstream)
    #priorities[~fit_indices] = 1e-9  #Assign very low priorites instead of zero, which prevent potential ZeroDivisionErrors in later calculations.

    return priorities
```
