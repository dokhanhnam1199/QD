```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Prioritizes bins based on feasibility, best fit, and fragmentation."""

    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # 1. Feasibility: Disqualify bins that can't fit the item.
    infeasible_mask = item > bins_remain_cap
    priorities[infeasible_mask] = -np.inf

    # 2. Best Fit (Ratio-based): Prioritize based on fill ratio.
    feasible_mask = ~infeasible_mask
    remaining_capacity = bins_remain_cap[feasible_mask]
    fill_ratio = item / remaining_capacity
    priorities[feasible_mask] = fill_ratio

    # 3. Fragmentation avoidance: Penalize bins that would leave small space.
    small_space_threshold = 0.15
    remaining_space = remaining_capacity - item
    frag_mask = (remaining_space > 0) & (remaining_space / remaining_capacity < small_space_threshold)
    priorities[feasible_mask][frag_mask] -= 0.1

    #4. Utilize almost full bins
    almost_full_threshold = 0.85
    almost_full_mask = (bins_remain_cap[feasible_mask] - item) / bins_remain_cap[feasible_mask] < (1- almost_full_threshold)
    priorities[feasible_mask][almost_full_mask]+= 0.15

    # 5. Balance: Prioritize bins with larger remaining capacity (slightly).
    priorities[feasible_mask] += 0.01 * (remaining_capacity / np.max(bins_remain_cap))  # Normalize

    return priorities
```
