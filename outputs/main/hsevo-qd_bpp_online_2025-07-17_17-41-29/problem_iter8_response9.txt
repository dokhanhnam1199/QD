```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Combines feasibility, best fit, nearly-full, and avoids tiny spaces."""

    # Feasibility: Only consider bins that can fit the item
    feasible_mask = bins_remain_cap >= item
    priorities = np.zeros_like(bins_remain_cap)

    if np.any(feasible_mask):
        # Best Fit: Prioritize bins with smallest remaining capacity after placing item.
        remaining_capacities = bins_remain_cap[feasible_mask] - item
        best_fit_priority = 1 / (remaining_capacities + 0.00001) # avoid division by zero
        priorities[feasible_mask] += best_fit_priority * 0.6

        # Nearly Full: Incentivize bins that become nearly full after placement.
        remaining_ratio = np.clip((bins_remain_cap[feasible_mask] - item) / np.max(bins_remain_cap), a_min=0.0, a_max=1.0)
        nearly_full_priority = -np.log(remaining_ratio + 0.001) # avoid log(0)
        priorities[feasible_mask] += nearly_full_priority * 0.4

    # Large penalty for bins that can't fit
    priorities[~feasible_mask] = -1e9
    return priorities
```
