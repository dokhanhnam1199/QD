```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Inspired by the celestial dance, we favor bins that are 'near' the item's size
    but also consider the overall 'harmony' by looking at how full the bin would be.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    for i, cap in enumerate(bins_remain_cap):
        if cap >= item:
            # Distance from the item's size, but relative to remaining capacity to account for bin size differences
            distance_penalty = np.abs(cap - item) / (item + 1e-9) #Avoid division by zero. Add small constant to prevent infinities

            # Harmony term: favors bins that, when filled, wouldn't be too full or too empty
            future_capacity = cap - item
            harmony_factor = 1.0 - np.abs(future_capacity - (np.sum(bins_remain_cap) - cap)) / (np.sum(bins_remain_cap)+1e-9)  # Bin near average future cap
            #Prioritize the bins based on factors inspired by the music of the spheres.
            priorities[i] = (1.0 - distance_penalty) + 0.5*harmony_factor

            #Prioritize better fit to empty bins better. Helps with spreading the bin capacity usage.
            if cap > 0:
                 priorities[i] *= (cap / np.sum(bins_remain_cap) +1e-9)

    return priorities
```
