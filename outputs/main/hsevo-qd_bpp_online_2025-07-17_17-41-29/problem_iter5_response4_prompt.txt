{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Combines fitability, nearly-full preference, overfill penalty, and best-fit logic.\"\"\"\n    # Fitability score, penalizing bins much larger or smaller than the item.\n    fitability = np.abs(bins_remain_cap - item)\n\n    # Nearly-full priority, preferring bins nearly full after item placement.\n    remaining_ratio = np.clip((bins_remain_cap - item) / np.mean(bins_remain_cap), a_min=0.0, a_max=1.0)\n    nearly_full_priority = -np.log(remaining_ratio + 0.001)\n\n    # Overfill penalty, strongly discouraging exceeding bin capacity.\n    overfill_penalty = np.where(item > bins_remain_cap, -1e9, 0)\n\n    # Best-fit component: prioritize smallest remaining space if it fits.\n    fit_indices = np.where(bins_remain_cap >= item)[0]\n    best_fit_priority = np.zeros_like(bins_remain_cap)\n    if len(fit_indices) > 0:\n        remaining_capacities_after_fit = bins_remain_cap[fit_indices] - item\n        best_fit_priority[fit_indices] = 1 / (remaining_capacities_after_fit + 0.00001)\n\n    # Combine all components with weights.\n    priorities = (\n        -fitability * 0.3\n        + nearly_full_priority * 0.7\n        + overfill_penalty\n        + best_fit_priority * 0.5\n    )\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    ratios = item / bins_remain_cap\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see the first heuristic considers feasibility, best fit, avoidance of very small spaces, utilizes almost full bins and introduces a balancing term. The last heuristic only considers a ratio of item size to remaining bin capacity using logarithms.\nComparing (2nd) vs (19th), the second heuristic considers feasibility, best fit, avoidance of very small spaces by applying penalty and utilizes almost full bins by giving a reward. The 19th heuristic, similar to the 20th only considers a ratio of item size to remaining bin capacity using logarithms.\nComparing (1st) vs (2nd), the first heuristic introduces a balancing term to penalize filling up the fullest bins when there are more available options.\nComparing (3rd) vs (4th), these two heuristics are identical, indicating they perform similarly. This suggests that just including the core logic of feasibility, best fit, small space avoidance, and utilizing almost full bins is a good starting point.\nComparing (second worst) vs (worst), we see that the second worst introduces a variety of parameters for tuning, this seems to suggest a basic version and an advanced version. Overall: The better heuristics incorporate multiple factors beyond just a simple ratio. They factor in feasibility, aim for best fit, avoid creating tiny remaining spaces, and prefer filling bins that are nearly full. Some also incorporate balancing to prevent premature filling of certain bins.\n- \nOkay, let's refine \"Current self-reflection\" for better heuristic design:\n\n*   **Keywords:** Principles, Evaluation, Adaptation, Simplification.\n*   **Advice:** Focus on fundamental principles first. Rigorously evaluate each added refinement's impact. Adapt the heuristic based on performance feedback. Aim for simplicity to avoid overfitting.\n*   **Avoid:** Arbitrary complexity, premature optimization, neglecting edge cases.\n*   **Explanation:** Prioritize a clear understanding of the problem, create a simple initial heuristic based on core principles, and then iteratively improve it by focusing on specific shortcomings identified through careful evaluation.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}