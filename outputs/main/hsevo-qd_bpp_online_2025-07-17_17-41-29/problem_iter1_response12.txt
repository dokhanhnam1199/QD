```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Inspired by the laws of gravity and potential energy:
    A smaller difference between item size and remaining capacity yields higher attraction (priority).
    Empty bins are strongly discouraged.
    Also introduces a component akin to simulated annealing:
    Acceptance probability influenced by a 'temperature' that decreases with filled bins
    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Avoid division by zero by adding a tiny epsilon
    epsilon = 1e-9
    
    # Remaining capacity after potentially placing the item
    potential_remaining_cap = bins_remain_cap - item
    
    # Calculate 'gravitational potential' - smaller remaining cap is 'lower'
    potential = -potential_remaining_cap  # Negative, higher value is preferred

    # Penalize bins that become too full
    overfill_penalty = np.where(potential_remaining_cap < 0, -np.inf, 0)  # Large negative if item doesn't fit

    # Encourage filling empty bins if the item fills it sufficiently. If after filling there will be some capacity left, do nothing.
    nearly_full_bonus = np.where((bins_remain_cap > 0) & (potential_remaining_cap > 0) & (potential_remaining_cap < 0.1), 1 / (potential_remaining_cap + epsilon), 0)

    # Penalize use of almost empty bins.
    almost_empty_penalty = np.where(bins_remain_cap >=0.95, -10, 0)

    # Combine effects - potential energy + overfill penalty + almost empty penalty+ nearly_full_bonus
    priorities = potential + overfill_penalty + nearly_full_bonus + almost_empty_penalty
    
    return priorities
```
