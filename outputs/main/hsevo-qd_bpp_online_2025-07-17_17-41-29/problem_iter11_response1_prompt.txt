{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Combines fitability, nearly-full preference, overfill penalty, and best-fit logic.\"\"\"\n    # Fitability score, penalizing bins much larger or smaller than the item.\n    fitability = np.abs(bins_remain_cap - item)\n\n    # Nearly-full priority, preferring bins nearly full after item placement.\n    remaining_ratio = np.clip((bins_remain_cap - item) / np.mean(bins_remain_cap), a_min=0.0, a_max=1.0)\n    nearly_full_priority = -np.log(remaining_ratio + 0.001)\n\n    # Overfill penalty, strongly discouraging exceeding bin capacity.\n    overfill_penalty = np.where(item > bins_remain_cap, -1e9, 0)\n\n    # Best-fit component: prioritize smallest remaining space if it fits.\n    fit_indices = np.where(bins_remain_cap >= item)[0]\n    best_fit_priority = np.zeros_like(bins_remain_cap)\n    if len(fit_indices) > 0:\n        remaining_capacities_after_fit = bins_remain_cap[fit_indices] - item\n        best_fit_priority[fit_indices] = 1 / (remaining_capacities_after_fit + 0.00001)\n\n    # Combine all components with weights.\n    priorities = (\n        -fitability * 0.3\n        + nearly_full_priority * 0.7\n        + overfill_penalty\n        + best_fit_priority * 0.5\n    )\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    ratios = item / bins_remain_cap\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see the best heuristic incorporates feasibility, best fit, avoidance of small spaces, utilization of almost full bins, and a balancing term, while the worst only considers the ratio of item size to remaining bin capacity using a logarithmic scale. (2nd) introduces the idea of fitability score, nearly-full priority, overfill penalty, and best-fit component.\n(1st) vs (6th): They are identical.\n(2nd) vs (3rd): They are identical.\n(4th) vs (5th): They are identical.\n(11th) vs (20th): They are identical.\nComparing (1st) vs (2nd), we see that the best heuristic uses a rule-based approach with specific thresholds and penalties/rewards for different scenarios, while the second best uses a weighted combination of continuous scores (fitability, nearly-full priority, etc.). The first one is more explicit and interpretable.\nComparing (4th) vs (8th), the main difference lies in the use of parameters in (4th) versus hardcoded values in (8th). This makes (4th) more flexible but also requires tuning. (4th) also includes a condition to only apply the small space penalty when more fits are feasible.\nComparing (2nd) vs (4th), (2nd) uses a combination of continuous scores and weights, while (4th) uses thresholds and penalties/rewards.\n\nOverall: The better heuristics involve multiple factors and potentially non-linear combinations or conditional application of rules. Simpler heuristics relying solely on ratios are less effective. Introducing tunable parameters improves flexibility. The best heuristics appear to balance exploration and exploitation by discouraging leaving very small spaces and rewarding filling bins almost completely.\n- \nHere's a redefined \"Current Self-Reflection\" focusing on actionable insights for heuristic design, while avoiding the pitfalls of the \"Ineffective Self-Reflection\":\n\n*   **Keywords:** Iterative refinement, modularity, parameterized balancing, feasibility-first.\n*   **Advice:** Design heuristics in stages, starting with a feasible solution and then adding layers of improvement. Focus on creating modular components (e.g., a feasibility checker, a bin selection module, a balancing module) that can be adjusted and combined. Parameterize the balancing stage to fine-tune the trade-offs between different objectives.\n*   **Avoid:** Premature complexity. Resist the urge to combine everything at once.\n*   **Explanation:** A staged, modular approach allows for easier debugging, testing, and adaptation of the heuristic. Parameterized balancing provides flexibility to prioritize different performance aspects. Starting with feasibility ensures a solid foundation.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}