```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Initialize priorities with a small default value to avoid division by zero and negative infinity issues.
    priorities = np.zeros_like(bins_remain_cap, dtype=float) - 1e9 # Large negative value makes them very low priority by default.
    
    # Identify bins where the item can fit
    fit_mask = bins_remain_cap >= item
    
    # Prioritize bins with tighter fits (minimize wasted space). Use a softmax approach for this.
    # The idea is to assign higher priority to bins whose remaining capacity after placement will be small.
    remaining_space = bins_remain_cap - item
    remaining_space[~fit_mask] = np.inf # Make invalid spaces effectively infinitely large for softmax calculation

    # Apply softmax after subtracting the minimum from remaining_space, which adds stability
    remaining_space_shifted = remaining_space - np.min(remaining_space[fit_mask]) if np.any(fit_mask) else remaining_space
    priorities[fit_mask] = np.exp(-remaining_space_shifted[fit_mask]) / np.sum(np.exp(-remaining_space_shifted[fit_mask])) if np.any(fit_mask) else 0.

    # Boost the priority of bins that are nearly full to try and complete them, provided the item fits
    nearly_full_threshold = 0.1  # e.g., Bin is considered nearly full if remaining capacity is less than 10% of item size
    nearly_full_bins = (bins_remain_cap <= item * (1 + nearly_full_threshold)) & fit_mask

    priorities[nearly_full_bins] += 1.0  # Add a boost to priority of nearly full bins
    return priorities
```
