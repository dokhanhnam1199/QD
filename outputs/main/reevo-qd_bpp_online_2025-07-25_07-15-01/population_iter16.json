[
  {
    "stdout_filepath": "problem_iter4_response0.txt_stdout.txt",
    "code_path": "problem_iter4_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on the ratio of the remaining capacity and the item size.\n    It prioritizes near-full bins, penalizes extremes and size mismatches, and balances ratio calculations.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Bins with less capacity than the item get zero priority\n    priority_score = np.where(bins_remain_cap < item, 0, \n                              # Balance ratio calculations\n                              (bins_remain_cap / (bins_remain_cap + item)) * \n                              # Priority is higher for bins that can just hold the item\n                              (1 / (1 + np.abs((bins_remain_cap - item) / bins_remain_cap))))\n    # Penalize extremes\n    priority_score = np.where((bins_remain_cap - item) > (bins_remain_cap / 2), 0.5 * priority_score, priority_score)\n    priority_score = np.where((bins_remain_cap - item) < -(bins_remain_cap / 2), 0.5 * priority_score, priority_score)\n    return priority_score",
    "response_id": 0,
    "obj": 3.8492221779018885,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 75.28421251514429,
    "mi": 65.824940363938,
    "token_count": 87.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response3.txt_stdout.txt",
    "code_path": "problem_iter5_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function simplifies and prioritizes ratios, \n    prioritizes near-full bins, and combines key factors for more effective heuristics.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Bins with less capacity than the item get zero priority\n    priority_score = np.where(bins_remain_cap < item, 0, \n                              # Simplify ratio calculations and prioritize near-full bins\n                              (1 - np.abs((bins_remain_cap - item) / bins_remain_cap)) * \n                              # Balance calculations\n                              (bins_remain_cap / (bins_remain_cap + item)))\n    # Penalize extremes and size mismatches\n    priority_score = np.where(np.abs((bins_remain_cap - item) / bins_remain_cap) > 0.5, 0.5 * priority_score, priority_score)\n    return priority_score",
    "response_id": 3,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 206.43891887060175,
    "mi": 83.86606999214833,
    "token_count": 152.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response1.txt_stdout.txt",
    "code_path": "problem_iter6_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on their remaining capacity relative to the item size,\n    balancing between utilizing space efficiently and avoiding extreme bin sizes.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Bins with less capacity than the item get zero priority\n    priority_score = np.where(bins_remain_cap < item, 0, \n                              # Balance ratio calculations, prioritizing near-full bins\n                              (bins_remain_cap / (bins_remain_cap + item)) * \n                              # Penalty for size mismatch, favoring bins that can just hold the item\n                              (1 / (1 + np.abs((bins_remain_cap - item) / (bins_remain_cap + 1e-8)))))\n    # Apply a soft penalty for extreme bin sizes to discourage very large or very small bins\n    priority_score *= np.where(np.abs(bins_remain_cap - item) > (bins_remain_cap / 2), 0.7, 1)\n    return priority_score",
    "response_id": 1,
    "obj": 3.8492221779018885,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 62.26976913547136,
    "mi": 68.37294522281853,
    "token_count": 68.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter7_response4.txt_stdout.txt",
    "code_path": "problem_iter7_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on the ratio of the remaining capacity and the item size.\n    It prioritizes near-full bins, penalizes extremes and size mismatches, and balances ratio calculations.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Bins with less capacity than the item get zero priority\n    priority_score = np.where(bins_remain_cap < item, 0, \n                              # Balance ratio calculations and prioritize near-full bins\n                              (1 - (bins_remain_cap - item) / bins_remain_cap) * \n                              # Reduce priority for bins with large remaining capacity\n                              (1 / (1 + np.abs(bins_remain_cap - item))))\n    # Penalize extremes and size mismatches\n    priority_score = np.where((bins_remain_cap - item) > (bins_remain_cap / 2), 0.25 * priority_score, priority_score)\n    priority_score = np.where((bins_remain_cap - item) < -(bins_remain_cap / 2), 0.25 * priority_score, priority_score)\n    return priority_score",
    "response_id": 4,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 229.24812503605784,
    "mi": 81.82777748928844,
    "token_count": 130.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response2.txt_stdout.txt",
    "code_path": "problem_iter8_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on the ratio of the remaining capacity and the item size.\n    It prioritizes near-full bins, penalizes extremes and size mismatches, and balances ratio calculations.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Bins with less capacity than the item get zero priority\n    priority_score = np.where(bins_remain_cap < item, 0, \n                              # Simplify and balance ratio calculations\n                              (bins_remain_cap / (bins_remain_cap + item)) * \n                              # Reduce priority for large size differences\n                              (1 / (1 + np.abs(bins_remain_cap - item) / bins_remain_cap)))\n    # Penalize large size mismatches\n    priority_score = np.where(np.abs(bins_remain_cap - item) > (bins_remain_cap / 2), 0.5 * priority_score, priority_score)\n    return priority_score",
    "response_id": 2,
    "obj": 3.8492221779018885,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 312.1143675543732,
    "mi": 82.81332607414046,
    "token_count": 157.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response1.txt_stdout.txt",
    "code_path": "problem_iter10_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on their relative remaining capacity to the item size,\n    emphasizing balance between utilization efficiency and size harmony.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Bins with less capacity than the item get zero priority\n    priority_score = np.where(bins_remain_cap < item, 0, \n                              # Balance ratio calculations, favoring near-full bins relative to item size\n                              (bins_remain_cap / (bins_remain_cap + item)) * \n                              # Relative penalty for size mismatch, favoring bins with capacity closer to item size\n                              (1 / (1 + np.abs((bins_remain_cap - item) / item))))\n    # Apply a soft, relative penalty for extreme bin sizes to maintain balance\n    priority_score *= np.where(np.abs(bins_remain_cap - item) > (bins_remain_cap * 0.5), 0.7, 1)\n    return priority_score",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 105.48604608143,
    "mi": 81.70321872525761,
    "token_count": 81.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response8.txt_stdout.txt",
    "code_path": "problem_iter12_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on the ratio of the remaining capacity and the item size.\n    It simplifies and balances ratio calculations, reduces priority for large size differences, \n    and penalizes large size mismatches.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Bins with less capacity than the item get zero priority\n    priority_score = np.where(bins_remain_cap < item, 0, \n                              # Simplify and balance ratio calculations\n                              (bins_remain_cap / (bins_remain_cap + item)) * \n                              # Reduce priority for large size differences\n                              (1 / (1 + np.abs(1 - (item / bins_remain_cap)))))\n    # Penalize large size mismatches\n    priority_score = np.where(np.abs(bins_remain_cap - item) > (bins_remain_cap / 2), 0.5 * priority_score, priority_score)\n    return priority_score",
    "response_id": 8,
    "obj": 3.8492221779018885,
    "SLOC": 13.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 419.8342010754868,
    "mi": 82.87372107396543,
    "token_count": 175.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter13_response4.txt_stdout.txt",
    "code_path": "problem_iter13_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on the ratio of the remaining capacity and the item size.\n    It prioritizes near-full bins, moderately penalizes extremes and size mismatches, and simplifies ratio calculations.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Bins with less capacity than the item get zero priority\n    priority_score = np.where(bins_remain_cap < item, 0, \n                              # Simplify ratio calculations and prioritize balance\n                              (bins_remain_cap / (bins_remain_cap + item)) ** 0.5)\n    # Moderately penalize extremes and size mismatches\n    priority_score = np.where((bins_remain_cap - item) > (bins_remain_cap / 2), 0.75 * priority_score, priority_score)\n    priority_score = np.where((bins_remain_cap - item) < -(bins_remain_cap / 2), 0.75 * priority_score, priority_score)\n    # Prioritize near-full bins\n    priority_score = np.where(np.abs(bins_remain_cap - item) < item * 0.1, 1.25 * priority_score, priority_score)\n    return priority_score",
    "response_id": 4,
    "obj": 3.7794176306342333,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 232.19280948873623,
    "mi": 76.2645575307969,
    "token_count": 138.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response0.txt_stdout.txt",
    "code_path": "problem_iter14_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on their remaining capacity relative to the item size,\n    balancing between utilizing space efficiently and avoiding extreme bin sizes.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Bins with less capacity than the item get zero priority\n    priority_score = np.where(bins_remain_cap < item, 0, \n                              # Balance ratio calculations, prioritizing near-full bins\n                              (bins_remain_cap / (bins_remain_cap + item)) * \n                              # Penalty for size mismatch, favoring bins that can just hold the item\n                              (1 / (1 + np.abs((bins_remain_cap - item) / (bins_remain_cap + 1e-8)))))\n\n    # Apply a penalty for extreme bin sizes to discourage very large or very small bins\n    priority_score *= np.where(np.abs(bins_remain_cap - item) > (bins_remain_cap / 2), \n                               # soft penalty, reducing priority but not eliminating it\n                               0.5, \n                               # medium penalty for bins that are too large or too small\n                               np.where(np.abs(bins_remain_cap - item) > (bins_remain_cap / 4), 0.8, 1))\n\n    # Apply a bonus for bins that are nearly full to encourage efficient use of space\n    priority_score *= np.where((bins_remain_cap - item) < (bins_remain_cap / 10), 1.2, 1)\n    return priority_score",
    "response_id": 0,
    "obj": 3.8492221779018885,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 256.76392511682735,
    "mi": 79.17163234062605,
    "token_count": 137.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter15_response2.txt_stdout.txt",
    "code_path": "problem_iter15_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on the ratio of the remaining capacity and the item size.\n    It prioritizes balance, moderately penalizes extremes and size mismatches, and simplifies ratio calculations.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Bins with less capacity than the item get zero priority\n    priority_score = np.where(bins_remain_cap < item, 0, \n                              # Simplify ratio calculations and prioritize balance\n                              (bins_remain_cap / (bins_remain_cap + item)) ** 0.5)\n    \n    # Moderately penalize extremes and size disparities\n    priority_score = np.where(np.abs(bins_remain_cap - item) > item, 0.5 * priority_score, priority_score)\n    \n    # Prioritize near-full bins and penalize underfilled bins\n    priority_score = np.where(np.abs(bins_remain_cap - item) < item * 0.1, 1.5 * priority_score, priority_score)\n    priority_score = np.where(bins_remain_cap > item * 2, 0.25 * priority_score, priority_score)\n    \n    return priority_score",
    "response_id": 2,
    "obj": 3.7794176306342333,
    "SLOC": 11.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 373.28516483252554,
    "mi": 81.47861971591182,
    "token_count": 184.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter16_response0.txt_stdout.txt",
    "code_path": "problem_iter16_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function simplifies and balances ratio calculations, prioritizing near-full bins and penalizing extremes and size mismatches.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Bins with less capacity than the item get zero priority\n    priority_score = np.where(bins_remain_cap < item, 0, \n                              # Simplify ratio calculations\n                              (bins_remain_cap / (bins_remain_cap + item)) * \n                              # Balance ratio calculations and prioritize near-full bins\n                              (1 - np.abs((bins_remain_cap - item) / bins_remain_cap)))\n    # Penalize extremes and size mismatches\n    priority_score = np.where(np.abs(bins_remain_cap - item) > bins_remain_cap / 2, 0.5 * priority_score, priority_score)\n    return priority_score",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 140.1816079436383,
    "mi": 78.34750920170268,
    "token_count": 110.0,
    "exec_success": true
  }
]