```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Returns priority with which we want to add item to each bin.

    This priority function combines multiple factors with penalties for extreme bin sizes.
    The factors include the ratio of the remaining capacity to the item size, 
    the remaining capacity after the item is packed, and penalties for bins that are too large or too small.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Mask the bins that have enough capacity to hold the item
    enough_capacity_mask = bins_remain_cap >= item
    
    # Initialize the priority array with zeros
    priority = np.zeros_like(bins_remain_cap)
    
    # If there are no bins with enough capacity, fill the item into the bin with the most capacity
    if not np.any(enough_capacity_mask):
        priority[np.argmax(bins_remain_cap)] = 1
    else:
        # Calculate the ratio of the remaining capacity to the item size
        ratio = bins_remain_cap / np.maximum(item, bins_remain_cap)
        
        # Calculate the remaining capacity of each bin after the item is packed
        remaining_cap = np.where(enough_capacity_mask, bins_remain_cap - item, 1e8)
        
        # Assign higher priority to bins with less remaining capacity
        remaining_cap_score = 1 / (remaining_cap + 1)
        
        # Calculate penalty score for extreme bin sizes
        penalty_score = -np.abs(bins_remain_cap - item)
        
        # Calculate the final priority score by combining the ratio score, remaining capacity score, and penalty score
        priority = np.where(enough_capacity_mask, 
                            0.5 * ratio + 0.3 * remaining_cap_score + 0.2 * penalty_score, 
                            0)
    
    return priority
```
