[
  {
    "stdout_filepath": "problem_iter4_response0.txt_stdout.txt",
    "code_path": "problem_iter4_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on the ratio of the remaining capacity and the item size.\n    It prioritizes near-full bins, penalizes extremes and size mismatches, and balances ratio calculations.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Bins with less capacity than the item get zero priority\n    priority_score = np.where(bins_remain_cap < item, 0, \n                              # Balance ratio calculations\n                              (bins_remain_cap / (bins_remain_cap + item)) * \n                              # Priority is higher for bins that can just hold the item\n                              (1 / (1 + np.abs((bins_remain_cap - item) / bins_remain_cap))))\n    # Penalize extremes\n    priority_score = np.where((bins_remain_cap - item) > (bins_remain_cap / 2), 0.5 * priority_score, priority_score)\n    priority_score = np.where((bins_remain_cap - item) < -(bins_remain_cap / 2), 0.5 * priority_score, priority_score)\n    return priority_score",
    "response_id": 0,
    "obj": 3.8492221779018885,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 75.28421251514429,
    "mi": 65.824940363938,
    "token_count": 87.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response1.txt_stdout.txt",
    "code_path": "problem_iter4_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on the ratio of the remaining capacity to the item size.\n    If a bin has just enough capacity to hold the item, it gets the highest priority.\n    Bins with less capacity than the item get zero priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the ratio of the remaining capacity to the item size\n    ratio = bins_remain_cap / item\n    \n    # Bins with less capacity than the item get zero priority\n    priority_score = np.where(bins_remain_cap < item, 0, \n                              # Priority is higher for bins that can just hold the item\n                              1 / (1 + np.abs(1 - ratio)))\n    return priority_score",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 75.28421251514429,
    "mi": 65.824940363938,
    "token_count": 87.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response2.txt_stdout.txt",
    "code_path": "problem_iter4_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on the ratio of the remaining capacity and the item size.\n    It prioritizes near-full bins and penalizes extremes and size mismatches.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Bins with less capacity than the item get zero priority\n    priority_score = np.where(bins_remain_cap < item, -np.inf, \n                              # Priority is higher for bins that can just hold the item and are near-full\n                              (1 - np.abs((bins_remain_cap - item) / (bins_remain_cap + 1e-8))) / (1 + np.abs(bins_remain_cap - item)))\n    # Penalize bins that are too empty or too full\n    priority_score = np.where(bins_remain_cap / (bins_remain_cap + item) < 0.2, priority_score * 0.5, \n                              np.where(bins_remain_cap / (bins_remain_cap + item) > 0.8, priority_score * 0.8, priority_score))\n    # Add a small random value to the priority to break ties randomly\n    priority_score += np.random.uniform(0, 1e-9, size=priority_score.shape)\n    return priority_score",
    "response_id": 2,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 75.28421251514429,
    "mi": 65.824940363938,
    "token_count": 87.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response3.txt_stdout.txt",
    "code_path": "problem_iter4_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on the ratio of the remaining capacity and the item size.\n    It prioritizes near-full bins, penalizes extremes and size mismatches, and balances ratio calculations.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Bins with less capacity than the item get zero priority\n    priority_score = np.where(bins_remain_cap < item, 0, \n                              # Balance ratio calculations\n                              (bins_remain_cap / (bins_remain_cap + item)) * \n                              # Priority is higher for bins that can just hold the item\n                              (1 / (1 + np.abs((bins_remain_cap - item) / bins_remain_cap))))\n    # Penalize extremes\n    priority_score = np.where((bins_remain_cap - item) > (bins_remain_cap / 2), 0.5 * priority_score, priority_score)\n    priority_score = np.where((bins_remain_cap - item) < -(bins_remain_cap / 2), 0.5 * priority_score, priority_score)\n    return priority_score",
    "response_id": 3,
    "obj": 3.8492221779018885,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 75.28421251514429,
    "mi": 65.824940363938,
    "token_count": 87.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response4.txt_stdout.txt",
    "code_path": "problem_iter4_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on the ratio of the remaining capacity to the item size.\n    Bins with less capacity than the item get zero priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Bins with less capacity than the item get zero priority\n    # Priority is higher for bins that can just hold the item, using a smooth and simple ratio\n    priority_score = np.where(bins_remain_cap < item, 0, \n                              np.exp(-((bins_remain_cap - item) / item) ** 2))\n    return priority_score",
    "response_id": 4,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 75.28421251514429,
    "mi": 65.824940363938,
    "token_count": 87.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response5.txt_stdout.txt",
    "code_path": "problem_iter4_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on the ratio of the remaining capacity to the item size.\n    Bins with less capacity than the item get zero priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate priority score based on the ratio of remaining capacity to item size\n    priority_score = np.where(bins_remain_cap < item, 0, \n                              1 - (bins_remain_cap - item) / (bins_remain_cap + item))\n    return priority_score",
    "response_id": 5,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 75.28421251514429,
    "mi": 65.824940363938,
    "token_count": 87.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response6.txt_stdout.txt",
    "code_path": "problem_iter4_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on how well the item fits into them.\n    Bins that can hold the item with the least remaining space are prioritized.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining space if the item is added to each bin\n    remaining_space = np.where(bins_remain_cap >= item, bins_remain_cap - item, np.inf)\n    \n    # Lower remaining space indicates a better fit, so use inverse remaining space as priority score\n    priority_scores = np.where(remaining_space == np.inf, 0, 1 / (1 + remaining_space))\n    \n    return priority_scores",
    "response_id": 6,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 75.28421251514429,
    "mi": 65.824940363938,
    "token_count": 87.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response7.txt_stdout.txt",
    "code_path": "problem_iter4_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function combines multiple factors with penalties for extreme bin sizes.\n    The factors include the ratio of the remaining capacity to the item size, \n    the remaining capacity after the item is packed, and penalties for bins that are too large or too small.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Mask the bins that have enough capacity to hold the item\n    enough_capacity_mask = bins_remain_cap >= item\n    \n    # Initialize the priority array with zeros\n    priority = np.zeros_like(bins_remain_cap)\n    \n    # If there are no bins with enough capacity, fill the item into the bin with the most capacity\n    if not np.any(enough_capacity_mask):\n        priority[np.argmax(bins_remain_cap)] = 1\n    else:\n        # Calculate the ratio of the remaining capacity to the item size\n        ratio = bins_remain_cap / np.maximum(item, bins_remain_cap)\n        \n        # Calculate the remaining capacity of each bin after the item is packed\n        remaining_cap = np.where(enough_capacity_mask, bins_remain_cap - item, 1e8)\n        \n        # Assign higher priority to bins with less remaining capacity\n        remaining_cap_score = 1 / (remaining_cap + 1)\n        \n        # Calculate penalty score for extreme bin sizes\n        penalty_score = -np.abs(bins_remain_cap - item)\n        \n        # Calculate the final priority score by combining the ratio score, remaining capacity score, and penalty score\n        priority = np.where(enough_capacity_mask, \n                            0.5 * ratio + 0.3 * remaining_cap_score + 0.2 * penalty_score, \n                            0)\n    \n    return priority",
    "response_id": 7,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 75.28421251514429,
    "mi": 65.824940363938,
    "token_count": 87.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response8.txt_stdout.txt",
    "code_path": "problem_iter4_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on minimizing waste \n    and only considers bins where the item can fit.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the waste that would be generated by adding the item to each bin\n    waste = bins_remain_cap - item\n    \n    # Assign high priority to valid bins with lower waste\n    # and low priority (negative infinity) to invalid bins\n    priority = np.where(waste >= 0, -waste, -np.inf)\n    \n    return priority",
    "response_id": 8,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 75.28421251514429,
    "mi": 65.824940363938,
    "token_count": 87.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response9.txt_stdout.txt",
    "code_path": "problem_iter4_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on the ratio of the remaining capacity to the item size\n    and the absolute difference between the remaining capacity and the item size.\n    If a bin has just enough capacity to hold the item, it gets the highest priority.\n    Bins with less capacity than the item get zero priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the ratio of the remaining capacity to the item size\n    ratio = np.where(bins_remain_cap < item, 0, bins_remain_cap / item)\n    \n    # Calculate the absolute difference between the remaining capacity and the item size\n    abs_diff = np.abs(bins_remain_cap - item)\n    \n    # Priority is higher for bins with a ratio close to 1 and an absolute difference close to 0\n    priority_score = np.where(bins_remain_cap < item, 0, \n                              1 / (1 + abs_diff) * ratio)\n    return priority_score",
    "response_id": 9,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 75.28421251514429,
    "mi": 65.824940363938,
    "token_count": 87.0,
    "exec_success": true
  }
]