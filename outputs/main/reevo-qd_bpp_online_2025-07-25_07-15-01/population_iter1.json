[
  {
    "stdout_filepath": "problem_iter0_stdout0.txt",
    "code_path": "problem_iter0_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    return np.zeros_like(bins_remain_cap)",
    "response_id": 0,
    "obj": 4.487435181491823,
    "SLOC": 2.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 0.0,
    "mi": 100.0,
    "token_count": 32.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response0.txt_stdout.txt",
    "code_path": "problem_iter1_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to favor bins that have enough capacity to hold the item\n    and penalize bins that are too full or too empty. The priority score is calculated as the\n    remaining capacity of the bin divided by the item size plus a bonus for nearly full bins.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Ensure that the item can fit in the bin\n    can_fit = bins_remain_cap >= item\n    \n    # Calculate the priority score for each bin\n    priority = np.where(can_fit, bins_remain_cap / item + np.where(bins_remain_cap - item < item / 2, 1, 0), 0)\n    \n    # Reward bins that are nearly full\n    priority = np.where(can_fit, priority * (1 + (bins_remain_cap - item) / item), 0)\n    \n    return priority",
    "response_id": 0,
    "obj": 112.3055444754687,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 38.03910001730775,
    "mi": 69.87170528764138,
    "token_count": 60.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response1.txt_stdout.txt",
    "code_path": "problem_iter1_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function favors bins that have the most available capacity,\n    while being cautious of bins that would have less than half of their capacity\n    remaining after adding the item.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    # Calculate the difference between each bin's remaining capacity and the item size\n    remaining_cap_diffs = bins_remain_cap - item\n    \n    # Set priorities to the reciprocal of the difference, ensuring a higher priority for bins with more available capacity\n    # If a bin cannot hold the item, set its priority to a very low value\n    for i in range(len(remaining_cap_diffs)):\n        if remaining_cap_diffs[i] < 0:\n            priorities[i] = -1  # Item doesn't fit\n        else:\n            priorities[i] = 1 / np.exp((remaining_cap_diffs[i] - item) / bins_remain_cap[i])\n    \n    # Adjust priorities to discourage bins with less than half of their capacity remaining\n    priorities = np.multiply(priorities, np.where(bins_remain_cap > 2 * item, 1, 0.5))\n    \n    return priorities",
    "response_id": 1,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.99997138000617 seconds"
  },
  {
    "stdout_filepath": "problem_iter1_response2.txt_stdout.txt",
    "code_path": "problem_iter1_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on the ratio of the remaining capacity and the item size.\n    If a bin has just enough capacity to hold the item, it gets the highest priority.\n    Bins with less capacity than the item get zero priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Bins with less capacity than the item get zero priority\n    priority_score = np.where(bins_remain_cap < item, 0, \n                              # Priority is higher for bins that can just hold the item\n                              1 / (1 + np.abs(bins_remain_cap - item)))\n    return priority_score",
    "response_id": 2,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 38.03910001730775,
    "mi": 69.87170528764138,
    "token_count": 60.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response3.txt_stdout.txt",
    "code_path": "problem_iter1_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to favor bins that have just enough capacity to \n    hold the item. It avoids overfilling bins and minimizes waste.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity of each bin after adding the item\n    remaining_cap = bins_remain_cap - item\n    \n    # Calculate the absolute difference between the remaining capacity and zero\n    # This favors bins that have just enough capacity to hold the item\n    diff = np.abs(remaining_cap)\n    \n    # Calculate the priority score for each bin, favoring bins with the smallest difference\n    priority = 1 / (1 + diff)\n    \n    # For bins that have no remaining capacity after adding the item, set their priority to zero\n    priority[remaining_cap < 0] = 0\n    \n    return priority",
    "response_id": 3,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 38.03910001730775,
    "mi": 69.87170528764138,
    "token_count": 60.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response4.txt_stdout.txt",
    "code_path": "problem_iter1_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to prioritize bins that have just enough capacity to pack the item,\n    minimizing waste of space. If no such bin exists, it prioritizes bins with the least remaining capacity,\n    encouraging efficient use of space.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the absolute difference between the item size and the remaining capacity of each bin\n    diff = np.abs(bins_remain_cap - item)\n    \n    # Calculate the priority score based on the difference and remaining capacity\n    priority = 1 / (diff + 1) + bins_remain_cap / (bins_remain_cap + 1)\n    \n    # Normalize the priority scores to ensure they are not zero\n    priority = priority / (priority.max() + 1e-10)\n    \n    return priority",
    "response_id": 4,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 38.03910001730775,
    "mi": 69.87170528764138,
    "token_count": 60.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response5.txt_stdout.txt",
    "code_path": "problem_iter1_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on the ratio of the remaining capacity and the item size.\n    If a bin has just enough capacity to hold the item, it gets the highest priority.\n    Bins with less capacity than the item get zero priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Bins with less capacity than the item get zero priority\n    priority_score = np.where(bins_remain_cap < item, 0, \n                              # Priority is higher for bins that can just hold the item\n                              1 / (1 + np.abs(bins_remain_cap - item)))\n    return priority_score",
    "response_id": 5,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 38.03910001730775,
    "mi": 69.87170528764138,
    "token_count": 60.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response6.txt_stdout.txt",
    "code_path": "problem_iter1_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to favor bins that have enough capacity to hold the item and \n    that have the least remaining capacity after the item is packed. This approach is known as the \n    'Best Fit' strategy.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize the priority array with zeros\n    priority = np.zeros_like(bins_remain_cap)\n    \n    # Mask the bins that have enough capacity to hold the item\n    enough_capacity_mask = bins_remain_cap >= item\n    \n    # If there are no bins with enough capacity, fill the item into the bin with the most capacity\n    if not np.any(enough_capacity_mask):\n        priority[np.argmax(bins_remain_cap)] = 1\n    else:\n        # Calculate the remaining capacity of each bin after the item is packed\n        remaining_cap = bins_remain_cap[enough_capacity_mask] - item\n        \n        # Assign higher priority to bins with less remaining capacity\n        priority[enough_capacity_mask] = 1 / (remaining_cap + 1)\n    \n    return priority",
    "response_id": 6,
    "obj": 4.198244914240141,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 38.03910001730775,
    "mi": 69.87170528764138,
    "token_count": 60.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response7.txt_stdout.txt",
    "code_path": "problem_iter1_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins with the least remaining capacity that can still accommodate the item.\n    This helps in minimizing the number of bins used.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Find bins that can accommodate the item\n    valid_bins = bins_remain_cap >= item\n    \n    # If no valid bins, return zeros\n    if not np.any(valid_bins):\n        return np.zeros_like(bins_remain_cap)\n    \n    # Calculate the priority score for each bin\n    priority_scores = np.where(valid_bins, bins_remain_cap - item + 1, 0)\n    \n    # To break ties, prioritize the first bin\n    priority_scores = priority_scores + 1e-6 * np.arange(len(bins_remain_cap))\n    \n    return -priority_scores",
    "response_id": 7,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 38.03910001730775,
    "mi": 69.87170528764138,
    "token_count": 60.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response8.txt_stdout.txt",
    "code_path": "problem_iter1_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on the ratio of the remaining capacity and the item size.\n    If a bin has a remaining capacity close to the item size, it will have a higher priority score.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # calculate the ratio of the remaining capacity and the item size for each bin\n    # a higher ratio means a bin has less spare capacity after adding the item\n    ratio = bins_remain_cap / item\n    \n    # the ratio is clamped to a minimum value of 1 to avoid very large ratio values\n    # this helps to prevent underflow when calculating the priority scores\n    ratio = np.maximum(ratio, 1.0)\n    \n    # the priority score for each bin is the inverse of its ratio\n    # a lower ratio means a bin has a higher priority score\n    priority = np.power(1.0 / ratio, 2.0)\n    \n    # return the priority score for each bin\n    return priority",
    "response_id": 8,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 38.03910001730775,
    "mi": 69.87170528764138,
    "token_count": 60.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response9.txt_stdout.txt",
    "code_path": "problem_iter1_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on the ratio of the remaining capacity and the item size.\n    If a bin has just enough capacity to hold the item, it gets the highest priority.\n    Bins with less capacity than the item get zero priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Bins with less capacity than the item get zero priority\n    priority_score = np.where(bins_remain_cap < item, 0, \n                              # Priority is higher for bins that can just hold the item\n                              1 / (1 + np.abs(bins_remain_cap - item) / item))\n    return priority_score",
    "response_id": 9,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 38.03910001730775,
    "mi": 69.87170528764138,
    "token_count": 60.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response10.txt_stdout.txt",
    "code_path": "problem_iter1_code10.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on the ratio of the remaining capacity and the item size.\n    If a bin has a higher remaining capacity compared to the item size, it gets a higher priority score.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Ensure that we don't divide by zero\n    zeros = (bins_remain_cap == 0)\n    # Calculate the denominator to avoid division by zero\n    denominator = np.where(zeros, 1e-8, bins_remain_cap)\n    \n    # Calculate priority score based on the ratio\n    priority = np.where(zeros, 0, bins_remain_cap / np.maximum(item, denominator))\n    \n    # Add additional scoring to penalize bins that are too large or too small\n    priority -= (bins_remain_cap - item) ** 2\n    \n    return priority",
    "response_id": 10,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 38.03910001730775,
    "mi": 69.87170528764138,
    "token_count": 60.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response11.txt_stdout.txt",
    "code_path": "problem_iter1_code11.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to prioritize bins that have just enough capacity to accommodate the item.\n    It favors bins with remaining capacity closest to the item size, while also considering the absolute remaining capacity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the absolute difference between the item size and the remaining capacity of each bin\n    diff = np.abs(bins_remain_cap - item)\n    \n    # Calculate the priority score for each bin, favoring bins with remaining capacity closest to the item size\n    priority = 1 / (diff + 1)  # Adding 1 to avoid division by zero\n    \n    # To prevent extremely large priority values when the difference is very small,\n    # we can use a bounded inverse function like the sigmoid function\n    priority = 1 / (1 + np.exp(-(priority - 0.5)))\n    \n    return priority",
    "response_id": 11,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 38.03910001730775,
    "mi": 69.87170528764138,
    "token_count": 60.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response12.txt_stdout.txt",
    "code_path": "problem_iter1_code12.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on the ratio of the remaining capacity and the item size.\n    If a bin has just enough capacity to hold the item, it gets the highest priority.\n    Bins with less capacity than the item get zero priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # First, calculate the ratio of remaining capacity to item size\n    ratios = np.where(bins_remain_cap >= item, bins_remain_cap / item, 0)\n    \n    # Give higher priority to bins with ratio close to 1\n    scores = np.where(ratios > 0, 1 / ratios, 0)\n    \n    return scores",
    "response_id": 12,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 38.03910001730775,
    "mi": 69.87170528764138,
    "token_count": 60.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response13.txt_stdout.txt",
    "code_path": "problem_iter1_code13.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins with the most remaining capacity,\n    while preventing bins from being overfilled.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Ensure the item can fit in the bin\n    can_fit = remaining_cap_after_addition >= 0\n    \n    # Set priority to 0 for bins that cannot fit the item\n    priority = np.where(can_fit, remaining_cap_after_addition, -np.inf)\n    \n    # Add a small random value to the priority to break ties randomly\n    priority += np.random.uniform(0, 1e-9, size=priority.shape)\n    \n    return priority",
    "response_id": 13,
    "obj": 149.30195452732352,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 38.03910001730775,
    "mi": 69.87170528764138,
    "token_count": 60.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response14.txt_stdout.txt",
    "code_path": "problem_iter1_code14.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to encourage the packing of items into bins \n    where the item size is close to the remaining capacity, thereby minimizing waste \n    and reducing the number of bins needed.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the waste that would be generated by adding the item to each bin\n    waste = bins_remain_cap - item\n    \n    #_MASK describes valid bins \n    mask = waste >= 0\n    \n    # Assign high priority to valid bins with lower waste\n    priority = np.where(mask, -waste, -np.inf)\n    \n    return priority",
    "response_id": 14,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 38.03910001730775,
    "mi": 69.87170528764138,
    "token_count": 60.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response15.txt_stdout.txt",
    "code_path": "problem_iter1_code15.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to favor bins that have just enough capacity to \n    hold the item. It avoids overfilling bins and minimizes waste.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity of each bin after adding the item\n    remaining_cap = bins_remain_cap - item\n    \n    # Calculate the wasted capacity of each bin after adding the item\n    wasted_cap = np.maximum(remaining_cap, 0)\n    \n    # Calculate the priority score of each bin based on the wasted capacity\n    # A lower wasted capacity results in a higher priority score\n    priority = 1 / (wasted_cap + 1e-9)  # Add a small value to avoid division by zero\n    \n    # Set the priority to 0 for bins that are not large enough to hold the item\n    priority[remaining_cap < 0] = 0\n    \n    return priority",
    "response_id": 15,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 38.03910001730775,
    "mi": 69.87170528764138,
    "token_count": 60.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response16.txt_stdout.txt",
    "code_path": "problem_iter1_code16.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on the ratio of the remaining capacity and the item size.\n    If a bin has just enough capacity to hold the item, it gets the highest priority.\n    Bins with less capacity than the item get zero priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Bins with less capacity than the item get zero priority\n    priority_score = np.where(bins_remain_cap < item, 0, \n                              # Priority is higher for bins that can just hold the item\n                              1 / (1 + np.abs(bins_remain_cap - item)))\n    return priority_score",
    "response_id": 16,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 38.03910001730775,
    "mi": 69.87170528764138,
    "token_count": 60.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response17.txt_stdout.txt",
    "code_path": "problem_iter1_code17.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins with the least remaining capacity that can still accommodate the item.\n    The rationale behind this is to avoid creating new bins whenever possible and to distribute items evenly.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the number of bins that can accommodate the item\n    can_fit = bins_remain_cap >= item\n    \n    # If no bins can accommodate the item, return zero priority for all bins\n    if not np.any(can_fit):\n        return np.zeros_like(bins_remain_cap)\n    \n    # Assign a higher priority to bins with less remaining capacity\n    priority = np.where(can_fit, 1 / (bins_remain_cap + 1e-9), 0)\n    \n    return priority",
    "response_id": 17,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 38.03910001730775,
    "mi": 69.87170528764138,
    "token_count": 60.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response18.txt_stdout.txt",
    "code_path": "problem_iter1_code18.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on the ratio of the remaining capacity and the item size.\n    If a bin has just enough capacity to hold the item, it gets the highest priority.\n    Bins with less capacity than the item get zero priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Bins with less capacity than the item get zero priority\n    priority_score = np.where(bins_remain_cap < item, 0, \n                              # Priority is higher for bins that can just hold the item\n                              1 / (1 + (bins_remain_cap - item) / (item + 1e-10)))\n    return priority_score",
    "response_id": 18,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 38.03910001730775,
    "mi": 69.87170528764138,
    "token_count": 60.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response19.txt_stdout.txt",
    "code_path": "problem_iter1_code19.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to prioritize bins that have just enough capacity to pack the item,\n    minimizing waste of space. If no such bin exists, it prioritizes bins with the least remaining capacity,\n    encouraging efficient use of space.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the capacity difference between each bin and the item size\n    capacity_diff = bins_remain_cap - item\n    \n    # Assign high priority to bins that have just enough capacity for the item\n    just_enough_cap = np.where(capacity_diff >= 0, np.exp(-capacity_diff), 0)\n    \n    # Assign lower priority to bins with the least remaining capacity\n    remaining_capPriority = np.where(capacity_diff < 0, 1 / (1 + np.abs(capacity_diff)), 0)\n    \n    # Combine the two priorities using a weighted sum, prioritizing just enough capacity\n    priorities = 0.7 * just_enough_cap + 0.3 * remaining_capPriority\n    \n    return priorities",
    "response_id": 19,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 38.03910001730775,
    "mi": 69.87170528764138,
    "token_count": 60.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response20.txt_stdout.txt",
    "code_path": "problem_iter1_code20.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on the ratio of the remaining capacity and the item size.\n    If a bin has a higher ratio, it is more likely to be selected.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the ratio of remaining capacity to item size for each bin\n    ratio = bins_remain_cap / item\n    \n    # To avoid division by zero in case the item size is zero\n    ratio[np.isinf(ratio)] = 0\n    \n    # Priority is higher for bins with higher ratios\n    priority = ratio\n    return priority",
    "response_id": 20,
    "obj": 149.30195452732352,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 38.03910001730775,
    "mi": 69.87170528764138,
    "token_count": 60.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response21.txt_stdout.txt",
    "code_path": "problem_iter1_code21.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on the ratio of the remaining capacity and the item size.\n    If a bin has just enough capacity to hold the item, it gets the highest priority.\n    Bins with less capacity than the item get zero priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Bins with less capacity than the item get zero priority\n    priority_score = np.where(bins_remain_cap < item, 0, \n                              # Priority is higher for bins that can just hold the item\n                              1 / (1 + np.abs(bins_remain_cap - item)))\n    return priority_score",
    "response_id": 21,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 38.03910001730775,
    "mi": 69.87170528764138,
    "token_count": 60.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response22.txt_stdout.txt",
    "code_path": "problem_iter1_code22.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins with the least remaining capacity that can still accommodate the item.\n    This encourages more efficient packing by avoiding leaving large amounts of empty space in bins.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Filter bins that can accommodate the item\n    valid_bins = bins_remain_cap >= item\n    \n    # Assign a low priority to bins that cannot accommodate the item\n    priority = np.where(valid_bins, 1 / (bins_remain_cap + 1), -1)\n    \n    # Bins with the same priority will be filtered by the argmax function, \n    # so we add a small value based on the index to ensure a deterministic order\n    return priority + 1e-6 * np.arange(len(priority))",
    "response_id": 22,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 38.03910001730775,
    "mi": 69.87170528764138,
    "token_count": 60.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response23.txt_stdout.txt",
    "code_path": "problem_iter1_code23.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to prioritize bins that have just enough capacity to pack the item,\n    minimizing waste of space. If no such bin exists, it prioritizes bins with the least remaining capacity,\n    encouraging efficient use of space.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the minimum remaining capacity required to pack the item\n    min_required_cap = item\n    \n    # Identify bins that have just enough capacity to pack the item\n    exact_fit_bins = bins_remain_cap >= min_required_cap\n    \n    # Prioritize exact fit bins\n    priority = np.where(exact_fit_bins, 1.0, 0.0)\n    \n    # For non-exact fit bins, prioritize bins with the least remaining capacity\n    priority[~exact_fit_bins] = 1.0 / (1.0 + bins_remain_cap[~exact_fit_bins] - min_required_cap)\n    \n    return priority",
    "response_id": 23,
    "obj": 4.487435181491823,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 38.03910001730775,
    "mi": 69.87170528764138,
    "token_count": 60.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response24.txt_stdout.txt",
    "code_path": "problem_iter1_code24.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on the ratio of the remaining capacity and the item size.\n    If a bin has just enough capacity to hold the item, it gets the highest priority.\n    Bins with less capacity than the item get zero priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # ensure bins_remain_cap is a numpy array\n    bins_remain_cap = np.asarray(bins_remain_cap)\n    \n    # mask bins with insufficient capacity\n    mask = bins_remain_cap >= item\n    \n    # calculate priority as the reciprocal of the ratio between remaining capacity and item size\n    priority = np.where(mask, 1.0 / (bins_remain_cap / item), 0.0)\n    \n    return priority",
    "response_id": 24,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 38.03910001730775,
    "mi": 69.87170528764138,
    "token_count": 60.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response25.txt_stdout.txt",
    "code_path": "problem_iter1_code25.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to favor bins that have just enough capacity to pack the item.\n    The goal is to minimize the number of bins used by packing items as tightly as possible.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the difference between the remaining capacity of each bin and the item size\n    capacity_diff = bins_remain_cap - item\n    \n    # Calculate a weight based on how close the remaining capacity is to the item size\n    weights = np.maximum(1 - np.abs(capacity_diff) / (np.max(bins_remain_cap) + item), 0)\n    \n    # Calculate the priority scores using the weights\n    priority_scores = weights * np.clip(bins_remain_cap - item, 0, None)\n    \n    return priority_scores",
    "response_id": 25,
    "obj": 112.80414838452334,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 38.03910001730775,
    "mi": 69.87170528764138,
    "token_count": 60.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response26.txt_stdout.txt",
    "code_path": "problem_iter1_code26.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on the ratio of the remaining capacity and the item size.\n    If a bin has just enough capacity to hold the item, it gets the highest priority.\n    Bins with less capacity than the item get zero priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Bins with less capacity than the item get zero priority\n    priority_score = np.where(bins_remain_cap < item, 0, \n                              # Priority is higher for bins that can just hold the item\n                              1 / (1 + np.abs(bins_remain_cap - item)))\n    return priority_score",
    "response_id": 26,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 38.03910001730775,
    "mi": 69.87170528764138,
    "token_count": 60.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response27.txt_stdout.txt",
    "code_path": "problem_iter1_code27.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins with the least remaining capacity that can still accommodate the item.\n    It incentivizes filling up bins that are already almost full, while avoiding overflowing bins.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity that is sufficient to hold the item\n    sufficient_bins = bins_remain_cap >= item\n    \n    # Assign high priority to bins with just enough capacity\n    priority = np.where(sufficient_bins, 1 / (bins_remain_cap + item), 0)\n    \n    return priority",
    "response_id": 27,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 38.03910001730775,
    "mi": 69.87170528764138,
    "token_count": 60.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response28.txt_stdout.txt",
    "code_path": "problem_iter1_code28.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to encourage the packing of items into bins \n    where the item size is close to the remaining capacity, thereby minimizing waste \n    and reducing the number of bins needed.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity of each bin\n    remaining_cap = bins_remain_cap\n    \n    # If the item size is larger than the bin's remaining capacity, set the priority to -inf\n    # to discourage packing into this bin\n    priority = np.where(remaining_cap < item, -np.inf, remaining_cap)\n    \n    # Calculate the efficiency of packing the item into each bin\n    # The efficiency is defined as the remaining capacity after packing the item\n    efficiency = np.where(remaining_cap < item, 0, remaining_cap - item)\n    \n    # Calculate the priority score as the product of remaining capacity and efficiency\n    # This prioritizes bins where the item size is close to the remaining capacity\n    priority = np.where(priority != -np.inf, priority * efficiency, priority)\n    \n    # Define the decay rate for bins with lower priority\n    decay_rate = 0.5\n    \n    # Calculate the decayed priority for bins where the item size is larger than the remaining capacity\n    priority = np.where(priority != -np.inf, priority, np.power(decay_rate, np.arange(len(priority))))\n    \n    return priority",
    "response_id": 28,
    "obj": 149.30195452732352,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 38.03910001730775,
    "mi": 69.87170528764138,
    "token_count": 60.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response29.txt_stdout.txt",
    "code_path": "problem_iter1_code29.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on the ratio of the remaining capacity and the item size.\n    If a bin has just enough capacity to hold the item, it gets the highest priority.\n    Bins with less capacity than the item get zero priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Bins with less capacity than the item get zero priority\n    priority_score = np.where(bins_remain_cap < item, 0, \n                              # Priority is higher for bins that can just hold the item\n                              1 / (1 + np.abs(bins_remain_cap - item)))\n    return priority_score",
    "response_id": 29,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 38.03910001730775,
    "mi": 69.87170528764138,
    "token_count": 60.0,
    "exec_success": true
  }
]