[
  {
    "stdout_filepath": "problem_iter2_response0.txt_stdout.txt",
    "code_path": "problem_iter2_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to favor bins that have enough capacity to hold the item,\n    reward nearly full bins, and penalize bins that are too full or too empty.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Ensure that the item can fit in the bin\n    can_fit = bins_remain_cap >= item\n    \n    # Calculate the remaining capacity after adding the item to the bin\n    remaining_cap = np.where(can_fit, bins_remain_cap - item, np.inf)\n    \n    # Reward bins that are nearly full\n    nearly_full_reward = np.where(remaining_cap < item / 2, 1, 0)\n    \n    # Penalize bins that are too full or too empty\n    penalty = np.where(remaining_cap > item, -1, 0)\n    \n    # Calculate the priority score for each bin\n    priority = np.where(can_fit, 1 / (1 + remaining_cap / item) + nearly_full_reward + penalty, 0)\n    \n    return priority",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 12.0,
    "mi": 60.69924415751687,
    "token_count": 54.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response1.txt_stdout.txt",
    "code_path": "problem_iter2_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to prioritize bins that have just enough capacity to pack the item,\n    minimizing waste of space. If no such bin exists, it prioritizes bins with the least remaining capacity,\n    encouraging efficient use of space.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the difference between the remaining capacity of each bin and the item size\n    capacity_diff = np.abs(bins_remain_cap - item)\n    \n    # Identify bins that have just enough capacity to pack the item\n    exact_fit_bins = capacity_diff == 0\n    \n    # Prioritize exact fit bins\n    priority = np.where(exact_fit_bins, 1.0, 0.0)\n    \n    # For non-exact fit bins, prioritize bins with the least remaining capacity\n    priority[~exact_fit_bins] = 1.0 / (1.0 + capacity_diff[~exact_fit_bins])\n    \n    # Ensure exact fit bins have the highest priority\n    priority[exact_fit_bins] = np.max(priority) + 1.0\n    \n    return priority",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 12.0,
    "mi": 60.69924415751687,
    "token_count": 54.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response2.txt_stdout.txt",
    "code_path": "problem_iter2_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on how well they fit the item.\n    If a bin has exactly enough capacity to hold the item, it gets the highest priority.\n    Bins with less capacity than the item get zero priority.\n    Bins with more capacity than the item get lower priority, with the priority decreasing as the excess capacity increases.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Bins with less capacity than the item get zero priority\n    priority_score = np.where(bins_remain_cap < item, 0, \n                              # Priority is higher for bins that can just hold the item\n                              np.where(bins_remain_cap == item, 1, \n                                       # For bins with more capacity, the priority decreases as the excess capacity increases\n                                       1 / (1 + np.abs(bins_remain_cap - item))))\n    return priority_score",
    "response_id": 2,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 12.0,
    "mi": 60.69924415751687,
    "token_count": 54.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response3.txt_stdout.txt",
    "code_path": "problem_iter2_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on the ratio of the remaining capacity and the item size.\n    It also penalizes bins that are too large or too small.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Ensure that we don't divide by zero\n    zeros = (bins_remain_cap == 0)\n    # Calculate the denominator to avoid division by zero\n    denominator = np.where(zeros, 1e-8, bins_remain_cap)\n    \n    # Calculate priority score based on the ratio\n    ratio_score = np.where(zeros, 0, bins_remain_cap / np.maximum(item, denominator))\n    \n    # Calculate penalty score for extreme bin sizes\n    penalty_score = -np.abs(bins_remain_cap - item)\n    \n    # Calculate the final priority score by combining the ratio score and penalty score\n    priority = ratio_score + 0.1 * penalty_score\n    \n    # Ensure that bins that cannot hold the item have a priority of 0\n    priority = np.where(bins_remain_cap < item, 0, priority)\n    \n    return priority",
    "response_id": 3,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 12.0,
    "mi": 60.69924415751687,
    "token_count": 54.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response4.txt_stdout.txt",
    "code_path": "problem_iter2_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on minimizing waste \n    and only considers bins where the item can fit.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the waste that would be generated by adding the item to each bin\n    waste = bins_remain_cap - item\n    \n    # Create a mask for valid bins where the item can fit\n    mask = waste >= 0\n    \n    # Assign high priority to valid bins with lower waste\n    # and low priority (negative infinity) to invalid bins\n    priority = np.where(mask, -waste, -np.inf)\n    \n    return priority",
    "response_id": 4,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 12.0,
    "mi": 60.69924415751687,
    "token_count": 54.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response5.txt_stdout.txt",
    "code_path": "problem_iter2_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function favors bins that have enough capacity to hold the item and \n    have the least remaining capacity after the item is packed.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize the priority array with zeros\n    priority = np.zeros_like(bins_remain_cap)\n    \n    # Mask the bins that have enough capacity to hold the item\n    enough_capacity_mask = bins_remain_cap >= item\n    \n    # If there are no bins with enough capacity, fill the item into the bin with the most capacity\n    if not np.any(enough_capacity_mask):\n        priority[np.argmax(bins_remain_cap)] = 1\n    else:\n        # Calculate the remaining capacity of each bin after the item is packed\n        remaining_cap = bins_remain_cap[enough_capacity_mask] - item\n        \n        # Assign higher priority to bins with less remaining capacity\n        # Using the reciprocal of the remaining capacity to avoid division by zero\n        priority[enough_capacity_mask] = 1 / (remaining_cap + 1)\n    \n    return priority",
    "response_id": 5,
    "obj": 4.198244914240141,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 12.0,
    "mi": 60.69924415751687,
    "token_count": 54.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response6.txt_stdout.txt",
    "code_path": "problem_iter2_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on the ratio of the remaining capacity and the item size.\n    If a bin has a higher remaining capacity compared to the item size, it gets a higher priority score.\n    It also penalizes bins that are too large or too small compared to the item size.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Ensure that we don't divide by zero\n    zeros = (bins_remain_cap == 0)\n    # Calculate the denominator to avoid division by zero\n    denominator = np.where(zeros, 1e-8, bins_remain_cap)\n    \n    # Calculate priority score based on the ratio\n    ratio = bins_remain_cap / (item + 1e-8)  # Add 1e-8 to item to avoid division by zero\n    \n    # Penalize bins that are too large or too small\n    penalty = 1 - np.abs((bins_remain_cap - item) / (bins_remain_cap + item + 1e-8))\n    \n    # Calculate final priority score\n    priority = ratio * penalty\n    \n    # Ensure the item can fit in the bin\n    can_fit = bins_remain_cap >= item\n    priority = np.where(can_fit, priority, -np.inf)\n    \n    # Add a small random value to the priority to break ties randomly\n    priority += np.random.uniform(0, 1e-9, size=priority.shape)\n    \n    return priority",
    "response_id": 6,
    "obj": 149.30195452732352,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 12.0,
    "mi": 60.69924415751687,
    "token_count": 54.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response7.txt_stdout.txt",
    "code_path": "problem_iter2_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on the ratio of the remaining capacity to the item size.\n    Bins with less capacity than the item get zero priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Bins with less capacity than the item get zero priority\n    # Priority is higher for bins that can just hold the item, using a simple ratio\n    priority_score = np.where(bins_remain_cap < item, 0, \n                              1 / (1 + (bins_remain_cap - item) ** 2))\n    return priority_score",
    "response_id": 7,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 12.0,
    "mi": 60.69924415751687,
    "token_count": 54.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response8.txt_stdout.txt",
    "code_path": "problem_iter2_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on the ratio of the remaining capacity to the item size.\n    If a bin has just enough capacity to hold the item, it gets the highest priority.\n    Bins with less capacity than the item get zero priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the ratio of remaining capacity to item size, with zero priority for insufficient bins\n    ratios = np.where(bins_remain_cap >= item, bins_remain_cap / item, 0)\n    \n    # Higher ratios indicate lower priority, so use inverse ratio as priority score\n    priority_scores = np.where(ratios > 0, 1 / ratios, 0)\n    \n    return priority_scores",
    "response_id": 8,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 12.0,
    "mi": 60.69924415751687,
    "token_count": 54.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response9.txt_stdout.txt",
    "code_path": "problem_iter2_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on the ratio of the item size to the remaining capacity.\n    If a bin has just enough capacity to hold the item, it gets the highest priority.\n    Bins with less capacity than the item get zero priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # mask bins with insufficient capacity\n    mask = bins_remain_cap >= item\n    \n    # calculate priority as the ratio between item size and remaining capacity\n    priority = np.where(mask, item / bins_remain_cap, 0.0)\n    \n    return priority",
    "response_id": 9,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 12.0,
    "mi": 60.69924415751687,
    "token_count": 54.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response0.txt_stdout.txt",
    "code_path": "problem_iter3_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on the ratio of the remaining capacity and the item size.\n    It penalizes bins that are too full or too empty, and prioritizes bins that can just hold the item.\n    Bins with less capacity than the item get zero priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Bins with less capacity than the item get zero priority\n    priority_score = np.where(bins_remain_cap < item, 0, \n                              # Penalty for bins that are too full or too empty\n                              (bins_remain_cap / (bins_remain_cap + item)) * \n                              # Priority is higher for bins that can just hold the item\n                              (1 / (1 + np.abs(bins_remain_cap - item))))\n    return priority_score",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 77.70923408096293,
    "mi": 79.62558291590506,
    "token_count": 75.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response1.txt_stdout.txt",
    "code_path": "problem_iter3_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on the ratio of the remaining capacity and the item size.\n    It prioritizes near-full bins and penalizes extremes and size mismatches.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Bins with less capacity than the item get zero priority\n    priority_score = np.where(bins_remain_cap < item, 0, \n                              # Priority is higher for bins that can just hold the item and are near-full\n                              (1 - np.abs((bins_remain_cap - item) / bins_remain_cap)) / (1 + np.abs(bins_remain_cap - item)))\n    # Penalize bins that are too empty or too full\n    priority_score = np.where(bins_remain_cap / (bins_remain_cap + item) < 0.2, priority_score * 0.5, \n                              np.where(bins_remain_cap / (bins_remain_cap + item) > 0.8, priority_score * 0.8, priority_score))\n    return priority_score",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 77.70923408096293,
    "mi": 79.62558291590506,
    "token_count": 75.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response2.txt_stdout.txt",
    "code_path": "problem_iter3_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on the ratio of the remaining capacity and the item size.\n    It prioritizes near-full bins and penalizes extremes and size mismatches.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Bins with less capacity than the item get zero priority\n    priority_score = np.where(bins_remain_cap < item, 0, \n                              # Priority is higher for bins that can just hold the item and are near-full\n                              (1 / (1 + np.abs(bins_remain_cap - item))) * \n                              # Penalize bins that are too empty\n                              (bins_remain_cap / (bins_remain_cap + item)))\n    return priority_score",
    "response_id": 2,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 77.70923408096293,
    "mi": 79.62558291590506,
    "token_count": 75.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response3.txt_stdout.txt",
    "code_path": "problem_iter3_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on the ratio of the remaining capacity and the item size.\n    It prioritizes near-full bins and penalizes extremes and size mismatches.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Bins with less capacity than the item get zero priority\n    priority_score = np.where(bins_remain_cap < item, 0, \n                              # Priority is higher for bins that can just hold the item and are near-full\n                              (1 - np.abs((bins_remain_cap - item) / bins_remain_cap)) * (1 - (item / bins_remain_cap)))\n    # Penalize extremes and size mismatches\n    priority_score = np.where((bins_remain_cap - item) > (bins_remain_cap / 2), 0.5 * priority_score, priority_score)\n    return priority_score",
    "response_id": 3,
    "obj": 17.401276426007183,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 77.70923408096293,
    "mi": 79.62558291590506,
    "token_count": 75.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response4.txt_stdout.txt",
    "code_path": "problem_iter3_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on the ratio of the remaining capacity and the item size.\n    It penalizes bins that are too full or too empty, and prioritizes bins that can just hold the item.\n    Bins with less capacity than the item get zero priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Bins with less capacity than the item get zero priority\n    priority_score = np.where(bins_remain_cap < item, 0, \n                              # Penalty for bins that are too full or too empty\n                              (bins_remain_cap / (bins_remain_cap + item)) * \n                              # Priority is higher for bins that can just hold the item\n                              (1 / (1 + np.abs(bins_remain_cap - item))))\n    return priority_score",
    "response_id": 4,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 77.70923408096293,
    "mi": 79.62558291590506,
    "token_count": 75.0,
    "exec_success": true
  }
]