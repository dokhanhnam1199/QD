[
     {
          "algorithm": "This algorithm constructs a heuristic matrix by iteratively improving random tours using a 2-opt swap, and the heuristic value of an edge reflects how often it appears in these improved tours.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n  \"\"\"{This algorithm constructs a heuristic matrix by iteratively improving random tours using a 2-opt swap, and the heuristic value of an edge reflects how often it appears in these improved tours.}\"\"\"\n  n = distance_matrix.shape[0]\n  num_iterations = 100\n  heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n  for _ in range(num_iterations):\n    # Generate a random tour\n    tour = np.random.permutation(n)\n    tour = np.append(tour, tour[0])\n\n    # Improve the tour using 2-opt swaps\n    for i in range(1, n):\n      for j in range(i + 2, n + 1):\n        if distance_matrix[tour[i - 1], tour[i]] + distance_matrix[tour[j - 1], tour[j]] > distance_matrix[tour[i - 1], tour[j - 1]] + distance_matrix[tour[i], tour[j]]:\n          tour[i:j] = tour[i:j][::-1]\n\n    # Update the heuristic matrix\n    for i in range(n):\n      node1 = tour[i]\n      node2 = tour[i+1]\n      heuristics_matrix[node1, node2] += 1\n      heuristics_matrix[node2, node1] += 1\n\n  heuristics_matrix /= num_iterations\n  return heuristics_matrix",
          "objective": 5.85543,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm constructs multiple tours by probabilistically selecting the next node based on a combination of distance and pheromone-inspired values, then averages the inverse of tour lengths, weighted by a factor that prioritizes shorter edges, to create a heuristic matrix.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n  \"\"\"{This algorithm constructs multiple tours by probabilistically selecting the next node based on a combination of distance and pheromone-inspired values, then averages the inverse of tour lengths, weighted by a factor that prioritizes shorter edges, to create a heuristic matrix.}\"\"\"\n  num_nodes = distance_matrix.shape[0]\n  num_samples = 100\n  pheromone_levels = np.ones_like(distance_matrix)\n  alpha = 0.5\n  beta = 3\n  gamma = 2 # Weighting factor for shorter edges\n\n  heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n  for _ in range(num_samples):\n    start_node = np.random.randint(num_nodes)\n    current_node = start_node\n    unvisited = set(range(num_nodes))\n    unvisited.remove(start_node)\n    tour = [start_node]\n    tour_length = 0\n\n    while unvisited:\n      probabilities = np.zeros(num_nodes)\n      for neighbor in unvisited:\n        probabilities[neighbor] = (pheromone_levels[current_node, neighbor]**alpha) / (distance_matrix[current_node, neighbor]**beta)\n      \n      probabilities /= np.sum(probabilities)\n      \n      next_node = np.random.choice(num_nodes, p=probabilities)\n      if next_node not in unvisited: \n          candidates = list(unvisited)\n          next_node = candidates[0]\n          min_dist = distance_matrix[current_node, next_node]\n          for candidate in candidates[1:]:\n              if distance_matrix[current_node, candidate] < min_dist:\n                  next_node = candidate\n                  min_dist = distance_matrix[current_node, candidate]\n      \n      tour.append(next_node)\n      tour_length += distance_matrix[current_node, next_node]\n      unvisited.remove(next_node)\n      current_node = next_node\n\n    tour_length += distance_matrix[current_node, start_node]\n    inverse_tour_length = 1 / tour_length\n\n    for i in range(num_nodes):\n      for j in range(i + 1, num_nodes):\n        if (i in tour) and (j in tour):\n          if abs(tour.index(i) - tour.index(j)) == 1 or (i == tour[0] and j == tour[-1]) or (j == tour[0] and i == tour[-1]):\n            heuristics_matrix[i, j] += inverse_tour_length * (1 / distance_matrix[i, j]**gamma)\n            heuristics_matrix[j, i] += inverse_tour_length * (1 / distance_matrix[i, j]**gamma)\n\n  heuristics_matrix /= num_samples\n\n  return heuristics_matrix",
          "objective": 5.86254,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm generates multiple random tours using a nearest neighbor heuristic with probabilistic neighbor selection based on distance raised to a power, and then calculates a heuristic matrix based on the frequency with which each edge appears in these tours, normalized by the edge distance.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n  \"\"\"{This algorithm generates multiple random tours using a nearest neighbor heuristic with probabilistic neighbor selection based on distance raised to a power, and then calculates a heuristic matrix based on the frequency with which each edge appears in these tours, normalized by the edge distance.}\"\"\"\n  n = distance_matrix.shape[0]\n  num_tours = 100\n  edge_counts = np.zeros_like(distance_matrix)\n  alpha = 2.0\n  \n  for _ in range(num_tours):\n    start_node = np.random.randint(n)\n    unvisited_nodes = set(range(n))\n    current_node = start_node\n    tour = [current_node]\n    unvisited_nodes.remove(current_node)\n    \n    while unvisited_nodes:\n      probabilities = []\n      for neighbor in unvisited_nodes:\n          probabilities.append(1.0 / (distance_matrix[current_node, neighbor]**alpha))\n          \n      probabilities = np.array(probabilities)\n      probabilities /= probabilities.sum()\n          \n      nearest_neighbor = np.random.choice(list(unvisited_nodes), p=probabilities)      \n      \n      tour.append(nearest_neighbor)\n      unvisited_nodes.remove(nearest_neighbor)\n      current_node = nearest_neighbor\n      \n    tour.append(start_node) \n    \n    for i in range(n):\n      node1 = tour[i]\n      node2 = tour[i+1]\n      edge_counts[node1, node2] += 1\n      edge_counts[node2, node1] += 1\n\n  heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n  for i in range(n):\n    for j in range(n):\n        if distance_matrix[i,j] > 0:\n            heuristics_matrix[i, j] = edge_counts[i, j] / distance_matrix[i, j]\n        else:\n            heuristics_matrix[i,j] = 0\n\n  return heuristics_matrix",
          "objective": 5.92012,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm constructs a heuristic matrix by combining shortest edge and minimum spanning tree principles to prioritize edges likely to be in the optimal TSP tour.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm constructs a heuristic matrix by combining shortest edge and minimum spanning tree principles to prioritize edges likely to be in the optimal TSP tour.}\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    # Kruskal's algorithm to find Minimum Spanning Tree (MST)\n    edges = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            edges.append((i, j, distance_matrix[i, j]))\n    edges.sort(key=lambda x: x[2])  # Sort edges by weight\n\n    parent = list(range(n))\n\n    def find(i):\n        if parent[i] == i:\n            return i\n        parent[i] = find(parent[i])\n        return parent[i]\n\n    def union(i, j):\n        root_i = find(i)\n        root_j = find(j)\n        if root_i != root_j:\n            parent[root_i] = root_j\n            return True\n        return False\n\n    mst_weight = 0\n    mst_edges = []\n    for i, j, weight in edges:\n        if union(i, j):\n            mst_weight += weight\n            mst_edges.append((i, j))\n\n    # Heuristic based on MST edges and shortest edges\n    shortest_edge_threshold = np.percentile(distance_matrix[distance_matrix > 0], 20)  # Consider top 20% shortest edges\n\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                if (i, j) in mst_edges or (j, i) in mst_edges:\n                    heuristics_matrix[i, j] += 1.0 / distance_matrix[i, j]\n                    heuristics_matrix[j, i] += 1.0 / distance_matrix[j, i]\n                if distance_matrix[i, j] <= shortest_edge_threshold:\n                    heuristics_matrix[i, j] += 0.5 / distance_matrix[i, j]\n                    heuristics_matrix[j, i] += 0.5 / distance_matrix[j, i]\n\n    return heuristics_matrix",
          "objective": 6.02341,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm generates multiple random tours using a nearest neighbor heuristic, and then calculates a heuristic matrix based on the inverse of the average rank of each edge distance within its row.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n  \"\"\"{This algorithm generates multiple random tours using a nearest neighbor heuristic, and then calculates a heuristic matrix based on the inverse of the average rank of each edge distance within its row.}\"\"\"\n  n = distance_matrix.shape[0]\n  heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n  for i in range(n):\n    distances = distance_matrix[i, :]\n    ranks = np.argsort(distances)\n    \n    for j in range(n):\n      if i != j:\n        rank = np.where(ranks == j)[0][0] + 1  # Rank starts from 1\n        heuristics_matrix[i, j] = 1 / rank\n      else:\n        heuristics_matrix[i, j] = 0\n\n  return heuristics_matrix",
          "objective": 6.0395,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm generates multiple random tours using a nearest neighbor heuristic, and then calculates a heuristic matrix based on the frequency with which each edge appears in these tours, normalized by the edge distance.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n  \"\"\"{This algorithm generates multiple random tours using a nearest neighbor heuristic, and then calculates a heuristic matrix based on the frequency with which each edge appears in these tours, normalized by the edge distance.}\"\"\"\n  n = distance_matrix.shape[0]\n  num_tours = 100\n  edge_counts = np.zeros_like(distance_matrix)\n  \n  for _ in range(num_tours):\n    start_node = np.random.randint(n)\n    unvisited_nodes = set(range(n))\n    current_node = start_node\n    tour = [current_node]\n    unvisited_nodes.remove(current_node)\n    \n    while unvisited_nodes:\n      nearest_neighbor = -1\n      min_distance = np.inf\n      \n      for neighbor in unvisited_nodes:\n        distance = distance_matrix[current_node, neighbor]\n        if distance < min_distance:\n          min_distance = distance\n          nearest_neighbor = neighbor\n          \n      tour.append(nearest_neighbor)\n      unvisited_nodes.remove(nearest_neighbor)\n      current_node = nearest_neighbor\n      \n    tour.append(start_node) \n    \n    for i in range(n):\n      node1 = tour[i]\n      node2 = tour[i+1]\n      edge_counts[node1, node2] += 1\n      edge_counts[node2, node1] += 1\n\n  heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n  for i in range(n):\n    for j in range(n):\n        if distance_matrix[i,j] > 0:\n            heuristics_matrix[i, j] = edge_counts[i, j] / distance_matrix[i, j]\n        else:\n            heuristics_matrix[i,j] = 0\n\n  return heuristics_matrix",
          "objective": 6.09731,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm constructs multiple tours by probabilistically selecting the next node based on a combination of distance and pheromone-inspired values, then averages the inverse of tour lengths to create a heuristic matrix.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n  \"\"\"{This algorithm constructs multiple tours by probabilistically selecting the next node based on a combination of distance and pheromone-inspired values, then averages the inverse of tour lengths to create a heuristic matrix.}\"\"\"\n  num_nodes = distance_matrix.shape[0]\n  num_samples = 100\n  pheromone_levels = np.ones_like(distance_matrix)\n  alpha = 1\n  beta = 2\n\n  heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n  for _ in range(num_samples):\n    start_node = np.random.randint(num_nodes)\n    current_node = start_node\n    unvisited = set(range(num_nodes))\n    unvisited.remove(start_node)\n    tour = [start_node]\n    tour_length = 0\n\n    while unvisited:\n      probabilities = np.zeros(num_nodes)\n      for neighbor in unvisited:\n        probabilities[neighbor] = (pheromone_levels[current_node, neighbor]**alpha) / (distance_matrix[current_node, neighbor]**beta)\n      \n      probabilities /= np.sum(probabilities)\n      \n      next_node = np.random.choice(num_nodes, p=probabilities)\n      if next_node not in unvisited: \n          candidates = list(unvisited)\n          next_node = candidates[0]\n          min_dist = distance_matrix[current_node, next_node]\n          for candidate in candidates[1:]:\n              if distance_matrix[current_node, candidate] < min_dist:\n                  next_node = candidate\n                  min_dist = distance_matrix[current_node, candidate]\n      \n      tour.append(next_node)\n      tour_length += distance_matrix[current_node, next_node]\n      unvisited.remove(next_node)\n      current_node = next_node\n\n    tour_length += distance_matrix[current_node, start_node]\n    inverse_tour_length = 1 / tour_length\n\n    for i in range(num_nodes):\n      for j in range(i + 1, num_nodes):\n        if (i in tour) and (j in tour):\n          if abs(tour.index(i) - tour.index(j)) == 1 or (i == tour[0] and j == tour[-1]) or (j == tour[0] and i == tour[-1]):\n            heuristics_matrix[i, j] += inverse_tour_length\n            heuristics_matrix[j, i] += inverse_tour_length\n\n  heuristics_matrix /= num_samples\n\n  return heuristics_matrix",
          "objective": 6.12575,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm refines the heuristic matrix by emphasizing edges present in the Minimum Spanning Tree (MST) and incorporating a weighted score based on edge length relative to the average edge length.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm refines the heuristic matrix by emphasizing edges present in the Minimum Spanning Tree (MST) and incorporating a weighted score based on edge length relative to the average edge length.}\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    # Kruskal's algorithm to find Minimum Spanning Tree (MST)\n    edges = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            edges.append((i, j, distance_matrix[i, j]))\n    edges.sort(key=lambda x: x[2])  # Sort edges by weight\n\n    parent = list(range(n))\n\n    def find(i):\n        if parent[i] == i:\n            return i\n        parent[i] = find(parent[i])\n        return parent[i]\n\n    def union(i, j):\n        root_i = find(i)\n        root_j = find(j)\n        if root_i != root_j:\n            parent[root_i] = root_j\n            return True\n        return False\n\n    mst_weight = 0\n    mst_edges = []\n    for i, j, weight in edges:\n        if union(i, j):\n            mst_weight += weight\n            mst_edges.append((i, j))\n\n    # Heuristic based on MST edges and shortest edges\n    avg_distance = np.mean(distance_matrix[distance_matrix > 0])\n\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                if (i, j) in mst_edges or (j, i) in mst_edges:\n                    heuristics_matrix[i, j] += 2.0 / distance_matrix[i, j]  # Higher weight for MST edges\n                    heuristics_matrix[j, i] += 2.0 / distance_matrix[j, i]\n                heuristics_matrix[i, j] += (avg_distance / distance_matrix[i, j])\n                heuristics_matrix[j, i] += (avg_distance / distance_matrix[j, i])\n\n    return heuristics_matrix",
          "objective": 6.13724,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm uses a combination of nearest neighbor and shortest edge principles, iteratively sampling and refining paths based on edge frequency and length to build a heuristic matrix, where the score function considers both path length and the number of hops.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm uses a combination of nearest neighbor and shortest edge principles, iteratively sampling and refining paths based on edge frequency and length to build a heuristic matrix, where the score function considers both path length and the number of hops.}\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    num_samples = 100\n    for _ in range(num_samples):\n        # Start with a random node\n        start_node = np.random.randint(n)\n        current_node = start_node\n        unvisited = set(range(n))\n        unvisited.remove(start_node)\n        path = [start_node]\n        path_length = 0\n        num_hops = 0\n\n        while unvisited:\n            # Find the nearest neighbor from the current node among unvisited nodes\n            nearest_neighbor = None\n            min_distance = np.inf\n            for neighbor in unvisited:\n                distance = distance_matrix[current_node, neighbor]\n                if distance < min_distance:\n                    min_distance = distance\n                    nearest_neighbor = neighbor\n\n            path.append(nearest_neighbor)\n            path_length += min_distance\n            num_hops += 1\n            unvisited.remove(nearest_neighbor)\n            current_node = nearest_neighbor\n        \n        # Return to the starting node\n        path.append(start_node)\n        path_length += distance_matrix[current_node, start_node]\n        num_hops += 1\n\n        # Update heuristics matrix based on edges in the path\n        for i in range(n):\n            node1 = path[i]\n            node2 = path[i+1]\n            heuristics_matrix[node1, node2] += 1 / (path_length * num_hops)\n            heuristics_matrix[node2, node1] += 1 / (path_length * num_hops)\n\n    return heuristics_matrix",
          "objective": 6.17736,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm generates multiple random tours using a nearest neighbor heuristic with probabilistic neighbor selection based on distance, and then calculates a heuristic matrix based on the frequency with which each edge appears in these tours, normalized by the edge distance.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n  \"\"\"{This algorithm generates multiple random tours using a nearest neighbor heuristic with probabilistic neighbor selection based on distance, and then calculates a heuristic matrix based on the frequency with which each edge appears in these tours, normalized by the edge distance.}\"\"\"\n  n = distance_matrix.shape[0]\n  num_tours = 100\n  edge_counts = np.zeros_like(distance_matrix)\n  \n  for _ in range(num_tours):\n    start_node = np.random.randint(n)\n    unvisited_nodes = set(range(n))\n    current_node = start_node\n    tour = [current_node]\n    unvisited_nodes.remove(current_node)\n    \n    while unvisited_nodes:\n      probabilities = []\n      for neighbor in unvisited_nodes:\n          probabilities.append(1.0 / distance_matrix[current_node, neighbor])\n          \n      probabilities = np.array(probabilities)\n      probabilities /= probabilities.sum()\n          \n      nearest_neighbor = np.random.choice(list(unvisited_nodes), p=probabilities)      \n      \n      tour.append(nearest_neighbor)\n      unvisited_nodes.remove(nearest_neighbor)\n      current_node = nearest_neighbor\n      \n    tour.append(start_node) \n    \n    for i in range(n):\n      node1 = tour[i]\n      node2 = tour[i+1]\n      edge_counts[node1, node2] += 1\n      edge_counts[node2, node1] += 1\n\n  heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n  for i in range(n):\n    for j in range(n):\n        if distance_matrix[i,j] > 0:\n            heuristics_matrix[i, j] = edge_counts[i, j] / distance_matrix[i, j]\n        else:\n            heuristics_matrix[i,j] = 0\n\n  return heuristics_matrix",
          "objective": 6.19026,
          "other_inf": null
     }
]