[
     {
          "algorithm": "This algorithm uses a nearest neighbor approach to generate initial tours, improves them with 2-opt, and aggregates edge frequencies weighted by an exponential function of tour rank based on their lengths.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm uses a nearest neighbor approach to generate initial tours, improves them with 2-opt, and aggregates edge frequencies weighted by an exponential function of tour rank based on their lengths.}\"\"\"\n    n = distance_matrix.shape[0]\n    num_tours = 50\n    edge_counts = np.zeros_like(distance_matrix)\n\n    tours = []\n    tour_lengths = []\n\n    for _ in range(num_tours):\n        # Generate initial tour using nearest neighbor\n        start_node = np.random.randint(n)\n        tour = [start_node]\n        unvisited = set(range(n))\n        unvisited.remove(start_node)\n\n        while unvisited:\n            last_node = tour[-1]\n            nearest_node = min(unvisited, key=lambda x: distance_matrix[last_node, x])\n            tour.append(nearest_node)\n            unvisited.remove(nearest_node)\n        tour.append(tour[0])\n\n        # 2-opt local search\n        improved = True\n        while improved:\n            improved = False\n            for i in range(1, n - 1):\n                for k in range(i + 1, n):\n                    current_cost = distance_matrix[tour[i-1], tour[i]] + distance_matrix[tour[k], tour[k+1]]\n                    new_cost = distance_matrix[tour[i-1], tour[k]] + distance_matrix[tour[i], tour[k+1]]\n\n                    if new_cost < current_cost:\n                        tour[i:k+1] = tour[i:k+1][::-1]\n                        improved = True\n\n        tour_length = sum(distance_matrix[tour[i], tour[i+1]] for i in range(n))\n        tours.append(tour)\n        tour_lengths.append(tour_length)\n\n    # Rank tours based on length\n    ranked_indices = np.argsort(tour_lengths)\n\n    for rank, index in enumerate(ranked_indices):\n        tour = tours[index]\n        # Weight edge counts by exponential function of rank\n        weight = np.exp(-rank / 10.0)  # Exponential weighting\n\n        for i in range(n):\n            node1 = tour[i]\n            node2 = tour[i+1]\n            edge_counts[node1, node2] += weight\n            edge_counts[node2, node1] += weight\n\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    for i in range(n):\n        for j in range(n):\n            if distance_matrix[i, j] > 0:\n                heuristics_matrix[i, j] = edge_counts[i, j] / distance_matrix[i, j]\n            else:\n                heuristics_matrix[i, j] = 0\n\n    return heuristics_matrix",
          "objective": 5.71529,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm uses a nearest neighbor approach to generate initial tours, improves them with 2-opt, and aggregates edge frequencies weighted inversely by tour rank based on their lengths.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm uses a nearest neighbor approach to generate initial tours, improves them with 2-opt, and aggregates edge frequencies weighted inversely by tour rank based on their lengths.}\"\"\"\n    n = distance_matrix.shape[0]\n    num_tours = 50\n    edge_counts = np.zeros_like(distance_matrix)\n\n    tours = []\n    tour_lengths = []\n\n    for _ in range(num_tours):\n        # Generate initial tour using nearest neighbor\n        start_node = np.random.randint(n)\n        tour = [start_node]\n        unvisited = set(range(n))\n        unvisited.remove(start_node)\n\n        while unvisited:\n            last_node = tour[-1]\n            nearest_node = min(unvisited, key=lambda x: distance_matrix[last_node, x])\n            tour.append(nearest_node)\n            unvisited.remove(nearest_node)\n        tour.append(tour[0])\n\n        # 2-opt local search\n        improved = True\n        while improved:\n            improved = False\n            for i in range(1, n - 1):\n                for k in range(i + 1, n):\n                    current_cost = distance_matrix[tour[i-1], tour[i]] + distance_matrix[tour[k], tour[k+1]]\n                    new_cost = distance_matrix[tour[i-1], tour[k]] + distance_matrix[tour[i], tour[k+1]]\n\n                    if new_cost < current_cost:\n                        tour[i:k+1] = tour[i:k+1][::-1]\n                        improved = True\n\n        tour_length = sum(distance_matrix[tour[i], tour[i+1]] for i in range(n))\n        tours.append(tour)\n        tour_lengths.append(tour_length)\n\n    # Rank tours based on length\n    ranked_indices = np.argsort(tour_lengths)\n\n    for rank, index in enumerate(ranked_indices):\n        tour = tours[index]\n        # Weight edge counts by inverse of rank (shorter tours have higher weight)\n        weight = 1.0 / (rank + 1)  # Adding 1 to avoid division by zero\n\n        for i in range(n):\n            node1 = tour[i]\n            node2 = tour[i+1]\n            edge_counts[node1, node2] += weight\n            edge_counts[node2, node1] += weight\n\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    for i in range(n):\n        for j in range(n):\n            if distance_matrix[i, j] > 0:\n                heuristics_matrix[i, j] = edge_counts[i, j] / distance_matrix[i, j]\n            else:\n                heuristics_matrix[i, j] = 0\n\n    return heuristics_matrix",
          "objective": 5.71889,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm constructs a heuristic matrix by generating tours with a nearest neighbor approach, applies 2-opt local search to improve them, and then uses the frequency of edges in the improved tours, weighted by the exponential of the negative tour length to construct the heuristic matrix.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm constructs a heuristic matrix by generating tours with a nearest neighbor approach, applies 2-opt local search to improve them, and then uses the frequency of edges in the improved tours, weighted by the exponential of the negative tour length to construct the heuristic matrix.}\"\"\"\n    n = distance_matrix.shape[0]\n    num_tours = 50\n    edge_weights = np.zeros_like(distance_matrix)\n\n    for _ in range(num_tours):\n        # Generate a tour using nearest neighbor heuristic\n        start_node = np.random.randint(n)\n        unvisited = list(range(n))\n        tour = [start_node]\n        unvisited.remove(start_node)\n        \n        while unvisited:\n            last_node = tour[-1]\n            nearest_node = min(unvisited, key=lambda node: distance_matrix[last_node, node])\n            tour.append(nearest_node)\n            unvisited.remove(nearest_node)\n            \n        tour.append(start_node)\n        \n        # 2-opt local search\n        improved = True\n        while improved:\n            improved = False\n            for i in range(1, n - 1):\n                for k in range(i + 1, n):\n                    current_cost = distance_matrix[tour[i-1], tour[i]] + distance_matrix[tour[k], tour[k+1]]\n                    new_cost = distance_matrix[tour[i-1], tour[k]] + distance_matrix[tour[i], tour[k+1]]\n\n                    if new_cost < current_cost:\n                        tour[i:k+1] = tour[i:k+1][::-1]\n                        improved = True\n        \n        tour_length = sum(distance_matrix[tour[i], tour[i+1]] for i in range(n))\n        tour_weight = np.exp(-tour_length)\n\n        for i in range(n):\n            node1 = tour[i]\n            node2 = tour[i+1]\n            edge_weights[node1, node2] += tour_weight\n            edge_weights[node2, node1] += tour_weight\n    \n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    for i in range(n):\n        for j in range(n):\n            if distance_matrix[i, j] > 0:\n                heuristics_matrix[i, j] = edge_weights[i, j]\n            else:\n                heuristics_matrix[i, j] = 0\n    \n    return heuristics_matrix",
          "objective": 5.71944,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm generates initial tours using a greedy approach with random starting nodes, refines them with 2-opt, and aggregates edge scores based on tour quality weighted by an exponential function of the tour's rank.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm generates initial tours using a greedy approach with random starting nodes, refines them with 2-opt, and aggregates edge scores based on tour quality weighted by an exponential function of the tour's rank.}\"\"\"\n    n = distance_matrix.shape[0]\n    num_tours = 50\n    edge_counts = np.zeros_like(distance_matrix)\n\n    tours = []\n    tour_lengths = []\n\n    for _ in range(num_tours):\n        # Generate initial tour using nearest neighbor (Greedy)\n        start_node = np.random.randint(n)\n        tour = [start_node]\n        unvisited = set(range(n))\n        unvisited.remove(start_node)\n\n        while unvisited:\n            last_node = tour[-1]\n            nearest_node = min(unvisited, key=lambda x: distance_matrix[last_node, x])\n            tour.append(nearest_node)\n            unvisited.remove(nearest_node)\n        tour.append(tour[0])\n\n        # 2-opt local search\n        improved = True\n        while improved:\n            improved = False\n            for i in range(1, n - 1):\n                for k in range(i + 1, n):\n                    current_cost = distance_matrix[tour[i-1], tour[i]] + distance_matrix[tour[k], tour[k+1]]\n                    new_cost = distance_matrix[tour[i-1], tour[k]] + distance_matrix[tour[i], tour[k+1]]\n\n                    if new_cost < current_cost:\n                        tour[i:k+1] = tour[i:k+1][::-1]\n                        improved = True\n\n        tour_length = sum(distance_matrix[tour[i], tour[i+1]] for i in range(n))\n        tours.append(tour)\n        tour_lengths.append(tour_length)\n\n    # Rank tours based on length\n    ranked_indices = np.argsort(tour_lengths)\n\n    for rank, index in enumerate(ranked_indices):\n        tour = tours[index]\n        # Weight edge counts by exponential function of rank\n        weight = np.exp(-rank / 10.0)  # Exponential decay, adjust 10.0 for sensitivity\n\n        for i in range(n):\n            node1 = tour[i]\n            node2 = tour[i+1]\n            edge_counts[node1, node2] += weight\n            edge_counts[node2, node1] += weight\n\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    for i in range(n):\n        for j in range(n):\n            if distance_matrix[i, j] > 0:\n                heuristics_matrix[i, j] = edge_counts[i, j] / distance_matrix[i, j]\n            else:\n                heuristics_matrix[i, j] = 0\n\n    return heuristics_matrix",
          "objective": 5.72268,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm constructs a heuristic matrix by generating tours with a nearest neighbor approach, applies 2-opt local search to improve them, and then uses the frequency of edges in the improved tours, weighted by the square root of the inverse of tour length, to construct the heuristic matrix.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm constructs a heuristic matrix by generating tours with a nearest neighbor approach, applies 2-opt local search to improve them, and then uses the frequency of edges in the improved tours, weighted by the square root of the inverse of tour length, to construct the heuristic matrix.}\"\"\"\n    n = distance_matrix.shape[0]\n    num_tours = 50\n    edge_weights = np.zeros_like(distance_matrix)\n\n    for _ in range(num_tours):\n        # Generate a tour using nearest neighbor heuristic\n        start_node = np.random.randint(n)\n        unvisited = list(range(n))\n        tour = [start_node]\n        unvisited.remove(start_node)\n        \n        while unvisited:\n            last_node = tour[-1]\n            nearest_node = min(unvisited, key=lambda node: distance_matrix[last_node, node])\n            tour.append(nearest_node)\n            unvisited.remove(nearest_node)\n            \n        tour.append(start_node)\n        \n        # 2-opt local search\n        improved = True\n        while improved:\n            improved = False\n            for i in range(1, n - 1):\n                for k in range(i + 1, n):\n                    current_cost = distance_matrix[tour[i-1], tour[i]] + distance_matrix[tour[k], tour[k+1]]\n                    new_cost = distance_matrix[tour[i-1], tour[k]] + distance_matrix[tour[i], tour[k+1]]\n\n                    if new_cost < current_cost:\n                        tour[i:k+1] = tour[i:k+1][::-1]\n                        improved = True\n        \n        tour_length = sum(distance_matrix[tour[i], tour[i+1]] for i in range(n))\n        tour_weight = (1.0 / tour_length)**0.5  # Weight proportional to sqrt of the inverse of tour length\n\n        for i in range(n):\n            node1 = tour[i]\n            node2 = tour[i+1]\n            edge_weights[node1, node2] += tour_weight\n            edge_weights[node2, node1] += tour_weight\n    \n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    for i in range(n):\n        for j in range(n):\n            if distance_matrix[i, j] > 0:\n                heuristics_matrix[i, j] = edge_weights[i, j]\n            else:\n                heuristics_matrix[i, j] = 0\n    \n    return heuristics_matrix",
          "objective": 5.7298,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm constructs a heuristic matrix by generating tours with a nearest neighbor approach, applies 2-opt local search to improve them, and then uses the frequency of edges in the improved tours, weighted by the inverse of tour length, to construct the heuristic matrix.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm constructs a heuristic matrix by generating tours with a nearest neighbor approach, applies 2-opt local search to improve them, and then uses the frequency of edges in the improved tours, weighted by the inverse of tour length, to construct the heuristic matrix.}\"\"\"\n    n = distance_matrix.shape[0]\n    num_tours = 50\n    edge_weights = np.zeros_like(distance_matrix)\n\n    for _ in range(num_tours):\n        # Generate a tour using nearest neighbor heuristic\n        start_node = np.random.randint(n)\n        unvisited = list(range(n))\n        tour = [start_node]\n        unvisited.remove(start_node)\n        \n        while unvisited:\n            last_node = tour[-1]\n            nearest_node = min(unvisited, key=lambda node: distance_matrix[last_node, node])\n            tour.append(nearest_node)\n            unvisited.remove(nearest_node)\n            \n        tour.append(start_node)\n        \n        # 2-opt local search\n        improved = True\n        while improved:\n            improved = False\n            for i in range(1, n - 1):\n                for k in range(i + 1, n):\n                    current_cost = distance_matrix[tour[i-1], tour[i]] + distance_matrix[tour[k], tour[k+1]]\n                    new_cost = distance_matrix[tour[i-1], tour[k]] + distance_matrix[tour[i], tour[k+1]]\n\n                    if new_cost < current_cost:\n                        tour[i:k+1] = tour[i:k+1][::-1]\n                        improved = True\n        \n        tour_length = sum(distance_matrix[tour[i], tour[i+1]] for i in range(n))\n        tour_weight = 1.0 / tour_length  # Weight inversely proportional to tour length\n\n        for i in range(n):\n            node1 = tour[i]\n            node2 = tour[i+1]\n            edge_weights[node1, node2] += tour_weight\n            edge_weights[node2, node1] += tour_weight\n    \n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    for i in range(n):\n        for j in range(n):\n            if distance_matrix[i, j] > 0:\n                heuristics_matrix[i, j] = edge_weights[i, j]\n            else:\n                heuristics_matrix[i, j] = 0\n    \n    return heuristics_matrix",
          "objective": 5.73198,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm constructs a heuristic matrix by iteratively improving tours using a 2-opt local search, and aggregates edge frequencies across multiple independently generated and optimized tours, weighted by tour length.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm constructs a heuristic matrix by iteratively improving tours using a 2-opt local search, and aggregates edge frequencies across multiple independently generated and optimized tours, weighted by tour length.}\"\"\"\n    n = distance_matrix.shape[0]\n    num_tours = 50\n    edge_counts = np.zeros_like(distance_matrix)\n    tour_lengths = []\n\n    for _ in range(num_tours):\n        # Generate a random initial tour\n        tour = list(np.random.permutation(n))\n        tour.append(tour[0])  # Return to starting city\n        \n        # 2-opt local search\n        improved = True\n        while improved:\n            improved = False\n            for i in range(1, n - 1):\n                for k in range(i + 1, n):\n                    \n                    current_cost = distance_matrix[tour[i-1], tour[i]] + distance_matrix[tour[k], tour[k+1]]\n                    new_cost = distance_matrix[tour[i-1], tour[k]] + distance_matrix[tour[i], tour[k+1]]\n\n                    if new_cost < current_cost:\n                        tour[i:k+1] = tour[i:k+1][::-1]\n                        improved = True\n                        \n        tour_length = sum(distance_matrix[tour[i], tour[i+1]] for i in range(n))\n        tour_lengths.append(tour_length)\n\n        for i in range(n):\n            node1 = tour[i]\n            node2 = tour[i+1]\n            edge_counts[node1, node2] += 1\n            edge_counts[node2, node1] += 1\n\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    for i in range(n):\n        for j in range(n):\n            if distance_matrix[i, j] > 0:\n                heuristics_matrix[i, j] = edge_counts[i, j] / distance_matrix[i, j]\n            else:\n                heuristics_matrix[i, j] = 0\n\n    return heuristics_matrix",
          "objective": 5.75767,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm constructs multiple tours by probabilistically selecting the next node based on distance, applying local search to improve tours, and averages the inverse of tour lengths to create a heuristic matrix.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n  \"\"\"{This algorithm constructs multiple tours by probabilistically selecting the next node based on distance, applying local search to improve tours, and averages the inverse of tour lengths to create a heuristic matrix.}\"\"\"\n  num_nodes = distance_matrix.shape[0]\n  num_samples = 100\n\n  heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n  def two_opt(tour):\n    best_tour = tour\n    improved = True\n    while improved:\n      improved = False\n      for i in range(1, len(tour) - 1):\n        for k in range(i + 1, len(tour)):\n          new_tour = tour[:i] + tour[i:k+1][::-1] + tour[k+1:]\n          current_cost = 0\n          for index in range(len(tour)-1):\n            current_cost += distance_matrix[tour[index], tour[index+1]]\n          current_cost += distance_matrix[tour[-1], tour[0]]\n\n          new_cost = 0\n          for index in range(len(new_tour)-1):\n            new_cost += distance_matrix[new_tour[index], new_tour[index+1]]\n          new_cost += distance_matrix[new_tour[-1], new_tour[0]]\n          \n          if new_cost < current_cost:\n            best_tour = new_tour\n            tour = new_tour\n            improved = True\n    return best_tour\n\n  for _ in range(num_samples):\n    start_node = np.random.randint(num_nodes)\n    current_node = start_node\n    unvisited = set(range(num_nodes))\n    unvisited.remove(start_node)\n    tour = [start_node]\n    tour_length = 0\n\n    while unvisited:\n      probabilities = np.zeros(num_nodes)\n      for neighbor in unvisited:\n        probabilities[neighbor] = 1 / (distance_matrix[current_node, neighbor] + 1e-9)\n      \n      probabilities /= np.sum(probabilities)\n      \n      next_node = np.random.choice(num_nodes, p=probabilities)\n      if next_node not in unvisited: \n          candidates = list(unvisited)\n          next_node = candidates[0]\n          min_dist = distance_matrix[current_node, next_node]\n          for candidate in candidates[1:]:\n              if distance_matrix[current_node, candidate] < min_dist:\n                  next_node = candidate\n                  min_dist = distance_matrix[current_node, candidate]\n      \n      tour.append(next_node)\n      tour_length += distance_matrix[current_node, next_node]\n      unvisited.remove(next_node)\n      current_node = next_node\n\n    tour.append(start_node)\n    tour_length += distance_matrix[current_node, start_node]\n    \n    tour = two_opt(tour)\n    tour_length = 0\n    for i in range(len(tour) - 1):\n        tour_length += distance_matrix[tour[i], tour[i+1]]\n    \n    inverse_tour_length = 1 / tour_length\n\n    for i in range(num_nodes):\n      for j in range(i + 1, num_nodes):\n        if (i in tour) and (j in tour):\n          if abs(tour.index(i) - tour.index(j)) == 1 or ( (i == tour[0] and j == tour[-1]) or (j == tour[0] and i == tour[-1])):\n            heuristics_matrix[i, j] += inverse_tour_length\n            heuristics_matrix[j, i] += inverse_tour_length\n\n  heuristics_matrix /= num_samples\n\n  return heuristics_matrix",
          "objective": 5.80761,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm constructs a heuristic matrix by iteratively improving random tours using a 2-opt swap, and the heuristic value of an edge reflects how often it appears in these improved tours.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n  \"\"\"{This algorithm constructs a heuristic matrix by iteratively improving random tours using a 2-opt swap, and the heuristic value of an edge reflects how often it appears in these improved tours.}\"\"\"\n  n = distance_matrix.shape[0]\n  num_iterations = 100\n  heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n  for _ in range(num_iterations):\n    # Generate a random tour\n    tour = np.random.permutation(n)\n    tour = np.append(tour, tour[0])\n\n    # Improve the tour using 2-opt swaps\n    for i in range(1, n):\n      for j in range(i + 2, n + 1):\n        if distance_matrix[tour[i - 1], tour[i]] + distance_matrix[tour[j - 1], tour[j]] > distance_matrix[tour[i - 1], tour[j - 1]] + distance_matrix[tour[i], tour[j]]:\n          tour[i:j] = tour[i:j][::-1]\n\n    # Update the heuristic matrix\n    for i in range(n):\n      node1 = tour[i]\n      node2 = tour[i+1]\n      heuristics_matrix[node1, node2] += 1\n      heuristics_matrix[node2, node1] += 1\n\n  heuristics_matrix /= num_iterations\n  return heuristics_matrix",
          "objective": 5.85543,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm constructs multiple tours by probabilistically selecting the next node based on a combination of distance and pheromone-inspired values, then averages the inverse of tour lengths, weighted by a factor that prioritizes shorter edges, to create a heuristic matrix.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n  \"\"\"{This algorithm constructs multiple tours by probabilistically selecting the next node based on a combination of distance and pheromone-inspired values, then averages the inverse of tour lengths, weighted by a factor that prioritizes shorter edges, to create a heuristic matrix.}\"\"\"\n  num_nodes = distance_matrix.shape[0]\n  num_samples = 100\n  pheromone_levels = np.ones_like(distance_matrix)\n  alpha = 0.5\n  beta = 3\n  gamma = 2 # Weighting factor for shorter edges\n\n  heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n  for _ in range(num_samples):\n    start_node = np.random.randint(num_nodes)\n    current_node = start_node\n    unvisited = set(range(num_nodes))\n    unvisited.remove(start_node)\n    tour = [start_node]\n    tour_length = 0\n\n    while unvisited:\n      probabilities = np.zeros(num_nodes)\n      for neighbor in unvisited:\n        probabilities[neighbor] = (pheromone_levels[current_node, neighbor]**alpha) / (distance_matrix[current_node, neighbor]**beta)\n      \n      probabilities /= np.sum(probabilities)\n      \n      next_node = np.random.choice(num_nodes, p=probabilities)\n      if next_node not in unvisited: \n          candidates = list(unvisited)\n          next_node = candidates[0]\n          min_dist = distance_matrix[current_node, next_node]\n          for candidate in candidates[1:]:\n              if distance_matrix[current_node, candidate] < min_dist:\n                  next_node = candidate\n                  min_dist = distance_matrix[current_node, candidate]\n      \n      tour.append(next_node)\n      tour_length += distance_matrix[current_node, next_node]\n      unvisited.remove(next_node)\n      current_node = next_node\n\n    tour_length += distance_matrix[current_node, start_node]\n    inverse_tour_length = 1 / tour_length\n\n    for i in range(num_nodes):\n      for j in range(i + 1, num_nodes):\n        if (i in tour) and (j in tour):\n          if abs(tour.index(i) - tour.index(j)) == 1 or (i == tour[0] and j == tour[-1]) or (j == tour[0] and i == tour[-1]):\n            heuristics_matrix[i, j] += inverse_tour_length * (1 / distance_matrix[i, j]**gamma)\n            heuristics_matrix[j, i] += inverse_tour_length * (1 / distance_matrix[i, j]**gamma)\n\n  heuristics_matrix /= num_samples\n\n  return heuristics_matrix",
          "objective": 5.86254,
          "other_inf": null
     }
]