{
     "algorithm": "This algorithm uses a nearest neighbor approach to generate initial tours, improves them with 2-opt, and aggregates edge frequencies weighted by an exponential function of tour rank based on their lengths.",
     "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm uses a nearest neighbor approach to generate initial tours, improves them with 2-opt, and aggregates edge frequencies weighted by an exponential function of tour rank based on their lengths.}\"\"\"\n    n = distance_matrix.shape[0]\n    num_tours = 50\n    edge_counts = np.zeros_like(distance_matrix)\n\n    tours = []\n    tour_lengths = []\n\n    for _ in range(num_tours):\n        # Generate initial tour using nearest neighbor\n        start_node = np.random.randint(n)\n        tour = [start_node]\n        unvisited = set(range(n))\n        unvisited.remove(start_node)\n\n        while unvisited:\n            last_node = tour[-1]\n            nearest_node = min(unvisited, key=lambda x: distance_matrix[last_node, x])\n            tour.append(nearest_node)\n            unvisited.remove(nearest_node)\n        tour.append(tour[0])\n\n        # 2-opt local search\n        improved = True\n        while improved:\n            improved = False\n            for i in range(1, n - 1):\n                for k in range(i + 1, n):\n                    current_cost = distance_matrix[tour[i-1], tour[i]] + distance_matrix[tour[k], tour[k+1]]\n                    new_cost = distance_matrix[tour[i-1], tour[k]] + distance_matrix[tour[i], tour[k+1]]\n\n                    if new_cost < current_cost:\n                        tour[i:k+1] = tour[i:k+1][::-1]\n                        improved = True\n\n        tour_length = sum(distance_matrix[tour[i], tour[i+1]] for i in range(n))\n        tours.append(tour)\n        tour_lengths.append(tour_length)\n\n    # Rank tours based on length\n    ranked_indices = np.argsort(tour_lengths)\n\n    for rank, index in enumerate(ranked_indices):\n        tour = tours[index]\n        # Weight edge counts by exponential function of rank\n        weight = np.exp(-rank / 10.0)  # Exponential weighting\n\n        for i in range(n):\n            node1 = tour[i]\n            node2 = tour[i+1]\n            edge_counts[node1, node2] += weight\n            edge_counts[node2, node1] += weight\n\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    for i in range(n):\n        for j in range(n):\n            if distance_matrix[i, j] > 0:\n                heuristics_matrix[i, j] = edge_counts[i, j] / distance_matrix[i, j]\n            else:\n                heuristics_matrix[i, j] = 0\n\n    return heuristics_matrix",
     "objective": 5.71529,
     "other_inf": null
}