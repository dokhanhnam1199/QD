[
     {
          "algorithm": "This algorithm generates multiple random tours using a nearest neighbor heuristic, and then calculates a heuristic matrix based on the frequency with which each edge appears in these tours, normalized by the edge distance.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n  \"\"\"{This algorithm generates multiple random tours using a nearest neighbor heuristic, and then calculates a heuristic matrix based on the frequency with which each edge appears in these tours, normalized by the edge distance.}\"\"\"\n  n = distance_matrix.shape[0]\n  num_tours = 100\n  edge_counts = np.zeros_like(distance_matrix)\n  \n  for _ in range(num_tours):\n    start_node = np.random.randint(n)\n    unvisited_nodes = set(range(n))\n    current_node = start_node\n    tour = [current_node]\n    unvisited_nodes.remove(current_node)\n    \n    while unvisited_nodes:\n      nearest_neighbor = -1\n      min_distance = np.inf\n      \n      for neighbor in unvisited_nodes:\n        distance = distance_matrix[current_node, neighbor]\n        if distance < min_distance:\n          min_distance = distance\n          nearest_neighbor = neighbor\n          \n      tour.append(nearest_neighbor)\n      unvisited_nodes.remove(nearest_neighbor)\n      current_node = nearest_neighbor\n      \n    tour.append(start_node) \n    \n    for i in range(n):\n      node1 = tour[i]\n      node2 = tour[i+1]\n      edge_counts[node1, node2] += 1\n      edge_counts[node2, node1] += 1\n\n  heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n  for i in range(n):\n    for j in range(n):\n        if distance_matrix[i,j] > 0:\n            heuristics_matrix[i, j] = edge_counts[i, j] / distance_matrix[i, j]\n        else:\n            heuristics_matrix[i,j] = 0\n\n  return heuristics_matrix",
          "objective": 6.09731,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm generates multiple random tours using a nearest neighbor heuristic, then averages the frequency of each edge's inclusion across these tours to produce a heuristic matrix.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"\n    {This algorithm generates multiple random tours using a nearest neighbor heuristic, then averages the frequency of each edge's inclusion across these tours to produce a heuristic matrix.}\n    \"\"\"\n    num_nodes = distance_matrix.shape[0]\n    num_samples = 100  # Number of sample tours to generate\n\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    for _ in range(num_samples):\n        start_node = np.random.randint(num_nodes)\n        current_node = start_node\n        unvisited = set(range(num_nodes))\n        unvisited.remove(start_node)\n        tour = [start_node]\n\n        while unvisited:\n            nearest_neighbor = min(unvisited, key=lambda x: distance_matrix[current_node, x])\n            tour.append(nearest_neighbor)\n            unvisited.remove(nearest_neighbor)\n            heuristics_matrix[current_node, nearest_neighbor] += 1\n            heuristics_matrix[nearest_neighbor, current_node] += 1  # Symmetry\n            current_node = nearest_neighbor\n\n        # Complete the tour back to the start\n        heuristics_matrix[current_node, start_node] += 1\n        heuristics_matrix[start_node, current_node] += 1\n\n    heuristics_matrix /= num_samples # Normalize by the number of samples. \n\n    return heuristics_matrix",
          "objective": 6.22264,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm samples multiple tours using a nearest neighbor heuristic, and the heuristics matrix reflects the frequency with which each edge appears in the sampled tours.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm samples multiple tours using a nearest neighbor heuristic, and the heuristics matrix reflects the frequency with which each edge appears in the sampled tours.}\"\"\"\n    n = distance_matrix.shape[0]\n    num_samples = 100\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    for _ in range(num_samples):\n        start_node = np.random.randint(n)\n        current_node = start_node\n        unvisited_nodes = set(range(n))\n        unvisited_nodes.remove(current_node)\n        tour = [current_node]\n\n        while unvisited_nodes:\n            nearest_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node, node])\n            tour.append(nearest_node)\n            unvisited_nodes.remove(nearest_node)\n            current_node = nearest_node\n\n        tour.append(start_node)\n\n        for i in range(n):\n            node1 = tour[i]\n            node2 = tour[i+1]\n            heuristics_matrix[node1, node2] += 1\n            heuristics_matrix[node2, node1] += 1\n\n    heuristics_matrix /= num_samples\n    return heuristics_matrix",
          "objective": 6.23413,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm uses a combination of nearest neighbor and shortest edge principles, iteratively sampling and refining paths based on edge frequency and length to build a heuristic matrix.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm uses a combination of nearest neighbor and shortest edge principles, iteratively sampling and refining paths based on edge frequency and length to build a heuristic matrix.}\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    num_samples = 100\n    for _ in range(num_samples):\n        # Start with a random node\n        start_node = np.random.randint(n)\n        current_node = start_node\n        unvisited = set(range(n))\n        unvisited.remove(start_node)\n        path = [start_node]\n        path_length = 0\n\n        while unvisited:\n            # Find the nearest neighbor from the current node among unvisited nodes\n            nearest_neighbor = None\n            min_distance = np.inf\n            for neighbor in unvisited:\n                distance = distance_matrix[current_node, neighbor]\n                if distance < min_distance:\n                    min_distance = distance\n                    nearest_neighbor = neighbor\n\n            path.append(nearest_neighbor)\n            path_length += min_distance\n            unvisited.remove(nearest_neighbor)\n            current_node = nearest_neighbor\n        \n        # Return to the starting node\n        path.append(start_node)\n        path_length += distance_matrix[current_node, start_node]\n\n        # Update heuristics matrix based on edges in the path\n        for i in range(n):\n            node1 = path[i]\n            node2 = path[i+1]\n            heuristics_matrix[node1, node2] += 1 / path_length\n            heuristics_matrix[node2, node1] += 1 / path_length\n\n    return heuristics_matrix",
          "objective": 6.24475,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm samples TSP solutions using a nearest-neighbor-inspired heuristic and then calculates a matrix where each entry indicates the frequency with which the corresponding edge appears in the sampled good solutions.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm samples TSP solutions using a nearest-neighbor-inspired heuristic and then calculates a matrix where each entry indicates the frequency with which the corresponding edge appears in the sampled good solutions.}\"\"\"\n    n = distance_matrix.shape[0]\n    num_samples = 1000\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    \n    for _ in range(num_samples):\n        start_node = np.random.randint(n)\n        current_node = start_node\n        unvisited_nodes = set(range(n))\n        unvisited_nodes.remove(current_node)\n        path = [current_node]\n        \n        while unvisited_nodes:\n            nearest_neighbor = None\n            min_distance = np.inf\n            \n            for neighbor in unvisited_nodes:\n                distance = distance_matrix[current_node, neighbor]\n                if distance < min_distance:\n                    min_distance = distance\n                    nearest_neighbor = neighbor\n                    \n            path.append(nearest_neighbor)\n            unvisited_nodes.remove(nearest_neighbor)\n            current_node = nearest_neighbor\n            \n        path.append(start_node)\n        \n        path_length = 0\n        for i in range(n):\n            path_length += distance_matrix[path[i], path[i+1]]\n            \n        if path_length < np.mean(distance_matrix) * n * 2: # Accept only \"good\" solutions\n            for i in range(n):\n                node1 = path[i]\n                node2 = path[i+1]\n                heuristics_matrix[node1, node2] += 1\n                heuristics_matrix[node2, node1] += 1\n                \n    heuristics_matrix /= num_samples\n    return heuristics_matrix",
          "objective": 6.27517,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm estimates edge promise by sampling random paths, recording edge occurrences, and normalizing by path length, then combines this with inverse distance and a shortest-path heuristic.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    num_samples = 1000\n    edge_counts = np.zeros_like(distance_matrix, dtype=float)\n    path_lengths = np.zeros(num_samples)\n\n    for i in range(num_samples):\n        path = np.random.permutation(n)\n        path_length = 0\n        for j in range(n):\n            node1 = path[j]\n            node2 = path[(j + 1) % n]\n            edge_counts[node1, node2] += 1\n            edge_counts[node2, node1] += 1\n            path_length += distance_matrix[node1, node2]\n        path_lengths[i] = path_length\n\n    # Normalize edge counts by path length\n    normalized_edge_counts = edge_counts / num_samples\n\n    # Combine with inverse distance\n    inverse_distance = 1.0 / (distance_matrix + np.eye(n))  # Avoid division by zero\n    combined_heuristic = normalized_edge_counts + inverse_distance\n\n    # Shortest path heuristic (Prim's algorithm approximation)\n    mst_heuristic = np.zeros_like(distance_matrix, dtype=float)\n    for start_node in range(n):\n        visited = {start_node",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"\n    {This algorithm estimates edge promise by sampling random paths, recording edge occurrences, and normalizing by path length, then combines this with inverse distance and a shortest-path heuristic.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    num_samples = 1000\n    edge_counts = np.zeros_like(distance_matrix, dtype=float)\n    path_lengths = np.zeros(num_samples)\n\n    for i in range(num_samples):\n        path = np.random.permutation(n)\n        path_length = 0\n        for j in range(n):\n            node1 = path[j]\n            node2 = path[(j + 1) % n]\n            edge_counts[node1, node2] += 1\n            edge_counts[node2, node1] += 1\n            path_length += distance_matrix[node1, node2]\n        path_lengths[i] = path_length\n\n    # Normalize edge counts by path length\n    normalized_edge_counts = edge_counts / num_samples\n\n    # Combine with inverse distance\n    inverse_distance = 1.0 / (distance_matrix + np.eye(n))  # Avoid division by zero\n    combined_heuristic = normalized_edge_counts + inverse_distance\n\n    # Shortest path heuristic (Prim's algorithm approximation)\n    mst_heuristic = np.zeros_like(distance_matrix, dtype=float)\n    for start_node in range(n):\n        visited = {start_node}\n        edges = []\n        for neighbor in range(n):\n            if neighbor != start_node:\n                edges.append((distance_matrix[start_node, neighbor], start_node, neighbor))\n        edges.sort()\n\n        while len(visited) < n:\n            min_edge = None\n            for edge in edges:\n                if edge[1] in visited and edge[2] not in visited:\n                    min_edge = edge\n                    break\n            if min_edge is None:\n                break\n            \n            weight, u, v = min_edge\n            mst_heuristic[u,v] = 1\n            mst_heuristic[v,u] = 1\n            visited.add(v)\n\n            for neighbor in range(n):\n                if neighbor not in visited and neighbor != v:\n                    edges.append((distance_matrix[v, neighbor], v, neighbor))\n            edges.sort()\n            edges = [edge for edge in edges if edge[1] not in visited or edge[2] not in visited ]\n\n    # Combine all heuristics\n    heuristics_matrix = combined_heuristic + mst_heuristic\n    return heuristics_matrix",
          "objective": 6.28712,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm uses a combination of nearest neighbor and simulated annealing principles to generate a promising edge matrix for the TSP problem.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm uses a combination of nearest neighbor and simulated annealing principles to generate a promising edge matrix for the TSP problem.}\"\"\"\n\n    num_nodes = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    for i in range(num_nodes):\n        for j in range(num_nodes):\n            if i == j:\n                heuristics_matrix[i, j] = 0\n            else:\n                heuristics_matrix[i, j] = 1 / distance_matrix[i, j] if distance_matrix[i, j] > 0 else 0\n\n    return heuristics_matrix",
          "objective": 6.48896,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm iteratively samples solutions by adding edges based on a combination of shortest distances, edge uniqueness, and penalty for closing cycles prematurely, and uses the frequency of edges appearing in good solutions as heuristic indicators.}\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    num_samples = 1000\n    \n    for _ in range(num_samples):\n        current_path = [np.random.randint(n)]\n        unvisited = set(range(n))\n        unvisited.remove(current_path[0])\n        \n        edges_used = set()\n        \n        while unvisited:\n            current_node = current_path[-1]\n            \n            # Calculate scores for each possible edge to unvisited nodes\n            edge_scores = {",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm iteratively samples solutions by adding edges based on a combination of shortest distances, edge uniqueness, and penalty for closing cycles prematurely, and uses the frequency of edges appearing in good solutions as heuristic indicators.}\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    num_samples = 1000\n    \n    for _ in range(num_samples):\n        current_path = [np.random.randint(n)]\n        unvisited = set(range(n))\n        unvisited.remove(current_path[0])\n        \n        edges_used = set()\n        \n        while unvisited:\n            current_node = current_path[-1]\n            \n            # Calculate scores for each possible edge to unvisited nodes\n            edge_scores = {}\n            for neighbor in unvisited:\n                distance = distance_matrix[current_node, neighbor]\n                \n                # Uniqueness factor - prefer less used edges\n                uniqueness = 1 / (1 + heuristics_matrix[current_node, neighbor])\n                \n                # Cycle penalty - avoid closing cycles too early\n                cycle_penalty = 1.0\n                \n                if len(current_path) > 2 and neighbor == current_path[0]:\n                    cycle_penalty = 0.1  # High penalty to close cycle prematurely, unless last node\n                \n                edge_scores[neighbor] = distance * cycle_penalty / uniqueness # Try to penalize long travel\n\n            # Select the next node based on edge scores (lower is better)\n            best_neighbor = min(edge_scores, key=edge_scores.get)\n                \n            current_path.append(best_neighbor)\n            unvisited.remove(best_neighbor)\n\n        # Complete the cycle\n        current_path.append(current_path[0])\n\n        # Calculate total distance of the sampled path\n        total_distance = 0\n        for i in range(n):\n            total_distance += distance_matrix[current_path[i], current_path[i+1]]\n            \n        # Update heuristics based on path quality\n        # paths that have shorter distances are considered better.\n        # Only good enough samples will be counted, to keep the samples relevant\n\n        if total_distance < np.mean(distance_matrix) * n * 1.5: #consider sample if total distance is smaller than 1.5 times of mean times node number\n           for i in range(n):\n              node1, node2 = current_path[i], current_path[i+1]\n              heuristics_matrix[node1, node2] += 1\n              heuristics_matrix[node2, node1] += 1\n\n    return heuristics_matrix",
          "objective": 6.84965,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm samples multiple near-greedy solutions based on a heuristic combination of distance and a pheromone-inspired edge desirability, and then returns a matrix indicating the frequency with which each edge appears in the sampled solutions.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm samples multiple near-greedy solutions based on a heuristic combination of distance and a pheromone-inspired edge desirability, and then returns a matrix indicating the frequency with which each edge appears in the sampled solutions.}\"\"\"\n    num_nodes = distance_matrix.shape[0]\n    num_samples = 100  # Number of sample solutions to generate\n    pheromone_matrix = np.ones_like(distance_matrix)  # Initial pheromone values\n    heuristics_matrix = np.zeros_like(distance_matrix)\n\n    for _ in range(num_samples):\n        current_node = np.random.randint(num_nodes)  # Start from a random node\n        unvisited_nodes = set(range(num_nodes))\n        unvisited_nodes.remove(current_node)\n        tour = [current_node]\n        tour_length = 0\n\n        while unvisited_nodes:\n            # Heuristic: Combine distance and pheromone\n            probabilities = np.zeros(num_nodes)\n            for neighbor in unvisited_nodes:\n                probabilities[neighbor] = (pheromone_matrix[current_node, neighbor] /\n                                           distance_matrix[current_node, neighbor])\n            \n            probabilities /= np.sum(probabilities)  # Normalize probabilities\n\n            # Select the next node probabilistically\n            next_node = np.random.choice(num_nodes, p=probabilities)\n            \n            if next_node not in unvisited_nodes:\n                # Handle rare case where node isn't in unvisited\n                eligible_nodes = list(unvisited_nodes)\n                if eligible_nodes:\n                   next_node = eligible_nodes[0]  # choose first one in the list if it happens\n                else:\n                   break #No unvisited nodes, break the loop\n                \n            tour.append(next_node)\n            tour_length += distance_matrix[current_node, next_node]\n            unvisited_nodes.remove(next_node)\n            current_node = next_node\n        \n        # Complete the tour by returning to the starting node\n        tour.append(tour[0])\n        tour_length += distance_matrix[current_node, tour[0]]\n        \n        # Update heuristics_matrix based on the tour\n        for i in range(num_nodes):\n            heuristics_matrix[tour[i], tour[i+1]] += 1\n            heuristics_matrix[tour[i+1], tour[i]] += 1 #ensure symmetry\n            \n        # Update pheromone matrix (optional - can be refined)\n        for i in range(num_nodes):\n            pheromone_matrix[tour[i], tour[i+1]] += 1.0 / tour_length\n            pheromone_matrix[tour[i+1], tour[i]] += 1.0 / tour_length\n\n\n    return heuristics_matrix",
          "objective": 7.60261,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm samples multiple near-greedy solutions using a probabilistic nearest neighbor selection biased by distance and combines the edge frequencies across solutions to create a heuristic matrix.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm samples multiple near-greedy solutions using a probabilistic nearest neighbor selection biased by distance and combines the edge frequencies across solutions to create a heuristic matrix.}\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    num_samples = 100\n\n    for _ in range(num_samples):\n        start_node = np.random.randint(n)\n        current_node = start_node\n        unvisited_nodes = set(range(n))\n        unvisited_nodes.remove(current_node)\n        path = [current_node]\n\n        while unvisited_nodes:\n            distances = distance_matrix[current_node, :]\n            probabilities = np.zeros(n)\n            for neighbor in unvisited_nodes:\n                probabilities[neighbor] = 1 / distances[neighbor] if distances[neighbor] > 0 else 0\n            \n            if np.sum(probabilities) == 0:\n                next_node = min(unvisited_nodes)\n            else:\n                probabilities = probabilities / np.sum(probabilities)\n                next_node = np.random.choice(n, p=probabilities)\n\n\n            heuristics_matrix[current_node, next_node] += 1\n            heuristics_matrix[next_node, current_node] += 1\n\n            path.append(next_node)\n            current_node = next_node\n            unvisited_nodes.remove(current_node)\n\n        heuristics_matrix[current_node, start_node] += 1\n        heuristics_matrix[start_node, current_node] += 1\n        \n    return heuristics_matrix",
          "objective": 7.78186,
          "other_inf": null
     }
]