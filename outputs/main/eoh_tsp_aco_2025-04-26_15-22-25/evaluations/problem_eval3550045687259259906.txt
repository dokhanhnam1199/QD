import numpy as np

def heuristics_v2(distance_matrix):
  """{This algorithm constructs a heuristic matrix by iteratively improving tours generated using a nearest neighbor approach with a probability of random edge swaps to escape local optima, updating the matrix based on tour length improvements.}"""
  n = distance_matrix.shape[0]
  num_iterations = 100
  heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

  for _ in range(num_iterations):
    # Initial tour (Nearest Neighbor)
    start_node = np.random.randint(n)
    current_node = start_node
    unvisited = set(range(n))
    unvisited.remove(start_node)
    tour = [start_node]
    tour_length = 0

    while unvisited:
      nearest_node = -1
      min_dist = np.inf
      for neighbor in unvisited:
        dist = distance_matrix[current_node, neighbor]
        if dist < min_dist:
          min_dist = dist
          nearest_node = neighbor
      next_node = nearest_node

      tour.append(next_node)
      tour_length += distance_matrix[current_node, next_node]
      unvisited.remove(next_node)
      current_node = next_node

    tour_length += distance_matrix[current_node, start_node]
    tour.append(start_node)
    original_tour = tour[:]
    original_tour_length = tour_length

    # Improvement by random edge swaps
    for _ in range(n): # Try n swaps per tour
      i = np.random.randint(1, n) # Avoid swapping start/end
      j = np.random.randint(1, n)
      if i == j:
          continue

      # Reverse the segment between i and j
      sub_tour = tour[i:j+1]
      sub_tour.reverse()
      new_tour = tour[:i] + sub_tour + tour[j+1:]
      new_tour_length = 0
      for k in range(n):
        new_tour_length += distance_matrix[new_tour[k], new_tour[k+1]]

      if new_tour_length < tour_length:
        tour = new_tour
        tour_length = new_tour_length

    # Update heuristic matrix if improvement
    if tour_length < original_tour_length:
        for i in range(n):
          node1 = tour[i]
          node2 = tour[i+1]
          heuristics_matrix[node1, node2] += (1/tour_length - 1/original_tour_length)
          heuristics_matrix[node2, node1] += (1/tour_length - 1/original_tour_length)

  heuristics_matrix /= num_iterations
  return heuristics_matrix
