import numpy as np

def heuristics_v2(distance_matrix):
  """{This algorithm constructs a heuristic matrix by averaging edge probabilities derived from shortest path lengths between node pairs, favoring edges on shorter paths.}"""
  n = distance_matrix.shape[0]
  heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
  num_paths = 10

  for i in range(n):
    for j in range(i + 1, n):
      path_lengths = []
      for _ in range(num_paths):
        path = [i]
        current_node = i
        unvisited = set(range(n))
        unvisited.remove(i)
        
        while current_node != j and unvisited:
          distances = distance_matrix[current_node, list(unvisited)]
          next_node = list(unvisited)[np.argmin(distances)]
          path.append(next_node)
          current_node = next_node
          if current_node in unvisited:
            unvisited.remove(current_node)
          else:
            break # No path exists
        
        if current_node == j:
          path_length = 0
          for k in range(len(path) - 1):
            path_length += distance_matrix[path[k], path[k+1]]
          path_lengths.append(path_length)

      if path_lengths:
        avg_path_length = np.mean(path_lengths)
        heuristics_matrix[i, j] = 1 / avg_path_length
        heuristics_matrix[j, i] = 1 / avg_path_length
      else:
        heuristics_matrix[i, j] = 0
        heuristics_matrix[j, i] = 0

  return heuristics_matrix
