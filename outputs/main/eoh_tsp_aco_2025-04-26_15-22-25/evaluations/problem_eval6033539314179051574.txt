import numpy as np

def heuristics_v2(distance_matrix):
    """
    {This algorithm generates multiple random tours using a nearest neighbor heuristic with a temperature-based acceptance probability, then averages the edge frequencies to produce a heuristic matrix.}
    """
    num_nodes = distance_matrix.shape[0]
    num_samples = 100  # Number of sample tours to generate
    temperature = 10.0 # Initial temperature
    cooling_rate = 0.95 # Cooling rate

    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

    for _ in range(num_samples):
        start_node = np.random.randint(num_nodes)
        current_node = start_node
        unvisited = set(range(num_nodes))
        unvisited.remove(start_node)
        tour = [start_node]

        while unvisited:
            # Nearest neighbor selection with temperature-based acceptance
            neighbors = list(unvisited)
            probabilities = np.zeros(len(neighbors))
            for i, neighbor in enumerate(neighbors):
                probabilities[i] = np.exp(-distance_matrix[current_node, neighbor] / temperature)
            
            probabilities /= np.sum(probabilities)

            nearest_neighbor = np.random.choice(neighbors, p=probabilities)
            tour.append(nearest_neighbor)
            unvisited.remove(nearest_neighbor)
            heuristics_matrix[current_node, nearest_neighbor] += 1
            heuristics_matrix[nearest_neighbor, current_node] += 1  # Symmetry
            current_node = nearest_neighbor

        # Complete the tour back to the start
        heuristics_matrix[current_node, start_node] += 1
        heuristics_matrix[start_node, current_node] += 1

        temperature *= cooling_rate # Cool down the temperature

    heuristics_matrix /= num_samples # Normalize by the number of samples. 

    return heuristics_matrix
