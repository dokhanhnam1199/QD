import numpy as np

def heuristics_v2(distance_matrix):
  """{This algorithm computes a heuristic matrix by combining the inverse distance with a weighted average of shortest path distances between nodes, promoting edges present in short alternative routes.}"""
  n = distance_matrix.shape[0]
  heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

  # Inverse distance component
  inverse_distance = np.zeros_like(distance_matrix, dtype=float)
  for i in range(n):
    for j in range(n):
      if i != j and distance_matrix[i, j] > 0:
        inverse_distance[i, j] = 1 / distance_matrix[i, j]

  # Shortest path component (using Floyd-Warshall)
  shortest_paths = np.copy(distance_matrix)
  shortest_paths[shortest_paths == 0] = np.inf  # Avoid division by zero later. Should not affect algorithm functionally.
  for k in range(n):
    for i in range(n):
      for j in range(n):
        shortest_paths[i, j] = min(shortest_paths[i, j], shortest_paths[i, k] + shortest_paths[k, j])
  
  # Combine inverse distance and shortest path information
  alpha = 0.5  # Weighting factor
  for i in range(n):
    for j in range(n):
      if i != j and distance_matrix[i, j] > 0:
        heuristics_matrix[i, j] = alpha * inverse_distance[i, j] + (1 - alpha) / shortest_paths[i, j] if shortest_paths[i, j] !=0 and shortest_paths[i, j] != np.inf else 0
  return heuristics_matrix
