import numpy as np

def heuristics_v2(distance_matrix):
  """{This algorithm employs a nearest neighbor approach to construct multiple tours from random starting nodes, then computes a heuristic matrix by penalizing edge usage based on tour length and edge rank within the tour.}"""
  num_nodes = distance_matrix.shape[0]
  num_samples = 100

  heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

  for _ in range(num_samples):
    start_node = np.random.randint(num_nodes)
    current_node = start_node
    unvisited = set(range(num_nodes))
    unvisited.remove(start_node)
    tour = [start_node]
    tour_length = 0

    while unvisited:
      nearest_neighbor = None
      min_distance = float('inf')
      for neighbor in unvisited:
        dist = distance_matrix[current_node, neighbor]
        if dist < min_distance:
          min_distance = dist
          nearest_neighbor = neighbor
          
      tour.append(nearest_neighbor)
      tour_length += distance_matrix[current_node, nearest_neighbor]
      unvisited.remove(nearest_neighbor)
      current_node = nearest_neighbor

    tour.append(start_node)
    tour_length += distance_matrix[current_node, start_node]

    
    for i in range(num_nodes):
      for j in range(i + 1, num_nodes):
        if (i in tour) and (j in tour):
            index_i = tour.index(i)
            index_j = tour.index(j)
            
            if abs(index_i - index_j) == 1 or (i == tour[0] and j == tour[-1]) or (j == tour[0] and i == tour[-1]):
                
                edge_rank = min(abs(index_i - index_j), len(tour) - abs(index_i - index_j)) 
                
                heuristics_matrix[i, j] += (1/tour_length) / (edge_rank + 1)
                heuristics_matrix[j, i] += (1/tour_length) / (edge_rank + 1)

  heuristics_matrix /= num_samples

  return heuristics_matrix
