import numpy as np

def heuristics_v2(distance_matrix):
  """{This algorithm constructs a heuristic matrix by iteratively improving random tours using a 3-opt swap, and the heuristic value of an edge reflects how often it appears in these improved tours.}"""
  n = distance_matrix.shape[0]
  num_iterations = 100
  heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

  for _ in range(num_iterations):
    # Generate a random tour
    tour = np.random.permutation(n)
    tour = np.append(tour, tour[0])

    # Improve the tour using 3-opt swaps
    improved = True
    while improved:
      improved = False
      for i in range(1, n - 1):
        for j in range(i + 2, n):
          for k in range(j + 2, n + 1):
            # Define segments
            A = tour[i - 1]
            B = tour[i]
            C = tour[j - 1]
            D = tour[j]
            E = tour[k - 1]
            F = tour[k]

            # Original length
            original_length = distance_matrix[A, B] + distance_matrix[C, D] + distance_matrix[E, F]

            # Possible 3-opt swaps
            swap_options = [
                (distance_matrix[A, C] + distance_matrix[B, D] + distance_matrix[E, F], tour[i:j][::-1]),  # 2-opt (i, j)
                (distance_matrix[A, B] + distance_matrix[C, E] + distance_matrix[D, F], tour[j:k][::-1]),  # 2-opt (j, k)
                (distance_matrix[A, D] + distance_matrix[E, B] + distance_matrix[C, F], tour[i:j][::-1] + tour[j:k][::-1]),  # 2-opt (i, k)
                (distance_matrix[A, C] + distance_matrix[E, D] + distance_matrix[B, F], tour[j:k][::-1] + tour[i:j][::-1]),  # 3-opt
                (distance_matrix[A, D] + distance_matrix[E, C] + distance_matrix[B, F], tour[j:k][::-1][1:] + tour[i:j][::-1] + [tour[j-1]]) #3-opt with rotation
            ]

            best_length = original_length
            best_swap = None

            for length, swap in swap_options:
              if length < best_length:
                best_length = length
                best_swap = swap

            if best_swap is not None:
              tour[i:k] = np.concatenate((best_swap,))
              improved = True
              break
        if improved:
          break
      if improved:
        break


    # Update the heuristic matrix
    for i in range(n):
      node1 = tour[i]
      node2 = tour[i+1]
      heuristics_matrix[node1, node2] += 1
      heuristics_matrix[node2, node1] += 1

  heuristics_matrix /= num_iterations
  return heuristics_matrix
