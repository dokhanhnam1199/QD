import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm constructs a heuristic matrix by emphasizing the shortest edges and edges that connect nodes with high average proximity to other nodes.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

    # Calculate average distance to all other nodes for each node
    avg_distances = np.mean(distance_matrix, axis=1)

    # Normalize distances for scaling
    normalized_distance_matrix = distance_matrix / np.max(distance_matrix)

    # Heuristic based on shortest edges and node proximity
    shortest_edge_threshold = np.percentile(distance_matrix[distance_matrix > 0], 25) # top 25%
    
    for i in range(n):
        for j in range(n):
            if i != j:
                # Prioritize shorter edges
                if distance_matrix[i, j] <= shortest_edge_threshold:
                    heuristics_matrix[i, j] += (1 - normalized_distance_matrix[i, j]) 
                    heuristics_matrix[j, i] += (1 - normalized_distance_matrix[j, i])
                
                # Give higher scores to edges connecting nodes with overall shorter distances
                heuristics_matrix[i, j] += 0.25 * (1 / (avg_distances[i] + avg_distances[j]))
                heuristics_matrix[j, i] += 0.25 * (1 / (avg_distances[j] + avg_distances[i]))

    return heuristics_matrix
