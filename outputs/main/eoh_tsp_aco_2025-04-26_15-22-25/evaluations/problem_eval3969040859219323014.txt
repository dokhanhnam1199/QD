import numpy as np

def heuristics_v2(distance_matrix):
  """{This algorithm generates multiple tours by randomly swapping nodes in an initial tour, and then calculates a heuristic matrix based on the improvement in tour length achieved by including each edge, normalized by the edge distance.}"""
  n = distance_matrix.shape[0]
  num_tours = 100
  edge_improvements = np.zeros_like(distance_matrix)

  def calculate_tour_length(tour):
    length = 0
    for i in range(n):
      length += distance_matrix[tour[i], tour[(i + 1) % n]]
    return length

  for _ in range(num_tours):
    # Generate a random initial tour
    tour = np.random.permutation(n)
    initial_tour_length = calculate_tour_length(tour)

    # Perform random swaps and evaluate improvement
    for i in range(n):
      for j in range(i + 1, n):
        # Create a new tour with swapped nodes
        new_tour = tour.copy()
        new_tour[i], new_tour[j] = new_tour[j], new_tour[i]
        new_tour_length = calculate_tour_length(new_tour)

        # Calculate improvement and update edge improvements
        improvement = initial_tour_length - new_tour_length
        edge_improvements[tour[i], tour[j]] += improvement
        edge_improvements[tour[j], tour[i]] += improvement

  heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
  for i in range(n):
    for j in range(n):
      if distance_matrix[i, j] > 0:
        heuristics_matrix[i, j] = edge_improvements[i, j] / distance_matrix[i, j]
      else:
        heuristics_matrix[i, j] = 0

  return heuristics_matrix
