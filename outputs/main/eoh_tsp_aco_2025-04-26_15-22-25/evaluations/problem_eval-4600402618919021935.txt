import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm samples paths, combines edge frequencies with inverse distance, and incorporates a nearest neighbor heuristic for edge prioritization.}"""
    n = distance_matrix.shape[0]
    num_samples = 500
    edge_counts = np.zeros_like(distance_matrix, dtype=float)

    for _ in range(num_samples):
        path = np.random.permutation(n)
        for i in range(n):
            u = path[i]
            v = path[(i + 1) % n]
            edge_counts[u, v] += 1
            edge_counts[v, u] += 1

    normalized_edge_counts = edge_counts / num_samples
    inverse_distance = 1.0 / (distance_matrix + np.eye(n))
    combined_heuristic = normalized_edge_counts + inverse_distance

    nn_heuristic = np.zeros_like(distance_matrix, dtype=float)
    for i in range(n):
        neighbors = np.argsort(distance_matrix[i, :])[1:4]
        for neighbor in neighbors:
            nn_heuristic[i, neighbor] = 1
            nn_heuristic[neighbor, i] = 1
    
    heuristics_matrix = combined_heuristic + nn_heuristic

    return heuristics_matrix
