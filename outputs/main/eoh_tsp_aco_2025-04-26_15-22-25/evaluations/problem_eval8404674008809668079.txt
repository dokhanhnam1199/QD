import numpy as np

def heuristics_v2(distance_matrix):
  """{This algorithm constructs multiple tours by probabilistically selecting the next node based on a combination of distance and pheromone-inspired values, then averages these values to create a heuristic matrix.}"""
  num_nodes = distance_matrix.shape[0]
  num_samples = 100
  pheromone_levels = np.ones_like(distance_matrix) 
  alpha = 1
  beta = 2

  heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

  for _ in range(num_samples):
    start_node = np.random.randint(num_nodes)
    current_node = start_node
    unvisited = set(range(num_nodes))
    unvisited.remove(start_node)
    tour = [start_node]

    while unvisited:
      probabilities = np.zeros(num_nodes)
      for neighbor in unvisited:
        probabilities[neighbor] = (pheromone_levels[current_node, neighbor]**alpha) / (distance_matrix[current_node, neighbor]**beta)
      
      probabilities /= np.sum(probabilities)
      
      next_node = np.random.choice(num_nodes, p=probabilities)
      if next_node not in unvisited: 
          candidates = list(unvisited)
          next_node = candidates[0]
          min_dist = distance_matrix[current_node, next_node]
          for candidate in candidates[1:]:
              if distance_matrix[current_node, candidate] < min_dist:
                  next_node = candidate
                  min_dist = distance_matrix[current_node, candidate]
      
      tour.append(next_node)
      heuristics_matrix[current_node, next_node] += 1
      heuristics_matrix[next_node, current_node] += 1
      unvisited.remove(next_node)
      current_node = next_node
          

    heuristics_matrix[current_node, start_node] += 1
    heuristics_matrix[start_node, current_node] += 1

  heuristics_matrix /= num_samples

  return heuristics_matrix
