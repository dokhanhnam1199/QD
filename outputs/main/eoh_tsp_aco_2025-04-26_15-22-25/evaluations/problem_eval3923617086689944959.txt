import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm constructs a heuristic matrix by generating tours with a nearest neighbor approach, applies 2-opt local search to improve them, and then uses the frequency of edges in the improved tours, weighted by the square root of the inverse of tour length, to construct the heuristic matrix.}"""
    n = distance_matrix.shape[0]
    num_tours = 50
    edge_weights = np.zeros_like(distance_matrix)

    for _ in range(num_tours):
        # Generate a tour using nearest neighbor heuristic
        start_node = np.random.randint(n)
        unvisited = list(range(n))
        tour = [start_node]
        unvisited.remove(start_node)
        
        while unvisited:
            last_node = tour[-1]
            nearest_node = min(unvisited, key=lambda node: distance_matrix[last_node, node])
            tour.append(nearest_node)
            unvisited.remove(nearest_node)
            
        tour.append(start_node)
        
        # 2-opt local search
        improved = True
        while improved:
            improved = False
            for i in range(1, n - 1):
                for k in range(i + 1, n):
                    current_cost = distance_matrix[tour[i-1], tour[i]] + distance_matrix[tour[k], tour[k+1]]
                    new_cost = distance_matrix[tour[i-1], tour[k]] + distance_matrix[tour[i], tour[k+1]]

                    if new_cost < current_cost:
                        tour[i:k+1] = tour[i:k+1][::-1]
                        improved = True
        
        tour_length = sum(distance_matrix[tour[i], tour[i+1]] for i in range(n))
        tour_weight = (1.0 / tour_length)**0.5  # Weight proportional to sqrt of the inverse of tour length

        for i in range(n):
            node1 = tour[i]
            node2 = tour[i+1]
            edge_weights[node1, node2] += tour_weight
            edge_weights[node2, node1] += tour_weight
    
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    for i in range(n):
        for j in range(n):
            if distance_matrix[i, j] > 0:
                heuristics_matrix[i, j] = edge_weights[i, j]
            else:
                heuristics_matrix[i, j] = 0
    
    return heuristics_matrix
