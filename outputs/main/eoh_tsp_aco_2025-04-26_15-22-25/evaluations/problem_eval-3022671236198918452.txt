import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm constructs a heuristic matrix by combining a greedy shortest edge selection with a penalty for edges that would create short cycles, iteratively building a skeleton tour.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    
    edges = []
    for i in range(n):
        for j in range(i + 1, n):
            edges.append((i, j, distance_matrix[i, j]))
    
    edges.sort(key=lambda x: x[2])  # Sort edges by distance
    
    adj = [[] for _ in range(n)]  # Adjacency lists to track connections
    degree = [0] * n  # Degree of each node
    
    for u, v, _ in edges:
        if degree[u] < 2 and degree[v] < 2:
            # Check for cycle formation.  Find path between u and v

            def find_path(start, end, path=[]):
                path = path + [start]
                if start == end:
                    return path
                for node in adj[start]:
                    if node not in path:
                        new_path = find_path(node, end, path)
                        if new_path:
                            return new_path
                return None
            
            if find_path(u,v) is None: # no path exists
                adj[u].append(v)
                adj[v].append(u)
                degree[u] += 1
                degree[v] += 1
                heuristics_matrix[u, v] = 1.0
                heuristics_matrix[v, u] = 1.0
                
    return heuristics_matrix
