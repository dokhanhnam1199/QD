import numpy as np

def heuristics_v2(distance_matrix):
    """
    {This algorithm estimates edge promise by sampling random paths, records edge occurrences with a length bias, and combines this with inverse distance and a shortest-path heuristic emphasizing shorter edges.}
    """
    n = distance_matrix.shape[0]
    num_samples = 1000
    edge_counts = np.zeros_like(distance_matrix, dtype=float)
    path_lengths = np.zeros(num_samples)

    for i in range(num_samples):
        path = np.random.permutation(n)
        path_length = 0
        for j in range(n):
            node1 = path[j]
            node2 = path[(j + 1) % n]
            edge_counts[node1, node2] += 1 / (distance_matrix[node1, node2] + 1e-6)
            edge_counts[node2, node1] += 1 / (distance_matrix[node2, node1] + 1e-6)
            path_length += distance_matrix[node1, node2]
        path_lengths[i] = path_length

    # Normalize edge counts by path length
    normalized_edge_counts = edge_counts / num_samples

    # Combine with inverse distance
    inverse_distance = 1.0 / (distance_matrix + np.eye(n))  # Avoid division by zero
    combined_heuristic = normalized_edge_counts + inverse_distance

    # Shortest path heuristic (Prim's algorithm approximation)
    mst_heuristic = np.zeros_like(distance_matrix, dtype=float)
    for start_node in range(n):
        visited = {start_node}
        edges = []
        for neighbor in range(n):
            if neighbor != start_node:
                edges.append((distance_matrix[start_node, neighbor], start_node, neighbor))
        edges.sort()

        while len(visited) < n:
            min_edge = None
            for edge in edges:
                if edge[1] in visited and edge[2] not in visited:
                    min_edge = edge
                    break
            if min_edge is None:
                break
            
            weight, u, v = min_edge
            mst_heuristic[u,v] = 1
            mst_heuristic[v,u] = 1
            visited.add(v)

            for neighbor in range(n):
                if neighbor not in visited and neighbor != v:
                    edges.append((distance_matrix[v, neighbor], v, neighbor))
            edges.sort()
            edges = [edge for edge in edges if edge[1] not in visited or edge[2] not in visited ]

    # Combine all heuristics
    heuristics_matrix = combined_heuristic + mst_heuristic
    return heuristics_matrix
