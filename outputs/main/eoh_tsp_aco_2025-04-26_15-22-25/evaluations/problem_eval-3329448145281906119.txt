import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm combines the nearest neighbor heuristic with a cycle prevention mechanism, prioritizing short edges to nodes with fewer connections to build a near-optimal tour.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    
    adj = [[] for _ in range(n)]
    degree = [0] * n
    
    unvisited = set(range(n))
    start_node = 0
    current_node = start_node
    unvisited.remove(current_node)
    
    while unvisited:
        nearest_neighbor = None
        min_distance = float('inf')
        
        for neighbor in unvisited:
            distance = distance_matrix[current_node, neighbor]
            if distance < min_distance:
                min_distance = distance
                nearest_neighbor = neighbor
                
        if nearest_neighbor is not None:
            if degree[current_node] < 2 and degree[nearest_neighbor] < 2:
                
                def find_path(start, end, path=[]):
                    path = path + [start]
                    if start == end:
                        return path
                    for node in adj[start]:
                        if node not in path:
                            new_path = find_path(node, end, path)
                            if new_path:
                                return new_path
                    return None
            
                if find_path(start_node, nearest_neighbor) is None or len(unvisited) == 1: # allows last connection
                    adj[current_node].append(nearest_neighbor)
                    adj[nearest_neighbor].append(current_node)
                    degree[current_node] += 1
                    degree[nearest_neighbor] += 1
                    heuristics_matrix[current_node, nearest_neighbor] = 1.0
                    heuristics_matrix[nearest_neighbor, current_node] = 1.0
                    current_node = nearest_neighbor
                    unvisited.remove(current_node)
            else:
                unvisited.remove(nearest_neighbor) # skip
                
    #Connect last node to start node if not already connected.
    last_node = current_node
    if start_node not in adj[last_node]:
        heuristics_matrix[current_node, start_node] = 1.0
        heuristics_matrix[start_node, current_node] = 1.0
    
    return heuristics_matrix
