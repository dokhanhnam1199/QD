import numpy as np

def heuristics_v2(distance_matrix):
  """{This algorithm adaptively adjusts edge selection probabilities based on the frequency with which edges appear in short tours found via a combination of nearest neighbor and random edge selection, thereby iteratively refining the heuristic matrix.}"""
  n = distance_matrix.shape[0]
  num_iterations = 100
  heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
  edge_counts = np.zeros_like(distance_matrix)
  alpha = 1.0

  for _ in range(num_iterations):
    start_node = np.random.randint(n)
    unvisited_nodes = set(range(n))
    current_node = start_node
    tour = [current_node]
    unvisited_nodes.remove(current_node)
    
    while unvisited_nodes:
      # Combine nearest neighbor and random selection
      probabilities = []
      for neighbor in unvisited_nodes:
          probabilities.append(np.exp(-alpha * distance_matrix[current_node, neighbor]))  # Softmax based on distance
          
      probabilities = np.array(probabilities)
      probabilities /= probabilities.sum()
      
      # Introduce some randomness
      probabilities = 0.8 * probabilities + 0.2 / len(unvisited_nodes) 
      probabilities /= probabilities.sum()
          
      next_node = np.random.choice(list(unvisited_nodes), p=probabilities)      
      
      tour.append(next_node)
      unvisited_nodes.remove(next_node)
      current_node = next_node
      
    tour.append(start_node)
    tour_length = 0
    for i in range(n):
        tour_length += distance_matrix[tour[i], tour[i+1]]
    
    # Update edge counts based on tour length (shorter tours contribute more)
    weight = np.exp(-tour_length/ (np.mean(distance_matrix) * n))
    for i in range(n):
      node1 = tour[i]
      node2 = tour[i+1]
      edge_counts[node1, node2] += weight
      edge_counts[node2, node1] += weight

    #Adaptive adjustment of edge selection probabilities
    alpha = 1 + np.mean(edge_counts)

  # Normalize edge counts to create the heuristic matrix
  sum_edge_counts = np.sum(edge_counts)
  if sum_edge_counts > 0:
    heuristics_matrix = edge_counts / sum_edge_counts
  else:
    heuristics_matrix = np.zeros_like(distance_matrix)
  
  return heuristics_matrix
