import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm uses a genetic algorithm approach to evolve a population of tours and constructs a heuristic matrix based on the frequency of edges in the best tours.}"""
    n = distance_matrix.shape[0]
    population_size = 50
    num_generations = 50
    mutation_rate = 0.05

    def create_initial_population(size, n):
        population = []
        for _ in range(size):
            tour = np.random.permutation(n)
            population.append(tour)
        return population

    def calculate_fitness(tour, distance_matrix):
        fitness = 0
        for i in range(len(tour) - 1):
            fitness += distance_matrix[tour[i], tour[i+1]]
        fitness += distance_matrix[tour[-1], tour[0]]
        return fitness

    def crossover(parent1, parent2):
        start = np.random.randint(len(parent1))
        end = np.random.randint(start + 1, len(parent1) + 1)
        child = np.zeros_like(parent1) - 1
        child[start:end] = parent1[start:end]
        
        remaining = [node for node in parent2 if node not in child]
        
        child_idx = 0
        for i in range(len(child)):
            if child[i] == -1:
                child[i] = remaining[child_idx]
                child_idx += 1
        
        return child

    def mutate(tour, mutation_rate):
        if np.random.rand() < mutation_rate:
            i, j = np.random.choice(len(tour), 2, replace=False)
            tour[i], tour[j] = tour[j], tour[i]
        return tour

    population = create_initial_population(population_size, n)
    
    for _ in range(num_generations):
        fitness_scores = np.array([calculate_fitness(tour, distance_matrix) for tour in population])
        probabilities = 1.0 / fitness_scores
        probabilities /= probabilities.sum()

        new_population = []
        for _ in range(population_size):
            parent1_idx = np.random.choice(population_size, p=probabilities)
            parent2_idx = np.random.choice(population_size, p=probabilities)
            
            child = crossover(population[parent1_idx], population[parent2_idx])
            child = mutate(child, mutation_rate)
            new_population.append(child)

        population = new_population

    best_tour_idx = np.argmin([calculate_fitness(tour, distance_matrix) for tour in population])
    best_tour = population[best_tour_idx]

    edge_counts = np.zeros_like(distance_matrix)
    
    num_best_tours = 10
    best_tour_indices = np.argsort([calculate_fitness(tour, distance_matrix) for tour in population])[:num_best_tours]
    
    for tour_idx in best_tour_indices:
        tour = population[tour_idx]
        for i in range(n):
            node1 = tour[i]
            node2 = tour[(i + 1) % n]
            edge_counts[node1, node2] += 1
            edge_counts[node2, node1] += 1

    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    for i in range(n):
        for j in range(n):
            if distance_matrix[i, j] > 0:
                heuristics_matrix[i, j] = edge_counts[i, j] / distance_matrix[i, j]
            else:
                heuristics_matrix[i, j] = 0

    return heuristics_matrix
