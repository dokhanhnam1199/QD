import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm constructs a heuristic matrix by combining shortest edge and minimum spanning tree principles to prioritize edges likely to be in the optimal TSP tour.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

    # Kruskal's algorithm to find Minimum Spanning Tree (MST)
    edges = []
    for i in range(n):
        for j in range(i + 1, n):
            edges.append((i, j, distance_matrix[i, j]))
    edges.sort(key=lambda x: x[2])  # Sort edges by weight

    parent = list(range(n))

    def find(i):
        if parent[i] == i:
            return i
        parent[i] = find(parent[i])
        return parent[i]

    def union(i, j):
        root_i = find(i)
        root_j = find(j)
        if root_i != root_j:
            parent[root_i] = root_j
            return True
        return False

    mst_weight = 0
    mst_edges = []
    for i, j, weight in edges:
        if union(i, j):
            mst_weight += weight
            mst_edges.append((i, j))

    # Heuristic based on MST edges and shortest edges
    shortest_edge_threshold = np.percentile(distance_matrix[distance_matrix > 0], 20)  # Consider top 20% shortest edges

    for i in range(n):
        for j in range(n):
            if i != j:
                if (i, j) in mst_edges or (j, i) in mst_edges:
                    heuristics_matrix[i, j] += 1.0 / distance_matrix[i, j]
                    heuristics_matrix[j, i] += 1.0 / distance_matrix[j, i]
                if distance_matrix[i, j] <= shortest_edge_threshold:
                    heuristics_matrix[i, j] += 0.5 / distance_matrix[i, j]
                    heuristics_matrix[j, i] += 0.5 / distance_matrix[j, i]

    return heuristics_matrix
