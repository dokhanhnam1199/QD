import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm generates multiple random tours, and for each edge, it counts how many times that edge appears in the top-k shortest tours, then normalizes these counts to get a heuristic matrix.}"""
    n = distance_matrix.shape[0]
    num_samples = 1000
    k = 10  # Consider top-k shortest tours

    edge_counts = np.zeros_like(distance_matrix, dtype=int)
    tour_lengths = []
    tours = []

    for _ in range(num_samples):
        # Generate a random tour
        tour = np.random.permutation(n)
        tours.append(tour)

        # Calculate the tour length
        tour_length = 0.0
        for i in range(n):
            tour_length += distance_matrix[tour[i], tour[(i + 1) % n]]
        tour_lengths.append(tour_length)

    # Find the top-k shortest tours
    sorted_indices = np.argsort(tour_lengths)
    top_k_tours = [tours[i] for i in sorted_indices[:k]]

    # Count edge occurrences in the top-k tours
    for tour in top_k_tours:
        for i in range(n):
            u = tour[i]
            v = tour[(i + 1) % n]
            edge_counts[u, v] += 1
            edge_counts[v, u] += 1  # Assuming symmetric distance matrix

    # Normalize edge counts to get the heuristic matrix
    heuristics_matrix = edge_counts / k

    return heuristics_matrix
