import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm refines the heuristic matrix by emphasizing edges present in the Minimum Spanning Tree (MST) and incorporating a weighted score based on edge length relative to the average edge length.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

    # Kruskal's algorithm to find Minimum Spanning Tree (MST)
    edges = []
    for i in range(n):
        for j in range(i + 1, n):
            edges.append((i, j, distance_matrix[i, j]))
    edges.sort(key=lambda x: x[2])  # Sort edges by weight

    parent = list(range(n))

    def find(i):
        if parent[i] == i:
            return i
        parent[i] = find(parent[i])
        return parent[i]

    def union(i, j):
        root_i = find(i)
        root_j = find(j)
        if root_i != root_j:
            parent[root_i] = root_j
            return True
        return False

    mst_weight = 0
    mst_edges = []
    for i, j, weight in edges:
        if union(i, j):
            mst_weight += weight
            mst_edges.append((i, j))

    # Heuristic based on MST edges and shortest edges
    avg_distance = np.mean(distance_matrix[distance_matrix > 0])

    for i in range(n):
        for j in range(n):
            if i != j:
                if (i, j) in mst_edges or (j, i) in mst_edges:
                    heuristics_matrix[i, j] += 2.0 / distance_matrix[i, j]  # Higher weight for MST edges
                    heuristics_matrix[j, i] += 2.0 / distance_matrix[j, i]
                heuristics_matrix[i, j] += (avg_distance / distance_matrix[i, j])
                heuristics_matrix[j, i] += (avg_distance / distance_matrix[j, i])

    return heuristics_matrix
