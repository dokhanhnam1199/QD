import numpy as np

def heuristics_v2(distance_matrix):
    """
    {This algorithm generates multiple random tours by iteratively selecting the nearest unvisited neighbor with a probability proportional to the inverse of the distance, then averages the frequency of each edge's inclusion across these tours to produce a heuristic matrix.}
    """
    num_nodes = distance_matrix.shape[0]
    num_samples = 100  # Number of sample tours to generate

    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

    for _ in range(num_samples):
        start_node = np.random.randint(num_nodes)
        current_node = start_node
        unvisited = set(range(num_nodes))
        unvisited.remove(start_node)
        tour = [start_node]

        while unvisited:
            probabilities = np.array([1 / distance_matrix[current_node, neighbor] for neighbor in unvisited])
            probabilities /= np.sum(probabilities) # Normalize the probabilities.
            nearest_neighbor = np.random.choice(list(unvisited), p=probabilities)
            tour.append(nearest_neighbor)
            unvisited.remove(nearest_neighbor)
            heuristics_matrix[current_node, nearest_neighbor] += 1
            heuristics_matrix[nearest_neighbor, current_node] += 1  # Symmetry
            current_node = nearest_neighbor

        # Complete the tour back to the start
        heuristics_matrix[current_node, start_node] += 1
        heuristics_matrix[start_node, current_node] += 1

    heuristics_matrix /= num_samples # Normalize by the number of samples. 

    return heuristics_matrix
