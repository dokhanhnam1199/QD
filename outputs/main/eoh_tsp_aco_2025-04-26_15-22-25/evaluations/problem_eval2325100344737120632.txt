import numpy as np

def heuristics_v2(distance_matrix):
  """{This algorithm combines edge frequency from short k-random tours with a penalty based on edge distance, emphasizing frequent, short edges.}"""
  n = distance_matrix.shape[0]
  num_tours = 100
  k = 5 # Length of random tours

  edge_counts = np.zeros_like(distance_matrix)

  for _ in range(num_tours):
    start_node = np.random.randint(n)
    tour = [start_node]
    current_node = start_node
    
    for _ in range(k - 1):
      neighbors = list(range(n))
      np.random.shuffle(neighbors)
      
      next_node = -1
      min_dist = np.inf
      
      for neighbor in neighbors:
        if neighbor != current_node:
          dist = distance_matrix[current_node, neighbor]
          if dist < min_dist:
            min_dist = dist
            next_node = neighbor
            
      if next_node != -1:
        tour.append(next_node)
        current_node = next_node
      else:
        break

    for i in range(len(tour) - 1):
      node1 = tour[i]
      node2 = tour[i+1]
      edge_counts[node1, node2] += 1
      edge_counts[node2, node1] += 1
          
  heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
  for i in range(n):
    for j in range(n):
        if distance_matrix[i,j] > 0:
            heuristics_matrix[i, j] = edge_counts[i, j] / (distance_matrix[i, j]**2)
        else:
            heuristics_matrix[i,j] = 0
  return heuristics_matrix
