import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm constructs a heuristic matrix by simulating a diffusion process on the distance matrix, prioritizing edges that facilitate efficient information flow across the graph.}"""
    num_nodes = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    diffusion_steps = 10
    diffusion_rate = 0.1

    # Initialize the heuristic matrix with inverse distances
    for i in range(num_nodes):
        for j in range(num_nodes):
            if i != j:
                heuristics_matrix[i, j] = 1.0 / distance_matrix[i, j]

    # Simulate diffusion process
    for _ in range(diffusion_steps):
        temp_matrix = np.copy(heuristics_matrix)
        for i in range(num_nodes):
            for j in range(num_nodes):
                if i != j:
                    neighbor_sum = 0
                    for k in range(num_nodes):
                        if k != i:
                            neighbor_sum += heuristics_matrix[i, k]
                    
                    average_neighbor = neighbor_sum / (num_nodes - 1) if num_nodes > 1 else 0 # Avoid division by zero
                    temp_matrix[i, j] = (1 - diffusion_rate) * heuristics_matrix[i, j] + diffusion_rate * average_neighbor
        heuristics_matrix = temp_matrix

    # Normalize the heuristic matrix
    max_val = np.max(heuristics_matrix)
    if max_val > 0:
        heuristics_matrix /= max_val

    return heuristics_matrix
