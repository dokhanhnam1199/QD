import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm samples multiple near-greedy solutions based on a heuristic combination of distance and a pheromone-inspired edge desirability, and then returns a matrix indicating the frequency with which each edge appears in the sampled solutions.}"""
    num_nodes = distance_matrix.shape[0]
    num_samples = 100  # Number of sample solutions to generate
    pheromone_matrix = np.ones_like(distance_matrix)  # Initial pheromone values
    heuristics_matrix = np.zeros_like(distance_matrix)

    for _ in range(num_samples):
        current_node = np.random.randint(num_nodes)  # Start from a random node
        unvisited_nodes = set(range(num_nodes))
        unvisited_nodes.remove(current_node)
        tour = [current_node]
        tour_length = 0

        while unvisited_nodes:
            # Heuristic: Combine distance and pheromone
            probabilities = np.zeros(num_nodes)
            for neighbor in unvisited_nodes:
                probabilities[neighbor] = (pheromone_matrix[current_node, neighbor] /
                                           distance_matrix[current_node, neighbor])
            
            probabilities /= np.sum(probabilities)  # Normalize probabilities

            # Select the next node probabilistically
            next_node = np.random.choice(num_nodes, p=probabilities)
            
            if next_node not in unvisited_nodes:
                # Handle rare case where node isn't in unvisited
                eligible_nodes = list(unvisited_nodes)
                if eligible_nodes:
                   next_node = eligible_nodes[0]  # choose first one in the list if it happens
                else:
                   break #No unvisited nodes, break the loop
                
            tour.append(next_node)
            tour_length += distance_matrix[current_node, next_node]
            unvisited_nodes.remove(next_node)
            current_node = next_node
        
        # Complete the tour by returning to the starting node
        tour.append(tour[0])
        tour_length += distance_matrix[current_node, tour[0]]
        
        # Update heuristics_matrix based on the tour
        for i in range(num_nodes):
            heuristics_matrix[tour[i], tour[i+1]] += 1
            heuristics_matrix[tour[i+1], tour[i]] += 1 #ensure symmetry
            
        # Update pheromone matrix (optional - can be refined)
        for i in range(num_nodes):
            pheromone_matrix[tour[i], tour[i+1]] += 1.0 / tour_length
            pheromone_matrix[tour[i+1], tour[i]] += 1.0 / tour_length


    return heuristics_matrix
