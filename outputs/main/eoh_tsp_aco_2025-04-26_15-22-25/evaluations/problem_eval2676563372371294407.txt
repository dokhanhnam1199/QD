import numpy as np

def heuristics_v2(distance_matrix):
  """{This algorithm constructs a heuristic matrix by combining node similarities based on shared neighbors and path diversity encouraged via cycle penalties.}"""
  n = distance_matrix.shape[0]
  heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

  # Node Similarity based on shared neighbors
  for i in range(n):
    for j in range(n):
      if i != j:
        shared_neighbors = 0
        for k in range(n):
          if k != i and k != j:
            if distance_matrix[i, k] < np.mean(distance_matrix[i, :]) and distance_matrix[j, k] < np.mean(distance_matrix[j, :]):
              shared_neighbors += 1
        heuristics_matrix[i, j] += shared_neighbors

  # Encourage path diversity by penalizing short cycles.
  for i in range(n):
    for j in range(n):
      if i != j:
        cycle_penalty = 0
        for k in range(n):
          if k != i and k != j:
            cycle_penalty += np.exp(-distance_matrix[i,k] - distance_matrix[k,j])
        heuristics_matrix[i,j] -= cycle_penalty * 0.1 #Scale the penalty

  # Normalize the heuristics matrix
  max_heuristic = np.max(heuristics_matrix)
  if max_heuristic > 0:
    heuristics_matrix /= max_heuristic

  return heuristics_matrix
