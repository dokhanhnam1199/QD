import numpy as np

def heuristics_v2(distance_matrix):
  """{This algorithm constructs a heuristic matrix by sampling tours based on a greedy nearest neighbor approach with occasional random diversions and updates the matrix based on the frequency of edge usage in these tours, weighted by the tour length.}"""
  n = distance_matrix.shape[0]
  num_iterations = 100
  heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

  for _ in range(num_iterations):
    start_node = np.random.randint(n)
    current_node = start_node
    unvisited = set(range(n))
    unvisited.remove(start_node)
    tour = [start_node]
    tour_length = 0

    while unvisited:
      # Nearest neighbor with some randomness
      if np.random.rand() < 0.9:
          nearest_node = -1
          min_dist = np.inf
          for neighbor in unvisited:
              dist = distance_matrix[current_node, neighbor]
              if dist < min_dist:
                  min_dist = dist
                  nearest_node = neighbor
          next_node = nearest_node
      else:
          next_node = np.random.choice(list(unvisited))

      tour.append(next_node)
      tour_length += distance_matrix[current_node, next_node]
      unvisited.remove(next_node)
      current_node = next_node

    tour_length += distance_matrix[current_node, start_node]
    tour.append(start_node)

    # Update heuristic matrix, weighted by tour length
    for i in range(n):
      node1 = tour[i]
      node2 = tour[i+1]
      heuristics_matrix[node1, node2] += 1/tour_length
      heuristics_matrix[node2, node1] += 1/tour_length

  heuristics_matrix /= num_iterations
  return heuristics_matrix
