import numpy as np

def heuristics_v2(distance_matrix):
  """{This algorithm constructs multiple tours by probabilistically selecting the next node based on distance, applying local search to improve tours, and averages the inverse of tour lengths to create a heuristic matrix.}"""
  num_nodes = distance_matrix.shape[0]
  num_samples = 100

  heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

  def two_opt(tour):
    best_tour = tour
    improved = True
    while improved:
      improved = False
      for i in range(1, len(tour) - 1):
        for k in range(i + 1, len(tour)):
          new_tour = tour[:i] + tour[i:k+1][::-1] + tour[k+1:]
          current_cost = 0
          for index in range(len(tour)-1):
            current_cost += distance_matrix[tour[index], tour[index+1]]
          current_cost += distance_matrix[tour[-1], tour[0]]

          new_cost = 0
          for index in range(len(new_tour)-1):
            new_cost += distance_matrix[new_tour[index], new_tour[index+1]]
          new_cost += distance_matrix[new_tour[-1], new_tour[0]]
          
          if new_cost < current_cost:
            best_tour = new_tour
            tour = new_tour
            improved = True
    return best_tour

  for _ in range(num_samples):
    start_node = np.random.randint(num_nodes)
    current_node = start_node
    unvisited = set(range(num_nodes))
    unvisited.remove(start_node)
    tour = [start_node]
    tour_length = 0

    while unvisited:
      probabilities = np.zeros(num_nodes)
      for neighbor in unvisited:
        probabilities[neighbor] = 1 / (distance_matrix[current_node, neighbor] + 1e-9)
      
      probabilities /= np.sum(probabilities)
      
      next_node = np.random.choice(num_nodes, p=probabilities)
      if next_node not in unvisited: 
          candidates = list(unvisited)
          next_node = candidates[0]
          min_dist = distance_matrix[current_node, next_node]
          for candidate in candidates[1:]:
              if distance_matrix[current_node, candidate] < min_dist:
                  next_node = candidate
                  min_dist = distance_matrix[current_node, candidate]
      
      tour.append(next_node)
      tour_length += distance_matrix[current_node, next_node]
      unvisited.remove(next_node)
      current_node = next_node

    tour.append(start_node)
    tour_length += distance_matrix[current_node, start_node]
    
    tour = two_opt(tour)
    tour_length = 0
    for i in range(len(tour) - 1):
        tour_length += distance_matrix[tour[i], tour[i+1]]
    
    inverse_tour_length = 1 / tour_length

    for i in range(num_nodes):
      for j in range(i + 1, num_nodes):
        if (i in tour) and (j in tour):
          if abs(tour.index(i) - tour.index(j)) == 1 or ( (i == tour[0] and j == tour[-1]) or (j == tour[0] and i == tour[-1])):
            heuristics_matrix[i, j] += inverse_tour_length
            heuristics_matrix[j, i] += inverse_tour_length

  heuristics_matrix /= num_samples

  return heuristics_matrix
