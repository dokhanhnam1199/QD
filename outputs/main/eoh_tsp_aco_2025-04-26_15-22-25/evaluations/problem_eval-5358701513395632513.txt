import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm uses a greedy approach with a probabilistic element, constructing tours by iteratively selecting the nearest unvisited city with a bias towards shorter distances, then averaging edge frequencies over multiple iterations to generate a heuristic matrix.}"""
    n = distance_matrix.shape[0]
    num_iterations = 50
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    
    for _ in range(num_iterations):
        tour = []
        unvisited = list(range(n))
        start_node = np.random.choice(unvisited)
        current_node = start_node
        tour.append(current_node)
        unvisited.remove(current_node)
        
        while unvisited:
            distances = [distance_matrix[current_node, node] for node in unvisited]
            probabilities = [1 / (d + 1e-6) for d in distances] # Inverse distance, avoid division by zero
            probabilities /= np.sum(probabilities)
            
            next_node = np.random.choice(unvisited, p=probabilities)
            tour.append(next_node)
            unvisited.remove(next_node)
            current_node = next_node

        tour.append(start_node)

        for i in range(n):
            node1 = tour[i]
            node2 = tour[i+1]
            heuristics_matrix[node1, node2] += 1
            heuristics_matrix[node2, node1] += 1
            
    heuristics_matrix /= num_iterations
    return heuristics_matrix
