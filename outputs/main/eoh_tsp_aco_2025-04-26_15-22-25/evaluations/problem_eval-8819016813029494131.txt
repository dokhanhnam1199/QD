import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm constructs a heuristic matrix by probabilistically favoring edges connecting nodes with high centrality and short distances, based on a combined metric of degree centrality and inverse distance.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

    # Calculate degree centrality (number of close neighbors)
    degree_centrality = np.sum(distance_matrix < np.median(distance_matrix[distance_matrix > 0]), axis=1)

    # Combine degree centrality and inverse distance
    for i in range(n):
        for j in range(n):
            if i != j:
                heuristics_matrix[i, j] = (degree_centrality[i] + degree_centrality[j]) / (distance_matrix[i, j] + 1e-9) # Add a small constant to prevent division by zero

    return heuristics_matrix
