import numpy as np

def heuristics_v2(distance_matrix):
  """{This algorithm generates multiple random tours by iteratively swapping nodes to reduce tour length, and then assigns higher heuristic values to edges frequently present in these improved tours.}"""
  n = distance_matrix.shape[0]
  num_samples = 100
  heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

  for _ in range(num_samples):
    # Generate a random tour
    tour = np.random.permutation(n)
    
    # Improve the tour using 2-opt swaps
    improved_tour = tour.copy()
    best_distance = calculate_tour_length(distance_matrix, improved_tour)
    
    for i in range(n):
      for j in range(i + 2, n):
        new_tour = improved_tour.copy()
        new_tour[i:j+1] = np.flip(new_tour[i:j+1])
        new_distance = calculate_tour_length(distance_matrix, new_tour)
        
        if new_distance < best_distance:
          improved_tour = new_tour.copy()
          best_distance = new_distance
          
    # Update the heuristic matrix based on the improved tour
    for i in range(n):
      j = (i + 1) % n
      node1 = improved_tour[i]
      node2 = improved_tour[j]
      heuristics_matrix[node1, node2] += 1
      heuristics_matrix[node2, node1] += 1

  heuristics_matrix /= num_samples
  return heuristics_matrix

def calculate_tour_length(distance_matrix, tour):
    """Calculates the total length of a tour given a distance matrix."""
    tour_length = 0
    num_nodes = len(tour)
    for i in range(num_nodes):
        j = (i + 1) % num_nodes
        tour_length += distance_matrix[tour[i], tour[j]]
    return heuristics_matrix
