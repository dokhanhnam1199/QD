import numpy as np

def heuristics_v2(distance_matrix):
  """{This algorithm constructs a heuristic matrix by iteratively improving random tours using 3-opt swaps and simulated annealing, with the heuristic value of an edge reflecting its presence in lower-energy tours.}"""
  n = distance_matrix.shape[0]
  num_iterations = 50
  heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
  temperature = 100.0
  cooling_rate = 0.95

  for _ in range(num_iterations):
    # Generate a random tour
    tour = np.random.permutation(n)
    tour = np.append(tour, tour[0])
    
    best_tour = tour.copy()
    best_tour_cost = calculate_tour_cost(best_tour, distance_matrix)

    # Improve the tour using 3-opt swaps and simulated annealing
    for i in range(1, n-1):
      for j in range(i + 2, n):
        for k in range(j + 2, n+1):
          new_tour = tour.copy()
          #Try different 3-opt moves
          segments = [new_tour[i:j], new_tour[j:k], new_tour[k:]]
          possible_tours = [
              new_tour[:i] + segments[0] + segments[1] + segments[2],
              new_tour[:i] + segments[0] + segments[1][::-1] + segments[2],
              new_tour[:i] + segments[0] + segments[2] + segments[1],
              new_tour[:i] + segments[0] + segments[2][::-1] + segments[1],
              new_tour[:i] + segments[0][::-1] + segments[1] + segments[2],
              new_tour[:i] + segments[0][::-1] + segments[1][::-1] + segments[2],
              new_tour[:i] + segments[0][::-1] + segments[2] + segments[1],
              new_tour[:i] + segments[0][::-1] + segments[2][::-1] + segments[1]
          ]
          
          possible_tours = [tour_seg[:n+1] for tour_seg in possible_tours]
          
          for pt in possible_tours:
              new_tour_cost = calculate_tour_cost(pt, distance_matrix)
              cost_diff = new_tour_cost - calculate_tour_cost(tour, distance_matrix)

              if cost_diff < 0 or np.random.rand() < np.exp(-cost_diff / temperature):
                  tour = pt.copy()
                  
                  if new_tour_cost < best_tour_cost:
                      best_tour = pt.copy()
                      best_tour_cost = new_tour_cost

    # Update the heuristic matrix based on the best tour
    for i in range(n):
      node1 = best_tour[i]
      node2 = best_tour[i+1]
      heuristics_matrix[node1, node2] += 1
      heuristics_matrix[node2, node1] += 1
    
    temperature *= cooling_rate

  heuristics_matrix /= num_iterations
  return heuristics_matrix

def calculate_tour_cost(tour, distance_matrix):
    cost = 0
    for i in range(len(tour) - 1):
        cost += distance_matrix[tour[i], tour[i+1]]
    return heuristics_matrix
