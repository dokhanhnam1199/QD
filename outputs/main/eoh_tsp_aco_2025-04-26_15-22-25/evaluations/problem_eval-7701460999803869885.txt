import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm constructs a heuristic matrix by iteratively improving tours using a 3-opt local search, and aggregates edge frequencies across multiple independently generated and optimized tours, weighted by tour length.}"""
    n = distance_matrix.shape[0]
    num_tours = 50
    edge_counts = np.zeros_like(distance_matrix)
    tour_lengths = []

    for _ in range(num_tours):
        # Generate a random initial tour
        tour = list(np.random.permutation(n))
        tour.append(tour[0])  # Return to starting city
        
        # 3-opt local search
        improved = True
        while improved:
            improved = False
            for i in range(1, n - 2):
                for j in range(i + 1, n - 1):
                    for k in range(j + 1, n):
                        
                        # Original segment costs
                        cost_original = (
                            distance_matrix[tour[i-1], tour[i]] +
                            distance_matrix[tour[j], tour[j+1]] +
                            distance_matrix[tour[k], tour[k+1]]
                        )
                        
                        # Possible 3-opt swaps
                        segments = [tour[i:j+1], tour[j+1:k+1]]

                        # Reverse segment i:j
                        tour_candidate_1 = tour[:i] + tour[i:j+1][::-1] + tour[j+1:k+1] + tour[k:]
                        cost_1 = (
                            distance_matrix[tour[i-1], tour[j]] +
                            distance_matrix[tour[i], tour[j+1]] +
                            distance_matrix[tour[k], tour[k+1]]
                        )
                        
                        # Reverse segment j+1:k
                        tour_candidate_2 = tour[:i] + tour[i:j+1] + tour[j+1:k+1][::-1] + tour[k:]
                        cost_2 = (
                            distance_matrix[tour[i-1], tour[i]] +
                            distance_matrix[tour[j], tour[k]] +
                            distance_matrix[tour[j+1], tour[k+1]]
                        )

                        # Reverse both segments
                        tour_candidate_3 = tour[:i] + tour[i:j+1][::-1] + tour[j+1:k+1][::-1] + tour[k:]
                        cost_3 = (
                            distance_matrix[tour[i-1], tour[j]] +
                            distance_matrix[tour[i], tour[k]] +
                            distance_matrix[tour[j+1], tour[k+1]]
                        )

                        best_cost = min(cost_original, cost_1, cost_2, cost_3)

                        if best_cost < cost_original:
                            improved = True
                            if best_cost == cost_1:
                                tour = tour_candidate_1
                            elif best_cost == cost_2:
                                tour = tour_candidate_2
                            else:
                                tour = tour_candidate_3
                        
        tour_length = sum(distance_matrix[tour[i], tour[i+1]] for i in range(n))
        tour_lengths.append(tour_length)

        for i in range(n):
            node1 = tour[i]
            node2 = tour[i+1]
            edge_counts[node1, node2] += 1
            edge_counts[node2, node1] += 1

    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    for i in range(n):
        for j in range(n):
            if distance_matrix[i, j] > 0:
                heuristics_matrix[i, j] = edge_counts[i, j] / distance_matrix[i, j]
            else:
                heuristics_matrix[i, j] = 0

    return heuristics_matrix
