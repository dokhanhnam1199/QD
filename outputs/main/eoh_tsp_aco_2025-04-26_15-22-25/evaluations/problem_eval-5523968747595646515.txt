import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm constructs a heuristic matrix by combining shortest path distances and edge centralities from a minimum spanning tree.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

    # 1. Minimum Spanning Tree (MST) approximation
    mst_edges = minimum_spanning_tree(distance_matrix)

    # 2. Edge Centrality in MST
    edge_centrality = np.zeros_like(distance_matrix, dtype=float)
    for u, v in mst_edges:
        edge_centrality[u, v] = 1
        edge_centrality[v, u] = 1

    # 3. Shortest Path distance as heuristics
    shortest_path_distances = np.zeros_like(distance_matrix, dtype=float)
    for i in range(n):
        for j in range(n):
            shortest_path_distances[i, j] = shortest_path(distance_matrix, i, j)

    # 4. Combine MST centrality and shortest path distances
    heuristics_matrix = edge_centrality + (1 / (1 + shortest_path_distances))

    return heuristics_matrix

def minimum_spanning_tree(distance_matrix):
    n = distance_matrix.shape[0]
    edges = []
    for i in range(n):
        for j in range(i + 1, n):
            edges.append((i, j, distance_matrix[i, j]))
    
    edges.sort(key=lambda x: x[2])  # Sort edges by weight

    parent = list(range(n))

    def find(i):
        if parent[i] == i:
            return i
        parent[i] = find(parent[i])
        return parent[i]

    def union(i, j):
        root_i = find(i)
        root_j = find(j)
        if root_i != root_j:
            parent[root_i] = root_j
            return True
        return False

    mst_edges = []
    for u, v, weight in edges:
        if union(u, v):
            mst_edges.append((u, v))

    return mst_edges

def shortest_path(distance_matrix, start, end):
    n = distance_matrix.shape[0]
    dist = np.full(n, np.inf)
    dist[start] = 0
    visited = [False] * n

    for _ in range(n):
        u = -1
        min_dist = np.inf
        for v in range(n):
            if not visited[v] and dist[v] < min_dist:
                min_dist = dist[v]
                u = v

        if u == -1:
            break

        visited[u] = True

        for v in range(n):
            if distance_matrix[u, v] > 0 and dist[u] != np.inf and dist[u] + distance_matrix[u, v] < dist[v]:
                dist[v] = dist[u] + distance_matrix[u, v]

    return heuristics_matrix
