import numpy as np

def heuristics_v2(distance_matrix):
  """{This algorithm constructs tours by iteratively adding the shortest edge that doesn't create a cycle or exceed node degree two, then calculates a heuristic matrix based on how often each edge is included in the generated tours.}"""
  num_nodes = distance_matrix.shape[0]
  num_samples = 100
  heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

  for _ in range(num_samples):
    edges = []
    for i in range(num_nodes):
      for j in range(i + 1, num_nodes):
        edges.append((i, j, distance_matrix[i, j]))
    
    edges.sort(key=lambda x: x[2])
    
    parent = list(range(num_nodes))
    degree = [0] * num_nodes
    tour_edges = []

    def find(i):
      if parent[i] == i:
        return i
      parent[i] = find(parent[i])
      return parent[i]

    def union(i, j):
      root_i = find(i)
      root_j = find(j)
      parent[root_i] = root_j

    for u, v, _ in edges:
      if find(u) != find(v) and degree[u] < 2 and degree[v] < 2:
        tour_edges.append((u, v))
        union(u, v)
        degree[u] += 1
        degree[v] += 1
    
    if len(tour_edges) != num_nodes:
        start_node = -1
        degree = [0] * num_nodes
        parent = list(range(num_nodes))
        tour_edges = []
        for u,v, _ in edges:
            if find(u) != find(v) and degree[u] < 2 and degree[v] < 2:
                tour_edges.append((u,v))
                union(u,v)
                degree[u] += 1
                degree[v] += 1
        
    for u, v in tour_edges:
      heuristics_matrix[u, v] += 1
      heuristics_matrix[v, u] += 1

  heuristics_matrix /= num_samples

  return heuristics_matrix
