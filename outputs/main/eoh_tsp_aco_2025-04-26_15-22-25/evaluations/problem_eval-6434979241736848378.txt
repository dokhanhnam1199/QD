import numpy as np

def heuristics_v2(distance_matrix):
  """{This algorithm constructs multiple tours by probabilistically selecting the next node based on distance, incorporating a simulated annealing-like acceptance criterion, and averages the inverse of tour lengths to create a heuristic matrix.}"""
  num_nodes = distance_matrix.shape[0]
  num_samples = 100
  temperature = 10
  decay_rate = 0.95

  heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

  for _ in range(num_samples):
    start_node = np.random.randint(num_nodes)
    current_node = start_node
    unvisited = set(range(num_nodes))
    unvisited.remove(start_node)
    tour = [start_node]
    tour_length = 0

    while unvisited:
      probabilities = np.zeros(num_nodes)
      for neighbor in unvisited:
        probabilities[neighbor] = 1 / (distance_matrix[current_node, neighbor] + 1e-9)

      probabilities /= np.sum(probabilities)

      next_node = np.random.choice(num_nodes, p=probabilities)
      
      if next_node not in unvisited:
        candidates = list(unvisited)
        next_node = candidates[0]
        min_dist = distance_matrix[current_node, next_node]
        for candidate in candidates[1:]:
          if distance_matrix[current_node, candidate] < min_dist:
            next_node = candidate
            min_dist = distance_matrix[current_node, candidate]
      
      delta_length = distance_matrix[current_node, next_node]
      
      if np.random.rand() < np.exp(-delta_length / temperature):
          pass
      else:
          candidates = list(unvisited)
          next_node = candidates[0]
          min_dist = distance_matrix[current_node, next_node]
          for candidate in candidates[1:]:
              if distance_matrix[current_node, candidate] < min_dist:
                  next_node = candidate
                  min_dist = distance_matrix[current_node, candidate]

      tour.append(next_node)
      tour_length += distance_matrix[current_node, next_node]
      unvisited.remove(next_node)
      current_node = next_node
    
    temperature *= decay_rate

    tour_length += distance_matrix[current_node, start_node]
    inverse_tour_length = 1 / tour_length

    for i in range(num_nodes):
      for j in range(i + 1, num_nodes):
        if (i in tour) and (j in tour):
          if abs(tour.index(i) - tour.index(j)) == 1 or (i == tour[0] and j == tour[-1]) or (j == tour[0] and i == tour[-1]):
            heuristics_matrix[i, j] += inverse_tour_length
            heuristics_matrix[j, i] += inverse_tour_length

  heuristics_matrix /= num_samples

  return heuristics_matrix
