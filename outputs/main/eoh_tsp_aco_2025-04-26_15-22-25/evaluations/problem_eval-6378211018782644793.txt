import numpy as np

def heuristics_v2(distance_matrix):
  """{This algorithm constructs multiple tours by probabilistically selecting the next node based on a combination of distance and pheromone-inspired values, then averages the inverse of tour lengths to create a heuristic matrix.}"""
  num_nodes = distance_matrix.shape[0]
  num_samples = 100
  pheromone_levels = np.ones_like(distance_matrix)
  alpha = 1
  beta = 2

  heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

  for _ in range(num_samples):
    start_node = np.random.randint(num_nodes)
    current_node = start_node
    unvisited = set(range(num_nodes))
    unvisited.remove(start_node)
    tour = [start_node]
    tour_length = 0

    while unvisited:
      probabilities = np.zeros(num_nodes)
      for neighbor in unvisited:
        probabilities[neighbor] = (pheromone_levels[current_node, neighbor]**alpha) / (distance_matrix[current_node, neighbor]**beta)
      
      probabilities /= np.sum(probabilities)
      
      next_node = np.random.choice(num_nodes, p=probabilities)
      if next_node not in unvisited: 
          candidates = list(unvisited)
          next_node = candidates[0]
          min_dist = distance_matrix[current_node, next_node]
          for candidate in candidates[1:]:
              if distance_matrix[current_node, candidate] < min_dist:
                  next_node = candidate
                  min_dist = distance_matrix[current_node, candidate]
      
      tour.append(next_node)
      tour_length += distance_matrix[current_node, next_node]
      unvisited.remove(next_node)
      current_node = next_node

    tour_length += distance_matrix[current_node, start_node]
    inverse_tour_length = 1 / tour_length

    for i in range(num_nodes):
      for j in range(i + 1, num_nodes):
        if (i in tour) and (j in tour):
          if abs(tour.index(i) - tour.index(j)) == 1 or (i == tour[0] and j == tour[-1]) or (j == tour[0] and i == tour[-1]):
            heuristics_matrix[i, j] += inverse_tour_length
            heuristics_matrix[j, i] += inverse_tour_length

  heuristics_matrix /= num_samples

  return heuristics_matrix
