[
  {
    "stdout_filepath": "problem_iter1_response0.txt_stdout.txt",
    "code_path": "problem_iter1_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Heuristic 1: Prefer bins that can fit the item (First-Fit Decreasing inspired)\n    fit_mask = bins_remain_cap >= item\n    priorities[fit_mask] += 1  # Give a base priority to bins that can fit\n    \n    # Heuristic 2: Reward bins with capacity closest to item size (Best-Fit inspired)\n    diff = bins_remain_cap - item\n    diff_fit = diff[fit_mask]\n    if len(diff_fit) > 0:\n        best_fit_idx = np.argmin(diff_fit)\n        indices = np.where(fit_mask)[0]\n        priorities[indices[best_fit_idx]] += 2  # Higher priority for the best fit\n    \n    # Heuristic 3: Penalize bins with very large remaining capacity. Prevents from filling one bin very slowly\n    large_cap_mask = bins_remain_cap > 2 * item\n    priorities[large_cap_mask] -= 0.5 #reduce their chance\n\n    #Heuristic 4: If the bin is almost full after adding the item give a huge incentive\n    almost_full_cap = bins_remain_cap - item\n    almost_full_mask = (almost_full_cap <= 0.1) & (almost_full_cap >= 0)\n    priorities[almost_full_mask] += 5 #high priority if we almost fill\n\n    #Heuristic 5: Do not pick a bin if the item doesn't fit\n    no_fit_mask = bins_remain_cap < item\n    priorities[no_fit_mask] -=100 # do not pick a bin that doens't fit\n\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response1.txt_stdout.txt",
    "code_path": "problem_iter1_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Prioritize bins that can fit the item\n    fit_mask = bins_remain_cap >= item\n    priorities[fit_mask] = 1\n\n    # If no bin can fit, assign a small negative priority to all bins to allow selection later if necessary, effectively postponing the bin opening\n    if not np.any(fit_mask):\n        priorities[:] = -0.01 # Assign small penalty so opening new bin is less favorable than packing when possible\n    else: # Otherwise, for bins that fit, prefer bins that leave the least waste.\n        waste = bins_remain_cap[fit_mask] - item\n        priorities[fit_mask] = 1 / (waste + 0.0001) # avoid div by zero and smaller waste means better priority\n\n    # Apply a bonus for bins that are almost full to encourage efficient use\n    almost_full_mask = (bins_remain_cap > 0) & (bins_remain_cap < item * 2) # bins at least half full, to avoid leaving many almost empty\n    priorities[almost_full_mask] += 0.5  # moderate bonus to avoid excessive greedy.\n\n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response2.txt_stdout.txt",
    "code_path": "problem_iter1_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Very small remaining capacity gets very high priority\n    priorities[bins_remain_cap < 0.001] = -np.inf\n    \n    # Calculate wasted space if item is placed in the bin\n    wasted_space = bins_remain_cap - item\n    \n    # Give higher priority to bins where the item fits\n    fit_indices = wasted_space >= 0\n    \n    if np.any(fit_indices):\n        # Prioritize bins with minimal wasted space. Avoid creating tiny fragmented spaces.\n        priorities[fit_indices] = 1 / (wasted_space[fit_indices] + 0.0001) # add small value to avoid inf\n        \n        # Also encourage to fill bins up to certain percentage of capacity\n        filled_percentage = 1 - (wasted_space[fit_indices] / bins_remain_cap[fit_indices])\n        priorities[fit_indices] += np.where((filled_percentage >= 0.75) & (filled_percentage <= 1), 10, 0) # Strong bonus for good filling\n        \n        # Penalize bins which become too full\n        priorities[fit_indices] -= np.where(filled_percentage > 0.999, 100, 0)\n\n    else:\n        # if it does not fit anywhere, place in bin that can accomodate item later\n        priorities[:] = bins_remain_cap - item\n    \n    return priorities",
    "response_id": 2,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response3.txt_stdout.txt",
    "code_path": "problem_iter1_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Calculate remaining capacity after adding the item\n    remaining_after_add = bins_remain_cap - item\n\n    # Give high priority to bins where the item fits\n    fit_indices = remaining_after_add >= 0\n    priorities[fit_indices] = 1.0 / (remaining_after_add[fit_indices] + 0.00001)  # Avoid division by zero and prefer tighter fits\n\n    # Give a negative priority to bins where the item does not fit (discourage)\n    priorities[~fit_indices] = -np.inf\n\n    # Normalize the priorities (optional, but can sometimes help)\n    # valid_priorities = priorities[np.isfinite(priorities)]\n    # if len(valid_priorities) > 0:\n    #     min_priority = np.min(valid_priorities)\n    #     max_priority = np.max(valid_priorities)\n    #     if max_priority > min_priority:\n    #         priorities[np.isfinite(priorities)] = (priorities[np.isfinite(priorities)] - min_priority) / (max_priority - min_priority)\n\n\n    return priorities",
    "response_id": 3,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response4.txt_stdout.txt",
    "code_path": "problem_iter1_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Very small bins are penalized.\n    priorities[bins_remain_cap < item] = -np.inf\n\n    # Bins with capacity closest to item size get higher priority\n    diff = np.abs(bins_remain_cap - item)\n    priorities[bins_remain_cap >= item] = -diff[bins_remain_cap >= item]\n\n    # Add a bonus for bins that are relatively full (but can still fit item)\n    fill_ratio = (1 - bins_remain_cap / np.max(bins_remain_cap))\n    priorities[bins_remain_cap >= item] += fill_ratio[bins_remain_cap >= item]\n\n    return priorities",
    "response_id": 4,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response5.txt_stdout.txt",
    "code_path": "problem_iter1_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Assign a high priority to bins that can fit the item.\n    # Bins that cannot fit the item get a very low (negative) priority.\n    \n    can_fit = bins_remain_cap >= item\n    priorities[can_fit] = bins_remain_cap[can_fit] - item #Remaining capacity if the item is added\n    priorities[~can_fit] = -np.inf  # Very low priority if cannot fit\n\n    # Add a small bonus for bins that are already partially full to help consolidate\n    # We do not consolidate if there are empty bins to avoid filling them when unnecessary\n    if np.any(bins_remain_cap < 1) and np.any(bins_remain_cap == 1):\n        priorities[can_fit] += (1 - bins_remain_cap[can_fit]) # Use the occupied portion as bonus\n\n    return priorities",
    "response_id": 5,
    "obj": 149.30195452732352,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response6.txt_stdout.txt",
    "code_path": "problem_iter1_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Assign high priority to bins that can fit the item\n    fit_mask = bins_remain_cap >= item\n    priorities[fit_mask] = 1.0\n    \n    # Give a slightly higher priority to bins that have minimal wasted space\n    waste = bins_remain_cap - item\n    minimal_waste_mask = (waste >= 0)\n    if np.any(minimal_waste_mask):\n        min_waste = np.min(waste[minimal_waste_mask])\n        priorities[minimal_waste_mask & (waste == min_waste)] += 0.5\n\n    # Penalize bins where the item doesn't fit by setting the priority to a very small number\n    priorities[~fit_mask] = -1e9\n    \n    # Introduce a small amount of randomness to break ties and explore solutions\n    priorities += np.random.rand(len(bins_remain_cap)) * 0.01\n    \n    return priorities",
    "response_id": 6,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response7.txt_stdout.txt",
    "code_path": "problem_iter1_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Large bins are preferred for smaller items (try to leave larger bins for larger items later)\n    priorities[bins_remain_cap >= item] = bins_remain_cap[bins_remain_cap >= item]  # Favor bins that can fit the item\n\n    # If no bin can fit the item, use the bin with the most remaining capacity\n    if np.all(bins_remain_cap < item):\n        priorities = bins_remain_cap # Use the bins with largest capacity even if they can't fit the item\n        priorities = priorities / np.max(priorities) # scale to range from 0 to 1\n\n    # Try to avoid almost full bins if possible\n    almost_full = (bins_remain_cap < (item + 0.1)) & (bins_remain_cap >= item) # added threshold for floating point inaccuracies\n    priorities[almost_full] -= 0.5  # slightly disincentivize nearly full bins (but still allow).\n\n\n    # Give higher priority to bins where the item fills a larger proportion of space\n    fill_ratio = item / bins_remain_cap\n    priorities[bins_remain_cap >= item] += fill_ratio[bins_remain_cap >= item]\n    return priorities",
    "response_id": 7,
    "obj": 149.30195452732352,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response8.txt_stdout.txt",
    "code_path": "problem_iter1_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # First-Fit Decreasing heuristic inspiration: Give highest priority to bins that can fit the item best\n    # Reward bins that have a capacity close to the item size, but not smaller (avoid wasting too much space)\n    # Give -inf priority to bins that cannot fit the item.\n    for i, cap in enumerate(bins_remain_cap):\n        if cap < item:\n            priorities[i] = -np.inf\n        else:\n            # Calculate wasted space if the item is placed in this bin\n            wasted_space = cap - item\n            # Priority is higher for bins that minimize wasted space.\n            # Adding a small constant to the item size to avoid division by zero if wasted_space is 0\n            priorities[i] = 1 / (wasted_space + 0.0001)\n\n            # Secondary priority: Prefer bins that are not too full already.\n            priorities[i] += 0.1 * (1 - (cap / np.max(bins_remain_cap))) # Add bonus for being relatively empty.\n    return priorities",
    "response_id": 8,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.99999213999945 seconds"
  },
  {
    "stdout_filepath": "problem_iter1_response9.txt_stdout.txt",
    "code_path": "problem_iter1_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Calculate the remaining capacity after adding the item to each bin.\n    remaining_capacities = bins_remain_cap - item\n\n    # Give a high priority to bins where the item fits and leaves minimal waste.\n    # Prioritize bins where the item fits. If it doesn't fit, priority is -inf.\n    fits = remaining_capacities >= 0\n    priorities[~fits] = -np.inf  # Make sure it does not select a bin which does not fits\n    waste = remaining_capacities[fits]\n\n    # Assign priorities based on waste; smaller waste = higher priority. If no bin fits, all priorities remain at 0.\n    if np.any(fits):\n        priorities[fits] = -waste\n\n        # Boost priority for bins with a capacity close to the item size.  Encourage using \"almost full\" bins first, which helps minimize the # bins used\n        # This is a heuristic to attempt First-Fit-Decreasing.\n        close_to_full = (bins_remain_cap[fits] >= item) & (bins_remain_cap[fits] <= item*1.2) #bin capacity up to 20% larger than item size\n        priorities[fits][close_to_full] += 10  # Significant boost\n\n        # Also consider the percentage of the bin that will be used up\n        usage_ratio = item / bins_remain_cap[fits]\n        priorities[fits] += usage_ratio  # Gives some preference to bins that fill better, even if the absolute waste is not as low\n\n    return priorities",
    "response_id": 9,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response10.txt_stdout.txt",
    "code_path": "problem_iter1_code10.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # First-Fit-Decreasing-like Heuristic: Prioritize bins that can fit the item with minimal waste.\n    \n    # 1. Filter out bins that cannot accommodate the item\n    valid_bins = bins_remain_cap >= item\n    \n    if not np.any(valid_bins):\n        # If no bin can fit the item, all priorities are zero (handled by initialization)\n        return priorities\n    \n    # 2. Calculate wasted space for valid bins\n    wasted_space = bins_remain_cap[valid_bins] - item\n    \n    # 3. Give higher priority to bins with less wasted space\n    priorities[valid_bins] = 1.0 / (wasted_space + 1e-6)  # Avoid division by zero\n    \n    # 4. Boost priority for bins that are nearly full after adding the item (encourages full bins)\n    nearly_full_threshold = 0.9  # Bins that are at least 90% full after insertion are preferred. Can be fine-tuned.\n    is_nearly_full = (bins_remain_cap[valid_bins] - item) / bins_remain_cap[valid_bins] <= (1 - nearly_full_threshold)\n    priorities[valid_bins][is_nearly_full] *= 2.0  # Adjust multiplier as needed\n\n    # Alternative 1: Give a very small priority to bins that cannot fit item, but only if NO bin can fit the item well.\n    # if not np.any(bins_remain_cap > item * 1.2):  # Try bins only if the \"waste\" will be high. 1.2 is a safety factor\n    #    priorities += 0.0001\n    # Alternative 2: Penalize very empty bins in all cases. This pushes for more packed bins overall.\n    #   priorities -= (1 - bins_remain_cap/ np.max(bins_remain_cap)) *0.001\n\n    return priorities",
    "response_id": 10,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response11.txt_stdout.txt",
    "code_path": "problem_iter1_code11.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Rule 1: Bins that can fit the item get higher priority.\n    can_fit = bins_remain_cap >= item\n    priorities[can_fit] += 1  # Or any positive value\n\n    # Rule 2: Among bins that can fit, prioritize those with less remaining space *after* placement.\n    remaining_after_placement = bins_remain_cap[can_fit] - item\n    priorities[can_fit] += np.max(bins_remain_cap) - remaining_after_placement # Prefer smaller remaining\n\n    # Rule 3: For bins that *cannot* fit, give them a negative score based on how close they are.  \n    cannot_fit = ~can_fit\n    closeness = bins_remain_cap[cannot_fit] + item - bins_remain_cap[cannot_fit] # =item \n    priorities[cannot_fit] -= closeness\n\n    return priorities",
    "response_id": 11,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response12.txt_stdout.txt",
    "code_path": "problem_iter1_code12.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # First-Fit Decreasing inspired heuristic: Prioritize bins that can fit the item closely\n    # and avoid bins that are too large relative to the item size.\n    \n    # 1. Bins that cannot fit the item get a negative priority (discouraged)\n    cannot_fit = bins_remain_cap < item\n    priorities[cannot_fit] = -np.inf  #Very low priority\n    \n    # 2. For bins that can fit the item:\n    can_fit = bins_remain_cap >= item\n    \n    if np.any(can_fit): #Only do calculations if any bin can fit. Prevents division by zero.\n    \n        # Calculate the waste if the item is placed in each bin\n        waste = bins_remain_cap[can_fit] - item\n\n        #Prioritize the bins such that the waste is minimal\n        priorities[can_fit] = -waste\n\n        #If multiple bins have the same amount of waste, then give priority to smaller bins\n        #This encourages bins with slightly smaller capacity to be utilized instead of leaving bigger bins open with capacity.\n        priorities[can_fit] += -0.00000001 * bins_remain_cap[can_fit]\n\n\n    return priorities",
    "response_id": 12,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response13.txt_stdout.txt",
    "code_path": "problem_iter1_code13.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # First, prioritize bins that can fit the item\n    fit_mask = bins_remain_cap >= item\n    priorities[fit_mask] = 1  # Give a base priority to bins that fit\n\n    # For bins that fit, prioritize those with smallest remaining capacity after placing the item\n    remaining_after_fit = bins_remain_cap[fit_mask] - item\n    priorities[fit_mask] += 1 / (remaining_after_fit + 0.00001)  # Add inverse of remaining capacity\n\n    #For bins that don't fit, penalize them\n    non_fit_mask = ~fit_mask\n    priorities[non_fit_mask] = -1 * (item - bins_remain_cap[non_fit_mask]) # The larger the difference between item size and bin cap, the more negative\n\n    return priorities",
    "response_id": 13,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 21, in priority_v2\n    if len(remaining_after_fit) > 0:\nnumpy._core._exceptions._UFuncOutputCastingError: Cannot cast ufunc 'add' output from dtype('float64') to dtype('int64') with casting rule 'same_kind'\n"
  },
  {
    "stdout_filepath": "problem_iter1_response14.txt_stdout.txt",
    "code_path": "problem_iter1_code14.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Prioritize bins where the item fits\n    fit_indices = bins_remain_cap >= item\n    priorities[fit_indices] = 1\n\n    # Further prioritize bins that have the least remaining capacity after adding the item, among those that fit.\n    remaining_after_fit = bins_remain_cap[fit_indices] - item\n    if len(remaining_after_fit) > 0:\n        min_remaining = np.min(remaining_after_fit)\n        best_fit_indices = np.where(bins_remain_cap[fit_indices] - item == min_remaining)[0]\n        indices_in_original = np.where(fit_indices)[0][best_fit_indices] # get original index\n\n        priorities[indices_in_original] = 2\n\n    # If no bin fits, prioritize bins with maximum capacity to minimize number of bins used\n    if not np.any(fit_indices):\n        max_cap = np.max(bins_remain_cap)\n        max_cap_indices = bins_remain_cap == max_cap\n        priorities[max_cap_indices] = 0.5 # less desirable but better than others\n\n    return priorities",
    "response_id": 14,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response15.txt_stdout.txt",
    "code_path": "problem_iter1_code15.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Very high priority for bins that can fit perfectly.\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    priorities[perfect_fit] = 1000  # A very large priority\n    \n    # High priority for bins that can fit and leave smallest waste\n    can_fit = bins_remain_cap >= item\n    waste = bins_remain_cap - item\n    priorities[can_fit] = 100 / (waste[can_fit] + 0.0001) # avoid division by zero\n    \n    # Negative priority to bins that cannot fit.  This avoids selecting completely unsuited bins, ever\n    cannot_fit = bins_remain_cap < item\n    priorities[cannot_fit] = -1000  \n    \n    return priorities",
    "response_id": 15,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response16.txt_stdout.txt",
    "code_path": "problem_iter1_code16.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Calculate remaining capacity after adding the item to each bin\n    remaining_after_add = bins_remain_cap - item\n\n    # Assign priorities based on different criteria:\n    # 1. If item fits perfectly (remaining capacity is 0), give it the highest priority.\n    perfect_fit = remaining_after_add == 0\n    priorities[perfect_fit] = 1000  # Highest priority\n\n    # 2. If item fits, give higher priority to bins with smaller remaining capacity, avoid fragmentation\n    fits = remaining_after_add >= 0\n    priorities[fits] = 100 / (remaining_after_add[fits] + 0.0001) # higher score with smaller remaining\n\n    # 3. If item does not fit, give the lowest possible priority. We want to add to available bin only\n    does_not_fit = remaining_after_add < 0\n    priorities[does_not_fit] = -1000\n    \n    # If the first two steps did not find any fits at all (all elements in remaining_after_add are < 0,\n    #   or no bins had a perfect fit, apply the following:\n    if np.all(does_not_fit):\n        priorities = -1000 * np.ones_like(bins_remain_cap) # Ensure no bin is mistakenly selected\n        \n    return priorities",
    "response_id": 16,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response17.txt_stdout.txt",
    "code_path": "problem_iter1_code17.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # First Fit Decreasing-like: prefer bins with enough space.\n    fit_mask = bins_remain_cap >= item\n    priorities[fit_mask] += 1\n\n    # Prefer bins with smaller remaining capacity after placing the item,\n    # but only if the item fits.\n    remaining_after_fit = bins_remain_cap[fit_mask] - item\n    priorities[fit_mask] += 1 / (remaining_after_fit + 1e-6)  # Avoid division by zero\n\n    # Penalize bins that cannot fit the item by a large negative number\n    # unless all bins are full, we dont do it.\n    if np.any(fit_mask):\n        priorities[~fit_mask] -= 1000\n\n    return priorities",
    "response_id": 17,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response18.txt_stdout.txt",
    "code_path": "problem_iter1_code18.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # First-Fit-Decreasing inspired: Prioritize bins that can fit the item reasonably well\n    # Avoid bins that are either too full (nearly full) or too empty (wasteful)\n    fit_ratios = item / bins_remain_cap\n    \n    # Give a base score if the item fits\n    fits = bins_remain_cap >= item\n    priorities[fits] += 1.0\n\n    # Higher priority if the bin is filled more completely without overflowing. Goal: bins_remain_cap - item to be small and positive.\n    #Prioritize bins with a remaining capacity close to the item size, but penalize bins where adding the item would cause a near-full bin.\n    remaining_after_fit = bins_remain_cap - item\n    \n    \n    good_fit = (remaining_after_fit >= 0)\n    \n    priorities[good_fit] += np.exp(-np.abs(remaining_after_fit[good_fit])) \n\n    # Bonus for avoiding nearly full bins: Prefer bins that leave a little space.\n    nearly_full = (bins_remain_cap > item) & (bins_remain_cap - item < 0.1) #if bin is nearly full\n    priorities[nearly_full] -=0.5 #give a small negative weight if adding leads to nearly full\n        \n\n    #Consider a bonus based on bin utilization, encouraging filling bins more fully. Avoid near empty bins by penalizing them\n    utilization_score = (bins_remain_cap - item) / bins_remain_cap # How much of the remaining space is used by the item\n    \n    priorities[good_fit] += (1 -utilization_score[good_fit]) # if remaining space after adding item is little, utilization is high, then a high value is assigned\n\n    #Very small cap bins should be penalized with a slightly larger penalty because of fragmentation\n    very_small_cap = (bins_remain_cap < item)\n    priorities[very_small_cap] -=1\n\n    return priorities",
    "response_id": 18,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response19.txt_stdout.txt",
    "code_path": "problem_iter1_code19.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # 1. Feasibility: Give -inf priority if item doesn't fit.\n    infeasible_mask = item > bins_remain_cap\n    priorities[infeasible_mask] = -np.inf\n    \n    # 2. Best Fit: Higher priority for bins with smallest remaining capacity after placement.\n    #    But only if it's not too tight (to avoid fragmentation)\n    \n    feasible_mask = ~infeasible_mask\n    remaining_after_placement = bins_remain_cap[feasible_mask] - item\n    \n    # a) Fragmentation penalty: if remaining capacity is too small.\n    fragmentation_threshold = 0.1 #tuneable, relative to bin size \n    \n    fragmentation_penalty_mask = remaining_after_placement < fragmentation_threshold\n    remaining_after_placement[fragmentation_penalty_mask] *= -1 #make them undesirable.\n\n    # b) Best Fit score: higher priority for bins that leave smallest amount of space\n    priorities[feasible_mask] = -remaining_after_placement\n    \n    # 3. Avoid Overfilling (Safety Buffer): Slightly prefer bins with larger capacities relative to item size, even if other factors are equal\n    #    Use the ratio as a smoothing/dampening factor.  Small values can be problematic\n    capacity_ratio = item / bins_remain_cap\n    safe_mask = ~infeasible_mask\n    priorities[safe_mask] += 0.1* (1-capacity_ratio[safe_mask])\n    \n    # 4. Ties - break ties randomly\n    ties_mask = priorities == np.max(priorities)\n    if np.sum(ties_mask) > 1:\n      priorities[ties_mask] += np.random.normal(0, 0.001, np.sum(ties_mask))\n\n    return priorities",
    "response_id": 19,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response20.txt_stdout.txt",
    "code_path": "problem_iter1_code20.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # 1. Feasibility check: Bin must have enough capacity.\n    feasible_bins = bins_remain_cap >= item\n    \n    # 2. If no bin is feasible, assign a very low priority to all bins.\n    if not np.any(feasible_bins):\n        return priorities - 1e9  # Return very low priority\n    \n    # 3. Calculate remaining capacity after placing the item (only for feasible bins).\n    remaining_capacities = bins_remain_cap - item\n    remaining_capacities[~feasible_bins] = -1  # Mark infeasible bins\n    \n    # 4. Calculate priority based on how full the bin would be after placement.\n    #    Prioritize bins that become fuller, but not too full.  We want a good fit, \n    #    but also want to avoid bins being too close to full to allow future placements\n    \n    # a. Fill ratio\n    fill_ratio = (bins_remain_cap - remaining_capacities) / 1.0 #Assume bin capacity is 1.0\n    \n    # b. Prioritize bins with a higher fill ratio, up to a point (e.g., 90% full).\n    priorities = fill_ratio\n\n    # c. Penalize bins that would be very full\n    very_full = remaining_capacities < 0.1\n    priorities[very_full & feasible_bins] -= 0.5 # Substantial penalty.\n\n    # d. Incentivize almost full, if possible\n    almost_full = (remaining_capacities >= 0.05) & (remaining_capacities < 0.1) & feasible_bins\n    priorities[almost_full] += 0.2\n    \n\n    # 5. Give infeasible bins very low priority.\n    priorities[~feasible_bins] = -1e9\n\n    return priorities",
    "response_id": 20,
    "obj": 5.534503390506582,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response21.txt_stdout.txt",
    "code_path": "problem_iter1_code21.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: Disqualify bins that are too small.\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -np.inf  # Mark as infeasible\n\n    # 2. Maximize space utilization: Prefer bins that fit the item best\n    # but avoid bins where item will be a tight fit\n    # Add a small constant to both numerator and denominator to\n    # bias towards partially filled bins and help diversify bin selection.\n    fit_scores = (bins_remain_cap - item + 0.1) / (bins_remain_cap + 0.1)\n    fit_scores[infeasible_bins] = -np.inf # Reset fit score for infeasible bins\n\n    # 3. Reward partially filled bins: Add bonus if bin is not empty but\n    # less than half full (encourage usage of partially filled bins).\n\n    partially_filled = (bins_remain_cap > item) & (bins_remain_cap < 0.5)\n\n    priorities += fit_scores\n\n    priorities[partially_filled] += 0.5 # give priority to partially filled bins.\n\n    #4. Penalty for almost full bins that don't have enough space. Only applicable if item is too big, since otherwise the bin would already be disqualified\n    almost_full = (bins_remain_cap > 0) & (bins_remain_cap < item)\n    priorities[almost_full] -= 1.0 # Give a penalty. This should be negative because item is too large anyway. The higher penalty helps to prevent bins being almost filled\n\n    return priorities",
    "response_id": 21,
    "obj": 149.30195452732352,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response22.txt_stdout.txt",
    "code_path": "problem_iter1_code22.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Assign a high priority to bins that can fit the item\n    can_fit = bins_remain_cap >= item\n    priorities[can_fit] = 1\n\n    # For bins that can fit, prioritize those with less remaining capacity *after* adding the item.\n    remaining_after_fit = bins_remain_cap[can_fit] - item\n    priorities[can_fit] += 1 / (remaining_after_fit + 1e-9)  # Add small epsilon to prevent division by zero\n\n    # Penalize bins that cannot fit\n    cannot_fit = ~can_fit\n    priorities[cannot_fit] = -10 # Assign a significant penalty\n\n    return priorities",
    "response_id": 22,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response23.txt_stdout.txt",
    "code_path": "problem_iter1_code23.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # First-Fit Decreasing-like heuristic: Prefer bins that can fit the item,\n    # and among those, prefer bins with less remaining space after packing the item.\n    # This helps in packing items more densely and potentially leaving larger bins for\n    # potentially larger upcoming items.\n\n    # Give a large negative priority if the bin cannot fit the item\n    priorities[bins_remain_cap < item] = -np.inf\n\n    # For bins that can fit the item:\n    valid_bins = bins_remain_cap >= item\n    remaining_space_after_packing = bins_remain_cap[valid_bins] - item\n\n    # Give a higher priority to bins that have less remaining space after packing\n    # We use a scaled negative remaining space, so smaller remaining space -> higher priority.\n    # Adding a small constant to avoid zero values if remaining space is small/zero.\n    priorities[valid_bins] = -remaining_space_after_packing\n\n    # Boost slightly bins that have larger remaining capacity. The aim is to somehow favor using empty bins or bins with a bit larger room.\n    # This is a tunable parameter and might improve or worsen the performance depending on test cases.\n    # Larger room also can cause to postpone fragmentation of the bin by smaller objects.\n\n    priorities[valid_bins] += 0.01 * bins_remain_cap[valid_bins]\n\n    return priorities",
    "response_id": 23,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response24.txt_stdout.txt",
    "code_path": "problem_iter1_code24.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Give a high priority to bins that can fit the item\n    fit_mask = bins_remain_cap >= item\n    priorities[fit_mask] += 1.0\n\n    # Prioritize bins where the remaining space after adding the item is small\n    remaining_after_fit = bins_remain_cap[fit_mask] - item\n    priorities[fit_mask] += np.exp(-remaining_after_fit)  # Exponential decay to favor smaller remaining space\n    \n    # Penalize bins that have very little remaining capacity overall to avoid fragmentation\n    priorities -= np.exp(-bins_remain_cap)  # Exponential penalty for small remaining capacity\n\n    # Heavily penalize bins that can't fit the item. We want to only select them as a last resort (or potentially never)\n    priorities[~fit_mask] -= 100 # large negative number so that the bins that fit will always be picked over these\n        \n    return priorities",
    "response_id": 24,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response25.txt_stdout.txt",
    "code_path": "problem_iter1_code25.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Give a high priority to bins that can accommodate the item.\n    feasible_bins = bins_remain_cap >= item\n    \n    if np.any(feasible_bins):\n        # Prioritize bins with tighter fit.\n        remaining_space = bins_remain_cap[feasible_bins] - item\n        priorities[feasible_bins] = 1 / (remaining_space + 1e-9) # avoid division by zero\n        \n        # Further prioritize bins where the item occupies a significant portion\n        # and doesn't leave much wasted space.\n        fill_ratios = item / bins_remain_cap[feasible_bins]\n        priorities[feasible_bins] += fill_ratios\n\n        # Consider penalizing bins with very high remaining capacity, as using them might lead to more overall waste.\n        large_capacity_bins = bins_remain_cap[feasible_bins] > 2 * item # arbitrary threshold\n        priorities[feasible_bins][large_capacity_bins] *= 0.5  # reduce priority slightly\n\n    # Optionally, penalize infeasible bins (though usually best to leave these at 0)\n    # priorities[~feasible_bins] = -1e9 # Very negative priority.\n\n    return priorities",
    "response_id": 25,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response26.txt_stdout.txt",
    "code_path": "problem_iter1_code26.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            fill_ratio = item / cap\n            waste = cap - item\n            # Combination of fill ratio and remaining waste.\n            # Prioritize bins that have a good fill ratio AND leave little waste.\n            priorities[i] = (1 - fill_ratio) + (1/(1 + waste))  # Minimize wasted space relative to bin size\n        else:\n            priorities[i] = -np.inf  # Never choose if item doesn't fit\n\n    return priorities",
    "response_id": 26,
    "obj": 85.25129637016356,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response27.txt_stdout.txt",
    "code_path": "problem_iter1_code27.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # A bin must have sufficient capacity to hold the item\n    feasible_bins = bins_remain_cap >= item\n    \n    # If no bin is feasible, return an array of -inf\n    if not np.any(feasible_bins):\n        return np.full_like(bins_remain_cap, -np.inf)\n    \n    \n    # Prioritize bins based on remaining capacity after placing the item\n    remaining_capacity_after_placement = bins_remain_cap - item\n    \n    # Only consider feasible bins\n    remaining_capacity_after_placement[~feasible_bins] = -1  # Mark infeasible bins\n    \n    # Prioritize based on how full the bin would be, but also penalize almost full bins\n    priorities[feasible_bins] = (item / bins_remain_cap[feasible_bins])  + np.exp(-10*(bins_remain_cap[feasible_bins] - item))\n    \n    return priorities",
    "response_id": 27,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response28.txt_stdout.txt",
    "code_path": "problem_iter1_code28.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # 1. Feasibility: Prioritize bins where the item fits.\n    feasible_bins = bins_remain_cap >= item\n    priorities[feasible_bins] += 1  # Give feasible bins a base priority\n\n    # 2. Remaining Capacity: Prioritize bins with less remaining capacity after placement (First Fit Decreasing variant). Closer fit is better.\n    remaining_after_fit = bins_remain_cap - item\n    remaining_after_fit[remaining_after_fit < 0] = np.inf  # Penalize infeasible bins\n    priorities[feasible_bins] += 1.0 / (remaining_after_fit[feasible_bins] + 0.00001)  # Avoid division by zero. Add to feasible bins only. Smaller remains = higher priority.\n    \n    # 3. Avoidance of Fragmentation: A penalty if the remaining capacity becomes too small\n    fragmentation_threshold = 0.1  #tuneable parameter related to bin size.\n    small_remaining = remaining_after_fit < fragmentation_threshold\n    priorities[small_remaining] -= 0.5  # Mild penalty\n\n    # 4. Bonus for almost full bins: Encourages closing off bins.\n\n    almost_full_threshold = 0.9\n    almost_full = (bins_remain_cap > 0) & ((bins_remain_cap - item) / bins_remain_cap < 1 - almost_full_threshold) & (bins_remain_cap >= item)\n    priorities[almost_full] += 2 #Higher Priority for bins that will be closed\n    \n    return priorities",
    "response_id": 28,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response29.txt_stdout.txt",
    "code_path": "problem_iter1_code29.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Give higher priority to bins that can accommodate the item\n    valid_bins = bins_remain_cap >= item\n    \n    if np.any(valid_bins):\n      \n        # Prioritize bins where the item fills a larger percentage of the remaining space,\n        # but penalize bins that are left with very little space\n        fill_ratios = item / bins_remain_cap[valid_bins]\n        remaining_space = bins_remain_cap[valid_bins] - item\n        \n        # Apply a function that balances fill ratio and remaining space.  We want to favor bins with\n        # good fill ratios but avoid bins that would leave very little remaining space. A small value like 0.1 helps preventing log(0).\n        priorities[valid_bins] = fill_ratios - 0.5*np.log(remaining_space + 0.1)\n    \n    else:\n        # If no bin can fit the item, assign a very low priority (negative infinity) to all bins\n        priorities[:] = -np.inf\n        \n    return priorities",
    "response_id": 29,
    "obj": 4.048663741523748,
    "exec_success": true
  }
]