[
  {
    "stdout_filepath": "problem_iter2_response0.txt_stdout.txt",
    "code_path": "problem_iter2_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # 1. Feasibility check: Bin must have enough capacity.\n    feasible_bins = bins_remain_cap >= item\n    \n    # 2. If no bin is feasible, assign a very low priority to all bins.\n    if not np.any(feasible_bins):\n        return priorities - 1e9  # Return very low priority\n    \n    # 3. Calculate remaining capacity after placing the item (only for feasible bins).\n    remaining_capacities = bins_remain_cap - item\n    remaining_capacities[~feasible_bins] = -1  # Mark infeasible bins\n    \n    # 4. Calculate priority based on how full the bin would be after placement.\n    #    Prioritize bins that become fuller, but not too full.  We want a good fit, \n    #    but also want to avoid bins being too close to full to allow future placements\n    \n    # a. Fill ratio\n    fill_ratio = (bins_remain_cap - remaining_capacities) #Assume bin capacity is 1.0, no need to divide\n    \n    # b. Prioritize bins with a higher fill ratio, up to a point (e.g., 90% full).\n    priorities = fill_ratio\n\n    # c. Penalize bins that would be very full\n    very_full = remaining_capacities < 0.1\n    priorities[very_full & feasible_bins] -= 0.5 # Substantial penalty.\n\n    # d. Incentivize almost full, if possible\n    almost_full = (remaining_capacities >= 0.05) & (remaining_capacities < 0.1) & feasible_bins\n    priorities[almost_full] += 0.2\n    \n\n    # 5. Give infeasible bins very low priority.\n    priorities[~feasible_bins] = -1e9\n\n    return priorities",
    "response_id": 0,
    "obj": 5.534503390506582,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response1.txt_stdout.txt",
    "code_path": "problem_iter2_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Heuristic 1: Feasibility - Must fit\n    fit_mask = bins_remain_cap >= item\n    priorities[~fit_mask] = -np.inf  # Infeasible bins get -inf priority\n    priorities[fit_mask] += 1 #slight increase for being feasible.\n\n    # Heuristic 2: Best Fit - Minimize Waste\n    waste = bins_remain_cap - item\n    waste[~fit_mask] = np.inf #ignore bins where it doesn't fit for this\n    best_fit_idx = np.argmin(waste)\n    priorities[best_fit_idx] += 5  # Substantially prioritize best fit\n\n    # Heuristic 3: Fill Percentage - Prefer higher fill\n    fill_percentage = item / bins_remain_cap\n    fill_percentage[~fit_mask] = 0  # Set fill to 0 where it doesn't fit\n    priorities += fill_percentage * 2 #slight incentive\n\n    # Heuristic 4: Avoid Excessive Waste\n    large_waste_mask = bins_remain_cap > 2 * item\n    priorities[large_waste_mask] -= 1 #slight penalty\n\n    # Heuristic 5: Almost Full Bin - Strong Incentive\n    almost_full_mask = (waste >= 0) & (waste <= 0.1)\n    priorities[almost_full_mask] += 10  # Huge incentive for almost full\n\n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response2.txt_stdout.txt",
    "code_path": "problem_iter2_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Calculate remaining capacity after adding the item\n    remaining_after_add = bins_remain_cap - item\n\n    # Give high priority to bins where the item fits, prioritizing tighter fits.\n    fit_indices = remaining_after_add >= 0\n    priorities[fit_indices] = 1.0 / (remaining_after_add[fit_indices] + 0.00001)  # Avoid division by zero and prefer tighter fits\n\n    # Give a negative priority to bins where the item does not fit (discourage)\n    priorities[~fit_indices] = -np.inf\n\n    # Normalize the priorities to a range between 0 and 1. This can improve exploration.\n    valid_priorities = priorities[np.isfinite(priorities)]\n    if len(valid_priorities) > 0:\n        min_priority = np.min(valid_priorities)\n        max_priority = np.max(valid_priorities)\n        if max_priority > min_priority:\n            priorities[np.isfinite(priorities)] = (priorities[np.isfinite(priorities)] - min_priority) / (max_priority - min_priority)\n\n    return priorities",
    "response_id": 2,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response3.txt_stdout.txt",
    "code_path": "problem_iter2_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # 1. Infeasible bins get negative infinity priority.\n    cannot_fit = bins_remain_cap < item\n    priorities[cannot_fit] = -np.inf\n    \n    # 2. Calculate waste for feasible bins.\n    can_fit = bins_remain_cap >= item\n    \n    if np.any(can_fit): #Only do calculations if any bin can fit. Prevents division by zero.\n    \n        waste = bins_remain_cap[can_fit] - item\n\n        # 3. Prioritize minimal waste (negative waste for maximization).\n        priorities[can_fit] = -waste\n\n        # 4. Break ties by favoring smaller bins (adding a small negative term proportional to bin capacity).\n        priorities[can_fit] += -0.00000001 * bins_remain_cap[can_fit]\n    \n\n    return priorities",
    "response_id": 3,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response4.txt_stdout.txt",
    "code_path": "problem_iter2_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # First-Fit Decreasing inspired heuristic: Prioritize bins that can fit the item closely\n    # and avoid bins that are too large relative to the item size.\n\n    # 1. Bins that cannot fit the item get a very negative priority (discouraged)\n    cannot_fit = bins_remain_cap < item\n    priorities[cannot_fit] = -np.inf  # Very low priority\n\n    # 2. For bins that can fit the item:\n    can_fit = bins_remain_cap >= item\n\n    if np.any(can_fit):  # Only do calculations if any bin can fit. Prevents division by zero.\n\n        # Calculate the waste if the item is placed in each bin\n        waste = bins_remain_cap[can_fit] - item\n\n        # Prioritize the bins such that the waste is minimal (tighter fit is better)\n        priorities[can_fit] = -waste\n\n        # If multiple bins have the same amount of waste, then give priority to smaller bins\n        # This encourages bins with slightly smaller capacity to be utilized instead of leaving bigger bins open with capacity.\n        # Add a tiny bias to prioritize smaller bins, but only if they can fit.\n        priorities[can_fit] += -0.00000001 * bins_remain_cap[can_fit]\n\n\n    return priorities",
    "response_id": 4,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response5.txt_stdout.txt",
    "code_path": "problem_iter2_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Calculate remaining capacity after adding the item\n    remaining_after_add = bins_remain_cap - item\n\n    # Give high priority to bins where the item fits\n    fit_indices = remaining_after_add >= 0\n    \n    #Prioritize tighter fits by inverting the remaining capacity after adding. Add a small constant to avoid division by zero.\n    priorities[fit_indices] = 1.0 / (remaining_after_add[fit_indices] + 0.00001)  \n\n    # Give a very negative priority to bins where the item does not fit (discourage strongly)\n    priorities[~fit_indices] = -np.inf\n\n    # Normalize the priorities to scale between 0 and 1. Useful if there is a need to compare priorities across different item sizes.\n    valid_priorities = priorities[np.isfinite(priorities)]\n    if len(valid_priorities) > 0:\n        min_priority = np.min(valid_priorities)\n        max_priority = np.max(valid_priorities)\n        if max_priority > min_priority:\n            priorities[np.isfinite(priorities)] = (priorities[np.isfinite(priorities)] - min_priority) / (max_priority - min_priority)\n\n    return priorities",
    "response_id": 5,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response6.txt_stdout.txt",
    "code_path": "problem_iter2_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # 1. Feasibility: Remove infeasible bins immediately.\n    feasible_bins = bins_remain_cap >= item\n    priorities[~feasible_bins] = -np.inf  # Very low priority\n\n    # 2. Fill Ratio: Prioritize higher fill ratios.\n    fill_ratios = item / bins_remain_cap[feasible_bins]\n    priorities[feasible_bins] = fill_ratios\n\n    # 3. Waste Minimization (Tie-breaker): Slightly favor bins with less waste.\n    waste = bins_remain_cap[feasible_bins] - item\n    # Scale the waste inversely to the bin size. The smaller the bin, the more important minimizing waste is.\n    waste_penalty = -waste / bins_remain_cap[feasible_bins]\n    priorities[feasible_bins] += waste_penalty * 0.1\n\n    # 4. Randomness (Exploration): Add a small random value to break ties and encourage exploration.\n    priorities[feasible_bins] += np.random.rand(np.sum(feasible_bins)) * 0.001\n\n    return priorities",
    "response_id": 6,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response7.txt_stdout.txt",
    "code_path": "problem_iter2_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Give a high priority to bins that can accommodate the item.\n    feasible_bins = bins_remain_cap >= item\n    \n    if np.any(feasible_bins):\n        # Prioritize bins with tighter fit.\n        remaining_space = bins_remain_cap[feasible_bins] - item\n        priorities[feasible_bins] = 1 / (remaining_space + 1e-9) # avoid division by zero\n        \n        # Further prioritize bins where the item occupies a significant portion\n        # and doesn't leave much wasted space.\n        fill_ratios = item / bins_remain_cap[feasible_bins]\n        priorities[feasible_bins] += fill_ratios\n\n        # Penalize bins with high remaining capacity, to encourage packing into bins that are already somewhat full.\n        # The penalty is proportional to the remaining capacity beyond the item size.\n        # A higher factor means stronger penalty.\n        penalty_factor = 0.1 \n        excess_capacity = bins_remain_cap[feasible_bins] - item\n        priorities[feasible_bins] -= penalty_factor * excess_capacity\n    \n\n    # Optionally, penalize infeasible bins (though usually best to leave these at 0)\n    # priorities[~feasible_bins] = -1e9 # Very negative priority.\n\n    return priorities",
    "response_id": 7,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response8.txt_stdout.txt",
    "code_path": "problem_iter2_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Heuristic 1: Prefer bins that can fit the item (First-Fit Decreasing inspired)\n    fit_mask = bins_remain_cap >= item\n    priorities[fit_mask] += 1  # Give a base priority to bins that can fit\n    \n    # Heuristic 2: Reward bins with capacity closest to item size (Best-Fit inspired)\n    diff = bins_remain_cap - item\n    diff_fit = diff[fit_mask]\n    if len(diff_fit) > 0:\n        best_fit_idx = np.argmin(diff_fit)\n        indices = np.where(fit_mask)[0]\n        priorities[indices[best_fit_idx]] += 2  # Higher priority for the best fit\n    \n    # Heuristic 3: Penalize bins with very large remaining capacity. Prevents from filling one bin very slowly\n    large_cap_mask = bins_remain_cap > 2 * item\n    priorities[large_cap_mask] -= 0.5 #reduce their chance\n\n    #Heuristic 4: If the bin is almost full after adding the item give a huge incentive\n    almost_full_cap = bins_remain_cap - item\n    almost_full_mask = (almost_full_cap <= 0.1) & (almost_full_cap >= 0)\n    priorities[almost_full_mask] += 5 #high priority if we almost fill\n\n    #Heuristic 5: Do not pick a bin if the item doesn't fit\n    no_fit_mask = bins_remain_cap < item\n    priorities[no_fit_mask] = -np.inf # do not pick a bin that doens't fit\n\n    return priorities",
    "response_id": 8,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response9.txt_stdout.txt",
    "code_path": "problem_iter2_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Give higher priority to bins that can accommodate the item\n    valid_bins = bins_remain_cap >= item\n    \n    if np.any(valid_bins):\n      \n        # Prioritize bins where the item fills a larger percentage of the remaining space,\n        # but penalize bins that are left with very little space\n        fill_ratios = item / bins_remain_cap[valid_bins]\n        remaining_space = bins_remain_cap[valid_bins] - item\n        \n        # Apply a function that balances fill ratio and remaining space.  We want to favor bins with\n        # good fill ratios but avoid bins that would leave very little remaining space. A small value like 0.01 helps preventing log(0).\n        priorities[valid_bins] = fill_ratios - 0.25*np.log(remaining_space + 0.01)\n    \n    else:\n        # If no bin can fit the item, assign a very low priority (negative infinity) to all bins\n        priorities[:] = -np.inf\n        \n    return priorities",
    "response_id": 9,
    "obj": 4.048663741523748,
    "exec_success": true
  }
]