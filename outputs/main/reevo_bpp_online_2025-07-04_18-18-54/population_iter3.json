[
  {
    "stdout_filepath": "problem_iter2_response0.txt_stdout.txt",
    "code_path": "problem_iter2_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # 1. Feasibility check: Bin must have enough capacity.\n    feasible_bins = bins_remain_cap >= item\n    \n    # 2. If no bin is feasible, assign a very low priority to all bins.\n    if not np.any(feasible_bins):\n        return priorities - 1e9  # Return very low priority\n    \n    # 3. Calculate remaining capacity after placing the item (only for feasible bins).\n    remaining_capacities = bins_remain_cap - item\n    remaining_capacities[~feasible_bins] = -1  # Mark infeasible bins\n    \n    # 4. Calculate priority based on how full the bin would be after placement.\n    #    Prioritize bins that become fuller, but not too full.  We want a good fit, \n    #    but also want to avoid bins being too close to full to allow future placements\n    \n    # a. Fill ratio\n    fill_ratio = (bins_remain_cap - remaining_capacities) #Assume bin capacity is 1.0, no need to divide\n    \n    # b. Prioritize bins with a higher fill ratio, up to a point (e.g., 90% full).\n    priorities = fill_ratio\n\n    # c. Penalize bins that would be very full\n    very_full = remaining_capacities < 0.1\n    priorities[very_full & feasible_bins] -= 0.5 # Substantial penalty.\n\n    # d. Incentivize almost full, if possible\n    almost_full = (remaining_capacities >= 0.05) & (remaining_capacities < 0.1) & feasible_bins\n    priorities[almost_full] += 0.2\n    \n\n    # 5. Give infeasible bins very low priority.\n    priorities[~feasible_bins] = -1e9\n\n    return priorities",
    "response_id": 0,
    "obj": 5.534503390506582,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response1.txt_stdout.txt",
    "code_path": "problem_iter2_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Heuristic 1: Feasibility - Must fit\n    fit_mask = bins_remain_cap >= item\n    priorities[~fit_mask] = -np.inf  # Infeasible bins get -inf priority\n    priorities[fit_mask] += 1 #slight increase for being feasible.\n\n    # Heuristic 2: Best Fit - Minimize Waste\n    waste = bins_remain_cap - item\n    waste[~fit_mask] = np.inf #ignore bins where it doesn't fit for this\n    best_fit_idx = np.argmin(waste)\n    priorities[best_fit_idx] += 5  # Substantially prioritize best fit\n\n    # Heuristic 3: Fill Percentage - Prefer higher fill\n    fill_percentage = item / bins_remain_cap\n    fill_percentage[~fit_mask] = 0  # Set fill to 0 where it doesn't fit\n    priorities += fill_percentage * 2 #slight incentive\n\n    # Heuristic 4: Avoid Excessive Waste\n    large_waste_mask = bins_remain_cap > 2 * item\n    priorities[large_waste_mask] -= 1 #slight penalty\n\n    # Heuristic 5: Almost Full Bin - Strong Incentive\n    almost_full_mask = (waste >= 0) & (waste <= 0.1)\n    priorities[almost_full_mask] += 10  # Huge incentive for almost full\n\n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response2.txt_stdout.txt",
    "code_path": "problem_iter2_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Calculate remaining capacity after adding the item\n    remaining_after_add = bins_remain_cap - item\n\n    # Give high priority to bins where the item fits, prioritizing tighter fits.\n    fit_indices = remaining_after_add >= 0\n    priorities[fit_indices] = 1.0 / (remaining_after_add[fit_indices] + 0.00001)  # Avoid division by zero and prefer tighter fits\n\n    # Give a negative priority to bins where the item does not fit (discourage)\n    priorities[~fit_indices] = -np.inf\n\n    # Normalize the priorities to a range between 0 and 1. This can improve exploration.\n    valid_priorities = priorities[np.isfinite(priorities)]\n    if len(valid_priorities) > 0:\n        min_priority = np.min(valid_priorities)\n        max_priority = np.max(valid_priorities)\n        if max_priority > min_priority:\n            priorities[np.isfinite(priorities)] = (priorities[np.isfinite(priorities)] - min_priority) / (max_priority - min_priority)\n\n    return priorities",
    "response_id": 2,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response3.txt_stdout.txt",
    "code_path": "problem_iter2_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # 1. Infeasible bins get negative infinity priority.\n    cannot_fit = bins_remain_cap < item\n    priorities[cannot_fit] = -np.inf\n    \n    # 2. Calculate waste for feasible bins.\n    can_fit = bins_remain_cap >= item\n    \n    if np.any(can_fit): #Only do calculations if any bin can fit. Prevents division by zero.\n    \n        waste = bins_remain_cap[can_fit] - item\n\n        # 3. Prioritize minimal waste (negative waste for maximization).\n        priorities[can_fit] = -waste\n\n        # 4. Break ties by favoring smaller bins (adding a small negative term proportional to bin capacity).\n        priorities[can_fit] += -0.00000001 * bins_remain_cap[can_fit]\n    \n\n    return priorities",
    "response_id": 3,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response4.txt_stdout.txt",
    "code_path": "problem_iter2_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # First-Fit Decreasing inspired heuristic: Prioritize bins that can fit the item closely\n    # and avoid bins that are too large relative to the item size.\n\n    # 1. Bins that cannot fit the item get a very negative priority (discouraged)\n    cannot_fit = bins_remain_cap < item\n    priorities[cannot_fit] = -np.inf  # Very low priority\n\n    # 2. For bins that can fit the item:\n    can_fit = bins_remain_cap >= item\n\n    if np.any(can_fit):  # Only do calculations if any bin can fit. Prevents division by zero.\n\n        # Calculate the waste if the item is placed in each bin\n        waste = bins_remain_cap[can_fit] - item\n\n        # Prioritize the bins such that the waste is minimal (tighter fit is better)\n        priorities[can_fit] = -waste\n\n        # If multiple bins have the same amount of waste, then give priority to smaller bins\n        # This encourages bins with slightly smaller capacity to be utilized instead of leaving bigger bins open with capacity.\n        # Add a tiny bias to prioritize smaller bins, but only if they can fit.\n        priorities[can_fit] += -0.00000001 * bins_remain_cap[can_fit]\n\n\n    return priorities",
    "response_id": 4,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response5.txt_stdout.txt",
    "code_path": "problem_iter2_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Calculate remaining capacity after adding the item\n    remaining_after_add = bins_remain_cap - item\n\n    # Give high priority to bins where the item fits\n    fit_indices = remaining_after_add >= 0\n    \n    #Prioritize tighter fits by inverting the remaining capacity after adding. Add a small constant to avoid division by zero.\n    priorities[fit_indices] = 1.0 / (remaining_after_add[fit_indices] + 0.00001)  \n\n    # Give a very negative priority to bins where the item does not fit (discourage strongly)\n    priorities[~fit_indices] = -np.inf\n\n    # Normalize the priorities to scale between 0 and 1. Useful if there is a need to compare priorities across different item sizes.\n    valid_priorities = priorities[np.isfinite(priorities)]\n    if len(valid_priorities) > 0:\n        min_priority = np.min(valid_priorities)\n        max_priority = np.max(valid_priorities)\n        if max_priority > min_priority:\n            priorities[np.isfinite(priorities)] = (priorities[np.isfinite(priorities)] - min_priority) / (max_priority - min_priority)\n\n    return priorities",
    "response_id": 5,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response6.txt_stdout.txt",
    "code_path": "problem_iter2_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # 1. Feasibility: Remove infeasible bins immediately.\n    feasible_bins = bins_remain_cap >= item\n    priorities[~feasible_bins] = -np.inf  # Very low priority\n\n    # 2. Fill Ratio: Prioritize higher fill ratios.\n    fill_ratios = item / bins_remain_cap[feasible_bins]\n    priorities[feasible_bins] = fill_ratios\n\n    # 3. Waste Minimization (Tie-breaker): Slightly favor bins with less waste.\n    waste = bins_remain_cap[feasible_bins] - item\n    # Scale the waste inversely to the bin size. The smaller the bin, the more important minimizing waste is.\n    waste_penalty = -waste / bins_remain_cap[feasible_bins]\n    priorities[feasible_bins] += waste_penalty * 0.1\n\n    # 4. Randomness (Exploration): Add a small random value to break ties and encourage exploration.\n    priorities[feasible_bins] += np.random.rand(np.sum(feasible_bins)) * 0.001\n\n    return priorities",
    "response_id": 6,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response7.txt_stdout.txt",
    "code_path": "problem_iter2_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Give a high priority to bins that can accommodate the item.\n    feasible_bins = bins_remain_cap >= item\n    \n    if np.any(feasible_bins):\n        # Prioritize bins with tighter fit.\n        remaining_space = bins_remain_cap[feasible_bins] - item\n        priorities[feasible_bins] = 1 / (remaining_space + 1e-9) # avoid division by zero\n        \n        # Further prioritize bins where the item occupies a significant portion\n        # and doesn't leave much wasted space.\n        fill_ratios = item / bins_remain_cap[feasible_bins]\n        priorities[feasible_bins] += fill_ratios\n\n        # Penalize bins with high remaining capacity, to encourage packing into bins that are already somewhat full.\n        # The penalty is proportional to the remaining capacity beyond the item size.\n        # A higher factor means stronger penalty.\n        penalty_factor = 0.1 \n        excess_capacity = bins_remain_cap[feasible_bins] - item\n        priorities[feasible_bins] -= penalty_factor * excess_capacity\n    \n\n    # Optionally, penalize infeasible bins (though usually best to leave these at 0)\n    # priorities[~feasible_bins] = -1e9 # Very negative priority.\n\n    return priorities",
    "response_id": 7,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response8.txt_stdout.txt",
    "code_path": "problem_iter2_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Heuristic 1: Prefer bins that can fit the item (First-Fit Decreasing inspired)\n    fit_mask = bins_remain_cap >= item\n    priorities[fit_mask] += 1  # Give a base priority to bins that can fit\n    \n    # Heuristic 2: Reward bins with capacity closest to item size (Best-Fit inspired)\n    diff = bins_remain_cap - item\n    diff_fit = diff[fit_mask]\n    if len(diff_fit) > 0:\n        best_fit_idx = np.argmin(diff_fit)\n        indices = np.where(fit_mask)[0]\n        priorities[indices[best_fit_idx]] += 2  # Higher priority for the best fit\n    \n    # Heuristic 3: Penalize bins with very large remaining capacity. Prevents from filling one bin very slowly\n    large_cap_mask = bins_remain_cap > 2 * item\n    priorities[large_cap_mask] -= 0.5 #reduce their chance\n\n    #Heuristic 4: If the bin is almost full after adding the item give a huge incentive\n    almost_full_cap = bins_remain_cap - item\n    almost_full_mask = (almost_full_cap <= 0.1) & (almost_full_cap >= 0)\n    priorities[almost_full_mask] += 5 #high priority if we almost fill\n\n    #Heuristic 5: Do not pick a bin if the item doesn't fit\n    no_fit_mask = bins_remain_cap < item\n    priorities[no_fit_mask] = -np.inf # do not pick a bin that doens't fit\n\n    return priorities",
    "response_id": 8,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response9.txt_stdout.txt",
    "code_path": "problem_iter2_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Give higher priority to bins that can accommodate the item\n    valid_bins = bins_remain_cap >= item\n    \n    if np.any(valid_bins):\n      \n        # Prioritize bins where the item fills a larger percentage of the remaining space,\n        # but penalize bins that are left with very little space\n        fill_ratios = item / bins_remain_cap[valid_bins]\n        remaining_space = bins_remain_cap[valid_bins] - item\n        \n        # Apply a function that balances fill ratio and remaining space.  We want to favor bins with\n        # good fill ratios but avoid bins that would leave very little remaining space. A small value like 0.01 helps preventing log(0).\n        priorities[valid_bins] = fill_ratios - 0.25*np.log(remaining_space + 0.01)\n    \n    else:\n        # If no bin can fit the item, assign a very low priority (negative infinity) to all bins\n        priorities[:] = -np.inf\n        \n    return priorities",
    "response_id": 9,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response0.txt_stdout.txt",
    "code_path": "problem_iter3_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_size = 1.0  # Assuming bin size is 1, can be parameterized\n\n    # 1. Feasibility: Strongly penalize bins that cannot fit the item\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] = -1e9  # Very low priority\n\n    # 2. Fill Ratio: Prioritize bins with higher fill ratio *after* packing\n    remaining_after_pack = bins_remain_cap - item\n    fill_ratio_after_pack = (bin_size - remaining_after_pack) / bin_size\n    fill_ratio_after_pack[infeasible_mask] = 0  # Zero fill for infeasible bins\n\n    priorities += fill_ratio_after_pack\n\n    # 3. Tight Fit: Reward bins where the remaining capacity after packing is small\n    #    but avoid bins that are nearly full to prevent fragmentation.\n    \n    fit_mask = bins_remain_cap >= item\n    remaining_capacity_after_pack = bins_remain_cap - item\n    remaining_capacity_after_pack[~fit_mask] = 1e9 #large number\n\n    tight_fit_bonus = np.exp(-5 * remaining_capacity_after_pack)  # Exponential decay\n    priorities += tight_fit_bonus\n    \n    almost_full_mask = (remaining_capacity_after_pack > 0) & (remaining_capacity_after_pack <= 0.1)\n    priorities[almost_full_mask] += 1 #small benefit\n    \n    # 4. Logarithmic Penalty for Near-Full Bins: Discourage bins close to full to avoid future problems\n    near_full_mask = (bins_remain_cap > item) & (bins_remain_cap - item < 0.2)  # Adjust threshold as needed\n\n    priorities[near_full_mask] -= 0.2 * np.log(1 / (bins_remain_cap[near_full_mask] - item + 0.0001)) #small log penalty\n\n    # 5. Normalization: Scale priorities to a reasonable range (e.g., 0 to 10)\n    min_priority = np.min(priorities)\n    max_priority = np.max(priorities)\n\n    if max_priority > min_priority:\n        priorities = 10 * (priorities - min_priority) / (max_priority - min_priority)\n\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response1.txt_stdout.txt",
    "code_path": "problem_iter3_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility check: Strongly penalize infeasible bins\n    feasible_bins = bins_remain_cap >= item\n    priorities[~feasible_bins] = -1e9  # Very low priority for infeasible bins\n\n    # 2. Fill ratio: Encourage filling bins (higher ratio is better)\n    fill_ratio = (bins_remain_cap - item) / bins_remain_cap\n    fill_ratio[~feasible_bins] = -1  # Set to -1 to avoid influencing infeasible bins\n\n    # 3. Tight fit: Reward bins with remaining capacity close to zero after adding the item\n    remaining_space = bins_remain_cap - item\n    tight_fit_score = np.exp(-10 * remaining_space) # Exponential decay for bins with larger remaining cap\n    tight_fit_score[~feasible_bins] = 0\n\n    # 4. Avoid near-full bins: Logarithmic penalty to discourage almost full bins\n    almost_full = (remaining_space > 0) & (remaining_space <= 0.1)\n    almost_full_penalty = np.zeros_like(bins_remain_cap)\n    almost_full_penalty[almost_full] = -np.log(0.1 - remaining_space[almost_full] + 0.001)\n    \n    # 5. Combine and normalize priorities\n    priorities = fill_ratio + 0.5 * tight_fit_score + almost_full_penalty\n    \n    # Normalize to scale the priorities between 0 and 1. This helps in exploration\n    if np.max(priorities) > np.min(priorities):\n      priorities = (priorities - np.min(priorities)) / (np.max(priorities) - np.min(priorities))\n    else:\n      priorities = np.zeros_like(bins_remain_cap)  # All bins have same priority\n\n    return priorities",
    "response_id": 1,
    "obj": 88.08336657359393,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response2.txt_stdout.txt",
    "code_path": "problem_iter3_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_size = 1.0  # Assuming bin size is 1, or determine dynamically if needed\n\n    # Heuristic 1: Infeasibility Penalty\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] = -1e9  # Huge penalty for infeasibility\n\n    # Heuristic 2: Fill Ratio (Balance utilization)\n    fill_ratio = (bin_size - bins_remain_cap) / bin_size\n    priorities += fill_ratio\n\n    # Heuristic 3: Tight Fit Reward (Best-Fit inspired)\n    remaining_space = bins_remain_cap - item\n    fit_mask = remaining_space >= 0\n    if np.any(fit_mask):\n        priorities[fit_mask] += 1.0 / (remaining_space[fit_mask] + 0.0001)  # Closer fit gets higher priority\n\n    # Heuristic 4: Near-Full Bin Penalty (Avoid near-full, but not completely full)\n    near_full_threshold = 0.1 * bin_size\n    near_full_mask = (remaining_space > 0) & (remaining_space <= near_full_threshold)\n    priorities[near_full_mask] -= 2.0 * np.log(near_full_threshold - remaining_space[near_full_mask] + 0.0001) # Stronger penalty\n\n    # Heuristic 5: Normalization (for exploration and finer control)\n    priorities = (priorities - np.min(priorities)) / (np.max(priorities) - np.min(priorities) + 0.0001)\n\n    return priorities",
    "response_id": 2,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response3.txt_stdout.txt",
    "code_path": "problem_iter3_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_size = 1.0 # Assuming bin size of 1\n\n    # Feasibility check: Hard constraint - invalidates bins that can't fit item.\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] = -np.inf\n\n    # 1. Fill Ratio Prioritization: Encourages higher fill ratios.\n    fill_ratio = (bin_size - bins_remain_cap) / bin_size  # Existing fill ratio\n    new_fill_ratio_if_added = (bin_size - (bins_remain_cap - item)) / bin_size\n    \n    # Prioritize higher fill ratios after adding the item\n    priorities += 2 * new_fill_ratio_if_added\n    \n    # 2. Tight Fit Bonus: Prioritize bins where the item fits snugly.\n    remaining_space = bins_remain_cap - item\n    fit_mask = bins_remain_cap >= item\n    \n    if np.any(fit_mask):\n        min_waste = np.min(remaining_space[fit_mask])\n        tight_fit_bonus = np.exp(-5 * (remaining_space / min_waste))  # Exponential decay\n        priorities[fit_mask] += tight_fit_bonus[fit_mask]\n        \n    # 3. Near-Full Penalty: Discourage filling bins too close to capacity.\n    near_full_threshold = 0.95 * bin_size\n    near_full_mask = (bins_remain_cap - item) < (bin_size - near_full_threshold)  #Check if after adding we go above threshold\n\n    priorities[near_full_mask] -= 3 # Strong penalty if adding this gets us near full\n        \n    # Normalize the Priorities:\n    if np.any(priorities != -np.inf): # only normalise if a feasible bin exists.\n        max_priority = np.max(priorities[priorities != -np.inf])\n        min_priority = np.min(priorities[priorities != -np.inf])\n        if max_priority > min_priority:\n            priorities[priorities != -np.inf] = (priorities[priorities != -np.inf] - min_priority) / (max_priority - min_priority)\n        else:\n            priorities[priorities != -np.inf] = 0.5 # if all priorities equal give them same weighting.\n    else:\n        priorities = -1*np.ones_like(bins_remain_cap)\n        \n    return priorities",
    "response_id": 3,
    "obj": 4.357798165137619,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response4.txt_stdout.txt",
    "code_path": "problem_iter3_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_size = 1 # Assume bin size is 1, can be passed as argument if variable\n\n    # Heuristic 1: Fill ratio - balance utilization\n    fill_ratio = (bin_size - bins_remain_cap) / bin_size\n    priorities += fill_ratio\n\n    # Heuristic 2: Tight fit - prioritize bins where item fits snugly\n    remaining_after_fit = bins_remain_cap - item\n    fit_mask = remaining_after_fit >= 0\n    if np.any(fit_mask):\n      priorities[fit_mask] += np.exp(-5 * remaining_after_fit[fit_mask])  # Exponential decay for tighter fits\n\n    # Heuristic 3: Penalize near-full bins (but not yet full) to avoid creating very fragmented bins\n    near_full_threshold = 0.1  # Adjust this threshold as needed\n    near_full_mask = (bins_remain_cap > item) & (remaining_after_fit <= near_full_threshold)\n    priorities[near_full_mask] -= 2 * np.log(1 / (remaining_after_fit[near_full_mask] + 0.01))   # Logarithmic penalty\n\n    # Heuristic 4: Strong penalty for infeasibility\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] -= 1000  # Huge negative priority\n\n    # Heuristic 5: Normalize priorities to range [0, 1] for stability and exploration\n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n\n    if max_priority > min_priority:\n        priorities = (priorities - min_priority) / (max_priority - min_priority)\n    else: # all values are equal, set to zero\n        priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    return priorities",
    "response_id": 4,
    "obj": 4.048663741523748,
    "exec_success": true
  }
]