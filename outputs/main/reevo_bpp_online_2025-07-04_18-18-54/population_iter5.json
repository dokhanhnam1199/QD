[
  {
    "stdout_filepath": "problem_iter4_response0.txt_stdout.txt",
    "code_path": "problem_iter4_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: Remove infeasible bins immediately.\n    feasible_bins = bins_remain_cap >= item\n    priorities[~feasible_bins] = -np.inf  # Very low priority\n\n    # 2. Fill Ratio: Prioritize higher fill ratios, but only for feasible bins.\n    if np.any(feasible_bins):\n        fill_ratios = item / bins_remain_cap[feasible_bins]\n        priorities[feasible_bins] = fill_ratios\n\n        # 3. Waste Minimization (Tie-breaker): Slightly favor bins with less waste.\n        waste = bins_remain_cap[feasible_bins] - item\n        # Scale the waste inversely to the bin size. The smaller the bin, the more important minimizing waste is.\n        waste_penalty = -waste / bins_remain_cap[feasible_bins]\n        priorities[feasible_bins] += waste_penalty * 0.1\n\n        # 4. Randomness (Exploration): Add a small random value to break ties and encourage exploration.\n        priorities[feasible_bins] += np.random.rand(np.sum(feasible_bins)) * 0.001\n\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response1.txt_stdout.txt",
    "code_path": "problem_iter4_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Calculate remaining capacity after adding the item\n    remaining_after_add = bins_remain_cap - item\n\n    # Give high priority to bins where the item fits\n    fit_indices = remaining_after_add >= 0\n\n    # Prioritize tighter fits by inverting the remaining capacity after adding.\n    # Add a small constant to avoid division by zero. Also, apply a scaling factor.\n    priorities[fit_indices] = 1.0 / (0.00001 + remaining_after_add[fit_indices])\n\n    # Give a very negative priority to bins where the item does not fit (discourage strongly)\n    priorities[~fit_indices] = -np.inf\n\n    # Normalize the priorities to scale between 0 and 1.\n    valid_priorities = priorities[np.isfinite(priorities)]\n    if len(valid_priorities) > 0:\n        min_priority = np.min(valid_priorities)\n        max_priority = np.max(valid_priorities)\n        if max_priority > min_priority:\n            priorities[np.isfinite(priorities)] = (priorities[np.isfinite(priorities)] - min_priority) / (max_priority - min_priority)\n\n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response2.txt_stdout.txt",
    "code_path": "problem_iter4_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_size = 1.0  # Assuming bin size is 1, can be parameterized\n\n    # 1. Feasibility: Strongly penalize bins that cannot fit the item\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] = -1e9  # Very low priority\n\n    # 2. Fill Ratio: Prioritize bins with higher fill ratio *after* packing\n    remaining_after_pack = bins_remain_cap - item\n    fill_ratio_after_pack = (bin_size - remaining_after_pack) / bin_size\n    fill_ratio_after_pack[infeasible_mask] = 0  # Zero fill for infeasible bins\n\n    priorities += fill_ratio_after_pack\n\n    # 3. Tight Fit: Reward bins where the remaining capacity after packing is small\n    #    but avoid bins that are nearly full to prevent fragmentation.\n    \n    fit_mask = bins_remain_cap >= item\n    remaining_capacity_after_pack = bins_remain_cap - item\n    remaining_capacity_after_pack[~fit_mask] = 1e9 #large number\n\n    tight_fit_bonus = np.exp(-10 * remaining_capacity_after_pack)  # Stronger Exponential decay\n    priorities += tight_fit_bonus\n    \n    almost_full_mask = (remaining_capacity_after_pack > 0) & (remaining_capacity_after_pack <= 0.1)\n    priorities[almost_full_mask] += 0.5 # Slightly larger benefit\n\n    # 4. Logarithmic Penalty for Near-Full Bins: Discourage bins close to full to avoid future problems\n    near_full_mask = (bins_remain_cap > item) & (bins_remain_cap - item < 0.2)  # Adjust threshold as needed\n\n    priorities[near_full_mask] -= 0.5 * np.log(1 / (bins_remain_cap[near_full_mask] - item + 0.0001)) # Larger log penalty\n\n    # 5. Introduce a bin utilization bonus.  Favor bins that are already somewhat filled.\n    utilization = (bin_size - bins_remain_cap) / bin_size\n    utilized_mask = bins_remain_cap < bin_size\n    priorities[utilized_mask] += 0.1 * utilization[utilized_mask]\n\n\n    # 6. Normalization: Scale priorities to a reasonable range (e.g., 0 to 10)\n    min_priority = np.min(priorities)\n    max_priority = np.max(priorities)\n\n    if max_priority > min_priority:\n        priorities = 10 * (priorities - min_priority) / (max_priority - min_priority)\n\n    return priorities",
    "response_id": 2,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response3.txt_stdout.txt",
    "code_path": "problem_iter4_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility check: Strongly penalize infeasible bins\n    cannot_fit = bins_remain_cap < item\n    priorities[cannot_fit] = -np.inf\n\n    # 2. Prioritize tight fits for feasible bins\n    can_fit = bins_remain_cap >= item\n    if np.any(can_fit):\n        waste = bins_remain_cap[can_fit] - item\n        priorities[can_fit] = -waste\n\n        # Break ties by prioritizing smaller bins (avoid leaving large gaps)\n        priorities[can_fit] -= 0.00000001 * bins_remain_cap[can_fit]\n\n    return priorities",
    "response_id": 3,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response4.txt_stdout.txt",
    "code_path": "problem_iter4_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: Infeasible bins get -inf priority\n    feasible_bins = bins_remain_cap >= item\n    priorities[~feasible_bins] = -np.inf\n\n    # 2. Best-Fit: Prioritize bins with the smallest remaining capacity after adding the item\n    remaining_capacity = bins_remain_cap - item\n    # Only consider feasible bins for best-fit calculation\n    remaining_capacity[~feasible_bins] = np.inf  # set infeasible bins to infinity for argmin\n\n    best_fit_index = np.argmin(remaining_capacity)\n    if np.isfinite(remaining_capacity[best_fit_index]):  # Check if a feasible bin exists\n        priorities[best_fit_index] += 3  # Give a high priority boost\n\n    # 3. Fill-Level: Give a bonus to bins that are filled to a good level.\n    fill_level = 1 - remaining_capacity / bins_remain_cap\n    # Apply only to feasible bins\n    fill_level[~feasible_bins] = 0\n\n    # Reward fill levels between 0.7 and 0.9\n    good_fill = (fill_level >= 0.7) & (fill_level <= 0.9)\n    priorities[good_fill] += 2  # Medium priority boost\n\n    # 4. Avoid Overfilling: Penalize bins that are close to being full after adding the item\n    almost_full = (remaining_capacity > 0) & (remaining_capacity <= 0.1)\n    priorities[almost_full] -= 1 # Small penalty\n\n    # 5. Penalize Large Remaining Capacity: Discourage bins with large remaining capacity\n    large_capacity = bins_remain_cap > 2 * item\n    priorities[large_capacity] -= 0.5  # Small penalty for large capacity\n\n    return priorities",
    "response_id": 4,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response5.txt_stdout.txt",
    "code_path": "problem_iter4_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Infeasible bins get negative infinity priority.\n    cannot_fit = bins_remain_cap < item\n    priorities[cannot_fit] = -np.inf\n\n    # 2. Calculate waste for feasible bins.\n    can_fit = bins_remain_cap >= item\n\n    if np.any(can_fit):\n        waste = bins_remain_cap[can_fit] - item\n\n        # 3. Prioritize minimal waste (negative waste for maximization).\n        priorities[can_fit] = -waste\n\n        # 4. Break ties by favoring bins with smaller initial remaining capacity.\n        # This encourages filling up bins that were already somewhat full.\n        priorities[can_fit] += -0.000001 * bins_remain_cap[can_fit]\n\n    return priorities",
    "response_id": 5,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response6.txt_stdout.txt",
    "code_path": "problem_iter4_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_size = 1.0  # Assuming bin size is 1, can be parameterized\n\n    # 1. Feasibility: Strongly penalize bins that cannot fit the item\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] = -1e9  # Very low priority\n\n    # 2. Fill Ratio: Prioritize bins with higher fill ratio *after* packing\n    remaining_after_pack = bins_remain_cap - item\n    fill_ratio_after_pack = (bin_size - remaining_after_pack) / bin_size\n    fill_ratio_after_pack[infeasible_mask] = 0  # Zero fill for infeasible bins\n\n    priorities += 2 * fill_ratio_after_pack\n\n    # 3. Tight Fit: Reward bins where the remaining capacity after packing is small\n    #    but avoid bins that are nearly full to prevent fragmentation.\n\n    remaining_capacity_after_pack = np.copy(bins_remain_cap)\n    remaining_capacity_after_pack[infeasible_mask] = 1  # Set to 1 to avoid division by zero\n\n    tight_fit_bonus = np.exp(-5 * np.abs(remaining_after_pack))  # Exponential decay\n    tight_fit_bonus[infeasible_mask] = 0\n\n    priorities += tight_fit_bonus\n\n    # 4. Logarithmic Penalty for Near-Full Bins: Discourage bins close to full to avoid future problems\n    near_full_threshold = 0.2 * bin_size\n    near_full_mask = (bins_remain_cap >= item) & (remaining_after_pack <= near_full_threshold)  # Adjust threshold as needed\n\n    priorities[near_full_mask] -= np.log(near_full_threshold - remaining_after_pack[near_full_mask] + 0.0001)\n\n    return priorities",
    "response_id": 6,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response7.txt_stdout.txt",
    "code_path": "problem_iter4_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility check: Bin must have enough capacity.\n    feasible_bins = bins_remain_cap >= item\n\n    # 2. If no bin is feasible, assign a very low priority to all bins.\n    if not np.any(feasible_bins):\n        return priorities - 1e9  # Return very low priority\n\n    # 3. Calculate remaining capacity after placing the item (only for feasible bins).\n    remaining_capacities = bins_remain_cap - item\n    remaining_capacities[~feasible_bins] = -1  # Mark infeasible bins\n\n    # 4. Calculate priority based on how full the bin would be after placement.\n    #    Prioritize bins that become fuller, but not too full.  We want a good fit,\n    #    but also want to avoid bins being too close to full to allow future placements\n\n    # a. Fill ratio\n    fill_ratio = item # Directly use item size as fill ratio since bin capacity is assumed to be 1\n\n    # b. Prioritize bins with a higher fill ratio.\n    priorities = fill_ratio\n\n    # c. Penalize bins that would be very full\n    very_full = remaining_capacities < 0.1\n    priorities[very_full & feasible_bins] -= 0.5  # Substantial penalty.\n\n    # d. Incentivize almost full, if possible\n    almost_full = (remaining_capacities >= 0.05) & (remaining_capacities < 0.1) & feasible_bins\n    priorities[almost_full] += 0.2\n\n    # 5. Give infeasible bins very low priority.\n    priorities[~feasible_bins] = -1e9\n\n    return priorities",
    "response_id": 7,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 38, in priority_v2\nIndexError: invalid index to scalar variable.\n"
  },
  {
    "stdout_filepath": "problem_iter4_response8.txt_stdout.txt",
    "code_path": "problem_iter4_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Infeasible bins get negative infinity priority.\n    cannot_fit = bins_remain_cap < item\n    priorities[cannot_fit] = -np.inf\n\n    # 2. Calculate waste for feasible bins.\n    can_fit = bins_remain_cap >= item\n\n    if np.any(can_fit):  # Only do calculations if any bin can fit.\n\n        waste = bins_remain_cap[can_fit] - item\n\n        # 3. Prioritize minimal waste (negative waste for maximization).\n        priorities[can_fit] = -waste\n\n        # 4. Break ties by favoring bins with higher fill ratio *after* adding the item\n        new_fill_ratios = (bins_remain_cap[can_fit] + item - waste) / (bins_remain_cap[can_fit] + item)\n        priorities[can_fit] += new_fill_ratios * 0.000001 # Add a very small bonus favoring higher fill ratios\n        #This breaks ties, uses fill ratio, and avoids explicitly referencing bin size.\n\n\n    return priorities",
    "response_id": 8,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response9.txt_stdout.txt",
    "code_path": "problem_iter4_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Identify bins that can accommodate the item.\n    feasible_bins = bins_remain_cap >= item\n    \n    if np.any(feasible_bins):\n        # TIGHT FIT: Prioritize bins with tighter fit.  Smaller remaining space is better.\n        remaining_space = bins_remain_cap[feasible_bins] - item\n        priorities[feasible_bins] += 1.0 / (remaining_space + 1e-9)  # Avoid division by zero\n\n        # FILL RATIO: Prioritize higher fill ratios (item size relative to bin capacity).\n        fill_ratios = item / bins_remain_cap[feasible_bins]\n        priorities[feasible_bins] += fill_ratios\n\n        # PENALIZE EXCESS CAPACITY: Discourage large remaining capacity after adding the item.\n        # Penalty is proportional to the *squared* excess capacity for stronger discouragement.\n        excess_capacity = bins_remain_cap[feasible_bins] - item\n        penalty_factor = 0.5  # Adjust as needed; higher values increase the penalty.\n        priorities[feasible_bins] -= penalty_factor * (excess_capacity**2)\n\n    return priorities",
    "response_id": 9,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response0.txt_stdout.txt",
    "code_path": "problem_iter5_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Feasibility: Highest priority for bins that can fit.\n    fit_mask = bins_remain_cap >= item\n    priorities[fit_mask] += 10\n\n    # Tight-Fit Bonus: Prioritize bins where the item fits snugly.\n    remaining_after_fit = bins_remain_cap[fit_mask] - item\n    tight_fit_bonus = np.exp(-10 * remaining_after_fit / item)  # Exponential decay of bonus\n    priorities[fit_mask] += tight_fit_bonus\n\n    # Waste Minimization: Slightly penalize bins with large remaining capacity after placement.\n    waste_penalty = np.maximum(0, (bins_remain_cap - item - 0.2*item)/(0.8)) #if remaining cap > threshold penalty increases\n    priorities[fit_mask] -= waste_penalty[fit_mask] * 0.5\n\n    # Near-Full Penalty: Discourage filling bins that are nearly full (might strand future larger items).\n    near_full_threshold = 0.1 #avoid making bins less than 10% full\n    near_full_mask = (bins_remain_cap < (item + near_full_threshold)) & fit_mask\n    priorities[near_full_mask] -= 2\n\n    #Hard Constraint: If it doesn't fit, ensure it's heavily penalized.\n    no_fit_mask = bins_remain_cap < item\n    priorities[no_fit_mask] -= 100\n\n    return priorities",
    "response_id": 0,
    "obj": 4.696848823294789,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response1.txt_stdout.txt",
    "code_path": "problem_iter5_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Heuristic 1: Feasibility - Prioritize bins that can fit the item\n    fit_mask = bins_remain_cap >= item\n    priorities[fit_mask] += 1\n    \n    # Heuristic 2: Tight-Fit Bonus - Higher reward for tighter fits\n    remaining_after_fit = bins_remain_cap - item\n    tight_fit_bonus = np.exp(-10 * remaining_after_fit) # Exponentially decaying bonus\n    tight_fit_bonus[~fit_mask] = 0 # No bonus for bins that don't fit\n    priorities += tight_fit_bonus\n    \n    # Heuristic 3: Near-Full Penalty - Discourage almost-full bins (but only if they still fit!)\n    near_full_threshold = 0.1 #Bins with remaining cap less than 0.1 are near full after adding item\n    almost_full_cap = bins_remain_cap - item\n    near_full_mask = (almost_full_cap <= near_full_threshold) & fit_mask & (almost_full_cap>=0)\n    priorities[near_full_mask] -= 3 # Penalty for bins near full\n\n    # Heuristic 4: Excessive Capacity Penalty - Avoid leaving bins with excessive space\n    excessive_cap_threshold = 2 * item\n    excessive_cap_mask = bins_remain_cap > excessive_cap_threshold\n    priorities[excessive_cap_mask] -= 0.5\n\n    # Heuristic 5: Infeasibility Penalty - Avoid picking bins that can't fit\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] -= 100\n    \n    return priorities",
    "response_id": 1,
    "obj": 5.185480654168329,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response2.txt_stdout.txt",
    "code_path": "problem_iter5_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Heuristic 1: Prefer bins that can fit the item (First-Fit Decreasing inspired)\n    fit_mask = bins_remain_cap >= item\n    priorities[fit_mask] += 1  # Give a base priority to bins that can fit\n    \n    # Heuristic 2: Reward bins with capacity closest to item size (Best-Fit inspired)\n    diff = bins_remain_cap - item\n    diff_fit = diff[fit_mask]\n    if len(diff_fit) > 0:\n        best_fit_idx = np.argmin(diff_fit)\n        indices = np.where(fit_mask)[0]\n        priorities[indices[best_fit_idx]] += 3  # Higher priority for the best fit\n    \n    # Heuristic 3: Penalize bins with very large remaining capacity. Prevents from filling one bin very slowly\n    large_cap_mask = bins_remain_cap > 1.5 * item # Adaptive Threshold\n    priorities[large_cap_mask] -= 0.75 #reduce their chance, increased penalty\n\n    #Heuristic 4: If the bin is almost full after adding the item give a huge incentive (Tight-Fit Bonus)\n    almost_full_cap = bins_remain_cap - item\n    almost_full_mask = (almost_full_cap <= 0.1) & (almost_full_cap >= 0)\n    priorities[almost_full_mask] += 7 #high priority if we almost fill, increased bonus\n\n    #Heuristic 5: Do not pick a bin if the item doesn't fit\n    no_fit_mask = bins_remain_cap < item\n    priorities[no_fit_mask] -= 100 # do not pick a bin that doens't fit\n\n    #Heuristic 6: Further penalize bins that are near-full before adding item (Waste Minimization)\n    near_full_mask = (bins_remain_cap > item) & (bins_remain_cap < item + 0.2)\n    priorities[near_full_mask] -= 2\n\n    return priorities",
    "response_id": 2,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response3.txt_stdout.txt",
    "code_path": "problem_iter5_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Heuristic 1: Feasibility - Must fit\n    fit_mask = bins_remain_cap >= item\n    priorities[~fit_mask] -= 1000  # Large penalty for infeasibility\n    priorities[fit_mask] += 1 #base priority\n\n    # Heuristic 2: Waste Minimization - Tight Fit Bonus\n    remaining_after_fit = bins_remain_cap[fit_mask] - item\n    tight_fit_threshold = 0.2 * item  # Adaptive threshold: prefer tighter fits relative to item size\n    tight_fit_mask = remaining_after_fit <= tight_fit_threshold\n    indices = np.where(fit_mask)[0]\n    priorities[indices[tight_fit_mask]] += 5  # Significant bonus for tight fits\n\n    # Heuristic 3: Penalize Near-Full Bins (but allow if very tight)\n    nearly_full_threshold = 0.1  # Fixed threshold: if capacity is very low\n    nearly_full_mask = (bins_remain_cap <= nearly_full_threshold) & fit_mask\n    priorities[nearly_full_mask] -= 2\n\n    # Heuristic 4: Penalize Excessive Remaining Capacity\n    excessive_capacity_threshold = 2 * item #adaptive threshold\n    excessive_capacity_mask = bins_remain_cap > excessive_capacity_threshold\n    priorities[excessive_capacity_mask] -= 0.5\n\n    # Heuristic 5: Best fit inside feasible bins\n    diff = bins_remain_cap - item\n    diff_fit = diff[fit_mask]\n    if len(diff_fit) > 0:\n        best_fit_idx = np.argmin(diff_fit)\n        indices = np.where(fit_mask)[0]\n        priorities[indices[best_fit_idx]] += 2  # Higher priority for the best fit\n        \n    return priorities",
    "response_id": 3,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response4.txt_stdout.txt",
    "code_path": "problem_iter5_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Feasibility: Must fit\n    fit_mask = bins_remain_cap >= item\n    priorities[~fit_mask] = -np.inf  # Absolutely avoid bins that don't fit\n\n    # Tight-Fit Bonus: Reward bins with small remaining capacity after placement.\n    remaining_after_fit = bins_remain_cap[fit_mask] - item\n    \n    # Avoid division by zero by adding small value to avoid division by zero.\n    priorities[fit_mask] += np.exp(-remaining_after_fit / (item + 1e-6))\n\n    # Waste Minimization: Penalize excessive remaining capacity\n    avg_cap = np.mean(bins_remain_cap)\n    excess_mask = bins_remain_cap > (avg_cap + item / 2)\n    priorities[excess_mask] -= 0.2\n\n    # Near-Full Penalty: Discourage almost-full bins (risk of small items later)\n    almost_full_threshold = 0.95\n    almost_full_mask = (bins_remain_cap < item * (1 / almost_full_threshold)) & fit_mask\n    priorities[almost_full_mask] -= 0.1  # Small penalty\n    \n    return priorities",
    "response_id": 4,
    "obj": 4.4674910251296325,
    "exec_success": true
  }
]