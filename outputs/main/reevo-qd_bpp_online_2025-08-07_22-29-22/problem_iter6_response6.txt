```python
import numpy as np

def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    *,
    steepness: float = 12.0,
    tolerance: float = 0.10,
    eps_noise: float = 1e-8,
) -> np.ndarray:
    """
    Compute a sigmoid‑based priority for placing `item` into each bin.

    The score favours bins that will have a small residual capacity after the
    placement (tight fit).  Residual capacity is normalised by an estimate of
    the bin capacity and passed through a logistic (sigmoid) function.
    Infeasible bins receive ``-np.inf`` so they are never selected.

    A tiny deterministic tie‑breaker proportional to the bin index is added
    to break exact ties without materially affecting the ordering.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of the current bins.
    steepness : float, optional
        Controls the sharpness of the sigmoid transition.
    tolerance : float, optional
        Desired maximal leftover fraction of the (estimated) bin capacity.
    eps_noise : float, optional
        Amplitude of the deterministic tie‑breaker added to each feasible bin.

    Returns
    -------
    np.ndarray
        Priority scores for each bin (same shape as ``bins_remain_cap``).
    """
    # Ensure a 1‑D float array for vectorised operations.
    caps = np.asarray(bins_remain_cap, dtype=float).ravel()

    # Residual capacity after (theoretically) placing the item.
    residual = caps - item

    # Feasibility mask: bins where the item fits.
    feasible = residual >= 0.0

    # If no bin can accommodate the item, return -inf for all.
    if not np.any(feasible):
        return np.full_like(caps, -np.inf, dtype=float)

    # Estimate the original bin capacity.
    # Adding the item guarantees that an empty bin (full capacity) yields
    # an estimate close to the true capacity.
    est_capacity = caps.max() + item

    # Normalised residual (fraction of capacity left after placement).
    # Clip to [0, 1] for numerical stability.
    norm_residual = np.clip(residual / est_capacity, 0.0, 1.0)

    # Initialise all scores to -inf (infeasible).
    scores = np.full_like(caps, -np.inf, dtype=float)

    # Logistic score: high when normalized residual <= tolerance,
    # low otherwise.
    scores[feasible] = 1.0 / (1.0 + np.exp(-steepness * (tolerance - norm_residual[feasible])))

    # Tiny deterministic tie‑breaker: proportional to bin index.
    # Guarantees a strict ordering when scores are exactly equal.
    tie_breaker = (np.arange(caps.size) / caps.size) * eps_noise
    scores[feasible] += tie_breaker[feasible]

    return scores
```
