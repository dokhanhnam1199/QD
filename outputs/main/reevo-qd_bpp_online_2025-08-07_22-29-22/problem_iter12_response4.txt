```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Simple deterministic best‑fit priority for the online Bin Packing Problem.

    Each bin receives a score proportional to how tightly the item would fill it.
    Bins that cannot accommodate the item get ``-np.inf`` so they are never chosen.
    Ties (identical slack) are broken by preferring the lower‑index bin.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of the remaining capacities of the current bins.

    Returns
    -------
    np.ndarray
        Priority scores for each bin (same shape as ``bins_remain_cap``).
        Higher scores are more desirable.  Infeasible bins have ``-np.inf``.
    """
    # Ensure we are working with a NumPy array of floats
    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)

    # Edge case: no existing bins
    if bins_remain_cap.size == 0:
        return np.array([], dtype=float)

    # Slack after placing the item (positive = leftover space)
    slack = bins_remain_cap - item

    # Floating‑point tolerance: treat very small negatives as zero
    eps = 1e-12
    feasible = slack >= -eps

    # Initialise all priorities to -inf (infeasible)
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Base score: negative slack (smaller slack → larger score)
    # Add a deterministic tie‑breaker: a tiny decreasing term with index
    tie_breaker = -np.arange(bins_remain_cap.size, dtype=float) * 1e-12

    # Assign scores to feasible bins
    priorities[feasible] = -slack[feasible] + tie_breaker[feasible]

    return priorities
```
