```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Compute a priority score for each bin for the incoming item.

    The priority favours:
        1. Exact fits (within a tolerance derived from EMA of item sizes).
        2. Bins with smaller slack (remaining capacity after placement) using an
           adaptive temperature based on an EMA of the median slack.
        3. Bins where slack is close to the EMA of item size (swap‑improvement boost).
        4. Penalises brand‑new bins (still at full capacity).
        5. Breaks ties deterministically by bin index.
        6. Adds a tiny random jitter to avoid degenerate ties.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of each bin.

    Returns
    -------
    np.ndarray
        Priority values (same shape as ``bins_remain_cap``). Infeasible bins
        receive ``-np.inf``.
    """
    # ------------------------------------------------------------------
    # Static state: EMA statistics, RNG, configuration constants.
    # ------------------------------------------------------------------
    if not hasattr(priority_v2, "_initialized"):
        # EMA of item size (mean and second moment) for std estimation.
        priority_v2._ema_item_mean = 0.0
        priority_v2._ema_item_sq = 0.0
        priority_v2._item_count = 0

        # EMA of median slack (used as adaptive temperature).
        priority_v2._ema_median_slack = 0.0

        # Random generator for jitter / tie‑break noise.
        priority_v2._rng = np.random.default_rng()

        # Configuration constants.
        priority_v2._EMA_ALPHA = 0.1
        priority_v2._EPSILON_FACTOR = 0.05
        priority_v2._SWAP_WEIGHT = 0.05
        priority_v2._PENALTY_BRAND_NEW = 0.01
        priority_v2._TIE_BREAK_EPS = 1e-9
        priority_v2._JITTER_SCALE = 1e-10
        priority_v2._EXACT_FIT_OFFSET = 1e9

        priority_v2._initialized = True

    # ------------------------------------------------------------------
    # 1. Update EMA of item size and compute its standard deviation.
    # ------------------------------------------------------------------
    alpha = priority_v2._EMA_ALPHA
    priority_v2._item_count += 1
    priority_v2._ema_item_mean = (1 - alpha) * priority_v2._ema_item_mean + alpha * item
    priority_v2._ema_item_sq = (1 - alpha) * priority_v2._ema_item_sq + alpha * (item * item)

    var = priority_v2._ema_item_sq - priority_v2._ema_item_mean ** 2
    var = max(var, 0.0)
    std_item = np.sqrt(var)

    # Tolerance for exact‑fit detection (scaled by observed std).
    eps_exact = max(1e-12, priority_v2._EPSILON_FACTOR * std_item)

    # ------------------------------------------------------------------
    # 2. Compute slack and feasibility masks.
    # ------------------------------------------------------------------
    slack = bins_remain_cap - item
    feasible = slack >= -eps_exact                     # allow tiny negative due to tolerance
    exact_fit = feasible & (np.abs(slack) <= eps_exact)

    # Initialise priority array: infeasible bins get -inf.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # ------------------------------------------------------------------
    # 3. Exact‑fit handling (huge offset + tiny random noise).
    # ------------------------------------------------------------------
    if np.any(exact_fit):
        noise = priority_v2._rng.uniform(0.0, 1e-6, size=exact_fit.sum())
        priorities[exact_fit] = priority_v2._EXACT_FIT_OFFSET + noise

    # ------------------------------------------------------------------
    # 4. Scoring of non‑exact feasible bins.
    # ------------------------------------------------------------------
    non_exact = feasible & ~exact_fit
    if np.any(non_exact):
        # 4a. Adaptive temperature: EMA of median slack.
        current_median = np.median(slack[non_exact])
        priority_v2._ema_median_slack = (1 - alpha) * priority_v2._ema_median_slack + alpha * current_median
        temperature = max(priority_v2._ema_median_slack, 1e-6)   # avoid division by zero

        # Slack values for non‑exact bins.
        slack_ne = slack[non_exact]

        # Primary component: prefers smaller slack (best‑fit). Clip to non‑negative.
        slack_ne_clipped = np.maximum(slack_ne, 0.0)
        primary_score = np.exp(-slack_ne_clipped / temperature)   # larger when slack is smaller

        # 4b. Swap‑improvement boost: reward slack close to mean item size.
        mean_item = priority_v2._ema_item_mean
        dist_to_mean = np.abs(slack_ne - mean_item)
        boost = priority_v2._SWAP_WEIGHT / (dist_to_mean + eps_exact)

        # 4c. Penalise brand‑new bins (those still at full capacity).
        full_capacity_est = np.max(bins_remain_cap)
        is_brand_new = np.isclose(bins_remain_cap, full_capacity_est, atol=1e-12) & non_exact
        brand_new_factor = np.where(is_brand_new, 1.0 - priority_v2._PENALTY_BRAND_NEW, 1.0)

        # 4d. Deterministic tie‑breaker by bin index (lower index gets slight boost).
        indices = np.arange(bins_remain_cap.shape[0], dtype=float)
        tie_break = indices[non_exact] * priority_v2._TIE_BREAK_EPS

        # 4e. Small random jitter to avoid pathological ties.
        jitter = priority_v2._rng.normal(scale=priority_v2._JITTER_SCALE, size=primary_score.shape)

        # Combine all components.
        combined = primary_score * brand_new_factor + boost - tie_break + jitter
        priorities[non_exact] = combined

    return priorities
```
