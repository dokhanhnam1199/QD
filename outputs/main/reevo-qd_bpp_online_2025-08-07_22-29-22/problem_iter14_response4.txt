```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Priority function for online bin packing.

    The function returns a priority score for each bin based on the remaining
    capacity that would remain after placing the given item.  A soft‑max
    transformation with an adaptive temperature is used so that bins with
    less slack get higher scores.  Brand‑new bins (still at full capacity)
    are given a tiny penalty to encourage re‑use of older bins.  Finally,
    a minuscule index bias breaks ties deterministically, favoring
    lower‑index bins.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of the existing bins.

    Returns
    -------
    np.ndarray
        Priority scores for each bin; infeasible bins receive ``-np.inf``.
    """
    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)

    # No bins: nothing to score.
    if bins_remain_cap.size == 0:
        return np.array([], dtype=float)

    # Slack if the item were placed.
    slack = bins_remain_cap - item
    feasible_mask = slack >= 0

    # Prepare output with -inf for infeasible bins.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # No feasible bin: return -inf for all.
    if not np.any(feasible_mask):
        return priorities

    # Base score: negative slack (smaller slack -> larger base score).
    base_score = -slack[feasible_mask]

    # Adaptive temperature: median slack among feasible bins.
    median_slack = np.median(slack[feasible_mask])
    temp = max(median_slack, 1e-6)  # avoid division by zero

    # Soft‑max style scores.
    soft_scores = np.exp(base_score / temp)

    # Assign to output.
    priorities[feasible_mask] = soft_scores

    # Identify brand‑new bins (still at full capacity).
    bin_capacity_est = np.max(bins_remain_cap)
    new_bin_mask = np.isclose(bins_remain_cap, bin_capacity_est) & feasible_mask

    # Tiny penalty for brand‑new bins.
    penalty_factor = 0.999  # ~0.1% reduction
    priorities[new_bin_mask] *= penalty_factor

    # Deterministic tie‑breaker: lower index gets a minuscule boost.
    indices = np.arange(bins_remain_cap.size, dtype=float)
    epsilon = 1e-9
    priorities[feasible_mask] += epsilon * (bins_remain_cap.size - 1 - indices[feasible_mask])

    return priorities
```
