```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Best‑Fit priority for the online Bin Packing Problem.

    For each bin we compute the remaining capacity after (hypothetically)
    placing the current `item`.  A feasible bin (remaining capacity ≥ 0)
    receives a priority equal to the negative of that leftover space.
    Since the caller selects the bin with the *highest* priority, the
    smallest leftover (i.e., the best‑fit) ends up with the largest value.

    Infeasible bins are given a very large negative score so they will never
    be chosen.  A tiny index‑based offset is added to break ties deterministically
    (prefer earlier bins when leftovers are equal).

    Args:
        item: Size of the incoming item.
        bins_remain_cap: 1‑D array of the remaining capacity of each bin.

    Returns:
        A float array of the same shape as ``bins_remain_cap`` containing the
        priority for each bin.
    """
    # Ensure we are dealing with a float array for arithmetic
    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)

    # Compute the capacity that would remain after placing the item
    leftover = bins_remain_cap - item

    # Feasibility mask: only bins with non‑negative leftover can host the item
    feasible = leftover >= 0

    # Initialise priorities with -inf (worst possible score)
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # For feasible bins, priority = -leftover (higher is better, i.e., smaller leftover)
    # Adding a tiny decreasing term based on index to break ties in favour of lower indices
    tie_breaker = -np.arange(bins_remain_cap.size) * 1e-12
    priorities[feasible] = -leftover[feasible] + tie_breaker[feasible]

    return priorities
```
