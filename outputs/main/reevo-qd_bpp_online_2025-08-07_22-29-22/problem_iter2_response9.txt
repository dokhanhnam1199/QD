```python
import numpy as np

# Global bin capacity (set this in your environment before calling priority_v2).
# If left as None, the function will infer capacity as the maximum remaining
# capacity among the provided bins (works when at least one empty bin exists).
BIN_CAPACITY = None


def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Enhanced priority function for online Bin Packing.

    - Masks infeasible bins (remaining capacity < item) with -inf.
    - Uses a hybrid best‑fit / worst‑fit strategy:
        * For relatively small items (≤ 0.5 * bin capacity) the function
          prefers bins with the smallest leftover after placement (best‑fit).
        * For large items (> 0.5 * bin capacity) it prefers bins with the
          largest leftover (worst‑fit) to preserve space for future items.
    - Adds a penalty for leaving a very small gap (less than 5% of capacity)
      when using best‑fit, discouraging creation of bins that cannot accommodate
      typical future items.
    - Break ties deterministically by subtracting a tiny decreasing term
      proportional to the bin index.
    - Returns a NumPy array of priority scores; the caller should select the
      bin with the highest score.

    Args:
        item: Size of the incoming item.
        bins_remain_cap: 1‑D array of the remaining capacity of each existing bin.

    Returns:
        A float NumPy array of the same shape as ``bins_remain_cap`` containing
        priority scores for each bin.
    """
    # Ensure a NumPy array of float type
    caps = np.asarray(bins_remain_cap, dtype=float)

    # Determine bin capacity: use global if set, else infer from the maximum remaining capacity.
    global BIN_CAPACITY
    if BIN_CAPACITY is not None:
        capacity = float(BIN_CAPACITY)
    else:
        capacity = caps.max() if caps.size > 0 else 0.0

    # Compute leftover capacity after hypothetical placement
    leftover = caps - item

    # Feasibility mask: bins that can accommodate the item
    feasible = leftover >= 0

    # Initialise priority array with -inf (worst possible)
    priorities = np.full_like(caps, -np.inf, dtype=float)

    # Strategy thresholds
    LARGE_ITEM_RATIO = 0.5          # Items >50% of capacity use worst‑fit
    GAP_THRESHOLD_RATIO = 0.05     # Gap <5% of capacity incurs a penalty

    # Base score selection based on item size relative to capacity
    if capacity > 0 and item > LARGE_ITEM_RATIO * capacity:
        # Large item: prefer bins with the most leftover (worst‑fit)
        base_score = leftover
        combined_score = base_score
    else:
        # Small/medium item: prefer bins with the smallest leftover (best‑fit)
        base_score = -leftover

        # Gap penalty: discourage leaving a tiny residual gap unlikely to be filled later
        gap_threshold = GAP_THRESHOLD_RATIO * capacity
        small_gap_mask = (leftover > 0) & (leftover < gap_threshold)
        eps = 1e-12
        penalty = np.zeros_like(caps, dtype=float)
        # Logarithmic penalty: larger for smaller gaps
        penalty[small_gap_mask] = -np.log((leftover[small_gap_mask] / gap_threshold) + eps)
        PENALTY_WEIGHT = 0.5.0 * 1e-1  # Adjust weight as needed; here 0.5
        combined_score = base_score + PENALTY_WEIGHT * penalty

    # Deterministic tie‑breaker: subtract a tiny decreasing term proportional to index
    tie_breaker = -np.arange(caps.size, dtype=float) * 1e-12
    combined_score = combined_score + tie_breaker

    # Assign combined scores only to feasible bins
    priorities[feasible] = combined_score[feasible]

    return priorities
```
