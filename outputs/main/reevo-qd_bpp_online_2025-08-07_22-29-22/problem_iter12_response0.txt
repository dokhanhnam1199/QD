```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Compute a deterministic priority for each bin in an online bin‑packing
    scenario.

    Prioritisation rules
    --------------------
    1. Exact fits (remaining capacity after placement ≈ 0) receive the highest
       priority.
    2. Among feasible non‑exact bins, a smaller leftover space (i.e. larger
       negative slack) yields a higher priority.
    3. Infeasible bins (cannot accommodate the item) get -inf so they are never
       selected.
    4. Deterministic tie‑breaking: lower‑indexed bins obtain a tiny boost,
       guaranteeing a stable ordering without randomness.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities for each existing bin.

    Returns
    -------
    np.ndarray
        Priority scores (same shape as ``bins_remain_cap``).  The bin with the
        largest score should be chosen.
    """
    # Ensure we are working with a float array
    caps = np.asarray(bins_remain_cap, dtype=float)

    # Tolerance for considering a fit to be "exact"
    eps_exact = 1e-12

    # Compute leftover capacity after placing the item in each bin
    leftover = caps - item

    # Masks for bin categories
    infeasible_mask = leftover < -eps_exact           # cannot fit
    exact_fit_mask   = np.abs(leftover) <= eps_exact  # exact (or near‑exact) fit
    feasible_mask    = ~infeasible_mask & ~exact_fit_mask

    # Initialise priority array with -inf for infeasible bins
    priorities = np.full_like(caps, -np.inf, dtype=float)

    # Deterministic tie‑breaker: a tiny offset proportional to the bin index
    # (lower index → slightly higher priority)
    tiny_offset = 1e-12
    indices = np.arange(caps.size, dtype=float)

    # Exact fits get a large constant offset to dominate all non‑exact scores
    exact_offset = 1e9
    priorities[exact_fit_mask] = exact_offset - tiny_offset * indices[exact_fit_mask]

    # For feasible non‑exact bins, priority = -leftover (smaller leftover ⇒ larger priority)
    # Apply the same tiny index‑based offset for deterministic tie‑breaking
    priorities[feasible_mask] = -leftover[feasible_mask] - tiny_offset * indices[feasible_mask]

    return priorities
```
