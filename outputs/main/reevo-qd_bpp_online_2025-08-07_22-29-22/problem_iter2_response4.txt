```python
import numpy as np

# Global RNG for tie‑breaking jitter (initialized once)
_rng = np.random.default_rng()

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Adaptive sigmoid priority for online bin packing.

    This function scores each existing bin based on the slack that would
    remain after placing the incoming item. Bins with smaller slack (i.e.
    tighter fit) receive higher scores. The scoring uses a logistic (sigmoid)
    function whose inflection point is the median slack of all feasible bins
    and whose slope adapts to the observed slack range. Infeasible bins
    (remaining capacity < item) receive ``-np.inf`` to guarantee they are never
    selected.

    A tiny random jitter is added to break ties in a deterministic way.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of the currently open bins.

    Returns
    -------
    np.ndarray
        Priority scores for each bin (higher is better). The caller should
        select the bin with the maximum priority.
    """
    # Ensure input is a NumPy float array
    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)

    # Slack after placing the item (negative = infeasible)
    slack = bins_remain_cap - item

    # Feasibility mask: bins that can accommodate the item
    feasible = slack >= 0.0

    # Initialise priorities to -inf (infeasible by default)
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # If no bin can accommodate the item, return early
    if not feasible.any():
        return priorities

    # Slack values for feasible bins only (non‑negative)
    slack_feas = slack[feasible]

    # Adaptive sigmoid parameters
    median_slack = np.median(slack_feas)

    # Slack range; avoid division by zero for near‑identical slacks
    slack_range = slack_feas.max() - slack_feas.min()
    if slack_range < 1e-12:
        # All feasible bins have (almost) identical slack → flat sigmoid
        alpha = 1.0
    else:
        # Scale alpha so the sigmoid transition spans roughly 8 slack units
        alpha = 8.0 / slack_range

    # Logistic function decreasing with slack; clamp exponent for stability
    exp_arg = np.clip(alpha * (slack_feas - median_slack), -50.0, 50.0)
    sigmoid_scores = 1.0 / (1.0 + np.exp(exp_arg))

    # Add a tiny random jitter (≤1e‑9) for deterministic tie‑breaking
    jitter = _rng.random(sigmoid_scores.shape) * 1e-9
    sigmoid_scores = sigmoid_scores + jitter

    # Populate the full priority vector
    priorities[feasible] = sigmoid_scores

    return priorities
```
