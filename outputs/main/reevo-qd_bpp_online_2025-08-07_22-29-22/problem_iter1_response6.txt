```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Sigmoid Fit Score priority for online bin packing.

    The score favours bins where the item leaves *little* slack after insertion.
    For each feasible bin (remaining capacity ≥ item) we compute the slack:
        slack = remaining_capacity - item
    A logistic (sigmoid) function is applied to the slack values:
        • Small slack → high priority (close to 1)
        • Large slack → low priority (close to 0)
    The inflection point of the sigmoid is placed at the median slack of the
    feasible bins, making the scoring adaptive to the current distribution of
    free space. Infeasible bins receive a priority of 0.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        Remaining capacities of the currently open bins.

    Returns
    -------
    np.ndarray
        Priority scores with the same shape as ``bins_remain_cap``. The bin
        with the highest score should be chosen for the item.
    """
    # Ensure we work with a float NumPy array
    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)

    # Slack after placing the item in every bin (negative = infeasible)
    slack = bins_remain_cap - item

    # Feasibility mask (only bins that can actually accommodate the item)
    feasible = slack >= 0.0

    # Initialise all priorities to 0 (infeasible bins stay at 0)
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # If nothing fits, simply return the zero vector
    if not feasible.any():
        return priorities

    # Slack values for feasible bins only
    slack_feas = slack[feasible]   # ≥ 0

    # Adaptive sigmoid parameters:
    #   β (beta)  – median slack (inflection point of the logistic)
    #   α (alpha) – slope, scaled so the curve spans roughly 8 units in the
    #               normalized slack range.
    beta = np.median(slack_feas)

    # Prevent division by zero when all feasible slacks are identical
    slack_range = slack_feas.max() - slack_feas.min() + 1e-12
    alpha = 8.0 / slack_range

    # Logistic (sigmoid) decreasing in slack:
    #   score = 1 / (1 + exp(α * (slack – β)))
    #   → slack < β  ⇒ exponent negative ⇒ score > 0.5 (high priority)
    #   → slack > β  ⇒ exponent positive ⇒ score < 0.5 (low priority)
    sigmoid_scores = 1.0 / (1.0 + np.exp(alpha * (slack_feas - beta)))

    # Fill the scores back into the full priority vector
    priorities[feasible] = sigmoid_scores

    return priorities
```
