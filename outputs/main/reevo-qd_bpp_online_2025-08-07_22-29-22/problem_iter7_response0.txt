```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Priority function for online bin packing.

    - Exact fit gets infinite priority.
    - Bins are scored by exp(-slack / λ), where λ is an EMA of recent slack.
    - Brand‑new bins (max remaining capacity) are penalised.
    - Older bins are favoured in ties by subtracting index * ε.
    - A minuscule random jitter breaks rare ties.
    """
    # Compute slack and masks
    slack = bins_remain_cap - item
    invalid_mask = slack < 0
    exact_fit_mask = slack == 0
    valid_mask = ~(invalid_mask | exact_fit_mask)

    # EMA of recent slack (simple stateful implementation)
    EMA_ALPHA = 0.1
    epsilon = 1e-6
    if np.any(valid_mask):
        median_slack = np.median(slack[valid_mask])
    else:
        median_slack = 0.0

    if not hasattr(priority_v2, "ema_slack"):
        priority_v2.ema_slack = median_slack
    priority_v2.ema_slack = (1 - EMA_ALPHA) * priority_v2.ema_slack + EMA_ALPHA * median_slack
    lam = priority_v2.ema_slack + epsilon

    # Base priority
    priority = np.empty_like(bins_remain_cap, dtype=float)
    priority[invalid_mask] = -np.inf
    priority[exact_fit_mask] = np.inf
    priority[valid_mask] = np.exp(-slack[valid_mask] / lam)

    # Penalise brand‑new bins (max remaining capacity)
    max_remaining = np.max(bins_remain_cap)
    brand_new_mask = bins_remain_cap == max_remaining
    penalty = 0.01
    penalty_mask = brand_new_mask & ~exact_fit_mask
    priority[penalty_mask] -= penalty

    # Deterministic tie‑breaking: older bins first
    indices = np.arange(len(bins_remain_cap))
    epsilon_tiebreaker = 1e-9
    priority -= indices * epsilon_tiebreaker

    # Add minuscule random jitter
    jitter_scale = 1e-10
    priority += np.random.normal(scale=jitter_scale, size=priority.shape)

    return priority
```
