```python
import numpy as np

# Global random generator for reproducible jitter (initialized once)
_rng = np.random.default_rng()


def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Adaptive sigmoid priority for online bin packing.

    Each bin is scored based on the slack (remaining capacity after placing the
    incoming item). Bins with smaller slack – i.e. tighter fits – obtain higher
    scores. The sigmoid’s centre (median slack) and steepness are adapted to
    the distribution of feasible slacks, making the heuristic robust across
    diverse instances. Infeasible bins (remaining capacity < item) receive
    ``-np.inf`` to guarantee they are never selected. A tiny random jitter
    (≤1e‑9) breaks ties deterministically while preserving reproducibility.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of the currently open bins.

    Returns
    -------
    np.ndarray
        Priority scores for each bin (higher is better). The caller should
        select the bin with the maximum priority.
    """
    # Ensure the capacity vector is a NumPy float array
    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)

    # Slack after placing the item (negative = infeasible)
    slack = bins_remain_cap - item

    # Feasibility mask: bins that can accommodate the item
    feasible_mask = slack >= 0.0

    # Initialise priorities with -inf for infeasible bins
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Early exit if no feasible bin exists
    if not np.any(feasible_mask):
        return priorities

    # Slack values for feasible bins only
    feasible_slack = slack[feasible_mask]

    # Adaptive sigmoid centre (median slack) and steepness
    median_slack = np.median(feasible_slack)

    # Slack range to adapt the slope; enforce a tiny floor to avoid div‑zero
    slack_min = feasible_slack.min()
    slack_max = feasible_slack.max()
    slack_range = slack_max - slack_min
    min_range = 1e-12
    if slack_range < min_range:
        # All feasible bins have (almost) identical slack → flat sigmoid
        alpha = 1.0
    else:
        # Choose alpha such that the sigmoid transitions over ~90% of the range:
        # exp(-alpha * (range/2)) ≈ 0.01  →  alpha ≈ 2*ln(99) / range
        alpha = 2.0 * np.log(99.0) / slack_range

    # Logistic (sigmoid) decreasing with slack; clip exponent for numeric stability
    exp_arg = np.clip(alpha * (feasible_slack - median_slack), -50.0, 50.0)
    sigmoid_scores = 1.0 / (1.0 + np.exp(exp_arg))

    # Add a tiny random jitter (≤1e‑9) for deterministic tie‑breaking
    jitter = _rng.random(sigmoid_scores.shape) * 1e-9
    sigmoid_scores = sigmoid_scores + jitter

    # Populate the full priority vector
    priorities[feasible_mask] = sigmoid_scores

    return priorities
```
