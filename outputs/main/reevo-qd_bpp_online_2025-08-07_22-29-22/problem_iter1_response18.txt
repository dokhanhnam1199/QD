```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.1) -> np.ndarray:
    """
    Compute a priority score for each bin using an epsilon‑greedy scheme.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        Remaining capacities of the current bins.
    epsilon : float, optional
        Exploration probability in [0, 1]. epsilon=0 yields pure greedy (best‑fit);
        epsilon=1 chooses a bin uniformly at random.

    Returns
    -------
    np.ndarray
        Priority scores of the same shape as ``bins_remain_cap``. The bin with the
        highest score should be selected for the item.
    """
    # Initialize scores with -inf for infeasible bins so they are never chosen.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Identify bins that can actually accommodate the item.
    feasible = bins_remain_cap >= item
    if not np.any(feasible):
        # No existing bin can hold the item – caller may open a new bin.
        return priorities

    # Compute remaining capacity after (hypothetically) placing the item.
    leftover = bins_remain_cap[feasible] - item            # >= 0

    # Deterministic component: best‑fit (smallest leftover) -> use negative leftover.
    deterministic = -leftover.astype(float)

    # Exploration component: random uniform numbers in [0, 1).
    exploration = np.random.rand(np.sum(feasible))

    # Blend deterministic and random parts according to epsilon.
    blended = (1.0 - epsilon) * deterministic + epsilon * exploration

    # Fill the priority array for feasible bins.
    priorities[feasible] = blended

    return priorities
```
