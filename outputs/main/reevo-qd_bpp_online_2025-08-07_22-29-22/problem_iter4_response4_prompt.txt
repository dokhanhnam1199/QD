{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n# Global random generator to avoid reseeding on every call\n_rng = np.random.default_rng()\n\n    \"\"\"Random\u2011Fit priority for online Bin Packing.\n\n    For each bin that can accommodate the incoming `item` (i.e. its remaining\n    capacity \u2265 item size), we assign an independent random number drawn from a\n    uniform distribution on (0, 1). Bins that cannot accommodate the item receive\n    a priority of -inf, ensuring they are never selected. The bin with the\n    maximum priority (the highest random draw) will be chosen, which implements\n    the classic Random Fit strategy.\n\n    Args:\n        item: Size of the incoming item.\n        bins_remain_cap: 1\u2011D array with the remaining capacity of each existing bin.\n\n    Returns:\n        A NumPy array of the same shape as `bins_remain_cap` containing priority\n        scores for each bin.\n    \"\"\"\n    # Initialise all priorities to -inf (infeasible by default)\n    priorities = np.full(bins_remain_cap.shape, -np.inf, dtype=float)\n\n    # Identify bins that can fit the item\n    feasible_mask = bins_remain_cap >= item\n    num_feasible = np.count_nonzero(feasible_mask)\n\n    # Assign random priorities only to feasible bins\n    if num_feasible:\n        priorities[feasible_mask] = _rng.random(num_feasible)\n\n    return priorities\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n# Single random generator \u2013 reused on every call (no reseeding)\n_rng = np.random.default_rng()\n\n# Simple running statistics of items seen so far (used for a lightweight look\u2011ahead)\n_item_count = 0\n_item_sum = 0.0\n\n\n    \"\"\"\n    Hybrid priority for the online Bin Packing Problem.\n\n    Combines a best\u2011fit score with:\n      \u2022 a controlled random perturbation (more randomness for small items),\n      \u2022 a deterministic tie\u2011breaker that favours lower\u2011index bins,\n      \u2022 a look\u2011ahead term based on the running average size of previously\n        observed items.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array with the remaining capacity of each existing bin.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin (same shape as ``bins_remain_cap``).\n        Higher values are preferred; infeasible bins receive ``-np.inf``.\n    \"\"\"\n    global _item_count, _item_sum\n\n    # Normalise input\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)\n\n    # No existing bins \u2013 caller will open a new one.\n    if bins_remain_cap.size == 0:\n        _item_count += 1\n        _item_sum += item\n        return np.array([], dtype=float)\n\n    # --- 1: feasibility -------------------------------------------------\n    leftover = bins_remain_cap - item               # capacity that would remain\n    feasible = leftover >= 0                         # True for bins that can host the item\n\n    # Initialise with -inf (worst possible score)\n    priorities = np.full(bins_remain_cap.shape, -np.inf, dtype=float)\n\n    # If nothing fits, just record statistics and return.\n    if not np.any(feasible):\n        _item_count += 1\n        _item_sum += item\n        return priorities\n\n    # --- 2: best\u2011fit base score -----------------------------------------\n    # Higher score \u2194 tighter fit (smaller leftover)\n    base_score = -leftover[feasible]                # negative leftover\n\n    # --- 3: controlled randomness ----------------------------------------\n    # Rough estimate of the true bin capacity (most empty bin + current item)\n    approx_capacity = bins_remain_cap.max() + item\n    approx_capacity = max(approx_capacity, 1.0)     # guard against degenerate zero\n\n    # Item\u2011size ratio: larger items \u2192 less randomness\n    item_ratio = item / approx_capacity\n\n    # Scale random noise relative to the spread of leftover space\n    leftover_feas = leftover[feasible * 1]  # alias for readability\n    leftover_range = leftover_feas.max() - leftover_feas.min()\n    noise_scale = leftover_range * 0.05 * (1.0 - item_ratio)\n    noise_scale = max(noise_scale, 0.0)\n\n    random_noise = _rng.random(leftover_feas.shape) * noise_scale\n\n    # --- 4: look\u2011ahead using running average item size -------------------\n    if _item_count > 0:\n        avg_item = _item_sum / _item_count\n    else:\n        avg_item = item   # first item \u2013 fall back to its own size\n\n    # Small boost for bins that would still have room for a typical future item\n    # (positive if leftover > avg_item, negative otherwise)\n    future_weight = 0.02                         # tiny constant factor\n    future_adjust = (leftover_feas - avg_item) * future_weight\n\n    # --- 5: deterministic tie\u2011breaker ------------------------------------\n    # Slightly penalise higher indices to break exact ties deterministically\n    tie_breaker = -np.arange(bins_remain_cap.size, dtype=float) * 1e-12\n\n    # --- 6: combine all components ---------------------------------------\n    priorities[feasible] = (\n        base_score\n        + random_noise\n        + future_adjust\n        + tie_breaker[feasible]\n    )\n\n    # Record the current item for future look\u2011ahead calculations\n    _item_count += 1\n    _item_sum += item\n\n    return priorities\n\n[Reflection]\nUse best\u2011fit scoring, scale noise by leftover spread, add look\u2011ahead averages, and tie\u2011break deterministically by bin index.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}