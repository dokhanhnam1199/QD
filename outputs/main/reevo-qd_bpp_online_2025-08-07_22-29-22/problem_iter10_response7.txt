```python
import numpy as np

# Global RNG for optional stochastic tie‑breaking
_rng = np.random.default_rng()


def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    *,
    temperature: float = 0.1,
    random_noise: bool = False,
    noise_scale: float = 1e-12,
) -> np.ndarray:
    """
    Compute a softmax‑based priority vector for an online Bin Packing item.

    The priority favours bins where the item fits tightly (small slack).
    For each feasible bin a logit proportional to the negative slack,
    scaled by ``temperature``, is transformed into a probability‑like score
    via a numerically‑stable softmax.  Infeasible bins receive a priority of 0.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of the currently open (or opened) bins.
    temperature : float, optional (default=0.1)
        Controls the sharpness of the softmax.  Lower values make the decision
        more deterministic (approaching Best‑Fit), while higher values spread
        the probability mass more uniformly.
    random_noise : bool, optional (default=False)
        If True, add a tiny uniform noise to the logits of feasible bins to
        break ties in a reproducible stochastic way.
    noise_scale : float, optional (default=1e-12)
        Magnitude of the optional tie‑breaking noise.

    Returns
    -------
    np.ndarray
        Priority scores for each bin (same shape as ``bins_remain_cap``).
        The scores sum to 1 across all feasible bins; infeasible bins have a
        score of 0.  The bin with the highest priority should be selected.
    """
    if temperature <= 0.0:
        raise ValueError("temperature must be a positive float")

    # Ensure a NumPy array of float64 for stable arithmetic
    caps = np.asarray(bins_remain_cap, dtype=np.float64)

    # Feasibility mask: bin can hold the item if remaining capacity >= item size
    (feasible) = caps >= item

    # Early exit when no bin can accommodate the item
    priorities = np.zeros_like(caps, dtype=np.float64)
    if not np.any(feasible):
        return priorities

    # Slack = unused capacity after placing the item (non‑negative for feasible bins)
    slack = caps[feasible] - item

    # Logits: tighter fit (smaller slack) → larger logit.
    # Scale by temperature; smaller temperature → larger magnitude differences.
    logits = np.full_like(caps, -np.inf, dtype=np.float64)
    logits[feasible] = -slack / temperature

    # Optional tiny noise for stochastic tie‑breaking
    if random_noise:
        noise = _rng.uniform(-noise_scale, noise_scale, size=logits.shape)
        logits[feasible] += noise[feasible]

    # Numerically stable softmax
    max_logit = np.max(logits[feasible])          # safe because feasible is non‑empty
    exp_shifted = np.exp(logits - max_logit)     # exp(-inf) = 0 for infeasible bins
    sum_exp = np.sum(exp_shifted)                # > 0

    priorities = exp_shifted / sum_exp
    return priorities
```
