[
  {
    "stdout_filepath": "problem_iter1_response3.txt_stdout.txt",
    "code_path": "problem_iter1_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Almost Full Fit priority function.\n\n    Picks the bin that will be *almost* full after placing the item\n    (i.e. the smallest positive slack).  Bins that cannot accommodate\n    the item receive a very low priority of -\u221e.\n\n    Parameters\n    ----------\n    item : float\n        Size of the item to place.\n    bins_remain_cap : np.ndarray\n        Remaining capacities of each bin.\n\n    Returns\n    -------\n    np.ndarray\n        Priority score for each bin; higher scores are preferred.\n    \"\"\"\n    # Compute the remaining slack after inserting the item.\n    slack = bins_remain_cap - item\n\n    # Bins that cannot fit the item are assigned -\u221e priority.\n    invalid_mask = slack < 0\n    priorities = np.where(invalid_mask, -np.inf, -slack)  # smaller slack \u21d2 larger priority\n\n    return priorities",
    "response_id": 3,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response1.txt_stdout.txt",
    "code_path": "problem_iter1_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Best\u2011Fit priority for the online Bin Packing Problem.\n\n    For each bin we compute the remaining capacity after (hypothetically)\n    placing the current `item`.  A feasible bin (remaining capacity \u2265 0)\n    receives a priority equal to the negative of that leftover space.\n    Since the caller selects the bin with the *highest* priority, the\n    smallest leftover (i.e., the best\u2011fit) ends up with the largest value.\n\n    Infeasible bins are given a very large negative score so they will never\n    be chosen.  A tiny index\u2011based offset is added to break ties deterministically\n    (prefer earlier bins when leftovers are equal).\n\n    Args:\n        item: Size of the incoming item.\n        bins_remain_cap: 1\u2011D array of the remaining capacity of each bin.\n\n    Returns:\n        A float array of the same shape as ``bins_remain_cap`` containing the\n        priority for each bin.\n    \"\"\"\n    # Ensure we are dealing with a float array for arithmetic\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)\n\n    # Compute the capacity that would remain after placing the item\n    leftover = bins_remain_cap - item\n\n    # Feasibility mask: only bins with non\u2011negative leftover can host the item\n    feasible = leftover >= 0\n\n    # Initialise priorities with -inf (worst possible score)\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # For feasible bins, priority = -leftover (higher is better, i.e., smaller leftover)\n    # Adding a tiny decreasing term based on index to break ties in favour of lower indices\n    tie_breaker = -np.arange(bins_remain_cap.size) * 1e-12\n    priorities[feasible] = -leftover[feasible] + tie_breaker[feasible]\n\n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response4.txt_stdout.txt",
    "code_path": "problem_iter1_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Priority function implementing the *Exact Fit First* strategy for online Bin Packing.\n\n    Each bin receives a score; the bin with the highest score is chosen for the item.\n    - Bins that cannot accommodate the item receive `-inf` (lowest possible priority).\n    - Among feasible bins, the priority is the negative remaining slack\n      (`-(remaining_capacity - item)`).  Thus a smaller slack \u2192 a larger priority,\n      with a perfect (exact) fit yielding the highest possible score (zero).\n\n    A tiny random perturbation is added to break ties deterministically without\n    affecting the ordering of distinct slack values.\n\n    Args:\n        item: Size of the incoming item.\n        bins_remain_cap: 1\u2011D array of remaining capacities of existing bins.\n\n    Returns:\n        A 1\u2011D `np.ndarray` of priority scores, same shape as `bins_remain_cap`.\n    \"\"\"\n    # Compute how much free space would remain after placing the item in each bin.\n    slack = bins_remain_cap - item\n\n    # Initialise all priorities to -inf (i.e., bins that cannot host the item).\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify feasible bins (enough remaining capacity).\n    feasible = slack >= 0\n\n    # For feasible bins, priority = -slack (higher for tighter fits).\n    priorities[feasible] = -slack[feasible]\n\n    # Optional tie\u2011breaker: add infinitesimal random noise to differentiate exact ties.\n    if feasible.any():\n        # Noise magnitude is far below any meaningful slack difference.\n        noise = np.random.rand(feasible.sum()) * 1e-9\n        priorities[feasible] += noise\n\n    return priorities",
    "response_id": 4,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response6.txt_stdout.txt",
    "code_path": "problem_iter1_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Sigmoid Fit Score priority for online bin packing.\n\n    The score favours bins where the item leaves *little* slack after insertion.\n    For each feasible bin (remaining capacity \u2265 item) we compute the slack:\n        slack = remaining_capacity - item\n    A logistic (sigmoid) function is applied to the slack values:\n        \u2022 Small slack \u2192 high priority (close to 1)\n        \u2022 Large slack \u2192 low priority (close to 0)\n    The inflection point of the sigmoid is placed at the median slack of the\n    feasible bins, making the scoring adaptive to the current distribution of\n    free space. Infeasible bins receive a priority of 0.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        Remaining capacities of the currently open bins.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores with the same shape as ``bins_remain_cap``. The bin\n        with the highest score should be chosen for the item.\n    \"\"\"\n    # Ensure we work with a float NumPy array\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)\n\n    # Slack after placing the item in every bin (negative = infeasible)\n    slack = bins_remain_cap - item\n\n    # Feasibility mask (only bins that can actually accommodate the item)\n    feasible = slack >= 0.0\n\n    # Initialise all priorities to 0 (infeasible bins stay at 0)\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # If nothing fits, simply return the zero vector\n    if not feasible.any():\n        return priorities\n\n    # Slack values for feasible bins only\n    slack_feas = slack[feasible]   # \u2265 0\n\n    # Adaptive sigmoid parameters:\n    #   \u03b2 (beta)  \u2013 median slack (inflection point of the logistic)\n    #   \u03b1 (alpha) \u2013 slope, scaled so the curve spans roughly 8 units in the\n    #               normalized slack range.\n    beta = np.median(slack_feas)\n\n    # Prevent division by zero when all feasible slacks are identical\n    slack_range = slack_feas.max() - slack_feas.min() + 1e-12\n    alpha = 8.0 / slack_range\n\n    # Logistic (sigmoid) decreasing in slack:\n    #   score = 1 / (1 + exp(\u03b1 * (slack \u2013 \u03b2)))\n    #   \u2192 slack < \u03b2  \u21d2 exponent negative \u21d2 score > 0.5 (high priority)\n    #   \u2192 slack > \u03b2  \u21d2 exponent positive \u21d2 score < 0.5 (low priority)\n    sigmoid_scores = 1.0 / (1.0 + np.exp(alpha * (slack_feas - beta)))\n\n    # Fill the scores back into the full priority vector\n    priorities[feasible] = sigmoid_scores\n\n    return priorities",
    "response_id": 6,
    "obj": 4.048663741523748,
    "SLOC": 14.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response7.txt_stdout.txt",
    "code_path": "problem_iter1_code7.py",
    "code": "import numpy as np\n\n# Global random generator to avoid reseeding on every call\n_rng = np.random.default_rng()\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Random\u2011Fit priority for online Bin Packing.\n\n    For each bin that can accommodate the incoming `item` (i.e. its remaining\n    capacity \u2265 item size), we assign an independent random number drawn from a\n    uniform distribution on (0, 1). Bins that cannot accommodate the item receive\n    a priority of -inf, ensuring they are never selected. The bin with the\n    maximum priority (the highest random draw) will be chosen, which implements\n    the classic Random Fit strategy.\n\n    Args:\n        item: Size of the incoming item.\n        bins_remain_cap: 1\u2011D array with the remaining capacity of each existing bin.\n\n    Returns:\n        A NumPy array of the same shape as `bins_remain_cap` containing priority\n        scores for each bin.\n    \"\"\"\n    # Initialise all priorities to -inf (infeasible by default)\n    priorities = np.full(bins_remain_cap.shape, -np.inf, dtype=float)\n\n    # Identify bins that can fit the item\n    feasible_mask = bins_remain_cap >= item\n    num_feasible = np.count_nonzero(feasible_mask)\n\n    # Assign random priorities only to feasible bins\n    if num_feasible:\n        priorities[feasible_mask] = _rng.random(num_feasible)\n\n    return priorities",
    "response_id": 7,
    "obj": 73.55404866374154,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response14.txt_stdout.txt",
    "code_path": "problem_iter1_code14.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Exact Fit First priority for the online Bin Packing Problem.\n\n    The function assigns:\n      * A very low score (negative infinity) to bins that cannot accommodate the item.\n      * A neutral/highest score (zero) to bins where the item fits *exactly* (within a tiny tolerance).\n      * For all other feasible bins, a score proportional to the *negative* leftover capacity,\n        i.e., the less space that will be wasted, the higher (less negative) the score.\n\n    By returning the array of scores, the caller can simply select the bin with the\n    maximum priority, which yields the \"Exact\u2011Fit\u2011First\" behaviour: any exact fit\n    beats any non\u2011exact fit, and among non\u2011exact fits the one leaving the smallest\n    waste is chosen.\n\n    Args:\n        item: Size of the incoming item.\n        bins_remain_cap: 1\u2011D array with the remaining capacity of each existing bin.\n\n    Returns:\n        np.ndarray of the same shape as ``bins_remain_cap`` containing priority scores.\n    \"\"\"\n    # Remaining capacity after (theoretically) placing the item in each bin\n    leftover = bins_remain_cap - item\n\n    # Tolerance for floating\u2011point comparisons (treat very small leftovers as exact fits)\n    eps = 1e-9\n\n    # If the item does not fit, assign -inf (worst possible priority)\n    # If it fits exactly (|leftover| <= eps), assign 0 (highest finite priority)\n    # Otherwise assign -leftover (larger leftover -> lower (more negative) priority)\n    priorities = np.where(\n        leftover < -eps,\n        -np.inf,\n        np.where(\n            np.abs(leftover) <= eps,\n            0.0,\n            -leftover\n        )\n    )\n\n    # Ensure floating\u2011point dtype\n    return priorities.astype(float)",
    "response_id": 14,
    "obj": 4.048663741523748,
    "SLOC": 13.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response16.txt_stdout.txt",
    "code_path": "problem_iter1_code16.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Compute a sigmoid\u2011based priority score for placing ``item`` into each bin.\n\n    The score favours bins that will have a small residual capacity after\n    packing the item (tight fit).  The relationship between residual capacity\n    and priority is shaped by a logistic (sigmoid) function:\n\n        score = 1 / (1 + exp(-k * (\u03c4 - r\u0302)))\n\n    where:\n        r\u0302 = (remaining_capacity - item) / C\u0302  is the normalized residual,\n        C\u0302 = max(bins_remain_cap) + item         an estimate of the true bin\n                                                   capacity,\n        \u03c4  = tolerance (fraction of capacity we consider \u201ctight\u201d),\n        k  = steepness controlling how sharply the score drops when\n             residual exceeds the tolerance.\n\n    Infeasible bins (where the item does not fit) receive a very low priority\n    (\u2011inf) so they are never selected.\n\n    Parameters\n    ----------\n    item : float\n        Size of the item to be placed.\n    bins_remain_cap : np.ndarray\n        1\u2011D array containing the remaining free capacity of each bin.\n\n    Returns\n    -------\n    np.ndarray\n        Array of priority scores of the same shape as ``bins_remain_cap``.\n    \"\"\"\n    # Ensure proper dtype for vectorised arithmetic.\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)\n\n    # Compute remaining capacity after the candidate placement.\n    residual = bins_remain_cap - item\n\n    # Feasibility mask \u2013 bins where the item fits.\n    feasible = residual >= 0.0\n\n    # Estimate the original bin capacity.\n    # Adding ``item`` guarantees that an empty bin (full capacity) yields C\u0302 \u2248 bin_capacity.\n    est_capacity = np.max(bins_remain_cap) + item\n\n    # Normalised residual (fraction of estimated capacity left after placement).\n    # Clip to [0, 1] for numerical stability.\n    norm_residual = np.clip(residual / est_capacity, 0.0, 1.0)\n\n    # Sigmoid hyper\u2011parameters.\n    steepness = 12.0   # Controls the sharpness of the transition.\n    tolerance = 0.10   # Desired maximal leftover fraction (10\u202f% of capacity).\n\n    # Compute sigmoid\u2011based scores.\n    # High score when normalized residual \u2264 tolerance, low otherwise.\n    scores = np.full_like(bins_remain_cap, fill_value=-np.inf, dtype=float)\n    scores[feasible] = 1.0 / (1.0 + np.exp(-steepness * (tolerance - norm_residual[feasible])))\n\n    return scores",
    "response_id": 16,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response19.txt_stdout.txt",
    "code_path": "problem_iter1_code19.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray,\n                temperature: float = 0.1) -> np.ndarray:\n    \"\"\"\n    Softmax\u2011Based Fit priority for online Bin Packing.\n\n    The idea is to assign a high priority to bins where the item fits tightly\n    (i.e., leaves little remaining capacity).  For each feasible bin we compute\n    a \u201clogit\u201d proportional to the negative slack (remaining capacity after\n    placement).  These logits are transformed with a softmax so that the best\n    fit gets the largest probability while still keeping a smooth preference\n    distribution.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities of the current bins.\n    temperature : float, optional (default=0.1)\n        Smoothing parameter > 0.  Lower values make the priority more\n        deterministic (closer to a greedy best\u2011fit), while higher values spread\n        the priority more uniformly.\n\n    Returns\n    # --------\n    np.ndarray\n        Priority scores for each bin.  The vector sums to 1 across all feasible\n        bins (infeasible bins receive a priority of 0).  The bin with the\n        highest priority should be selected for the item.\n    \"\"\"\n    if temperature <= 0:\n        raise ValueError(\"temperature must be positive\")\n    # Ensure float dtype for calculations\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=np.float64)\n\n    # Feasibility mask: item can only go into bins with enough remaining capacity\n    feasible = bins_remain_cap >= item\n\n    # Initialise priorities with zeros\n    priorities = np.zeros_like(bins_remain_cap, dtype=np.float64)\n\n    # If no bin can accommodate the item, return all zeros (the caller may open a new bin)\n    if not np.any(feasible):\n        return priorities\n\n    # Compute slack (unused capacity after placing the item) for feasible bins\n    slack = np.empty_like(bins_remain_cap, dtype=np.float64)\n    slack.fill(np.inf)                      # non\u2011feasible bins get infinite slack\n    slack[feasible] = bins_remain_cap[feasible] - item\n\n    # Logits: higher when slack is smaller (tighter fit)\n    #   logits = -slack / temperature   (more negative for larger slack)\n    logits = -slack / temperature\n\n    # Stabilize the softmax: subtract the maximum logit (ignoring -inf)\n    max_logit = np.max(logits[feasible])   # safe because we have at least one feasible bin\n    exp_logits = np.exp(logits - max_logit)  # infeasible entries become exp(-inf)=0\n\n    # Normalise to obtain a probability\u2011like priority vector\n    sum_exp = np.sum(exp_logits[feasible])\n    if sum_exp > 0:\n        priorities[feasible] = exp_logits[feasible] / sum_exp\n    # Infeasible bins already have priority 0\n\n    return priorities",
    "response_id": 19,
    "obj": 4.048663741523748,
    "SLOC": 19.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response21.txt_stdout.txt",
    "code_path": "problem_iter1_code21.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Return priority scores for bin placement using a Best\u2011Fit rule.\n\n    The strategy gives higher priority to bins that will have the smallest\n    remaining capacity after the item is inserted.  Bins that cannot\n    accommodate the item receive a very low score.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array holding the remaining capacity of each open bin.\n\n    Returns\n    -------\n    priorities : np.ndarray\n        An array of the same shape as ``bins_remain_cap`` with a numeric\n        priority for each bin.  The bin with the maximum priority will\n        be chosen by the caller.  Bins that cannot take the item will\n        get a score of ``-np.inf``.\n    \"\"\"\n    # Ensure the input is a float array (in case the caller passes ints)\n    bins = np.asarray(bins_remain_cap, dtype=float)\n    n = bins.size\n\n    # Fast path for an empty bin list \u2013 typical for the very first item.\n    if n == 0:\n        return np.empty(0, dtype=float)\n\n    # Initialise all priorities to a very low value.\n    priorities = np.full(n, -np.inf, dtype=float)\n\n    # Identify bins that can accommodate the item\n    can_place = bins >= item\n    if not np.any(can_place):\n        return priorities  # nothing can take the item\n\n    # Remaining capacity after the item would be inserted\n    leftover = bins[can_place] - item\n\n    # Small deterministic bias \u2013 earlier bins get slightly higher priority\n    # for bins with exactly the same leftover.  This keeps the behaviour\n    # reproducible across runs.\n    indices = np.arange(n)[can_place]\n    priorities[can_place] = -leftover - 1e-7 * indices\n\n    return priorities",
    "response_id": 21,
    "obj": 4.048663741523748,
    "SLOC": 13.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response29.txt_stdout.txt",
    "code_path": "problem_iter1_code29.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Softmax\u2011Based Fit priority function for online Bin Packing.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities of each currently open bin.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin. Scores sum to 1 across bins that can host the\n        item (softmax probabilities). Infeasible bins receive a score of 0.\n    \n    Strategy\n    --------\n    1. Determine which bins can accommodate the item.\n    2. Compute the *waste* that would remain after inserting the item:\n          waste_i = bins_remain_cap[i] - item.\n    3. Transform waste into a fitness score with exponential decay:\n          score_i = exp(-\u03bb * waste_i)\n       where \u03bb controls the steepness of the softmax. \u03bb is set adaptively as\n       the inverse of the average waste among feasible bins.\n    4. Apply a softmax normalisation so tighter fits (smaller waste) obtain\n       higher priority.\n    \"\"\"\n    # Ensure a NumPy array of float for vectorised operations\n    caps = np.asarray(bins_remain_cap, dtype=float)\n\n    # ---------- 1. Feasibility ----------\n    feasible = caps >= item\n    if not np.any(feasible):\n        # No open bin can host the item \u2192 caller should open a new bin.\n        return np.zeros_like(caps)\n\n    # ---------- 2. Compute waste ----------\n    # waste for feasible bins, np.inf for infeasible (will be ignored later)\n    waste = np.where(feasible, caps - item, np.inf)\n\n    # ---------- 3. Adaptive \u03bb (softmax temperature) ----------\n    # Small epsilon avoids division by zero if waste is exactly zero.\n    eps = 1e-12\n    mean_waste = waste[feasible].mean()\n    lam = 1.0 / (mean_waste + eps)\n\n    # ---------- 4. Raw scores via exponential decay ----------\n    raw = np.exp(-lam * waste)\n    raw[~feasible] = 0.0  # enforce zero for infeasible bins\n\n    # ---------- 5. Softmax normalisation ----------\n    total = raw.sum()\n    if total > 0:\n        priorities = raw / total\n    else:\n        # Numerically unlikely fallback: uniform over feasible bins\n        priorities = np.where(feasible, 1.0 / feasible.sum(), 0.0)\n\n    return priorities",
    "response_id": 29,
    "obj": 4.048663741523748,
    "SLOC": 17.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  }
]