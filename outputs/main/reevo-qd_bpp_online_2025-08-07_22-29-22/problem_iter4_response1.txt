```python
import numpy as np

# Global random generator (single instance to avoid reseeding)
_rng = np.random.default_rng()


def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Waste‑decay softmax priority with adaptive temperature and controlled randomness.

    Strategy
    --------
    1. **Feasibility** – Identify bins that can accommodate ``item``.
    2. **Waste computation** – For feasible bins compute the leftover capacity
       (``waste = remaining_capacity - item``).
    3. **Adaptive temperature (λ)** – λ is set inversely proportional to the
       average waste *plus* a fraction of the waste standard deviation.  This
       makes the softmax sharper when bins are uniformly tight and softer when
       waste varies a lot.
    4. **Base scores** – ``score_i = exp(-λ * waste_i)`` gives higher scores to
       tighter fits.
    5. **Controlled randomness** – Multiplicative log‑normal noise with a
       standard deviation that scales with the relative waste variance is
       applied, encouraging exploration while still favouring low waste.
    6. **Normalization** – Scores are normalised to sum to 1 over feasible
       bins (infeasible bins receive 0).  The returned array can be used as a
       probability distribution or as raw priorities; the bin with the highest
       value will be selected.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of currently open bins.

    Returns
    -------
    np.ndarray
        Priority scores for each bin (same shape as ``bins_remain_cap``).  Infeasible
        bins have a score of 0.
    """
    # Ensure a NumPy float array for vectorised ops
    caps = np.asarray(bins_remain_cap, dtype=float)

    # ---------- 1. Feasibility ----------
    feasible = caps >= item
    if not np.any(feasible):
        # No bin can host the item – caller should open a new bin.
        return np.zeros_like(caps)

    # ---------- 2. Compute waste ----------
    waste = caps[feasible] - item  # only for feasible bins

    # ---------- 3. Adaptive λ (temperature) ----------
    eps = 1e-12
    mean_waste = waste.mean()
    std_waste = waste.std()
    # λ inversely proportional to mean waste + a fraction of the std deviation
    lam = 1.0 / (mean_waste + 0.5 * std_waste + eps)

    # ---------- 4. Base scores via exponential decay ----------
    base_scores = np.exp(-lam * waste)  # higher for tighter fits

    # ---------- 5. Controlled randomness ----------
    # Relative variance controls the magnitude of randomness
    rel_variance = std_waste / (mean_waste + eps)
    # Scale of log‑normal noise (clipped to avoid extreme perturbations)
    noise_sigma = min(0.3, rel_variance)  # σ ∈ [0, 0.3]
    noise = _rng.lognormal(mean=0.0, sigma=noise_sigma, size=base_scores.shape)
    noisy_scores = base_scores * noise

    # ---------- 6. Assemble full priority vector ----------
    priorities = np.zeros_like(caps)
    priorities[feasible] = noisy_scores

    # Normalise to a proper probability distribution (optional but convenient)
    total = priorities.sum()
    if total > 0.0:
        priorities /= total
    else:
        # Numerical fallback: uniform over feasible bins
        priorities[feasible] = 1.0 / feasible.sum()

    return priorities
```
