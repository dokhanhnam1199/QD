```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Priority function for the online Bin Packing Problem.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of the remaining capacities of the currently open bins.
        The order of the array reflects bin age (index 0 = oldest bin).

    Returns
    -------
    np.ndarray
        Priority score for each bin (higher = more preferred). Bins that cannot
        accommodate the item receive ``-np.inf``.
    """
    # Ensure numpy array
    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)

    # Slack after inserting the item
    slack = bins_remain_cap - item
    feasible_mask = slack >= 0                     # bins that can hold the item

    # Initialise all priorities to -inf (infeasible)
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # ------------------------------------------------------------------
    # 1) Exact fits: give them the highest possible priority and return
    # ------------------------------------------------------------------
    exact_fit_mask = feasible_mask & np.isclose(slack, 0.0, atol=1e-12)
    if np.any(exact_fit_mask):
        # Very large base score for exact fits
        base_score = 1e9
        # Tie‑break by age: older bins (lower index) get a tiny advantage
        epsilon_age = 1e-7
        exact_indices = np.where(exact_fit_mask)[0]
        priorities[exact_indices] = (
            base_score
            - epsilon_age * exact_indices
            + np.random.uniform(0, 1e-6, size=exact_indices.shape)  # jitter
        )
        return priorities

    # If no feasible bins at all, keep -inf priorities
    if not np.any(feasible_mask):
        return priorities

    # --------------------------------------------------------------
    # 2) Softmax‑style scoring for feasible bins (no exact fit found)
    # --------------------------------------------------------------

    # Median slack of feasible bins (used for temperature λ)
    feasible_slack = slack[feasible_mask]
    median_slack = np.median(feasible_slack)

    # ---- EMA of median slack (maintained as a function attribute) ----
    alpha = 0.1  # smoothing factor
    if not hasattr(priority_v2, "_ema_median_slack"):
        priority_v2._ema_median_slack = median_slack
    else:
        priority_v2._ema_median_slack = (
            alpha * median_slack + (1 - alpha) * priority_v2._ema_median_slack
        )
    # Temperature λ (avoid zero)
    lam = max(priority_v2._ema_median_slack, 1e-6)

    # Softmax kernel: exp(-slack / λ) – larger for smaller slack
    exp_scores = np.exp(-slack[feasible_mask] / lam)

    # -------------------------------------------------
    # 3) Penalise new bins (bins that are still empty)
    # -------------------------------------------------
    # Estimate the full bin capacity as the maximum remaining capacity seen
    full_capacity_est = np.max(bins_remain_cap)
    # A bin is considered "new" if its remaining capacity ≈ full capacity
    new_bin_mask = np.isclose(bins_remain_cap, full_capacity_est, atol=1e-9)

    # Apply a mild penalty (e.g., 0.9) to new bins
    penalty_factor = 0.9
    new_bin_penalty = np.where(
        new_bin_mask[feasible_mask], penalty_factor, 1.0
    )
    scores = exp_scores * new_bin_penalty

    # -------------------------------------------------
    # 4) Add tiny random jitter for tie breaking
    # -------------------------------------------------
    scores += np.random.uniform(0, 1e-6, size=scores.shape)

    # -------------------------------------------------
    # 5) Tie‑break by bin age (older bins win)
    # -------------------------------------------------
    epsilon_age = 1e-7
    feasible_indices = np.where(feasible_mask)[0]
    scores = scores - epsilon_age * feasible_indices

    # Fill the priority array for feasible bins
    priorities[feasible_indices] = scores

    return priorities
```
