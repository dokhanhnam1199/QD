```python
import numpy as np

# Global random generator for optional tie‑breaking noise
_rng = np.random.default_rng()


def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    *,
    temperature: float = 0.1,
    random_noise: bool = False,
    noise_scale: float = 1e-12,
) -> np.ndarray:
    """
    Compute a softmax‑based priority vector for an online Bin Packing item.

    The function prefers bins where the item fits tightly (small slack).
    For each feasible bin we compute a logit proportional to the negative slack,
    scaled by ``temperature``.  The logits are turned into a probability‑like
    priority distribution via a numerically‑stable softmax.  Infeasible bins
    receive a priority of 0.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of the currently open bins.
    temperature : float, optional (default=0.1)
        Controls the sharpness of the softmax.  Lower values make the decision
        more deterministic (closer to a greedy Best‑Fit), while higher values
        spread the probability mass more uniformly.
    random_noise : bool, optional (default=False)
        If True, a tiny uniform noise (±``noise_scale``) is added to the logits
        of feasible bins to break ties in a reproducible stochastic way.
    noise_scale : float, optional (default=1e-12)
        Magnitude of the optional tie‑breaking noise.

    Returns
    -------
    np.ndarray
        Priority scores for each bin (same shape as ``bins_remain_cap``).  The
        scores sum to 1 across all feasible bins; infeasible bins have a score
        of 0.  The bin with the highest priority should be selected for the item.
    """
    if temperature <= 0.0:
        raise ValueError("temperature must be a positive float")

    # Ensure we work with a NumPy array of float64 for numerical stability
    caps = np.asarray(bins_remain_cap, dtype=np.float64)

    # Feasibility mask: only bins with enough remaining capacity can hold the item
    feasible = caps >= item

    # Initialise priority vector with zeros (infeasible bins stay zero)
    priorities = np.zeros_like(caps, dtype=np.float64)

    # If no bin can accommodate the item, return the zero vector
    if not np.any(feasible):
        return priorities

    # Compute slack (unused capacity after placing the item) for feasible bins
    slack = caps[feasible] - item  # non‑negative by construction

    # Logits: tighter fit (smaller slack) gets larger logit
    logits = np.full_like(caps, -np.inf, dtype=np.float64)
    logits[feasible] = -slack / temperature

    # Optional tiny noise for stochastic tie‑breaking (deterministic otherwise)
    if random_noise:
        noise = _rng.uniform(-noise_scale, noise_scale, size=logits.shape)
        logits[feasible] += noise[feasible]

    # Numerically stable softmax
    max_logit = np.max(logits[feasible])          # safe because feasible is non‑empty
    exp_shifted = np.exp(logits - max_logit)     # exp(-inf) = 0 for infeasible bins
    sum_exp = np.sum(exp_shifted)                # >0 because at least one entry is 1

    # Normalise to obtain a probability‑like priority distribution
    priorities = exp_shifted / sum_exp

    return priorities
```
