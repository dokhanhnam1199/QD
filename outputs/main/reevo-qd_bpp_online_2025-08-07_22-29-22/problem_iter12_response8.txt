```python
import numpy as np
from typing import Optional

# Global random generator for deterministic tie‑breaking noise
_GLOBAL_RNG = np.random.default_rng()


def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    *,
    temperature: float = 0.1,
    noise_scale: float = 1e-12,
    rng: Optional[np.random.Generator] = None,
) -> np.ndarray:
    """
    Compute a priority vector for online bin packing using a temperature‑controlled softmax.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of each bin.
    temperature : float, default=0.1
        Softmax temperature.  Must be positive.  Smaller values approach a
        deterministic best‑fit (bin with smallest slack); larger values give a
        more uniform distribution among feasible bins.
    noise_scale : float, default=1e-12
        Magnitude of optional uniform noise (added to logits) for tie‑breaking.
        A tiny noise makes the selection reproducible when scores would otherwise
        be identical.
    rng : np.random.Generator, optional
        Random generator for the tie‑breaking noise.  If ``None`` a module‑level
        generator is used.

    Returns
    -------
    np.ndarray
        Priority scores for each bin (same shape as ``bins_remain_cap``).  Infeasible
        bins receive a score of 0.  The scores sum to 1 across feasible bins.
    """
    # ------------------------------------------------------------------
    # Validate input
    # ------------------------------------------------------------------
    if temperature <= 0.0:
        raise ValueError("temperature must be a positive float")

    caps = np.asarray(bins_remain_cap, dtype=np.float64)

    # Identify bins that can accommodate the item
    feasible = caps >= item
    priorities = np.zeros_like(caps, dtype=np.float64)

    # No feasible bin → return all zeros
    if not np.any(feasible):
        return priorities

    # Slack (unused capacity) for feasible bins
    slack = caps[feasible] - item  # >= 0

    # ------------------------------------------------------------------
    # Deterministic best‑fit fallback for extremely low temperature
    # ------------------------------------------------------------------
    _tiny_temp = 1e-12
    if temperature < _tiny_temp:
        # Choose bin with smallest slack (best‑fit)
        best_local = np.argmin(slack)
        best_global = np.flatnonzero(feasible)[best_local]
        priorities[best_global] = 1.0
        return priorities

    # ------------------------------------------------------------------
    # Compute logits: tighter fit → larger logit
    # ------------------------------------------------------------------
    logits = np.full_like(caps, -np.inf, dtype=np.float64)
    logits[feasible] = -slack / temperature

    # Optional tie‑breaking noise
    if noise_scale > 0.0:
        if rng is None:
            rng = _GLOBAL_RNG
        noise = rng.uniform(-noise_scale, noise_scale, size=caps.shape)
        logits[feasible] += noise[feasible]

    # ------------------------------------------------------------------
    # Numerically stable softmax
    # ------------------------------------------------------------------
    max_logit = np.max(logits[feasible])
    shifted = logits - max_logit
    exp_shifted = np.exp(shifted, dtype=np.float64)

    # Sum over feasible bins (infeasible contribute zero because exp(-inf)=0)
    sum_exp = np.sum(exp_shifted[feasible])

    # Guard against pathological numerical issues
    if sum_exp <= 0.0 or not np.isfinite(sum_exp):
        # Fallback to deterministic best‑fit
        best_local = np.argmin(slack)
        best_global = np.flatnonzero(feasible)[best_local]
        priorities[best_global] = 1.0
        return priorities

    # Normalise to obtain probabilities / priority scores
    priorities[feasible] = exp_shifted[feasible] / sum_exp

    return priorities
```
