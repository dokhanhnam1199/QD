```python
import numpy as np

# Global random number generator (single instance)
_rng = np.random.default_rng()

# EMA parameters for tracking item size distribution
_alpha_ema = 0.1            # smoothing factor (0 < α ≤ 1)
_epsilon_factor = 0.05      # fraction of std used as exact‑fit tolerance
_swap_weight = 0.05         # scaling factor for swap‑improvement boost
_exact_fit_offset = 1e9     # large constant to dominate priority for exact fits
_eps_noise = 1e-6           # magnitude of random tie‑breaker

# EMA state
_ema_item_size = 0.0
_ema_item_sq = 0.0
_item_count = 0


def _update_item_stats(item: float) -> None:
    """Update exponential moving averages of item size and squared size."""
    global _ema_item_size, _ema_item_sq, _item_count
    _item_count += 1
    _ema_item_size = (1 - _alpha_ema) * _ema_item_size + _alpha_ema * item
    _ema_item_sq = (1 - _alpha_ema) * _ema_item_sq + _alpha_ema * (item *only* item)


def _current_std() -> float:
    """Return the current estimated standard deviation of item sizes."""
    var = _ema_item_sq - _ema_item_size * _ema_item_size
    if var < 0.0:
        var = 0.0
    return np.sqrt(var)


def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Adaptive priority function for online bin packing.

    The priority reflects three guiding principles:
    1. Exact fits receive a very large base score so they are always chosen.
    2. Among feasible non‑exact bins, a smaller leftover space yields a higher
       score (i.e., we aim to pack tightly).
    3. A modest boost is added when the leftover after placement is close to
       the observed mean item size (swap‑improvement heuristic).

    A tiny random perturbation breaks ties deterministically.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of the currently open bins.

    Returns
    -------
    np.ndarray
        Priority scores for each bin.  The caller should be selected the bin with
        the maximum score.  Infeasible bins receive ``-np.inf``.
    """
    # ------------------------------------------------------------------
    # 1) Update global statistics with the new item.
    # ------------------------------------------------------------------
    _update_item_stats(item)

    # Adaptive tolerance for detecting an exact fit (scaled by observed std)
    std = _current_std()
    eps = max(1e-9, _epsilon_factor * std)

    # Remaining capacity after hypothetically placing the item.
    leftover = bins_remain_cap - item

    # Feasibility mask (allow a tiny negative slack due to eps)
    feasible = leftover >= -eps

    # Initialise priorities with -inf for infeasible bins.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    if not np.any(feasible):
        # No bin can accommodate the item.
        return priorities

    # ------------------------------------------------------------------
    # 2) Exact‑fit handling.
    # ------------------------------------------------------------------
    exact_fit = feasible & (np.abs(leftover) <= eps)
    if np.any(exact_fit):
        # Large constant offset guarantees dominance; add tiny random noise
        # to break ties among multiple exact‑fit bins.
        noise = _rng.uniform(0.0, _eps_noise, size=exact_fit.sum())
        priorities[exact_fit] = _exact_fit_offset + noise

    # ------------------------------------------------------------------
    # 3) Non‑exact feasible bins.
    # ------------------------------------------------------------------
    non_exact = feasible & ~exact_fit
    if np.any(non_exact):
        # Primary component: negative leftover (smaller leftover → higher priority).
        primary = -leftover[non_exact]

        # Swap‑improvement boost: bins whose leftover is close to the
        # observed mean item size are slightly favoured.
        mean_size = _ema_item_size
        distance_to_mean = np.abs(leftover[non_exact] - mean_size)
        boost = _swap_weight / (distance_to_mean + eps)

        # Tiny random perturbation for deterministic tie‑breaking.
        noise = _rng.uniform(-_eps_noise, _eps_noise, size=non_exact.sum())

        priorities[non_exact] = primary + boost + noise

    return priorities
```
