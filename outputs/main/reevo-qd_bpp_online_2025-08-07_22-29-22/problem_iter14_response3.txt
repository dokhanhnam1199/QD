```python
import numpy as np

# Global random generator and running statistics
_rng = np.random.default_rng()
_item_count = 0
_item_sum = 0.0


def priority_v2(item: float,
                bins_remain_cap: np.ndarray,
                temperature: float = 0.1) -> np.ndarray:
    """
    Compute a probability‑like priority for each bin in an online bin‑packing
    setting.

    The priority blends several heuristics:
    * **Best‑fit** – prefers bins with smallest slack after placing the item.
    * **Adaptive noise** – injects Gaussian noise whose scale grows for small
      items and when the slack spread among feasible bins is large.
    * **Look‑ahead** – uses a running average of item sizes to slightly bias
      bins whose slack is close to the expected future item size.
    * **Tie‑breaker** – a tiny deterministic term that favours lower‑index bins.
    * **New‑bin penalty** – discourages opening a completely empty bin unless
      necessary.

    Parameters
    ----------
    item : float
        Size of the incoming item (0 < item ≤ bin capacity).
    bins_remain_cap : np.ndarray
        1‑D array of the remaining capacity of each existing bin.
    temperature : float, optional
        Softmax temperature (>0). Lower values make the decision more greedy
        (closer to deterministic best‑fit). Default is 0.1.

    Returns
    -------
    np.ndarray
        Priority scores for each bin (same shape as ``bins_remain_cap``). The
        scores sum to 1 over feasible bins; infeasible bins receive a score of
        0.
    """
    global _item_count, _item_sum

    if temperature <= 0:
        raise ValueError("temperature must be positive")

    # Ensure a 1‑D float64 array for numerical stability
    bins = np.asarray(bins_remain_cap, dtype=np.float64).ravel()
    n_bins = bins.size

    # Edge case: no bins exist yet
    if n_bins == 0:
        _item_count += 1
        _item_sum += item
        return np.empty_like(bins)

    # Feasibility mask (allow tiny tolerance for floating‑point noise)
    eps = 1e-12
    feasible = bins + eps >= item

    # Initialise priorities with zeros (infeasible bins stay zero)
    priorities = np.zeros_like(bins, dtype=np.float64)

    # If nothing fits, return zero priorities (caller may open a new bin)
    if not np.any(feasible):
        _item_count += 1
        _item_sum += item
        return priorities

    # Slack after placing the item in each feasible bin
    slack = bins[feasible] - item  # non‑negative

    # -------------------------------------------------
    # 1. Base logits: best‑fit (smaller slack → larger logit)
    # -------------------------------------------------
    base_logits = -slack / temperature

    # -------------------------------------------------
    # 2. Adaptive random noise
    # -------------------------------------------------
    # Estimate original bin capacity as the maximum remaining capacity observed.
    full_capacity = bins.max()
    # Ratio of the current item size to the (approximate) capacity
    item_ratio = min(item / full_capacity, 1.0)  # in [0, 1]

    # Slack spread among feasible bins (0 if all equal)
    slack_range = slack.max() - slack.min() if slack.size > 1 else 0.0

    # Noise scale: larger for small items and when slack spread is large
    noise_factor = 0.05
    noise_scale = noise_factor * slack_range * (1.0 - item_ratio)

    if noise_scale > 0:
        noise = _rng.normal(loc=0.0, scale=noise_scale, size=slack.shape[0])
    else:
        noise = np.zeros_like(slack)

    # -------------------------------------------------
    # 3. Look‑ahead boost using running average item size
    # -------------------------------------------------
    if _item_count > 0:
        avg_item = _item_sum / _item_count
    else:
        avg_item = item

    lookahead_weight = 0.02
    lookahead_adjust = (slack - avg_item) * lookahead_weight

    # -------------------------------------------------
    # 4. Deterministic tie‑breaker (lower index gets tiny boost)
    # -------------------------------------------------
    tie_eps = 1e-12
    tie_breaker = -np.arange(n_bins, dtype=np.float64)[feasible] * tie_eps

    # -------------------------------------------------
    # 5. Combine components into logits
    # -------------------------------------------------
    logits = base_logits + noise + lookahead_adjust + tie_breaker

    # -------------------------------------------------
    # 6. Penalty for brand‑new bins (still at full capacity)
    # -------------------------------------------------
    new_bin_mask = feasible & np.isclose(bins, full_capacity, atol=1e-12)
    if np.any(new_bin_mask):
        penalty = 0.001  # 0.1 % penalty
        logits[new_bin_mask] += np.log(1.0 - penalty)

    # -------------------------------------------------
    # 7. Softmax over feasible bins (numerically stable)
    # -------------------------------------------------
    max_logit = np.max(logits)
    exp_shifted = np.exp(logits - max_logit)
    probs = exp_shifted / np.sum(exp_shifted)

    # Fill the full priority vector
    priorities[feasible] = probs

    # -------------------------------------------------
    # 8. Update running statistics
    # -------------------------------------------------
    _item_count += 1
    _item_sum += item

    return priorities


__all__ = ["priority_v2"]
```
