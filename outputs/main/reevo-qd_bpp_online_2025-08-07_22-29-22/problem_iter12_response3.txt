```python
import numpy as np

# Global random generator reused across calls (light and fast)
_rng = np.random.default_rng()


def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Priority function for the online Bin Packing Problem.

    The function scores each existing bin for placing ``item``.
    Higher scores indicate more desirable bins.  The bin with the
    highest score should be selected.

    Scoring rules (in order of importance):
      1. Exact fits (leftover ≈ 0) get the highest score.
      2. Among feasible bins, smaller leftover space is preferred.
      3. A tiny random perturbation breaks ties.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array with the remaining capacity of each bin.

    Returns
    -------
    np.ndarray
        Priority scores for each bin (same shape as ``bins_remain_cap``).
        Infeasible bins receive ``-np.inf``.
    """
    # Ensure a NumPy array of floats
    bins = np.asarray(bins_remain_cap, dtype=float)

    # Edge case: no bins exist yet
    if bins.size == 0:
        return np.inf * np.empty(0)  # empty array of appropriate dtype

    # Tolerances
    eps = 1e-9          # for floating‑point feasibility
    eps_noise = 1e-6    # magnitude of random tie‑breaker

    # Remaining capacity if the item were placed in each bin
    leftover = bins - item

    # Feasibility mask (allow tiny negative due to rounding)
    feasible = leftover >= -eps

    # Initialise all priorities to -inf (infeasible)
    priorities = np.full_like(bins, -np.inf, dtype=float)

    # No feasible bin – return early (all -inf)
    if not np.any(feasible):
        return priorities

    # Base priority: negative leftover.
    # Exact fit → leftover ≈ 0 → priority ≈ 0 (highest among feasible).
    # Positive leftover → negative priority (lower).
    base_priority = -leftover[feasible]

    # Tiny random noise to break ties (uniform in [-eps_noise, eps_noise])
    noise = _rng.uniform(-eps_noise, eps_noise, size=base_priority.shape)

    # Combine base score with noise
    priorities[feasible] = base_priority + 0  # placeholder to keep dtype
    priorities[feasible] = base_priority + noise

    return priorities
```
