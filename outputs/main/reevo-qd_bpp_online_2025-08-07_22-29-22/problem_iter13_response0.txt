```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Compute priority scores for bins when packing an item in an online
    bin packing setting. Higher scores indicate more desirable bins.

    Scoring rules:
    - Exact fits (remaining capacity == item) receive the highest priority.
    - Among feasible bins, the one leaving the smallest slack (best‑fit)
      gets higher priority.
    - Infeasible bins receive -inf.
    - Ties are broken deterministically by preferring bins with smaller
      index (i.e., older bins) via a tiny epsilon term.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        Remaining capacities of existing bins.

    Returns
    -------
    np.ndarray
        Priority scores for each bin; higher is better.
    """
    # Slack after placing the item
    slack = bins_remain_cap - item

    # Feasibility mask
    feasible = slack >= 0

    # Base priority: -slack (smaller slack -> larger priority)
    priorities = np.where(feasible, -slack, -np.inf)

    # Exact fits get an infinite boost
    exact_fit = np.isclose(slack, 0.0)
    priorities = np.where(exact_fit, np.inf, priorities)

    # Deterministic tie‑breaker: tiny epsilon favoring lower indices (older bins)
    epsilon = 1e-12
    tie_break = epsilon * (bins_remain_cap.size - np.arange(bins_remain_cap.size))
    priorities = priorities + tie_break

    return priorities
```
