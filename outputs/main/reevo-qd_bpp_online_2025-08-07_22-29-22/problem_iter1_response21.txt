```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Return priority scores for bin placement using a Best‑Fit rule.

    The strategy gives higher priority to bins that will have the smallest
    remaining capacity after the item is inserted.  Bins that cannot
    accommodate the item receive a very low score.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array holding the remaining capacity of each open bin.

    Returns
    -------
    priorities : np.ndarray
        An array of the same shape as ``bins_remain_cap`` with a numeric
        priority for each bin.  The bin with the maximum priority will
        be chosen by the caller.  Bins that cannot take the item will
        get a score of ``-np.inf``.
    """
    # Ensure the input is a float array (in case the caller passes ints)
    bins = np.asarray(bins_remain_cap, dtype=float)
    n = bins.size

    # Fast path for an empty bin list – typical for the very first item.
    if n == 0:
        return np.empty(0, dtype=float)

    # Initialise all priorities to a very low value.
    priorities = np.full(n, -np.inf, dtype=float)

    # Identify bins that can accommodate the item
    can_place = bins >= item
    if not np.any(can_place):
        return priorities  # nothing can take the item

    # Remaining capacity after the item would be inserted
    leftover = bins[can_place] - item

    # Small deterministic bias – earlier bins get slightly higher priority
    # for bins with exactly the same leftover.  This keeps the behaviour
    # reproducible across runs.
    indices = np.arange(n)[can_place]
    priorities[can_place] = -leftover - 1e-7 * indices

    return priorities
```
