```python
import numpy as np

def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    *,
    temperature: float = 0.1,
    random_noise: bool = False,
    noise_scale: float = 1e-12,
) -> np.ndarray:
    """
    Compute a softmax‑based priority vector for an online Bin Packing item.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of the currently open bins.
    temperature : float, optional (default=0.1)
        Controls the sharpness of the softmax.  Smaller values make the decision
        more deterministic (closer to greedy Best‑Fit), while larger values
        spread the probability mass more uniformly.
    random_noise : bool, optional (default=False)
        If True, adds a tiny uniform noise (±``noise_scale``) to the logits of
        feasible bins to break ties stochastically.
    noise_scale : float, optional (default=1e-12)
        Magnitude of the optional tie‑breaking noise.

    Returns
    -------
    np.ndarray
        Priority scores for each bin (same shape as ``bins_remain_cap``).  The
        scores sum to 1 across all feasible bins; infeasible bins have a score
        of 0.  The bin with the highest priority should be selected for the item.
    """
    if temperature <= 0.0:
        raise ValueError("temperature must be a positive float")

    # Ensure a 1‑D NumPy array of float64 for numerical stability
    caps = np.asarray(bins_remain_cap, dtype=np.float64).ravel()

    # Feasibility mask: only bins with enough remaining capacity can hold the item
    feasible = caps >= item

    # Initialise priority vector with zeros (infeasible bins stay zero)
    priorities = np.zeros_like(caps, dtype=np.float64)

    # If no bin can accommodate the item, return the zero vector
    if not np.any(feasible):
        return priorities

    # Slack (unused capacity) after placing the item for feasible bins
    slack = caps[feasible] - item  # non‑negative by construction

    # Logits: tighter fit (smaller slack) gets larger logit
    logits = np.full_like(caps, -np.inf, dtype=np.float64)
    logits[feasible] = -slack / temperature

    # Optional tiny noise for stochastic tie‑breaking (deterministic otherwise)
    if random_noise:
        rng = np.random.default_rng()
        noise = rng.uniform(-noise_scale, noise_scale, size=logits.shape)
        logits[feasible] += noise[feasible]

    # Numerically stable softmax
    max_logit = np.max(logits[feasible])  # safe because feasible is non‑empty
    exp_shifted = np.exp(logits - max_logit)  # exp(-inf) = 0 for infeasible bins
    sum_exp = np.sum(exp_shifted)            # >0 because at least one feasible bin

    priorities = exp_shifted / sum_exp
    return priorities
```
