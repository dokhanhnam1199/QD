```python
import numpy as np

# Global RNG for optional random tie‑breaking
_rng = np.random.default_rng()


def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    temperature: float = 0.1,
    epsilon: float = 1e-12,
) -> np.ndarray:
    """
    Compute a priority vector for the online Bin Packing problem.

    Each bin receives a score proportional to how tightly the item would fit.
    Scores are obtained by a temperature‑controlled softmax over the negative
    slack (remaining capacity after placement).  Infeasible bins get a priority
    of 0.  A small multiplicative random perturbation (controlled by ``epsilon``)
    breaks ties and adds exploration.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of the current bins.
    temperature : float, optional
        Softmax temperature > 0.  Smaller values make the decision more
        deterministic (closer to classic Best‑Fit); larger values smooth the
        distribution for more exploration.
    epsilon : float, optional
        Scale of random perturbation for tie‑breaking.  Set to 0 to disable.

    Returns
    -------
    np.ndarray
        Priority scores for each bin.  The vector sums to 1 over feasible bins,
        while infeasible bins have priority 0.
    """
    if temperature <= 0:
        raise ValueError("temperature must be positive")

    # Ensure a NumPy float array for vectorised operations
    caps = np.asarray(bins_remain_cap, dtype=np.float64)

    # Feasibility mask: item can only be placed in bins with enough capacity
    feasible = caps >= item

    # Initialise priority vector with zeros (infeasible bins stay zero)
    priorities = np.zeros_like(caps, dtype=np.float64)

    # If no bin can accommodate the item, return the zero vector (caller may open a new bin)
    if not np.any(feasible):
        return priorities

    # Slack = leftover capacity after placing the item (only for feasible bins)
    slack = caps[feasible] - item  # non‑negative by construction

    # Logits: tighter fits (smaller slack) get larger logits
    logits = -slack / temperature

    # Stabilise softmax: subtract max logit to avoid overflow
    max_logit = np.max(logits)
    stable_logits = logits - max_logit

    # Softmax exponentials
    exp_logits = np.exp(stable_logits)

    # Optional random perturbation for tie‑breaking (multiplicative noise)
    if epsilon > 0:
        noise = 1.0 + epsilon * _rng.random(exp_logits.shape, dtype=np.float64)
        exp_logits *= noise

    # Normalise to obtain a probability‑like priority vector
    sum_exp = exp_logits.sum()
    if sum_exp > 0:
        priorities[feasible] = exp_logits / sum_exp

    return priorities
```
