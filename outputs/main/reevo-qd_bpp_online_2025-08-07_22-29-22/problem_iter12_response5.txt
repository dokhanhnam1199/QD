```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Compute priority for each bin in an online bin‑packing scenario.

    Parameters
    ----------
    item : float
        Size of the item to pack.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of existing bins.

    Returns
    -------
    np.ndarray
        Priority scores for each bin.  A higher score means the bin is more
        desirable.  Infeasible bins receive -np.inf.
    """
    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)

    # Remaining capacity if we were to place the item
    leftover = bins_remain_cap - item

    # Feasibility: only bins with non‑negative leftover can host the item
    feasible = leftover >= 0

    # Base priority: larger for bins with less leftover (best fit)
    priorities = -leftover
    # Infeasible bins are set to -inf
    priorities[~feasible] = -np.inf

    # Penalty for brand‑new bins: those with remaining capacity equal to the
    # maximum remaining capacity seen (within a tiny tolerance).
    if bins_remain_cap.size > 0:
        max_cap = bins_remain_cap.max()
        # Use isclose to avoid issues with floating‑point round‑off
        new_bins = np.isclose(bins_remain_cap, max_cap, atol=1e-9)
        # Only penalize bins that are feasible and truly new
        mask_new_feasible = feasible & new_bins
        # Small penalty: reduce priority by a tiny constant
        penalty = 1e-3
        priorities[mask_new_feasible] -= penalty

    # Deterministic tie‑breaker: prefer lower‑index bins by adding a tiny
    # decreasing offset (negative small epsilon times index).
    tie_breaker = -np.arange(bins_remain_cap.size) * 1e-12
    priorities += tie_breaker

    return priorities
```
