```python
import numpy as np

# Global random generator to avoid reseeding on every call
_rng = np.random.default_rng()

def priority_v2(item: float,
                bins_remain_cap: np.ndarray,
                bin_ages: np.ndarray | None = None,
                age_weight: float = 1e-3,
                tie_break_noise: float = 1e-6) -> np.ndarray:
    """
    Priority function for online Bin Packing.

    This heuristic prefers bins that become as full as possible after
    placing the item (i.e. minimal remaining slack).  To break ties between
    equally good bins a small random noise is added.  Additionally an age‑penalty
    is subtracted from the priority to discourage over‑use of older bins,
    reducing systematic bias toward early bins.

    # Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities for each existing bin.
    bin_ages : np.ndarray | None, optional
        1‑D array giving the “age” of each bin (e.g. number of packing steps
        since the bin was opened).  If ``None`` the index of the bin is used
        as a proxy for age (higher index → newer bin).  Larger values indicate
        older bins.
    age_weight : float, optional
        Weight applied to the age penalty.  Larger values increase the
        influence of age in the priority calculation.
    tie_break_noise : float, optional
        Scale of the random noise used for tie‑breaking.  The noise is drawn
        from a uniform distribution on ``[0, tie_break_noise)`` and added to
        the priority after the age penalty.

    Returns
    -------
    np.ndarray
        Priority scores for each bin; higher values indicate more desirable
        bins.  Bins that cannot accommodate the item receive a priority of
        ``-np.inf``.
    """
    # Compute slack after placing the item
    slack = bins_remain_cap - item

    # Feasibility mask: only bins with non‑negative slack can receive the item
    feasible_mask = slack >= 0

    # Base priority: negative slack (smaller slack → larger priority)
    # Initialise with -inf for infeasible bins
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)
    priorities[feasible_mask] = -slack[feasible_mask]

    # Determine ages; if not provided, use index (older bins have smaller index)
    if bin_ages is None:
        # Use the bin index as a proxy for age; larger index = newer bin
        ages = np.arange(bins_remain_cap.shape[0], dtype=float)
    else:
        ages = np.asarray(bin_ages, dtype=float)

    if ages.shape != bins_remain_cap.shape:
        raise ValueError("bin_ages must have the same shape as bins_remain_cap")

    # Apply age penalty: older bins (larger age) receive a larger penalty.
    # Only adjust feasible bins
    priorities[feasible_mask] -= age_weight * ages[feasible_mask]

    # Random tie‑break noise (small positive value) for feasible bins
    if tie_break_noise > 0:
        noise = _rng.random(size=bins_remain_cap.shape) * tie_break_noise
        priorities[feasible_mask] += noise[feasible_mask]

    return priorities
```
