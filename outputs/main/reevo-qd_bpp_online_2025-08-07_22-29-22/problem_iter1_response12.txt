```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Compute priority scores for each bin following a Worst‑Fit strategy.

    For each bin that can accommodate `item`, its priority is the remaining
    capacity after the item would be placed. Bins that cannot hold the
    item receive a very large negative priority so they are never selected.

    A tiny random perturbation is added to the priority to guarantee a
    unique maximum in the event of a tie, without affecting the Worst‑Fit
    ordering in practice.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        Remaining capacities of all current bins.

    Returns
    -------
    np.ndarray
        Array of priority scores, one per bin.
    """
    rc = bins_remain_cap.astype(np.float64, copy=False)

    # Start with a very low default score.
    priorities = np.full_like(rc, -np.inf, dtype=np.float64)

    # Bins that can fit the item.
    fit_mask = rc >= item
    priorities[fit_mask] = rc[fit_mask] - item

    # Tiny random noise to break ties deterministically.
    rng = np.random.default_rng(seed=None)
    priorities += 1e-12 * rng.standard_normal(rc.shape)

    return priorities
```
