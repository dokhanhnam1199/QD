```python
import numpy as np

# Global RNG for optional tie‑breaking noise
_rng = np.random.default_rng()

# Running statistics of observed item sizes (past items only)
_item_count = 0
_item_sum = 0.0

def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    *,
    temperature: float = 0.1,
    random_noise: bool = True,
    noise_scale: float = 1e-12,
    future_weight: float = 0.02
) -> np.ndarray:
    """
    Compute a priority vector for an online Bin Packing item.

    The priority is based on a softmax over the negative slack
    (i.e. how tightly the item fits into each bin).  A small
    deterministic noise can be added to break ties.
    A look‑ahead adjustment encourages bins that still have
    room for a typical future item.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of the currently open bins.
    temperature : float, optional
        Controls the sharpness of the softmax.  Lower values make
        the decision closer to a greedy Best‑Fit.  Must be > 0.
    random_noise : bool, optional
        If True, a tiny uniform noise (±``noise_scale``) is added to
        the logits of feasible bins to break ties in a reproducible
        stochastic way.
    noise_scale : float, optional
        Magnitude of the optional tie‑breaking noise.
    future_weight : float, optional
        Weight for the look‑ahead adjustment based on the running
        average item size.

    Returns
    -------
    np.ndarray
        Priority scores for each bin (same shape as ``bins_remain_cap``).
        Feasible bins have non‑zero scores that sum to 1; infeasible bins
        have a score of 0.  The bin with the highest score should be
        selected for the item.
    """
    global _item_count, _item_sum

    # Ensure we are working with a NumPy array of floats
    caps = np.asarray(bins_remain_cap, dtype=np.float64)
    n = caps.size

    # Handle empty bin list
    if n == 0:
        return np.array([], dtype=np.float64)

    if temperature <= 0.0:
        raise ValueError("temperature must be a positive float")

    # Feasibility mask: only bins with enough remaining capacity can hold the item
    feasible = caps >= item

    # Initialise priority vector with zeros (infeasible bins stay zero)
    priorities = np.zeros_like(caps, dtype=np.float64)

    # If no bin can accommodate the item, return the zero vector
    if not np.any(feasible):
        return priorities

    # Compute average item size from past items only
    if _item_count > 0:
        avg_item = _item_sum / _item_count
    else:
        avg_item = item  # fallback for the first item

    # Compute slack (unused capacity after placing the item) for feasible bins
    slack = caps[feasible] - item  # non‑negative by construction

    # Look‑ahead adjustment based on running average of item sizes
    future_adjust = (slack - avg_item) * future_weight

    # Logits: tighter fit (smaller slack) gets larger logit
    logits = -slack / temperature + future_adjust

    # Assemble full logits array (inf for infeasible bins)
    full_logits = np.full_like(caps, -np.inf, dtype=np.float64)
    full_logits[feasible] = logits

    # Optional tiny noise for deterministic tie‑breaking (if requested)
    if random_noise:
        noise = _rng.uniform(-noise_scale, noise_scale, size=full_logits.shape)
        full_logits[feasible] += noise[feasible]

    # Numerically stable softmax
    max_logit = np.max(full_logits[feasible])  # safe because feasible is non‑empty
    exp_shifted = np.exp(full_logits - max_logit)  # inf -> 0 for infeasible bins
    sum_exp = np.sum(exp_shifted[feasible])        # >0 because at least one entry is finite

    # Normalise to obtain a probability‑like priority distribution
    priorities[feasible] = exp_shifted[feasible] / sum_exp

    # Update statistics with the current item
    _item_count += 1
    _item_sum += item

    return priorities
```
