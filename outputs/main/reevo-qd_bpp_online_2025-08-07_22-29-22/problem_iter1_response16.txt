```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Compute a sigmoid‑based priority score for placing ``item`` into each bin.

    The score favours bins that will have a small residual capacity after
    packing the item (tight fit).  The relationship between residual capacity
    and priority is shaped by a logistic (sigmoid) function:

        score = 1 / (1 + exp(-k * (τ - r̂)))

    where:
        r̂ = (remaining_capacity - item) / Ĉ  is the normalized residual,
        Ĉ = max(bins_remain_cap) + item         an estimate of the true bin
                                                   capacity,
        τ  = tolerance (fraction of capacity we consider “tight”),
        k  = steepness controlling how sharply the score drops when
             residual exceeds the tolerance.

    Infeasible bins (where the item does not fit) receive a very low priority
    (‑inf) so they are never selected.

    Parameters
    ----------
    item : float
        Size of the item to be placed.
    bins_remain_cap : np.ndarray
        1‑D array containing the remaining free capacity of each bin.

    Returns
    -------
    np.ndarray
        Array of priority scores of the same shape as ``bins_remain_cap``.
    """
    # Ensure proper dtype for vectorised arithmetic.
    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)

    # Compute remaining capacity after the candidate placement.
    residual = bins_remain_cap - item

    # Feasibility mask – bins where the item fits.
    feasible = residual >= 0.0

    # Estimate the original bin capacity.
    # Adding ``item`` guarantees that an empty bin (full capacity) yields Ĉ ≈ bin_capacity.
    est_capacity = np.max(bins_remain_cap) + item

    # Normalised residual (fraction of estimated capacity left after placement).
    # Clip to [0, 1] for numerical stability.
    norm_residual = np.clip(residual / est_capacity, 0.0, 1.0)

    # Sigmoid hyper‑parameters.
    steepness = 12.0   # Controls the sharpness of the transition.
    tolerance = 0.10   # Desired maximal leftover fraction (10 % of capacity).

    # Compute sigmoid‑based scores.
    # High score when normalized residual ≤ tolerance, low otherwise.
    scores = np.full_like(bins_remain_cap, fill_value=-np.inf, dtype=float)
    scores[feasible] = 1.0 / (1.0 + np.exp(-steepness * (tolerance - norm_residual[feasible])))

    return scores
```
