```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Inverse‑distance (Proximity‑Fit) priority for online Bin Packing.

    For each bin we compute the leftover capacity after placing the item:
        diff = bins_remain_cap - item

    Bins that can accommodate the item (diff >= 0) receive a priority equal to the
    inverse of this leftover space (larger when the fit is tighter).  Bins that
    cannot accommodate the item get a very low priority so they will never be
    selected.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        Remaining capacities of the bins (one entry per bin).

    Returns
    -------
    np.ndarray
        Priority scores for each bin; higher scores indicate a more desirable
        bin for this item.
    """
    # Ensure we work with floats to avoid integer division issues
    # (especially when bins_remain_cap is integer typed)
    caps = bins_remain_cap.astype(float)

    # Remaining space after hypothetically placing the item
    diff = caps - item

    # Feasibility mask: True for bins that can accept the item
    can_fit = diff >= 0

    # Small epsilon to avoid division by zero when diff == 0 (perfect fit)
    eps = 1e-12

    # Initialise priority array
    priorities = np.full_like(caps, -np.inf, dtype=float)

    # Inverse distance for feasible bins: tighter fit → larger priority
    priorities[can_fit] = 1.0 / (diff[can_fit] + eps)

    # OPTIONAL: break ties by favouring bins that are already more filled.
    # This can be done by adding a tiny bias proportional to the used capacity.
    # used = 1.0 - caps / caps.max()  # normalized usage (0 = empty, 1 = full)
    # priorities[can_fit] += 1e-6 * used[can_fit]

    return priorities
```
