```python
import numpy as np

# ----------------------------------------------------------------------
# Global configuration and EMA state (shared across calls)
# ----------------------------------------------------------------------
_alpha_ema = 0.1               # smoothing factor for EMA of item sizes
_epsilon_factor = 0.05         # fraction of EMA std used as exact‑fit tolerance
_exact_fit_offset = 1e9        # huge offset to force exact‑fit selection
_new_bin_penalty = 0.01        # 1 % penalty for untouched (full‑capacity) bins
_random_tie_eps = 1e-6         # scale of random tie‑breaker (multiplicative)
_tie_break_eps = 1e-12         # deterministic tie‑breaker (index‑based)

# Random generator for minimal stochastic tie‑breaking
_rng = np.random.default_rng()

# EMA statistics for observed item sizes
_ema_mean = 0.0
_ema_sq = 0.0
_item_count = 0


def _update_item_stats(item: float) -> None:
    """Update exponential moving averages for the incoming item size."""
    global _ema_mean, _ema_sq, _item_count
    _item_count += 1
    _ema_mean = (1 - _alpha_ema) * _ema_mean + _alpha_ema * item
    _ema_sq = (1 - _alpha_ema) * _ema_sq + _alpha_ema * (item * item)


def _current_std() -> float:
    """Return the current EMA‑based estimate of the standard deviation."""
    var = _ema_sq - _ema_mean * _ema_mean
    if var < 0.0:
        var = 0.0
    return np.sqrt(var)


def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Adaptive priority function for the online Bin Packing problem.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of the current bins.

    Returns
    -------
    np.ndarray
        Priority values for each bin (same shape as ``bins_remain_cap``).
        Infeasible bins receive ``-np.inf``.  The bin with the highest
        priority should be chosen for placement.
    """
    # ------------------------------------------------------------------
    # 1. Update EMA statistics for the incoming item
    # ------------------------------------------------------------------
    _update_item_stats(item)

    # Tolerance for exact‑fit detection (based on EMA std)
    std_est = _current_std()
    eps_fit = max(1e-9, _epsilon_factor * std_est)

    # ------------------------------------------------------------------
    # 2. Compute slack and feasibility
    # ------------------------------------------------------------------
    caps = np.asarray(bins_remain_cap, dtype=np.float64)
    slack = caps - item                       # remaining capacity after placement
    feasible = slack >= -eps_fit              # allow tiny negative due to tolerance

    # Initialise priorities: infeasible bins get -inf
    priorities = np.full_like(caps, -np.inf, dtype=np.float64)

    if not np.any(feasible):
        # No bin can accommodate the item – caller may open a new bin
        return priorities

    # ------------------------------------------------------------------
    # 3. Exact‑fit handling
    # ------------------------------------------------------------------
    exact_fit = feasible & (np.abs(slack) <= eps_fit)
    if np.any(exact_fit):
        # Deterministic tie‑breaker: lower index gets a tiny boost
        idx_exact = np.nonzero(exact_fit)[0].astype(np.float64)
        priorities[exact_fit] = _exact_fit_offset - _tie_break_eps * idx_exact

    # ------------------------------------------------------------------
    # 4. Scoring of non‑exact feasible bins
    # ------------------------------------------------------------------
    non_exact = feasible & ~exact_fit
    if np.any(non_exact):
        # Adaptive temperature: median slack among all feasible bins
        median_slack = np.median(slack[feasible])
        temperature = max(median_slack, 1e-6)   # avoid division by zero

        # Logits: tighter fits (smaller slack) get larger logits
        logits = -slack[non_exact] / temperature

        # Stable softmax (subtract max logit)
        max_logit = np.max(logits)
        stable_logits = logits - max_logit
        exp_logits = np.exp(stable_logits)

        # Minimal random tie‑breaker (multiplicative noise)
        if _random_tie_eps > 0:
        # It seems there is an issue here, as the line is not properly completed. 
        # Let me fix it.

        # Minimal random tie‑breaker (multiplicative noise)
        if _random_tie_eps > 0:
            noise = 1.0 + _random_tie_eps * _rng.random(exp_logits.shape, dtype=np.float64)
            exp_logits *= noise

        # Penalise brand‑new bins (still at full capacity)
        # Estimate bin capacity as the maximum remaining capacity observed
        bin_capacity_est = np.max(caps)
        new_bin_mask = np.isclose(caps, bin_capacity_est) & non_exact
        if np.any(new_bin_mask):
            # Identify positions of new bins within the non‑exact subset
            non_exact_indices = np.nonzero(non_exact)[0]
            new_bin_indices = np.nonzero(new_bin_mask)[0]
            # Mask aligning with exp_logits order
            penalty_mask = np.isin(non_exact_indices, new_bin_indices)
            exp_logits[penalty_mask] *= (1.0 - _new_bin_penalty)

        # Deterministic tie‑breaker for non‑exact bins (favor lower index)
        non_exact_indices = np.nonzero
        # This line seems unfinished and erroneous; we need to correctly compute tie‑breaker.

        # Deterministic tie‑breaker for non‑exact bins (favor lower index)
        non_exact_indices = np.nonzero(non_exact)[0].astype(np.float64)
        exp_logits -= _tie_break_eps * non_exact_indices

        # Assign computed scores back to the priority vector
        priorities[non_exact] = exp_logits

    return priorities
```
