```python
import numpy as np

# Single random generator – reused on every call (no reseeding)
_rng = np.random.default_rng()

# Simple running statistics of items seen so far (used for a lightweight look‑ahead)
_item_count = 0
_item_sum = 0.0


def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Hybrid priority for the online Bin Packing Problem.

    Combines a best‑fit score with:
      • a controlled random perturbation (more randomness for small items),
      • a deterministic tie‑breaker that favours lower‑index bins,
      • a look‑ahead term based on the running average size of previously
        observed items.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array with the remaining capacity of each existing bin.

    Returns
    -------
    np.ndarray
        Priority scores for each bin (same shape as ``bins_remain_cap``).
        Higher values are preferred; infeasible bins receive ``-np.inf``.
    """
    global _item_count, _item_sum

    # Normalise input
    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)

    # No existing bins – caller will open a new one.
    if bins_remain_cap.size == 0:
        _item_count += 1
        _item_sum += item
        return np.array([], dtype=float)

    # --- 1: feasibility -------------------------------------------------
    leftover = bins_remain_cap - item               # capacity that would remain
    feasible = leftover >= 0                         # True for bins that can host the item

    # Initialise with -inf (worst possible score)
    priorities = np.full(bins_remain_cap.shape, -np.inf, dtype=float)

    # If nothing fits, just record statistics and return.
    if not np.any(feasible):
        _item_count += 1
        _item_sum += item
        return priorities

    # --- 2: best‑fit base score -----------------------------------------
    # Higher score ↔ tighter fit (smaller leftover)
    base_score = -leftover[feasible]                # negative leftover

    # --- 3: controlled randomness ----------------------------------------
    # Rough estimate of the true bin capacity (most empty bin + current item)
    approx_capacity = bins_remain_cap.max() + item
    approx_capacity = max(approx_capacity, 1.0)     # guard against degenerate zero

    # Item‑size ratio: larger items → less randomness
    item_ratio = item / approx_capacity

    # Scale random noise relative to the spread of leftover space
    leftover_feas = leftover[feasible * 1]  # alias for readability
    leftover_range = leftover_feas.max() - leftover_feas.min()
    noise_scale = leftover_range * 0.05 * (1.0 - item_ratio)
    noise_scale = max(noise_scale, 0.0)

    random_noise = _rng.random(leftover_feas.shape) * noise_scale

    # --- 4: look‑ahead using running average item size -------------------
    if _item_count > 0:
        avg_item = _item_sum / _item_count
    else:
        avg_item = item   # first item – fall back to its own size

    # Small boost for bins that would still have room for a typical future item
    # (positive if leftover > avg_item, negative otherwise)
    future_weight = 0.02                         # tiny constant factor
    future_adjust = (leftover_feas - avg_item) * future_weight

    # --- 5: deterministic tie‑breaker ------------------------------------
    # Slightly penalise higher indices to break exact ties deterministically
    tie_breaker = -np.arange(bins_remain_cap.size, dtype=float) * 1e-12

    # --- 6: combine all components ---------------------------------------
    priorities[feasible] = (
        base_score
        + random_noise
        + future_adjust
        + tie_breaker[feasible]
    )

    # Record the current item for future look‑ahead calculations
    _item_count += 1
    _item_sum += item

    return priorities
```
