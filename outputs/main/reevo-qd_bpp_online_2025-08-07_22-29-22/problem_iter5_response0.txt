```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Adaptive priority function for online Bin Packing.

    Scores feasible bins (those with enough remaining capacity) using a
    temperature‑controlled softmax over the negative slack (i.e., the space
    that would remain after placing the item).  A tiny penalty is applied to
    brand‑new bins (still at full capacity) to encourage reuse of older bins,
    and a minuscule index‑based offset breaks ties deterministically
    (lower index = older bin).

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities for each bin.

    Returns
    -------
    np.ndarray
        Priority score for each bin.  Higher values indicate a more preferred
        bin; infeasible bins receive ``-np.inf``.
    """
    # Compute remaining slack after placing the item
    slack = bins_remain_cap - item

    # Feasible bins have non‑negative slack
    feasible_mask = slack >= 0

    # Initialise priority array with -inf for infeasible bins
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # If no bin can accommodate the item, return early (caller may open a new bin)
    if not np.any(feasible_mask):
        return priorities

    # Base score: negative slack (smaller slack → larger score)
    base_score = -slack[feasible_mask]

    # Adaptive temperature λ: median slack among feasible bins (avoid zero)
    median_slack = np.median(slack[feasible_mask])
    temperature = max(median_slack, 1e-6)

    # Softmax‑like transformation: larger for smaller slack
    soft_scores = np.exp(base_score / temperature)

    # Assign soft scores to the priority vector
    priorities[feasible_mask] = soft_scores

    # Estimate full bin capacity (maximum remaining capacity corresponds to an empty bin)
    bin_capacity_est = np.max(bins_remain_cap)

    # Identify brand‑new bins (still at full capacity) among feasible bins
    new_bin_mask = np.isclose(bins_remain_cap, bin_capacity_est) & feasible_mask

    # Apply a tiny penalty to new bins to encourage reuse of older bins
    new_bin_penalty = 1e-3  # 0.1 % reduction for new bins
    priorities[new_bin_mask] *= (1.0 - new_bin_penalty)

    # Deterministic tie‑
    # breaker: older bins (lower index) get a minuscule boost
    epsilon = 1e-9
    indices = np.arange(bins_remain_cap.shape[0], dtype=float)
    priorities[feasible_mask] -= epsilon * indices[feasible_mask]

    return priorities
```
