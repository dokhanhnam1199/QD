```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    import numpy as np
    # Compute slack after placing the item
    slack = bins_remain_cap - item
    feasible_mask = slack >= 0

    # Base scores initialized to -inf for infeasible bins
    scores = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)

    if np.any(feasible_mask):
        # Adaptive temperature λ based on the average slack of feasible bins
        mean_slack = np.mean(slack[feasible_mask])
        lam = max(mean_slack, 1e-6)  # avoid division by zero

        # Soft‑max weight favouring tight fits (smaller slack → larger weight)
        weight = np.exp(-slack[feasible_mask] / lam)

        # Small age penalty: older bins (smaller index) get slightly higher priority
        indices = np.arange(len(bins_remain_cap))
        age_penalty = 1e-4 * indices  # tune this factor as needed

        # Tiny random tie‑break to avoid deterministic ties
        noise = np.random.uniform(-1e-6, 1e-6, size=weight.shape)

        # Final priority: weight minus age penalty plus noise
        scores[feasible_mask] = weight - age_penalty[feasible_mask] + noise

    return scores
```
