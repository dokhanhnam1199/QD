```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Adaptive priority function for online Bin Packing (v2).

    Scoring strategy:
    1. Compute the slack (remaining capacity after placing the item) for each bin.
    2. Feasible bins (slack >= 0) receive a softmax‑like score based on the
       negative slack.  Smaller slack → larger score.
    3. The temperature of the softmax is the median slack among feasible bins,
       guaranteeing a scale‑free transformation and handling both tight and loose
       fits.  A tiny floor prevents division by zero.
    4. Brand‑new (empty) bins are penalised slightly to encourage reuse of
       already opened bins.
    5. A deterministic tie‑breaker favours older bins (lower index) by
       subtracting a minute index‑dependent offset.
    6. Infeasible bins receive ``-np.inf`` so they are never selected.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities for each existing bin.

    Returns
    -------
    np.ndarray
        Priority scores for each bin; higher scores indicate a more preferred bin.
    """
    # 1. Slack after hypothetically placing the item
    slack = bins_remain_cap - item

    # 2. Feasibility mask (allow a tiny tolerance for floating‑point noise)
    feasible = slack >= -1e-12
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    if not np.any(feasible):
        # No bin can accommodate the item; caller may open a new bin.
        return priorities

    # 3. Base score: negative slack (smaller slack ⇒ larger base score)
    base_score = -slack[feasible]

    # 4. Adaptive temperature: median slack among feasible bins (avoid zero)
    median_slack = np.median(slack[feasible])
    temperature = max(median_slack, 1e-6)  # floor to keep denominator safe

    # 5. Softmax‑like transformation (larger for smaller slack)
    soft_scores = np.exp(base_score / temperature)
    priorities[feasible] = soft_scores

    # 6. Penalise brand‑new bins (still at full capacity) to favour reuse.
    # Estimate the bin capacity as the maximum remaining capacity observed.
    bin_capacity_est = np.max(bins_remain_cap)
    new_bin_mask = feasible & np.isclose(bins_remain_cap, bin_capacity_est, atol=1e-12)
    new_bin_penalty = 1e-3  # 0.1 % reduction
    priorities[new_bin_mask] *= (1.0 - new_bin_penalty)

    # 7. Deterministic tie‑breaker: lower index gets a tiny boost.
    epsilon = 1e-9
    indices = np.arange(bins_remain_cap.shape[0], dtype=float)
    priorities[feasible] -= epsilon * indices[feasible]

    # (Optional) Minimal random noise could be added here if desired,
    # but the deterministic offset already resolves ties.

    return priorities
```
