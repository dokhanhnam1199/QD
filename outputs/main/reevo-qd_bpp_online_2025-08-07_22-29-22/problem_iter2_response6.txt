```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray, eps: float = 1e-9) -> np.ndarray:
    """
    Compute priority scores for an online Bin Packing problem.

    The priority ordering is:
    * Bins that cannot accommodate the item receive -inf (worst possible priority).
    * Bins where the item fits exactly (within tolerance `eps`) receive the highest
      finite priority, zero.
    * Among the remaining feasible bins the priority is the negative leftover
      capacity (i.e. - (remaining_capacity - item)).  The smaller the waste,
      the larger (less negative) the priority.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of the remaining capacities of the existing bins.
    eps : float, optional
        Tolerance for floating‑point comparisons.  Defaults to 1e‑9.

    Returns
    -------
    np.ndarray
        Array of the same shape as ``bins_remain_cap`` containing the priority
        score for each bin.  The caller should select the bin with the maximum
        score.
    """
    # Ensure input is a NumPy array of floats
    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)

    # Remaining capacity after (theoretically) placing the item in each bin
    leftover = bins_remain_cap - item

    # Compute priorities using vectorised conditional logic
    priorities = np.where(
        leftover < -eps,                     # Infeasible bin
        -np.inf,
        np.where(
            np.abs(leftover) <= eps,         # Exact fit (within tolerance)
            0.0,
            -leftover                        # Feasible but not exact: negative waste
        )
    )

    # Ensure output dtype is float
    return priorities.astype(float)
```
