```python
import numpy as np

# Global RNG for tie‑breaking jitter (initialized once)
_rng = np.random.default_rng()


def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Hybrid sigmoid slack scoring with size‑ratio weighting and jitter for online bin packing.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of each currently open bin.

    Returns
    -------
    np.ndarray
        Priority scores for each bin (higher is better). 0 for infeasible bins.
        The caller should select the bin with the maximum score.
    """
    # Ensure input is a NumPy float array
    caps = np.asarray(bins_remain_cap, dtype=float)

    # Edge case: no bins present
    if caps.size == 0:
        return np.empty_like(caps)

    # Slack after placing the item (negative = infeasible)
    slack = caps - item

    # Feasibility mask
    feasible = slack >= 0.0
    if not np.any(feasible):
        # No open bin can accommodate the item – return zeros so a new bin can be opened
        return np.zeros_like(caps)

    # Slack values for feasible bins only
    slack_feas = slack[feasible]

    # Adaptive sigmoid parameters
    median_slack = np.median(slack_feas)
    slack_range = slack_feas.max() - slack_feas.min()
    alpha = 8.0 / slack_range if slack_range > 1e-12 else 1.0

    # Logistic function decreasing with slack
    exp_arg = np.clip(alpha * (slack_feas - median_slack), -50.0, 50.0)
    sigmoid_scores = 1.0 / (1.0 + np.exp(exp_arg))

    # Size‑ratio weighting: fraction of the remaining capacity that the item will occupy
    size_ratio = item / caps[feasible]
    # Guard against division by zero (should not happen if feasible)
    size_ratio = np.where(size_ratio > 0, size_ratio, 0.0)

    # Combine components
    scores = sigmoid_scores * size_ratio

    # Add a tiny random jitter (≤1e‑9) for deterministic tie‑breaking
    jitter = _rng.random(scores.shape) * 1e-9
    scores += jitter

    # Build full priority array
    priorities = np.zeros_like(caps)
    priorities[feasible] = scores

    # Normalise to sum to 1 over feasible bins
    total = scores.sum()
    if total > 0.0:
        priorities[feasible] /= total
    else:
        # Fallback: uniform distribution over feasible bins
        num_feasible = feasible.sum()
        priorities[feasible] = 1.0 / num_feasible

    return priorities
```
