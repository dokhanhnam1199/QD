```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray, temperature: float = 0.1) -> np.ndarray:
    """
    Priority scores for online bin packing based on a temperature‑scaled softmax.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of the current bins.
    temperature : float, optional (default=0.1)
        Smoothing parameter (>0).  Lower values make the priority more deterministic
        (closer to a greedy best‑fit), while higher values spread the priority more
        uniformly.

    Returns
    -------
    np.ndarray
        Priority scores for each bin.  Infeasible bins receive a priority of 0.
        The bin with the highest score should be selected for the item.
    """
    if temperature <= 0:
        raise ValueError("temperature must be positive")

    # Ensure a float64 array for numerical stability
    bins = np.asarray(bins_remain_cap, dtype=np.float64)

    # Feasibility mask: item can only go into bins with enough capacity
    feasible = bins >= item

    # Output array
    priorities = np.zeros_like(bins, dtype=np.float64)

    # If no bin can accommodate the item, return zeros (caller may open a new bin)
    if not np.any(feasible):
        return priorities

    # Compute slack for feasible bins (remaining capacity after placement)
    slack = bins[feasible] - item  # >= 0

    # Logits: higher when slack is smaller (tighter fit)
    logits = -slack / temperature  # <= 0

    # Softmax with numerical stability (max logit is 0)
    exp_logits = np.exp(logits)
    probs = exp_logits / np.sum(exp_logits)

    # Assign the softmax probabilities to the feasible bins
    priorities[feasible] = probs

    # -------------------------------------------------------------
    # Modest penalty for brand‑new bins (still at full capacity)
    # -------------------------------------------------------------
    full_capacity = np.max(bins)
    new_bin_mask = feasible & np.isclose(bins, full_capacity)
    if np.any(new_bin_mask):
        penalty = 0.001  # 0.1 % reduction
        priorities[new_bin_mask] *= (1.0 - penalty)

    # -------------------------------------------------------------
    # Deterministic tie‑breaker: lower index gets a tiny boost
    # -------------------------------------------------------------
    indices = np.arange(len(bins), dtype=np.float64)
    tie_eps = 1e-12
    priorities[feasible] -= tie_eps * indices[feasible]

    # Clamp to non‑negative values (in case tie‑breaking pushed below zero)
    priorities[priorities < 0] = 0.0

    return priorities
```
