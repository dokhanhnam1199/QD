```python
import numpy as np

# Global random generator – avoid reseeding on each call
_rng = np.random.default_rng()

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Adaptive sigmoid priority with tiny jitter for online bin packing.

    For each feasible bin (remaining capacity ≥ item) the score is computed by a
    logistic function that prefers bins leaving little slack after insertion.
    The sigmoid is centred at the median slack of the feasible bins and its
    slope is scaled by the slack range, making the scoring adaptive to the
    current free‑space distribution. A minute random jitter is added to break
    ties and introduce a little stochasticity.

    Infeasible bins receive a priority of ``-np.inf`` so they are never chosen.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of the currently open bins.

    Returns
    -------
    np.ndarray
        Priority scores (same shape as ``bins_remain_cap``). The bin with the
        highest score should be selected.
    """
    # Ensure a float NumPy array
    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)

    # Slack after placing the item in each bin (negative => infeasible)
    slack = bins_remain_cap - item

    # Feasibility mask
    feasible = slack >= 0.0

    # Initialise priorities: infeasible bins get -inf
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # If no bin can accommodate the item, return early
    if not feasible.any():
        return priorities

    # Slack values for feasible bins only
    slack_feas = slack[feasible]   # ≥ 0

    # Adaptive sigmoid parameters
    beta = np.median(slack_feas)                              # centre (inflection)
    slack_range = slack_feas.max() - slack_feas.minimum() + 1e-12
    alpha = 8.0 / slack_range                                 # slope scaling

    # Logistic decreasing in slack: higher score for smaller slack
    sigmoid_scores = 1.0 / (1.0 + np.exp(alpha * (slack_feas - beta)))

    # Tiny random jitter to break ties (uniform in [-ε, ε])
    epsilon = 1e-6
    jitter = _rng.uniform(-epsilon, epsilon, size=sigmoid_scores.shape)

    # Combine sigmoid score and jitter, clip to valid range
    scores = np.clip(sigmoid_scores + jitter, 0.0, 1.0)

    # Fill back into full priority vector
    priorities[feasible] = scores

    return priorities
```
