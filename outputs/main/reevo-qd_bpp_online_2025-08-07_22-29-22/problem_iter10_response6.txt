```python
import numpy as np

# Global parameters and state
_alpha_ema = 0.05           # EMA smoothing factor for item sizes
_epsilon_factor = 0.05      # Fraction of std used for exact‑fit tolerance
_exact_fit_offset = 1e9     # Large offset to guarantee exact fits win
_alpha_ratio = 0.5          # Weight for the item‑to‑capacity ratio (0 → waste only)

# EMA statistics
_ema_mean = 0.0
_ema_sq = 0.0
_item_count = 0

# RNG placeholder for potential extensions
_rng = np.random.default_rng()


def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Compute priority scores for each bin in an online bin‑packing scenario.

    The score combines an adaptive waste penalty (via a soft‑max over
    waste) and a ratio penalty that favours bins whose remaining capacity
    is close to the item size.  An exact fit (within a small tolerance
    based on a running EMA of item sizes) receives a huge priority offset.
    The function returns a score array; bins that cannot accommodate the
    item receive ``-np.inf``.
    """
    global _ema_mean, _ema_sq, _item_count
    # Update EMA statistics
    _item_count += 1
    _ema_mean = (1 - _alpha_ema) * _ema_mean + _alpha_ema * item
    _ema_sq = (1 - _alpha_ema) * _ema_sq + _alpha_ema * (item * item)

    var = _ema_sq - _ema_mean * _ema_mean
    std = np.sqrt(var) if var > 0 else 0.0
    eps = max(1e-9, _epsilon_factor * std)

    caps = np.asarray(bins_remain_cap, dtype=float)
    feasible = caps >= item

    # Initialize priority array with -inf for infeasible bins
    priorities = np.full_like(caps, -np.inf, dtype=float)
    if not np.any(feasible):
        return priorities

    slack = caps - item
    exact_fit = feasible & (np.abs(slack) <= eps)

    # Waste penalty with adaptive λ
    waste = slack[feasible]
    lam = 1.0 / (np.mean(waste) + 1e-6)
    raw_waste = np.exp(-lam * waste)

    # Ratio penalty
    ratio = item / caps[feasible]
    combined = raw_waste * (ratio ** _alpha_ratio)

    # Soft‑max over feasible bins
    max_val = combined.max()
    exp_scores = np.exp(combined - max_val)
    exp_scores /= exp_scores.sum()

    idx = np.arange(len(caps), dtype=float)
    priorities[feasible] = exp_scores
    priorities[feasible] -= 1e-12 * idx[feasible]
    priorities[exact_fit] = _exact_fit_offset - 1e-12 * idx[exact_fit]

    return priorities
```
