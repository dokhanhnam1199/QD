```python
import numpy as np

# Global RNG for random tie-breaking (initialized once)
_rng = np.random.default_rng()

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Compute a priority score for each bin in an online bin-packing setting.

    The priority favors:
    1. Exact fits (remaining capacity after placement ≈ 0) as highest priority.
    2. Among feasible bins, those that leave the smallest leftover space.
    3. Random tie-breaking with a very small perturbation.

    Infeasible bins (capacity < item) receive -inf so they are never selected.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities for each existing bin.

    Returns
    -------
    np.ndarray
        Array of priority scores (same shape as `bins_remain_cap`).  The bin with
        the largest score should be selected.
    """
    # Ensure input is a NumPy array (float dtype)
    caps = np.asarray(bins_remain_cap, dtype=float)

    # Tolerances
    eps = 1e-9          # tolerance for floating‑point comparison to zero
    eps_noise = 1e-6    # magnitude of random tie‑breaker

    # Compute leftover capacity if item were placed in each bin
    leftover = caps - item

    # Base priority: -inf for infeasible bins; otherwise -leftover (larger is better)
    # Exact fits (|leftover| <= eps) get priority 0 (the maximum possible without noise)
    base = np.where(
        leftover < -eps,               # cannot fit (negative leftover beyond tolerance)
        -np.inf,
        np.where(
            # Exact fit within tolerance
            np.abs(leftover) <= eps,
            0.0,
            -leftover                  # feasible but not exact; larger leftover => more negative priority
        )
    )

    # Add tiny random noise to break ties (including among exact fits)
    noise = _rng.uniform(-eps_noise, eps_noise, size=base.shape)

    priority = base + noise

    return priority.astype(float)
```
