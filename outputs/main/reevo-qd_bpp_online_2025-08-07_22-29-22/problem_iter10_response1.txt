```python
import numpy as np

def priority_v2(item: float,
                bins_remain_cap: np.ndarray,
                temperature: float = 0.1) -> np.ndarray:
    """
    Softmax‑based priority for the online Bin Packing Problem.

    Each bin receives a score proportional to the exponential of the
    negative slack (remaining capacity after placing ``item``).  The
    temperature parameter controls the greediness of the decision:
    low temperature → almost deterministic best‑fit; high temperature →
    more uniform exploration.  A tiny deterministic bias based on the
    bin index resolves ties in favour of lower‑index bins.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities for the current bins.
    temperature : float, optional (default=0.1)
        Positive scalar that smooths the softmax.  Must be > 0.

    Returns
    -------
    np.ndarray
        Priority scores for each bin (same shape as ``bins_remain_cap``).
        Scores sum to 1 across all feasible bins; infeasible bins have
        a priority of 0.
    """
    if temperature <= 0:
        raise ValueError("temperature must be positive")

    # Ensure we are working with a float array
    caps = np.asarray(bins_remain_cap, dtype=np.float64)

    # Edge case: no bins yet
    if caps.size == 0:
        return np.array([], dtype=np.float64)

    # Feasibility mask: a bin can receive the item only if it has enough
    # remaining capacity.
    feasible = caps >= item

    # Initialise priority vector with zeros (infeasible bins stay zero)
    priorities = np.zeros_like(caps, dtype=np.float64)

    # If nothing fits, return zero priorities (caller may open a new bin)
    if not np.any(feasible):
        return priorities

    # Slack (unused capacity) for each feasible bin
    slack = caps[feasible] - item  # non‑negative by construction

    # Deterministic tie‑breaker: tiny penalty proportional to bin index.
    # This ensures stable ordering when slacks are identical.
    eps = 1e-12
    feasible_indices = np.nonzero(feasible)[0].astype(np.float64)
    tie_bias = eps * feasible_indices

    # Logits: larger (less negative) for tighter fits (smaller slack)
    logits = -slack / temperature - tie_bias

    # Stable softmax: subtract max logit to avoid overflow
    max_logit = np.max(logits)
    exp_logits = np.exp(logits - max_logit)

    # Normalise to obtain a probability‑like priority vector
    sum_exp = np.sum(exp_logits)
    if sum_exp > 0:
        probs = exp_logits / sum_exp
        priorities[feasible] = probs

    return priorities
```
