{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is calculated based on the remaining capacity of each bin.\n    A bin with a remaining capacity closest to the item size gets the highest priority.\n    If a bin has not enough capacity to hold the item, its priority is set to negative infinity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin\n    # A bin with remaining capacity closest to the item size gets the highest priority\n    priority = -np.abs(bins_remain_cap - item)\n    \n    # If a bin does not have enough capacity, set its priority to negative infinity\n    priority[bins_remain_cap < item] = -np.inf\n    \n    return priority\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines best-fit strategy with nuanced normalization.\n    Prioritizes bins with remaining capacity closest to the item size.\n    \"\"\"\n    # Calculate absolute difference between item size and bin remaining capacity\n    diff = np.abs(bins_remain_cap - item)\n    \n    # Set priority to negative infinity for bins that cannot hold the item\n    priority = np.where(bins_remain_cap < item, -np.inf, \n                        # Combine best-fit strategy with relative utilization\n                        -diff / (item + 1e-6) + bins_remain_cap / (np.max(bins_remain_cap) + 1e-6))\n    \n    # Normalize priority scores using softmax-like function for valid bins\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):\n        max_priority = np.max(priority[valid_bins])\n        min_priority = np.min(priority[valid_bins])\n        priority[valid_bins] = (priority[valid_bins] - min_priority) / (max_priority - min_priority + 1e-6)\n        priority[valid_bins] = np.exp(priority[valid_bins]) / (np.sum(np.exp(priority[valid_bins])) + 1e-6)\n    \n    return priority\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is calculated based on the remaining capacity of each bin and the item size.\n    A bin with a remaining capacity closest to the item size gets the highest priority, \n    with a bonus for bins that are nearly full. \n    If a bin has not enough capacity to hold the item, its priority is set to negative infinity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin\n    # A bin with remaining capacity closest to the item size gets the highest priority\n    priority = -np.abs(bins_remain_cap - item)\n    \n    # Give a bonus to bins that are nearly full to encourage packing items tightly\n    nearly_full_bonus = np.where((bins_remain_cap - item) < (item / 2), 1, 0)\n    priority += nearly_full_bonus\n    \n    # Normalize the priority scores to be within a comparable range\n    max_priority = np.max(priority[bins_remain_cap >= item])\n    if max_priority != -np.inf:  # Check to avoid division by -inf or nan\n        priority[bins_remain_cap >= item] = (priority[bins_remain_cap >= item] - np.min(priority[bins_remain_cap >= item])) / (max_priority - np.min(priority[bins_remain_cap >= item]))\n    \n    # If a bin does not have enough capacity, set its priority to negative infinity\n    priority[bins_remain_cap < item] = -np.inf\n    \n    return priority\n\n[Heuristics 4th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines best-fit strategy with nuanced scoring and normalization.\n    \"\"\"\n    # Calculate remaining capacity after adding the item\n    remaining_capacity_after_addition = bins_remain_cap - item\n    \n    # Assign -inf priority to bins where the item doesn't fit\n    # Use negative remaining capacity for best-fit strategy and add a bonus for almost full bins\n    priority = np.where(remaining_capacity_after_addition >= 0, \n                        -np.abs(remaining_capacity_after_addition) + \n                        bins_remain_cap / (bins_remain_cap + item),  # bonus for less utilized bins\n                        -np.inf)\n    \n    # Normalize priority scores for valid bins\n    valid_bins = remaining_capacity_after_addition >= 0\n    if np.any(valid_bins):\n        min_priority, max_priority = np.min(priority[valid_bins]), np.max(priority[valid_bins])\n        priority = np.where(valid_bins, (priority - min_priority) / (max_priority - min_priority), -np.inf)\n    \n    return priority\n\n[Heuristics 5th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is calculated based on a combination of the remaining capacity \n    and the proportion of the bin that the item would occupy. A bin with a \n    remaining capacity closest to the item size and that would be filled to a \n    high proportion gets the highest priority. If a bin has not enough capacity \n    to hold the item, its priority is set to negative infinity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin (assuming all bins have the same total capacity).\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Assuming all bins have the same total capacity, which is the maximum possible value in bins_remain_cap\n    bin_capacity = np.max(bins_remain_cap) + (np.max(bins_remain_cap) - np.min(bins_remain_cap)) / 2\n    \n    # Calculate the proportion of the bin that the item would occupy\n    occupancy_proportion = item / (bins_remain_cap)\n    \n    # Avoid division by zero for empty bins\n    occupancy_proportion[bins_remain_cap == bin_capacity] = 0\n    \n    # Calculate the priority score for each bin\n    # A bin with remaining capacity closest to the item size and high occupancy proportion gets the highest priority\n    priority = -np.abs(bins_remain_cap - item) + np.log(1 + (1 - occupancy_proportion))\n    \n    # If a bin does not have enough capacity, set its priority to negative infinity\n    priority[bins_remain_cap < item] = -np.inf\n    \n    return priority\n\n[Heuristics 6th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is calculated based on the remaining capacity of each bin and the item size.\n    A bin with a remaining capacity closest to the item size and not less than it gets the highest priority.\n    If a bin has not enough capacity to hold the item, its priority is set to negative infinity.\n    The priority is also influenced by the bin utilization, favoring bins that are more full.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin\n    # A bin with remaining capacity closest to the item size gets the highest priority\n    # We also consider the bin utilization by adding a term that favors more full bins\n    max_capacity = np.max(bins_remain_cap) + item  # Assuming all bins have the same max capacity\n    priority = -np.abs(bins_remain_cap - item) + 0.5 * (max_capacity - bins_remain_cap) / max_capacity\n    \n    # If a bin does not have enough capacity, set its priority to negative infinity\n    priority[bins_remain_cap < item] = -np.inf\n    \n    return priority\n\n[Heuristics 7th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines best-fit strategy with nuanced normalization.\n    Prioritizes bins with remaining capacity closest to the item size.\n    \"\"\"\n    # Calculate absolute difference between item size and bin remaining capacity\n    diff = np.abs(bins_remain_cap - item)\n    \n    # Set priority to negative infinity for bins that cannot hold the item\n    priority = np.where(bins_remain_cap < item, -np.inf, \n                        # Combine best-fit strategy with relative utilization\n                        -diff / (item + 1e-6) + bins_remain_cap / (np.max(bins_remain_cap) + 1e-6))\n    \n    # Normalize priority scores using softmax-like function for valid bins\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):\n        max_priority = np.max(priority[valid_bins])\n        min_priority = np.min(priority[valid_bins])\n        priority[valid_bins] = (priority[valid_bins] - min_priority) / (max_priority - min_priority + 1e-6)\n        priority[valid_bins] = np.exp(priority[valid_bins]) / (np.sum(np.exp(priority[valid_bins])) + 1e-6)\n    \n    return priority\n\n[Heuristics 8th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines nuanced scoring and normalization for online Bin Packing Problem.\n    Prioritizes bins based on negative absolute difference and remaining capacity.\n    \"\"\"\n    # Calculate the absolute difference between the item size and the remaining capacity of each bin\n    diff = np.abs(bins_remain_cap - item)\n    \n    # Initial capacity is assumed to be 1.0 for all bins\n    initial_capacity = 1.0\n    \n    # Calculate the priority score as a combination of negative difference and relative utilization\n    priority = -diff / initial_capacity + bins_remain_cap / initial_capacity\n    \n    # Normalize the priority scores for valid bins\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):  \n        max_priority = np.max(priority[valid_bins])\n        min_priority = np.min(priority[valid_bins])\n        priority = np.where(valid_bins, (priority - min_priority) / (max_priority - min_priority + 1e-6), -np.inf)\n    else:\n        priority = -np.inf * np.ones_like(priority)\n    \n    # Enhance priority for bins that are almost full after adding the item\n    priority = np.where((bins_remain_cap - item >= 0) & (bins_remain_cap - item < item), priority + 1e-6, priority)\n    \n    return priority\n\n[Heuristics 9th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines nuanced scoring and normalization for online Bin Packing Problem.\n    Prioritizes bins based on negative absolute difference and remaining capacity.\n    \"\"\"\n    # Calculate the absolute difference between the item size and the remaining capacity of each bin\n    diff = np.abs(bins_remain_cap - item)\n    \n    # Initial capacity is assumed to be 1.0 for all bins\n    initial_capacity = 1.0\n    \n    # Calculate the priority score as a combination of negative difference and relative utilization\n    priority = -diff / initial_capacity + bins_remain_cap / initial_capacity\n    \n    # Normalize the priority scores for valid bins\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):  \n        max_priority = np.max(priority[valid_bins])\n        min_priority = np.min(priority[valid_bins])\n        priority = np.where(valid_bins, (priority - min_priority) / (max_priority - min_priority + 1e-6), -np.inf)\n    else:\n        priority = -np.inf * np.ones_like(priority)\n    \n    # Enhance priority for bins that are almost full after adding the item\n    priority = np.where((bins_remain_cap - item >= 0) & (bins_remain_cap - item < item), priority + 1e-6, priority)\n    \n    return priority\n\n[Heuristics 10th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines nuanced scoring and normalization for online Bin Packing Problem.\n    Prioritizes bins based on negative absolute difference and remaining capacity.\n    \"\"\"\n    # Calculate the absolute difference between the item size and the remaining capacity of each bin\n    diff = np.abs(bins_remain_cap - item)\n    \n    # Initial capacity is assumed to be 1.0 for all bins\n    initial_capacity = 1.0\n    \n    # Calculate the priority score as a combination of negative difference and relative utilization\n    priority = -diff / initial_capacity + bins_remain_cap / initial_capacity\n    \n    # Normalize the priority scores for valid bins\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):  \n        max_priority = np.max(priority[valid_bins])\n        min_priority = np.min(priority[valid_bins])\n        priority = np.where(valid_bins, (priority - min_priority) / (max_priority - min_priority + 1e-6), -np.inf)\n    else:\n        priority = -np.inf * np.ones_like(priority)\n    \n    # Enhance priority for bins that are almost full after adding the item\n    priority = np.where((bins_remain_cap - item >= 0) & (bins_remain_cap - item < item), priority + 1e-6, priority)\n    \n    return priority\n\n[Heuristics 11th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines nuanced scoring and normalization for online Bin Packing Problem.\n    Prioritizes bins based on negative absolute difference and remaining capacity.\n    \"\"\"\n    # Calculate the absolute difference between the item size and the remaining capacity of each bin\n    diff = np.abs(bins_remain_cap - item)\n    \n    # Initial capacity is assumed to be 1.0 for all bins\n    initial_capacity = 1.0\n    \n    # Calculate the priority score as a combination of negative difference and relative utilization\n    priority = -diff / initial_capacity + bins_remain_cap / initial_capacity\n    \n    # Normalize the priority scores for valid bins\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):  \n        max_priority = np.max(priority[valid_bins])\n        min_priority = np.min(priority[valid_bins])\n        priority = np.where(valid_bins, (priority - min_priority) / (max_priority - min_priority + 1e-6), -np.inf)\n    else:\n        priority = -np.inf * np.ones_like(priority)\n    \n    # Enhance priority for bins that are almost full after adding the item\n    priority = np.where((bins_remain_cap - item >= 0) & (bins_remain_cap - item < item), priority + 1e-6, priority)\n    \n    return priority\n\n[Heuristics 12th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines nuanced scoring and normalization for online Bin Packing Problem.\n    Prioritizes bins based on negative absolute difference and remaining capacity.\n    \"\"\"\n    # Calculate the absolute difference between the item size and the remaining capacity of each bin\n    diff = np.abs(bins_remain_cap - item)\n    \n    # Initial capacity is assumed to be 1.0 for all bins\n    initial_capacity = 1.0\n    \n    # Calculate the priority score as a combination of negative difference and relative utilization\n    priority = -diff / initial_capacity + bins_remain_cap / initial_capacity\n    \n    # Normalize the priority scores for valid bins\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):  \n        max_priority = np.max(priority[valid_bins])\n        min_priority = np.min(priority[valid_bins])\n        priority = np.where(valid_bins, (priority - min_priority) / (max_priority - min_priority + 1e-6), -np.inf)\n    else:\n        priority = -np.inf * np.ones_like(priority)\n    \n    # Enhance priority for bins that are almost full after adding the item\n    priority = np.where((bins_remain_cap - item >= 0) & (bins_remain_cap - item < item), priority + 1e-6, priority)\n    \n    return priority\n\n[Heuristics 13th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority score for each bin based on a combination of best-fit strategy and relative utilization.\n    \"\"\"\n    # Calculate the absolute difference between the remaining capacity of each bin and the item size\n    diff = np.abs(bins_remain_cap - item)\n    \n    # Calculate the priority score for each bin based on the difference and relative utilization\n    priority = -diff + bins_remain_cap\n    \n    # Normalize the priority scores using exponential normalization for valid bins\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):\n        max_priority = np.max(priority[valid_bins])\n        min_priority = np.min(priority[valid_bins])\n        priority[valid_bins] = (priority[valid_bins] - min_priority) / (max_priority - min_priority + 1e-9)\n        priority[valid_bins] = np.exp(priority[valid_bins])  # Exponential normalization\n    \n    # Set priority to negative infinity for bins that cannot hold the item\n    priority[~valid_bins] = -np.inf\n    \n    return priority\n\n[Heuristics 14th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority score for each bin by combining best-fit strategy and nuanced scoring with relative utilization.\n    \"\"\"\n    # Check if item can fit into each bin and calculate remaining capacity after addition\n    can_fit = bins_remain_cap >= item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Assign high priority to bins where item fits using a combination of best-fit and relative utilization\n    initial_capacity = 1.0  # Assuming uniform initial capacity for all bins\n    priority = np.where(can_fit, -np.abs(remaining_cap_after_addition) + bins_remain_cap / initial_capacity, -np.inf)\n    \n    # Normalize priority scores using exponential function for bins where item fits\n    max_priority = np.max(priority[can_fit]) if np.any(can_fit) else -np.inf\n    if not np.isneginf(max_priority):  \n        priority = np.where(can_fit, np.exp(priority - max_priority), priority)\n    \n    return priority\n\n[Heuristics 15th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines best-fit strategy with nuanced scoring and normalization for online Bin Packing Problem.\n    \"\"\"\n    # Calculate initial priority score based on negative absolute difference and remaining capacity\n    priority = -np.abs(bins_remain_cap - item) + bins_remain_cap\n    \n    # Set priority to negative infinity if bin cannot fit the item\n    priority[bins_remain_cap < item] = -np.inf\n    \n    # Apply softmax normalization for robustness\n    valid_priority = priority[priority != -np.inf]\n    if len(valid_priority) > 0:\n        exp_priority = np.exp(priority - np.max(valid_priority))  # Subtract max for numerical stability\n        exp_priority[priority == -np.inf] = 0\n        priority = exp_priority / np.sum(exp_priority)\n    else:\n        priority = np.zeros_like(priority)\n    \n    return priority\n\n[Heuristics 16th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority score for each bin based on a combination of best-fit strategy and relative utilization.\n    \"\"\"\n    # Calculate the absolute difference between the remaining capacity of each bin and the item size\n    diff = np.abs(bins_remain_cap - item)\n    \n    # Calculate the priority score for each bin based on the difference and relative utilization\n    priority = -diff + bins_remain_cap\n    \n    # Normalize the priority scores using exponential normalization for valid bins\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):\n        max_priority = np.max(priority[valid_bins])\n        min_priority = np.min(priority[valid_bins])\n        priority[valid_bins] = (priority[valid_bins] - min_priority) / (max_priority - min_priority + 1e-9)\n        priority[valid_bins] = np.exp(priority[valid_bins])  # Exponential normalization\n    \n    # Set priority to negative infinity for bins that cannot hold the item\n    priority[~valid_bins] = -np.inf\n    \n    return priority\n\n[Heuristics 17th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority score for each bin by combining best-fit strategy and nuanced scoring with relative utilization.\n    \"\"\"\n    # Check if item can fit into each bin and calculate remaining capacity after addition\n    can_fit = bins_remain_cap >= item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Assign high priority to bins where item fits using a combination of best-fit and relative utilization\n    initial_capacity = 1.0  # Assuming uniform initial capacity for all bins\n    priority = np.where(can_fit, -np.abs(remaining_cap_after_addition) + bins_remain_cap / initial_capacity, -np.inf)\n    \n    # Normalize priority scores using exponential function for bins where item fits\n    max_priority = np.max(priority[can_fit]) if np.any(can_fit) else -np.inf\n    if not np.isneginf(max_priority):  \n        priority = np.where(can_fit, np.exp(priority - max_priority), priority)\n    \n    return priority\n\n[Heuristics 18th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for each bin based on best-fit strategy and nuanced normalization.\n    Combines the benefits of nuanced scoring and relative utilization.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Assign a very low priority to bins where the item doesn't fit\n    priority = np.where(remaining_cap_after_addition < 0, -np.inf, \n                        # For bins where the item fits, use a best-fit scoring system with relative utilization\n                        -np.abs(remaining_cap_after_addition) + bins_remain_cap)\n    \n    # Normalize the priority scores using the exponential function\n    valid_bins = np.isfinite(priority)\n    if np.any(valid_bins):  \n        max_priority = np.max(priority[valid_bins])\n        min_priority = np.min(priority[valid_bins])\n        # Normalize the priority scores to avoid identical values\n        priority[valid_bins] = (priority[valid_bins] - min_priority) / (max_priority - min_priority)\n        priority[valid_bins] = np.exp(priority[valid_bins])  # Apply exponential normalization\n    \n    return priority\n\n[Heuristics 19th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for each bin based on a nuanced scoring system combining best-fit strategy and remaining capacity.\n    \"\"\"\n    # Calculate the absolute difference between the remaining capacity and the item size\n    diff = np.abs(bins_remain_cap - item)\n    \n    # Calculate priority score using a combination of difference and remaining capacity\n    priority = -diff / (bins_remain_cap + 1e-6) + bins_remain_cap\n    \n    # Set priority to negative infinity for bins without enough capacity\n    priority[bins_remain_cap < item] = -np.inf\n    \n    # Normalize priority scores for valid bins\n    valid_bins = priority != -np.inf\n    if np.any(valid_bins):\n        min_priority = np.min(priority[valid_bins])\n        max_priority = np.max(priority[valid_bins])\n        if max_priority != min_priority:\n            priority[valid_bins] = (priority[valid_bins] - min_priority) / (max_priority - min_priority)\n        else:\n            priority[valid_bins] = 1.0\n    \n    return priority\n\n[Heuristics 20th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for each bin based on a nuanced scoring system combining best-fit strategy and remaining capacity.\n    \"\"\"\n    # Calculate the absolute difference between the remaining capacity and the item size\n    diff = np.abs(bins_remain_cap - item)\n    \n    # Calculate priority score using a combination of difference and remaining capacity\n    priority = -diff / (bins_remain_cap + 1e-6) + bins_remain_cap\n    \n    # Set priority to negative infinity for bins without enough capacity\n    priority[bins_remain_cap < item] = -np.inf\n    \n    # Normalize priority scores for valid bins\n    valid_bins = priority != -np.inf\n    if np.any(valid_bins):\n        min_priority = np.min(priority[valid_bins])\n        max_priority = np.max(priority[valid_bins])\n        if max_priority != min_priority:\n            priority[valid_bins] = (priority[valid_bins] - min_priority) / (max_priority - min_priority)\n        else:\n            priority[valid_bins] = 1.0\n    \n    return priority\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}