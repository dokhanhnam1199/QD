```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Returns priority scores for each bin based on best-fit strategy and nuanced normalization.
    Combines the benefits of nuanced scoring and relative utilization.
    """
    # Calculate the remaining capacity after adding the item to each bin
    remaining_cap_after_addition = bins_remain_cap - item
    
    # Assign a very low priority to bins where the item doesn't fit
    priority = np.where(remaining_cap_after_addition < 0, -np.inf, 
                        # For bins where the item fits, use a best-fit scoring system with relative utilization
                        -np.abs(remaining_cap_after_addition) + bins_remain_cap)
    
    # Normalize the priority scores using the exponential function
    valid_bins = np.isfinite(priority)
    if np.any(valid_bins):  
        max_priority = np.max(priority[valid_bins])
        min_priority = np.min(priority[valid_bins])
        # Normalize the priority scores to avoid identical values
        priority[valid_bins] = (priority[valid_bins] - min_priority) / (max_priority - min_priority)
        priority[valid_bins] = np.exp(priority[valid_bins])  # Apply exponential normalization
    
    return priority
```
