[
  {
    "stdout_filepath": "problem_iter14_response0.txt_stdout.txt",
    "code_path": "problem_iter14_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines best-fit strategy with a bonus for bins that are nearly full after adding the item and normalization.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_cap_after_add = bins_remain_cap - item\n    \n    # Best-fit strategy: prioritize bins with remaining capacity closest to item size\n    priority = np.where(bins_remain_cap >= item, -np.abs(bins_remain_cap - item), -np.inf)\n    \n    # Enhance priority for bins that are almost full after adding the item\n    bonus = np.where((remaining_cap_after_add >= 0) & (remaining_cap_after_add < item), 1e-6, 0)\n    priority += bonus\n    \n    # Normalize the priority scores for valid bins\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):  \n        max_priority = np.max(priority[valid_bins])\n        min_priority = np.min(priority[valid_bins])\n        priority = np.where(valid_bins, (priority - min_priority) / (max_priority - min_priority + 1e-6), priority)\n    \n    return priority",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 220.92066675263135,
    "mi": 87.1667583235797,
    "token_count": 177.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response1.txt_stdout.txt",
    "code_path": "problem_iter14_code1.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines best-fit strategy with bonus for nearly full bins and normalization.\n    \n    Prioritizes bins based on remaining capacity closest to item size, \n    adds bonus for bins that are nearly full, and normalizes priority scores.\n    \"\"\"\n    # Best-fit strategy: prioritize bins with remaining capacity closest to item size\n    priority = -np.abs(bins_remain_cap - item)\n    \n    # Add bonus for bins that are nearly full after adding the item\n    remaining_cap_after_add = np.where(bins_remain_cap >= item, bins_remain_cap - item, np.inf)\n    bonus = -remaining_cap_after_add / (item + 1e-6)  # Normalize the remaining capacity\n    \n    # Combine best-fit priority and bonus\n    priority += bonus\n    \n    # Normalize priority scores for valid bins\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):\n        max_priority = np.max(priority[valid_bins])\n        min_priority = np.min(priority[valid_bins])\n        priority = np.where(valid_bins, (priority - min_priority) / (max_priority - min_priority + 1e-6), -np.inf)\n    else:\n        priority = -np.inf * np.ones_like(priority)\n    \n    return priority",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 220.92066675263135,
    "mi": 87.1667583235797,
    "token_count": 177.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response2.txt_stdout.txt",
    "code_path": "problem_iter14_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines best-fit strategy with a bonus for nearly full bins and normalized priority scores.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Set priority based on best-fit strategy\n    priority = -np.abs(bins_remain_cap - item)\n    \n    # Enhance priority for bins that are almost full after adding the item\n    priority = np.where((remain_cap_after_add >= 0) & (remain_cap_after_add < item), priority + 1e-6, priority)\n    \n    # Set priority to negative infinity for bins that cannot hold the item\n    valid_bins = bins_remain_cap >= item\n    priority = np.where(valid_bins, priority, -np.inf)\n    \n    # Normalize the priority scores for valid bins\n    if np.any(valid_bins):  \n        max_priority = np.max(priority[valid_bins])\n        min_priority = np.min(priority[valid_bins])\n        priority = np.where(valid_bins, (priority - min_priority) / (max_priority - min_priority + 1e-6), priority)\n    \n    return priority",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 220.92066675263135,
    "mi": 87.1667583235797,
    "token_count": 177.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response3.txt_stdout.txt",
    "code_path": "problem_iter14_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines best-fit strategy with a bonus for nearly full bins and normalization.\n    \n    Prioritizes bins based on remaining capacity closest to item size, \n    with a bonus for bins that would be nearly full after adding the item.\n    \"\"\"\n    # Define the capacity of the bins (assuming it's the same for all bins)\n    bin_capacity = np.max(bins_remain_cap) + (np.max(bins_remain_cap) - np.min(bins_remain_cap))\n    \n    # Best-fit strategy: prioritize bins with remaining capacity closest to item size\n    best_fit_priority = -np.abs(bins_remain_cap - item)\n    \n    # Give a bonus to bins that would be filled to at least 90% capacity after adding the item\n    bonus = np.where((bins_remain_cap - item) / bin_capacity <= 0.1, 10, 0)\n    \n    # Combine the best-fit priority and the bonus\n    priority = best_fit_priority + bonus\n    \n    # If a bin does not have enough capacity, set its priority to negative infinity\n    priority[bins_remain_cap < item] = -np.inf\n    \n    # Normalize priority scores for valid bins\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):\n        max_priority = np.max(priority[valid_bins])\n        min_priority = np.min(priority[valid_bins])\n        priority = np.where(valid_bins, (priority - min_priority) / (max_priority - min_priority + 1e-6), -np.inf)\n    \n    return priority",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 220.92066675263135,
    "mi": 87.1667583235797,
    "token_count": 177.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response4.txt_stdout.txt",
    "code_path": "problem_iter14_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines best-fit strategy with a bonus for nearly full bins and normalization.\n    \n    Prioritizes bins based on remaining capacity closest to item size, \n    gives a bonus to nearly full bins, and normalizes priority scores.\n    \"\"\"\n    # Best-fit strategy: prioritize bins with remaining capacity closest to item size\n    priority = -np.abs(bins_remain_cap - item)\n    \n    # Give a bonus to bins that are nearly full (remaining capacity less than 0.5 * item size)\n    nearly_full_bonus = bins_remain_cap < 0.5 * item\n    priority[nearly_full_bonus] += 1\n    \n    # If a bin does not have enough capacity, set its priority to negative infinity\n    priority[bins_remain_cap < item] = -np.inf\n    \n    # Normalize priority scores for valid bins\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):\n        max_priority = np.max(priority[valid_bins])\n        min_priority = np.min(priority[valid_bins])\n        priority = np.where(valid_bins, (priority - min_priority) / (max_priority - min_priority + 1e-6), -np.inf)\n    \n    return priority",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 220.92066675263135,
    "mi": 87.1667583235797,
    "token_count": 177.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response5.txt_stdout.txt",
    "code_path": "problem_iter14_code5.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines best-fit strategy with a bonus for bins that are nearly full after adding the item and normalizes priority scores.\n    \"\"\"\n    # Calculate remaining capacity after adding item to each bin\n    remaining_cap_after_add = bins_remain_cap - item\n    \n    # Best-fit strategy with a check for valid bins\n    valid_bins = bins_remain_cap >= item\n    priority = np.where(valid_bins, -np.abs(bins_remain_cap - item), -np.inf)\n    \n    # Bonus for bins that are almost full after adding the item\n    bonus = np.where((remaining_cap_after_add >= 0) & (remaining_cap_after_add < item), 1e-6, 0)\n    priority += bonus\n    \n    # Normalize priority scores for valid bins\n    if np.any(valid_bins):\n        max_priority = np.max(priority[valid_bins])\n        min_priority = np.min(priority[valid_bins])\n        priority = np.where(valid_bins, (priority - min_priority) / (max_priority - min_priority + 1e-6), -np.inf)\n    \n    return priority",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 220.92066675263135,
    "mi": 87.1667583235797,
    "token_count": 177.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response6.txt_stdout.txt",
    "code_path": "problem_iter14_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines best-fit strategy with a bonus for nearly full bins and normalization.\n    \"\"\"\n    # Best-fit strategy: prioritize bins with remaining capacity closest to item size\n    diff = np.abs(bins_remain_cap - item)\n    priority = np.where(bins_remain_cap >= item, -diff, -np.inf)\n    \n    # Enhance priority for bins that are almost full after adding the item\n    remaining_after_add = bins_remain_cap - item\n    priority = np.where((remaining_after_add >= 0) & (remaining_after_add < item/2), priority + 1e-6, priority)\n    \n    # Normalize priority scores for valid bins\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):\n        max_priority = np.max(priority[valid_bins])\n        min_priority = np.min(priority[valid_bins])\n        priority = np.where(valid_bins, (priority - min_priority) / (max_priority - min_priority + 1e-6), -np.inf)\n    \n    return priority",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 220.92066675263135,
    "mi": 87.1667583235797,
    "token_count": 177.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response7.txt_stdout.txt",
    "code_path": "problem_iter14_code7.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines best-fit strategy with a nuanced handling of remaining capacity.\n    \n    Prioritizes bins based on remaining capacity closest to item size and \n    remaining capacity after adding the item, with a bonus for nearly full bins.\n    \"\"\"\n    # Best-fit strategy: prioritize bins with remaining capacity closest to item size\n    priority = -np.abs(bins_remain_cap - item)\n    \n    # Nuanced handling: consider remaining capacity after adding the item and give a bonus to nearly full bins\n    remaining_cap_after_add = np.where(bins_remain_cap >= item, bins_remain_cap - item, np.inf)\n    priority += -remaining_cap_after_add / (item + 1e-6)  # Normalize the remaining capacity\n    \n    # Bonus for nearly full bins\n    nearly_full_bonus = np.where(bins_remain_cap >= item, (bins_remain_cap - item) < item * 0.1, False)\n    priority += np.where(nearly_full_bonus, 1, 0)  # Add a bonus for bins that are 90% full\n    \n    # Normalize priority scores for valid bins\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):\n        max_priority = np.max(priority[valid_bins])\n        min_priority = np.min(priority[valid_bins])\n        priority = np.where(valid_bins, (priority - min_priority) / (max_priority - min_priority + 1e-6), -np.inf)\n    else:\n        priority = -np.inf * np.ones_like(priority)\n    \n    return priority",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 220.92066675263135,
    "mi": 87.1667583235797,
    "token_count": 177.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response8.txt_stdout.txt",
    "code_path": "problem_iter14_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines best-fit strategy with a bonus for nearly full bins and normalization.\n    \n    Prioritizes bins based on remaining capacity closest to item size, \n    gives a bonus to nearly full bins, and normalizes priority scores.\n    \"\"\"\n    # Best-fit strategy: prioritize bins with remaining capacity closest to item size\n    priority = -np.abs(bins_remain_cap - item)\n    \n    # Give a bonus to bins that are nearly full (remaining capacity less than 0.5 * item size)\n    nearly_full_bonus = bins_remain_cap < 0.5 * item\n    priority[nearly_full_bonus] += 1\n    \n    # If a bin does not have enough capacity, set its priority to negative infinity\n    priority[bins_remain_cap < item] = -np.inf\n    \n    # Normalize priority scores for valid bins\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):\n        max_priority = np.max(priority[valid_bins])\n        min_priority = np.min(priority[valid_bins])\n        priority = np.where(valid_bins, (priority - min_priority) / (max_priority - min_priority + 1e-6), -np.inf)\n    \n    return priority",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 220.92066675263135,
    "mi": 87.1667583235797,
    "token_count": 177.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response9.txt_stdout.txt",
    "code_path": "problem_iter14_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines best-fit strategy with a bonus for nearly full bins and normalized remaining capacity.\n    \"\"\"\n    # Best-fit strategy\n    best_fit = -np.abs(bins_remain_cap - item)\n    \n    # Bonus for bins that are nearly full after adding the item\n    remaining_cap = np.where(bins_remain_cap >= item, bins_remain_cap - item, np.inf)\n    bonus = -remaining_cap / np.max(remaining_cap + 1e-6)\n    \n    # Combine best-fit with bonus and normalize\n    priority = best_fit + 0.5 * bonus\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):\n        max_priority = np.max(priority[valid_bins])\n        min_priority = np.min(priority[valid_bins])\n        priority = np.where(valid_bins, (priority - min_priority) / (max_priority - min_priority + 1e-6), -np.inf)\n    else:\n        priority = -np.inf * np.ones_like(priority)\n    \n    return priority",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 220.92066675263135,
    "mi": 87.1667583235797,
    "token_count": 177.0,
    "exec_success": true
  }
]