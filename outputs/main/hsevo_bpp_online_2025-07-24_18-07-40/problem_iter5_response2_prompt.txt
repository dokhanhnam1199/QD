{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Returns priority scores for each bin based on a nuanced scoring system combining best-fit strategy and normalization.\n    \n    Prioritizes bins with remaining capacity closest to the item size, using exponential normalization.\n    \"\"\"\n    # Calculate the absolute difference between the item size and the remaining capacity of each bin\n    diff = np.abs(bins_remain_cap - item)\n    \n    # Set the priority score to negative infinity for bins that cannot hold the item\n    priority = np.where(bins_remain_cap < item, -np.inf, \n                        # For bins that can hold the item, use a scoring system that combines best-fit and normalization\n                        -diff / (bins_remain_cap + 1e-6) + np.exp(-diff / (item + 1e-6)))\n    \n    return priority\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is calculated based on a combination of the remaining capacity of each bin and its relative utilization.\n    A bin with a remaining capacity closest to the item size and higher overall capacity gets the highest priority.\n    If a bin has not enough capacity to hold the item, its priority is set to negative infinity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the initial capacity of the bins (assuming it's the same for all bins)\n    # For demonstration, let's assume the initial capacity is 1.0 (can be changed based on actual problem requirements)\n    initial_capacity = 1.0\n    \n    # Calculate the priority score for each bin based on the remaining capacity and relative utilization\n    # A bin with remaining capacity closest to the item size gets higher priority\n    # A bin with higher overall capacity (less utilized) gets higher priority\n    priority = -np.abs(bins_remain_cap - item) / initial_capacity + bins_remain_cap / initial_capacity\n    \n    # Normalize the priority scores to be within a comparable range\n    # Using a simple normalization technique for demonstration; can be adjusted based on the problem's requirements\n    max_priority = np.max(priority[bins_remain_cap >= item])\n    if not np.isneginf(max_priority):  # Check if there's at least one valid bin\n        priority = np.where(bins_remain_cap >= item, (priority - np.min(priority[bins_remain_cap >= item])) / (max_priority - np.min(priority[bins_remain_cap >= item])), -np.inf)\n    else:\n        priority = -np.inf * np.ones_like(priority)\n    \n    # If a bin does not have enough capacity, set its priority to negative infinity\n    priority[bins_remain_cap < item] = -np.inf\n    \n    return priority\n\n### Analyze & experience\n- Comparing the best (Heuristics 1st) vs the worst (Heuristics 20th), we see that the top heuristic uses a more nuanced scoring system with exponential normalization, whereas the worst heuristic uses a repetitive and less optimized approach. \nComparing (1st) vs (2nd), we see that the first heuristic directly uses negative absolute difference for best-fit strategy and then normalizes using exponential function, while the second heuristic uses a combination of difference and remaining capacity. \n(3rd) vs (4th) show similar patterns with nuanced scoring and normalization. \nOverall, top heuristics tend to have more sophisticated normalization techniques and nuanced scoring systems.\n- \nTo redefine 'Current self-reflection', let's first identify the overlapping and ineffective aspects.\n\n* **Keywords**: Nuanced scoring, normalization, optimization\n* **Advice**: Focus on creating diverse and context-specific scoring functions that can adapt to different problem domains.\n* **Avoid**: Repetitive code, generic normalization techniques (like exponential normalization without consideration for context)\n* **Explanation**: The original 'Current self-reflection' was not effective because it lacked specificity and adaptability, mirroring 'Ineffective self-reflection' in its suggestion to use exponential normalization without considering the context or problem specifics, thus not truly avoiding the pitfalls it aimed to.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}