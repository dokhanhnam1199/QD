[
  {
    "stdout_filepath": "problem_iter2_response0.txt_stdout.txt",
    "code_path": "problem_iter2_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for each bin based on remaining capacity and item size.\n    Combines nuanced scoring and normalization techniques for improved heuristic design.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Assign a very low priority to bins where the item doesn't fit\n    priority = np.where(remaining_cap_after_addition < 0, -np.inf, \n                        # For bins where the item fits, use a nuanced scoring system\n                        -remaining_cap_after_addition)\n    \n    # Normalize the priority scores using the exponential function\n    priority = np.exp(priority)\n    \n    return priority",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 41.20902501875006,
    "mi": 96.34859085287245,
    "token_count": 99.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response1.txt_stdout.txt",
    "code_path": "problem_iter2_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority score for each bin by combining best-fit strategy and nuanced scoring.\n    \n    Prioritizes bins with the least remaining capacity after adding the item.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_capacity_after_addition = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot accommodate the item\n    # For bins that can accommodate the item, use negative remaining capacity as priority\n    priority = np.where(remaining_capacity_after_addition >= 0, \n                        -remaining_capacity_after_addition, \n                        -np.inf)\n    \n    # Normalize priority scores using exponential function to enhance nuance\n    priority = np.exp(priority - np.max(priority[~np.isinf(priority)]))\n    \n    return priority",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 41.20902501875006,
    "mi": 96.34859085287245,
    "token_count": 99.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response2.txt_stdout.txt",
    "code_path": "problem_iter2_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for each bin based on remaining capacity and item size.\n    Combines best-fit strategy with exponential normalization for robustness.\n    \"\"\"\n    # Calculate priority score as negative absolute difference between remaining capacity and item size\n    priority = -np.abs(bins_remain_cap - item)\n    \n    # Set priority to negative infinity if bin cannot fit the item\n    priority[bins_remain_cap < item] = -np.inf\n    \n    # Apply softmax to convert scores to probabilities for normalization\n    exp_priority = np.exp(priority - np.max(priority[priority != -np.inf]))  # Subtract max for numerical stability\n    exp_priority[priority == -np.inf] = 0  # Set exp_priority to 0 where priority is -inf\n    \n    # Normalize to get final priority scores\n    sum_exp_priority = np.sum(exp_priority)\n    if sum_exp_priority > 0:\n        priority = exp_priority / sum_exp_priority\n    else:\n        priority = np.zeros_like(exp_priority)\n    \n    return priority",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 41.20902501875006,
    "mi": 96.34859085287245,
    "token_count": 99.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response3.txt_stdout.txt",
    "code_path": "problem_iter2_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for each bin by combining Best-Fit strategy with normalization.\n    Prioritizes bins that can accommodate the item and have remaining capacity closest to the item size.\n    \"\"\"\n    # Calculate the absolute difference between the item size and the remaining capacity\n    diff = np.abs(bins_remain_cap - item)\n    \n    # Bins that cannot accommodate the item get a priority of -inf\n    priority = np.where(bins_remain_cap >= item, -diff, -np.inf)\n    \n    # Normalize the priority scores for valid bins\n    valid_bins = priority != -np.inf\n    if np.any(valid_bins):\n        min_priority = np.min(priority[valid_bins])\n        max_priority = np.max(priority[valid_bins])\n        if max_priority != min_priority:\n            priority[valid_bins] = (priority[valid_bins] - min_priority) / (max_priority - min_priority)\n    \n    return priority",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 41.20902501875006,
    "mi": 96.34859085287245,
    "token_count": 99.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response4.txt_stdout.txt",
    "code_path": "problem_iter2_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for each bin based on a nuanced scoring system combining best-fit strategy and normalization.\n    \n    Prioritizes bins with remaining capacity closest to the item size, using exponential normalization.\n    \"\"\"\n    # Calculate the absolute difference between the item size and the remaining capacity of each bin\n    diff = np.abs(bins_remain_cap - item)\n    \n    # Set the priority score to negative infinity for bins that cannot hold the item\n    priority = np.where(bins_remain_cap < item, -np.inf, \n                        # For bins that can hold the item, use a scoring system that combines best-fit and normalization\n                        -diff / (bins_remain_cap + 1e-6) + np.exp(-diff / (item + 1e-6)))\n    \n    return priority",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 41.20902501875006,
    "mi": 96.34859085287245,
    "token_count": 99.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response5.txt_stdout.txt",
    "code_path": "problem_iter2_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority score for each bin using a nuanced scoring system with exponential normalization.\n\n    The priority is higher for bins that have enough capacity for the item and \n    lower remaining capacity after packing the item.\n    \"\"\"\n    # Calculate the remaining capacity after packing the item into each bin\n    remaining_cap_after_packing = bins_remain_cap - item\n    \n    # Check if the bin has enough capacity for the item\n    has_enough_capacity = remaining_cap_after_packing >= 0\n    \n    # Assign a very low priority to bins that cannot hold the item\n    priority = np.where(has_enough_capacity, -remaining_cap_after_packing, -np.inf)\n    \n    # Apply exponential normalization to priority scores\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:  \n        valid_priority = priority != -np.inf\n        priority[valid_priority] = np.exp(priority[valid_priority] - max_priority)\n        priority[~valid_priority] = 0\n    \n    return priority",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 41.20902501875006,
    "mi": 96.34859085287245,
    "token_count": 99.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response6.txt_stdout.txt",
    "code_path": "problem_iter2_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority score for each bin by combining Best Fit strategy and nuanced scoring.\n    Prioritizes bins with just enough capacity and uses exponential normalization.\n    \"\"\"\n    # Check if item can fit into the bin\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    \n    # Calculate priority using Best Fit strategy with exponential normalization\n    priority = np.where(valid_bins > 0, np.exp(-(bins_remain_cap - item) / bins_remain_cap), -1)\n    \n    return priority",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 41.20902501875006,
    "mi": 96.34859085287245,
    "token_count": 99.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response7.txt_stdout.txt",
    "code_path": "problem_iter2_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority score for each bin by combining best-fit strategy and nuanced scoring.\n    \"\"\"\n    # Calculate remaining capacity after adding the item\n    remaining_capacity_after_addition = bins_remain_cap - item\n    \n    # Assign -inf priority to bins where the item doesn't fit\n    priority = np.where(remaining_capacity_after_addition >= 0, \n                        # Use negative remaining capacity for best-fit strategy\n                        -remaining_capacity_after_addition + \n                        # Add a small bonus for bins that are almost full\n                        np.exp(-remaining_capacity_after_addition / item), \n                        -np.inf)\n    \n    return priority",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 41.20902501875006,
    "mi": 96.34859085287245,
    "token_count": 99.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response8.txt_stdout.txt",
    "code_path": "problem_iter2_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines elements of best-fit and nuanced scoring.\n    Prioritizes bins based on negative absolute difference and remaining capacity.\n    \"\"\"\n    # Calculate the absolute difference between the item size and the remaining capacity of each bin\n    diff = np.abs(bins_remain_cap - item)\n    \n    # Calculate the priority score as the negative of the difference, normalized by remaining capacity\n    priority = -diff / (bins_remain_cap + 1e-6)\n    \n    # Set the priority score to negative infinity for bins that cannot hold the item\n    priority[bins_remain_cap < item] = -np.inf\n    \n    # Enhance priority for bins that are almost full after adding the item\n    priority = np.where((bins_remain_cap - item >= 0) & (bins_remain_cap - item < item), priority + 1e-6, priority)\n    \n    return priority",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 41.20902501875006,
    "mi": 96.34859085287245,
    "token_count": 99.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response9.txt_stdout.txt",
    "code_path": "problem_iter2_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority score for each bin by combining best-fit strategy and nuanced scoring.\n    \"\"\"\n    # Check if item can fit into each bin and calculate remaining capacity after addition\n    can_fit = bins_remain_cap >= item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Assign high priority to bins where item fits, using negative absolute difference for best-fit strategy\n    priority = np.where(can_fit, -np.abs(remaining_cap_after_addition), -np.inf)\n    \n    # Normalize priority scores using exponential function for bins where item fits\n    max_priority = np.max(priority)\n    priority = np.where(can_fit, np.exp(priority - max_priority), priority)\n    \n    return priority",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 41.20902501875006,
    "mi": 96.34859085287245,
    "token_count": 99.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response0.txt_stdout.txt",
    "code_path": "problem_iter3_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is calculated based on a combination of the remaining capacity of each bin and a normalization technique.\n    A bin with a remaining capacity closest to the item size gets the highest priority, and the priority is normalized to be between 0 and 1.\n    If a bin has not enough capacity to hold the item, its priority is set to negative infinity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the absolute difference between the remaining capacity of each bin and the item size\n    diff = np.abs(bins_remain_cap - item)\n    \n    # Calculate the minimum and maximum differences\n    min_diff = np.min(diff[bins_remain_cap >= item]) if np.any(bins_remain_cap >= item) else 0\n    max_diff = np.max(diff)\n    \n    # Normalize the differences to be between 0 and 1\n    normalized_diff = (diff - min_diff) / (max_diff - min_diff + 1e-9)\n    \n    # Calculate the priority score for each bin\n    # A bin with a remaining capacity closest to the item size gets the highest priority\n    priority = 1 - normalized_diff\n    \n    # If a bin does not have enough capacity, set its priority to negative infinity\n    priority[bins_remain_cap < item] = -np.inf\n    \n    return priority",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 155.88872502451935,
    "mi": 76.54505240657787,
    "token_count": 149.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response1.txt_stdout.txt",
    "code_path": "problem_iter3_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is calculated based on a combination of the remaining capacity \n    of each bin and a normalization technique to improve heuristic design.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the absolute difference between the remaining capacity and the item size\n    diff = np.abs(bins_remain_cap - item)\n    \n    # Calculate the priority score for each bin using a combination of the difference and the remaining capacity\n    # A bin with remaining capacity closest to the item size and with more remaining capacity gets the highest priority\n    priority = -diff / (bins_remain_cap + 1e-6)  # Adding a small value to avoid division by zero\n    \n    # If a bin does not have enough capacity, set its priority to negative infinity\n    priority[bins_remain_cap < item] = -np.inf\n    \n    # Normalize the priority scores to be between 0 and 1 for bins with sufficient capacity\n    valid_bins = priority != -np.inf\n    if np.any(valid_bins):\n        min_priority = np.min(priority[valid_bins])\n        max_priority = np.max(priority[valid_bins])\n        if max_priority != min_priority:\n            priority[valid_bins] = (priority[valid_bins] - min_priority) / (max_priority - min_priority)\n        else:\n            priority[valid_bins] = 1.0  # All valid bins have the same priority, so set them to 1.0\n    \n    return priority",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 155.88872502451935,
    "mi": 76.54505240657787,
    "token_count": 149.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response2.txt_stdout.txt",
    "code_path": "problem_iter3_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is calculated based on a combination of the remaining capacity \n    of each bin and a normalization technique to enhance the scoring system.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the absolute difference between the remaining capacity and the item size\n    diff = np.abs(bins_remain_cap - item)\n    \n    # Calculate the priority score for each bin using a combination of the difference and the remaining capacity\n    # A bin with remaining capacity closest to the item size and with larger remaining capacity gets the highest priority\n    priority = -diff / (bins_remain_cap + 1e-6)  # Adding a small value to avoid division by zero\n    \n    # If a bin does not have enough capacity, set its priority to negative infinity\n    priority[bins_remain_cap < item] = -np.inf\n    \n    # Normalize the priority scores to be within a certain range\n    finite_priority = priority[np.isfinite(priority)]\n    if len(finite_priority) > 0:\n        max_priority = np.max(finite_priority)\n        min_priority = np.min(finite_priority)\n        if max_priority != min_priority:\n            priority[np.isfinite(priority)] = (finite_priority - min_priority) / (max_priority - min_priority)\n    \n    return priority",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 155.88872502451935,
    "mi": 76.54505240657787,
    "token_count": 149.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response3.txt_stdout.txt",
    "code_path": "problem_iter3_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is calculated based on a combination of the remaining capacity of each bin and its relative utilization.\n    A bin with a remaining capacity closest to the item size and higher overall capacity gets the highest priority.\n    If a bin has not enough capacity to hold the item, its priority is set to negative infinity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the initial capacity of the bins (assuming it's the same for all bins)\n    # For demonstration, let's assume the initial capacity is 1.0 (can be changed based on actual problem requirements)\n    initial_capacity = 1.0\n    \n    # Calculate the priority score for each bin based on the remaining capacity and relative utilization\n    # A bin with remaining capacity closest to the item size gets higher priority\n    # A bin with higher overall capacity (less utilized) gets higher priority\n    priority = -np.abs(bins_remain_cap - item) / initial_capacity + bins_remain_cap / initial_capacity\n    \n    # Normalize the priority scores to be within a comparable range\n    # Using a simple normalization technique for demonstration; can be adjusted based on the problem's requirements\n    max_priority = np.max(priority[bins_remain_cap >= item])\n    if not np.isneginf(max_priority):  # Check if there's at least one valid bin\n        priority = np.where(bins_remain_cap >= item, (priority - np.min(priority[bins_remain_cap >= item])) / (max_priority - np.min(priority[bins_remain_cap >= item])), -np.inf)\n    else:\n        priority = -np.inf * np.ones_like(priority)\n    \n    # If a bin does not have enough capacity, set its priority to negative infinity\n    priority[bins_remain_cap < item] = -np.inf\n    \n    return priority",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 12.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 155.88872502451935,
    "mi": 76.54505240657787,
    "token_count": 149.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response4.txt_stdout.txt",
    "code_path": "problem_iter3_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is calculated based on a combination of the remaining capacity \n    of each bin and a normalization technique to enhance the scoring system.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the absolute difference between the remaining capacity and the item size\n    diff = np.abs(bins_remain_cap - item)\n    \n    # Calculate the priority score for each bin using a nuanced scoring system\n    # A bin with remaining capacity closest to the item size gets the highest priority\n    # We use a combination of the negative difference and the remaining capacity to break ties\n    priority = -diff / (bins_remain_cap + 1e-6)  # Adding a small value to avoid division by zero\n    \n    # If a bin does not have enough capacity, set its priority to negative infinity\n    priority[bins_remain_cap < item] = -np.inf\n    \n    # Normalize the priority scores using a softmax-like function to enhance contrast\n    finite_priorities = priority[np.isfinite(priority)]\n    if len(finite_priorities) > 0:\n        max_priority = np.max(finite_priorities)\n        min_priority = np.min(finite_priorities)\n        if max_priority != min_priority:\n            normalized_priority = (priority - min_priority) / (max_priority - min_priority)\n            # Apply a non-linear transformation to further enhance contrast\n            priority = normalized_priority ** 2\n    \n    return priority",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 155.88872502451935,
    "mi": 76.54505240657787,
    "token_count": 149.0,
    "exec_success": true
  }
]