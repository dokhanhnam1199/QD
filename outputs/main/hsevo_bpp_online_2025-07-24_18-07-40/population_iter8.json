[
  {
    "stdout_filepath": "problem_iter8_response0.txt_stdout.txt",
    "code_path": "problem_iter8_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines best-fit strategy with a bonus for nearly full bins.\n    Simple and focused approach for effective online Bin Packing.\n    \"\"\"\n    # Calculate the absolute difference between the item size and the remaining capacity of each bin\n    diff = np.abs(bins_remain_cap - item)\n    \n    # Calculate the priority score based on negative difference\n    priority = -diff\n    \n    # Set priority to negative infinity for bins that cannot hold the item\n    valid_bins = bins_remain_cap >= item\n    priority = np.where(valid_bins, priority, -np.inf)\n    \n    # Enhance priority for bins that are almost full after adding the item\n    priority = np.where((bins_remain_cap - item >= 0) & (bins_remain_cap - item < item), priority + 1e-6, priority)\n    \n    # Normalize the priority scores for valid bins\n    if np.any(valid_bins):  \n        max_priority = np.max(priority[valid_bins])\n        min_priority = np.min(priority[valid_bins])\n        priority = np.where(valid_bins, (priority - min_priority) / (max_priority - min_priority + 1e-6), priority)\n    \n    return priority",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 133.97977094150824,
    "mi": 90.97353528550462,
    "token_count": 163.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response1.txt_stdout.txt",
    "code_path": "problem_iter8_code1.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Priority score for each bin based on remaining capacity closest to item size and a bonus for nearly full bins.\n    \"\"\"\n    # Calculate priority score based on remaining capacity closest to item size\n    priority = -np.abs(bins_remain_cap - item)\n    \n    # Give a bonus to bins that are nearly full\n    priority += 0.1 * bins_remain_cap\n    \n    # Set priority to negative infinity for bins without enough capacity\n    priority[bins_remain_cap < item] = -np.inf\n    \n    return priority",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 133.97977094150824,
    "mi": 90.97353528550462,
    "token_count": 163.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response2.txt_stdout.txt",
    "code_path": "problem_iter8_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines best-fit strategy and bonus for nearly full bins.\n    Prioritizes bins with remaining capacity closest to the item size.\n    \"\"\"\n    # Calculate absolute difference between item size and bin remaining capacity\n    diff = np.abs(bins_remain_cap - item)\n    \n    # Set priority to negative infinity for bins that cannot hold the item\n    priority = np.where(bins_remain_cap < item, -np.inf, -diff)\n    \n    # Give a bonus to bins that are nearly full after adding the item\n    priority = np.where((bins_remain_cap >= item) & (bins_remain_cap - item < item), priority + 1, priority)\n    \n    # Normalize priority scores using softmax-like function for valid bins\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):\n        max_priority = np.max(priority[valid_bins])\n        min_priority = np.min(priority[valid_bins])\n        priority[valid_bins] = (priority[valid_bins] - min_priority) / (max_priority - min_priority + 1e-6)\n        priority[valid_bins] = np.exp(priority[valid_bins]) / (np.sum(np.exp(priority[valid_bins])) + 1e-6)\n    \n    return priority",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 133.97977094150824,
    "mi": 90.97353528550462,
    "token_count": 163.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response3.txt_stdout.txt",
    "code_path": "problem_iter8_code3.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines best-fit strategy with a bonus for nearly full bins.\n    \n    Prioritizes bins based on remaining capacity closest to item size and \n    gives a bonus to bins that are nearly full after adding the item.\n    \"\"\"\n    # Best-fit strategy: prioritize bins with remaining capacity closest to item size\n    priority = -np.abs(bins_remain_cap - item)\n    \n    # Bonus for bins that are nearly full after adding the item\n    nearly_full_bonus = np.where((bins_remain_cap - item >= 0) & (bins_remain_cap - item < item / 2), 1, 0)\n    priority += nearly_full_bonus\n    \n    # Normalize priority scores for valid bins\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):\n        max_priority = np.max(priority[valid_bins])\n        min_priority = np.min(priority[valid_bins])\n        priority = np.where(valid_bins, (priority - min_priority) / (max_priority - min_priority + 1e-6), -np.inf)\n    else:\n        priority = -np.inf * np.ones_like(priority)\n    \n    return priority",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 133.97977094150824,
    "mi": 90.97353528550462,
    "token_count": 163.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response4.txt_stdout.txt",
    "code_path": "problem_iter8_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines best-fit strategy with a bonus for nearly full bins.\n    \"\"\"\n    # Calculate remaining capacity after adding the item\n    remaining_capacity_after_addition = bins_remain_cap - item\n    \n    # Assign -inf priority to bins where the item doesn't fit\n    # Use negative remaining capacity for best-fit strategy\n    priority = np.where(remaining_capacity_after_addition >= 0, \n                        -np.abs(remaining_capacity_after_addition), \n                        -np.inf)\n    \n    # Give a bonus to bins that are nearly full after adding the item\n    priority = np.where((remaining_capacity_after_addition >= 0) & \n                        (remaining_capacity_after_addition < item / 2), \n                        priority + 1e-6, priority)\n    \n    # Normalize priority scores for valid bins\n    valid_bins = remaining_capacity_after_addition >= 0\n    if np.any(valid_bins):\n        min_priority, max_priority = np.min(priority[valid_bins]), np.max(priority[valid_bins])\n        priority = np.where(valid_bins, (priority - min_priority) / (max_priority - min_priority), -np.inf)\n    \n    return priority",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 133.97977094150824,
    "mi": 90.97353528550462,
    "token_count": 163.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response5.txt_stdout.txt",
    "code_path": "problem_iter8_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines best-fit strategy with a simple bonus for nearly full bins.\n    Prioritizes bins based on negative absolute difference and a bonus for bins that are almost full.\n    \"\"\"\n    # Calculate the absolute difference between the item size and the remaining capacity of each bin\n    diff = np.abs(bins_remain_cap - item)\n    \n    # Assign high priority to bins where item fits using best-fit strategy\n    priority = np.where(bins_remain_cap >= item, -diff, -np.inf)\n    \n    # Enhance priority for bins that are almost full after adding the item\n    priority = np.where((bins_remain_cap - item >= 0) & (bins_remain_cap - item < item), priority + 1e-6, priority)\n    \n    return priority",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 133.97977094150824,
    "mi": 90.97353528550462,
    "token_count": 163.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response6.txt_stdout.txt",
    "code_path": "problem_iter8_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines best-fit strategy with a simple scoring system for online Bin Packing Problem.\n    Prioritizes bins with remaining capacity closest to the item size.\n    \"\"\"\n    # Calculate the priority score for each bin\n    priority = -np.abs(bins_remain_cap - item)  # Best-fit strategy\n    \n    # Set priority to negative infinity if bin cannot fit the item\n    priority[bins_remain_cap < item] = -np.inf\n    \n    return priority",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 133.97977094150824,
    "mi": 90.97353528550462,
    "token_count": 163.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response7.txt_stdout.txt",
    "code_path": "problem_iter8_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for each bin based on a simple best-fit strategy.\n    \"\"\"\n    # Calculate the absolute difference between the remaining capacity and the item size\n    diff = np.abs(bins_remain_cap - item)\n    \n    # Prioritize bins with remaining capacity closest to the item size and having enough capacity\n    valid_bins = bins_remain_cap >= item\n    priority = np.where(valid_bins, -diff, -np.inf)  # Simple best-fit strategy\n    \n    # Normalize priority scores for valid bins using exponential normalization\n    if np.any(valid_bins):\n        max_priority = np.max(priority[valid_bins])\n        min_priority = np.min(priority[valid_bins])\n        priority[valid_bins] = (priority[valid_bins] - min_priority) / (max_priority - min_priority + 1e-9)\n        priority[valid_bins] = np.exp(priority[valid_bins])  # Exponential normalization\n    \n    return priority",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 133.97977094150824,
    "mi": 90.97353528550462,
    "token_count": 163.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response8.txt_stdout.txt",
    "code_path": "problem_iter8_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Priority score for each bin based on remaining capacity closest to item size and bin utilization.\n    \"\"\"\n    # Calculate priority score: favor bins with remaining capacity closest to item size and higher utilization\n    max_capacity = 1.0  # Uniform initial capacity for all bins\n    priority = -np.abs(bins_remain_cap - item) + 0.5 * (max_capacity - bins_remain_cap) / max_capacity\n    \n    # Set priority to negative infinity if bin cannot hold the item\n    priority[bins_remain_cap < item] = -np.inf\n    \n    return priority",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 133.97977094150824,
    "mi": 90.97353528550462,
    "token_count": 163.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response9.txt_stdout.txt",
    "code_path": "problem_iter8_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines best-fit strategy with a simple scoring system.\n    Prioritizes bins with remaining capacity closest to the item size.\n    \"\"\"\n    # Calculate absolute difference between item size and bin remaining capacity\n    diff = np.abs(bins_remain_cap - item)\n    \n    # Assign a very low priority to bins where the item doesn't fit\n    priority = np.where(bins_remain_cap < item, -np.inf, -diff)\n    \n    # Normalize priority scores using softmax-like function for valid bins\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):\n        max_priority = np.max(priority[valid_bins])\n        min_priority = np.min(priority[valid_bins])\n        priority[valid_bins] = (priority[valid_bins] - min_priority) / (max_priority - min_priority + 1e-6)\n        priority[valid_bins] = np.exp(priority[valid_bins]) / (np.sum(np.exp(priority[valid_bins])) + 1e-6)\n    \n    return priority",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 133.97977094150824,
    "mi": 90.97353528550462,
    "token_count": 163.0,
    "exec_success": true
  }
]