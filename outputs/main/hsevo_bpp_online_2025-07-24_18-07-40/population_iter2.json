[
  {
    "stdout_filepath": "problem_iter2_response0.txt_stdout.txt",
    "code_path": "problem_iter2_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for each bin based on remaining capacity and item size.\n    Combines nuanced scoring and normalization techniques for improved heuristic design.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Assign a very low priority to bins where the item doesn't fit\n    priority = np.where(remaining_cap_after_addition < 0, -np.inf, \n                        # For bins where the item fits, use a nuanced scoring system\n                        -remaining_cap_after_addition)\n    \n    # Normalize the priority scores using the exponential function\n    priority = np.exp(priority)\n    \n    return priority",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 41.20902501875006,
    "mi": 96.34859085287245,
    "token_count": 99.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response1.txt_stdout.txt",
    "code_path": "problem_iter2_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority score for each bin by combining best-fit strategy and nuanced scoring.\n    \n    Prioritizes bins with the least remaining capacity after adding the item.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_capacity_after_addition = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot accommodate the item\n    # For bins that can accommodate the item, use negative remaining capacity as priority\n    priority = np.where(remaining_capacity_after_addition >= 0, \n                        -remaining_capacity_after_addition, \n                        -np.inf)\n    \n    # Normalize priority scores using exponential function to enhance nuance\n    priority = np.exp(priority - np.max(priority[~np.isinf(priority)]))\n    \n    return priority",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 41.20902501875006,
    "mi": 96.34859085287245,
    "token_count": 99.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response2.txt_stdout.txt",
    "code_path": "problem_iter2_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for each bin based on remaining capacity and item size.\n    Combines best-fit strategy with exponential normalization for robustness.\n    \"\"\"\n    # Calculate priority score as negative absolute difference between remaining capacity and item size\n    priority = -np.abs(bins_remain_cap - item)\n    \n    # Set priority to negative infinity if bin cannot fit the item\n    priority[bins_remain_cap < item] = -np.inf\n    \n    # Apply softmax to convert scores to probabilities for normalization\n    exp_priority = np.exp(priority - np.max(priority[priority != -np.inf]))  # Subtract max for numerical stability\n    exp_priority[priority == -np.inf] = 0  # Set exp_priority to 0 where priority is -inf\n    \n    # Normalize to get final priority scores\n    sum_exp_priority = np.sum(exp_priority)\n    if sum_exp_priority > 0:\n        priority = exp_priority / sum_exp_priority\n    else:\n        priority = np.zeros_like(exp_priority)\n    \n    return priority",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 41.20902501875006,
    "mi": 96.34859085287245,
    "token_count": 99.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response3.txt_stdout.txt",
    "code_path": "problem_iter2_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for each bin by combining Best-Fit strategy with normalization.\n    Prioritizes bins that can accommodate the item and have remaining capacity closest to the item size.\n    \"\"\"\n    # Calculate the absolute difference between the item size and the remaining capacity\n    diff = np.abs(bins_remain_cap - item)\n    \n    # Bins that cannot accommodate the item get a priority of -inf\n    priority = np.where(bins_remain_cap >= item, -diff, -np.inf)\n    \n    # Normalize the priority scores for valid bins\n    valid_bins = priority != -np.inf\n    if np.any(valid_bins):\n        min_priority = np.min(priority[valid_bins])\n        max_priority = np.max(priority[valid_bins])\n        if max_priority != min_priority:\n            priority[valid_bins] = (priority[valid_bins] - min_priority) / (max_priority - min_priority)\n    \n    return priority",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 41.20902501875006,
    "mi": 96.34859085287245,
    "token_count": 99.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response4.txt_stdout.txt",
    "code_path": "problem_iter2_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for each bin based on a nuanced scoring system combining best-fit strategy and normalization.\n    \n    Prioritizes bins with remaining capacity closest to the item size, using exponential normalization.\n    \"\"\"\n    # Calculate the absolute difference between the item size and the remaining capacity of each bin\n    diff = np.abs(bins_remain_cap - item)\n    \n    # Set the priority score to negative infinity for bins that cannot hold the item\n    priority = np.where(bins_remain_cap < item, -np.inf, \n                        # For bins that can hold the item, use a scoring system that combines best-fit and normalization\n                        -diff / (bins_remain_cap + 1e-6) + np.exp(-diff / (item + 1e-6)))\n    \n    return priority",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 41.20902501875006,
    "mi": 96.34859085287245,
    "token_count": 99.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response5.txt_stdout.txt",
    "code_path": "problem_iter2_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority score for each bin using a nuanced scoring system with exponential normalization.\n\n    The priority is higher for bins that have enough capacity for the item and \n    lower remaining capacity after packing the item.\n    \"\"\"\n    # Calculate the remaining capacity after packing the item into each bin\n    remaining_cap_after_packing = bins_remain_cap - item\n    \n    # Check if the bin has enough capacity for the item\n    has_enough_capacity = remaining_cap_after_packing >= 0\n    \n    # Assign a very low priority to bins that cannot hold the item\n    priority = np.where(has_enough_capacity, -remaining_cap_after_packing, -np.inf)\n    \n    # Apply exponential normalization to priority scores\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:  \n        valid_priority = priority != -np.inf\n        priority[valid_priority] = np.exp(priority[valid_priority] - max_priority)\n        priority[~valid_priority] = 0\n    \n    return priority",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 41.20902501875006,
    "mi": 96.34859085287245,
    "token_count": 99.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response6.txt_stdout.txt",
    "code_path": "problem_iter2_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority score for each bin by combining Best Fit strategy and nuanced scoring.\n    Prioritizes bins with just enough capacity and uses exponential normalization.\n    \"\"\"\n    # Check if item can fit into the bin\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    \n    # Calculate priority using Best Fit strategy with exponential normalization\n    priority = np.where(valid_bins > 0, np.exp(-(bins_remain_cap - item) / bins_remain_cap), -1)\n    \n    return priority",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 41.20902501875006,
    "mi": 96.34859085287245,
    "token_count": 99.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response7.txt_stdout.txt",
    "code_path": "problem_iter2_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority score for each bin by combining best-fit strategy and nuanced scoring.\n    \"\"\"\n    # Calculate remaining capacity after adding the item\n    remaining_capacity_after_addition = bins_remain_cap - item\n    \n    # Assign -inf priority to bins where the item doesn't fit\n    priority = np.where(remaining_capacity_after_addition >= 0, \n                        # Use negative remaining capacity for best-fit strategy\n                        -remaining_capacity_after_addition + \n                        # Add a small bonus for bins that are almost full\n                        np.exp(-remaining_capacity_after_addition / item), \n                        -np.inf)\n    \n    return priority",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 41.20902501875006,
    "mi": 96.34859085287245,
    "token_count": 99.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response8.txt_stdout.txt",
    "code_path": "problem_iter2_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines elements of best-fit and nuanced scoring.\n    Prioritizes bins based on negative absolute difference and remaining capacity.\n    \"\"\"\n    # Calculate the absolute difference between the item size and the remaining capacity of each bin\n    diff = np.abs(bins_remain_cap - item)\n    \n    # Calculate the priority score as the negative of the difference, normalized by remaining capacity\n    priority = -diff / (bins_remain_cap + 1e-6)\n    \n    # Set the priority score to negative infinity for bins that cannot hold the item\n    priority[bins_remain_cap < item] = -np.inf\n    \n    # Enhance priority for bins that are almost full after adding the item\n    priority = np.where((bins_remain_cap - item >= 0) & (bins_remain_cap - item < item), priority + 1e-6, priority)\n    \n    return priority",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 41.20902501875006,
    "mi": 96.34859085287245,
    "token_count": 99.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response9.txt_stdout.txt",
    "code_path": "problem_iter2_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority score for each bin by combining best-fit strategy and nuanced scoring.\n    \"\"\"\n    # Check if item can fit into each bin and calculate remaining capacity after addition\n    can_fit = bins_remain_cap >= item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Assign high priority to bins where item fits, using negative absolute difference for best-fit strategy\n    priority = np.where(can_fit, -np.abs(remaining_cap_after_addition), -np.inf)\n    \n    # Normalize priority scores using exponential function for bins where item fits\n    max_priority = np.max(priority)\n    priority = np.where(can_fit, np.exp(priority - max_priority), priority)\n    \n    return priority",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 41.20902501875006,
    "mi": 96.34859085287245,
    "token_count": 99.0,
    "exec_success": true
  }
]