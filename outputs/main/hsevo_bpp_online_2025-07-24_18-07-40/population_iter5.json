[
  {
    "stdout_filepath": "problem_iter5_response0.txt_stdout.txt",
    "code_path": "problem_iter5_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority score for each bin by combining best-fit strategy and nuanced scoring with relative utilization.\n    \"\"\"\n    # Check if item can fit into each bin and calculate remaining capacity after addition\n    can_fit = bins_remain_cap >= item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Assign high priority to bins where item fits using a combination of best-fit and relative utilization\n    initial_capacity = 1.0  # Assuming uniform initial capacity for all bins\n    priority = np.where(can_fit, -np.abs(remaining_cap_after_addition) + bins_remain_cap / initial_capacity, -np.inf)\n    \n    # Normalize priority scores using exponential function for bins where item fits\n    max_priority = np.max(priority[can_fit]) if np.any(can_fit) else -np.inf\n    if not np.isneginf(max_priority):  \n        priority = np.where(can_fit, np.exp(priority - max_priority), priority)\n    \n    return priority",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 140.55415752892034,
    "mi": 90.2916994528432,
    "token_count": 139.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response1.txt_stdout.txt",
    "code_path": "problem_iter5_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for each bin based on a nuanced scoring system combining best-fit strategy and remaining capacity.\n    \"\"\"\n    # Calculate the absolute difference between the remaining capacity and the item size\n    diff = np.abs(bins_remain_cap - item)\n    \n    # Calculate priority score using a combination of difference and remaining capacity\n    priority = -diff / (bins_remain_cap + 1e-6) + bins_remain_cap\n    \n    # Set priority to negative infinity for bins without enough capacity\n    priority[bins_remain_cap < item] = -np.inf\n    \n    # Normalize priority scores for valid bins\n    valid_bins = priority != -np.inf\n    if np.any(valid_bins):\n        min_priority = np.min(priority[valid_bins])\n        max_priority = np.max(priority[valid_bins])\n        if max_priority != min_priority:\n            priority[valid_bins] = (priority[valid_bins] - min_priority) / (max_priority - min_priority)\n        else:\n            priority[valid_bins] = 1.0\n    \n    return priority",
    "response_id": 1,
    "tryHS": false,
    "obj": 149.30195452732352,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 140.55415752892034,
    "mi": 90.2916994528432,
    "token_count": 139.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response2.txt_stdout.txt",
    "code_path": "problem_iter5_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines best-fit strategy with nuanced scoring and normalization.\n    Prioritizes bins with remaining capacity closest to the item size.\n    \"\"\"\n    # Calculate the absolute difference between the item size and the remaining capacity of each bin\n    diff = np.abs(bins_remain_cap - item)\n    \n    # Initial capacity is assumed to be 1.0 for demonstration; adjust as needed\n    initial_capacity = 1.0\n    \n    # Scoring system that combines best-fit and relative utilization\n    priority = np.where(bins_remain_cap < item, -np.inf, \n                        -diff / initial_capacity + bins_remain_cap / initial_capacity + np.exp(-diff / (item + 1e-6)))\n    \n    return priority",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 140.55415752892034,
    "mi": 90.2916994528432,
    "token_count": 139.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response3.txt_stdout.txt",
    "code_path": "problem_iter5_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines nuanced scoring and normalization for online Bin Packing Problem.\n    Prioritizes bins based on negative absolute difference and remaining capacity.\n    \"\"\"\n    # Calculate the absolute difference between the item size and the remaining capacity of each bin\n    diff = np.abs(bins_remain_cap - item)\n    \n    # Initial capacity is assumed to be 1.0 for all bins\n    initial_capacity = 1.0\n    \n    # Calculate the priority score as a combination of negative difference and relative utilization\n    priority = -diff / initial_capacity + bins_remain_cap / initial_capacity\n    \n    # Normalize the priority scores for valid bins\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):  \n        max_priority = np.max(priority[valid_bins])\n        min_priority = np.min(priority[valid_bins])\n        priority = np.where(valid_bins, (priority - min_priority) / (max_priority - min_priority + 1e-6), -np.inf)\n    else:\n        priority = -np.inf * np.ones_like(priority)\n    \n    # Enhance priority for bins that are almost full after adding the item\n    priority = np.where((bins_remain_cap - item >= 0) & (bins_remain_cap - item < item), priority + 1e-6, priority)\n    \n    return priority",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.4674910251296325,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 140.55415752892034,
    "mi": 90.2916994528432,
    "token_count": 139.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response4.txt_stdout.txt",
    "code_path": "problem_iter5_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority score for each bin based on a combination of best-fit strategy and relative utilization.\n    \"\"\"\n    # Calculate the absolute difference between the remaining capacity of each bin and the item size\n    diff = np.abs(bins_remain_cap - item)\n    \n    # Calculate the priority score for each bin based on the difference and relative utilization\n    priority = -diff + bins_remain_cap\n    \n    # Normalize the priority scores using exponential normalization for valid bins\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):\n        max_priority = np.max(priority[valid_bins])\n        min_priority = np.min(priority[valid_bins])\n        priority[valid_bins] = (priority[valid_bins] - min_priority) / (max_priority - min_priority + 1e-9)\n        priority[valid_bins] = np.exp(priority[valid_bins])  # Exponential normalization\n    \n    # Set priority to negative infinity for bins that cannot hold the item\n    priority[~valid_bins] = -np.inf\n    \n    return priority",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 140.55415752892034,
    "mi": 90.2916994528432,
    "token_count": 139.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response5.txt_stdout.txt",
    "code_path": "problem_iter5_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for each bin based on best-fit strategy and nuanced normalization.\n    Combines the benefits of nuanced scoring and relative utilization.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Assign a very low priority to bins where the item doesn't fit\n    priority = np.where(remaining_cap_after_addition < 0, -np.inf, \n                        # For bins where the item fits, use a best-fit scoring system with relative utilization\n                        -np.abs(remaining_cap_after_addition) + bins_remain_cap)\n    \n    # Normalize the priority scores using the exponential function\n    valid_bins = np.isfinite(priority)\n    if np.any(valid_bins):  \n        max_priority = np.max(priority[valid_bins])\n        min_priority = np.min(priority[valid_bins])\n        # Normalize the priority scores to avoid identical values\n        priority[valid_bins] = (priority[valid_bins] - min_priority) / (max_priority - min_priority)\n        priority[valid_bins] = np.exp(priority[valid_bins])  # Apply exponential normalization\n    \n    return priority",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 140.55415752892034,
    "mi": 90.2916994528432,
    "token_count": 139.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response6.txt_stdout.txt",
    "code_path": "problem_iter5_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines best-fit strategy with nuanced normalization.\n    Prioritizes bins with remaining capacity closest to the item size.\n    \"\"\"\n    # Calculate absolute difference between item size and bin remaining capacity\n    diff = np.abs(bins_remain_cap - item)\n    \n    # Set priority to negative infinity for bins that cannot hold the item\n    priority = np.where(bins_remain_cap < item, -np.inf, \n                        # Combine best-fit strategy with relative utilization\n                        -diff / (item + 1e-6) + bins_remain_cap / (np.max(bins_remain_cap) + 1e-6))\n    \n    # Normalize priority scores using softmax-like function for valid bins\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):\n        max_priority = np.max(priority[valid_bins])\n        min_priority = np.min(priority[valid_bins])\n        priority[valid_bins] = (priority[valid_bins] - min_priority) / (max_priority - min_priority + 1e-6)\n        priority[valid_bins] = np.exp(priority[valid_bins]) / (np.sum(np.exp(priority[valid_bins])) + 1e-6)\n    \n    return priority",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 140.55415752892034,
    "mi": 90.2916994528432,
    "token_count": 139.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response7.txt_stdout.txt",
    "code_path": "problem_iter5_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines best-fit strategy with nuanced scoring and normalization.\n    \"\"\"\n    # Calculate remaining capacity after adding the item\n    remaining_capacity_after_addition = bins_remain_cap - item\n    \n    # Assign -inf priority to bins where the item doesn't fit\n    # Use negative remaining capacity for best-fit strategy and add a bonus for almost full bins\n    priority = np.where(remaining_capacity_after_addition >= 0, \n                        -np.abs(remaining_capacity_after_addition) + \n                        bins_remain_cap / (bins_remain_cap + item),  # bonus for less utilized bins\n                        -np.inf)\n    \n    # Normalize priority scores for valid bins\n    valid_bins = remaining_capacity_after_addition >= 0\n    if np.any(valid_bins):\n        min_priority, max_priority = np.min(priority[valid_bins]), np.max(priority[valid_bins])\n        priority = np.where(valid_bins, (priority - min_priority) / (max_priority - min_priority), -np.inf)\n    \n    return priority",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 140.55415752892034,
    "mi": 90.2916994528432,
    "token_count": 139.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response8.txt_stdout.txt",
    "code_path": "problem_iter5_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines Best-Fit strategy with nuanced scoring and normalization.\n    Prioritizes bins that can accommodate the item, have remaining capacity closest to the item size, and are less utilized.\n    \"\"\"\n    # Calculate the absolute difference and relative utilization\n    diff = np.abs(bins_remain_cap - item)\n    utilization = bins_remain_cap  # Assuming initial capacity is 1.0\n    \n    # Calculate priority score combining both factors\n    priority = np.where(bins_remain_cap >= item, -diff + utilization, -np.inf)\n    \n    # Normalize the priority scores for valid bins using a simple normalization technique\n    valid_bins = priority != -np.inf\n    if np.any(valid_bins):\n        min_priority = np.min(priority[valid_bins])\n        max_priority = np.max(priority[valid_bins])\n        if max_priority != min_priority:\n            priority[valid_bins] = (priority[valid_bins] - min_priority) / (max_priority - min_priority)\n    \n    return priority",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 140.55415752892034,
    "mi": 90.2916994528432,
    "token_count": 139.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response9.txt_stdout.txt",
    "code_path": "problem_iter5_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines best-fit strategy with nuanced scoring and normalization for online Bin Packing Problem.\n    \"\"\"\n    # Calculate initial priority score based on negative absolute difference and remaining capacity\n    priority = -np.abs(bins_remain_cap - item) + bins_remain_cap\n    \n    # Set priority to negative infinity if bin cannot fit the item\n    priority[bins_remain_cap < item] = -np.inf\n    \n    # Apply softmax normalization for robustness\n    valid_priority = priority[priority != -np.inf]\n    if len(valid_priority) > 0:\n        exp_priority = np.exp(priority - np.max(valid_priority))  # Subtract max for numerical stability\n        exp_priority[priority == -np.inf] = 0\n        priority = exp_priority / np.sum(exp_priority)\n    else:\n        priority = np.zeros_like(priority)\n    \n    return priority",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 140.55415752892034,
    "mi": 90.2916994528432,
    "token_count": 139.0,
    "exec_success": true
  }
]