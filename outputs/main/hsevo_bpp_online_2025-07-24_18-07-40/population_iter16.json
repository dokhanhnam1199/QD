[
  {
    "stdout_filepath": "problem_iter14_response0.txt_stdout.txt",
    "code_path": "problem_iter14_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines best-fit strategy with a bonus for bins that are nearly full after adding the item and normalization.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_cap_after_add = bins_remain_cap - item\n    \n    # Best-fit strategy: prioritize bins with remaining capacity closest to item size\n    priority = np.where(bins_remain_cap >= item, -np.abs(bins_remain_cap - item), -np.inf)\n    \n    # Enhance priority for bins that are almost full after adding the item\n    bonus = np.where((remaining_cap_after_add >= 0) & (remaining_cap_after_add < item), 1e-6, 0)\n    priority += bonus\n    \n    # Normalize the priority scores for valid bins\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):  \n        max_priority = np.max(priority[valid_bins])\n        min_priority = np.min(priority[valid_bins])\n        priority = np.where(valid_bins, (priority - min_priority) / (max_priority - min_priority + 1e-6), priority)\n    \n    return priority",
    "response_id": 0,
    "tryHS": true,
    "obj": 4.048663741523748,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 220.92066675263135,
    "mi": 87.1667583235797,
    "token_count": 177.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response1.txt_stdout.txt",
    "code_path": "problem_iter14_code1.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines best-fit strategy with bonus for nearly full bins and normalization.\n    \n    Prioritizes bins based on remaining capacity closest to item size, \n    adds bonus for bins that are nearly full, and normalizes priority scores.\n    \"\"\"\n    # Best-fit strategy: prioritize bins with remaining capacity closest to item size\n    priority = -np.abs(bins_remain_cap - item)\n    \n    # Add bonus for bins that are nearly full after adding the item\n    remaining_cap_after_add = np.where(bins_remain_cap >= item, bins_remain_cap - item, np.inf)\n    bonus = -remaining_cap_after_add / (item + 1e-6)  # Normalize the remaining capacity\n    \n    # Combine best-fit priority and bonus\n    priority += bonus\n    \n    # Normalize priority scores for valid bins\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):\n        max_priority = np.max(priority[valid_bins])\n        min_priority = np.min(priority[valid_bins])\n        priority = np.where(valid_bins, (priority - min_priority) / (max_priority - min_priority + 1e-6), -np.inf)\n    else:\n        priority = -np.inf * np.ones_like(priority)\n    \n    return priority",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 220.92066675263135,
    "mi": 87.1667583235797,
    "token_count": 177.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response2.txt_stdout.txt",
    "code_path": "problem_iter14_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines best-fit strategy with a bonus for nearly full bins and normalized priority scores.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Set priority based on best-fit strategy\n    priority = -np.abs(bins_remain_cap - item)\n    \n    # Enhance priority for bins that are almost full after adding the item\n    priority = np.where((remain_cap_after_add >= 0) & (remain_cap_after_add < item), priority + 1e-6, priority)\n    \n    # Set priority to negative infinity for bins that cannot hold the item\n    valid_bins = bins_remain_cap >= item\n    priority = np.where(valid_bins, priority, -np.inf)\n    \n    # Normalize the priority scores for valid bins\n    if np.any(valid_bins):  \n        max_priority = np.max(priority[valid_bins])\n        min_priority = np.min(priority[valid_bins])\n        priority = np.where(valid_bins, (priority - min_priority) / (max_priority - min_priority + 1e-6), priority)\n    \n    return priority",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 220.92066675263135,
    "mi": 87.1667583235797,
    "token_count": 177.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response3.txt_stdout.txt",
    "code_path": "problem_iter14_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines best-fit strategy with a bonus for nearly full bins and normalization.\n    \n    Prioritizes bins based on remaining capacity closest to item size, \n    with a bonus for bins that would be nearly full after adding the item.\n    \"\"\"\n    # Define the capacity of the bins (assuming it's the same for all bins)\n    bin_capacity = np.max(bins_remain_cap) + (np.max(bins_remain_cap) - np.min(bins_remain_cap))\n    \n    # Best-fit strategy: prioritize bins with remaining capacity closest to item size\n    best_fit_priority = -np.abs(bins_remain_cap - item)\n    \n    # Give a bonus to bins that would be filled to at least 90% capacity after adding the item\n    bonus = np.where((bins_remain_cap - item) / bin_capacity <= 0.1, 10, 0)\n    \n    # Combine the best-fit priority and the bonus\n    priority = best_fit_priority + bonus\n    \n    # If a bin does not have enough capacity, set its priority to negative infinity\n    priority[bins_remain_cap < item] = -np.inf\n    \n    # Normalize priority scores for valid bins\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):\n        max_priority = np.max(priority[valid_bins])\n        min_priority = np.min(priority[valid_bins])\n        priority = np.where(valid_bins, (priority - min_priority) / (max_priority - min_priority + 1e-6), -np.inf)\n    \n    return priority",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 220.92066675263135,
    "mi": 87.1667583235797,
    "token_count": 177.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response4.txt_stdout.txt",
    "code_path": "problem_iter14_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines best-fit strategy with a bonus for nearly full bins and normalization.\n    \n    Prioritizes bins based on remaining capacity closest to item size, \n    gives a bonus to nearly full bins, and normalizes priority scores.\n    \"\"\"\n    # Best-fit strategy: prioritize bins with remaining capacity closest to item size\n    priority = -np.abs(bins_remain_cap - item)\n    \n    # Give a bonus to bins that are nearly full (remaining capacity less than 0.5 * item size)\n    nearly_full_bonus = bins_remain_cap < 0.5 * item\n    priority[nearly_full_bonus] += 1\n    \n    # If a bin does not have enough capacity, set its priority to negative infinity\n    priority[bins_remain_cap < item] = -np.inf\n    \n    # Normalize priority scores for valid bins\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):\n        max_priority = np.max(priority[valid_bins])\n        min_priority = np.min(priority[valid_bins])\n        priority = np.where(valid_bins, (priority - min_priority) / (max_priority - min_priority + 1e-6), -np.inf)\n    \n    return priority",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 220.92066675263135,
    "mi": 87.1667583235797,
    "token_count": 177.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response5.txt_stdout.txt",
    "code_path": "problem_iter14_code5.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines best-fit strategy with a bonus for bins that are nearly full after adding the item and normalizes priority scores.\n    \"\"\"\n    # Calculate remaining capacity after adding item to each bin\n    remaining_cap_after_add = bins_remain_cap - item\n    \n    # Best-fit strategy with a check for valid bins\n    valid_bins = bins_remain_cap >= item\n    priority = np.where(valid_bins, -np.abs(bins_remain_cap - item), -np.inf)\n    \n    # Bonus for bins that are almost full after adding the item\n    bonus = np.where((remaining_cap_after_add >= 0) & (remaining_cap_after_add < item), 1e-6, 0)\n    priority += bonus\n    \n    # Normalize priority scores for valid bins\n    if np.any(valid_bins):\n        max_priority = np.max(priority[valid_bins])\n        min_priority = np.min(priority[valid_bins])\n        priority = np.where(valid_bins, (priority - min_priority) / (max_priority - min_priority + 1e-6), -np.inf)\n    \n    return priority",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 220.92066675263135,
    "mi": 87.1667583235797,
    "token_count": 177.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response6.txt_stdout.txt",
    "code_path": "problem_iter14_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines best-fit strategy with a bonus for nearly full bins and normalization.\n    \"\"\"\n    # Best-fit strategy: prioritize bins with remaining capacity closest to item size\n    diff = np.abs(bins_remain_cap - item)\n    priority = np.where(bins_remain_cap >= item, -diff, -np.inf)\n    \n    # Enhance priority for bins that are almost full after adding the item\n    remaining_after_add = bins_remain_cap - item\n    priority = np.where((remaining_after_add >= 0) & (remaining_after_add < item/2), priority + 1e-6, priority)\n    \n    # Normalize priority scores for valid bins\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):\n        max_priority = np.max(priority[valid_bins])\n        min_priority = np.min(priority[valid_bins])\n        priority = np.where(valid_bins, (priority - min_priority) / (max_priority - min_priority + 1e-6), -np.inf)\n    \n    return priority",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 220.92066675263135,
    "mi": 87.1667583235797,
    "token_count": 177.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response7.txt_stdout.txt",
    "code_path": "problem_iter14_code7.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines best-fit strategy with a nuanced handling of remaining capacity.\n    \n    Prioritizes bins based on remaining capacity closest to item size and \n    remaining capacity after adding the item, with a bonus for nearly full bins.\n    \"\"\"\n    # Best-fit strategy: prioritize bins with remaining capacity closest to item size\n    priority = -np.abs(bins_remain_cap - item)\n    \n    # Nuanced handling: consider remaining capacity after adding the item and give a bonus to nearly full bins\n    remaining_cap_after_add = np.where(bins_remain_cap >= item, bins_remain_cap - item, np.inf)\n    priority += -remaining_cap_after_add / (item + 1e-6)  # Normalize the remaining capacity\n    \n    # Bonus for nearly full bins\n    nearly_full_bonus = np.where(bins_remain_cap >= item, (bins_remain_cap - item) < item * 0.1, False)\n    priority += np.where(nearly_full_bonus, 1, 0)  # Add a bonus for bins that are 90% full\n    \n    # Normalize priority scores for valid bins\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):\n        max_priority = np.max(priority[valid_bins])\n        min_priority = np.min(priority[valid_bins])\n        priority = np.where(valid_bins, (priority - min_priority) / (max_priority - min_priority + 1e-6), -np.inf)\n    else:\n        priority = -np.inf * np.ones_like(priority)\n    \n    return priority",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 220.92066675263135,
    "mi": 87.1667583235797,
    "token_count": 177.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response8.txt_stdout.txt",
    "code_path": "problem_iter14_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines best-fit strategy with a bonus for nearly full bins and normalization.\n    \n    Prioritizes bins based on remaining capacity closest to item size, \n    gives a bonus to nearly full bins, and normalizes priority scores.\n    \"\"\"\n    # Best-fit strategy: prioritize bins with remaining capacity closest to item size\n    priority = -np.abs(bins_remain_cap - item)\n    \n    # Give a bonus to bins that are nearly full (remaining capacity less than 0.5 * item size)\n    nearly_full_bonus = bins_remain_cap < 0.5 * item\n    priority[nearly_full_bonus] += 1\n    \n    # If a bin does not have enough capacity, set its priority to negative infinity\n    priority[bins_remain_cap < item] = -np.inf\n    \n    # Normalize priority scores for valid bins\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):\n        max_priority = np.max(priority[valid_bins])\n        min_priority = np.min(priority[valid_bins])\n        priority = np.where(valid_bins, (priority - min_priority) / (max_priority - min_priority + 1e-6), -np.inf)\n    \n    return priority",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 220.92066675263135,
    "mi": 87.1667583235797,
    "token_count": 177.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response9.txt_stdout.txt",
    "code_path": "problem_iter14_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines best-fit strategy with a bonus for nearly full bins and normalized remaining capacity.\n    \"\"\"\n    # Best-fit strategy\n    best_fit = -np.abs(bins_remain_cap - item)\n    \n    # Bonus for bins that are nearly full after adding the item\n    remaining_cap = np.where(bins_remain_cap >= item, bins_remain_cap - item, np.inf)\n    bonus = -remaining_cap / np.max(remaining_cap + 1e-6)\n    \n    # Combine best-fit with bonus and normalize\n    priority = best_fit + 0.5 * bonus\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):\n        max_priority = np.max(priority[valid_bins])\n        min_priority = np.min(priority[valid_bins])\n        priority = np.where(valid_bins, (priority - min_priority) / (max_priority - min_priority + 1e-6), -np.inf)\n    else:\n        priority = -np.inf * np.ones_like(priority)\n    \n    return priority",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 220.92066675263135,
    "mi": 87.1667583235797,
    "token_count": 177.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter15_response0.txt_stdout.txt",
    "code_path": "problem_iter15_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is calculated based on the remaining capacity of each bin and \n    whether the bin has enough capacity to hold the item. A bin with a remaining \n    capacity closest to the item size gets the highest priority among the bins \n    that can hold the item. If no bin can hold the item, the bin with the largest \n    remaining capacity gets the highest priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priority array with negative infinity\n    priority = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    \n    # Check if there are bins that can hold the item\n    valid_bins = bins_remain_cap >= item\n    \n    # For bins that can hold the item, calculate priority based on remaining capacity\n    if np.any(valid_bins):\n        # A bin with remaining capacity closest to the item size gets the highest priority\n        priority[valid_bins] = -np.abs(bins_remain_cap[valid_bins] - item)\n    else:\n        # If no bin can hold the item, the bin with the largest remaining capacity gets the highest priority\n        priority = bins_remain_cap\n    \n    return priority",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 30.0,
    "mi": 66.75242731831115,
    "token_count": 68.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter15_response1.txt_stdout.txt",
    "code_path": "problem_iter15_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is calculated based on the remaining capacity of each bin.\n    A bin with a remaining capacity closest to the item size and not less than it gets the highest priority.\n    If multiple bins have the same remaining capacity closest to the item size, \n    the one with the smallest remaining capacity gets the highest priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin\n    # A bin with remaining capacity closest to and not less than the item size gets the highest priority\n    priority = np.where(bins_remain_cap >= item, -bins_remain_cap + item, -np.inf)\n    \n    return priority",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 30.0,
    "mi": 66.75242731831115,
    "token_count": 68.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter15_response2.txt_stdout.txt",
    "code_path": "problem_iter15_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is calculated based on the remaining capacity of each bin and \n    whether the bin can accommodate the item. It combines a best-fit strategy \n    with a nuanced handling of remaining capacity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # First, filter out bins that cannot accommodate the item and set their priority to negative infinity\n    priority = np.where(bins_remain_cap >= item, \n                         # For bins that can accommodate the item, use a best-fit strategy\n                         # by prioritizing bins with the least remaining capacity after adding the item\n                         - (bins_remain_cap - item), \n                         -np.inf)\n    \n    return priority",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 30.0,
    "mi": 66.75242731831115,
    "token_count": 68.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter15_response3.txt_stdout.txt",
    "code_path": "problem_iter15_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is calculated based on the remaining capacity of each bin and the item size.\n    A bin with enough capacity and the smallest remaining capacity after adding the item gets the highest priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_cap_after_add = bins_remain_cap - item\n    \n    # A bin with not enough capacity gets a priority of negative infinity\n    priority = np.where(remaining_cap_after_add >= 0, -remaining_cap_after_add, -np.inf)\n    \n    return priority",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 30.0,
    "mi": 66.75242731831115,
    "token_count": 68.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter15_response4.txt_stdout.txt",
    "code_path": "problem_iter15_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is calculated based on a combination of best-fit strategy and \n    a nuanced handling of the remaining capacity. A bin with enough capacity \n    and the smallest remaining capacity after adding the item gets the highest priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priority array with negative infinity\n    priority = np.full_like(bins_remain_cap, -np.inf)\n    \n    # For bins that can accommodate the item, calculate the priority\n    valid_bins = bins_remain_cap >= item\n    priority[valid_bins] = - (bins_remain_cap[valid_bins] - item)\n    \n    return priority",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 30.0,
    "mi": 66.75242731831115,
    "token_count": 68.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter16_response0.txt_stdout.txt",
    "code_path": "problem_iter16_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, \n                bonus_threshold_ratio: float = 0.5799306293608957, \n                bonus_value: float = 9.06245656715701e-06, \n                epsilon: float = 9.056276669111845e-06) -> np.ndarray:\n    \"\"\"\n    Combines best-fit strategy with a bonus for bins that are nearly full after adding the item and normalization.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_cap_after_add = bins_remain_cap - item\n    \n    # Best-fit strategy: prioritize bins with remaining capacity closest to item size\n    priority = np.where(bins_remain_cap >= item, -np.abs(bins_remain_cap - item), -np.inf)\n    \n    # Enhance priority for bins that are almost full after adding the item\n    bonus = np.where((remaining_cap_after_add >= 0) & (remaining_cap_after_add < item * bonus_threshold_ratio), bonus_value, 0)\n    priority += bonus\n    \n    # Normalize the priority scores for valid bins\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):  \n        max_priority = np.max(priority[valid_bins])\n        min_priority = np.min(priority[valid_bins])\n        priority = np.where(valid_bins, (priority - min_priority) / (max_priority - min_priority + epsilon), priority)\n    \n    return priority",
    "response_id": 0,
    "tryHS": true,
    "obj": 4.048663741523748,
    "SLOC": 14.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 202.11890788006698,
    "mi": 89.12272143575554,
    "token_count": 187.0,
    "exec_success": true
  }
]