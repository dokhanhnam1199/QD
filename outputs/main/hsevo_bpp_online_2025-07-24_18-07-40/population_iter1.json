[
  {
    "stdout_filepath": "problem_iter1_response0.txt_stdout.txt",
    "code_path": "problem_iter1_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # For bins that have enough capacity, the priority is the negative of the remaining capacity after addition\n    # This encourages packing items tightly into bins\n    priority = np.where(remaining_cap_after_addition >= 0, -remaining_cap_after_addition, -np.inf)\n    \n    # Normalize the priority scores to be between 0 and 1\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:  # Check if there are bins with enough capacity\n        priority = np.where(priority != -np.inf, priority / max_priority, 0)\n    else:\n        priority = np.zeros_like(bins_remain_cap)\n    \n    return priority",
    "response_id": 0,
    "tryHS": false,
    "obj": 86.58755484643,
    "SLOC": 10.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 110.36149671375918,
    "mi": 83.11991936758335,
    "token_count": 133.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response1.txt_stdout.txt",
    "code_path": "problem_iter1_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is calculated based on the remaining capacity of each bin.\n    A bin with a remaining capacity closest to the item size gets the highest priority.\n    If a bin has not enough capacity to hold the item, its priority is set to negative infinity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin\n    # A bin with remaining capacity closest to the item size gets the highest priority\n    priority = -np.abs(bins_remain_cap - item)\n    \n    # If a bin does not have enough capacity, set its priority to negative infinity\n    priority[bins_remain_cap < item] = -np.inf\n    \n    return priority",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 110.36149671375918,
    "mi": 83.11991936758335,
    "token_count": 133.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response2.txt_stdout.txt",
    "code_path": "problem_iter1_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    \n    This function implements the First-Fit decreasing heuristic with a twist.\n    It prioritizes bins that have just enough capacity to hold the item.\n    \n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin\n    # The score is high if the bin has just enough capacity to hold the item\n    priority_scores = np.where(bins_remain_cap >= item, \n                               # Priority is inversely proportional to the remaining capacity\n                               1 / (bins_remain_cap + 1e-6), \n                               # If the bin cannot hold the item, its priority is -inf\n                               -np.inf)\n    \n    return priority_scores",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 110.36149671375918,
    "mi": 83.11991936758335,
    "token_count": 133.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response3.txt_stdout.txt",
    "code_path": "problem_iter1_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Check if the item can fit into the bin\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    \n    # Prioritize bins that have just enough capacity for the item (Best Fit strategy)\n    priority = np.where(valid_bins > 0, 1 - (bins_remain_cap - item) / bins_remain_cap, -1)\n    \n    # Return the priority score for each bin\n    return priority",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 110.36149671375918,
    "mi": 83.11991936758335,
    "token_count": 133.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response4.txt_stdout.txt",
    "code_path": "problem_iter1_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is calculated based on the remaining capacity of each bin.\n    The bin with the least remaining capacity that can still fit the item gets the highest priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin\n    # The bin that has just enough capacity to fit the item gets the highest priority\n    priority = np.where(bins_remain_cap >= item, 1 - bins_remain_cap / (item + bins_remain_cap), -1)\n    \n    # To avoid division by zero and to handle the case where item is zero\n    # we use np.where to assign a low priority to bins that cannot fit the item\n    \n    return priority",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 110.36149671375918,
    "mi": 83.11991936758335,
    "token_count": 133.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response5.txt_stdout.txt",
    "code_path": "problem_iter1_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins that have just enough capacity for the item.\n    It uses a Gaussian-like function to score bins based on their remaining capacity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin based on its remaining capacity\n    # We want to prioritize bins that have just enough capacity for the item\n    # So, we use a scoring function that peaks when the remaining capacity equals the item size\n    scores = np.exp(-((bins_remain_cap - item) / item) ** 2)\n\n    # We also want to avoid bins that don't have enough capacity for the item\n    # So, we set the score to zero for bins that are too small\n    scores[bins_remain_cap < item] = 0\n\n    return scores",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 110.36149671375918,
    "mi": 83.11991936758335,
    "token_count": 133.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response6.txt_stdout.txt",
    "code_path": "problem_iter1_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is calculated based on the remaining capacity of each bin.\n    A bin with a remaining capacity closest to the item size gets the highest priority.\n    If a bin cannot hold the item, its priority is set to negative infinity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin\n    # A bin with remaining capacity closest to the item size gets the highest priority\n    priority = np.where(bins_remain_cap >= item, -np.abs(bins_remain_cap - item), -np.inf)\n    \n    return priority",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 110.36149671375918,
    "mi": 83.11991936758335,
    "token_count": 133.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response7.txt_stdout.txt",
    "code_path": "problem_iter1_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_capacity_after_addition = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot accommodate the item\n    priority = np.where(remaining_capacity_after_addition >= 0, \n                        # For bins that can accommodate the item, prioritize those with the least remaining capacity\n                        -remaining_capacity_after_addition, \n                        # For bins that cannot accommodate the item, assign a very low priority\n                        -np.inf)\n    \n    return priority",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 110.36149671375918,
    "mi": 83.11991936758335,
    "token_count": 133.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response8.txt_stdout.txt",
    "code_path": "problem_iter1_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin based on the remaining capacity and item size.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score based on how well the item fits into the bin\n    # The closer the item size is to the remaining capacity, the higher the priority\n    priority = np.where(bins_remain_cap >= item, bins_remain_cap - item, -np.inf)\n    \n    # Normalize the priority scores to ensure they are on the same scale\n    # Using the negative exponential to give higher scores to bins that are closer to being full\n    priority = np.exp(-priority)\n    \n    # Return the priority scores\n    return priority",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 110.36149671375918,
    "mi": 83.11991936758335,
    "token_count": 133.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response9.txt_stdout.txt",
    "code_path": "problem_iter1_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is calculated based on the remaining capacity of each bin.\n    A bin with a remaining capacity closest to the item size gets the highest priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Bins that cannot accommodate the item get a priority of -inf\n    priority = np.where(remaining_cap_after_addition >= 0, -remaining_cap_after_addition, -np.inf)\n    \n    # Normalize the priority to avoid potential overflow\n    max_priority = np.max(priority)\n    if max_priority == -np.inf:  # No bin can accommodate the item\n        return np.zeros_like(bins_remain_cap)\n    else:\n        return priority - max_priority",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 110.36149671375918,
    "mi": 83.11991936758335,
    "token_count": 133.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response10.txt_stdout.txt",
    "code_path": "problem_iter1_code10.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # For bins that can accommodate the item, prioritize the bin with the least remaining capacity\n    # This is a \"Best Fit\" strategy, which tends to pack items tightly\n    priority = np.where(remaining_cap_after_addition >= 0, -remaining_cap_after_addition, -np.inf)\n    \n    # Normalize the priority scores to be between 0 and 1 for bins that can accommodate the item\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:  # Check if there are bins that can accommodate the item\n        priority = np.where(priority != -np.inf, priority - max_priority, priority)\n    \n    return priority",
    "response_id": 10,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 110.36149671375918,
    "mi": 83.11991936758335,
    "token_count": 133.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response11.txt_stdout.txt",
    "code_path": "problem_iter1_code11.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    The priority is based on the remaining capacity of the bin and the size of the item.\n    A bin with remaining capacity closer to the item size gets higher priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin based on the remaining capacity\n    # A bin with remaining capacity closer to the item size gets higher priority\n    priority = np.where(bins_remain_cap >= item, \n                        1 - np.abs(bins_remain_cap - item) / item, \n                        0)\n    return priority",
    "response_id": 11,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 110.36149671375918,
    "mi": 83.11991936758335,
    "token_count": 133.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response12.txt_stdout.txt",
    "code_path": "problem_iter1_code12.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This function implements the First-Fit Decreasing Height (FFDH) heuristic \n    with a twist. It prioritizes bins that have just enough capacity to hold \n    the item, and penalizes bins that would have a lot of remaining capacity \n    after the item is added.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Check if the item can fit in each bin\n    item_fits = remaining_cap_after_addition >= 0\n    \n    # Calculate the priority score for each bin\n    # Bins that can fit the item and have just enough capacity are prioritized\n    priority = np.where(item_fits, -remaining_cap_after_addition, -np.inf)\n    \n    return priority",
    "response_id": 12,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 110.36149671375918,
    "mi": 83.11991936758335,
    "token_count": 133.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response13.txt_stdout.txt",
    "code_path": "problem_iter1_code13.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is calculated based on how well the item fits into the bin.\n    The bin that has just enough capacity for the item gets the highest priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin\n    # The score is high when the remaining capacity is just enough for the item\n    # We use a negative exponent to penalize bins that are too large or too small\n    priority = np.where(bins_remain_cap >= item, np.exp(-(bins_remain_cap - item)), 0)\n    \n    return priority",
    "response_id": 13,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 110.36149671375918,
    "mi": 83.11991936758335,
    "token_count": 133.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response14.txt_stdout.txt",
    "code_path": "problem_iter1_code14.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    \n    The priority is calculated based on the remaining capacity of each bin.\n    The bin with the least remaining capacity that can still fit the item gets the highest priority.\n    \n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    \n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Check if the item can fit into each bin\n    can_fit = bins_remain_cap >= item\n    \n    # Calculate the priority score for each bin\n    # The bin with the least remaining capacity that can fit the item gets the highest priority\n    priority = np.where(can_fit, bins_remain_cap.max() - bins_remain_cap, -np.inf)\n    \n    return priority",
    "response_id": 14,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 110.36149671375918,
    "mi": 83.11991936758335,
    "token_count": 133.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response15.txt_stdout.txt",
    "code_path": "problem_iter1_code15.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin based on \n    the remaining capacity and the size of the item.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin based on how well the item fits\n    # into the remaining capacity. The closer the item size is to the remaining\n    # capacity, the higher the priority.\n    priority_score = np.where(bins_remain_cap >= item, \n                              bins_remain_cap - item, \n                              -np.inf)\n    \n    # To avoid division by zero and to ensure that bins with more remaining \n    # capacity after placing the item are prioritized less, we use the \n    # negative of the remaining capacity after placing the item as a secondary \n    # priority metric.\n    return priority_score",
    "response_id": 15,
    "tryHS": false,
    "obj": 149.30195452732352,
    "SLOC": 10.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 110.36149671375918,
    "mi": 83.11991936758335,
    "token_count": 133.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response16.txt_stdout.txt",
    "code_path": "problem_iter1_code16.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    \n    The priority is calculated based on the remaining capacity of each bin. \n    The bin with the least remaining capacity that can still fit the item gets the highest priority.\n    \n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin\n    # The score is high if the bin has enough capacity and is close to being full\n    scores = np.where(bins_remain_cap >= item, bins_remain_cap - item, -np.inf)\n    \n    # Normalize the scores to avoid overflow\n    max_score = np.max(scores)\n    if max_score > -np.inf:\n        scores = scores - max_score\n    \n    # Apply softmax to convert scores to probabilities\n    exp_scores = np.exp(scores)\n    priority = exp_scores / np.sum(exp_scores)\n    \n    return priority",
    "response_id": 16,
    "tryHS": false,
    "obj": 149.30195452732352,
    "SLOC": 10.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 110.36149671375918,
    "mi": 83.11991936758335,
    "token_count": 133.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response17.txt_stdout.txt",
    "code_path": "problem_iter1_code17.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is calculated based on the remaining capacity of each bin.\n    The bin with the least remaining capacity that can still fit the item gets the highest priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin\n    # A bin gets a high priority if it has just enough capacity to fit the item\n    priority = np.where(bins_remain_cap >= item, 1 - bins_remain_cap / (item + bins_remain_cap), -1.0)\n    \n    # Ensure that bins that cannot fit the item get a lower priority\n    return priority",
    "response_id": 17,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 110.36149671375918,
    "mi": 83.11991936758335,
    "token_count": 133.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response18.txt_stdout.txt",
    "code_path": "problem_iter1_code18.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    \n    The priority is calculated based on how well the item fits into the bin.\n    A higher priority is given to bins where the item fits perfectly or leaves a large remaining capacity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Assign a very low priority to bins where the item doesn't fit\n    priority = np.where(remaining_cap_after_addition < 0, -1e10, \n                        # For bins where the item fits, the priority is the remaining capacity after addition\n                        # This encourages filling bins as much as possible\n                        remaining_cap_after_addition)\n    \n    # To further encourage using bins that are almost full, we can slightly increase the priority\n    # for bins with very small remaining capacity after adding the item\n    priority = np.where((remaining_cap_after_addition >= 0) & (remaining_cap_after_addition < item), \n                        priority + 1e-6, priority)\n    \n    return priority",
    "response_id": 18,
    "tryHS": false,
    "obj": 149.30195452732352,
    "SLOC": 10.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 110.36149671375918,
    "mi": 83.11991936758335,
    "token_count": 133.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response19.txt_stdout.txt",
    "code_path": "problem_iter1_code19.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is calculated based on the remaining capacity of each bin.\n    A bin with remaining capacity closest to the item size gets the highest priority.\n    If a bin cannot fit the item, its priority is set to negative infinity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin\n    # A bin with remaining capacity closest to the item size gets the highest priority\n    priority = np.where(bins_remain_cap >= item, -np.abs(bins_remain_cap - item), -np.inf)\n    \n    return priority",
    "response_id": 19,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 110.36149671375918,
    "mi": 83.11991936758335,
    "token_count": 133.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response20.txt_stdout.txt",
    "code_path": "problem_iter1_code20.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is calculated based on the remaining capacity of each bin.\n    A bin with remaining capacity closest to the item size will have the highest priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the absolute difference between the item size and the remaining capacity of each bin\n    diff = np.abs(bins_remain_cap - item)\n    \n    # Calculate the priority score as the negative of the difference (so that the bin with the smallest difference has the highest priority)\n    # Add a small value to the denominator to avoid division by zero\n    priority = -diff / (bins_remain_cap + 1e-6)\n    \n    # Set the priority score to negative infinity for bins that cannot hold the item\n    priority[bins_remain_cap < item] = -np.inf\n    \n    return priority",
    "response_id": 20,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 110.36149671375918,
    "mi": 83.11991936758335,
    "token_count": 133.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response21.txt_stdout.txt",
    "code_path": "problem_iter1_code21.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is calculated based on the remaining capacity of each bin.\n    A bin with a remaining capacity that is just enough to hold the item gets the highest priority.\n    The priority decreases as the remaining capacity becomes larger or smaller.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin\n    # A bin with remaining capacity close to the item size gets higher priority\n    priority = np.where(bins_remain_cap >= item, \n                        1 - np.abs(bins_remain_cap - item) / bins_remain_cap, \n                        0)\n    \n    return priority",
    "response_id": 21,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 110.36149671375918,
    "mi": 83.11991936758335,
    "token_count": 133.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response22.txt_stdout.txt",
    "code_path": "problem_iter1_code22.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is higher for bins that have enough capacity for the item and \n    lower remaining capacity after packing the item.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after packing the item into each bin\n    remaining_cap_after_packing = bins_remain_cap - item\n    \n    # Check if the bin has enough capacity for the item\n    has_enough_capacity = remaining_cap_after_packing >= 0\n    \n    # Assign a very low priority to bins that cannot hold the item\n    priority = np.where(has_enough_capacity, -remaining_cap_after_packing, -np.inf)\n    \n    return priority",
    "response_id": 22,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 110.36149671375918,
    "mi": 83.11991936758335,
    "token_count": 133.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response23.txt_stdout.txt",
    "code_path": "problem_iter1_code23.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is calculated based on the remaining capacity of each bin.\n    The bin with the least remaining capacity that can still fit the item gets the highest priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin\n    # A bin is eligible if it has enough capacity to hold the item\n    eligible_bins = bins_remain_cap >= item\n    \n    # For eligible bins, the priority score is inversely proportional to the remaining capacity\n    # This means that the bin with the least remaining capacity gets the highest priority\n    priority_scores = np.where(eligible_bins, 1 / (bins_remain_cap + 1e-6), 0)\n    \n    return priority_scores",
    "response_id": 23,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 110.36149671375918,
    "mi": 83.11991936758335,
    "token_count": 133.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response24.txt_stdout.txt",
    "code_path": "problem_iter1_code24.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_capacity_after_addition = bins_remain_cap - item\n    \n    # For bins that can fit the item, the priority is the negative of the remaining capacity\n    # This encourages choosing the bin with the least remaining capacity (i.e., the best fit)\n    priority = np.where(remaining_capacity_after_addition >= 0, -remaining_capacity_after_addition, -np.inf)\n    \n    return priority",
    "response_id": 24,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 110.36149671375918,
    "mi": 83.11991936758335,
    "token_count": 133.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response25.txt_stdout.txt",
    "code_path": "problem_iter1_code25.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This version uses a heuristic that prioritizes bins that have just enough capacity for the item.\n    The priority score is calculated as the negative of the absolute difference between the remaining capacity and the item size.\n    This encourages the algorithm to pack the item into a bin that is as full as possible after packing.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the absolute difference between the remaining capacity and the item size\n    diff = np.abs(bins_remain_cap - item)\n    \n    # Calculate the priority score as the negative of the difference\n    priority = -diff\n    \n    # Set the priority score to negative infinity for bins that cannot hold the item\n    priority[bins_remain_cap < item] = -np.inf\n    \n    return priority",
    "response_id": 25,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 110.36149671375918,
    "mi": 83.11991936758335,
    "token_count": 133.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response26.txt_stdout.txt",
    "code_path": "problem_iter1_code26.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    \n    The priority score is calculated based on the remaining capacity of each bin.\n    A bin with remaining capacity closest to the item size gets the highest priority.\n    If a bin doesn't have enough capacity, its priority is set to negative infinity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Check if the bin has enough capacity for the item\n    has_enough_capacity = remaining_cap_after_addition >= 0\n    \n    # For bins with enough capacity, calculate the priority score as the negative of the remaining capacity\n    # This is because we want to prioritize bins with remaining capacity closest to the item size\n    priority_scores = np.where(has_enough_capacity, -remaining_cap_after_addition, -np.inf)\n    \n    return priority_scores",
    "response_id": 26,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 110.36149671375918,
    "mi": 83.11991936758335,
    "token_count": 133.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response27.txt_stdout.txt",
    "code_path": "problem_iter1_code27.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Assign a very low priority (negative infinity) to bins that cannot accommodate the item\n    priority = np.where(remaining_cap_after_addition >= 0, -remaining_cap_after_addition, -np.inf)\n    \n    # To encourage using bins that are already filled (thus minimizing the number of bins),\n    # we add a small bonus to the priority of bins with less remaining capacity\n    # The bonus is proportional to the remaining capacity, so bins with less remaining capacity get higher priority\n    \n    # Normalize the priority scores to avoid overflow when calculating the bonus\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:  # Check if there are bins that can accommodate the item\n        priority = np.where(priority != -np.inf, priority - max_priority, -np.inf)\n    \n    # Return the priority scores\n    return priority",
    "response_id": 27,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 110.36149671375918,
    "mi": 83.11991936758335,
    "token_count": 133.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response28.txt_stdout.txt",
    "code_path": "problem_iter1_code28.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    \n    The priority is calculated based on the remaining capacity of each bin.\n    The bin with the least remaining capacity that can still fit the item gets the highest priority.\n    \n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin\n    # The score is high when the bin has just enough capacity for the item\n    priority_scores = np.where(bins_remain_cap >= item, 1 / (bins_remain_cap - item + 1e-6), 0)\n    \n    # Add a small random noise to break ties\n    priority_scores += np.random.uniform(0, 1e-6, size=len(bins_remain_cap))\n    \n    return priority_scores",
    "response_id": 28,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 110.36149671375918,
    "mi": 83.11991936758335,
    "token_count": 133.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response29.txt_stdout.txt",
    "code_path": "problem_iter1_code29.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    \n    This function implements the First-Fit decreasing heuristic with a twist.\n    The priority is higher for bins that have enough capacity and are more full.\n    \n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that cannot accommodate the item get a priority of -inf\n    priority = np.where(remaining_after_addition >= 0, -remaining_after_addition, -np.inf)\n    \n    # Normalize the priority to be between 0 and 1 for valid bins\n    valid_bins = priority != -np.inf\n    if np.any(valid_bins):\n        min_priority = np.min(priority[valid_bins])\n        max_priority = np.max(priority[valid_bins])\n        if max_priority != min_priority:\n            priority[valid_bins] = (priority[valid_bins] - min_priority) / (max_priority - min_priority)\n    \n    return priority",
    "response_id": 29,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 110.36149671375918,
    "mi": 83.11991936758335,
    "token_count": 133.0,
    "exec_success": true
  }
]