```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version prioritizes bins that can accommodate the item without excessive waste,
    but also discourages using bins that are almost perfectly filled by the item (to avoid fragmentation).
    It uses a combination of remaining capacity and a "sweet spot" around a certain waste percentage.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Define a preferred waste percentage range (e.g., 10-30%)
    preferred_waste_low = 0.10
    preferred_waste_high = 0.30

    for i, cap in enumerate(bins_remain_cap):
        if cap >= item:
            waste = (cap - item) / cap
            if preferred_waste_low <= waste <= preferred_waste_high:
                # Ideal waste, give high priority
                priorities[i] = 10  #Arbitrary high value. Consider function of cap/item
            elif waste < preferred_waste_low and waste > 0:
                # Too little waste (almost full), give lower priority (penalize)
                priorities[i] = 10 * waste / preferred_waste_low # linear decrease to 0
            elif waste > preferred_waste_high:
                # Excessive waste, give moderate priority, prefer less waste over more.
                priorities[i] = 5 * np.exp(-5 * (waste - preferred_waste_high))

    return priorities
```
