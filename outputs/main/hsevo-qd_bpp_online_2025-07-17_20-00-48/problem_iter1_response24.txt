```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    for i, cap in enumerate(bins_remain_cap):
        if cap >= item:
            # Tesla's Resonance Principle: Favour bins close to the item size but avoid overflow.
            proximity = 1 - abs(cap - item) / item if item > 0 else 0 # Normalized distance to item size
            utilization = item / cap # How well we are filling the bin.

            # The Grand Unification: Combine proximity and utilization for optimal harmony.
            # High proximity is good, and we want to increase the utilization.
            priorities[i] = 5 * proximity + 2 * utilization  # Tuned for balanced performance.

            # Introduce slight encouragement for filling up relatively empty bins
            # if (cap > 2 * item):
            #     priorities[i] -= 0.5 * utilization
        else:
            # Invalid bins get minimum priority
            priorities[i] = -np.inf

    return priorities
```
