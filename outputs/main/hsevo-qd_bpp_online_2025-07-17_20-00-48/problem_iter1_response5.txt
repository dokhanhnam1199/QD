```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Inspired by the celestial dance, where larger bodies exert a stronger gravitational pull,
    we prioritize bins whose remaining capacity is closest to the item size. This aims to minimize wasted space.
    Furthermore, to encourage exploration and avoid prematurely filling bins, a slight stochastic element is added,
    mirroring the imperfect predictability of planetary orbits. Bins with sufficient capacity will
    have increased probability.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    # Calculate the difference between bin capacity and item size. Smaller difference is better
    diff = np.abs(bins_remain_cap - item)
    # Introduce small value to avoid division by zero.
    epsilon = 1e-6
    # Transform into a priority score (higher is better), with emphasis on sufficient capacity.
    priorities = np.where(bins_remain_cap >= item, 1 / (diff + epsilon), -np.inf)
    # Add a capacity-based bias, which favores bins with more capacity, avoiding premature fill.
    priorities = priorities + 0.1*bins_remain_cap

    # Adding small degree of exploration with a random value to explore new bins
    random_noise = np.random.rand(len(bins_remain_cap)) * 0.01
    priorities = priorities + random_noise
    return priorities
```
