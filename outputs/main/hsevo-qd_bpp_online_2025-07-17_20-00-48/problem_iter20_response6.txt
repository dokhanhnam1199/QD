```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Calculate bin priorities considering fit, fragmentation, and bin diversity."""

    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    max_cap = np.max(bins_remain_cap)
    num_bins = len(bins_remain_cap)

    # Hard constraint: Item must fit.
    cannot_fit = bins_remain_cap < item
    priorities[cannot_fit] = -np.inf

    can_fit = ~cannot_fit

    if not np.any(can_fit):
        return priorities

    # 1. Utilization Score (scaled by item size)
    utilization = item / max_cap
    remaining_cap_after_fit = bins_remain_cap - item
    utilization_score = (1 - remaining_cap_after_fit / max_cap) * utilization
    priorities[can_fit] += utilization_score[can_fit]

    # 2. Fragmentation Penalty (adaptive to item size)
    tiny_fragment_threshold = 0.05 * max_cap
    small_fragment_threshold = 0.2 * max_cap
    tiny_fragment_penalty = -5.0 - 7.0 * utilization
    small_fragment_penalty = -1.0 - 2.0 * utilization

    tiny_fragment = (remaining_cap_after_fit > 0) & (remaining_cap_after_fit <= tiny_fragment_threshold)
    small_fragment = (remaining_cap_after_fit > tiny_fragment_threshold) & (remaining_cap_after_fit <= small_fragment_threshold)

    priorities[tiny_fragment] += tiny_fragment_penalty
    priorities[small_fragment] += small_fragment_penalty

    # 3. Best Fit Bonus (scaled by bin capacity)
    diffs = bins_remain_cap - item
    min_diff = np.min(diffs[diffs >= 0]) if np.any(diffs >= 0) else np.inf
    best_fit = diffs == min_diff
    best_fit_bonus = np.where(best_fit, (1.0 + 0.5 * (1 - utilization)) * (bins_remain_cap / max_cap), 0)
    priorities += best_fit_bonus

    # 4. Bin Diversity (Encourage balanced loading)
    if num_bins > 1:
        bin_fullness = (max_cap - bins_remain_cap) / max_cap
        diversity_metric = np.std(bin_fullness[can_fit])
        diversity_bonus = diversity_metric
        priorities[can_fit] += 0.3 * diversity_bonus

    return priorities
```
