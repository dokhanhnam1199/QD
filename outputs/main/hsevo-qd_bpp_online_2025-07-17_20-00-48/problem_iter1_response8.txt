```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version prioritizes bins that can fit the item but are not too much larger than the item.
    It uses a combination of remaining capacity and "waste" calculation to achieve this.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    # Assign very low priority if the item doesn't fit
    infeasible_mask = bins_remain_cap < item
    priorities[infeasible_mask] = -np.inf

    # Calculate remaining capacity after adding the item
    remaining_after_add = bins_remain_cap - item
    
    # Calculate waste (remaining capacity) for feasible bins
    waste = remaining_after_add
    waste[infeasible_mask] = np.inf  # Ensure infeasible bins have infinite waste.
    
    # Priority score is calculated as a combination of
    # 1. Higher priority for bins with enough space
    # 2. Lower priority for bins with a lot of wasted space after adding the item
    # We use a modified logarithmic function to scale the priority inversely proportional to waste. 
    #  and some scaling factor alpha to make the remaining capacity (bins_remain_cap) more influential.
    alpha = 0.5 # Adjust alpha based on testing - relative importance of remain capacity.

    feasible_mask = ~infeasible_mask

    priorities[feasible_mask] = alpha * bins_remain_cap[feasible_mask] - np.log(1 + waste[feasible_mask])

    return priorities
```
