```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This function dynamically adjusts bin priorities based on item size relative to bin capacities,
    with weighted considerations for utilization, fragmentation, and bin emptiness.  It aims for
    a balanced approach adaptable to diverse item distributions.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    max_cap = np.max(bins_remain_cap)
    avg_cap = np.mean(bins_remain_cap)

    # 0. Hard constraint: Item must fit.  Bins that can't fit get -inf priority.
    priorities[bins_remain_cap < item] = -np.inf
    fit_mask = bins_remain_cap >= item

    if not np.any(fit_mask):
        return priorities  # No bin can fit the item

    remaining_capacity_after_fit = bins_remain_cap - item

    # 1. Utilization Score: Favor bins that lead to better utilization, adjust weight dynamically
    utilization_score = (item / max_cap) * (bins_remain_cap / max_cap)
    priorities[fit_mask] += 1.2 * utilization_score[fit_mask]

    # 2. Fragmentation Avoidance: Penalize bins that result in very small or moderately small fragments, dynamically adjust penalty
    tiny_fragment_threshold = 0.05 * max_cap
    small_fragment_threshold = 0.2 * max_cap
    med_fragment_threshold = 0.4 * max_cap

    tiny_fragment_penalty = -15.0
    small_fragment_penalty = -4.0
    med_fragment_penalty = -1.0

    tiny_fragment_mask = (remaining_capacity_after_fit > 0) & (remaining_capacity_after_fit <= tiny_fragment_threshold)
    small_fragment_mask = (remaining_capacity_after_fit > tiny_fragment_threshold) & (remaining_capacity_after_fit <= small_fragment_threshold)
    med_fragment_mask = (remaining_capacity_after_fit > small_fragment_threshold) & (remaining_capacity_after_fit <= med_fragment_threshold)

    priorities[tiny_fragment_mask] += tiny_fragment_penalty
    priorities[small_fragment_mask] += small_fragment_penalty
    priorities[med_fragment_mask] += med_fragment_penalty

    # 3. Bin Capacity Pressure: Bins with more capacity are more eager to accept items, adjust pressure dynamically
    pressure = (bins_remain_cap / max_cap) * (1 - (item / max_cap))
    priorities[fit_mask] += 0.8 * pressure[fit_mask]

    # 4. Best Fit Bonus: Reward the bin with the minimum wasted space, adjust the bonus dynamically
    diffs = bins_remain_cap - item
    min_diff = np.min(diffs[diffs >= 0]) if np.any(diffs >= 0) else np.inf
    best_fit_bonus = np.where(diffs == min_diff, 2.0, 0)
    priorities += best_fit_bonus
    
    # 5. Adaptive Empty Bin Preference: Highly prefer empty bins if the item is reasonably large
    empty_bin_mask = bins_remain_cap == max_cap
    empty_bin_threshold = 0.7 * max_cap
    if item >= empty_bin_threshold and np.any(empty_bin_mask):
        priorities[empty_bin_mask] += 5.0
    
    # 6. Normalize priorities, helps stabilize behavior and avoid extreme values
    if np.any(np.isfinite(priorities)):
        max_priority = np.max(priorities[np.isfinite(priorities)])
        min_priority = np.min(priorities[np.isfinite(priorities)])
        if max_priority != min_priority:  # Avoid division by zero
             priorities[np.isfinite(priorities)] = (priorities[np.isfinite(priorities)] - min_priority) / (max_priority - min_priority)

    return priorities
```
