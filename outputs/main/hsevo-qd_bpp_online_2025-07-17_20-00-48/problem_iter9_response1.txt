```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This function prioritizes bins based on a combination of factors, incorporating adaptive scaling
    and considering the overall distribution of item sizes.  It includes mechanisms to prefer
    nearly full bins in specific scenarios and dynamically adjusts fragment penalties.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    max_cap = np.max(bins_remain_cap)
    mean_cap = np.mean(bins_remain_cap)

    # 0. Hard constraint: Item must fit.  Bins that can't fit get -inf priority.
    priorities[bins_remain_cap < item] = -np.inf

    fit_mask = bins_remain_cap >= item

    if not np.any(fit_mask):
        return priorities  # No bin can fit the item

    # 1. Utilization Term: Favor better utilization, adaptively scaled based on item size.
    utilization = item / max_cap
    remaining_capacity_after_fit = bins_remain_cap - item
    utilization_score = (1 - remaining_capacity_after_fit / max_cap) * utilization
    priorities[fit_mask] += utilization_score[fit_mask] * (1 + utilization)  # Boost for larger items

    # 2. Fragmentation Avoidance: Dynamically adjust penalties based on item size and remaining capacity.
    tiny_fragment_threshold = 0.05 * max_cap
    small_fragment_threshold = 0.2 * max_cap

    # Adaptive penalty scaling
    tiny_fragment_penalty = -10.0 * (1 + item / max_cap)  # Larger items, stronger penalty
    small_fragment_penalty = -2.0 * (1 + item / max_cap)
    
    tiny_fragment_mask = (remaining_capacity_after_fit > 0) & (remaining_capacity_after_fit <= tiny_fragment_threshold)
    small_fragment_mask = (remaining_capacity_after_fit > tiny_fragment_threshold) & (remaining_capacity_after_fit <= small_fragment_threshold)

    priorities[tiny_fragment_mask] += tiny_fragment_penalty
    priorities[small_fragment_mask] += small_fragment_penalty
    
    # 3. "Pressure" Term: Scale pressure based on both remaining capacity and item size.
    pressure = bins_remain_cap / max_cap * (1 - utilization)
    priorities[fit_mask] += 0.5 * pressure[fit_mask] * (1 - utilization) # Lower pressure for large items

    # 4. Best Fit Bonus: Reward the bin that provides the absolute best fit (smallest waste).
    diffs = bins_remain_cap - item
    min_diff = np.min(diffs[diffs >= 0]) if np.any(diffs >= 0) else np.inf
    best_fit_bonus = np.where(diffs == min_diff, 1.5, 0)
    priorities += best_fit_bonus
    
    # 5. Empty Bin Preference (Adaptive): If the item is a significant fraction of bin size, strongly prefer an empty bin.
    empty_bin_mask = bins_remain_cap == max_cap
    empty_bin_threshold = 0.6 * max_cap
    if item >= empty_bin_threshold and np.any(empty_bin_mask):
        priorities[empty_bin_mask] += 3.0

    # 6. Nearly Full Bin Preference: If an item fills a bin almost completely, prioritize it.
    nearly_full_threshold = 0.95 * max_cap
    nearly_full_mask = (bins_remain_cap >= item) & (remaining_capacity_after_fit <= (max_cap - nearly_full_threshold))
    priorities[nearly_full_mask] += 4.0

    # 7. Balance Bins with higher than average capacity
    above_average_mask = bins_remain_cap > mean_cap
    priorities[above_average_mask & fit_mask] += 0.75 * utilization  # Give a small incentive
    
    return priorities
```
