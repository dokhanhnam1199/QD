```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Heuristics:
    1.  Encourage packing into bins that are already somewhat full (First-Fit Decreasing).
    2.  Discourage placing the item into bins that would result in a very small remaining capacity
        after the item is placed (to avoid fragmentation).
    3. Add some stochasticity to avoid local optima.
    """
    # Epsilon to avoid division by zero
    epsilon = 1e-9

    # 1. First-Fit Decreasing (but modified to fit a priority score)
    # Prioritize bins with higher (but not excessively high) utilization if we packed the item in it.
    potential_remain_cap = bins_remain_cap - item
    potential_utilization = (bins_remain_cap - potential_remain_cap) / (bins_remain_cap + epsilon)
    ffd_priority = potential_utilization

    # 2. Fragmentation Avoidance
    # Penalize bins that will have very small remaining capacity after packing
    fragmentation_penalty = np.where(potential_remain_cap > 0, np.exp(-10*potential_remain_cap), -np.inf) # Heavily penalize negative remaining capacities
    # Scale down penalty
    fragmentation_penalty *= 0.5

    # 3. Stochasticity
    stochasticity = np.random.rand(len(bins_remain_cap)) * 0.1

    # Combine the priorities
    priorities = ffd_priority + fragmentation_penalty + stochasticity

    return priorities
```
