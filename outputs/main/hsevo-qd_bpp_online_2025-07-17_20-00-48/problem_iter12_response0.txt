```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This function prioritizes bins based on a refined combination of factors,
    including utilization, fragmentation avoidance, pressure, best fit, empty bin preference,
    bin diversity, and load balancing, with adaptive adjustments based on item size and bin
    characteristics. It aims to improve upon priority_v1 by dynamically adjusting penalties
    and bonuses to better handle diverse item sizes and bin configurations, and introducing
    a load balancing term inspired by physics principles.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    max_cap = np.max(bins_remain_cap)
    num_bins = len(bins_remain_cap)

    # 0. Hard constraint: Item must fit. Bins that can't fit get -inf priority.
    priorities[bins_remain_cap < item] = -np.inf

    fit_mask = bins_remain_cap >= item

    if not np.any(fit_mask):
        return priorities  # No bin can fit the item

    # 1. Utilization Term: Favor better utilization, but scale based on item size.
    utilization = item / max_cap
    remaining_capacity_after_fit = bins_remain_cap - item
    utilization_score = (1 - remaining_capacity_after_fit / max_cap) * utilization
    priorities[fit_mask] += utilization_score[fit_mask]

    # 2. Fragmentation Avoidance: Penalize bins that will result in tiny fragments.
    tiny_fragment_threshold = 0.05 * max_cap
    small_fragment_threshold = 0.2 * max_cap

    # Adaptive penalty based on item size: Larger items impose a heavier penalty for tiny fragments
    tiny_fragment_penalty = -5.0 - 5.0 * utilization  # Higher penalty for larger items
    small_fragment_penalty = -1.0 - 1.0 * utilization

    tiny_fragment_mask = (remaining_capacity_after_fit > 0) & (remaining_capacity_after_fit <= tiny_fragment_threshold)
    small_fragment_mask = (remaining_capacity_after_fit > tiny_fragment_threshold) & (remaining_capacity_after_fit <= small_fragment_threshold)

    priorities[tiny_fragment_mask] += tiny_fragment_penalty
    priorities[small_fragment_mask] += small_fragment_penalty

    # 3. "Pressure" Term: Bins with higher remaining capacity exert more "pressure".  Adjust scaling dynamically.
    pressure = bins_remain_cap / max_cap * (1 - utilization)
    priorities[fit_mask] += 0.5 * pressure[fit_mask]

    # 4. Best Fit Bonus: Reward the bin that provides the absolute best fit (smallest waste).
    diffs = bins_remain_cap - item
    min_diff = np.min(diffs[diffs >= 0]) if np.any(diffs >= 0) else np.inf
    best_fit_bonus = np.where(diffs == min_diff, 1.0 + 0.5 * (1 - utilization), 0)  # Adaptive bonus
    priorities += best_fit_bonus

    # 5. Empty Bin Preference (Adaptive): If the item is a significant fraction of bin size, strongly prefer an empty bin.
    empty_bin_mask = bins_remain_cap == max_cap
    empty_bin_threshold = 0.6 * max_cap
    if item >= empty_bin_threshold and np.any(empty_bin_mask):
        priorities[empty_bin_mask] += 2.0 + 1.0 * utilization  # Stronger adaptive preference

    # 6. Bin Diversity Bonus: Encourage spreading items across different bins.
    # This penalizes using bins with similar remaining capacities if there are other options.
    if num_bins > 1:
        std_dev = np.std(bins_remain_cap[fit_mask])  # Standard deviation of remaining capacities
        diversity_bonus = std_dev / max_cap # Normalize
        priorities[fit_mask] += 0.25 * diversity_bonus # Moderate diversity bonus

    # 7. Load Balancing (Physics-Inspired): Encourage filling bins to a more uniform level.
    # Apply a "force" that pushes items towards bins with lower fill levels, where force is proportional to capacity difference.
    average_fill = np.mean(max_cap - bins_remain_cap)
    load_imbalance = (average_fill - (max_cap - bins_remain_cap)) / max_cap # Normalize by max capacity
    load_balancing_force = 0.3 * load_imbalance  # Scaling factor for the force. Experiment with this.
    priorities[fit_mask] += load_balancing_force[fit_mask]

    # 8.  Item Size Consideration in Best Fit: Adjust best fit bonus based on the item size relative to bin size.
    # If the item is large, a closer fit is more crucial than if the item is small.
    if np.any(best_fit_bonus > 0):
        best_fit_bins = diffs == min_diff
        best_fit_adjustment = utilization  # Use utilization (item size relative to bin size) as adjustment
        priorities[best_fit_bins] += 0.5 * best_fit_adjustment # Apply adjusted bonus

    return priorities
```
