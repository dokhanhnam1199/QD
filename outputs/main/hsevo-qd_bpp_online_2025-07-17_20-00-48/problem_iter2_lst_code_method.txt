{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This function prioritizes bins based on a combination of factors inspired by physics.\n    It considers the 'energy' required to place the item (smaller remaining capacity = higher energy),\n    a 'potential well' effect (bins with capacities slightly larger than the item are favored),\n    and a 'repulsion' effect (bins with capacities much larger than the item are discouraged).\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 'Energy' term: Higher priority for bins that are almost full\n    energy = 1.0 / (bins_remain_cap + 1e-9)  # Avoid division by zero\n    priorities += energy\n\n    # 'Potential well' term: Favor bins with capacities slightly larger than the item\n    diff = bins_remain_cap - item\n    potential_well = np.exp(-(diff**2) / (2 * (item/3)**2)) #Gaussian centered at item. Larger variance when item size is bigger\n    priorities += potential_well\n\n    # 'Repulsion' term: Discourage bins with capacities much larger than the item\n    repulsion = np.exp(-bins_remain_cap / (item*5))  # Exponential decay with bin capacity. Higher decay if item is small\n    priorities -= 0.5 * repulsion # We don't want it to be the dominating factor\n\n    # Consider bins where item doesn't fit as non viable\n    priorities[bins_remain_cap < item] = -np.inf\n\n    return priorities\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This function prioritizes bins based on a combination of factors inspired by physics.\n    It considers the 'energy' required to place the item (smaller remaining capacity = higher energy),\n    a 'potential well' effect (bins with capacities slightly larger than the item are favored),\n    and a 'repulsion' effect (bins with capacities much larger than the item are discouraged).\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 'Energy' term: Higher priority for bins that are almost full\n    energy = 1.0 / (bins_remain_cap + 1e-9)  # Avoid division by zero\n    priorities += energy\n\n    # 'Potential well' term: Favor bins with capacities slightly larger than the item\n    diff = bins_remain_cap - item\n    potential_well = np.exp(-(diff**2) / (2 * (item/3)**2)) #Gaussian centered at item. Larger variance when item size is bigger\n    priorities += potential_well\n\n    # 'Repulsion' term: Discourage bins with capacities much larger than the item\n    repulsion = np.exp(-bins_remain_cap / (item*5))  # Exponential decay with bin capacity. Higher decay if item is small\n    priorities -= 0.5 * repulsion # We don't want it to be the dominating factor\n\n    # Consider bins where item doesn't fit as non viable\n    priorities[bins_remain_cap < item] = -np.inf\n\n    return priorities\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            # Tesla's Resonance Principle: Favour bins close to the item size but avoid overflow.\n            proximity = 1 - abs(cap - item) / item if item > 0 else 0 # Normalized distance to item size\n            utilization = item / cap # How well we are filling the bin.\n\n            # The Grand Unification: Combine proximity and utilization for optimal harmony.\n            # High proximity is good, and we want to increase the utilization.\n            priorities[i] = 5 * proximity + 2 * utilization  # Tuned for balanced performance.\n\n            # Introduce slight encouragement for filling up relatively empty bins\n            # if (cap > 2 * item):\n            #     priorities[i] -= 0.5 * utilization\n        else:\n            # Invalid bins get minimum priority\n            priorities[i] = -np.inf\n\n    return priorities\n\n[Heuristics 4th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    This version prioritizes bins that can accommodate the item with minimal wasted space.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Iterate through each bin's remaining capacity\n    for i, remaining_capacity in enumerate(bins_remain_cap):\n        # If the item fits in the bin\n        if remaining_capacity >= item:\n            # Calculate the wasted space\n            wasted_space = remaining_capacity - item\n\n            # A lower wasted space is more desirable, so we use its inverse\n            # Plus a small amount to avoid the divide by zero problems.\n\n            priorities[i] = 1.0 / (wasted_space + 0.0001)\n\n        else:\n            # Item does not fit, assign a very low priority.  Setting to a large negative number ensures that\n            # only bins that fit the item will be considered.  Zero might allow bins to be chosen at random\n            # when there is no good place for them\n\n            priorities[i] = -1000  # or np.NINF\n\n    return priorities\n\n[Heuristics 5th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    valid_bins = bins_remain_cap >= item\n\n    if np.any(valid_bins):\n        # 1. Fill the almost full bins first. High reward for bins that fit the item tightly.\n        # 2. Avoid fragmentation by prioritizing bins that use space most efficiently.\n\n        remaining_after_fit = bins_remain_cap[valid_bins] - item\n        space_utilization = item / bins_remain_cap[valid_bins]  # item size / bin size\n        # prioritize bins which space utilization is close to 1.\n        priorities[valid_bins] = space_utilization # * (1+np.exp(-remaining_after_fit*10)) # amplify reward when almost perfectly packed\n\n        # Avoid creating very small gaps by penalizing creating very small gaps\n        very_small_gap = remaining_after_fit < 0.1\n        priorities[valid_bins][very_small_gap] = -1\n\n    else:\n        # No bin can accommodate the item, assign very low priority\n        priorities[:] = -np.inf\n\n    return priorities\n\n[Heuristics 6th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Filter out bins that cannot fit the item\n    valid_bins = bins_remain_cap >= item\n\n    if not np.any(valid_bins):\n        # If no bin can fit the item, prioritize the fullest bin (least remaining capacity)\n        # This might open up space for future items\n        priorities = -bins_remain_cap\n        return priorities\n    \n    \n    # Calculate remaining capacity after placing the item\n    remaining_after_placement = bins_remain_cap[valid_bins] - item\n\n    # Prioritize bins that would have a high fill rate after item placement\n    fill_rate = (bins_remain_cap[valid_bins] - remaining_after_placement) / bins_remain_cap[valid_bins]\n    priorities[valid_bins] = fill_rate\n\n    # Smallest Waste Heuristic :\n    # Adjust priorities by penalizing bins with small remaining space after placement. This favors more complete fills\n    # and tries to avoid very fragmented bins.\n    \n    waste_penalty = np.exp(-remaining_after_placement) # Exponential decay based on wasted space\n    priorities[valid_bins] *= waste_penalty\n\n    # Adjust the scaling so that the priorities of bins which *cannot* take the item are at the far negative end\n    priorities[~valid_bins] = -np.inf\n\n    return priorities\n\n[Heuristics 7th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            # Tesla's Resonance Principle: Favour bins close to the item size but avoid overflow.\n            proximity = 1 - abs(cap - item) / item if item > 0 else 0 # Normalized distance to item size\n            utilization = item / cap # How well we are filling the bin.\n\n            # The Grand Unification: Combine proximity and utilization for optimal harmony.\n            # High proximity is good, and we want to increase the utilization.\n            priorities[i] = 5 * proximity + 2 * utilization  # Tuned for balanced performance.\n\n            # Introduce slight encouragement for filling up relatively empty bins\n            # if (cap > 2 * item):\n            #     priorities[i] -= 0.5 * utilization\n        else:\n            # Invalid bins get minimum priority\n            priorities[i] = -np.inf\n\n    return priorities\n\n[Heuristics 8th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priorities with a base value (e.g., 0).\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Assign a high priority to bins that can fit the item.  Prioritize bins where item is close to filling bin\n    fit_mask = bins_remain_cap >= item\n    priorities[fit_mask] = (bins_remain_cap[fit_mask] - item) / bins_remain_cap[fit_mask]\n\n    priorities[fit_mask] = 1 - priorities[fit_mask] # Make small waste have high priority\n\n    # Very bad to exceed capacity\n    overflow_mask = bins_remain_cap < item\n    priorities[overflow_mask] = -np.inf\n\n    return priorities\n\n[Heuristics 9th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):\n        # 1. Minimize wasted space: Favour bins where the item fits best. Smallest gap\n        #waste = bins_remain_cap[valid_bins] - item\n        #priorities[valid_bins] = -waste # Larger the waste, smaller priority.\n        # 2. Balancing bin use (first fit decreasing inspired)\n        priorities[valid_bins] = bins_remain_cap[valid_bins] / np.sum(bins_remain_cap[valid_bins])\n        #3. Hybrid : Encourage packing into partially full bins, with emphasis to fit in as tight as possible\n        #waste = bins_remain_cap[valid_bins] - item\n        #priorities[valid_bins] = (bins_remain_cap[valid_bins] / np.sum(bins_remain_cap[valid_bins])) - waste\n\n        #Newtonian gravitation inspired: Inverse square relation of waste, proportional to total capacity\n        #waste = bins_remain_cap[valid_bins] - item\n        #priorities[valid_bins] = bins_remain_cap[valid_bins] / (1+waste**2)\n        #Normalised ratio, favour near fits\n        waste = bins_remain_cap[valid_bins] - item\n        priorities[valid_bins] = (bins_remain_cap[valid_bins] - waste) / bins_remain_cap[valid_bins]\n    else:\n        priorities = np.full_like(bins_remain_cap, -np.inf)\n    return priorities\n\n[Heuristics 10th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Very large penalty if the item doesn't fit\n    priorities[bins_remain_cap < item] = -np.inf\n    \n    # Give a bonus if the item fits perfectly. This reduces fragmentation.\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    priorities[perfect_fit] = np.inf\n    \n    # Prioritize bins that can accommodate the item with minimal remaining space.\n    # This encourages filling bins completely.  Avoids creating bins with tiny spaces\n    # that will be hard to fill later. Use a capped inverse to limit extreme preference for tiny residual spaces.\n    \n    residual_space = bins_remain_cap - item\n    valid_bins = bins_remain_cap >= item\n    \n    # Calculate priority only for bins where the item fits\n    if np.any(valid_bins):\n        # Cap residual_space to a max value to avoid overly prioritizing bins with extremely small remaining capacity.\n        capped_residual_space = np.minimum(residual_space[valid_bins], 0.5)  # Example: cap at 0.5\n        priorities[valid_bins] += 1.0 / (capped_residual_space + 0.0000001) # Adding small constant to avoid division by zero\n\n    return priorities\n\n[Heuristics 11th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Employing a combination of heuristics, considering both space utilization\n    and a probabilistic element to explore different bin assignments.  This is\n    inspired by the balance between gravity (deterministic) and random molecular motion\n    (stochastic) in the physical world. We favour bins where the item fits relatively\n    well (higher utilization) and introduce a small chance of using a less-optimal\n    bin to explore the solution space.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    # First, give a very low priority to bins that cannot contain the item\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] = -np.inf  # Ensure these bins are never chosen if possible\n\n    # For feasible bins, calculate a \"gravity\" score based on space utilization.\n    # Higher utilization (smaller remaining capacity after packing) is preferred.\n    feasible_mask = ~infeasible_mask\n    if np.any(feasible_mask):\n        utilization = item / bins_remain_cap[feasible_mask]\n        priorities[feasible_mask] = utilization\n\n        # Introduce a probabilistic element (\"Brownian motion\") to encourage exploration.\n        # This helps escape local optima. The 'temperature' parameter controls the\n        # magnitude of the random perturbation.\n\n        temperature = 0.1  # Adjust this parameter as needed\n        random_noise = np.random.normal(0, temperature, size=np.sum(feasible_mask))\n        priorities[feasible_mask] += random_noise\n\n\n        # A small bonus to using bins already somewhat full to reduce fragmentation.\n        fullness_bonus = bins_remain_cap[feasible_mask] / np.max(bins_remain_cap)\n        priorities[feasible_mask] += 0.1* (1-fullness_bonus)\n\n\n    return priorities\n\n[Heuristics 12th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Employing a combination of heuristics, considering both space utilization\n    and a probabilistic element to explore different bin assignments.  This is\n    inspired by the balance between gravity (deterministic) and random molecular motion\n    (stochastic) in the physical world. We favour bins where the item fits relatively\n    well (higher utilization) and introduce a small chance of using a less-optimal\n    bin to explore the solution space.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    # First, give a very low priority to bins that cannot contain the item\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] = -np.inf  # Ensure these bins are never chosen if possible\n\n    # For feasible bins, calculate a \"gravity\" score based on space utilization.\n    # Higher utilization (smaller remaining capacity after packing) is preferred.\n    feasible_mask = ~infeasible_mask\n    if np.any(feasible_mask):\n        utilization = item / bins_remain_cap[feasible_mask]\n        priorities[feasible_mask] = utilization\n\n        # Introduce a probabilistic element (\"Brownian motion\") to encourage exploration.\n        # This helps escape local optima. The 'temperature' parameter controls the\n        # magnitude of the random perturbation.\n\n        temperature = 0.1  # Adjust this parameter as needed\n        random_noise = np.random.normal(0, temperature, size=np.sum(feasible_mask))\n        priorities[feasible_mask] += random_noise\n\n\n        # A small bonus to using bins already somewhat full to reduce fragmentation.\n        fullness_bonus = bins_remain_cap[feasible_mask] / np.max(bins_remain_cap)\n        priorities[feasible_mask] += 0.1* (1-fullness_bonus)\n\n\n    return priorities\n\n[Heuristics 13th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Heuristics:\n    1.  Encourage packing into bins that are already somewhat full (First-Fit Decreasing).\n    2.  Discourage placing the item into bins that would result in a very small remaining capacity\n        after the item is placed (to avoid fragmentation).\n    3. Add some stochasticity to avoid local optima.\n    \"\"\"\n    # Epsilon to avoid division by zero\n    epsilon = 1e-9\n\n    # 1. First-Fit Decreasing (but modified to fit a priority score)\n    # Prioritize bins with higher (but not excessively high) utilization if we packed the item in it.\n    potential_remain_cap = bins_remain_cap - item\n    potential_utilization = (bins_remain_cap - potential_remain_cap) / (bins_remain_cap + epsilon)\n    ffd_priority = potential_utilization\n\n    # 2. Fragmentation Avoidance\n    # Penalize bins that will have very small remaining capacity after packing\n    fragmentation_penalty = np.where(potential_remain_cap > 0, np.exp(-10*potential_remain_cap), -np.inf) # Heavily penalize negative remaining capacities\n    # Scale down penalty\n    fragmentation_penalty *= 0.5\n\n    # 3. Stochasticity\n    stochasticity = np.random.rand(len(bins_remain_cap)) * 0.1\n\n    # Combine the priorities\n    priorities = ffd_priority + fragmentation_penalty + stochasticity\n\n    return priorities\n\n[Heuristics 14th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Heuristics:\n    1.  Encourage packing into bins that are already somewhat full (First-Fit Decreasing).\n    2.  Discourage placing the item into bins that would result in a very small remaining capacity\n        after the item is placed (to avoid fragmentation).\n    3. Add some stochasticity to avoid local optima.\n    \"\"\"\n    # Epsilon to avoid division by zero\n    epsilon = 1e-9\n\n    # 1. First-Fit Decreasing (but modified to fit a priority score)\n    # Prioritize bins with higher (but not excessively high) utilization if we packed the item in it.\n    potential_remain_cap = bins_remain_cap - item\n    potential_utilization = (bins_remain_cap - potential_remain_cap) / (bins_remain_cap + epsilon)\n    ffd_priority = potential_utilization\n\n    # 2. Fragmentation Avoidance\n    # Penalize bins that will have very small remaining capacity after packing\n    fragmentation_penalty = np.where(potential_remain_cap > 0, np.exp(-10*potential_remain_cap), -np.inf) # Heavily penalize negative remaining capacities\n    # Scale down penalty\n    fragmentation_penalty *= 0.5\n\n    # 3. Stochasticity\n    stochasticity = np.random.rand(len(bins_remain_cap)) * 0.1\n\n    # Combine the priorities\n    priorities = ffd_priority + fragmentation_penalty + stochasticity\n\n    return priorities\n\n[Heuristics 15th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Inspired by the concept of spacetime curvature, bins with remaining capacity closer\n    to the item size will experience a stronger \"gravitational pull.\" We also add a\n    factor to avoid filling bins too greedily early on, preserving space for potentially\n    larger future items (analogous to maintaining spacetime stability). A small random\n    component is added, like Brownian motion, to explore near-optimal configurations.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Avoid division by zero (bins with zero remaining capacity).  Give them very low priority.\n    bins_remain_cap_safe = np.where(bins_remain_cap <= 0, np.inf, bins_remain_cap)\n\n    # Calculate the \"gravitational potential\" based on how well the item fits.\n    # A value close to 0 suggests a good fit.  Add a small number to remaining\n    # capacity so item fits.\n    potential = np.abs(bins_remain_cap_safe - item)\n\n    # Use a Gaussian-like function to convert potential to \"gravitational force\" or priority.\n    # The smaller the potential (closer the fit), the higher the priority.\n    priority_base = np.exp(-(potential**2) / (2 * (item / 2)**2))  # sigma proportional to item size\n\n    # Penalize bins that are getting too full (analogy to \"spacetime distortion\").\n    # Reduce priority for bins that have been filled past some percentage, for example 80%.\n    fill_ratio = (1 - bins_remain_cap_safe / np.max(bins_remain_cap)) #Use max cap for reference\n    full_bin_penalty = np.where(fill_ratio > 0.8, 1-fill_ratio, 1) # Penalize bins filled >80%\n\n    priorities = priority_base * full_bin_penalty\n\n    # Add a small random component to encourage exploration.\n    priorities += np.random.normal(0, 0.01, size=bins_remain_cap.shape)\n\n    # Set bins with insufficient capacity to negative infinity.\n    priorities = np.where(bins_remain_cap < item, -np.inf, priorities)\n\n    return priorities\n\n[Heuristics 16th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins that can accommodate the item without excessive waste,\n    but also discourages using bins that are almost perfectly filled by the item (to avoid fragmentation).\n    It uses a combination of remaining capacity and a \"sweet spot\" around a certain waste percentage.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Define a preferred waste percentage range (e.g., 10-30%)\n    preferred_waste_low = 0.10\n    preferred_waste_high = 0.30\n\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            waste = (cap - item) / cap\n            if preferred_waste_low <= waste <= preferred_waste_high:\n                # Ideal waste, give high priority\n                priorities[i] = 10  #Arbitrary high value. Consider function of cap/item\n            elif waste < preferred_waste_low and waste > 0:\n                # Too little waste (almost full), give lower priority (penalize)\n                priorities[i] = 10 * waste / preferred_waste_low # linear decrease to 0\n            elif waste > preferred_waste_high:\n                # Excessive waste, give moderate priority, prefer less waste over more.\n                priorities[i] = 5 * np.exp(-5 * (waste - preferred_waste_high))\n\n    return priorities\n\n[Heuristics 17th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Inspired by the celestial dance, where larger bodies exert a stronger gravitational pull,\n    we prioritize bins whose remaining capacity is closest to the item size. This aims to minimize wasted space.\n    Furthermore, to encourage exploration and avoid prematurely filling bins, a slight stochastic element is added,\n    mirroring the imperfect predictability of planetary orbits. Bins with sufficient capacity will\n    have increased probability.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Calculate the difference between bin capacity and item size. Smaller difference is better\n    diff = np.abs(bins_remain_cap - item)\n    # Introduce small value to avoid division by zero.\n    epsilon = 1e-6\n    # Transform into a priority score (higher is better), with emphasis on sufficient capacity.\n    priorities = np.where(bins_remain_cap >= item, 1 / (diff + epsilon), -np.inf)\n    # Add a capacity-based bias, which favores bins with more capacity, avoiding premature fill.\n    priorities = priorities + 0.1*bins_remain_cap\n\n    # Adding small degree of exploration with a random value to explore new bins\n    random_noise = np.random.rand(len(bins_remain_cap)) * 0.01\n    priorities = priorities + random_noise\n    return priorities\n\n[Heuristics 18th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Initialize priorities with a base value (e.g., all bins are equally likely at first)\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1.  Encourage filling bins that have sufficient space.\n    #     A bin with ample space for the item should get a higher initial boost.\n    sufficient_space = bins_remain_cap >= item\n    priorities[sufficient_space] += 1.0  # Simple boost for now.  May adjust weight later\n\n    # 2. Penalize bins with very little space left after placing the item, or not enough to fit the item\n    near_full = (bins_remain_cap - item) < 0.1  # Check within 10% near fullness (example)\n\n    insufficient_space = bins_remain_cap < item\n    priorities[insufficient_space] = -np.inf #Never pick these ones.\n    \n    priorities[near_full & sufficient_space] -= 0.5 # Discourage from picking nearly full sufficient bins\n\n\n    #3. Add incentive for bins that after filling the item will have an occupancy closest to a target percentage.\n    #   Example: Ideally fill the bin up to 75%.\n    target_occupancy = 0.75\n    current_occupancy = (bins_remain_cap - item) / np.max(bins_remain_cap)\n    occupancy_diff = np.abs(current_occupancy - target_occupancy)\n    occupancy_priority = -occupancy_diff # Smaller difference to target gives higher priority\n\n    priorities[sufficient_space] += occupancy_priority[sufficient_space]\n   \n    # Add some randomness to avoid getting stuck\n    randomness = np.random.rand(len(bins_remain_cap)) * 0.01  # small amount of noise\n    priorities += randomness\n\n    return priorities\n\n[Heuristics 19th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Initialize priorities with a base value (e.g., all bins are equally likely at first)\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1.  Encourage filling bins that have sufficient space.\n    #     A bin with ample space for the item should get a higher initial boost.\n    sufficient_space = bins_remain_cap >= item\n    priorities[sufficient_space] += 1.0  # Simple boost for now.  May adjust weight later\n\n    # 2. Penalize bins with very little space left after placing the item, or not enough to fit the item\n    near_full = (bins_remain_cap - item) < 0.1  # Check within 10% near fullness (example)\n\n    insufficient_space = bins_remain_cap < item\n    priorities[insufficient_space] = -np.inf #Never pick these ones.\n    \n    priorities[near_full & sufficient_space] -= 0.5 # Discourage from picking nearly full sufficient bins\n\n\n    #3. Add incentive for bins that after filling the item will have an occupancy closest to a target percentage.\n    #   Example: Ideally fill the bin up to 75%.\n    target_occupancy = 0.75\n    current_occupancy = (bins_remain_cap - item) / np.max(bins_remain_cap)\n    occupancy_diff = np.abs(current_occupancy - target_occupancy)\n    occupancy_priority = -occupancy_diff # Smaller difference to target gives higher priority\n\n    priorities[sufficient_space] += occupancy_priority[sufficient_space]\n   \n    # Add some randomness to avoid getting stuck\n    randomness = np.random.rand(len(bins_remain_cap)) * 0.01  # small amount of noise\n    priorities += randomness\n\n    return priorities\n\n[Heuristics 20th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins that can fit the item but are not too much larger than the item.\n    It uses a combination of remaining capacity and \"waste\" calculation to achieve this.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Assign very low priority if the item doesn't fit\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] = -np.inf\n\n    # Calculate remaining capacity after adding the item\n    remaining_after_add = bins_remain_cap - item\n    \n    # Calculate waste (remaining capacity) for feasible bins\n    waste = remaining_after_add\n    waste[infeasible_mask] = np.inf  # Ensure infeasible bins have infinite waste.\n    \n    # Priority score is calculated as a combination of\n    # 1. Higher priority for bins with enough space\n    # 2. Lower priority for bins with a lot of wasted space after adding the item\n    # We use a modified logarithmic function to scale the priority inversely proportional to waste. \n    #  and some scaling factor alpha to make the remaining capacity (bins_remain_cap) more influential.\n    alpha = 0.5 # Adjust alpha based on testing - relative importance of remain capacity.\n\n    feasible_mask = ~infeasible_mask\n\n    priorities[feasible_mask] = alpha * bins_remain_cap[feasible_mask] - np.log(1 + waste[feasible_mask])\n\n    return priorities\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}