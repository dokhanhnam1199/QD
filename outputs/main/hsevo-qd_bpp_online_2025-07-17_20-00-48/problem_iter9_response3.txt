```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This function enhances the bin packing heuristic by incorporating adaptive
    strategies based on item size and bin availability. It also includes
    a bin balancing mechanism and addresses potential edge cases.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    max_cap = np.max(bins_remain_cap)
    num_bins = len(bins_remain_cap)

    # 0. Hard constraint: Item must fit. Bins that can't fit get -inf priority.
    priorities[bins_remain_cap < item] = -np.inf

    fit_mask = bins_remain_cap >= item

    if not np.any(fit_mask):
        return priorities  # No bin can fit the item

    # 1. Utilization Term: Favor better utilization, adaptively scaled.
    utilization = item / max_cap
    remaining_capacity_after_fit = bins_remain_cap - item
    utilization_score = (1 - remaining_capacity_after_fit / max_cap) * utilization
    utilization_weight = 1.0  # Base weight
    if item > 0.5 * max_cap:  # Increase weight for large items
        utilization_weight = 1.5
    priorities[fit_mask] += utilization_score[fit_mask] * utilization_weight

    # 2. Fragmentation Avoidance: Penalize bins creating tiny fragments.
    tiny_fragment_threshold = 0.05 * max_cap
    small_fragment_threshold = 0.2 * max_cap

    tiny_fragment_penalty = -10.0
    small_fragment_penalty = -2.0

    tiny_fragment_mask = (remaining_capacity_after_fit > 0) & (remaining_capacity_after_fit <= tiny_fragment_threshold)
    small_fragment_mask = (remaining_capacity_after_fit > tiny_fragment_threshold) & (remaining_capacity_after_fit <= small_fragment_threshold)

    priorities[tiny_fragment_mask] += tiny_fragment_penalty
    priorities[small_fragment_mask] += small_fragment_penalty

    # 3. "Pressure" Term: Bins with higher remaining capacity exert more "pressure".
    pressure = bins_remain_cap / max_cap * (1 - utilization)
    pressure_weight = 0.5 #Base weight
    if item < 0.2 * max_cap:
        pressure_weight = 0.25 #Reduce weight for very small items
    priorities[fit_mask] += pressure[fit_mask] * pressure_weight
    
    # 4. Best Fit Bonus: Reward the bin that provides the absolute best fit (smallest waste).
    diffs = bins_remain_cap - item
    min_diff = np.min(diffs[diffs >= 0]) if np.any(diffs >= 0) else np.inf
    best_fit_bonus = np.where(diffs == min_diff, 1.5, 0)
    priorities += best_fit_bonus

    # 5. Empty Bin Preference (Adaptive): Strongly prefer an empty bin for large items.
    empty_bin_mask = bins_remain_cap == max_cap
    empty_bin_threshold = 0.6 * max_cap
    if item >= empty_bin_threshold and np.any(empty_bin_mask):
        priorities[empty_bin_mask] += 3.0  # Strong preference

    # 6. Bin Balancing: Encourage filling bins evenly.  Bins with significantly higher
    # remaining capacity compared to the average get a slight bonus. This encourages
    # the algorithm to use bins more uniformly, hopefully preventing a few bins
    # from being nearly full while others are almost empty.
    average_remaining_capacity = np.mean(bins_remain_cap)
    balance_threshold = 1.2 * average_remaining_capacity #Bins 20% higher than average get a bonus
    above_average_mask = bins_remain_cap > balance_threshold
    balance_bonus = 0.75
    priorities[above_average_mask] += balance_bonus

    return priorities
```
