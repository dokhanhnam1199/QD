```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray,
                 tiny_fragment_threshold_fraction: float = 0.1,
                 small_fragment_threshold_fraction: float = 0.3,
                 tiny_fragment_penalty: float = -20.0,
                 small_fragment_penalty: float = -3.0,
                 pressure_weight: float = 0.6,
                 best_fit_bonus_value: float = 1.3,
                 empty_bin_threshold_fraction: float = 0.5,
                 empty_bin_preference: float = 3.0) -> np.ndarray:
    """Combines best-fit with fragmentation avoidance and bin pressure."""

    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    max_cap = np.max(bins_remain_cap)

    # 0. Hard constraint: Item must fit.  Bins that can't fit get -inf priority.
    priorities[bins_remain_cap < item] = -np.inf
    fit_mask = bins_remain_cap >= item

    if not np.any(fit_mask):
        return priorities  # No bin can fit the item

    # 1. Best Fit: Prefer bins where the item fits best.
    residual_space = bins_remain_cap[fit_mask] - item
    best_fit_idx = np.argmin(residual_space)
    priorities[fit_mask][best_fit_idx] += best_fit_bonus_value

    # 2. Fragmentation avoidance.
    remaining_after_pack = bins_remain_cap[fit_mask] - item
    tiny_fragment_threshold = max_cap * tiny_fragment_threshold_fraction
    small_fragment_threshold = max_cap * small_fragment_threshold_fraction

    tiny_fragment_mask = remaining_after_pack > 0.0
    tiny_fragment_mask = np.logical_and(tiny_fragment_mask, remaining_after_pack < tiny_fragment_threshold)

    small_fragment_mask = remaining_after_pack >= tiny_fragment_threshold
    small_fragment_mask = np.logical_and(small_fragment_mask, remaining_after_pack < small_fragment_threshold)

    priorities[fit_mask][tiny_fragment_mask] += tiny_fragment_penalty
    priorities[fit_mask][small_fragment_mask] += small_fragment_penalty

    # 3. Bin "Pressure": Preferentially fill emptier bins less.
    pressure = (max_cap - bins_remain_cap) / max_cap
    priorities[fit_mask] += pressure_weight * pressure[fit_mask]

    # 4. Empty bin preference for large items.
    if item > max_cap * empty_bin_threshold_fraction:
        empty_bin_mask = bins_remain_cap == max_cap
        priorities[empty_bin_mask] += empty_bin_preference

    return priorities
```
