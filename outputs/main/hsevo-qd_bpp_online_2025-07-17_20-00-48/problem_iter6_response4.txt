```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This function prioritizes bins based on a combination of factors, inspired by
    physical systems and adaptive parameter adjustments. Aims for robust performance
    across various item sizes.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    max_cap = np.max(bins_remain_cap)
    # 0. Handle Infeasibility
    infeasible_mask = bins_remain_cap < item
    priorities[infeasible_mask] = -np.inf

    # Proceed only for feasible bins
    feasible_mask = ~infeasible_mask
    if not np.any(feasible_mask):
        return priorities

    # 1. Utilization Term (Gravitational Analogy): Favor bins that provide a "good fit",
    #    akin to gravitational attraction proportional to mass and inversely proportional to distance.
    remaining_space = bins_remain_cap[feasible_mask] - item
    utilization_factor = item / (max_cap + 1e-9)
    #Prioritize bins with smaller remaining space (good fit), but penalize empty bins unless the item is large
    utilization_priority = utilization_factor / (remaining_space + 0.1*max_cap) #avoid division by zero and prioritize well-filled bins.

    # 2. Fragmentation Penalty (Surface Tension Analogy):  Discourage creating small fragments;
    #    Surface tension minimizes surface area.
    frag_threshold = item / 5.0  # Adaptive threshold based on item size
    frag_penalty = np.exp(-np.abs(remaining_space - frag_threshold) / (frag_threshold + 1e-9))

    # 3. Best Fit Bonus: Like crystallization, prefer the 'best' spot among close options.
    min_remaining = np.min(remaining_space)
    best_fit_bonus = np.where(remaining_space == min_remaining, 0.2, 0) #Increased the weight


    # 4. Empty Bin Preference (Inertia):  If the item is a significant portion of bin size,
    #    overcome 'inertia' and place in an empty bin.
    empty_bin_mask = bins_remain_cap == max_cap
    large_item_threshold = 0.65 * max_cap #Slightly decrease threshold
    empty_bin_priority = np.zeros_like(bins_remain_cap[feasible_mask])

    if item > large_item_threshold and np.any(empty_bin_mask[feasible_mask]):
        empty_bin_priority[empty_bin_mask[feasible_mask]] = 0.4 #Slightly increase priority


    #Combine Factors Adaptively:
    combined_priority = utilization_priority - 0.15* frag_penalty + best_fit_bonus + empty_bin_priority #tuned weights

    priorities[feasible_mask] = combined_priority


    # Add some randomness to prevent premature convergence.  Scaled by item size to allow for exploration on small items.
    randomness_scale = 0.05 * item / (max_cap+1e-9)
    priorities[feasible_mask] += np.random.normal(0, randomness_scale, size=np.sum(feasible_mask))

    return priorities
```
