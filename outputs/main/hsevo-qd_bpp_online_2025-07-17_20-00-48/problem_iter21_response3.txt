```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Enhanced priority function for online bin packing.

    This function improves upon previous versions by incorporating more nuanced strategies
    for bin selection, focusing on balancing utilization, fragmentation avoidance, bin diversity,
    and adaptability to item size. It introduces a dynamic penalty system for fragmentation
    and utilizes a bin entropy measure to promote even distribution of items.

    Args:
        item: Size of the item to be added.
        bins_remain_cap: Array of remaining capacities for each bin.

    Returns:
        Array of priority scores for each bin.
    """

    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    max_cap = np.max(bins_remain_cap)
    num_bins = len(bins_remain_cap)

    # 0. Hard constraint: Item must fit.
    fit_mask = bins_remain_cap >= item
    if not np.any(fit_mask):
        return priorities  # No bin can fit the item
    priorities[~fit_mask] = -np.inf

    # 1. Utilization Score:
    remaining_capacity_after_fit = bins_remain_cap - item
    utilization = item / max_cap
    utilization_score = (1 - remaining_capacity_after_fit / max_cap) * utilization
    priorities[fit_mask] += utilization_score[fit_mask]

    # 2. Fragmentation Avoidance (Dynamic Penalties):
    tiny_fragment_threshold = 0.05 * max_cap
    small_fragment_threshold = 0.2 * max_cap

    # Adaptive penalties based on item size and remaining capacity:
    tiny_fragment_penalty = -8.0 * (utilization + 0.1)  # Increased penalty
    small_fragment_penalty = -2.0 * (utilization + 0.1)

    tiny_fragment_mask = (remaining_capacity_after_fit > 0) & (remaining_capacity_after_fit <= tiny_fragment_threshold)
    small_fragment_mask = (remaining_capacity_after_fit > tiny_fragment_threshold) & (remaining_capacity_after_fit <= small_fragment_threshold)

    priorities[tiny_fragment_mask] += tiny_fragment_penalty
    priorities[small_fragment_mask] += small_fragment_penalty

    # 3. Pressure Term (Capacity-Aware):
    pressure = (bins_remain_cap / max_cap) * (1 - utilization)
    priorities[fit_mask] += 0.5 * pressure[fit_mask]

    # 4. Best Fit Bonus (Adaptive):
    diffs = bins_remain_cap - item
    min_diff = np.min(diffs[diffs >= 0]) if np.any(diffs >= 0) else np.inf
    best_fit_bonus = np.where(diffs == min_diff, 1.5 * (1 - utilization), 0)  # Increased bonus
    priorities += best_fit_bonus

    # 5. Empty Bin Preference (Strategic):
    empty_bin_mask = bins_remain_cap == max_cap
    empty_bin_threshold = 0.7 * max_cap  # Increased threshold
    if item >= empty_bin_threshold and np.any(empty_bin_mask):
        priorities[empty_bin_mask] += 3.0 * (utilization + 0.2)  # Stronger preference

    # 6. Bin Diversity Bonus (Entropy-Based):
    if num_bins > 1:
        # Normalize remaining capacities to create a probability distribution
        normalized_capacities = bins_remain_cap[fit_mask] / np.sum(bins_remain_cap[fit_mask])
        # Calculate entropy
        entropy = -np.sum(normalized_capacities * np.log2(normalized_capacities + 1e-9))  # Adding a small value to avoid log(0)
        # Normalize entropy to a range [0, 1]
        max_entropy = np.log2(len(normalized_capacities)) if len(normalized_capacities) > 0 else 0
        normalized_entropy = entropy / max_entropy if max_entropy > 0 else 0

        diversity_bonus = normalized_entropy
        priorities[fit_mask] += 0.3 * diversity_bonus  # Moderate bonus

    # 7. Introduce a penalty for bins nearing full capacity, but only if other options exist
    almost_full_threshold = 0.1 * max_cap
    almost_full_mask = (bins_remain_cap < item + almost_full_threshold) & (bins_remain_cap >= item)
    if np.sum(fit_mask) > 1 and np.any(almost_full_mask):  # only apply if other bins can fit
         priorities[almost_full_mask] -= 1.0 # Small penalty to discourage filling up bins completely


    return priorities
```
