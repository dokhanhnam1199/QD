import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray, *,
                 tiny_fragment_threshold_fraction: float = 0.16529609973450002,
                 small_fragment_threshold_fraction: float = 0.26982086867758737,
                 tiny_fragment_penalty: float = -12.260319825369422,
                 small_fragment_penalty: float = -4.820879413344704,
                 pressure_weight: float = 0.6845786502638291,
                 best_fit_bonus_value: float = 1.5017700654384907,
                 empty_bin_threshold_fraction: float = 0.6082192725339908,
                 empty_bin_preference: float = 3.9225929235851824) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This function prioritizes bins based on a combination of factors, now including a simulated "pressure"
    analogy and adaptive adjustments for large and small items, and explicitly avoids creating extremely small
    fragments by rejecting bins that would lead to near-zero remaining capacity.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.
        tiny_fragment_threshold_fraction: Fraction of max_cap to define tiny fragments.
        small_fragment_threshold_fraction: Fraction of max_cap to define small fragments.
        tiny_fragment_penalty: Penalty for creating a tiny fragment.
        small_fragment_penalty: Penalty for creating a small fragment.
        pressure_weight: Weight of the pressure term.
        best_fit_bonus_value: Bonus for the best fit bin.
        empty_bin_threshold_fraction: Fraction of max_cap to consider an item large for empty bin preference.
        empty_bin_preference: Preference for empty bins when item is large.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    max_cap = np.max(bins_remain_cap)

    # 0. Hard constraint: Item must fit.  Bins that can't fit get -inf priority.
    priorities[bins_remain_cap < item] = -np.inf

    fit_mask = bins_remain_cap >= item

    if not np.any(fit_mask):
        return priorities  # No bin can fit the item

    # 1. Utilization Term:  Favor better utilization, but scale based on item size.
    # Larger items get a bigger utilization bonus.
    utilization = item / max_cap  # Item size relative to maximum capacity
    remaining_capacity_after_fit = bins_remain_cap - item
    utilization_score = (1 - remaining_capacity_after_fit / max_cap) * utilization
    priorities[fit_mask] += utilization_score[fit_mask]

    # 2. Fragmentation Avoidance:  Strongly penalize bins that will result in tiny fragments.
    # Also, penalize moderately if it creates a slightly larger, but still small fragment.
    tiny_fragment_threshold = tiny_fragment_threshold_fraction * max_cap  # Significantly smaller than before, more aggressive
    small_fragment_threshold = small_fragment_threshold_fraction * max_cap   #Adjusted threshold
    
    tiny_fragment_mask = (remaining_capacity_after_fit > 0) & (remaining_capacity_after_fit <= tiny_fragment_threshold)
    small_fragment_mask = (remaining_capacity_after_fit > tiny_fragment_threshold) & (remaining_capacity_after_fit <= small_fragment_threshold)
    
    priorities[tiny_fragment_mask] += tiny_fragment_penalty
    priorities[small_fragment_mask] += small_fragment_penalty
    
    # 3. "Pressure" Term:  Simulate bins as containers with "pressure."  Bins with higher remaining
    # capacity exert more "pressure" to accept the item, but scale down with item size to prevent overfilling.
    pressure = bins_remain_cap / max_cap * (1 - utilization)
    priorities[fit_mask] += pressure_weight * pressure[fit_mask]

    # 4. Best Fit Bonus:  Reward the bin that provides the absolute best fit (smallest waste).
    diffs = bins_remain_cap - item
    min_diff = np.min(diffs[diffs >= 0]) if np.any(diffs >= 0) else np.inf
    best_fit_bonus = np.where(diffs == min_diff, best_fit_bonus_value, 0)
    priorities += best_fit_bonus
    
    # 5. Empty Bin Preference (Adaptive): If the item is a significant fraction of bin size, strongly prefer
    # an empty bin.  The threshold is now adaptive and more stringent.
    empty_bin_mask = bins_remain_cap == max_cap
    empty_bin_threshold = empty_bin_threshold_fraction * max_cap
    if item >= empty_bin_threshold and np.any(empty_bin_mask):
        priorities[empty_bin_mask] += empty_bin_preference # Strong preference

    return priorities
