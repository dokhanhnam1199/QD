```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Inspired by my laws of motion and gravity. The "force" of attraction
    between the item and the bin is proportional to the product of their
    "masses" (related to sizes/capacity) and inversely proportional to the
    "distance" (difference in remaining capacity and item size, scaled).

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Ensure positive remaining capacity to avoid division by zero.
    safe_bins_remain_cap = np.maximum(bins_remain_cap, 1e-9)

    # Potential bins where the item fits. Give others a low negative priority.
    fit_mask = safe_bins_remain_cap >= item
    priorities = np.full_like(safe_bins_remain_cap, -1e9)
    priorities[~fit_mask] = -np.inf # should never choose bins with item > capacity

    # Define masses: item size as mass_item, remaining capacity as mass_bin.
    mass_item = item
    mass_bin = safe_bins_remain_cap

    # Define distance: difference between remaining capacity and item size, plus small number to avoid inf
    distance = np.abs(safe_bins_remain_cap - item) + 1e-9

    # Calculate "gravitational force" (priority):  G * (mass_item * mass_bin) / distance^2
    # We can drop G because we are only interested in relative priorities.
    priorities[fit_mask] = (mass_item * mass_bin[fit_mask]) / (distance[fit_mask]**2)

    # Add small bonus for bins that are nearly full (packing efficiency) but make sure it won't override invalid bins.
    nearly_full_bonus = np.zeros_like(priorities)
    nearly_full_mask = (safe_bins_remain_cap - item) < (0.1 * safe_bins_remain_cap)
    nearly_full_bonus[nearly_full_mask & fit_mask] = 10

    priorities += nearly_full_bonus

    return priorities
```
