```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Combines utilization, fragmentation avoidance, and best fit with adaptivity."""

    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    max_cap = np.max(bins_remain_cap)

    # Hard constraint: Item must fit.
    no_fit_mask = bins_remain_cap < item
    priorities[no_fit_mask] = -np.inf

    # Utilization Term: Favor better utilization.
    fit_mask = bins_remain_cap >= item
    if np.any(fit_mask):
      utilization = item / max_cap
      remaining_capacity_after_fit = bins_remain_cap - item
      utilization_score = (1 - remaining_capacity_after_fit / max_cap) * utilization
      priorities[fit_mask] += utilization_score[fit_mask]

    # Fragmentation Avoidance: Penalize tiny fragments.
    if np.any(fit_mask):
      tiny_fragment_threshold = 0.05 * max_cap
      tiny_fragment_penalty = -5.0

      remaining_capacity_after_fit = bins_remain_cap - item
      tiny_fragment_mask = (remaining_capacity_after_fit > 0) & (remaining_capacity_after_fit <= tiny_fragment_threshold)

      priorities[tiny_fragment_mask] += tiny_fragment_penalty

    # Best Fit Bonus: Reward the bin with smallest waste.
    if np.any(fit_mask):
      diffs = bins_remain_cap - item
      valid_diffs = diffs[diffs >= 0]
      if valid_diffs.size > 0:
        min_diff = np.min(valid_diffs)
        best_fit_bonus = np.where(diffs == min_diff, 1.0, 0)
        priorities += best_fit_bonus
    return priorities
```
