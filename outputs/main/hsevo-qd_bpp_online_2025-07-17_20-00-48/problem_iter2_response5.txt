```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Prioritizes bins based on space utilization and preferred waste."""
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    valid_bins = bins_remain_cap >= item
    if np.any(valid_bins):
        remaining_after_fit = bins_remain_cap[valid_bins] - item
        space_utilization = item / bins_remain_cap[valid_bins]
        preferred_waste_low = 0.1
        preferred_waste_high = 0.3
        waste = remaining_after_fit / bins_remain_cap[valid_bins]
        ideal_waste = (waste >= preferred_waste_low) & (waste <= preferred_waste_high)
        too_little_waste = (waste < preferred_waste_low) & (waste > 0)
        excessive_waste = waste > preferred_waste_high

        priorities[valid_bins][ideal_waste] = 10 * space_utilization[ideal_waste] #Arbitrary high value. Consider function of cap/item
        priorities[valid_bins][too_little_waste] = 10 * space_utilization[too_little_waste] * waste[too_little_waste] / preferred_waste_low # linear decrease to 0
        priorities[valid_bins][excessive_waste] = 5 * space_utilization[excessive_waste] * np.exp(-5 * (waste[excessive_waste] - preferred_waste_high))
        very_small_gap = remaining_after_fit < 0.1
        priorities[valid_bins][very_small_gap] = -1
    else:
        priorities[:] = -np.inf
    return priorities
```
