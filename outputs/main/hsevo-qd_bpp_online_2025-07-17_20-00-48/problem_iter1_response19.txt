```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version prioritizes bins that have enough space for the item
    but penalizes those with too much or too little space to reduce fragmentation.
    It also considers filling bins to near-full capacity as a high priority.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    available_bins = bins_remain_cap >= item

    if not np.any(available_bins):
        return priorities # No suitable bin, all priorities remain 0

    for i in range(len(bins_remain_cap)):
        if available_bins[i]:
            remaining_space = bins_remain_cap[i] - item
            # Reward bins with minimal wasted space
            waste_penalty = np.abs(remaining_space) # Linear penalty

            #Heuristic 1: Favour bins that have exactly enough capacity for the item
            exact_fit_reward = 0
            if remaining_space == 0:
              exact_fit_reward = 10

            #Heuristic 2: Reduce Fragmentation
            frag_penalty = 0
            if remaining_space > 0: #some wasted space
                frag_penalty = remaining_space / np.sum(bins_remain_cap) #Normalizing remaining space to capacity

            #Heuristic 3: Maximize Bin utilization
            bin_util = item / (bins_remain_cap[i] + item)

            #Priority calculations. Combine heuristic aspects
            priorities[i] = 100 - waste_penalty - (frag_penalty * 50) + exact_fit_reward + bin_util*20
        else:
            priorities[i] = -np.inf  # Impossible to fit

    return priorities
```
