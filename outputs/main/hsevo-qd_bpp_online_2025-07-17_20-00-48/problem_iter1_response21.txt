```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.
    Inspired by the concept of spacetime curvature, bins with remaining capacity closer
    to the item size will experience a stronger "gravitational pull." We also add a
    factor to avoid filling bins too greedily early on, preserving space for potentially
    larger future items (analogous to maintaining spacetime stability). A small random
    component is added, like Brownian motion, to explore near-optimal configurations.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Avoid division by zero (bins with zero remaining capacity).  Give them very low priority.
    bins_remain_cap_safe = np.where(bins_remain_cap <= 0, np.inf, bins_remain_cap)

    # Calculate the "gravitational potential" based on how well the item fits.
    # A value close to 0 suggests a good fit.  Add a small number to remaining
    # capacity so item fits.
    potential = np.abs(bins_remain_cap_safe - item)

    # Use a Gaussian-like function to convert potential to "gravitational force" or priority.
    # The smaller the potential (closer the fit), the higher the priority.
    priority_base = np.exp(-(potential**2) / (2 * (item / 2)**2))  # sigma proportional to item size

    # Penalize bins that are getting too full (analogy to "spacetime distortion").
    # Reduce priority for bins that have been filled past some percentage, for example 80%.
    fill_ratio = (1 - bins_remain_cap_safe / np.max(bins_remain_cap)) #Use max cap for reference
    full_bin_penalty = np.where(fill_ratio > 0.8, 1-fill_ratio, 1) # Penalize bins filled >80%

    priorities = priority_base * full_bin_penalty

    # Add a small random component to encourage exploration.
    priorities += np.random.normal(0, 0.01, size=bins_remain_cap.shape)

    # Set bins with insufficient capacity to negative infinity.
    priorities = np.where(bins_remain_cap < item, -np.inf, priorities)

    return priorities
```
