```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This function refines the priority calculation by incorporating a refined fragmentation penalty,
    a capacity-aware best-fit bonus, a bin-emptiness gradient, and an advanced diversity measure
    that considers both remaining capacity and the number of items already packed.  Adaptive scaling
    is used throughout to adjust to varying item and bin sizes.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    max_cap = np.max(bins_remain_cap)
    num_bins = len(bins_remain_cap)

    # 0. Hard constraint: Item must fit. Bins that can't fit get -inf priority.
    priorities[bins_remain_cap < item] = -np.inf

    fit_mask = bins_remain_cap >= item

    if not np.any(fit_mask):
        return priorities  # No bin can fit the item

    # 1. Utilization Term: Favor better utilization, but scale based on item size.
    utilization = item / max_cap
    remaining_capacity_after_fit = bins_remain_cap - item
    utilization_score = (1 - remaining_capacity_after_fit / max_cap) * utilization
    priorities[fit_mask] += utilization_score[fit_mask]

    # 2. Refined Fragmentation Avoidance: Penalize bins that will result in tiny or small fragments,
    # with adaptive penalties based on the item's relative size compared to the bin.
    tiny_fragment_threshold = 0.05 * max_cap
    small_fragment_threshold = 0.2 * max_cap

    # Adaptive penalty based on item size: Larger items impose a heavier penalty for tiny fragments
    tiny_fragment_penalty = -5.0 - 7.0 * utilization  # Enhanced penalty for larger items causing tiny fragments
    small_fragment_penalty = -1.0 - 2.0 * utilization  # Enhanced penalty for larger items causing small fragments

    tiny_fragment_mask = (remaining_capacity_after_fit > 0) & (remaining_capacity_after_fit <= tiny_fragment_threshold)
    small_fragment_mask = (remaining_capacity_after_fit > tiny_fragment_threshold) & (remaining_capacity_after_fit <= small_fragment_threshold)

    priorities[tiny_fragment_mask] += tiny_fragment_penalty
    priorities[small_fragment_mask] += small_fragment_penalty

    # 3. "Pressure" Term: Bins with higher remaining capacity exert more "pressure". Adjust scaling dynamically.
    pressure = bins_remain_cap / max_cap * (1 - utilization)
    priorities[fit_mask] += 0.5 * pressure[fit_mask]

    # 4. Capacity-Aware Best Fit Bonus: Reward the bin that provides the absolute best fit (smallest waste),
    # with a bonus that increases as the bin's capacity increases.
    diffs = bins_remain_cap - item
    min_diff = np.min(diffs[diffs >= 0]) if np.any(diffs >= 0) else np.inf
    best_fit_bonus = np.where(diffs == min_diff, (1.0 + 0.5 * (1 - utilization)) * (bins_remain_cap / max_cap), 0)  # Adaptive bonus
    priorities += best_fit_bonus

    # 5. Empty Bin Preference (Adaptive Gradient): If the item is a significant fraction of bin size, strongly prefer an empty bin.
    # Add a gradient based on how close the bin is to empty.
    empty_bin_mask = bins_remain_cap == max_cap
    nearly_empty_mask = (bins_remain_cap > 0.9 * max_cap) & (bins_remain_cap < max_cap)
    empty_bin_threshold = 0.6 * max_cap

    if item >= empty_bin_threshold:
        if np.any(empty_bin_mask):
            priorities[empty_bin_mask] += 2.5 + 1.5 * utilization  # Stronger adaptive preference

        if np.any(nearly_empty_mask):
            priorities[nearly_empty_mask] += 1.0 + 0.5 * utilization

    # 6. Advanced Bin Diversity Bonus: Encourage spreading items across different bins, considering both
    # remaining capacity and the number of items already packed in each bin.  This encourages more balanced loading.
    if num_bins > 1:
        # Estimate 'fullness' based on how close to the original max_cap each bin is.
        bin_fullness = (max_cap - bins_remain_cap) / max_cap
        diversity_metric = np.std(bin_fullness[fit_mask])  # Std dev of fullness
        diversity_bonus = diversity_metric  # Normalize
        priorities[fit_mask] += 0.3 * diversity_bonus  # Moderate diversity bonus

    return priorities
```
