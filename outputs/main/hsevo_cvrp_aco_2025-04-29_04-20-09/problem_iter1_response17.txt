```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics function for CVRP using a combination of distance, demand,
    and angle considerations. This version attempts to incorporate the
    vehicle capacity constraint more directly.

    Args:
        distance_matrix: Distance between nodes (n x n).
        coordinates: Node coordinates (n x 2).
        demands: Node demands (n).
        capacity: Vehicle capacity.

    Returns:
        A matrix (n x n) representing the desirability of each edge.
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Parameters (tunable)
    alpha = 1.0  # Weight for distance
    beta = 1.0   # Weight for demand
    gamma = 1.0  # Weight for angle

    for i in range(n):
        for j in range(n):
            if i != j:
                # Distance component (inverse of distance)
                distance_component = 1 / distance_matrix[i, j]

                # Demand component: penalize links that connect nodes where sum
                # of demands would largely exceed capacity.  Higher values when demands are small.
                demand_component = 1.0 / (1.0 + np.exp(beta * (demands[i] + demands[j] - capacity/2.0))) #Sigmoid centered on capacity/2

                # Angle component (encourage gradual turns; penalize sharp turns)
                # Dot product of vectors (depot -> i) and (depot -> j). Smaller angle implies better
                if i != 0 and j != 0:  #Exclude links to depot when calc. angle component.
                    vector_i = coordinates[i] - coordinates[0]
                    vector_j = coordinates[j] - coordinates[0]
                    dot_product = np.dot(vector_i, vector_j) / (np.linalg.norm(vector_i) * np.linalg.norm(vector_j) + 1e-9) # +1e-9 to avoid division by zero.
                    angle_component = (1.0 + dot_product)/2.0 #scale from -1..1 to 0..1

                elif i !=0: #connecting a node to the depot
                    vector_i = coordinates[i] - coordinates[0]
                    angle_component = 0.5 # Neutral value, not particularly useful.

                elif j != 0:
                    vector_j = coordinates[j] - coordinates[0]
                    angle_component = 0.5  # Neutral value, not particularly useful.
                else:
                     angle_component = 0.5  #Neutral - connecting depot to depot has no real angle.


                # Combine components
                heuristic_matrix[i, j] = (alpha * distance_component +
                                            beta * demand_component +
                                            gamma * angle_component)


    return heuristic_matrix
```
