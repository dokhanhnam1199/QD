```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """Combines distance, demand, angle, centrality, and depot attraction, with sparsification."""
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix)
    center_x = np.mean(coordinates[1:, 0])
    center_y = np.mean(coordinates[1:, 1])
    total_demand = np.sum(demands[1:])
    demand_weighted_dist_to_depot = np.sum(demands[1:] * distance_matrix[0, 1:]) / total_demand if total_demand > 0 else 0

    # Calculate average demand
    avg_demand = np.mean(demands[1:])

    # Normalized demands for smoother calculations
    demand_normalized = demands / np.max(demands)

    for i in range(n):
        for j in range(n):
            if i == j:
                continue

            distance = distance_matrix[i, j]
            distance_component = 1 / (distance + 1e-6)

            # Capacity component with smoother transition
            demand_component = np.exp(-((demands[i] + demands[j]) / (capacity + 1e-6))**2)  # Gaussian penalty


            # Angle component - prefer edges that don't cause sharp turns
            angle_component = 1.0
            if i != 0 and j != 0:
                angles = []
                for k in range(n):
                    if k != i and k != j:
                        v1 = coordinates[i] - coordinates[j]
                        v2 = coordinates[k] - coordinates[i]
                        dot_product = np.dot(v1, v2)
                        magnitudes = np.linalg.norm(v1) * np.linalg.norm(v2)
                        if magnitudes == 0:
                            angle = 0
                        else:
                            angle = np.arccos(dot_product / magnitudes)
                        angles.append(angle)
                if len(angles) > 0:
                    angle_component = min(np.degrees(angles) / 180.0)  # Normalize to [0, 1]

            # Centrality component - attract towards the center of gravity
            center_distance = (np.sqrt((coordinates[i, 0] - center_x)**2 + (coordinates[i, 1] - center_y)**2) +
                               np.sqrt((coordinates[j, 0] - center_x)**2 + (coordinates[j, 1] - center_y)**2)) / 2
            centrality_component = np.exp(-center_distance / (demand_weighted_dist_to_depot + 1e-6))

            # Depot attraction component - nodes with high demand should be closer to the depot
            depot_component = 1.0
            if i!=0 and j!=0:
                depot_dist_i = distance_matrix[0, i]
                depot_dist_j = distance_matrix[0, j]
                depot_component = np.exp(-(depot_dist_i + depot_dist_j) / (2 * demand_weighted_dist_to_depot + 1e-6))

            # Demand Balance Component - Try to balance the load on the routes
            demand_balance_component = 1.0
            if i != 0 and j != 0:
                demand_diff = abs(demands[i] - demands[j])
                demand_balance_component = np.exp(-demand_diff / (avg_demand + 1e-6))

            heuristic_matrix[i, j] = (distance_component**1.5 * demand_component * (1 - angle_component)**0.5 *
                                      centrality_component**0.8 * depot_component**0.7 * demand_balance_component**0.6)

            # Sparsification - Remove edges that are unlikely to be in the optimal solution
            if heuristic_matrix[i, j] < 0.1 * np.mean(heuristic_matrix): #Dynamic threshold.
                heuristic_matrix[i, j] = 0

    return heuristic_matrix
```
