```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Newtonian Heuristics for Capacitated Vehicle Routing Problem (CVRP).

    This function incorporates gravity-inspired attraction, pheromone-like reinforcement,
    and capacity considerations to generate a heuristic matrix guiding stochastic solution sampling.

    Args:
        distance_matrix (np.ndarray): Distance matrix between nodes (n x n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (n x 2).
        demands (np.ndarray): Demand of each node (n). depot is demands[0].
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Heuristic matrix (n x n) indicating edge desirability.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Parameters (tuned with physical intuition and experimentation)
    gravity_constant = 1.0  # Strength of attraction (inverse distance)
    pheromone_strength = 0.5  # Reinforcement of edges used in good solutions (initially 0)
    capacity_penalty = 2.0 # Increased penalty based on approaching capacity.
    depot_attraction = 1.5 # Bias towards traveling from depot, as most routes require this.
    nearby_penalty = 0.8 # discourage near node.
    # mass = demand?

    # Initialize Pheromone Matrix (representing "good routes" seen so far) - Initially none.
    pheromone_matrix = np.zeros((n, n)) # tracks how often the edge appears.


    # --- Newtonian Gravitation Inspired Attraction ---
    #   Stronger attraction between closer nodes (inverse distance).

    for i in range(n):
        for j in range(n):
            if i != j:
                heuristic_matrix[i, j] = gravity_constant / distance_matrix[i, j]

                #Emphasize Depot connections.
                if i == 0 or j == 0:
                  heuristic_matrix[i, j] *= depot_attraction


    # --- Capacity Consideration ---
    #   Penalize edges that lead to exceeding vehicle capacity

    for i in range(n):
        for j in range(n):
            if i != j:
                #Approximated Penalty. Needs to see further context.
                estimated_load = demands[j]
                if estimated_load > capacity:
                  heuristic_matrix[i, j] = 0 # No chance if exceeds capacity.
                else:
                    # Penalize based on the remaining available capacity. The closer to capacity the more penalization.
                    remaining_capacity_ratio = (capacity - estimated_load) / capacity
                    heuristic_matrix[i, j] *= (1 + capacity_penalty * remaining_capacity_ratio)


    # --- Node Location Consideration ---
    #   Discourage traveling to very nearby nodes (might create unnecessary loops).

    for i in range(n):
        for j in range(n):
            if i !=j and distance_matrix[i,j] < np.mean(distance_matrix):
                heuristic_matrix[i,j] *= nearby_penalty


    # --- Normalize Heuristic Matrix ---
    #   Ensures values are within a reasonable range. Prevents overflow.
    heuristic_matrix = (heuristic_matrix - np.min(heuristic_matrix)) / (np.max(heuristic_matrix) - np.min(heuristic_matrix) + 1e-9)


    return heuristic_matrix
```
