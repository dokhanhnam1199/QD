```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """Combines adaptive distance, demand, centrality, and depot attraction."""
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix)

    # Adaptive distance component
    avg_dist_to_depot = np.mean(distance_matrix[0, 1:])
    distance_component = np.exp(-distance_matrix / (avg_dist_to_depot + 1e-9))

    # Demand component, penalizing capacity violations
    demand_matrix = np.add.outer(demands, demands)
    demand_component = np.where(demand_matrix > capacity, 0.01, 1.0)
    for i in range(n):
        demand_component[i,i] = 0

    # Centrality component
    center_x = np.mean(coordinates[1:, 0])
    center_y = np.mean(coordinates[1:, 1])
    center_distances = np.sqrt((coordinates[:, 0] - center_x)**2 + (coordinates[:, 1] - center_y)**2)
    total_demand = np.sum(demands[1:])
    demand_weighted_dist_to_depot = np.sum(demands[1:] * distance_matrix[0, 1:]) / total_demand if total_demand > 0 else np.mean(distance_matrix[0, 1:])
    centrality_component = np.exp(-(center_distances[:, None] + center_distances[None, :]) / (2 * demand_weighted_dist_to_depot + 1e-9))

    # Depot attraction component
    depot_attraction = np.exp(-distance_matrix[0, :] / (avg_dist_to_depot + 1e-9))
    depot_component = (depot_attraction[:, None] + depot_attraction[None, :]) / 2

    # Angle Component
    depot_x, depot_y = coordinates[0]
    angles = np.arctan2(coordinates[:, 1] - depot_y, coordinates[:, 0] - depot_x)
    angle_diffs = np.abs(angles[:, None] - angles[None, :])
    angle_component = np.exp(-2 * angle_diffs)

    # Combine components multiplicatively with powers
    alpha, beta, gamma, delta, epsilon = 1.0, 1.0, 1.0, 1.0, 1.0  # Tune these!
    heuristic_matrix = distance_component**alpha * demand_component**beta * centrality_component**gamma * depot_component**delta * angle_component**epsilon

    # Adaptive sparsification
    threshold = np.mean(heuristic_matrix[heuristic_matrix > 0]) * 0.2
    heuristic_matrix[heuristic_matrix < threshold] = 0
    heuristic_matrix[distance_matrix == 0] = 0 # remove edges that are not allowed

    return heuristic_matrix
```
