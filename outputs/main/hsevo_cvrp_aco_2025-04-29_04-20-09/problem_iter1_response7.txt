```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics for CVRP based on a combination of distance, demand, and angular considerations.
    This version attempts to incorporate some of the clever ideas I might have considered,
    namely probability weighting based on angles to try to steer routes in a way that minimizes sharp turns (a common feature of bad routes in CVRP).

    Args:
        distance_matrix (np.ndarray): Distance matrix (n x n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (n x 2).
        demands (np.ndarray): Customer demands (n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators for edges (n x n).  Higher values indicate more promising edges.
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros((n, n))

    # Add a tiny amount to demands to prevent division by zero issues.
    adjusted_demands = demands + 1e-9

    # Combine inverse distance with demand considerations. Avoid depot->depot edges.
    for i in range(n):
        for j in range(n):
            if i != j: # Avoid self loops which are not feasible
                heuristics_matrix[i, j] = (1 / distance_matrix[i, j]) * (1 - (adjusted_demands[j] / capacity)) # Normalized demand penalization

    # Favor edges connected to depot from far away locations.
    depot_distance_bonuses = np.zeros((n,n))
    for i in range(1,n): #Skip the depot.
      for j in range(1,n):
          depot_distance_bonuses[0, i] = 1/distance_matrix[0,i] #Favor connecting edges to nodes that are far away from depot.

    heuristics_matrix += depot_distance_bonuses

    #Angle considerations to favor smooth paths
    angle_bonuses = np.zeros((n, n))
    for i in range(1, n):
        for j in range(1, n):
            if i!=j:
              #Dot product-based measurement of angle smoothness
              vector1 = coordinates[i] - coordinates[0]
              vector2 = coordinates[j] - coordinates[i]
              unit_vector1 = vector1 / np.linalg.norm(vector1)
              unit_vector2 = vector2 / np.linalg.norm(vector2)
              dot_product = np.dot(unit_vector1, unit_vector2)
              angle_bonuses[i, j] = (dot_product + 1) / 2 #Scales to [0, 1] higher values indicate lower angles/straighter paths

    heuristics_matrix += 0.1*angle_bonuses #Small influence, not sure about the weighting

    #Set diagonals to 0.
    for i in range(n):
        heuristics_matrix[i,i] = 0

    # Return the heuristic matrix.  A normalization or other transformations could be added to tune exploration characteristics.
    return heuristics_matrix
```
