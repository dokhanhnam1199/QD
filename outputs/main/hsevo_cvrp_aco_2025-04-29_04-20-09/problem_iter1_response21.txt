```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristic function for solving Capacitated Vehicle Routing Problem (CVRP)
    via stochastic solution sampling.  This version incorporates more factors
    than the trivial version.

    Args:
        distance_matrix (np.ndarray): Distance matrix (n x n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (n x 2).
        demands (np.ndarray): Customer demands (n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators for edges (n x n).
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros((n, n))

    # Calculate a capacity penalty. Nodes with higher demand should be visited earlier
    # or connected to the depot, as the available vehicle space becomes limited.
    demand_normalized = demands / np.max(demands) #demand between 0 and 1
    demand_penalty = np.zeros((n, n))
    for i in range(n):
      for j in range(n):
        demand_penalty[i,j] = demand_normalized[i] + demand_normalized[j]
    demand_penalty = np.clip(demand_penalty,0.0,1.0)
    

    # Distance heuristic: Shorter distances are generally preferred
    distance_heuristic = 1 / (distance_matrix + 1e-6)  # Adding a small value to prevent division by zero


    # Depot affinity heuristic: Encourage connections to the depot,
    # particularly for nodes with high demand.
    depot_affinity = np.zeros((n, n))
    for i in range(n):
        for j in range(n):
            if i == 0 or j == 0: #either i or j is the depot
                depot_affinity[i, j] = 1.0 # high priority if going from/to depot
            else:
                 depot_affinity[i,j] = 0.0

    # Coordinates based routing: closer coordinate pairs are considered first.

    coordinate_distance = np.zeros((n,n))

    for i in range(n):
      for j in range(n):
        coordinate_distance[i,j] = np.linalg.norm(coordinates[i,:] - coordinates[j,:])
    coordinate_heuristic = 1 / (coordinate_distance+1e-6)

    # Combine the heuristics (weighted sum)

    heuristics = (0.6 * distance_heuristic
                  + 0.15 * depot_affinity
                  + 0.15 * coordinate_heuristic
                  + 0.1 * (1-demand_penalty) )

    # Set diagonal elements to zero to avoid self-loops
    for i in range(n):
        heuristics[i, i] = 0

    return heuristics
```
