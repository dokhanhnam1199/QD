```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """Adaptive heuristic using distance, demand, angle, and sparsification."""
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Normalize distance
    max_distance = np.max(distance_matrix[distance_matrix != np.inf])
    normalized_distance = distance_matrix / max_distance
    normalized_distance = np.where(normalized_distance == 0, 1e-6, normalized_distance)

    # Calculate angles relative to the depot
    depot_x, depot_y = coordinates[0]
    angles = np.arctan2(coordinates[:, 1] - depot_y, coordinates[:, 0] - depot_x)

    # Calculate demand density
    areas = []
    for i in range(n):
        area = distance_matrix[0, i] ** 2
        areas.append(area)
    max_area = np.max(areas) if np.max(areas) > 0 else 1
    demand_densities = demands / (np.array(areas) / max_area + 1e-6)

    # Center of mass
    center_x = np.mean(coordinates[1:, 0])
    center_y = np.mean(coordinates[1:, 1])

    # Weights (adaptive) - can be tuned during the search
    distance_weight = 0.5
    demand_weight = 0.25
    angle_weight = 0.15
    centrality_weight = 0.1

    for i in range(n):
        for j in range(n):
            if i != j:
                heuristic_value = 1.0

                # Distance component
                heuristic_value *= (1 / normalized_distance[i, j]) ** distance_weight

                # Demand component
                demand_penalty = np.exp(-2 * (demand_densities[i] + demand_densities[j]))
                heuristic_value *= demand_penalty ** demand_weight

                # Angle component
                angle_diff = abs(angles[i] - angles[j])
                angle_penalty = np.exp(-2 * angle_diff)
                heuristic_value *= angle_penalty ** angle_weight

                # Centrality component
                center_distance_i = np.sqrt((coordinates[i, 0] - center_x)**2 + (coordinates[i, 1] - center_y)**2) / max_distance
                center_distance_j = np.sqrt((coordinates[j, 0] - center_x)**2 + (coordinates[j, 1] - center_y)**2) / max_distance
                avg_center_distance = (center_distance_i + center_distance_j) / 2
                centrality_penalty = np.exp(-avg_center_distance)
                heuristic_value *= centrality_penalty ** centrality_weight

                heuristic_matrix[i, j] = heuristic_value

    # Adaptive sparsification based on mean
    threshold = np.mean(heuristic_matrix) * 0.2
    heuristic_matrix[heuristic_matrix < threshold] = 0

    return heuristic_matrix
```
