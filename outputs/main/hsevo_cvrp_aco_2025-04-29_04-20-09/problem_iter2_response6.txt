```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Combines distance, demand, depot proximity, and capacity awareness.
    Penalizes high-demand connections and favors depot returns.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix)

    normalized_demands = demands / np.max(demands) if np.max(demands) > 0 else demands
    depot_distances = distance_matrix[0, :]
    normalized_depot_distances = depot_distances / np.max(depot_distances)

    gravity_constant = 1.0
    capacity_penalty = 2.0
    depot_attraction = 1.5
    nearby_penalty = 0.8

    for i in range(n):
        for j in range(n):
            if i == j:
                heuristic_matrix[i, j] = 0
            else:
                heuristic = gravity_constant / (distance_matrix[i, j] + 1e-9)

                if i == 0 or j == 0:
                    heuristic *= depot_attraction

                estimated_load = demands[j]
                if estimated_load > capacity:
                    heuristic = 0
                else:
                    remaining_capacity_ratio = (capacity - estimated_load) / capacity
                    heuristic *= (1 + capacity_penalty * remaining_capacity_ratio)
                    heuristic *= (1 - (normalized_demands[i] + normalized_demands[j]) / 2)
                    heuristic += 0.1 * (1 - (normalized_depot_distances[i] + normalized_depot_distances[j]) / 2)

                if distance_matrix[i, j] < np.mean(distance_matrix):
                    heuristic *= nearby_penalty

                heuristic_matrix[i, j] = heuristic

    heuristic_matrix = (heuristic_matrix - np.min(heuristic_matrix)) / (np.max(heuristic_matrix) - np.min(heuristic_matrix) + 1e-9)
    return heuristic_matrix
```
