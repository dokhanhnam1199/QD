{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Combines centrality, capacity, angle, and depot attraction for CVRP.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n    center_x = np.mean(coordinates[1:, 0])\n    center_y = np.mean(coordinates[1:, 1])\n    total_demand = np.sum(demands[1:])\n    demand_weighted_dist_to_depot = np.sum(demands[1:] * distance_matrix[0, 1:]) / total_demand if total_demand > 0 else 0\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n\n            distance = distance_matrix[i, j]\n            distance_component = 1 / (distance + 1e-6)\n\n            demand_component = 1.0\n            if i != 0 and j != 0 and demands[i] + demands[j] > capacity:\n                demand_component = 0.1\n\n            angle_component = 1.0\n            if i != 0 and j != 0:\n                angles = []\n                for k in range(n):\n                    if k != i and k != j:\n                        v1 = coordinates[i] - coordinates[j]\n                        v2 = coordinates[k] - coordinates[i]\n                        dot_product = np.dot(v1, v2)\n                        magnitudes = np.linalg.norm(v1) * np.linalg.norm(v2)\n                        if magnitudes == 0:\n                            angle = 0\n                        else:\n                            angle = np.arccos(dot_product / magnitudes)\n                        angles.append(angle)\n                if len(angles) > 0:\n                    angle_component = min(np.degrees(angles) / 180.0)\n\n            center_distance = (np.sqrt((coordinates[i, 0] - center_x)**2 + (coordinates[i, 1] - center_y)**2) +\n                               np.sqrt((coordinates[j, 0] - center_x)**2 + (coordinates[j, 1] - center_y)**2)) / 2\n            centrality_component = np.exp(-center_distance / demand_weighted_dist_to_depot if demand_weighted_dist_to_depot>0 else 1)\n\n            depot_component = 1.0\n            if i!=0:\n                load_before_depot = demands[i]\n                depot_component = (1 + np.exp(load_before_depot/capacity)) / 2\n\n            heuristic_matrix[i, j] = (distance_component * demand_component * (1 - angle_component) * centrality_component * depot_component)\n\n    return heuristic_matrix\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Combines distance, demand, angle, centrality, and depot attraction, with sparsification.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n    center_x = np.mean(coordinates[1:, 0])\n    center_y = np.mean(coordinates[1:, 1])\n    total_demand = np.sum(demands[1:])\n    demand_weighted_dist_to_depot = np.sum(demands[1:] * distance_matrix[0, 1:]) / total_demand if total_demand > 0 else 0\n\n    # Calculate average demand\n    avg_demand = np.mean(demands[1:])\n\n    # Normalized demands for smoother calculations\n    demand_normalized = demands / np.max(demands)\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n\n            distance = distance_matrix[i, j]\n            distance_component = 1 / (distance + 1e-6)\n\n            # Capacity component with smoother transition\n            demand_component = np.exp(-((demands[i] + demands[j]) / (capacity + 1e-6))**2)  # Gaussian penalty\n\n\n            # Angle component - prefer edges that don't cause sharp turns\n            angle_component = 1.0\n            if i != 0 and j != 0:\n                angles = []\n                for k in range(n):\n                    if k != i and k != j:\n                        v1 = coordinates[i] - coordinates[j]\n                        v2 = coordinates[k] - coordinates[i]\n                        dot_product = np.dot(v1, v2)\n                        magnitudes = np.linalg.norm(v1) * np.linalg.norm(v2)\n                        if magnitudes == 0:\n                            angle = 0\n                        else:\n                            angle = np.arccos(dot_product / magnitudes)\n                        angles.append(angle)\n                if len(angles) > 0:\n                    angle_component = min(np.degrees(angles) / 180.0)  # Normalize to [0, 1]\n\n            # Centrality component - attract towards the center of gravity\n            center_distance = (np.sqrt((coordinates[i, 0] - center_x)**2 + (coordinates[i, 1] - center_y)**2) +\n                               np.sqrt((coordinates[j, 0] - center_x)**2 + (coordinates[j, 1] - center_y)**2)) / 2\n            centrality_component = np.exp(-center_distance / (demand_weighted_dist_to_depot + 1e-6))\n\n            # Depot attraction component - nodes with high demand should be closer to the depot\n            depot_component = 1.0\n            if i!=0 and j!=0:\n                depot_dist_i = distance_matrix[0, i]\n                depot_dist_j = distance_matrix[0, j]\n                depot_component = np.exp(-(depot_dist_i + depot_dist_j) / (2 * demand_weighted_dist_to_depot + 1e-6))\n\n            # Demand Balance Component - Try to balance the load on the routes\n            demand_balance_component = 1.0\n            if i != 0 and j != 0:\n                demand_diff = abs(demands[i] - demands[j])\n                demand_balance_component = np.exp(-demand_diff / (avg_demand + 1e-6))\n\n            heuristic_matrix[i, j] = (distance_component**1.5 * demand_component * (1 - angle_component)**0.5 *\n                                      centrality_component**0.8 * depot_component**0.7 * demand_balance_component**0.6)\n\n            # Sparsification - Remove edges that are unlikely to be in the optimal solution\n            if heuristic_matrix[i, j] < 0.1 * np.mean(heuristic_matrix): #Dynamic threshold.\n                heuristic_matrix[i, j] = 0\n\n    return heuristic_matrix\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Combines distance, demand, depot proximity, and angle.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n\n    # Normalize distance\n    max_distance = np.max(distance_matrix[distance_matrix != np.inf])\n    normalized_distance = distance_matrix / max_distance\n    normalized_distance = np.where(normalized_distance == 0, 1e-6, normalized_distance)\n\n    # Calculate angles\n    depot_x, depot_y = coordinates[0]\n    angles = np.arctan2(coordinates[:, 1] - depot_y, coordinates[:, 0] - depot_x)\n\n    # Depot proximity\n    depot_distances = distance_matrix[0, :]\n    depot_proximity_i = np.tile(depot_distances, (n, 1))\n    depot_proximity_j = np.tile(depot_distances, (n, 1)).T\n    depot_proximity_factor = 1 / (depot_proximity_i + depot_proximity_j + 1e-9)\n\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                heuristic_value = 1 / normalized_distance[i, j]\n\n                # Demand penalty with continuous scaling\n                demand_ratio = (demands[i] + demands[j]) / capacity\n                demand_penalty = np.clip(demand_ratio, 0.1, 1.0)\n                if i != 0 and j != 0:\n                      heuristic_value /= demand_penalty\n\n                # Depot proximity weighting\n                depot_distance_i = distance_matrix[0, i] / max_distance\n                depot_distance_j = distance_matrix[0, j] / max_distance\n                proximity_weight = 1 - np.clip(depot_distance_i + depot_distance_j, 0, 0.9)  # Scale between 0.1 and 1.0\n                if i != 0 and j != 0:\n                    heuristic_value *= proximity_weight\n\n                # Angle difference penalty\n                angle_diff = abs(angles[i] - angles[j])\n                heuristic_value *= np.exp(-2 * angle_diff)\n\n                heuristic_matrix[i, j] = heuristic_value\n\n    return heuristic_matrix\n\n[Heuristics 4th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Combines distance, demand, angle, depot proximity, and demand density.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n    depot_coords = coordinates[0]\n    angles = np.arctan2(coordinates[:, 1] - depot_coords[1], coordinates[:, 0] - depot_coords[0])\n\n    # Demand density calculation (similar to v0)\n    demand_density = np.zeros(n)\n    for i in range(1, n):\n        nearby_demand = 0\n        for j in range(1, n):\n            if i != j and distance_matrix[i, j] < np.mean(distance_matrix):\n                nearby_demand += demands[j]\n        demand_density[i] = nearby_demand\n    max_demand_density = np.max(demand_density) if np.max(demand_density) > 0 else 1\n\n    #Center calculation\n    center_x = np.mean(coordinates[1:, 0])\n    center_y = np.mean(coordinates[1:, 1])\n    total_demand = np.sum(demands[1:])\n    demand_weighted_dist_to_depot = np.sum(demands[1:] * distance_matrix[0, 1:]) / total_demand if total_demand > 0 else 1e-6  # Avoid division by zero\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n\n            distance = distance_matrix[i, j]\n            dist_factor = 1 / (distance + 1e-6)\n\n            # Demand penalty (similar to v1, but smoother)\n            demand_penalty = 1.0 - np.clip((demands[i] + demands[j]) / (2 * capacity), 0, 0.7) #Smoother and combined\n\n            # Angular factor (v1)\n            angle_diff = abs(angles[i] - angles[j])\n            angular_factor = 1 / (angle_diff + 0.1)\n\n            # Depot proximity (v1, but modified)\n            depot_proximity = 1.0\n            if i == 0 or j == 0:\n                depot_proximity = 1.2  #Slightly less aggressive\n\n            #Demand Density Component (v0)\n            density_component = 1.0\n            if i != 0 and j != 0:\n                density_component = np.sqrt((demand_density[i] / max_demand_density) * (demand_density[j] / max_demand_density))\n\n            #Center Component(v0)\n            center_distance = (np.sqrt((coordinates[i, 0] - center_x)**2 + (coordinates[i, 1] - center_y)**2) +\n                               np.sqrt((coordinates[j, 0] - center_x)**2 + (coordinates[j, 1] - center_y)**2)) / 2\n            centrality_component = np.exp(-center_distance / demand_weighted_dist_to_depot if demand_weighted_dist_to_depot>0 else 1)\n\n            # Combined heuristic\n            heuristic_matrix[i, j] = (dist_factor * demand_penalty * angular_factor * depot_proximity * density_component * centrality_component)\n\n            #Sparsification\n            if i!=0 and j!=0 and (demands[i] + demands[j]) > 1.5 * capacity:\n                heuristic_matrix[i, j] = 0\n            if i!=0 and j!=0 and (demands[i] > capacity or demands[j] > capacity) :\n                heuristic_matrix[i, j] = 0\n\n            heuristic_matrix[i, j] = np.clip(heuristic_matrix[i, j], 0, 1e6)\n\n    return heuristic_matrix\n\n[Heuristics 5th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Combines distance, demand, angle, depot proximity, and demand density.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n    depot_coords = coordinates[0]\n    angles = np.arctan2(coordinates[:, 1] - depot_coords[1], coordinates[:, 0] - depot_coords[0])\n\n    # Demand density calculation (similar to v0)\n    demand_density = np.zeros(n)\n    for i in range(1, n):\n        nearby_demand = 0\n        for j in range(1, n):\n            if i != j and distance_matrix[i, j] < np.mean(distance_matrix):\n                nearby_demand += demands[j]\n        demand_density[i] = nearby_demand\n    max_demand_density = np.max(demand_density) if np.max(demand_density) > 0 else 1\n\n    #Center calculation\n    center_x = np.mean(coordinates[1:, 0])\n    center_y = np.mean(coordinates[1:, 1])\n    total_demand = np.sum(demands[1:])\n    demand_weighted_dist_to_depot = np.sum(demands[1:] * distance_matrix[0, 1:]) / total_demand if total_demand > 0 else 1e-6  # Avoid division by zero\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n\n            distance = distance_matrix[i, j]\n            dist_factor = 1 / (distance + 1e-6)\n\n            # Demand penalty (similar to v1, but smoother)\n            demand_penalty = 1.0 - np.clip((demands[i] + demands[j]) / (2 * capacity), 0, 0.7) #Smoother and combined\n\n            # Angular factor (v1)\n            angle_diff = abs(angles[i] - angles[j])\n            angular_factor = 1 / (angle_diff + 0.1)\n\n            # Depot proximity (v1, but modified)\n            depot_proximity = 1.0\n            if i == 0 or j == 0:\n                depot_proximity = 1.2  #Slightly less aggressive\n\n            #Demand Density Component (v0)\n            density_component = 1.0\n            if i != 0 and j != 0:\n                density_component = np.sqrt((demand_density[i] / max_demand_density) * (demand_density[j] / max_demand_density))\n\n            #Center Component(v0)\n            center_distance = (np.sqrt((coordinates[i, 0] - center_x)**2 + (coordinates[i, 1] - center_y)**2) +\n                               np.sqrt((coordinates[j, 0] - center_x)**2 + (coordinates[j, 1] - center_y)**2)) / 2\n            centrality_component = np.exp(-center_distance / demand_weighted_dist_to_depot if demand_weighted_dist_to_depot>0 else 1)\n\n            # Combined heuristic\n            heuristic_matrix[i, j] = (dist_factor * demand_penalty * angular_factor * depot_proximity * density_component * centrality_component)\n\n            #Sparsification\n            if i!=0 and j!=0 and (demands[i] + demands[j]) > 1.5 * capacity:\n                heuristic_matrix[i, j] = 0\n            if i!=0 and j!=0 and (demands[i] > capacity or demands[j] > capacity) :\n                heuristic_matrix[i, j] = 0\n\n            heuristic_matrix[i, j] = np.clip(heuristic_matrix[i, j], 0, 1e6)\n\n    return heuristic_matrix\n\n[Heuristics 6th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Combines centrality, capacity, angle, depot attraction, and demand considerations for CVRP,\n    with sparsification.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n    center_x = np.mean(coordinates[1:, 0])\n    center_y = np.mean(coordinates[1:, 1])\n    total_demand = np.sum(demands[1:])\n    demand_weighted_dist_to_depot = np.sum(demands[1:] * distance_matrix[0, 1:]) / total_demand if total_demand > 0 else 1\n\n    # Normalizing distances and demands\n    max_distance = np.max(distance_matrix)\n    normalized_distances = distance_matrix / (max_distance + 1e-6)\n\n    max_demand = np.max(demands)\n    normalized_demands = demands / (max_demand + 1e-6)\n\n    # Parameters for weighting different components\n    alpha = 0.5  # Distance importance\n    beta = 0.3   # Demand importance\n    gamma = 0.2  # Centrality importance\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n\n            # Distance component (normalized)\n            distance_component = 1 / (normalized_distances[i, j] + 1e-6)\n\n            # Demand component: discourage edges that overload the vehicle\n            demand_component = np.exp(-max(0, (demands[i] + demands[j] - capacity) / capacity))\n\n            # Centrality component (distance to the center)\n            center_distance_i = np.sqrt((coordinates[i, 0] - center_x)**2 + (coordinates[i, 1] - center_y)**2)\n            center_distance_j = np.sqrt((coordinates[j, 0] - center_x)**2 + (coordinates[j, 1] - center_y)**2)\n            avg_center_distance = (center_distance_i + center_distance_j) / 2\n            centrality_component = np.exp(-avg_center_distance / (demand_weighted_dist_to_depot + 1e-6))\n\n            # Depot attraction - pull customers closer to the depot earlier on\n            depot_attraction_i = 1 / (distance_matrix[0, i] + 1e-6) if i != 0 else 1.0\n            depot_attraction_j = 1 / (distance_matrix[0, j] + 1e-6) if j != 0 else 1.0\n            depot_component = (depot_attraction_i + depot_attraction_j) / 2\n\n            # Combined heuristic value\n            heuristic_value = (alpha * distance_component +\n                               beta * demand_component +\n                               gamma * centrality_component) * depot_component\n\n            heuristic_matrix[i, j] = heuristic_value\n\n    # Sparsification: zero out edges that are too long\n    distance_threshold = np.percentile(distance_matrix[distance_matrix > 0], 75) #keep top 75%\n    heuristic_matrix[distance_matrix > distance_threshold] = 0\n    heuristic_matrix[distance_matrix == 0] = 0\n\n\n    return heuristic_matrix\n\n[Heuristics 7th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Combines centrality, capacity, angle, depot attraction, and demand considerations for CVRP,\n    with sparsification.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n    center_x = np.mean(coordinates[1:, 0])\n    center_y = np.mean(coordinates[1:, 1])\n    total_demand = np.sum(demands[1:])\n    demand_weighted_dist_to_depot = np.sum(demands[1:] * distance_matrix[0, 1:]) / total_demand if total_demand > 0 else 1\n\n    # Normalizing distances and demands\n    max_distance = np.max(distance_matrix)\n    normalized_distances = distance_matrix / (max_distance + 1e-6)\n\n    max_demand = np.max(demands)\n    normalized_demands = demands / (max_demand + 1e-6)\n\n    # Parameters for weighting different components\n    alpha = 0.5  # Distance importance\n    beta = 0.3   # Demand importance\n    gamma = 0.2  # Centrality importance\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n\n            # Distance component (normalized)\n            distance_component = 1 / (normalized_distances[i, j] + 1e-6)\n\n            # Demand component: discourage edges that overload the vehicle\n            demand_component = np.exp(-max(0, (demands[i] + demands[j] - capacity) / capacity))\n\n            # Centrality component (distance to the center)\n            center_distance_i = np.sqrt((coordinates[i, 0] - center_x)**2 + (coordinates[i, 1] - center_y)**2)\n            center_distance_j = np.sqrt((coordinates[j, 0] - center_x)**2 + (coordinates[j, 1] - center_y)**2)\n            avg_center_distance = (center_distance_i + center_distance_j) / 2\n            centrality_component = np.exp(-avg_center_distance / (demand_weighted_dist_to_depot + 1e-6))\n\n            # Depot attraction - pull customers closer to the depot earlier on\n            depot_attraction_i = 1 / (distance_matrix[0, i] + 1e-6) if i != 0 else 1.0\n            depot_attraction_j = 1 / (distance_matrix[0, j] + 1e-6) if j != 0 else 1.0\n            depot_component = (depot_attraction_i + depot_attraction_j) / 2\n\n            # Combined heuristic value\n            heuristic_value = (alpha * distance_component +\n                               beta * demand_component +\n                               gamma * centrality_component) * depot_component\n\n            heuristic_matrix[i, j] = heuristic_value\n\n    # Sparsification: zero out edges that are too long\n    distance_threshold = np.percentile(distance_matrix[distance_matrix > 0], 75) #keep top 75%\n    heuristic_matrix[distance_matrix > distance_threshold] = 0\n    heuristic_matrix[distance_matrix == 0] = 0\n\n\n    return heuristic_matrix\n\n[Heuristics 8th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Combines centrality, capacity, angle, depot attraction, and demand considerations for CVRP,\n    with sparsification.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n    center_x = np.mean(coordinates[1:, 0])\n    center_y = np.mean(coordinates[1:, 1])\n    total_demand = np.sum(demands[1:])\n    demand_weighted_dist_to_depot = np.sum(demands[1:] * distance_matrix[0, 1:]) / total_demand if total_demand > 0 else 1\n\n    # Normalizing distances and demands\n    max_distance = np.max(distance_matrix)\n    normalized_distances = distance_matrix / (max_distance + 1e-6)\n\n    max_demand = np.max(demands)\n    normalized_demands = demands / (max_demand + 1e-6)\n\n    # Parameters for weighting different components\n    alpha = 0.5  # Distance importance\n    beta = 0.3   # Demand importance\n    gamma = 0.2  # Centrality importance\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n\n            # Distance component (normalized)\n            distance_component = 1 / (normalized_distances[i, j] + 1e-6)\n\n            # Demand component: discourage edges that overload the vehicle\n            demand_component = np.exp(-max(0, (demands[i] + demands[j] - capacity) / capacity))\n\n            # Centrality component (distance to the center)\n            center_distance_i = np.sqrt((coordinates[i, 0] - center_x)**2 + (coordinates[i, 1] - center_y)**2)\n            center_distance_j = np.sqrt((coordinates[j, 0] - center_x)**2 + (coordinates[j, 1] - center_y)**2)\n            avg_center_distance = (center_distance_i + center_distance_j) / 2\n            centrality_component = np.exp(-avg_center_distance / (demand_weighted_dist_to_depot + 1e-6))\n\n            # Depot attraction - pull customers closer to the depot earlier on\n            depot_attraction_i = 1 / (distance_matrix[0, i] + 1e-6) if i != 0 else 1.0\n            depot_attraction_j = 1 / (distance_matrix[0, j] + 1e-6) if j != 0 else 1.0\n            depot_component = (depot_attraction_i + depot_attraction_j) / 2\n\n            # Combined heuristic value\n            heuristic_value = (alpha * distance_component +\n                               beta * demand_component +\n                               gamma * centrality_component) * depot_component\n\n            heuristic_matrix[i, j] = heuristic_value\n\n    # Sparsification: zero out edges that are too long\n    distance_threshold = np.percentile(distance_matrix[distance_matrix > 0], 75) #keep top 75%\n    heuristic_matrix[distance_matrix > distance_threshold] = 0\n    heuristic_matrix[distance_matrix == 0] = 0\n\n\n    return heuristic_matrix\n\n[Heuristics 9th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Enhanced heuristic: Combines distance, savings, demand, and centrality.\"\"\"\n\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n\n    # Distance heuristic\n    distance_heuristic = 1 / (distance_matrix + 1e-6)\n\n    # Savings Heuristic (Clarke-Wright)\n    savings_matrix = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings_matrix[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings_matrix[j, i] = savings_matrix[i, j]\n    savings_matrix = savings_matrix / np.max(savings_matrix + 1e-6)\n\n    # Demand consideration\n    demand_penalty = np.zeros((n, n))\n    for i in range(n):\n        for j in range(n):\n            demand_penalty[i, j] = (demands[i] + demands[j])\n    demand_penalty = 1 / (demand_penalty + 1e-6)\n\n    # Centrality component\n    center_x = np.mean(coordinates[1:, 0])\n    center_y = np.mean(coordinates[1:, 1])\n    total_demand = np.sum(demands[1:])\n    demand_weighted_dist_to_depot = np.sum(demands[1:] * distance_matrix[0, 1:]) / total_demand if total_demand > 0 else 0\n    centrality_component = np.zeros((n,n))\n    for i in range(n):\n      for j in range(n):\n        center_distance = (np.sqrt((coordinates[i, 0] - center_x)**2 + (coordinates[i, 1] - center_y)**2) +\n                           np.sqrt((coordinates[j, 0] - center_x)**2 + (coordinates[j, 1] - center_y)**2)) / 2\n        centrality_component[i,j] = np.exp(-center_distance / demand_weighted_dist_to_depot if demand_weighted_dist_to_depot>0 else 1)\n\n\n    # Combine heuristics\n    heuristic_matrix = (0.4 * distance_heuristic + 0.3 * savings_matrix + 0.15 * demand_penalty + 0.15 * centrality_component)\n\n    # Ensure depot connections are preferred\n    for i in range(1, n):\n        heuristic_matrix[0, i] *= 1.1\n        heuristic_matrix[i, 0] *= 1.1\n\n    # Ensure no self-loops\n    for i in range(n):\n        heuristic_matrix[i, i] = 0\n\n    return heuristic_matrix\n\n[Heuristics 10th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Combines distance, demand, angle, and depot proximity with weighting.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n\n    # Normalize distance\n    max_distance = np.max(distance_matrix[distance_matrix != np.inf])\n    normalized_distance = distance_matrix / max_distance\n    normalized_distance = np.where(normalized_distance == 0, 1e-6, normalized_distance)\n\n    # Calculate angles\n    depot_x, depot_y = coordinates[0]\n    angles = np.arctan2(coordinates[:, 1] - depot_y, coordinates[:, 0] - depot_x)\n\n    # Parameters\n    distance_weight = 0.6\n    demand_weight = 0.2\n    depot_weight = 0.1\n    angle_weight = 0.1\n\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                heuristic_value = 0.0\n\n                # Distance component\n                heuristic_value += distance_weight * (1 / normalized_distance[i, j])\n\n                # Demand component\n                demand_penalty = 1.0\n                if demands[i] + demands[j] > capacity and i != 0 and j != 0:\n                    demand_penalty = 0.1\n                elif (demands[i] > capacity or demands[j] > capacity) and i != 0 and j != 0:\n                    demand_penalty = 0.01\n                heuristic_value += demand_weight * demand_penalty\n\n                # Depot proximity component\n                depot_distance_i = distance_matrix[0, i] / max_distance\n                depot_distance_j = distance_matrix[0, j] / max_distance\n                depot_proximity_penalty = 1.0\n                if i != 0 and j != 0:\n                    if depot_distance_i < 0.2 and depot_distance_j < 0.2:\n                        depot_proximity_penalty = 0.5\n                heuristic_value += depot_weight * depot_proximity_penalty\n\n                # Angle component\n                angle_diff = abs(angles[i] - angles[j])\n                angle_penalty = np.exp(-2 * angle_diff)\n                heuristic_value += angle_weight * angle_penalty\n\n                heuristic_matrix[i, j] = heuristic_value\n\n    return heuristic_matrix\n\n[Heuristics 11th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Combines distance, demand, savings, angle, depot proximity.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n\n    # Distance component\n    distance_component = 1 / (distance_matrix + 1e-9)\n\n    # Demand component\n    demand_matrix = np.zeros((n, n))\n    for i in range(n):\n        for j in range(n):\n            demand_matrix[i, j] = demands[i] + demands[j]\n    demand_component = np.clip(1 - (demand_matrix / capacity), 0, 1)\n\n    # Savings Heuristic (Clarke-Wright)\n    savings_matrix = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings_matrix[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings_matrix[j, i] = savings_matrix[i, j]\n    savings_matrix = savings_matrix / (np.max(savings_matrix + 1e-9))\n\n    # Depot proximity component\n    depot_distances = distance_matrix[0, :]\n    depot_proximity_matrix = np.zeros((n, n))\n    for i in range(n):\n        for j in range(n):\n            depot_proximity_matrix[i, j] = 1 / (depot_distances[i] + depot_distances[j] + 1e-9)\n    max_val = np.max(depot_proximity_matrix)\n    if max_val > 0:\n        depot_proximity_matrix = depot_proximity_matrix / max_val\n\n    # Angle component\n    angle_matrix = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                angles = []\n                for k in range(1, n):\n                    if k != i and k != j:\n                        v1 = coordinates[i] - coordinates[j]\n                        v2 = coordinates[k] - coordinates[i]\n                        dot_product = np.dot(v1, v2)\n                        magnitudes = np.linalg.norm(v1) * np.linalg.norm(v2)\n                        if magnitudes == 0:\n                            angle = 0\n                        else:\n                            angle = np.arccos(dot_product / magnitudes)\n                        angles.append(angle)\n                if len(angles) > 0:\n                    angle_matrix[i, j] = np.mean(np.degrees(angles) / 180.0)\n                else:\n                    angle_matrix[i, j] = 0.5  # Default if no other nodes\n    angle_component = 1 - angle_matrix # Smaller angle better\n\n    # Combined heuristic\n    heuristic_matrix = (\n        0.4 * distance_component +\n        0.2 * demand_component +\n        0.1 * savings_matrix +\n        0.1 * depot_proximity_matrix +\n        0.2 * angle_component\n    )\n\n    # Sparsification\n    threshold = np.mean(heuristic_matrix[heuristic_matrix > 0]) * 0.2\n    heuristic_matrix[heuristic_matrix < threshold] = 0\n\n    # Ensure no self-loops\n    for i in range(n):\n        heuristic_matrix[i, i] = 0\n\n    return heuristic_matrix\n\n[Heuristics 12th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Enhanced heuristics for CVRP combining distance, demand, angle, centrality, and depot attraction with normalization and weighting.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n\n    # Calculate center of mass and demand-weighted distance to depot\n    center_x = np.mean(coordinates[1:, 0])\n    center_y = np.mean(coordinates[1:, 1])\n    total_demand = np.sum(demands[1:])\n    demand_weighted_dist_to_depot = np.sum(demands[1:] * distance_matrix[0, 1:]) / total_demand if total_demand > 0 else np.mean(distance_matrix[0,1:])\n\n    # Normalizing constants.  Avoid division by zero\n    max_distance = np.max(distance_matrix) if np.max(distance_matrix) > 0 else 1\n    max_demand = np.max(demands) if np.max(demands) > 0 else 1\n    max_coord = np.max(np.abs(coordinates)) if np.max(np.abs(coordinates)) > 0 else 1\n\n    # Heuristic weights (tunable parameters)\n    distance_weight = 0.4\n    demand_weight = 0.3\n    angle_weight = 0.1\n    centrality_weight = 0.1\n    depot_attraction_weight = 0.1\n    capacity_penalty_weight = 0.2  #New penalty for violating capacity\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n\n            # Normalized distance component\n            distance = distance_matrix[i, j]\n            normalized_distance = distance / max_distance\n            distance_component = 1 / (normalized_distance + 0.01)  # Avoid division by zero\n\n            # Normalized demand component\n            demand_i = demands[i] / max_demand\n            demand_j = demands[j] / max_demand\n            demand_component = np.exp(-2 * (demand_i + demand_j))  # Prefer smaller demands\n\n            # Angle component (avoid sharp turns)\n            angle_component = 0.0\n            if i != 0 and j != 0:\n                angles = []\n                for k in range(n):\n                    if k != i and k != j:\n                        v1 = coordinates[i] - coordinates[j]\n                        v2 = coordinates[k] - coordinates[i]\n                        dot_product = np.dot(v1, v2)\n                        magnitudes = np.linalg.norm(v1) * np.linalg.norm(v2)\n                        if magnitudes == 0:\n                            angle = 0\n                        else:\n                            angle = np.arccos(dot_product / magnitudes)\n                        angles.append(angle)\n                if len(angles) > 0:\n                    angle_component = np.min(np.degrees(angles)) / 180.0\n                angle_component = np.clip(angle_component, 0.0, 1.0) # Ensure within [0, 1]\n            angle_component = 1 - angle_component # Smaller angle is better\n\n            # Centrality component (nodes closer to center are less preferred)\n            center_distance_i = np.sqrt((coordinates[i, 0] - center_x)**2 + (coordinates[i, 1] - center_y)**2) / max_coord\n            center_distance_j = np.sqrt((coordinates[j, 0] - center_x)**2 + (coordinates[j, 1] - center_y)**2) / max_coord\n            avg_center_distance = (center_distance_i + center_distance_j) / 2\n            centrality_component = np.exp(-avg_center_distance / (demand_weighted_dist_to_depot/max_distance) if demand_weighted_dist_to_depot>0 else 1)\n\n            # Depot attraction component (encourage returning to depot)\n            depot_attraction_i = np.exp(-distance_matrix[i, 0] / max_distance)\n            depot_attraction_j = np.exp(-distance_matrix[j, 0] / max_distance)\n            depot_component = (depot_attraction_i + depot_attraction_j) / 2\n\n            # Capacity penalty (discourage exceeding capacity) - Soft constraint\n            capacity_penalty = 0.0\n            if i != 0 and j != 0:\n               capacity_penalty = np.exp(max(0, (demands[i] + demands[j] - capacity) / capacity))\n\n            # Weighted sum of components\n            heuristic_matrix[i, j] = (\n                distance_weight * distance_component +\n                demand_weight * demand_component +\n                angle_weight * angle_component +\n                centrality_weight * centrality_component +\n                depot_attraction_weight * depot_component -\n                capacity_penalty_weight * capacity_penalty\n            )\n\n    # Sparsify the matrix (optional - can improve performance)\n    threshold = np.mean(heuristic_matrix) * 0.1  # Adjust threshold as needed\n    heuristic_matrix[heuristic_matrix < threshold] = 0\n\n    return heuristic_matrix\n\n[Heuristics 13th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Combines distance, demand, centrality, and depot attraction.\n    Sparsifies the matrix based on a dynamic threshold.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n    center_x = np.mean(coordinates[1:, 0])\n    center_y = np.mean(coordinates[1:, 1])\n    total_demand = np.sum(demands[1:])\n    demand_weighted_dist_to_depot = np.sum(demands[1:] * distance_matrix[0, 1:]) / total_demand if total_demand > 0 else 0\n\n    avg_dist_to_depot = np.mean(distance_matrix[0, 1:])\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n\n            distance = distance_matrix[i, j]\n            distance_component = np.exp(-distance / avg_dist_to_depot) if avg_dist_to_depot > 0 else 1.0\n\n            demand_component = 1.0\n            if i != 0 and j != 0 and demands[i] + demands[j] > capacity:\n                demand_component = 0.01\n\n            center_distance = (np.sqrt((coordinates[i, 0] - center_x)**2 + (coordinates[i, 1] - center_y)**2) +\n                               np.sqrt((coordinates[j, 0] - center_x)**2 + (coordinates[j, 1] - center_y)**2)) / 2\n            centrality_component = np.exp(-center_distance / demand_weighted_dist_to_depot) if demand_weighted_dist_to_depot > 0 else 1.0\n\n            depot_component = 1.0\n            if i!=0 and j!=0:\n                depot_attraction_i = np.exp(-distance_matrix[i, 0] / avg_dist_to_depot) if avg_dist_to_depot>0 else 1.0\n                depot_attraction_j = np.exp(-distance_matrix[j, 0] / avg_dist_to_depot) if avg_dist_to_depot>0 else 1.0\n                depot_component = (depot_attraction_i + depot_attraction_j) / 2\n\n            elif i==0:\n                depot_component = np.exp(-distance_matrix[j,0]/ avg_dist_to_depot) if avg_dist_to_depot>0 else 1.0\n            elif j==0:\n                 depot_component = np.exp(-distance_matrix[i,0]/ avg_dist_to_depot) if avg_dist_to_depot>0 else 1.0\n\n            heuristic_value = distance_component * demand_component * centrality_component * depot_component\n            heuristic_matrix[i, j] = heuristic_value\n\n    threshold = np.mean(heuristic_matrix[heuristic_matrix > 0]) * 0.2\n    heuristic_matrix[heuristic_matrix < threshold] = 0\n\n    return heuristic_matrix\n\n[Heuristics 14th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Combines distance, demand, centrality, and depot attraction.\n    Sparsifies the matrix based on a dynamic threshold.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n    center_x = np.mean(coordinates[1:, 0])\n    center_y = np.mean(coordinates[1:, 1])\n    total_demand = np.sum(demands[1:])\n    demand_weighted_dist_to_depot = np.sum(demands[1:] * distance_matrix[0, 1:]) / total_demand if total_demand > 0 else 0\n\n    avg_dist_to_depot = np.mean(distance_matrix[0, 1:])\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n\n            distance = distance_matrix[i, j]\n            distance_component = np.exp(-distance / avg_dist_to_depot) if avg_dist_to_depot > 0 else 1.0\n\n            demand_component = 1.0\n            if i != 0 and j != 0 and demands[i] + demands[j] > capacity:\n                demand_component = 0.01\n\n            center_distance = (np.sqrt((coordinates[i, 0] - center_x)**2 + (coordinates[i, 1] - center_y)**2) +\n                               np.sqrt((coordinates[j, 0] - center_x)**2 + (coordinates[j, 1] - center_y)**2)) / 2\n            centrality_component = np.exp(-center_distance / demand_weighted_dist_to_depot) if demand_weighted_dist_to_depot > 0 else 1.0\n\n            depot_component = 1.0\n            if i!=0 and j!=0:\n                depot_attraction_i = np.exp(-distance_matrix[i, 0] / avg_dist_to_depot) if avg_dist_to_depot>0 else 1.0\n                depot_attraction_j = np.exp(-distance_matrix[j, 0] / avg_dist_to_depot) if avg_dist_to_depot>0 else 1.0\n                depot_component = (depot_attraction_i + depot_attraction_j) / 2\n\n            elif i==0:\n                depot_component = np.exp(-distance_matrix[j,0]/ avg_dist_to_depot) if avg_dist_to_depot>0 else 1.0\n            elif j==0:\n                 depot_component = np.exp(-distance_matrix[i,0]/ avg_dist_to_depot) if avg_dist_to_depot>0 else 1.0\n\n            heuristic_value = distance_component * demand_component * centrality_component * depot_component\n            heuristic_matrix[i, j] = heuristic_value\n\n    threshold = np.mean(heuristic_matrix[heuristic_matrix > 0]) * 0.2\n    heuristic_matrix[heuristic_matrix < threshold] = 0\n\n    return heuristic_matrix\n\n[Heuristics 15th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Enhances CVRP heuristic by combining normalized distance, capacity, angle, centrality, depot attraction, and sparsification.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n\n    # Calculate center and characteristic distance\n    center_x = np.mean(coordinates[1:, 0])\n    center_y = np.mean(coordinates[1:, 1])\n    total_demand = np.sum(demands[1:])\n    demand_weighted_dist_to_depot = np.sum(demands[1:] * distance_matrix[0, 1:]) / total_demand if total_demand > 0 else 0\n\n    # Normalization factors to ensure features are on comparable scales.\n    max_distance = np.max(distance_matrix)\n    max_demand = np.max(demands)\n    max_coord = np.max(np.abs(coordinates))  # use max absolute value for centering calculation\n\n\n    # Define weights for each component.  Tunable parameters!\n    weight_distance = 0.4\n    weight_demand = 0.2\n    weight_angle = 0.1\n    weight_centrality = 0.15\n    weight_depot = 0.15\n\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n\n            # 1. Distance Component (Normalized)\n            distance = distance_matrix[i, j]\n            distance_component = 1 - (distance / max_distance)  # Higher is better\n\n\n            # 2. Demand Component (Considers combined demand relative to capacity)\n            demand_component = 1.0  # default\n            if i != 0 and j != 0:\n                 combined_demand = demands[i] + demands[j]\n                 demand_component = max(0.1, 1 - (combined_demand / capacity))  # Scale linearly. Never go to 0\n            # if demands[i] + demands[j] > capacity: # replaced by above\n            #     demand_component = 0.1\n\n\n            # 3. Angle Component (Smaller angle = higher priority). More robust.\n            angle_component = 0.0\n            if i != 0 and j != 0:\n                angles = []\n                for k in range(n):\n                    if k != i and k != j:\n                        v1 = coordinates[i] - coordinates[j]\n                        v2 = coordinates[k] - coordinates[i]\n                        dot_product = np.dot(v1, v2)\n                        magnitudes = np.linalg.norm(v1) * np.linalg.norm(v2)\n                        if magnitudes == 0:\n                            angle = 0\n                        else:\n                            angle = np.arccos(dot_product / magnitudes)\n                        angles.append(angle)\n\n                if len(angles) > 0:\n                     angle_component = min(np.degrees(angles) / 180.0) # Normalize between 0 and 1\n            angle_component = 1 - angle_component # Invert, smaller angle better.\n\n            # 4. Centrality Component (Nodes closer to center are more attractive)\n            center_distance_i = np.sqrt((coordinates[i, 0] - center_x)**2 + (coordinates[i, 1] - center_y)**2)\n            center_distance_j = np.sqrt((coordinates[j, 0] - center_x)**2 + (coordinates[j, 1] - center_y)**2)\n            avg_center_distance = (center_distance_i + center_distance_j) / 2\n            centrality_component = np.exp(-avg_center_distance / (demand_weighted_dist_to_depot + 1e-6))\n\n\n            # 5. Depot Attraction (Attract nodes back to depot based on load)\n            depot_component = 1.0\n            if i != 0:  # Only penalize non-depot nodes.\n                load_before_depot = demands[i]  # Demand of node 'i'\n                depot_component = (1 + np.exp(-load_before_depot / (capacity + 1e-6))) / 2  # Inverted, higher is better to return\n                # depot_component = (1 + np.tanh(-load_before_depot / capacity)) / 2 # alternative\n\n\n            # Combine the components using weighted sum.  Crucial step.\n            heuristic_matrix[i, j] = (\n                weight_distance * distance_component +\n                weight_demand * demand_component +\n                weight_angle * angle_component +\n                weight_centrality * centrality_component +\n                weight_depot * depot_component\n            )\n\n\n    # Sparsify the matrix.  Zero out very low values, reducing the search space.\n    threshold = np.mean(heuristic_matrix) * 0.1  # Dynamic threshold\n    heuristic_matrix[heuristic_matrix < threshold] = 0\n\n\n    return heuristic_matrix\n\n[Heuristics 16th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Combines distance, demand, angle, and depot proximity with smooth weighting.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n\n    # Normalize distance\n    max_distance = np.max(distance_matrix[distance_matrix != np.inf])\n    normalized_distance = distance_matrix / max_distance if max_distance > 0 else np.ones_like(distance_matrix) # Avoid division by zero\n    normalized_distance = np.where(normalized_distance == 0, 1e-6, normalized_distance)\n\n    # Calculate angles relative to depot\n    depot_x, depot_y = coordinates[0]\n    angles = np.arctan2(coordinates[:, 1] - depot_y, coordinates[:, 0] - depot_x)\n\n    # Demand density component\n    total_demand = np.sum(demands[1:])\n    demand_weighted_dist_to_depot = np.sum(demands[1:] * distance_matrix[0, 1:]) / total_demand if total_demand > 0 else np.mean(distance_matrix[0,1:])  # Avoid division by zero\n\n    demand_density = np.zeros(n)\n    for i in range(1, n):  # Skip depot\n        nearby_demand = 0\n        for j in range(1, n):\n            if i != j and distance_matrix[i, j] < demand_weighted_dist_to_depot:  # Check reasonable distance\n                nearby_demand += demands[j]\n        demand_density[i] = nearby_demand\n\n    max_demand_density = np.max(demand_density) if np.max(demand_density) > 0 else 1 # Avoid division by zero\n\n\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                heuristic_value = 1 / normalized_distance[i, j]\n\n                # Demand penalty with smooth weighting\n                demand_penalty = 1.0\n                if i != 0 and j != 0:\n                    excess_demand = max(0, demands[i] + demands[j] - capacity)\n                    demand_penalty = np.exp(-excess_demand / capacity) #Smooth penalty\n\n                heuristic_value *= demand_penalty\n\n                # Depot proximity with smooth weighting\n                depot_distance_i = distance_matrix[0, i] / max_distance\n                depot_distance_j = distance_matrix[0, j] / max_distance\n                depot_proximity = np.exp(-5 * (depot_distance_i + depot_distance_j)) #Smooth\n\n                if i != 0 and j != 0:\n                    heuristic_value *= depot_proximity\n\n                # Angle difference penalty\n                angle_diff = abs(angles[i] - angles[j])\n                heuristic_value *= np.exp(-2 * angle_diff)\n\n                # Demand density component\n\n                density_component = 1.0\n                if i != 0 and j != 0:\n                    density_component = np.sqrt((demand_density[i] / max_demand_density) * (demand_density[j] / max_demand_density))\n\n                heuristic_value*= density_component\n                heuristic_matrix[i, j] = heuristic_value\n\n    return heuristic_matrix\n\n[Heuristics 17th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Combines distance, demand, angle, and depot proximity with smooth weighting.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n\n    # Normalize distance\n    max_distance = np.max(distance_matrix[distance_matrix != np.inf])\n    normalized_distance = distance_matrix / max_distance if max_distance > 0 else np.ones_like(distance_matrix) # Avoid division by zero\n    normalized_distance = np.where(normalized_distance == 0, 1e-6, normalized_distance)\n\n    # Calculate angles relative to depot\n    depot_x, depot_y = coordinates[0]\n    angles = np.arctan2(coordinates[:, 1] - depot_y, coordinates[:, 0] - depot_x)\n\n    # Demand density component\n    total_demand = np.sum(demands[1:])\n    demand_weighted_dist_to_depot = np.sum(demands[1:] * distance_matrix[0, 1:]) / total_demand if total_demand > 0 else np.mean(distance_matrix[0,1:])  # Avoid division by zero\n\n    demand_density = np.zeros(n)\n    for i in range(1, n):  # Skip depot\n        nearby_demand = 0\n        for j in range(1, n):\n            if i != j and distance_matrix[i, j] < demand_weighted_dist_to_depot:  # Check reasonable distance\n                nearby_demand += demands[j]\n        demand_density[i] = nearby_demand\n\n    max_demand_density = np.max(demand_density) if np.max(demand_density) > 0 else 1 # Avoid division by zero\n\n\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                heuristic_value = 1 / normalized_distance[i, j]\n\n                # Demand penalty with smooth weighting\n                demand_penalty = 1.0\n                if i != 0 and j != 0:\n                    excess_demand = max(0, demands[i] + demands[j] - capacity)\n                    demand_penalty = np.exp(-excess_demand / capacity) #Smooth penalty\n\n                heuristic_value *= demand_penalty\n\n                # Depot proximity with smooth weighting\n                depot_distance_i = distance_matrix[0, i] / max_distance\n                depot_distance_j = distance_matrix[0, j] / max_distance\n                depot_proximity = np.exp(-5 * (depot_distance_i + depot_distance_j)) #Smooth\n\n                if i != 0 and j != 0:\n                    heuristic_value *= depot_proximity\n\n                # Angle difference penalty\n                angle_diff = abs(angles[i] - angles[j])\n                heuristic_value *= np.exp(-2 * angle_diff)\n\n                # Demand density component\n\n                density_component = 1.0\n                if i != 0 and j != 0:\n                    density_component = np.sqrt((demand_density[i] / max_demand_density) * (demand_density[j] / max_demand_density))\n\n                heuristic_value*= density_component\n                heuristic_matrix[i, j] = heuristic_value\n\n    return heuristic_matrix\n\n[Heuristics 18th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Combines distance, demand, angle, and depot proximity with smooth weighting.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n\n    # Normalize distance\n    max_distance = np.max(distance_matrix[distance_matrix != np.inf])\n    normalized_distance = distance_matrix / max_distance if max_distance > 0 else np.ones_like(distance_matrix) # Avoid division by zero\n    normalized_distance = np.where(normalized_distance == 0, 1e-6, normalized_distance)\n\n    # Calculate angles relative to depot\n    depot_x, depot_y = coordinates[0]\n    angles = np.arctan2(coordinates[:, 1] - depot_y, coordinates[:, 0] - depot_x)\n\n    # Demand density component\n    total_demand = np.sum(demands[1:])\n    demand_weighted_dist_to_depot = np.sum(demands[1:] * distance_matrix[0, 1:]) / total_demand if total_demand > 0 else np.mean(distance_matrix[0,1:])  # Avoid division by zero\n\n    demand_density = np.zeros(n)\n    for i in range(1, n):  # Skip depot\n        nearby_demand = 0\n        for j in range(1, n):\n            if i != j and distance_matrix[i, j] < demand_weighted_dist_to_depot:  # Check reasonable distance\n                nearby_demand += demands[j]\n        demand_density[i] = nearby_demand\n\n    max_demand_density = np.max(demand_density) if np.max(demand_density) > 0 else 1 # Avoid division by zero\n\n\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                heuristic_value = 1 / normalized_distance[i, j]\n\n                # Demand penalty with smooth weighting\n                demand_penalty = 1.0\n                if i != 0 and j != 0:\n                    excess_demand = max(0, demands[i] + demands[j] - capacity)\n                    demand_penalty = np.exp(-excess_demand / capacity) #Smooth penalty\n\n                heuristic_value *= demand_penalty\n\n                # Depot proximity with smooth weighting\n                depot_distance_i = distance_matrix[0, i] / max_distance\n                depot_distance_j = distance_matrix[0, j] / max_distance\n                depot_proximity = np.exp(-5 * (depot_distance_i + depot_distance_j)) #Smooth\n\n                if i != 0 and j != 0:\n                    heuristic_value *= depot_proximity\n\n                # Angle difference penalty\n                angle_diff = abs(angles[i] - angles[j])\n                heuristic_value *= np.exp(-2 * angle_diff)\n\n                # Demand density component\n\n                density_component = 1.0\n                if i != 0 and j != 0:\n                    density_component = np.sqrt((demand_density[i] / max_demand_density) * (demand_density[j] / max_demand_density))\n\n                heuristic_value*= density_component\n                heuristic_matrix[i, j] = heuristic_value\n\n    return heuristic_matrix\n\n[Heuristics 19th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Combines distance, demand, angle, and depot proximity with smooth weighting.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n\n    # Normalize distance\n    max_distance = np.max(distance_matrix[distance_matrix != np.inf])\n    normalized_distance = distance_matrix / max_distance if max_distance > 0 else np.ones_like(distance_matrix) # Avoid division by zero\n    normalized_distance = np.where(normalized_distance == 0, 1e-6, normalized_distance)\n\n    # Calculate angles relative to depot\n    depot_x, depot_y = coordinates[0]\n    angles = np.arctan2(coordinates[:, 1] - depot_y, coordinates[:, 0] - depot_x)\n\n    # Demand density component\n    total_demand = np.sum(demands[1:])\n    demand_weighted_dist_to_depot = np.sum(demands[1:] * distance_matrix[0, 1:]) / total_demand if total_demand > 0 else np.mean(distance_matrix[0,1:])  # Avoid division by zero\n\n    demand_density = np.zeros(n)\n    for i in range(1, n):  # Skip depot\n        nearby_demand = 0\n        for j in range(1, n):\n            if i != j and distance_matrix[i, j] < demand_weighted_dist_to_depot:  # Check reasonable distance\n                nearby_demand += demands[j]\n        demand_density[i] = nearby_demand\n\n    max_demand_density = np.max(demand_density) if np.max(demand_density) > 0 else 1 # Avoid division by zero\n\n\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                heuristic_value = 1 / normalized_distance[i, j]\n\n                # Demand penalty with smooth weighting\n                demand_penalty = 1.0\n                if i != 0 and j != 0:\n                    excess_demand = max(0, demands[i] + demands[j] - capacity)\n                    demand_penalty = np.exp(-excess_demand / capacity) #Smooth penalty\n\n                heuristic_value *= demand_penalty\n\n                # Depot proximity with smooth weighting\n                depot_distance_i = distance_matrix[0, i] / max_distance\n                depot_distance_j = distance_matrix[0, j] / max_distance\n                depot_proximity = np.exp(-5 * (depot_distance_i + depot_distance_j)) #Smooth\n\n                if i != 0 and j != 0:\n                    heuristic_value *= depot_proximity\n\n                # Angle difference penalty\n                angle_diff = abs(angles[i] - angles[j])\n                heuristic_value *= np.exp(-2 * angle_diff)\n\n                # Demand density component\n\n                density_component = 1.0\n                if i != 0 and j != 0:\n                    density_component = np.sqrt((demand_density[i] / max_demand_density) * (demand_density[j] / max_demand_density))\n\n                heuristic_value*= density_component\n                heuristic_matrix[i, j] = heuristic_value\n\n    return heuristic_matrix\n\n[Heuristics 20th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Improved heuristics for CVRP, combining distance, demand, angle, centrality, and depot attraction, with sparsification.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n\n    # Calculate centrality components\n    center_x = np.mean(coordinates[1:, 0])\n    center_y = np.mean(coordinates[1:, 1])\n    total_demand = np.sum(demands[1:])\n    demand_weighted_dist_to_depot = np.sum(demands[1:] * distance_matrix[0, 1:]) / total_demand if total_demand > 0 else 1\n\n    # Normalizing factor for distance\n    max_distance = np.max(distance_matrix)\n    if max_distance == 0:\n        max_distance = 1\n\n    # Heuristic parameters (tunable)\n    alpha = 1.0  # Distance importance\n    beta = 1.5  # Demand importance\n    gamma = 0.7  # Angle importance\n    delta = 0.8  # Centrality importance\n    epsilon = 1.2 # Depot attraction importance\n    zeta = 0.5 #sparsification\n    eta = 0.9 # load\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n\n            distance = distance_matrix[i, j]\n            normalized_distance = distance / max_distance\n            distance_component = 1 / (normalized_distance + 1e-6)\n\n            demand_component = np.exp(-beta * max(0, (demands[i] + demands[j] - capacity) / capacity))\n\n            angle_component = 0.0\n            if i != 0 and j != 0:\n                angles = []\n                for k in range(n):\n                    if k != i and k != j:\n                        v1 = coordinates[i] - coordinates[j]\n                        v2 = coordinates[k] - coordinates[i]\n                        dot_product = np.dot(v1, v2)\n                        magnitudes = np.linalg.norm(v1) * np.linalg.norm(v2)\n                        if magnitudes == 0:\n                            angle = 0\n                        else:\n                            angle = np.arccos(dot_product / magnitudes)\n                        angles.append(angle)\n                if len(angles) > 0:\n                    angle_component = np.mean(np.degrees(angles) / 180.0)  # Using mean angle\n\n            center_distance = (np.sqrt((coordinates[i, 0] - center_x)**2 + (coordinates[i, 1] - center_y)**2) +\n                               np.sqrt((coordinates[j, 0] - center_x)**2 + (coordinates[j, 1] - center_y)**2)) / 2\n            centrality_component = np.exp(-delta * center_distance / demand_weighted_dist_to_depot)\n\n            depot_component = 1.0\n            if i != 0:\n                load_before_depot = demands[i]\n                depot_component = np.tanh(epsilon * load_before_depot / capacity) #tanh for smoother transitions\n\n            heuristic_value = (alpha * distance_component *\n                               demand_component *\n                               (1 - gamma * angle_component) *\n                               centrality_component *\n                               depot_component)\n\n            #Sparsification\n            if heuristic_value < zeta * np.mean(distance_matrix) / (distance+1e-9):\n                heuristic_matrix[i, j] = 0\n            else:\n                heuristic_matrix[i, j] = heuristic_value\n\n    return heuristic_matrix\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}