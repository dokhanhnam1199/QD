```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristic function for CVRP based on distance, demand, and node proximity to depot.

    Args:
        distance_matrix (np.ndarray): Distance matrix (n x n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (n x 2).
        demands (np.ndarray): Customer demands (n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators for each edge (n x n).
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Heuristic based on distance (shorter distances are preferred)
    distance_heuristic = 1 / (distance_matrix + 1e-6)  # Adding a small value to avoid division by zero

    # Heuristic based on demand and distance to depot: penalize edges connecting
    # a node with high demand far from the depot to another node.
    depot_distances = distance_matrix[0, :]
    demand_penalty = np.zeros((n,n))
    for i in range(n):
      for j in range(n):
        demand_penalty[i,j] = (demands[i] * depot_distances[i] + demands[j] * depot_distances[j])
    demand_penalty = 1/(demand_penalty+1e-6)

    # Heuristic based on angle from depot. Nodes further away angularly from the depot
    #  should be connected later if possible to increase density around the depot
    # which helps later on.
    depot_x, depot_y = coordinates[0, 0], coordinates[0, 1]
    angles = np.zeros(n)
    for i in range(n):
        if i != 0:
            dx = coordinates[i, 0] - depot_x
            dy = coordinates[i, 1] - depot_y
            angles[i] = np.arctan2(dy, dx)

    angle_diff_matrix = np.zeros((n,n))
    for i in range(n):
      for j in range(n):
          angle_diff_matrix[i,j] = abs(angles[i]-angles[j])

    angle_diff_penalty = 1/(angle_diff_matrix+1e-6)


    heuristic_matrix = (0.6 * distance_heuristic + 0.2 * demand_penalty + 0.2 * angle_diff_penalty)

    # Ensure depot connections are always relatively preferred, crucial for feasibility.
    for i in range(1, n):
        heuristic_matrix[0, i] *= 1.2 # Encourage returning to depot, or expanding from it.
        heuristic_matrix[i, 0] *= 1.2

    return heuristic_matrix
```
