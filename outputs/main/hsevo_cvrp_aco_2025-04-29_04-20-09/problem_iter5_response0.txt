```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """Combines distance, demand, angle, and depot proximity with weighting."""
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Normalize distance
    max_distance = np.max(distance_matrix[distance_matrix != np.inf])
    normalized_distance = distance_matrix / max_distance
    normalized_distance = np.where(normalized_distance == 0, 1e-6, normalized_distance)

    # Calculate angles
    depot_x, depot_y = coordinates[0]
    angles = np.arctan2(coordinates[:, 1] - depot_y, coordinates[:, 0] - depot_x)

    # Parameters
    distance_weight = 0.6
    demand_weight = 0.2
    depot_weight = 0.1
    angle_weight = 0.1

    for i in range(n):
        for j in range(n):
            if i != j:
                heuristic_value = 0.0

                # Distance component
                heuristic_value += distance_weight * (1 / normalized_distance[i, j])

                # Demand component
                demand_penalty = 1.0
                if demands[i] + demands[j] > capacity and i != 0 and j != 0:
                    demand_penalty = 0.1
                elif (demands[i] > capacity or demands[j] > capacity) and i != 0 and j != 0:
                    demand_penalty = 0.01
                heuristic_value += demand_weight * demand_penalty

                # Depot proximity component
                depot_distance_i = distance_matrix[0, i] / max_distance
                depot_distance_j = distance_matrix[0, j] / max_distance
                depot_proximity_penalty = 1.0
                if i != 0 and j != 0:
                    if depot_distance_i < 0.2 and depot_distance_j < 0.2:
                        depot_proximity_penalty = 0.5
                heuristic_value += depot_weight * depot_proximity_penalty

                # Angle component
                angle_diff = abs(angles[i] - angles[j])
                angle_penalty = np.exp(-2 * angle_diff)
                heuristic_value += angle_weight * angle_penalty

                heuristic_matrix[i, j] = heuristic_value

    return heuristic_matrix
```
