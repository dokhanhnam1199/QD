```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics for Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.

    This version incorporates several factors to estimate the desirability of each edge:
    - Distance: Shorter distances are preferred.
    - Demand Compatibility: Edges connecting nodes with combined demands less than the capacity are favored.
    - Closeness to Depot: Edges connecting nodes far from the depot are penalized.
    - Angle to Depot: Encourages connections that form 'rounder' routes (avoiding long, thin chains).

    Args:
        distance_matrix (np.ndarray): Distance matrix between nodes (n x n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (n x 2).
        demands (np.ndarray): Customer demands (n). Depot demand is assumed to be 0.
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (n x n).
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Normalize distance to be in [0, 1]
    max_distance = np.max(distance_matrix[distance_matrix != np.inf])  # Avoid inf values
    normalized_distance = distance_matrix / max_distance

    # Adjustments for avoiding division by zero and inf values.
    normalized_distance = np.where(normalized_distance == 0, 1e-6, normalized_distance)

    # Calculate angles between nodes and the depot.
    depot_x, depot_y = coordinates[0]
    angles = np.arctan2(coordinates[:, 1] - depot_y, coordinates[:, 0] - depot_x)

    for i in range(n):
        for j in range(n):
            if i != j:
                # Base heuristic: inverse of distance
                heuristic_value = 1 / normalized_distance[i, j]

                # Demand compatibility: Penalize edges where combined demand exceeds capacity.
                if demands[i] + demands[j] > capacity and i != 0 and j != 0: #Except for going to depot
                     heuristic_value *= 0.1  #Strong penalty
                elif (demands[i] > capacity or demands[j] > capacity) and i != 0 and j!=0:
                     heuristic_value *= 0.01


                # Closeness to depot: Nodes far from the depot should be prioritized
                #Penalize if both nodes are close to the depot

                depot_distance_i = distance_matrix[0, i] / max_distance
                depot_distance_j = distance_matrix[0, j] / max_distance
                if i != 0 and j != 0:
                     if depot_distance_i < 0.2 and depot_distance_j < 0.2:
                          heuristic_value *= 0.5


                # Angle difference penalty. Avoids overly 'thin' routes.
                angle_diff = abs(angles[i] - angles[j])
                heuristic_value *= np.exp(-2 * angle_diff)  # Exponential penalty
                heuristic_matrix[i, j] = heuristic_value

    return heuristic_matrix
```
