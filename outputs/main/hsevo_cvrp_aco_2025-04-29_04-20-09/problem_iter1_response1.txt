```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristic function for Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.
    Combines distance, demand, and node proximity to depot to create edge desirability scores.

    Args:
        distance_matrix (np.ndarray): Distance matrix (n x n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (n x 2).
        demands (np.ndarray): Customer demands (n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Edge desirability scores (n x n).  Higher score indicates more promising edge.
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)

    # Constants to tune the influence of different factors.  Experimentation is key!
    distance_weight = 1.0
    demand_weight = 0.5
    depot_proximity_weight = 0.8  # Adjusted for stronger impact

    #  Handle division by zero: Add a small epsilon to distances
    epsilon = 1e-6  # Small value to avoid division by zero

    for i in range(n):
        for j in range(n):
            if i != j:
                # Prioritize shorter distances (basic principle)
                distance_score = distance_weight / (distance_matrix[i, j] + epsilon)

                # Penalize connecting nodes with very high combined demand *if* neither is the depot.
                # Helps avoid immediately overloading vehicles.  Less strict on depot connections.
                demand_penalty = 0.0
                if i != 0 and j != 0: #Neither i nor j is the depot
                    combined_demand = demands[i] + demands[j]
                    demand_penalty = (combined_demand / (2*capacity)) ** 2 if combined_demand > capacity else 0.0
                    #Squaring the ratio means that if the combined demand far exceeds the capacity, demand_penalty becomes very significant

                # Incentivize connections closer to the depot. Prioritize those furthest away
                # Node's proximity to the depot affects desirability of *all* edges connected to it.
                # Higher values indicate more immediate need to serve that node
                depot_proximity_i = distance_matrix[i, 0]
                depot_proximity_j = distance_matrix[j, 0]

                depot_proximity_score = depot_proximity_weight * (1 / (0.5*(depot_proximity_i + depot_proximity_j) + epsilon))

                # Combine the scores - careful weighing is essential.  Subtract the penalty
                heuristics[i, j] = distance_score + depot_proximity_score - demand_weight * demand_penalty
            else:
                heuristics[i, j] = 0.0  # No self-loops

    return heuristics
```
