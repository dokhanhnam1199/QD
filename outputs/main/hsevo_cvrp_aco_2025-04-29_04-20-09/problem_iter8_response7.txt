```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """Combines normalized distance, demand, angle, centrality, depot proximity for CVRP."""
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix)

    # Normalize distances
    max_distance = np.max(distance_matrix)
    normalized_distances = distance_matrix / (max_distance + 1e-6)

    # Calculate center of mass
    center_x = np.mean(coordinates[1:, 0])
    center_y = np.mean(coordinates[1:, 1])

    # Weight components
    alpha = 0.4  # Distance importance
    beta = 0.3  # Demand importance
    gamma = 0.2 # Angle importance
    delta = 0.1 # Centrality importance

    for i in range(n):
        for j in range(n):
            if i == j:
                continue

            # Distance component
            distance_component = 1 / (normalized_distances[i, j] + 1e-6)

            # Demand component: discourage edges exceeding capacity
            demand_component = np.exp(-max(0, (demands[i] + demands[j] - capacity) / capacity))

            # Angle component
            angles = []
            for k in range(1, n):  # Iterate through customers
                if k != i and k != j:
                    v1 = coordinates[i] - coordinates[j]
                    v2 = coordinates[k] - coordinates[i]
                    dot_product = np.dot(v1, v2)
                    magnitudes = np.linalg.norm(v1) * np.linalg.norm(v2)
                    if magnitudes == 0:
                        angle = 0
                    else:
                        angle = np.arccos(dot_product / magnitudes)
                    angles.append(angle)

            angle_component = 1.0
            if angles:
                angle_component = min(np.degrees(angles) / 180.0)

            # Centrality component
            center_distance_i = np.sqrt((coordinates[i, 0] - center_x)**2 + (coordinates[i, 1] - center_y)**2)
            center_distance_j = np.sqrt((coordinates[j, 0] - center_x)**2 + (coordinates[j, 1] - center_y)**2)
            avg_center_distance = (center_distance_i + center_distance_j) / 2
            total_demand = np.sum(demands[1:])
            demand_weighted_dist_to_depot = np.sum(demands[1:] * distance_matrix[0, 1:]) / total_demand if total_demand > 0 else 1
            centrality_component = np.exp(-avg_center_distance / (demand_weighted_dist_to_depot + 1e-6))

            # Depot attraction
            depot_attraction_i = 1 / (distance_matrix[0, i] + 1e-6) if i != 0 else 1.0
            depot_attraction_j = 1 / (distance_matrix[0, j] + 1e-6) if j != 0 else 1.0
            depot_component = (depot_attraction_i + depot_attraction_j) / 2

            # Combine components
            heuristic_value = (alpha * distance_component +
                               beta * demand_component +
                               gamma * (1-angle_component) +
                               delta * centrality_component) * depot_component

            heuristic_matrix[i, j] = heuristic_value

    # Sparsification
    distance_threshold = np.percentile(distance_matrix[distance_matrix > 0], 75)
    heuristic_matrix[distance_matrix > distance_threshold] = 0
    heuristic_matrix[distance_matrix == 0] = 0

    return heuristic_matrix
```
