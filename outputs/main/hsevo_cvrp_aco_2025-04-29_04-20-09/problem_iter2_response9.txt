```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """Combines distance, demand, angle, and depot proximity for CVRP."""
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))
    depot_distances = distance_matrix[0, :]
    normalized_demands = demands / np.max(demands) if np.max(demands) > 0 else demands # Prevent divide by zero
    normalized_depot_distances = depot_distances / np.max(depot_distances)


    for i in range(n):
        for j in range(n):
            if i == j:
                heuristic_matrix[i, j] = 0
                continue
            if distance_matrix[i, j] == 0:
                heuristic_matrix[i, j] = 0
                continue

            # Distance component (shorter distance is better)
            distance_heuristic = 1 / (distance_matrix[i, j] + 1e-9)

            # Demand component (lower demand is generally better)
            demand_heuristic = 1 - (normalized_demands[i] + normalized_demands[j]) / 2
            demand_heuristic = max(demand_heuristic, 0.01)

            # Angle component (smaller angles are better)
            if i != 0:
                vector_depot = coordinates[0] - coordinates[i]
                vector_j = coordinates[j] - coordinates[i]

                norm_depot = np.linalg.norm(vector_depot)
                norm_j = np.linalg.norm(vector_j)
                if norm_depot == 0 or norm_j == 0:
                    angle = 0
                else:
                    vector_depot = vector_depot / norm_depot
                    vector_j = vector_j / norm_j

                    dot_product = np.dot(vector_depot, vector_j)
                    angle = np.arccos(np.clip(dot_product, -1.0, 1.0))

                angle_heuristic = 1.0 -  angle / np.pi
                angle_heuristic = max(angle_heuristic, 0.01)
            else:
                angle_heuristic = 1.0

            # Depot proximity component
            depot_proximity_heuristic = 1 - (normalized_depot_distances[i] + normalized_depot_distances[j]) / 2
            depot_proximity_heuristic = max(depot_proximity_heuristic,0.01)

            heuristic_matrix[i, j] = (
                distance_heuristic * demand_heuristic * angle_heuristic * depot_proximity_heuristic
            )

    return heuristic_matrix
```
