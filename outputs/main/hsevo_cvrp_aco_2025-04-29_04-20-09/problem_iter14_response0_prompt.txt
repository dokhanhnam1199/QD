{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a heuristics function for Solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling. CVRP requires finding the shortest path that visits all given nodes and returns to the starting node. Each node has a demand and each vehicle has a capacity. The total demand of the nodes visited by a vehicle cannot exceed the vehicle capacity. When the total demand exceeds the vehicle capacity, the vehicle must return to the starting node.\nThe `heuristics` function takes as input a distance matrix (shape: n by n), Euclidean coordinates of nodes (shape: n by 2), a vector of customer demands (shape: n), and the integer capacity of vehicle capacity. It returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the distance_matrix. The depot node is indexed by 0.\n\n\n### Better code\ndef heuristics_v0(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n\n    \"\"\"Combines adaptive distance, demand, centrality, depot attraction, and angle.\n    Sparsifies based on a dynamic threshold.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n    center_x = np.mean(coordinates[1:, 0])\n    center_y = np.mean(coordinates[1:, 1])\n    total_demand = np.sum(demands[1:])\n    demand_weighted_dist_to_depot = np.sum(demands[1:] * distance_matrix[0, 1:]) / total_demand if total_demand > 0 else np.mean(distance_matrix[0,1:])\n\n    avg_dist_to_depot = np.mean(distance_matrix[0, 1:])\n\n    depot_x, depot_y = coordinates[0]\n    angles = np.arctan2(coordinates[:, 1] - depot_y, coordinates[:, 0] - depot_x)\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n\n            distance = distance_matrix[i, j]\n            distance_component = np.exp(-distance / avg_dist_to_depot) if avg_dist_to_depot > 0 else 1.0\n\n            demand_component = 1.0\n            if i != 0 and j != 0 and demands[i] + demands[j] > capacity:\n                demand_component = 0.01\n\n            center_distance = (np.sqrt((coordinates[i, 0] - center_x)**2 + (coordinates[i, 1] - center_y)**2) +\n                               np.sqrt((coordinates[j, 0] - center_x)**2 + (coordinates[j, 1] - center_y)**2)) / 2\n            centrality_component = np.exp(-center_distance / demand_weighted_dist_to_depot) if demand_weighted_dist_to_depot > 0 else 1.0\n\n            depot_component = 1.0\n            if i!=0 and j!=0:\n                depot_attraction_i = np.exp(-distance_matrix[i, 0] / avg_dist_to_depot) if avg_dist_to_depot>0 else 1.0\n                depot_attraction_j = np.exp(-distance_matrix[j, 0] / avg_dist_to_depot) if avg_dist_to_depot>0 else 1.0\n                depot_component = (depot_attraction_i + depot_attraction_j) / 2\n\n            elif i==0:\n                depot_component = np.exp(-distance_matrix[j,0]/ avg_dist_to_depot) if avg_dist_to_depot>0 else 1.0\n            elif j==0:\n                 depot_component = np.exp(-distance_matrix[i,0]/ avg_dist_to_depot) if avg_dist_to_depot>0 else 1.0\n\n            angle_diff = abs(angles[i] - angles[j])\n            angle_component = np.exp(-2 * angle_diff)\n\n            heuristic_value = distance_component * demand_component * centrality_component * depot_component * angle_component\n            heuristic_matrix[i, j] = heuristic_value\n\n    # Adaptive thresholding\n    threshold = np.mean(heuristic_matrix[heuristic_matrix > 0]) * 0.2\n    heuristic_matrix[heuristic_matrix < threshold] = 0\n\n    # Additional sparsification based on capacity and depot proximity\n    for i in range(n):\n        for j in range(n):\n            if i != 0 and j != 0 and (demands[i] + demands[j]) > 1.5 * capacity:\n                heuristic_matrix[i, j] = 0\n            if i!=0 and j!=0 and (demands[i] > capacity or demands[j] > capacity) :\n                heuristic_matrix[i, j] = 0\n            if (i==0 and distance_matrix[i,j] > 2*avg_dist_to_depot):\n                heuristic_matrix[i, j] = 0\n            if (j==0 and distance_matrix[i,j] > 2*avg_dist_to_depot):\n                heuristic_matrix[i, j] = 0\n\n\n    return heuristic_matrix\n\n### Worse code\ndef heuristics_v1(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n\n    \"\"\"Combines centrality, capacity, angle, depot attraction, and sparsification for CVRP.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n    center_x = np.mean(coordinates[1:, 0])\n    center_y = np.mean(coordinates[1:, 1])\n    total_demand = np.sum(demands[1:])\n    demand_weighted_dist_to_depot = np.sum(demands[1:] * distance_matrix[0, 1:]) / total_demand if total_demand > 0 else 0\n\n    # Adaptive parameters (to be tuned)\n    distance_weight = 1.0\n    demand_weight = 1.0\n    angle_weight = 1.0\n    centrality_weight = 1.0\n    depot_attraction_weight = 1.0\n    sparsification_threshold = 0.1  # Adjust based on problem scale\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n\n            distance = distance_matrix[i, j]\n            distance_component = 1 / (distance + 1e-6)\n\n            demand_component = 1.0\n            if i != 0 and j != 0:\n                if demands[i] + demands[j] > capacity:\n                    demand_component = 0.1  # Heavily penalize exceeding capacity\n\n            angle_component = 1.0\n            if i != 0 and j != 0:\n                angles = []\n                for k in range(n):\n                    if k != i and k != j:\n                        v1 = coordinates[i] - coordinates[j]\n                        v2 = coordinates[k] - coordinates[i]\n                        dot_product = np.dot(v1, v2)\n                        magnitudes = np.linalg.norm(v1) * np.linalg.norm(v2)\n                        if magnitudes == 0:\n                            angle = 0\n                        else:\n                            angle = np.arccos(dot_product / magnitudes)\n                        angles.append(angle)\n                if len(angles) > 0:\n                    angle_component = min(np.degrees(angles) / 180.0)\n\n            center_distance = (np.sqrt((coordinates[i, 0] - center_x)**2 + (coordinates[i, 1] - center_y)**2) +\n                               np.sqrt((coordinates[j, 0] - center_x)**2 + (coordinates[j, 1] - center_y)**2)) / 2\n            centrality_component = np.exp(-center_distance / (demand_weighted_dist_to_depot+1e-6))\n\n            depot_component = 1.0\n            if i!=0:\n                load_before_depot = demands[i]\n                depot_component = (1 + np.exp(load_before_depot/capacity)) / 2\n\n            # Context-aware combination with adaptive weights\n            heuristic_value = (\n                distance_weight * distance_component *\n                demand_weight * demand_component *\n                angle_weight * (1 - angle_component) *\n                centrality_weight * centrality_component *\n                depot_attraction_weight * depot_component\n            )\n\n            heuristic_matrix[i, j] = heuristic_value\n\n    # Sparsification: Zero out less promising edges\n    max_heuristic_value = np.max(heuristic_matrix)\n    if max_heuristic_value > 0:\n        normalized_heuristic_matrix = heuristic_matrix / max_heuristic_value\n        heuristic_matrix[normalized_heuristic_matrix < sparsification_threshold] = 0\n\n    return heuristic_matrix\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see that the best heuristic combines centrality, capacity, angle, and depot attraction, while the worst uses a combination of distance, demand, angle, and sparsification but with less effective normalization and weighting. The best heuristic also incorporates precomputed depot attraction and angle differences. The worst heuristic also does not check the feasibility of capacity, causing routes to be infeasible.\n(2nd best) vs (2nd worst) the second best approach has a more comprehensive consideration of multiple factors (distance, demand, angle, centrality, and depot attraction), combined with adaptive sparsification based on demand and distance.  The 19th ranked heuristic uses powers to tune importance.\nComparing (1st) vs (2nd), we see the 1st ranked heuristic uses simpler calculations but the 2nd ranked heuristic is a more complex formula, adaptive sparsification, relaxed capacity constraint, and sampling.\n(3rd) vs (4th) - No difference, meaning there are duplicate heuristics on the list.\nComparing (second worst) vs (worst), we see that the 19th and 20th heuristics share similar design choices, but the 19th emphasizes demand and angle more and is more likely to provide better results.\nOverall: The better heuristics incorporate more relevant factors (centrality, depot attraction, angle) and employ adaptive techniques. They are more robust in handling capacity constraints and prioritize computational efficiency through normalization or sparsification. They also often use powers to tune the various component.\n- - Try combining various factors to determine how promising it is to select an edge.\n- Try sparsifying the matrix by setting unpromising elements to zero.\nOkay, let's refine \"Current Self-Reflection\" to design better heuristics, avoiding the pitfalls of \"Ineffective Self-Reflection.\" We'll aim for actionable advice.\n\nHere's a revised self-reflection framework:\n\n*   **Keywords:** Problem context, adaptive parameters, normalization, weighted combinations, computational cost, solution quality, experimental validation.\n\n*   **Advice:** Deeply analyze the problem's structure and constraints. Construct adaptive heuristics dynamically adjusting parameters (powers, weights) based on the search progress. Rigorously test and validate heuristics across diverse problem instances.\n\n*   **Avoid:** Overly complex weighting schemes without justification. Static parameter tuning; strive for adaptivity. Ignoring computational cost implications when increasing heuristic complexity.\n\n*   **Explanation:** Effective heuristics require a solid understanding of the underlying problem. Adaptivity allows heuristics to learn and refine their search strategy during execution. Balance between solution quality and computational efficiency is crucial for real-world applications. Normalization prevents features with large magnitudes from dominating heuristic performance.\n\n\nYour task is to write an improved function `heuristics_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}