{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Combines centrality, capacity, angle, and depot attraction for CVRP.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n    center_x = np.mean(coordinates[1:, 0])\n    center_y = np.mean(coordinates[1:, 1])\n    total_demand = np.sum(demands[1:])\n    demand_weighted_dist_to_depot = np.sum(demands[1:] * distance_matrix[0, 1:]) / total_demand if total_demand > 0 else 0\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n\n            distance = distance_matrix[i, j]\n            distance_component = 1 / (distance + 1e-6)\n\n            demand_component = 1.0\n            if i != 0 and j != 0 and demands[i] + demands[j] > capacity:\n                demand_component = 0.1\n\n            angle_component = 1.0\n            if i != 0 and j != 0:\n                angles = []\n                for k in range(n):\n                    if k != i and k != j:\n                        v1 = coordinates[i] - coordinates[j]\n                        v2 = coordinates[k] - coordinates[i]\n                        dot_product = np.dot(v1, v2)\n                        magnitudes = np.linalg.norm(v1) * np.linalg.norm(v2)\n                        if magnitudes == 0:\n                            angle = 0\n                        else:\n                            angle = np.arccos(dot_product / magnitudes)\n                        angles.append(angle)\n                if len(angles) > 0:\n                    angle_component = min(np.degrees(angles) / 180.0)\n\n            center_distance = (np.sqrt((coordinates[i, 0] - center_x)**2 + (coordinates[i, 1] - center_y)**2) +\n                               np.sqrt((coordinates[j, 0] - center_x)**2 + (coordinates[j, 1] - center_y)**2)) / 2\n            centrality_component = np.exp(-center_distance / demand_weighted_dist_to_depot if demand_weighted_dist_to_depot>0 else 1)\n\n            depot_component = 1.0\n            if i!=0:\n                load_before_depot = demands[i]\n                depot_component = (1 + np.exp(load_before_depot/capacity)) / 2\n\n            heuristic_matrix[i, j] = (distance_component * demand_component * (1 - angle_component) * centrality_component * depot_component)\n\n    return heuristic_matrix\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Enhanced heuristics combining distance, capacity, angle, centrality, and depot attraction.\n    Sparsifies the matrix and adapts weights based on problem characteristics.\"\"\"\n\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n    \n    # --- Centrality Component ---\n    center_x = np.mean(coordinates[1:, 0])\n    center_y = np.mean(coordinates[1:, 1])\n    total_demand = np.sum(demands[1:])\n    demand_weighted_dist_to_depot = np.sum(demands[1:] * distance_matrix[0, 1:]) / total_demand if total_demand > 0 else 1\n\n    # --- Sparsification Threshold (Adaptive) ---\n    # Dynamically adjust the sparsification threshold based on the average distance\n    avg_distance = np.mean(distance_matrix)\n    sparsification_threshold = 2.5 * avg_distance  # Increased factor for more aggressive sparsification\n\n\n    # --- Demand Pairings Heuristic ---\n    demand_pairs = {}\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            if demands[i] + demands[j] <= capacity:\n                demand_pairs[(i, j)] = 1.0 # A value of 1.0 means the pair is feasible\n\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n\n            distance = distance_matrix[i, j]\n\n            # --- Sparsification ---\n            if distance > sparsification_threshold:  # More aggressive sparsification\n                continue  # Skip calculation, effectively setting heuristic_matrix[i, j] to 0\n\n\n            distance_component = 1 / (distance + 1e-6)\n\n            demand_component = 1.0\n            if i != 0 and j != 0:\n                if demands[i] + demands[j] > capacity:\n                   demand_component = 0.01 # Severe penalty\n                else:\n                    # Small bonus for making feasible pairs\n                    if (min(i,j), max(i,j)) in demand_pairs:\n                        demand_component = 1.1\n\n            angle_component = 1.0\n            if i != 0 and j != 0:\n                angles = []\n                for k in range(n):\n                    if k != i and k != j:\n                        v1 = coordinates[i] - coordinates[j]\n                        v2 = coordinates[k] - coordinates[i]\n                        dot_product = np.dot(v1, v2)\n                        magnitudes = np.linalg.norm(v1) * np.linalg.norm(v2)\n                        if magnitudes == 0:\n                            angle = 0\n                        else:\n                            angle = np.arccos(dot_product / magnitudes)\n                        angles.append(angle)\n                if len(angles) > 0:\n                    angle_component = min(np.degrees(angles) / 180.0)\n\n            center_distance = (np.sqrt((coordinates[i, 0] - center_x)**2 + (coordinates[i, 1] - center_y)**2) +\n                               np.sqrt((coordinates[j, 0] - center_x)**2 + (coordinates[j, 1] - center_y)**2)) / 2\n            centrality_component = np.exp(-center_distance / demand_weighted_dist_to_depot if demand_weighted_dist_to_depot>0 else 1)\n\n            depot_component = 1.0\n            if i!=0:\n                load_before_depot = demands[i]\n                depot_component = (1 + np.exp(load_before_depot/capacity)) / 2\n\n\n            # --- Feature Interaction & Weighting ---\n            heuristic_value = (distance_component * demand_component * (1 - angle_component) * centrality_component * depot_component)\n\n            #Adjust weighting\n            if i==0 or j == 0:\n                heuristic_value *= 1.2 #Favor connection to depot\n\n\n\n            heuristic_matrix[i, j] = heuristic_value\n\n    return heuristic_matrix\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Combines adaptive distance, demand, centrality, depot attraction, and angle.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n    center_x = np.mean(coordinates[1:, 0])\n    center_y = np.mean(coordinates[1:, 1])\n    total_demand = np.sum(demands[1:])\n    demand_weighted_dist_to_depot = np.sum(demands[1:] * distance_matrix[0, 1:]) / total_demand if total_demand > 0 else np.mean(distance_matrix[0,1:])\n\n    avg_dist_to_depot = np.mean(distance_matrix[0, 1:])\n\n    depot_x, depot_y = coordinates[0]\n    angles = np.arctan2(coordinates[:, 1] - depot_y, coordinates[:, 0] - depot_x)\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n\n            distance = distance_matrix[i, j]\n            distance_component = np.exp(-distance / avg_dist_to_depot) if avg_dist_to_depot > 0 else 1.0\n\n            demand_component = 1.0\n            if i != 0 and j != 0 and demands[i] + demands[j] > capacity:\n                demand_component = 0.01\n\n            center_distance = (np.sqrt((coordinates[i, 0] - center_x)**2 + (coordinates[i, 1] - center_y)**2) +\n                               np.sqrt((coordinates[j, 0] - center_x)**2 + (coordinates[j, 1] - center_y)**2)) / 2\n            centrality_component = np.exp(-center_distance / demand_weighted_dist_to_depot) if demand_weighted_dist_to_depot > 0 else 1.0\n\n            depot_component = 1.0\n            if i!=0 and j!=0:\n                depot_attraction_i = np.exp(-distance_matrix[i, 0] / avg_dist_to_depot) if avg_dist_to_depot>0 else 1.0\n                depot_attraction_j = np.exp(-distance_matrix[j, 0] / avg_dist_to_depot) if avg_dist_to_depot>0 else 1.0\n                depot_component = (depot_attraction_i + depot_attraction_j) / 2\n\n            elif i==0:\n                depot_component = np.exp(-distance_matrix[j,0]/ avg_dist_to_depot) if avg_dist_to_depot>0 else 1.0\n            elif j==0:\n                 depot_component = np.exp(-distance_matrix[i,0]/ avg_dist_to_depot) if avg_dist_to_depot>0 else 1.0\n\n            angle_diff = abs(angles[i] - angles[j])\n            angle_component = np.exp(-2 * angle_diff)\n\n            heuristic_value = distance_component * demand_component * centrality_component * depot_component * angle_component\n            heuristic_matrix[i, j] = heuristic_value\n\n    threshold = np.mean(heuristic_matrix[heuristic_matrix > 0]) * 0.2\n    heuristic_matrix[heuristic_matrix < threshold] = 0\n\n    return heuristic_matrix\n\n[Heuristics 4th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Combines adaptive distance, demand, centrality, depot attraction, and angle.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n    center_x = np.mean(coordinates[1:, 0])\n    center_y = np.mean(coordinates[1:, 1])\n    total_demand = np.sum(demands[1:])\n    demand_weighted_dist_to_depot = np.sum(demands[1:] * distance_matrix[0, 1:]) / total_demand if total_demand > 0 else np.mean(distance_matrix[0,1:])\n\n    avg_dist_to_depot = np.mean(distance_matrix[0, 1:])\n\n    depot_x, depot_y = coordinates[0]\n    angles = np.arctan2(coordinates[:, 1] - depot_y, coordinates[:, 0] - depot_x)\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n\n            distance = distance_matrix[i, j]\n            distance_component = np.exp(-distance / avg_dist_to_depot) if avg_dist_to_depot > 0 else 1.0\n\n            demand_component = 1.0\n            if i != 0 and j != 0 and demands[i] + demands[j] > capacity:\n                demand_component = 0.01\n\n            center_distance = (np.sqrt((coordinates[i, 0] - center_x)**2 + (coordinates[i, 1] - center_y)**2) +\n                               np.sqrt((coordinates[j, 0] - center_x)**2 + (coordinates[j, 1] - center_y)**2)) / 2\n            centrality_component = np.exp(-center_distance / demand_weighted_dist_to_depot) if demand_weighted_dist_to_depot > 0 else 1.0\n\n            depot_component = 1.0\n            if i!=0 and j!=0:\n                depot_attraction_i = np.exp(-distance_matrix[i, 0] / avg_dist_to_depot) if avg_dist_to_depot>0 else 1.0\n                depot_attraction_j = np.exp(-distance_matrix[j, 0] / avg_dist_to_depot) if avg_dist_to_depot>0 else 1.0\n                depot_component = (depot_attraction_i + depot_attraction_j) / 2\n\n            elif i==0:\n                depot_component = np.exp(-distance_matrix[j,0]/ avg_dist_to_depot) if avg_dist_to_depot>0 else 1.0\n            elif j==0:\n                 depot_component = np.exp(-distance_matrix[i,0]/ avg_dist_to_depot) if avg_dist_to_depot>0 else 1.0\n\n            angle_diff = abs(angles[i] - angles[j])\n            angle_component = np.exp(-2 * angle_diff)\n\n            heuristic_value = distance_component * demand_component * centrality_component * depot_component * angle_component\n            heuristic_matrix[i, j] = heuristic_value\n\n    threshold = np.mean(heuristic_matrix[heuristic_matrix > 0]) * 0.2\n    heuristic_matrix[heuristic_matrix < threshold] = 0\n\n    return heuristic_matrix\n\n[Heuristics 5th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Combines adaptive distance, demand, centrality, depot attraction, and angle.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n    center_x = np.mean(coordinates[1:, 0])\n    center_y = np.mean(coordinates[1:, 1])\n    total_demand = np.sum(demands[1:])\n    demand_weighted_dist_to_depot = np.sum(demands[1:] * distance_matrix[0, 1:]) / total_demand if total_demand > 0 else np.mean(distance_matrix[0,1:])\n\n    avg_dist_to_depot = np.mean(distance_matrix[0, 1:])\n\n    depot_x, depot_y = coordinates[0]\n    angles = np.arctan2(coordinates[:, 1] - depot_y, coordinates[:, 0] - depot_x)\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n\n            distance = distance_matrix[i, j]\n            distance_component = np.exp(-distance / avg_dist_to_depot) if avg_dist_to_depot > 0 else 1.0\n\n            demand_component = 1.0\n            if i != 0 and j != 0 and demands[i] + demands[j] > capacity:\n                demand_component = 0.01\n\n            center_distance = (np.sqrt((coordinates[i, 0] - center_x)**2 + (coordinates[i, 1] - center_y)**2) +\n                               np.sqrt((coordinates[j, 0] - center_x)**2 + (coordinates[j, 1] - center_y)**2)) / 2\n            centrality_component = np.exp(-center_distance / demand_weighted_dist_to_depot) if demand_weighted_dist_to_depot > 0 else 1.0\n\n            depot_component = 1.0\n            if i!=0 and j!=0:\n                depot_attraction_i = np.exp(-distance_matrix[i, 0] / avg_dist_to_depot) if avg_dist_to_depot>0 else 1.0\n                depot_attraction_j = np.exp(-distance_matrix[j, 0] / avg_dist_to_depot) if avg_dist_to_depot>0 else 1.0\n                depot_component = (depot_attraction_i + depot_attraction_j) / 2\n\n            elif i==0:\n                depot_component = np.exp(-distance_matrix[j,0]/ avg_dist_to_depot) if avg_dist_to_depot>0 else 1.0\n            elif j==0:\n                 depot_component = np.exp(-distance_matrix[i,0]/ avg_dist_to_depot) if avg_dist_to_depot>0 else 1.0\n\n            angle_diff = abs(angles[i] - angles[j])\n            angle_component = np.exp(-2 * angle_diff)\n\n            heuristic_value = distance_component * demand_component * centrality_component * depot_component * angle_component\n            heuristic_matrix[i, j] = heuristic_value\n\n    threshold = np.mean(heuristic_matrix[heuristic_matrix > 0]) * 0.2\n    heuristic_matrix[heuristic_matrix < threshold] = 0\n\n    return heuristic_matrix\n\n[Heuristics 6th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Enhanced heuristic combining distance, demand, angle, centrality, and depot attraction with adaptive weights and sparsification.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n\n    # Calculate center and total demand for centrality calculations\n    center_x = np.mean(coordinates[1:, 0])\n    center_y = np.mean(coordinates[1:, 1])\n    total_demand = np.sum(demands[1:])\n    demand_weighted_dist_to_depot = np.sum(demands[1:] * distance_matrix[0, 1:]) / total_demand if total_demand > 0 else 1e6  # prevent zero division\n\n    # Adaptive weights (can be tuned based on problem instances)\n    distance_weight = 0.4\n    demand_weight = 0.3\n    angle_weight = 0.15\n    centrality_weight = 0.1\n    depot_weight = 0.05\n\n    # Sparsification threshold (can be tuned)\n    sparsification_threshold = 0.1\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n\n            # Distance component\n            distance = distance_matrix[i, j]\n            distance_component = 1 / (distance + 1e-6)\n\n            # Demand component\n            demand_component = 1.0\n            if i != 0 and j != 0:\n                if demands[i] + demands[j] > capacity:\n                    demand_component = 0.05  # heavily penalize exceeding capacity\n                else:\n                     demand_component = 1 - (demands[i] + demands[j]) / (2 * capacity)\n\n\n            # Angle component (calculate angle to other nodes)\n            angle_component = 1.0\n            if i != 0 and j != 0:\n                angles = []\n                for k in range(n):\n                    if k != i and k != j:\n                        v1 = coordinates[i] - coordinates[j]\n                        v2 = coordinates[k] - coordinates[i]\n                        dot_product = np.dot(v1, v2)\n                        magnitudes = np.linalg.norm(v1) * np.linalg.norm(v2)\n                        if magnitudes == 0:\n                            angle = np.pi/2 #Set angle to right angle for robustness\n                        else:\n                            angle = np.arccos(np.clip(dot_product / magnitudes, -1.0, 1.0)) #clip for numerical stability\n                        angles.append(angle)\n\n                if len(angles) > 0:\n                    angle_component = np.min(np.degrees(angles)) / 180.0\n                else:\n                    angle_component = 0.5  #reasonable default value when the node has no other neighbors to calculate the angle with.\n            else:\n                angle_component = 0.5\n\n            # Centrality component (distance from center of gravity)\n            center_distance = (np.sqrt((coordinates[i, 0] - center_x)**2 + (coordinates[i, 1] - center_y)**2) +\n                               np.sqrt((coordinates[j, 0] - center_x)**2 + (coordinates[j, 1] - center_y)**2)) / 2\n            centrality_component = np.exp(-center_distance / (demand_weighted_dist_to_depot + 1e-6))\n\n            # Depot component (attraction to the depot, especially for nodes with high demand)\n            depot_component = 1.0\n            if i != 0:\n                depot_distance_i = distance_matrix[i, 0]\n                depot_component_i = np.exp(-depot_distance_i / (demand_weighted_dist_to_depot + 1e-6)) * (1 + demands[i]/capacity)\n\n            else:\n                depot_component_i = 1.0\n\n            if j!= 0:\n\n                depot_distance_j = distance_matrix[j, 0]\n                depot_component_j = np.exp(-depot_distance_j / (demand_weighted_dist_to_depot+ 1e-6)) * (1 + demands[j]/capacity)\n            else:\n                depot_component_j = 1.0\n            depot_component = (depot_component_i + depot_component_j)/2\n\n\n            # Combine components with adaptive weights\n            heuristic_value = (distance_weight * distance_component +\n                               demand_weight * demand_component +\n                               angle_weight * (1 - angle_component) +  # minimize angle\n                               centrality_weight * centrality_component +\n                               depot_weight * depot_component)\n\n            heuristic_matrix[i, j] = heuristic_value\n\n    #Sparsify the matrix\n    max_heuristic = np.max(heuristic_matrix)\n    if max_heuristic > 0:\n        heuristic_matrix[heuristic_matrix < sparsification_threshold * max_heuristic] = 0\n\n    return heuristic_matrix\n\n[Heuristics 7th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Combines normalized distance, demand, angle, centrality, depot proximity for CVRP.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n\n    # Normalize distances\n    max_distance = np.max(distance_matrix)\n    normalized_distances = distance_matrix / (max_distance + 1e-6)\n\n    # Calculate center of mass\n    center_x = np.mean(coordinates[1:, 0])\n    center_y = np.mean(coordinates[1:, 1])\n\n    # Weight components\n    alpha = 0.4  # Distance importance\n    beta = 0.3  # Demand importance\n    gamma = 0.2 # Angle importance\n    delta = 0.1 # Centrality importance\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n\n            # Distance component\n            distance_component = 1 / (normalized_distances[i, j] + 1e-6)\n\n            # Demand component: discourage edges exceeding capacity\n            demand_component = np.exp(-max(0, (demands[i] + demands[j] - capacity) / capacity))\n\n            # Angle component\n            angles = []\n            for k in range(1, n):  # Iterate through customers\n                if k != i and k != j:\n                    v1 = coordinates[i] - coordinates[j]\n                    v2 = coordinates[k] - coordinates[i]\n                    dot_product = np.dot(v1, v2)\n                    magnitudes = np.linalg.norm(v1) * np.linalg.norm(v2)\n                    if magnitudes == 0:\n                        angle = 0\n                    else:\n                        angle = np.arccos(dot_product / magnitudes)\n                    angles.append(angle)\n\n            angle_component = 1.0\n            if angles:\n                angle_component = min(np.degrees(angles) / 180.0)\n\n            # Centrality component\n            center_distance_i = np.sqrt((coordinates[i, 0] - center_x)**2 + (coordinates[i, 1] - center_y)**2)\n            center_distance_j = np.sqrt((coordinates[j, 0] - center_x)**2 + (coordinates[j, 1] - center_y)**2)\n            avg_center_distance = (center_distance_i + center_distance_j) / 2\n            total_demand = np.sum(demands[1:])\n            demand_weighted_dist_to_depot = np.sum(demands[1:] * distance_matrix[0, 1:]) / total_demand if total_demand > 0 else 1\n            centrality_component = np.exp(-avg_center_distance / (demand_weighted_dist_to_depot + 1e-6))\n\n            # Depot attraction\n            depot_attraction_i = 1 / (distance_matrix[0, i] + 1e-6) if i != 0 else 1.0\n            depot_attraction_j = 1 / (distance_matrix[0, j] + 1e-6) if j != 0 else 1.0\n            depot_component = (depot_attraction_i + depot_attraction_j) / 2\n\n            # Combine components\n            heuristic_value = (alpha * distance_component +\n                               beta * demand_component +\n                               gamma * (1-angle_component) +\n                               delta * centrality_component) * depot_component\n\n            heuristic_matrix[i, j] = heuristic_value\n\n    # Sparsification\n    distance_threshold = np.percentile(distance_matrix[distance_matrix > 0], 75)\n    heuristic_matrix[distance_matrix > distance_threshold] = 0\n    heuristic_matrix[distance_matrix == 0] = 0\n\n    return heuristic_matrix\n\n[Heuristics 8th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Combines normalized distance, demand, angle, centrality, depot proximity for CVRP.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n\n    # Normalize distances\n    max_distance = np.max(distance_matrix)\n    normalized_distances = distance_matrix / (max_distance + 1e-6)\n\n    # Calculate center of mass\n    center_x = np.mean(coordinates[1:, 0])\n    center_y = np.mean(coordinates[1:, 1])\n\n    # Weight components\n    alpha = 0.4  # Distance importance\n    beta = 0.3  # Demand importance\n    gamma = 0.2 # Angle importance\n    delta = 0.1 # Centrality importance\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n\n            # Distance component\n            distance_component = 1 / (normalized_distances[i, j] + 1e-6)\n\n            # Demand component: discourage edges exceeding capacity\n            demand_component = np.exp(-max(0, (demands[i] + demands[j] - capacity) / capacity))\n\n            # Angle component\n            angles = []\n            for k in range(1, n):  # Iterate through customers\n                if k != i and k != j:\n                    v1 = coordinates[i] - coordinates[j]\n                    v2 = coordinates[k] - coordinates[i]\n                    dot_product = np.dot(v1, v2)\n                    magnitudes = np.linalg.norm(v1) * np.linalg.norm(v2)\n                    if magnitudes == 0:\n                        angle = 0\n                    else:\n                        angle = np.arccos(dot_product / magnitudes)\n                    angles.append(angle)\n\n            angle_component = 1.0\n            if angles:\n                angle_component = min(np.degrees(angles) / 180.0)\n\n            # Centrality component\n            center_distance_i = np.sqrt((coordinates[i, 0] - center_x)**2 + (coordinates[i, 1] - center_y)**2)\n            center_distance_j = np.sqrt((coordinates[j, 0] - center_x)**2 + (coordinates[j, 1] - center_y)**2)\n            avg_center_distance = (center_distance_i + center_distance_j) / 2\n            total_demand = np.sum(demands[1:])\n            demand_weighted_dist_to_depot = np.sum(demands[1:] * distance_matrix[0, 1:]) / total_demand if total_demand > 0 else 1\n            centrality_component = np.exp(-avg_center_distance / (demand_weighted_dist_to_depot + 1e-6))\n\n            # Depot attraction\n            depot_attraction_i = 1 / (distance_matrix[0, i] + 1e-6) if i != 0 else 1.0\n            depot_attraction_j = 1 / (distance_matrix[0, j] + 1e-6) if j != 0 else 1.0\n            depot_component = (depot_attraction_i + depot_attraction_j) / 2\n\n            # Combine components\n            heuristic_value = (alpha * distance_component +\n                               beta * demand_component +\n                               gamma * (1-angle_component) +\n                               delta * centrality_component) * depot_component\n\n            heuristic_matrix[i, j] = heuristic_value\n\n    # Sparsification\n    distance_threshold = np.percentile(distance_matrix[distance_matrix > 0], 75)\n    heuristic_matrix[distance_matrix > distance_threshold] = 0\n    heuristic_matrix[distance_matrix == 0] = 0\n\n    return heuristic_matrix\n\n[Heuristics 9th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Combines distance, demand density, angle, centrality and depot proximity.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n\n    # Normalize distance\n    max_distance = np.max(distance_matrix[distance_matrix != np.inf])\n    normalized_distance = distance_matrix / max_distance\n    normalized_distance = np.where(normalized_distance == 0, 1e-6, normalized_distance)\n\n    # Calculate angles relative to the depot\n    depot_x, depot_y = coordinates[0]\n    angles = np.arctan2(coordinates[:, 1] - depot_y, coordinates[:, 0] - depot_x)\n\n    # Calculate demand density\n    areas = []\n    for i in range(n):\n        # Approximate area as proportional to the square of distance to depot\n        area = distance_matrix[0, i] ** 2\n        areas.append(area)\n\n    max_area = np.max(areas) if np.max(areas) > 0 else 1\n    demand_densities = demands / (np.array(areas) / max_area + 1e-6) # Avoid divide by zero\n\n    # Calculate center of mass\n    center_x = np.mean(coordinates[1:, 0])\n    center_y = np.mean(coordinates[1:, 1])\n\n    # Parameters - these could be adaptive in a more advanced version\n    distance_weight = 0.4\n    demand_weight = 0.2\n    angle_weight = 0.1\n    depot_weight = 0.2\n    centrality_weight = 0.1\n\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                heuristic_value = 0.0\n\n                # Distance component\n                heuristic_value += distance_weight * (1 / normalized_distance[i, j])\n\n                # Demand component (using demand density)\n                demand_penalty = np.exp(-2 * (demand_densities[i] + demand_densities[j]))\n                heuristic_value += demand_weight * demand_penalty\n\n                # Angle component\n                angle_diff = abs(angles[i] - angles[j])\n                angle_penalty = np.exp(-2 * angle_diff)\n                heuristic_value += angle_weight * angle_penalty\n\n                # Depot proximity component (penalize if far from depot)\n                depot_distance_i = distance_matrix[0, i] / max_distance\n                depot_distance_j = distance_matrix[0, j] / max_distance\n                depot_proximity_penalty = np.exp(-1 * (depot_distance_i + depot_distance_j))\n                heuristic_value += depot_weight * depot_proximity_penalty\n\n                # Centrality component\n                center_distance_i = np.sqrt((coordinates[i, 0] - center_x)**2 + (coordinates[i, 1] - center_y)**2) / max_distance\n                center_distance_j = np.sqrt((coordinates[j, 0] - center_x)**2 + (coordinates[j, 1] - center_y)**2) / max_distance\n                avg_center_distance = (center_distance_i + center_distance_j) / 2\n                centrality_penalty = np.exp(-avg_center_distance)\n                heuristic_value += centrality_weight * centrality_penalty\n\n                heuristic_matrix[i, j] = heuristic_value\n\n    # Sparsify the matrix (optional)\n    threshold = np.mean(heuristic_matrix) * 0.1\n    heuristic_matrix[heuristic_matrix < threshold] = 0\n\n    return heuristic_matrix\n\n[Heuristics 10th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Combines distance, demand density, angle, centrality and depot proximity.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n\n    # Normalize distance\n    max_distance = np.max(distance_matrix[distance_matrix != np.inf])\n    normalized_distance = distance_matrix / max_distance\n    normalized_distance = np.where(normalized_distance == 0, 1e-6, normalized_distance)\n\n    # Calculate angles relative to the depot\n    depot_x, depot_y = coordinates[0]\n    angles = np.arctan2(coordinates[:, 1] - depot_y, coordinates[:, 0] - depot_x)\n\n    # Calculate demand density\n    areas = []\n    for i in range(n):\n        # Approximate area as proportional to the square of distance to depot\n        area = distance_matrix[0, i] ** 2\n        areas.append(area)\n\n    max_area = np.max(areas) if np.max(areas) > 0 else 1\n    demand_densities = demands / (np.array(areas) / max_area + 1e-6) # Avoid divide by zero\n\n    # Calculate center of mass\n    center_x = np.mean(coordinates[1:, 0])\n    center_y = np.mean(coordinates[1:, 1])\n\n    # Parameters - these could be adaptive in a more advanced version\n    distance_weight = 0.4\n    demand_weight = 0.2\n    angle_weight = 0.1\n    depot_weight = 0.2\n    centrality_weight = 0.1\n\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                heuristic_value = 0.0\n\n                # Distance component\n                heuristic_value += distance_weight * (1 / normalized_distance[i, j])\n\n                # Demand component (using demand density)\n                demand_penalty = np.exp(-2 * (demand_densities[i] + demand_densities[j]))\n                heuristic_value += demand_weight * demand_penalty\n\n                # Angle component\n                angle_diff = abs(angles[i] - angles[j])\n                angle_penalty = np.exp(-2 * angle_diff)\n                heuristic_value += angle_weight * angle_penalty\n\n                # Depot proximity component (penalize if far from depot)\n                depot_distance_i = distance_matrix[0, i] / max_distance\n                depot_distance_j = distance_matrix[0, j] / max_distance\n                depot_proximity_penalty = np.exp(-1 * (depot_distance_i + depot_distance_j))\n                heuristic_value += depot_weight * depot_proximity_penalty\n\n                # Centrality component\n                center_distance_i = np.sqrt((coordinates[i, 0] - center_x)**2 + (coordinates[i, 1] - center_y)**2) / max_distance\n                center_distance_j = np.sqrt((coordinates[j, 0] - center_x)**2 + (coordinates[j, 1] - center_y)**2) / max_distance\n                avg_center_distance = (center_distance_i + center_distance_j) / 2\n                centrality_penalty = np.exp(-avg_center_distance)\n                heuristic_value += centrality_weight * centrality_penalty\n\n                heuristic_matrix[i, j] = heuristic_value\n\n    # Sparsify the matrix (optional)\n    threshold = np.mean(heuristic_matrix) * 0.1\n    heuristic_matrix[heuristic_matrix < threshold] = 0\n\n    return heuristic_matrix\n\n[Heuristics 11th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Enhanced heuristics for CVRP combining distance, demand, angle, centrality,\n    depot attraction, and route feasibility with adaptive weighting.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n    center_x = np.mean(coordinates[1:, 0])\n    center_y = np.mean(coordinates[1:, 1])\n    total_demand = np.sum(demands[1:])\n    demand_weighted_dist_to_depot = np.sum(demands[1:] * distance_matrix[0, 1:]) / total_demand if total_demand > 0 else 1e-6  #Avoid division by zero\n\n    # Adaptive weight initialization (can be tuned further)\n    weight_distance = 0.4\n    weight_demand = 0.2\n    weight_angle = 0.1\n    weight_centrality = 0.2\n    weight_depot = 0.1\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n\n            distance = distance_matrix[i, j]\n            distance_component = 1 / (distance + 1e-6)  # Avoid division by zero\n\n            demand_component = 1.0\n            if i != 0 and j != 0:\n                if demands[i] + demands[j] > capacity:\n                    demand_component = 0.05  # Heavily penalize exceeding capacity\n                else:\n                    demand_component = 1 - (demands[i] + demands[j]) / (2*capacity) # reward smaller demand.\n\n            angle_component = 1.0\n            if i != 0 and j != 0:\n                angles = []\n                for k in range(n):\n                    if k != i and k != j:\n                        v1 = coordinates[i] - coordinates[j]\n                        v2 = coordinates[k] - coordinates[i]\n                        dot_product = np.dot(v1, v2)\n                        magnitudes = np.linalg.norm(v1) * np.linalg.norm(v2)\n                        if magnitudes == 0:\n                            angle = 0\n                        else:\n                            angle = np.arccos(dot_product / magnitudes)\n                        angles.append(angle)\n                if len(angles) > 0:\n                    angle_component = np.mean(np.degrees(angles)) / 180.0  # Average angle\n                else:\n                    angle_component = 0.5 # default\n\n            center_distance = (np.sqrt((coordinates[i, 0] - center_x)**2 + (coordinates[i, 1] - center_y)**2) +\n                               np.sqrt((coordinates[j, 0] - center_x)**2 + (coordinates[j, 1] - center_y)**2)) / 2\n            centrality_component = np.exp(-center_distance / (demand_weighted_dist_to_depot + 1e-6)) #Avoid division by zero\n\n            depot_component = 1.0\n            if i != 0 and j != 0: # Apply to customer-customer edges, helps prioritize starting/ending routes near the depot\n                depot_attraction_i = np.exp(-distance_matrix[i, 0] / demand_weighted_dist_to_depot)\n                depot_attraction_j = np.exp(-distance_matrix[j, 0] / demand_weighted_dist_to_depot)\n                depot_component = (depot_attraction_i + depot_attraction_j) / 2\n            elif i == 0:\n                depot_component = np.exp(-distance_matrix[j, 0] / demand_weighted_dist_to_depot)\n            elif j == 0:\n                depot_component = np.exp(-distance_matrix[i, 0] / demand_weighted_dist_to_depot)\n\n\n            heuristic_matrix[i, j] = (weight_distance * distance_component +\n                                     weight_demand * demand_component +\n                                     weight_angle * (1 - angle_component) + # Smaller angles are better.\n                                     weight_centrality * centrality_component +\n                                     weight_depot * depot_component)\n\n    # Sparsify the matrix (optional, but often beneficial)\n    threshold = np.mean(heuristic_matrix) * 0.2  # Dynamic threshold, prune low promising edges\n    heuristic_matrix[heuristic_matrix < threshold] = 0\n\n    return heuristic_matrix\n\n[Heuristics 12th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Enhanced heuristics for CVRP combining distance, demand, angle, centrality,\n    depot attraction, and route feasibility with adaptive weighting.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n    center_x = np.mean(coordinates[1:, 0])\n    center_y = np.mean(coordinates[1:, 1])\n    total_demand = np.sum(demands[1:])\n    demand_weighted_dist_to_depot = np.sum(demands[1:] * distance_matrix[0, 1:]) / total_demand if total_demand > 0 else 1e-6  #Avoid division by zero\n\n    # Adaptive weight initialization (can be tuned further)\n    weight_distance = 0.4\n    weight_demand = 0.2\n    weight_angle = 0.1\n    weight_centrality = 0.2\n    weight_depot = 0.1\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n\n            distance = distance_matrix[i, j]\n            distance_component = 1 / (distance + 1e-6)  # Avoid division by zero\n\n            demand_component = 1.0\n            if i != 0 and j != 0:\n                if demands[i] + demands[j] > capacity:\n                    demand_component = 0.05  # Heavily penalize exceeding capacity\n                else:\n                    demand_component = 1 - (demands[i] + demands[j]) / (2*capacity) # reward smaller demand.\n\n            angle_component = 1.0\n            if i != 0 and j != 0:\n                angles = []\n                for k in range(n):\n                    if k != i and k != j:\n                        v1 = coordinates[i] - coordinates[j]\n                        v2 = coordinates[k] - coordinates[i]\n                        dot_product = np.dot(v1, v2)\n                        magnitudes = np.linalg.norm(v1) * np.linalg.norm(v2)\n                        if magnitudes == 0:\n                            angle = 0\n                        else:\n                            angle = np.arccos(dot_product / magnitudes)\n                        angles.append(angle)\n                if len(angles) > 0:\n                    angle_component = np.mean(np.degrees(angles)) / 180.0  # Average angle\n                else:\n                    angle_component = 0.5 # default\n\n            center_distance = (np.sqrt((coordinates[i, 0] - center_x)**2 + (coordinates[i, 1] - center_y)**2) +\n                               np.sqrt((coordinates[j, 0] - center_x)**2 + (coordinates[j, 1] - center_y)**2)) / 2\n            centrality_component = np.exp(-center_distance / (demand_weighted_dist_to_depot + 1e-6)) #Avoid division by zero\n\n            depot_component = 1.0\n            if i != 0 and j != 0: # Apply to customer-customer edges, helps prioritize starting/ending routes near the depot\n                depot_attraction_i = np.exp(-distance_matrix[i, 0] / demand_weighted_dist_to_depot)\n                depot_attraction_j = np.exp(-distance_matrix[j, 0] / demand_weighted_dist_to_depot)\n                depot_component = (depot_attraction_i + depot_attraction_j) / 2\n            elif i == 0:\n                depot_component = np.exp(-distance_matrix[j, 0] / demand_weighted_dist_to_depot)\n            elif j == 0:\n                depot_component = np.exp(-distance_matrix[i, 0] / demand_weighted_dist_to_depot)\n\n\n            heuristic_matrix[i, j] = (weight_distance * distance_component +\n                                     weight_demand * demand_component +\n                                     weight_angle * (1 - angle_component) + # Smaller angles are better.\n                                     weight_centrality * centrality_component +\n                                     weight_depot * depot_component)\n\n    # Sparsify the matrix (optional, but often beneficial)\n    threshold = np.mean(heuristic_matrix) * 0.2  # Dynamic threshold, prune low promising edges\n    heuristic_matrix[heuristic_matrix < threshold] = 0\n\n    return heuristic_matrix\n\n[Heuristics 13th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Combines distance, demand, angle, depot proximity, and demand density\n    using weighted average and sparsification.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n    depot_coords = coordinates[0]\n    angles = np.arctan2(coordinates[:, 1] - depot_coords[1], coordinates[:, 0] - depot_coords[0])\n\n    # Demand density calculation\n    demand_density = np.zeros(n)\n    for i in range(1, n):\n        nearby_demand = 0\n        for j in range(1, n):\n            if i != j and distance_matrix[i, j] < np.mean(distance_matrix):\n                nearby_demand += demands[j]\n        demand_density[i] = nearby_demand\n    max_demand_density = np.max(demand_density) if np.max(demand_density) > 0 else 1\n\n    #Center calculation\n    center_x = np.mean(coordinates[1:, 0])\n    center_y = np.mean(coordinates[1:, 1])\n    total_demand = np.sum(demands[1:])\n    demand_weighted_dist_to_depot = np.sum(demands[1:] * distance_matrix[0, 1:]) / total_demand if total_demand > 0 else 1e-6\n\n    # Normalizing factor for distance\n    max_distance = np.max(distance_matrix)\n    if max_distance == 0:\n        max_distance = 1\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n\n            distance = distance_matrix[i, j]\n            normalized_distance = distance / max_distance\n            distance_component = 1 / (normalized_distance + 1e-6)\n\n            demand_penalty = 1.0 - np.clip((demands[i] + demands[j]) / (2 * capacity), 0, 0.7)\n\n            angle_diff = abs(angles[i] - angles[j])\n            angular_factor = 1 / (angle_diff + 0.1)\n\n            depot_proximity = 1.0\n            if i == 0 or j == 0:\n                depot_proximity = 1.2\n\n            density_component = 1.0\n            if i != 0 and j != 0:\n                density_component = np.sqrt((demand_density[i] / max_demand_density) * (demand_density[j] / max_demand_density))\n\n            center_distance = (np.sqrt((coordinates[i, 0] - center_x)**2 + (coordinates[i, 1] - center_y)**2) +\n                               np.sqrt((coordinates[j, 0] - center_x)**2 + (coordinates[j, 1] - center_y)**2)) / 2\n            centrality_component = np.exp(-center_distance / demand_weighted_dist_to_depot if demand_weighted_dist_to_depot>0 else 1)\n\n            # Weighted heuristic combining components.\n            alpha, beta, gamma, delta, epsilon = 0.4, 0.2, 0.15, 0.15, 0.1 #Adjustable weights\n            heuristic_matrix[i, j] = (alpha * distance_component +\n                                       beta * demand_penalty +\n                                       gamma * angular_factor +\n                                       delta * depot_proximity +\n                                       epsilon * density_component +\n                                       (1-alpha-beta-gamma-delta-epsilon) * centrality_component)\n\n            # Sparsification\n            if i!=0 and j!=0 and (demands[i] + demands[j]) > 1.5 * capacity:\n                heuristic_matrix[i, j] = 0\n            if i!=0 and j!=0 and (demands[i] > capacity or demands[j] > capacity) :\n                heuristic_matrix[i, j] = 0\n\n            heuristic_matrix[i, j] = np.clip(heuristic_matrix[i, j], 0, 1e6)\n\n    return heuristic_matrix\n\n[Heuristics 14th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Combines distance, demand, angle, depot proximity, and demand density\n    using weighted average and sparsification.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n    depot_coords = coordinates[0]\n    angles = np.arctan2(coordinates[:, 1] - depot_coords[1], coordinates[:, 0] - depot_coords[0])\n\n    # Demand density calculation\n    demand_density = np.zeros(n)\n    for i in range(1, n):\n        nearby_demand = 0\n        for j in range(1, n):\n            if i != j and distance_matrix[i, j] < np.mean(distance_matrix):\n                nearby_demand += demands[j]\n        demand_density[i] = nearby_demand\n    max_demand_density = np.max(demand_density) if np.max(demand_density) > 0 else 1\n\n    #Center calculation\n    center_x = np.mean(coordinates[1:, 0])\n    center_y = np.mean(coordinates[1:, 1])\n    total_demand = np.sum(demands[1:])\n    demand_weighted_dist_to_depot = np.sum(demands[1:] * distance_matrix[0, 1:]) / total_demand if total_demand > 0 else 1e-6\n\n    # Normalizing factor for distance\n    max_distance = np.max(distance_matrix)\n    if max_distance == 0:\n        max_distance = 1\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n\n            distance = distance_matrix[i, j]\n            normalized_distance = distance / max_distance\n            distance_component = 1 / (normalized_distance + 1e-6)\n\n            demand_penalty = 1.0 - np.clip((demands[i] + demands[j]) / (2 * capacity), 0, 0.7)\n\n            angle_diff = abs(angles[i] - angles[j])\n            angular_factor = 1 / (angle_diff + 0.1)\n\n            depot_proximity = 1.0\n            if i == 0 or j == 0:\n                depot_proximity = 1.2\n\n            density_component = 1.0\n            if i != 0 and j != 0:\n                density_component = np.sqrt((demand_density[i] / max_demand_density) * (demand_density[j] / max_demand_density))\n\n            center_distance = (np.sqrt((coordinates[i, 0] - center_x)**2 + (coordinates[i, 1] - center_y)**2) +\n                               np.sqrt((coordinates[j, 0] - center_x)**2 + (coordinates[j, 1] - center_y)**2)) / 2\n            centrality_component = np.exp(-center_distance / demand_weighted_dist_to_depot if demand_weighted_dist_to_depot>0 else 1)\n\n            # Weighted heuristic combining components.\n            alpha, beta, gamma, delta, epsilon = 0.4, 0.2, 0.15, 0.15, 0.1 #Adjustable weights\n            heuristic_matrix[i, j] = (alpha * distance_component +\n                                       beta * demand_penalty +\n                                       gamma * angular_factor +\n                                       delta * depot_proximity +\n                                       epsilon * density_component +\n                                       (1-alpha-beta-gamma-delta-epsilon) * centrality_component)\n\n            # Sparsification\n            if i!=0 and j!=0 and (demands[i] + demands[j]) > 1.5 * capacity:\n                heuristic_matrix[i, j] = 0\n            if i!=0 and j!=0 and (demands[i] > capacity or demands[j] > capacity) :\n                heuristic_matrix[i, j] = 0\n\n            heuristic_matrix[i, j] = np.clip(heuristic_matrix[i, j], 0, 1e6)\n\n    return heuristic_matrix\n\n[Heuristics 15th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Combines distance, demand, angle, depot proximity, and demand density\n    using weighted average and sparsification.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n    depot_coords = coordinates[0]\n    angles = np.arctan2(coordinates[:, 1] - depot_coords[1], coordinates[:, 0] - depot_coords[0])\n\n    # Demand density calculation\n    demand_density = np.zeros(n)\n    for i in range(1, n):\n        nearby_demand = 0\n        for j in range(1, n):\n            if i != j and distance_matrix[i, j] < np.mean(distance_matrix):\n                nearby_demand += demands[j]\n        demand_density[i] = nearby_demand\n    max_demand_density = np.max(demand_density) if np.max(demand_density) > 0 else 1\n\n    #Center calculation\n    center_x = np.mean(coordinates[1:, 0])\n    center_y = np.mean(coordinates[1:, 1])\n    total_demand = np.sum(demands[1:])\n    demand_weighted_dist_to_depot = np.sum(demands[1:] * distance_matrix[0, 1:]) / total_demand if total_demand > 0 else 1e-6\n\n    # Normalizing factor for distance\n    max_distance = np.max(distance_matrix)\n    if max_distance == 0:\n        max_distance = 1\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n\n            distance = distance_matrix[i, j]\n            normalized_distance = distance / max_distance\n            distance_component = 1 / (normalized_distance + 1e-6)\n\n            demand_penalty = 1.0 - np.clip((demands[i] + demands[j]) / (2 * capacity), 0, 0.7)\n\n            angle_diff = abs(angles[i] - angles[j])\n            angular_factor = 1 / (angle_diff + 0.1)\n\n            depot_proximity = 1.0\n            if i == 0 or j == 0:\n                depot_proximity = 1.2\n\n            density_component = 1.0\n            if i != 0 and j != 0:\n                density_component = np.sqrt((demand_density[i] / max_demand_density) * (demand_density[j] / max_demand_density))\n\n            center_distance = (np.sqrt((coordinates[i, 0] - center_x)**2 + (coordinates[i, 1] - center_y)**2) +\n                               np.sqrt((coordinates[j, 0] - center_x)**2 + (coordinates[j, 1] - center_y)**2)) / 2\n            centrality_component = np.exp(-center_distance / demand_weighted_dist_to_depot if demand_weighted_dist_to_depot>0 else 1)\n\n            # Weighted heuristic combining components.\n            alpha, beta, gamma, delta, epsilon = 0.4, 0.2, 0.15, 0.15, 0.1 #Adjustable weights\n            heuristic_matrix[i, j] = (alpha * distance_component +\n                                       beta * demand_penalty +\n                                       gamma * angular_factor +\n                                       delta * depot_proximity +\n                                       epsilon * density_component +\n                                       (1-alpha-beta-gamma-delta-epsilon) * centrality_component)\n\n            # Sparsification\n            if i!=0 and j!=0 and (demands[i] + demands[j]) > 1.5 * capacity:\n                heuristic_matrix[i, j] = 0\n            if i!=0 and j!=0 and (demands[i] > capacity or demands[j] > capacity) :\n                heuristic_matrix[i, j] = 0\n\n            heuristic_matrix[i, j] = np.clip(heuristic_matrix[i, j], 0, 1e6)\n\n    return heuristic_matrix\n\n[Heuristics 16th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Combines normalized distance, demand, depot proximity, and centrality with dynamic threshold.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n\n    # Normalize distance\n    max_distance = np.max(distance_matrix[distance_matrix != np.inf])\n    normalized_distance = distance_matrix / (max_distance + 1e-9)\n\n    # Demand component\n    demand_matrix = np.zeros((n, n))\n    for i in range(n):\n        for j in range(n):\n            demand_matrix[i, j] = demands[i] + demands[j]\n    demand_component = np.clip(1 - (demand_matrix / capacity), 0, 1)\n\n    # Centrality (degree centrality)\n    centrality = np.sum(1 / (distance_matrix + 1e-9), axis=1)\n    normalized_centrality = centrality / np.max(centrality + 1e-9)\n    centrality_matrix = np.zeros((n, n))\n    for i in range(n):\n        for j in range(n):\n            centrality_matrix[i, j] = (normalized_centrality[i] + normalized_centrality[j]) / 2\n\n    # Depot proximity\n    depot_distances = distance_matrix[0, :]\n    depot_proximity_matrix = np.zeros((n, n))\n    for i in range(n):\n        for j in range(n):\n            depot_proximity_matrix[i, j] = 1 / (depot_distances[i] + depot_distances[j] + 1e-9)\n    max_val = np.max(depot_proximity_matrix)\n    if max_val > 0:\n        depot_proximity_matrix = depot_proximity_matrix / max_val\n\n    # Combine components with weights\n    heuristic_matrix = (\n        0.4 * (1 / (normalized_distance + 1e-9)) +  # Distance\n        0.3 * demand_component +  # Demand\n        0.15 * centrality_matrix + #Centrality\n        0.15 * depot_proximity_matrix # Depot Proximity\n    )\n\n    # Sparsification with dynamic threshold\n    threshold = np.mean(heuristic_matrix[heuristic_matrix > 0]) * 0.2\n    heuristic_matrix[heuristic_matrix < threshold] = 0\n\n    # Ensure no self-loops\n    for i in range(n):\n        heuristic_matrix[i, i] = 0\n\n    return heuristic_matrix\n\n[Heuristics 17th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Combines normalized distance, demand, depot proximity, and centrality with dynamic threshold.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n\n    # Normalize distance\n    max_distance = np.max(distance_matrix[distance_matrix != np.inf])\n    normalized_distance = distance_matrix / (max_distance + 1e-9)\n\n    # Demand component\n    demand_matrix = np.zeros((n, n))\n    for i in range(n):\n        for j in range(n):\n            demand_matrix[i, j] = demands[i] + demands[j]\n    demand_component = np.clip(1 - (demand_matrix / capacity), 0, 1)\n\n    # Centrality (degree centrality)\n    centrality = np.sum(1 / (distance_matrix + 1e-9), axis=1)\n    normalized_centrality = centrality / np.max(centrality + 1e-9)\n    centrality_matrix = np.zeros((n, n))\n    for i in range(n):\n        for j in range(n):\n            centrality_matrix[i, j] = (normalized_centrality[i] + normalized_centrality[j]) / 2\n\n    # Depot proximity\n    depot_distances = distance_matrix[0, :]\n    depot_proximity_matrix = np.zeros((n, n))\n    for i in range(n):\n        for j in range(n):\n            depot_proximity_matrix[i, j] = 1 / (depot_distances[i] + depot_distances[j] + 1e-9)\n    max_val = np.max(depot_proximity_matrix)\n    if max_val > 0:\n        depot_proximity_matrix = depot_proximity_matrix / max_val\n\n    # Combine components with weights\n    heuristic_matrix = (\n        0.4 * (1 / (normalized_distance + 1e-9)) +  # Distance\n        0.3 * demand_component +  # Demand\n        0.15 * centrality_matrix + #Centrality\n        0.15 * depot_proximity_matrix # Depot Proximity\n    )\n\n    # Sparsification with dynamic threshold\n    threshold = np.mean(heuristic_matrix[heuristic_matrix > 0]) * 0.2\n    heuristic_matrix[heuristic_matrix < threshold] = 0\n\n    # Ensure no self-loops\n    for i in range(n):\n        heuristic_matrix[i, i] = 0\n\n    return heuristic_matrix\n\n[Heuristics 18th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Combines normalized distance, demand density, and depot proximity.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n\n    # Normalize distance matrix\n    max_distance = np.max(distance_matrix)\n    normalized_distances = distance_matrix / (max_distance + 1e-6)\n\n    # Calculate demand density\n    demand_density = np.zeros(n)\n    for i in range(1, n):\n        nearby_demand = 0\n        for j in range(1, n):\n            if i != j and distance_matrix[i, j] < np.mean(distance_matrix):\n                nearby_demand += demands[j]\n        demand_density[i] = nearby_demand\n    max_demand_density = np.max(demand_density) if np.max(demand_density) > 0 else 1\n\n    # Depot proximity\n    depot_distances = distance_matrix[0, :]\n    max_depot_distance = np.max(depot_distances)\n    normalized_depot_distances = depot_distances / (max_depot_distance + 1e-6)\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n\n            # Distance component\n            distance_component = 1 / (normalized_distances[i, j] + 1e-6)\n\n            # Demand density component\n            density_component = 1.0\n            if i != 0 and j != 0:\n                density_component = np.sqrt((demand_density[i] / max_demand_density) * (demand_density[j] / max_demand_density))\n\n            # Depot proximity component\n            depot_proximity_i = 1 / (normalized_depot_distances[i] + 0.1) if i != 0 else 1.0\n            depot_proximity_j = 1 / (normalized_depot_distances[j] + 0.1) if j != 0 else 1.0\n            depot_component = (depot_proximity_i + depot_proximity_j) / 2.0\n\n            # Demand penalty\n            demand_penalty = 1.0 - np.clip((demands[i] + demands[j]) / (2 * capacity), 0, 0.7)\n\n            # Combined heuristic\n            heuristic_matrix[i, j] = distance_component * density_component * depot_component * demand_penalty\n\n            # Sparsification\n            if i != 0 and j != 0 and (demands[i] + demands[j]) > 1.5 * capacity:\n                heuristic_matrix[i, j] = 0\n            if i!=0 and j!=0 and (demands[i] > capacity or demands[j] > capacity) :\n                heuristic_matrix[i, j] = 0\n\n            heuristic_matrix[i, j] = np.clip(heuristic_matrix[i, j], 0, 1e6)\n\n    return heuristic_matrix\n\n[Heuristics 19th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Combines normalized distance, demand, angle, centrality, depot attraction, sparsification, and smooth weighting.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n\n    # Calculate center and characteristic distance\n    center_x = np.mean(coordinates[1:, 0])\n    center_y = np.mean(coordinates[1:, 1])\n    total_demand = np.sum(demands[1:])\n    demand_weighted_dist_to_depot = np.sum(demands[1:] * distance_matrix[0, 1:]) / total_demand if total_demand > 0 else 0\n\n    # Normalization factors\n    max_distance = np.max(distance_matrix)\n    max_demand = np.max(demands)\n    max_coord = np.max(np.abs(coordinates))\n\n    # Weights (Tunable)\n    weight_distance = 0.3\n    weight_demand = 0.25\n    weight_angle = 0.15\n    weight_centrality = 0.15\n    weight_depot = 0.15\n\n    # Calculate angles relative to depot\n    depot_x, depot_y = coordinates[0]\n    angles = np.arctan2(coordinates[:, 1] - depot_y, coordinates[:, 0] - depot_x)\n\n    # Demand density component\n    demand_density = np.zeros(n)\n    for i in range(1, n):  # Skip depot\n        nearby_demand = 0\n        for j in range(1, n):\n            if i != j and distance_matrix[i, j] < demand_weighted_dist_to_depot:  # Check reasonable distance\n                nearby_demand += demands[j]\n        demand_density[i] = nearby_demand\n\n    max_demand_density = np.max(demand_density) if np.max(demand_density) > 0 else 1  # Avoid division by zero\n\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n\n            # 1. Distance Component (Normalized)\n            distance = distance_matrix[i, j]\n            distance_component = 1 - (distance / max_distance)  # Higher is better\n\n            # 2. Demand Component (Considers combined demand relative to capacity)\n            demand_component = 1.0\n            if i != 0 and j != 0:\n                 combined_demand = demands[i] + demands[j]\n                 demand_component = max(0.1, 1 - (combined_demand / capacity))\n\n            # 3. Angle Component (Smaller angle = higher priority) relative to depot\n            angle_diff = abs(angles[i] - angles[j])\n            angle_component = np.exp(-2 * angle_diff)\n\n\n            # 4. Centrality Component (Nodes closer to center are more attractive)\n            center_distance_i = np.sqrt((coordinates[i, 0] - center_x)**2 + (coordinates[i, 1] - center_y)**2)\n            center_distance_j = np.sqrt((coordinates[j, 0] - center_x)**2 + (coordinates[j, 1] - center_y)**2)\n            avg_center_distance = (center_distance_i + center_distance_j) / 2\n            centrality_component = np.exp(-avg_center_distance / (demand_weighted_dist_to_depot + 1e-6))\n\n            # 5. Depot Attraction (Attract nodes back to depot based on load)\n            depot_component = 1.0\n            if i != 0:  # Only penalize non-depot nodes.\n                load_before_depot = demands[i]  # Demand of node 'i'\n                depot_component = (1 + np.exp(-load_before_depot / (capacity + 1e-6))) / 2  # Inverted, higher is better to return\n\n            # Demand density component\n            density_component = 1.0\n            if i != 0 and j != 0:\n                density_component = np.sqrt((demand_density[i] / max_demand_density) * (demand_density[j] / max_demand_density))\n\n\n            # Combine the components using weighted sum\n            heuristic_matrix[i, j] = (\n                weight_distance * distance_component +\n                weight_demand * demand_component +\n                weight_angle * angle_component +\n                weight_centrality * centrality_component +\n                weight_depot * depot_component +\n                0.05 * density_component\n            )\n\n    # Sparsify the matrix.  Zero out very low values, reducing the search space.\n    threshold = np.mean(heuristic_matrix) * 0.1  # Dynamic threshold\n    heuristic_matrix[heuristic_matrix < threshold] = 0\n\n    return heuristic_matrix\n\n[Heuristics 20th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Combines distance, demand, angle, centrality, and depot attraction with adaptive weighting.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n    center_x = np.mean(coordinates[1:, 0])\n    center_y = np.mean(coordinates[1:, 1])\n    total_demand = np.sum(demands[1:])\n    demand_weighted_dist_to_depot = np.sum(demands[1:] * distance_matrix[0, 1:]) / total_demand if total_demand > 0 else np.mean(distance_matrix[0, 1:])\n\n    # Normalize distance\n    max_distance = np.max(distance_matrix[distance_matrix != np.inf])\n    normalized_distance = distance_matrix / max_distance if max_distance > 0 else np.ones_like(distance_matrix)\n    normalized_distance = np.where(normalized_distance == 0, 1e-6, normalized_distance)\n    \n    # Calculate angles relative to depot\n    depot_x, depot_y = coordinates[0]\n    angles = np.arctan2(coordinates[:, 1] - depot_y, coordinates[:, 0] - depot_x)\n\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n\n            # Adaptive weights (example, adjust based on problem instance)\n            distance_weight = 1.0\n            demand_weight = 1.0\n            angle_weight = 0.5\n            centrality_weight = 0.8\n            depot_weight = 0.7\n\n            # Distance component\n            distance = normalized_distance[i, j]\n            distance_component = 1 / (distance + 1e-6)\n\n            # Capacity component with smoother transition\n            demand_component = np.exp(-((demands[i] + demands[j]) / (capacity + 1e-6))**2)  # Gaussian penalty\n\n\n            # Angle component - prefer edges that don't cause sharp turns\n            angle_component = 1.0\n            if i != 0 and j != 0:\n                angle_diff = abs(angles[i] - angles[j])\n                angle_component = np.exp(-2 * angle_diff)\n\n\n            # Centrality component - attract towards the center of gravity\n            center_distance = (np.sqrt((coordinates[i, 0] - center_x)**2 + (coordinates[i, 1] - center_y)**2) +\n                               np.sqrt((coordinates[j, 0] - center_x)**2 + (coordinates[j, 1] - center_y)**2)) / 2\n            centrality_component = np.exp(-center_distance / (demand_weighted_dist_to_depot + 1e-6))\n\n            # Depot attraction component - nodes with high demand should be closer to the depot\n            depot_component = 1.0\n            if i!=0 and j!=0:\n                depot_dist_i = distance_matrix[0, i] / max_distance\n                depot_dist_j = distance_matrix[0, j] / max_distance\n                depot_component = np.exp(-5 * (depot_dist_i + depot_dist_j))\n\n            heuristic_matrix[i, j] = (distance_component**distance_weight * demand_component**demand_weight * angle_component**angle_weight *\n                                      centrality_component**centrality_weight * depot_component**depot_weight)\n\n            # Sparsification - Remove edges that are unlikely to be in the optimal solution\n            if heuristic_matrix[i, j] < 0.1 * np.mean(heuristic_matrix): #Dynamic threshold.\n                heuristic_matrix[i, j] = 0\n\n    return heuristic_matrix\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}