```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """Combines normalized distance, demand, angle, centrality, depot attraction, sparsification, and smooth weighting."""
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix)

    # Calculate center and characteristic distance
    center_x = np.mean(coordinates[1:, 0])
    center_y = np.mean(coordinates[1:, 1])
    total_demand = np.sum(demands[1:])
    demand_weighted_dist_to_depot = np.sum(demands[1:] * distance_matrix[0, 1:]) / total_demand if total_demand > 0 else 0

    # Normalization factors
    max_distance = np.max(distance_matrix)
    max_demand = np.max(demands)
    max_coord = np.max(np.abs(coordinates))

    # Weights (Tunable)
    weight_distance = 0.3
    weight_demand = 0.25
    weight_angle = 0.15
    weight_centrality = 0.15
    weight_depot = 0.15

    # Calculate angles relative to depot
    depot_x, depot_y = coordinates[0]
    angles = np.arctan2(coordinates[:, 1] - depot_y, coordinates[:, 0] - depot_x)

    # Demand density component
    demand_density = np.zeros(n)
    for i in range(1, n):  # Skip depot
        nearby_demand = 0
        for j in range(1, n):
            if i != j and distance_matrix[i, j] < demand_weighted_dist_to_depot:  # Check reasonable distance
                nearby_demand += demands[j]
        demand_density[i] = nearby_demand

    max_demand_density = np.max(demand_density) if np.max(demand_density) > 0 else 1  # Avoid division by zero


    for i in range(n):
        for j in range(n):
            if i == j:
                continue

            # 1. Distance Component (Normalized)
            distance = distance_matrix[i, j]
            distance_component = 1 - (distance / max_distance)  # Higher is better

            # 2. Demand Component (Considers combined demand relative to capacity)
            demand_component = 1.0
            if i != 0 and j != 0:
                 combined_demand = demands[i] + demands[j]
                 demand_component = max(0.1, 1 - (combined_demand / capacity))

            # 3. Angle Component (Smaller angle = higher priority) relative to depot
            angle_diff = abs(angles[i] - angles[j])
            angle_component = np.exp(-2 * angle_diff)


            # 4. Centrality Component (Nodes closer to center are more attractive)
            center_distance_i = np.sqrt((coordinates[i, 0] - center_x)**2 + (coordinates[i, 1] - center_y)**2)
            center_distance_j = np.sqrt((coordinates[j, 0] - center_x)**2 + (coordinates[j, 1] - center_y)**2)
            avg_center_distance = (center_distance_i + center_distance_j) / 2
            centrality_component = np.exp(-avg_center_distance / (demand_weighted_dist_to_depot + 1e-6))

            # 5. Depot Attraction (Attract nodes back to depot based on load)
            depot_component = 1.0
            if i != 0:  # Only penalize non-depot nodes.
                load_before_depot = demands[i]  # Demand of node 'i'
                depot_component = (1 + np.exp(-load_before_depot / (capacity + 1e-6))) / 2  # Inverted, higher is better to return

            # Demand density component
            density_component = 1.0
            if i != 0 and j != 0:
                density_component = np.sqrt((demand_density[i] / max_demand_density) * (demand_density[j] / max_demand_density))


            # Combine the components using weighted sum
            heuristic_matrix[i, j] = (
                weight_distance * distance_component +
                weight_demand * demand_component +
                weight_angle * angle_component +
                weight_centrality * centrality_component +
                weight_depot * depot_component +
                0.05 * density_component
            )

    # Sparsify the matrix.  Zero out very low values, reducing the search space.
    threshold = np.mean(heuristic_matrix) * 0.1  # Dynamic threshold
    heuristic_matrix[heuristic_matrix < threshold] = 0

    return heuristic_matrix
```
