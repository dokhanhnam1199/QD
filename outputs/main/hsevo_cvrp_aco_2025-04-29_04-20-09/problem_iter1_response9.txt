```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    A heuristic function for solving the Capacitated Vehicle Routing Problem (CVRP)
    via stochastic solution sampling. This version considers distance, demand,
    and angle from the depot.

    Args:
        distance_matrix (np.ndarray): A matrix of distances between nodes (n x n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (n x 2).
        demands (np.ndarray): A vector of customer demands (n).
        capacity (int): The capacity of each vehicle.

    Returns:
        np.ndarray: A matrix of heuristic values for each edge (n x n).  Higher
                    values indicate more promising edges.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Heuristic components:
    # 1. Distance-based: Shorter distances are preferred.
    distance_component = 1 / (distance_matrix + 1e-6)  # Add small constant to avoid division by zero

    # 2. Demand-based: Penalize edges that lead to large demand increases
    demand_penalty = np.zeros((n, n))
    for i in range(n):
        for j in range(n):
            demand_penalty[i, j] = (demands[j] / capacity)  #Scale demand by capacity


    #3 Angle heuristic to encourage visiting nodes in a circular manner, reducing crisscrossing.
    depot_x, depot_y = coordinates[0]
    angle_matrix = np.zeros((n, n))
    for i in range(1, n): #start at node 1
        angle_i = np.arctan2(coordinates[i, 1] - depot_y, coordinates[i, 0] - depot_x)
        for j in range(1, n): #start at node 1
            if i == j:
                angle_matrix[i,j] = 0
            else:
                angle_j = np.arctan2(coordinates[j, 1] - depot_y, coordinates[j, 0] - depot_x)
                angle_diff = np.abs(angle_i - angle_j)
                angle_diff = np.min([angle_diff, 2 * np.pi - angle_diff]) # Take the shorter angle
                angle_matrix[i, j] = 1/(angle_diff + 0.1) #add a small number to avoid division by zero.


    # Combine the components.  Experiment with different weights.
    heuristic_matrix = (0.6 * distance_component) + (0.1 * (1 - demand_penalty)) + (0.3* angle_matrix)
    # Set diagonal elements to 0 to prevent self-loops.
    for i in range(n):
        heuristic_matrix[i, i] = 0

    return heuristic_matrix
```
