```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Improves upon the basic distance-based heuristic by incorporating:
    1. Demand considerations: Edges connecting nodes with high combined demand
       are penalized if they would likely overload a vehicle.
    2. Angular proximity: Nodes that are close in angle from the depot are
       encouraged to be served by the same vehicle.
    3. Closeness to depot from destination nodes.

    Args:
        distance_matrix: n x n matrix of distances between nodes.
        coordinates: n x 2 matrix of node coordinates (x, y).
        demands: n-dimensional vector of customer demands.
        capacity: Integer representing vehicle capacity.

    Returns:
        A heuristic matrix of the same shape as distance_matrix,
        representing the desirability of including each edge in a solution.
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Calculate angles relative to the depot
    depot_x, depot_y = coordinates[0]
    angles = np.arctan2(coordinates[:, 1] - depot_y, coordinates[:, 0] - depot_x)

    for i in range(n):
        for j in range(n):
            if i == j:
                heuristic_matrix[i, j] = 0  # Disallow self-loops
                continue

            distance = distance_matrix[i, j]

            # Base heuristic: inverse distance
            heuristic_value = 1 / (distance + 1e-9) # prevent division by zero

            # Demand penalty: Penalize edges that would lead to overloading vehicles
            combined_demand = demands[i] + demands[j]
            if combined_demand > capacity / 2:  # Penalize edges likely to cause overloading
                heuristic_value *= (capacity / (combined_demand + 1e-9)) # Penalize more for higher overload

            # Angular proximity: Encourage connecting nodes with similar angles (close on the map relative to depot)
            angle_diff = abs(angles[i] - angles[j])
            angle_diff = min(angle_diff, 2 * np.pi - angle_diff)  # Ensure the shorter angular distance

            angle_penalty = 1 - (angle_diff / np.pi)  # Higher if angles are similar, close to 1 if similar, close to 0 if opposite
            heuristic_value *= angle_penalty
            
            #Closeness of destination to depot (favor shorter returns)
            depot_distance = distance_matrix[j,0]
            heuristic_value /= (depot_distance + 1e-9)**0.5

            heuristic_matrix[i, j] = heuristic_value

    return heuristic_matrix
```
