```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """Combines normalized distances, adaptive demand penalty, depot proximity, and centrality."""
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix)

    # Normalize distances
    max_distance = np.max(distance_matrix)
    normalized_distances = distance_matrix / (max_distance + 1e-6)

    # Calculate center of mass (excluding depot)
    center_x = np.mean(coordinates[1:, 0])
    center_y = np.mean(coordinates[1:, 1])

    total_demand = np.sum(demands[1:])
    demand_weighted_dist_to_depot = np.sum(demands[1:] * distance_matrix[0, 1:]) / total_demand if total_demand > 0 else np.mean(distance_matrix[0,1:])
    # Adaptive demand penalty factor (adjust during search)
    demand_penalty_factor = 1.0

    for i in range(n):
        for j in range(n):
            if i == j:
                continue

            heuristic_value = 1 / (normalized_distances[i, j] + 1e-6)

            # Adaptive demand penalty
            excess_demand = max(0, demands[i] + demands[j] - capacity)
            demand_penalty = np.exp(-demand_penalty_factor * excess_demand / capacity)
            heuristic_value *= demand_penalty

            # Depot proximity
            depot_distance_i = distance_matrix[0, i] / (max_distance + 1e-6)
            depot_distance_j = distance_matrix[0, j] / (max_distance + 1e-6)
            depot_proximity = np.exp(-5 * (depot_distance_i + depot_distance_j))
            heuristic_value *= depot_proximity

            # Centrality component
            center_distance_i = np.sqrt((coordinates[i, 0] - center_x)**2 + (coordinates[i, 1] - center_y)**2)
            center_distance_j = np.sqrt((coordinates[j, 0] - center_x)**2 + (coordinates[j, 1] - center_y)**2)
            avg_center_distance = (center_distance_i + center_distance_j) / 2
            centrality_component = np.exp(-avg_center_distance / (demand_weighted_dist_to_depot + 1e-6))
            heuristic_value *= centrality_component

            heuristic_matrix[i, j] = heuristic_value

    # Sparsification (dynamic threshold)
    distance_threshold = np.percentile(distance_matrix[distance_matrix > 0], 75)
    heuristic_matrix[distance_matrix > distance_threshold] = 0
    heuristic_matrix[distance_matrix == 0] = 0

    return heuristic_matrix
```
