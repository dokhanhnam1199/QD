```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics for solving CVRP via stochastic solution sampling.

    Args:
        distance_matrix (np.ndarray): Distance matrix (shape: n by n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n by 2).
        demands (np.ndarray): Vector of customer demands (shape: n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n by n).
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Initialize with inverse distance
    heuristic_matrix = 1 / (distance_matrix + 1e-9) # Add a small constant to avoid division by zero

    # Penalize edges that would likely lead to exceeding capacity constraints early
    for i in range(1, n):
        for j in range(1, n):
            if i != j:
                # Estimate the potential load of a route including edge (i, j)
                # A simple estimation based on the average demand. This may not be perfectly correct but serves as a guide.
                estimated_load = demands[i] + demands[j]  # Directly demand of two nodes
                if estimated_load > capacity:
                     heuristic_matrix[i,j] = heuristic_matrix[i,j] * 0.1 #Very discouraged
                     heuristic_matrix[j,i] = heuristic_matrix[j,i] * 0.1

                # Discourage connecting two far away points when capacity is relatively small compared to total demands
                elif capacity < np.sum(demands) / 3 and distance_matrix[i,j] > np.mean(distance_matrix):
                      heuristic_matrix[i, j] = heuristic_matrix[i, j] * 0.5
                      heuristic_matrix[j, i] = heuristic_matrix[j, i] * 0.5

    # Boost connections to and from the depot, especially to nodes with high demand. Helps start and end routes efficiently.
    for i in range(1,n):
        heuristic_matrix[0,i] = heuristic_matrix[0,i] * (1 + demands[i]/np.mean(demands))
        heuristic_matrix[i,0] = heuristic_matrix[i,0] * (1 + demands[i]/np.mean(demands))



    # Encourage edges to close "gaps" in location, penalizing long jumps relative to location clusters

    avg_distance = np.mean(distance_matrix)
    for i in range(1,n):
        for j in range(i+1, n): #Only compute upper triangular

             if distance_matrix[i,j] > avg_distance * 1.5:
                 #Check for presence of other customers nearby.

                 nearby_customer = False
                 for k in range(1, n):
                     if k != i and k != j and distance_matrix[i,k] < avg_distance / 2 and distance_matrix[j, k] < avg_distance/2:
                         nearby_customer = True
                         break

                 if not nearby_customer:
                     heuristic_matrix[i,j] = heuristic_matrix[i,j] * 0.7 #Less promising large jump
                     heuristic_matrix[j,i] = heuristic_matrix[j,i] * 0.7

    return heuristic_matrix
```
