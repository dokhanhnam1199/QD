```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristic function for CVRP using a combination of distance, demand,
    and angle considerations for stochastic solution sampling.

    Args:
        distance_matrix (np.ndarray): Distance matrix (n x n).
        coordinates (np.ndarray): Coordinates of nodes (n x 2).
        demands (np.ndarray): Demand of each node (n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Edge prior indicators (n x n).
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # 1. Distance Component: Inverse of distance, potentially with scaling
    distance_heuristic = 1 / (distance_matrix + 1e-6)  # Add a small value to avoid division by zero

    # 2. Demand Component: Favor edges connecting nodes with smaller demands relative to capacity
    demand_factor = np.outer(demands, demands) / (capacity**2) # Outer product of demands divided by capacity squared
    demand_heuristic = 1 - np.clip(demand_factor, 0, 1)   # 1 - (demand_i * demand_j / capacity^2). Higher heuristic for low demand pairs
    np.fill_diagonal(demand_heuristic, 0)  # Ignore self-loops

    # 3. Angle Component: Penalize sharp turns (Encourage more direct routes). Calculate angle based on coordinates
    angle_heuristic = np.ones((n, n)) #initialise
    for i in range(n):
        for j in range(n):
            if i != j:
                angles = np.zeros(n) # array to save angles with each nodes to the nodes i,j.
                for k in range(n):
                  if k != i and k!=j:
                    v1 = coordinates[j] - coordinates[i]
                    v2 = coordinates[k] - coordinates[i]
                    dot_product = np.dot(v1, v2)
                    magnitudes = np.linalg.norm(v1) * np.linalg.norm(v2)
                    if magnitudes != 0:
                      angles[k] = np.arccos(np.clip(dot_product / magnitudes, -1.0, 1.0)) # Clipping the value to keep it between -1 and 1 to avoid errors when very close
                    else:
                      angles[k] = np.pi/2 # 90 deg if magnitude is zero
                angle_heuristic[i,j] = np.mean(np.exp(-angles)) # Favor edges where other nodes are on straight line

    # 4. Depot proximity bonus.
    depot_proximity_heuristic = np.ones((n, n))
    for i in range(1,n):
        depot_proximity_heuristic[0,i] = 2
        depot_proximity_heuristic[i,0] = 2 #Return to the start gives a good heuristics.

    # Combine the heuristics using weighted sum or product
    heuristic_matrix = distance_heuristic * demand_heuristic * angle_heuristic * depot_proximity_heuristic

    #Set the diagonal elements to zero
    np.fill_diagonal(heuristic_matrix,0)

    return heuristic_matrix
```
