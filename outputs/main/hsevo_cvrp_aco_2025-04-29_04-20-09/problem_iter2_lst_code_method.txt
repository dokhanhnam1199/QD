{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    A heuristic function for solving the Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.\n\n    This version incorporates several factors to estimate the desirability of including each edge in a solution:\n        - Distance: Shorter distances are preferred.\n        - Demand Compatibility: Edges connecting nodes with demands that can be feasibly combined within vehicle capacity\n                                  are favored. Avoid edges which may immediately cause capacity constraint violations\n        - Angle: Edges creating sharp turns are penalized (to encourage smoother routes). Depot visits are incentivized if capacity isn't sufficient.\n        - Centrality: Favor edges near the 'center' of gravity of all customer locations\n        - Depot Attraction: A higher probability of going to the depot, especially when near vehicle capacity.\n\n    Args:\n        distance_matrix (np.ndarray): A matrix of pairwise distances between nodes (n x n).\n        coordinates (np.ndarray): A matrix of node coordinates (n x 2).\n        demands (np.ndarray): A vector of customer demands (n).  depot demand assumed to be 0\n        capacity (int): The vehicle capacity.\n\n    Returns:\n        np.ndarray: A matrix of heuristic values indicating the desirability of including each edge (n x n).\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n\n    # Calculate the center of gravity of customer locations (excluding the depot).\n    center_x = np.mean(coordinates[1:, 0])\n    center_y = np.mean(coordinates[1:, 1])\n\n    # Demand-weighted average distance to depot. If high, routes are more decentralized.\n    total_demand = np.sum(demands[1:])  # Total demand of all customers\n    demand_weighted_dist_to_depot = np.sum(demands[1:] * distance_matrix[0, 1:]) / total_demand if total_demand > 0 else 0\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristic_matrix[i, j] = 0  # No self-loops\n                continue\n\n            distance = distance_matrix[i, j]\n\n            # Distance component: inversely proportional to distance\n            distance_component = 1 / (distance + 1e-6)  # avoid divide by zero\n\n            # Demand compatibility component: Penalize edges which could cause immediate capacity violation\n            demand_component = 1.0\n            if i != 0 and j != 0 and demands[i] + demands[j] > capacity:\n                demand_component = 0.1  # Severely penalize potentially invalid route segments\n\n\n            # Angle component: Penalize sharp turns by looking at nearby nodes.\n            angle_component = 1.0\n            if i != 0 and j != 0:  # Only consider angles for customer-customer edges. Don't penalize edges *to* depot.\n\n                # Find k, such that the nodes j, i and k form an angle\n                angles = []\n\n                for k in range(n): # considers all neighbours of i\n                    if (k!=i and k!=j):\n                        v1 = coordinates[i]-coordinates[j]\n                        v2 = coordinates[k]-coordinates[i]\n                        dot_product = np.dot(v1, v2)\n                        magnitudes = np.linalg.norm(v1) * np.linalg.norm(v2)\n                        if magnitudes == 0:\n                            angle = 0 #Avoid NaN for superimposed coords\n                        else:\n                            angle = np.arccos(dot_product / magnitudes)\n                        angles.append(angle)\n                #We penalize sharpest turn possible. Penalties can accumulate\n                if len(angles)>0:\n                    angle_component = min(np.degrees(angles) / 180.0)\n\n            # Centrality component: Favor edges closer to the center of customer locations.\n            center_distance = (np.sqrt((coordinates[i, 0] - center_x)**2 + (coordinates[i, 1] - center_y)**2) +\n                               np.sqrt((coordinates[j, 0] - center_x)**2 + (coordinates[j, 1] - center_y)**2)) / 2\n\n            centrality_component = np.exp(-center_distance / demand_weighted_dist_to_depot if demand_weighted_dist_to_depot>0 else 1) #Scale the centrality measure\n\n            #Depot attraction Component: Incentivise returning to the depot, higher chance if close to capacity\n            depot_component = 1.0\n            if i!=0: #Going from customer i to Depot\n                load_before_depot = demands[i] #assuming last delivery before depot has roughly this load\n                depot_component = (1 + np.exp(load_before_depot/capacity)) / 2\n\n            heuristic_matrix[i, j] = (distance_component * demand_component * (1 - angle_component) * centrality_component * depot_component)\n\n    return heuristic_matrix\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristics for Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.\n\n    This version incorporates several factors to estimate the desirability of each edge:\n    - Distance: Shorter distances are preferred.\n    - Demand Compatibility: Edges connecting nodes with combined demands less than the capacity are favored.\n    - Closeness to Depot: Edges connecting nodes far from the depot are penalized.\n    - Angle to Depot: Encourages connections that form 'rounder' routes (avoiding long, thin chains).\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix between nodes (n x n).\n        coordinates (np.ndarray): Euclidean coordinates of nodes (n x 2).\n        demands (np.ndarray): Customer demands (n). Depot demand is assumed to be 0.\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (n x n).\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n\n    # Normalize distance to be in [0, 1]\n    max_distance = np.max(distance_matrix[distance_matrix != np.inf])  # Avoid inf values\n    normalized_distance = distance_matrix / max_distance\n\n    # Adjustments for avoiding division by zero and inf values.\n    normalized_distance = np.where(normalized_distance == 0, 1e-6, normalized_distance)\n\n    # Calculate angles between nodes and the depot.\n    depot_x, depot_y = coordinates[0]\n    angles = np.arctan2(coordinates[:, 1] - depot_y, coordinates[:, 0] - depot_x)\n\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                # Base heuristic: inverse of distance\n                heuristic_value = 1 / normalized_distance[i, j]\n\n                # Demand compatibility: Penalize edges where combined demand exceeds capacity.\n                if demands[i] + demands[j] > capacity and i != 0 and j != 0: #Except for going to depot\n                     heuristic_value *= 0.1  #Strong penalty\n                elif (demands[i] > capacity or demands[j] > capacity) and i != 0 and j!=0:\n                     heuristic_value *= 0.01\n\n\n                # Closeness to depot: Nodes far from the depot should be prioritized\n                #Penalize if both nodes are close to the depot\n\n                depot_distance_i = distance_matrix[0, i] / max_distance\n                depot_distance_j = distance_matrix[0, j] / max_distance\n                if i != 0 and j != 0:\n                     if depot_distance_i < 0.2 and depot_distance_j < 0.2:\n                          heuristic_value *= 0.5\n\n\n                # Angle difference penalty. Avoids overly 'thin' routes.\n                angle_diff = abs(angles[i] - angles[j])\n                heuristic_value *= np.exp(-2 * angle_diff)  # Exponential penalty\n                heuristic_matrix[i, j] = heuristic_value\n\n    return heuristic_matrix\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Enhanced heuristics for CVRP based on distance, demand, and angular considerations.\n\n    This version considers:\n    1. Inverse distance: Shorter distances are preferred.\n    2. Demand factor: Edges connecting to nodes with higher demand are penalized\n       if including them might lead to capacity violations on the current route.\n    3. Angular proximity: Nodes closer in angle from the depot are preferred,\n       encouraging more compact routes.\n    4. Depot proximity: Edges closer to depot are preferred.\n    \"\"\"\n\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n\n    # Calculate angles from depot\n    depot_coords = coordinates[0]\n    angles = np.arctan2(coordinates[:, 1] - depot_coords[1], coordinates[:, 0] - depot_coords[0])\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristic_matrix[i, j] = 0  # No self-loops\n                continue\n\n            distance_factor = 1 / distance_matrix[i, j] if distance_matrix[i, j] > 0 else 0  # Avoid division by zero\n            demand_factor = 1.0\n\n            # Prioritize edges from the depot (node 0)\n            if i == 0 or j == 0:\n                depot_proximity = 1.5 # Give depot edges a boost. Experiment.\n            else:\n                depot_proximity = 1.0\n\n            # Penalize edges if demand is high (especially for neighbors of nodes with already large demand)\n            # The idea is to encourage smaller routes near the depot and prevent overstuffing of vehicles too early.\n            demand_penalty = 1.0\n            if demands[i] > capacity / 4 or demands[j] > capacity / 4:  #Tune the factor.\n                demand_penalty = 0.7  # Slightly reduce probability of high-demand edge.\n            if (demands[i] + demands[j]) > capacity / 2: # Further penalty if together high.\n                demand_penalty = 0.5\n\n\n            # Angular proximity (favor nodes closer in angle relative to depot).\n            angle_diff = abs(angles[i] - angles[j])\n            angular_factor = 1 / (angle_diff + 0.1) #Add a small constanst to avoid divergence,\n\n            heuristic_matrix[i, j] = distance_factor * demand_factor * angular_factor * depot_proximity\n            heuristic_matrix[i, j] = np.clip(heuristic_matrix[i, j], 0, 1e6) # Clip large values.\n\n    return heuristic_matrix\n\n[Heuristics 4th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    A heuristic function for the Capacitated Vehicle Routing Problem (CVRP).\n    It prioritizes edges based on distance, demand, and angular proximity to the depot.\n\n    Args:\n        distance_matrix: A numpy array of shape (n, n) representing the distance between each pair of nodes.\n        coordinates: A numpy array of shape (n, 2) representing the Euclidean coordinates of each node.\n        demands: A numpy array of shape (n,) representing the demand of each node.\n        capacity: An integer representing the capacity of each vehicle.\n\n    Returns:\n        A numpy array of shape (n, n) representing the prior indicators of how promising\n        it is to include each edge in a solution.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n\n    # Depot coordinates\n    depot_x, depot_y = coordinates[0]\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristic_matrix[i, j] = 0  # No self-loops\n                continue\n\n            distance_factor = 1 / distance_matrix[i, j]  # Shorter distances are better\n\n            # Demand factor: Penalize edges connecting high-demand nodes to each other\n            demand_factor = 1 / (demands[i] + demands[j] + 1e-6) # Add a small constant to avoid division by zero.\n\n            # Angular proximity to depot: Prioritize edges that contribute to routes returning to depot.\n            # Calculate angles between nodes and depot\n            angle_i = np.arctan2(coordinates[i][1] - depot_y, coordinates[i][0] - depot_x)\n            angle_j = np.arctan2(coordinates[j][1] - depot_y, coordinates[j][0] - depot_x)\n            angle_diff = np.abs(angle_i - angle_j)\n            angle_factor = 1 / (np.minimum(angle_diff, 2 * np.pi - angle_diff) + 1e-6) # Small angle diff is favored\n\n            heuristic_matrix[i, j] = distance_factor * demand_factor * angle_factor\n\n    return heuristic_matrix\n\n[Heuristics 5th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristics for CVRP based on distance, demand, and node proximity to depot.\n    This version incorporates depot proximity and demand considerations into the heuristic.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n\n    # Inverse distance, with a small value added to prevent division by zero\n    inverse_distance = 1 / (distance_matrix + 1e-9)\n\n    # Depot proximity: favor edges connecting to nodes closer to the depot (node 0)\n    depot_distances = distance_matrix[0, :]\n    depot_proximity_i = np.tile(depot_distances, (n, 1))\n    depot_proximity_j = np.tile(depot_distances, (n, 1)).T\n    depot_proximity_factor = 1 / (depot_proximity_i + depot_proximity_j + 1e-9)\n\n    # Demand consideration: penalize edges connecting nodes with high combined demand\n    demand_i = np.tile(demands, (n, 1))\n    demand_j = np.tile(demands, (n, 1)).T\n    demand_factor = 1 / (demand_i + demand_j + 1e-9)\n    #Demand proximity to depot: Favor visiting customers far from depot first.\n\n    #Edge Length\n    edge_length = distance_matrix\n    max_edge_length = np.max(distance_matrix)\n\n    edge_length_factor = (max_edge_length - edge_length + 1e-9)/(max_edge_length + 1e-9) #Smallest distance gets highest values.\n\n    heuristic_matrix = inverse_distance * depot_proximity_factor * demand_factor * edge_length_factor\n    #Zero-out the diagonal\n    np.fill_diagonal(heuristic_matrix, 0)\n    return heuristic_matrix\n\n[Heuristics 6th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristic function for CVRP based on distance, demand, and node proximity to depot.\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix (n x n).\n        coordinates (np.ndarray): Euclidean coordinates of nodes (n x 2).\n        demands (np.ndarray): Customer demands (n).\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Prior indicators for each edge (n x n).\n    \"\"\"\n\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n\n    # Heuristic based on distance (shorter distances are preferred)\n    distance_heuristic = 1 / (distance_matrix + 1e-6)  # Adding a small value to avoid division by zero\n\n    # Heuristic based on demand and distance to depot: penalize edges connecting\n    # a node with high demand far from the depot to another node.\n    depot_distances = distance_matrix[0, :]\n    demand_penalty = np.zeros((n,n))\n    for i in range(n):\n      for j in range(n):\n        demand_penalty[i,j] = (demands[i] * depot_distances[i] + demands[j] * depot_distances[j])\n    demand_penalty = 1/(demand_penalty+1e-6)\n\n    # Heuristic based on angle from depot. Nodes further away angularly from the depot\n    #  should be connected later if possible to increase density around the depot\n    # which helps later on.\n    depot_x, depot_y = coordinates[0, 0], coordinates[0, 1]\n    angles = np.zeros(n)\n    for i in range(n):\n        if i != 0:\n            dx = coordinates[i, 0] - depot_x\n            dy = coordinates[i, 1] - depot_y\n            angles[i] = np.arctan2(dy, dx)\n\n    angle_diff_matrix = np.zeros((n,n))\n    for i in range(n):\n      for j in range(n):\n          angle_diff_matrix[i,j] = abs(angles[i]-angles[j])\n\n    angle_diff_penalty = 1/(angle_diff_matrix+1e-6)\n\n\n    heuristic_matrix = (0.6 * distance_heuristic + 0.2 * demand_penalty + 0.2 * angle_diff_penalty)\n\n    # Ensure depot connections are always relatively preferred, crucial for feasibility.\n    for i in range(1, n):\n        heuristic_matrix[0, i] *= 1.2 # Encourage returning to depot, or expanding from it.\n        heuristic_matrix[i, 0] *= 1.2\n\n    return heuristic_matrix\n\n[Heuristics 7th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristic function for CVRP based on distance, demand, and node proximity to depot.\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix (n x n).\n        coordinates (np.ndarray): Euclidean coordinates of nodes (n x 2).\n        demands (np.ndarray): Customer demands (n).\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Prior indicators for each edge (n x n).\n    \"\"\"\n\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n\n    # Heuristic based on distance (shorter distances are preferred)\n    distance_heuristic = 1 / (distance_matrix + 1e-6)  # Adding a small value to avoid division by zero\n\n    # Heuristic based on demand and distance to depot: penalize edges connecting\n    # a node with high demand far from the depot to another node.\n    depot_distances = distance_matrix[0, :]\n    demand_penalty = np.zeros((n,n))\n    for i in range(n):\n      for j in range(n):\n        demand_penalty[i,j] = (demands[i] * depot_distances[i] + demands[j] * depot_distances[j])\n    demand_penalty = 1/(demand_penalty+1e-6)\n\n    # Heuristic based on angle from depot. Nodes further away angularly from the depot\n    #  should be connected later if possible to increase density around the depot\n    # which helps later on.\n    depot_x, depot_y = coordinates[0, 0], coordinates[0, 1]\n    angles = np.zeros(n)\n    for i in range(n):\n        if i != 0:\n            dx = coordinates[i, 0] - depot_x\n            dy = coordinates[i, 1] - depot_y\n            angles[i] = np.arctan2(dy, dx)\n\n    angle_diff_matrix = np.zeros((n,n))\n    for i in range(n):\n      for j in range(n):\n          angle_diff_matrix[i,j] = abs(angles[i]-angles[j])\n\n    angle_diff_penalty = 1/(angle_diff_matrix+1e-6)\n\n\n    heuristic_matrix = (0.6 * distance_heuristic + 0.2 * demand_penalty + 0.2 * angle_diff_penalty)\n\n    # Ensure depot connections are always relatively preferred, crucial for feasibility.\n    for i in range(1, n):\n        heuristic_matrix[0, i] *= 1.2 # Encourage returning to depot, or expanding from it.\n        heuristic_matrix[i, 0] *= 1.2\n\n    return heuristic_matrix\n\n[Heuristics 8th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristic function for solving Capacitated Vehicle Routing Problem (CVRP)\n    via stochastic solution sampling.  This version incorporates more factors\n    than the trivial version.\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix (n x n).\n        coordinates (np.ndarray): Euclidean coordinates of nodes (n x 2).\n        demands (np.ndarray): Customer demands (n).\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Prior indicators for edges (n x n).\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros((n, n))\n\n    # Calculate a capacity penalty. Nodes with higher demand should be visited earlier\n    # or connected to the depot, as the available vehicle space becomes limited.\n    demand_normalized = demands / np.max(demands) #demand between 0 and 1\n    demand_penalty = np.zeros((n, n))\n    for i in range(n):\n      for j in range(n):\n        demand_penalty[i,j] = demand_normalized[i] + demand_normalized[j]\n    demand_penalty = np.clip(demand_penalty,0.0,1.0)\n    \n\n    # Distance heuristic: Shorter distances are generally preferred\n    distance_heuristic = 1 / (distance_matrix + 1e-6)  # Adding a small value to prevent division by zero\n\n\n    # Depot affinity heuristic: Encourage connections to the depot,\n    # particularly for nodes with high demand.\n    depot_affinity = np.zeros((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i == 0 or j == 0: #either i or j is the depot\n                depot_affinity[i, j] = 1.0 # high priority if going from/to depot\n            else:\n                 depot_affinity[i,j] = 0.0\n\n    # Coordinates based routing: closer coordinate pairs are considered first.\n\n    coordinate_distance = np.zeros((n,n))\n\n    for i in range(n):\n      for j in range(n):\n        coordinate_distance[i,j] = np.linalg.norm(coordinates[i,:] - coordinates[j,:])\n    coordinate_heuristic = 1 / (coordinate_distance+1e-6)\n\n    # Combine the heuristics (weighted sum)\n\n    heuristics = (0.6 * distance_heuristic\n                  + 0.15 * depot_affinity\n                  + 0.15 * coordinate_heuristic\n                  + 0.1 * (1-demand_penalty) )\n\n    # Set diagonal elements to zero to avoid self-loops\n    for i in range(n):\n        heuristics[i, i] = 0\n\n    return heuristics\n\n[Heuristics 9th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristics for Capacitated Vehicle Routing Problem (CVRP) using a combination of\n    distance, demand, and proximity to the depot.\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix (n x n).\n        coordinates (np.ndarray): Euclidean coordinates of nodes (n x 2).\n        demands (np.ndarray): Customer demands (n).\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Prior indicators for each edge (n x n). Higher values indicate\n                    more promising edges.\n    \"\"\"\n\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros((n, n))\n\n    # Inverse distance (as in v1, but more emphasized)\n    distance_heuristic = 1 / (distance_matrix + 1e-9)  # Add small value to avoid division by zero\n    heuristics += distance_heuristic * 2.0 # weighting increased.\n\n    # Demand-based heuristic: Penalize edges that connect nodes with high combined demand\n    # relative to the vehicle capacity.  This encourages the creation of routes\n    # that are feasible (don't overload vehicles).\n\n    demand_matrix = np.zeros((n, n))\n    for i in range(n):\n        for j in range(n):\n            demand_matrix[i, j] = demands[i] + demands[j]\n\n    demand_heuristic = np.clip(1 - (demand_matrix / capacity), 0, 1) # between 0 and 1\n\n    heuristics += demand_heuristic * 1.0 #consider demand constraints\n\n\n    # Depot proximity heuristic:  Nodes far from the depot are penalized\n    # making connections from distant nodes to other nodes less favorable.\n    # This tries to cluster nodes near the depot together.\n\n    depot_distances = distance_matrix[0, :] #Distances from depot to each other node\n    depot_proximity_matrix = np.zeros((n, n))\n    for i in range(n):\n        for j in range(n):\n            depot_proximity_matrix[i, j] = 1/(depot_distances[i]+ depot_distances[j]+ 1e-9)\n\n    # Normalize depot_proximity_matrix\n    max_val = np.max(depot_proximity_matrix)\n    if max_val > 0:\n        depot_proximity_matrix = depot_proximity_matrix / max_val\n\n    heuristics += depot_proximity_matrix * 0.5 #weighting of 0.5\n\n    # Make diagonal elements zero, which is important.\n    for i in range(n):\n        heuristics[i, i] = 0\n\n    return heuristics\n\n[Heuristics 10th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristics for Capacitated Vehicle Routing Problem (CVRP) using a combination of\n    distance, demand, and proximity to the depot.\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix (n x n).\n        coordinates (np.ndarray): Euclidean coordinates of nodes (n x 2).\n        demands (np.ndarray): Customer demands (n).\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Prior indicators for each edge (n x n). Higher values indicate\n                    more promising edges.\n    \"\"\"\n\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros((n, n))\n\n    # Inverse distance (as in v1, but more emphasized)\n    distance_heuristic = 1 / (distance_matrix + 1e-9)  # Add small value to avoid division by zero\n    heuristics += distance_heuristic * 2.0 # weighting increased.\n\n    # Demand-based heuristic: Penalize edges that connect nodes with high combined demand\n    # relative to the vehicle capacity.  This encourages the creation of routes\n    # that are feasible (don't overload vehicles).\n\n    demand_matrix = np.zeros((n, n))\n    for i in range(n):\n        for j in range(n):\n            demand_matrix[i, j] = demands[i] + demands[j]\n\n    demand_heuristic = np.clip(1 - (demand_matrix / capacity), 0, 1) # between 0 and 1\n\n    heuristics += demand_heuristic * 1.0 #consider demand constraints\n\n\n    # Depot proximity heuristic:  Nodes far from the depot are penalized\n    # making connections from distant nodes to other nodes less favorable.\n    # This tries to cluster nodes near the depot together.\n\n    depot_distances = distance_matrix[0, :] #Distances from depot to each other node\n    depot_proximity_matrix = np.zeros((n, n))\n    for i in range(n):\n        for j in range(n):\n            depot_proximity_matrix[i, j] = 1/(depot_distances[i]+ depot_distances[j]+ 1e-9)\n\n    # Normalize depot_proximity_matrix\n    max_val = np.max(depot_proximity_matrix)\n    if max_val > 0:\n        depot_proximity_matrix = depot_proximity_matrix / max_val\n\n    heuristics += depot_proximity_matrix * 0.5 #weighting of 0.5\n\n    # Make diagonal elements zero, which is important.\n    for i in range(n):\n        heuristics[i, i] = 0\n\n    return heuristics\n\n[Heuristics 11th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Generates a heuristic matrix for the Capacitated Vehicle Routing Problem (CVRP)\n    based on a combination of distance, demand, and angle considerations.\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix between nodes (n x n).\n        coordinates (np.ndarray): Euclidean coordinates of nodes (n x 2).\n        demands (np.ndarray): Vector of customer demands (n).\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Heuristic matrix (n x n) representing the desirability of including each edge.\n    \"\"\"\n\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n\n    # Parameters to control the influence of each factor\n    distance_weight = 1.0\n    demand_weight = 0.5  # Penalize edges connecting to high-demand nodes\n    angle_weight = 0.3  # Encourage edges forming \"good\" turns (smaller angles)\n    capacity_proximity_weight = 0.2 # Encourage edges connecting nodes with demands close to the residual capacity after depot trip\n    # Iterate through all possible edges\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristic_matrix[i, j] = 0  # No self-loops\n                continue\n            if distance_matrix[i, j] == 0:\n                heuristic_matrix[i, j] = 0\n                continue\n\n            # Distance component (shorter distance is better)\n            distance_heuristic = distance_weight / distance_matrix[i, j]\n\n            # Demand component (lower demand is generally better)\n            # We penalize connecting to high-demand nodes\n            demand_heuristic = 1.0 - demand_weight * (demands[i] + demands[j]) / (2*capacity)\n            demand_heuristic = max(demand_heuristic, 0.01) # Avoid zero values, ensures at least a minimal chance to consider larger demand nodes.\n\n            # Angle component (smaller angles are better - less turning)\n            # Calculate angle between vectors (i -> depot) and (i -> j)\n            if i != 0:\n                vector_depot = coordinates[0] - coordinates[i]\n                vector_j = coordinates[j] - coordinates[i]\n\n                #Normalize the vectors. Avoid division by zero if both locations are at the same point\n                norm_depot = np.linalg.norm(vector_depot)\n                norm_j = np.linalg.norm(vector_j)\n                if norm_depot == 0 or norm_j == 0:\n                    angle = 0  #Angle undefined. Set to 0, i.e. no penalty\n                else:\n                    vector_depot = vector_depot / norm_depot\n                    vector_j = vector_j / norm_j\n\n                    dot_product = np.dot(vector_depot, vector_j)\n                    angle = np.arccos(np.clip(dot_product, -1.0, 1.0))  # Clip for numerical stability\n\n                angle_heuristic = 1.0 - angle_weight * angle / np.pi # Normalize the angle to [0,1]. Pi is the max possible angle. Inverting the scale.\n                angle_heuristic = max(angle_heuristic, 0.01)  # Avoid zero values\n            else:\n                angle_heuristic = 1.0 #From the depot any turn is acceptable\n\n            #Capacity Proximity Component\n\n            capacity_proximity_heuristic = 1.0- np.abs(capacity-demands[i])/(capacity+1e-9)\n            capacity_proximity_heuristic = max(capacity_proximity_heuristic,0.01)\n\n\n\n            # Combine the heuristics\n            heuristic_matrix[i, j] = (\n                distance_heuristic * demand_heuristic * angle_heuristic * capacity_proximity_heuristic\n            )\n\n    return heuristic_matrix\n\n[Heuristics 12th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Generates a heuristic matrix for the Capacitated Vehicle Routing Problem (CVRP)\n    based on a combination of distance, demand, and angle considerations.\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix between nodes (n x n).\n        coordinates (np.ndarray): Euclidean coordinates of nodes (n x 2).\n        demands (np.ndarray): Vector of customer demands (n).\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Heuristic matrix (n x n) representing the desirability of including each edge.\n    \"\"\"\n\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n\n    # Parameters to control the influence of each factor\n    distance_weight = 1.0\n    demand_weight = 0.5  # Penalize edges connecting to high-demand nodes\n    angle_weight = 0.3  # Encourage edges forming \"good\" turns (smaller angles)\n    capacity_proximity_weight = 0.2 # Encourage edges connecting nodes with demands close to the residual capacity after depot trip\n    # Iterate through all possible edges\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristic_matrix[i, j] = 0  # No self-loops\n                continue\n            if distance_matrix[i, j] == 0:\n                heuristic_matrix[i, j] = 0\n                continue\n\n            # Distance component (shorter distance is better)\n            distance_heuristic = distance_weight / distance_matrix[i, j]\n\n            # Demand component (lower demand is generally better)\n            # We penalize connecting to high-demand nodes\n            demand_heuristic = 1.0 - demand_weight * (demands[i] + demands[j]) / (2*capacity)\n            demand_heuristic = max(demand_heuristic, 0.01) # Avoid zero values, ensures at least a minimal chance to consider larger demand nodes.\n\n            # Angle component (smaller angles are better - less turning)\n            # Calculate angle between vectors (i -> depot) and (i -> j)\n            if i != 0:\n                vector_depot = coordinates[0] - coordinates[i]\n                vector_j = coordinates[j] - coordinates[i]\n\n                #Normalize the vectors. Avoid division by zero if both locations are at the same point\n                norm_depot = np.linalg.norm(vector_depot)\n                norm_j = np.linalg.norm(vector_j)\n                if norm_depot == 0 or norm_j == 0:\n                    angle = 0  #Angle undefined. Set to 0, i.e. no penalty\n                else:\n                    vector_depot = vector_depot / norm_depot\n                    vector_j = vector_j / norm_j\n\n                    dot_product = np.dot(vector_depot, vector_j)\n                    angle = np.arccos(np.clip(dot_product, -1.0, 1.0))  # Clip for numerical stability\n\n                angle_heuristic = 1.0 - angle_weight * angle / np.pi # Normalize the angle to [0,1]. Pi is the max possible angle. Inverting the scale.\n                angle_heuristic = max(angle_heuristic, 0.01)  # Avoid zero values\n            else:\n                angle_heuristic = 1.0 #From the depot any turn is acceptable\n\n            #Capacity Proximity Component\n\n            capacity_proximity_heuristic = 1.0- np.abs(capacity-demands[i])/(capacity+1e-9)\n            capacity_proximity_heuristic = max(capacity_proximity_heuristic,0.01)\n\n\n\n            # Combine the heuristics\n            heuristic_matrix[i, j] = (\n                distance_heuristic * demand_heuristic * angle_heuristic * capacity_proximity_heuristic\n            )\n\n    return heuristic_matrix\n\n[Heuristics 13th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristics function for CVRP using a combination of distance, demand,\n    and angle considerations. This version attempts to incorporate the\n    vehicle capacity constraint more directly.\n\n    Args:\n        distance_matrix: Distance between nodes (n x n).\n        coordinates: Node coordinates (n x 2).\n        demands: Node demands (n).\n        capacity: Vehicle capacity.\n\n    Returns:\n        A matrix (n x n) representing the desirability of each edge.\n    \"\"\"\n\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n\n    # Parameters (tunable)\n    alpha = 1.0  # Weight for distance\n    beta = 1.0   # Weight for demand\n    gamma = 1.0  # Weight for angle\n\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                # Distance component (inverse of distance)\n                distance_component = 1 / distance_matrix[i, j]\n\n                # Demand component: penalize links that connect nodes where sum\n                # of demands would largely exceed capacity.  Higher values when demands are small.\n                demand_component = 1.0 / (1.0 + np.exp(beta * (demands[i] + demands[j] - capacity/2.0))) #Sigmoid centered on capacity/2\n\n                # Angle component (encourage gradual turns; penalize sharp turns)\n                # Dot product of vectors (depot -> i) and (depot -> j). Smaller angle implies better\n                if i != 0 and j != 0:  #Exclude links to depot when calc. angle component.\n                    vector_i = coordinates[i] - coordinates[0]\n                    vector_j = coordinates[j] - coordinates[0]\n                    dot_product = np.dot(vector_i, vector_j) / (np.linalg.norm(vector_i) * np.linalg.norm(vector_j) + 1e-9) # +1e-9 to avoid division by zero.\n                    angle_component = (1.0 + dot_product)/2.0 #scale from -1..1 to 0..1\n\n                elif i !=0: #connecting a node to the depot\n                    vector_i = coordinates[i] - coordinates[0]\n                    angle_component = 0.5 # Neutral value, not particularly useful.\n\n                elif j != 0:\n                    vector_j = coordinates[j] - coordinates[0]\n                    angle_component = 0.5  # Neutral value, not particularly useful.\n                else:\n                     angle_component = 0.5  #Neutral - connecting depot to depot has no real angle.\n\n\n                # Combine components\n                heuristic_matrix[i, j] = (alpha * distance_component +\n                                            beta * demand_component +\n                                            gamma * angle_component)\n\n\n    return heuristic_matrix\n\n[Heuristics 14th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristics for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.\n\n    This heuristic combines distance, demand, and node proximity to the depot to guide the search.\n    It prioritizes shorter distances, penalizes edges connecting high-demand nodes,\n    and favors edges closer to the depot (node 0) when a vehicle is likely to be near capacity.\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix (n x n) between nodes.\n        coordinates (np.ndarray): Euclidean coordinates of nodes (n x 2).\n        demands (np.ndarray): Customer demands (n).\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Prior indicators (n x n) of edge promisingness.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n\n    # Normalize demands for better scaling\n    normalized_demands = demands / np.max(demands) if np.max(demands) > 0 else demands # Prevent divide by zero\n    \n    #distance from depot\n    depot_distances = distance_matrix[0, :]  # Distances from depot to all nodes\n    normalized_depot_distances = depot_distances / np.max(depot_distances)\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristic_matrix[i, j] = 0  # Avoid self-loops\n            else:\n                # Base: Inverse distance\n                heuristic = 1 / (distance_matrix[i, j] + 1e-9)  # Add a small constant to avoid division by zero\n\n                # Penalize high-demand connections\n                heuristic *= (1 - (normalized_demands[i] + normalized_demands[j]) / 2)\n                \n                #Bonus for edges closer to depot. Encourages returning to depot when near capacity.\n                heuristic += 0.1*(1- (normalized_depot_distances[i] + normalized_depot_distances[j])/2)\n                \n                heuristic_matrix[i, j] = heuristic\n\n    return heuristic_matrix\n\n[Heuristics 15th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristics for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.\n\n    This heuristic combines distance, demand, and node proximity to the depot to guide the search.\n    It prioritizes shorter distances, penalizes edges connecting high-demand nodes,\n    and favors edges closer to the depot (node 0) when a vehicle is likely to be near capacity.\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix (n x n) between nodes.\n        coordinates (np.ndarray): Euclidean coordinates of nodes (n x 2).\n        demands (np.ndarray): Customer demands (n).\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Prior indicators (n x n) of edge promisingness.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n\n    # Normalize demands for better scaling\n    normalized_demands = demands / np.max(demands) if np.max(demands) > 0 else demands # Prevent divide by zero\n    \n    #distance from depot\n    depot_distances = distance_matrix[0, :]  # Distances from depot to all nodes\n    normalized_depot_distances = depot_distances / np.max(depot_distances)\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristic_matrix[i, j] = 0  # Avoid self-loops\n            else:\n                # Base: Inverse distance\n                heuristic = 1 / (distance_matrix[i, j] + 1e-9)  # Add a small constant to avoid division by zero\n\n                # Penalize high-demand connections\n                heuristic *= (1 - (normalized_demands[i] + normalized_demands[j]) / 2)\n                \n                #Bonus for edges closer to depot. Encourages returning to depot when near capacity.\n                heuristic += 0.1*(1- (normalized_depot_distances[i] + normalized_depot_distances[j])/2)\n                \n                heuristic_matrix[i, j] = heuristic\n\n    return heuristic_matrix\n\n[Heuristics 16th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Newtonian Heuristics for Capacitated Vehicle Routing Problem (CVRP).\n\n    This function incorporates gravity-inspired attraction, pheromone-like reinforcement,\n    and capacity considerations to generate a heuristic matrix guiding stochastic solution sampling.\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix between nodes (n x n).\n        coordinates (np.ndarray): Euclidean coordinates of nodes (n x 2).\n        demands (np.ndarray): Demand of each node (n). depot is demands[0].\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Heuristic matrix (n x n) indicating edge desirability.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n\n    # Parameters (tuned with physical intuition and experimentation)\n    gravity_constant = 1.0  # Strength of attraction (inverse distance)\n    pheromone_strength = 0.5  # Reinforcement of edges used in good solutions (initially 0)\n    capacity_penalty = 2.0 # Increased penalty based on approaching capacity.\n    depot_attraction = 1.5 # Bias towards traveling from depot, as most routes require this.\n    nearby_penalty = 0.8 # discourage near node.\n    # mass = demand?\n\n    # Initialize Pheromone Matrix (representing \"good routes\" seen so far) - Initially none.\n    pheromone_matrix = np.zeros((n, n)) # tracks how often the edge appears.\n\n\n    # --- Newtonian Gravitation Inspired Attraction ---\n    #   Stronger attraction between closer nodes (inverse distance).\n\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                heuristic_matrix[i, j] = gravity_constant / distance_matrix[i, j]\n\n                #Emphasize Depot connections.\n                if i == 0 or j == 0:\n                  heuristic_matrix[i, j] *= depot_attraction\n\n\n    # --- Capacity Consideration ---\n    #   Penalize edges that lead to exceeding vehicle capacity\n\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                #Approximated Penalty. Needs to see further context.\n                estimated_load = demands[j]\n                if estimated_load > capacity:\n                  heuristic_matrix[i, j] = 0 # No chance if exceeds capacity.\n                else:\n                    # Penalize based on the remaining available capacity. The closer to capacity the more penalization.\n                    remaining_capacity_ratio = (capacity - estimated_load) / capacity\n                    heuristic_matrix[i, j] *= (1 + capacity_penalty * remaining_capacity_ratio)\n\n\n    # --- Node Location Consideration ---\n    #   Discourage traveling to very nearby nodes (might create unnecessary loops).\n\n    for i in range(n):\n        for j in range(n):\n            if i !=j and distance_matrix[i,j] < np.mean(distance_matrix):\n                heuristic_matrix[i,j] *= nearby_penalty\n\n\n    # --- Normalize Heuristic Matrix ---\n    #   Ensures values are within a reasonable range. Prevents overflow.\n    heuristic_matrix = (heuristic_matrix - np.min(heuristic_matrix)) / (np.max(heuristic_matrix) - np.min(heuristic_matrix) + 1e-9)\n\n\n    return heuristic_matrix\n\n[Heuristics 17th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Newtonian Heuristics for Capacitated Vehicle Routing Problem (CVRP).\n\n    This function incorporates gravity-inspired attraction, pheromone-like reinforcement,\n    and capacity considerations to generate a heuristic matrix guiding stochastic solution sampling.\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix between nodes (n x n).\n        coordinates (np.ndarray): Euclidean coordinates of nodes (n x 2).\n        demands (np.ndarray): Demand of each node (n). depot is demands[0].\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Heuristic matrix (n x n) indicating edge desirability.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n\n    # Parameters (tuned with physical intuition and experimentation)\n    gravity_constant = 1.0  # Strength of attraction (inverse distance)\n    pheromone_strength = 0.5  # Reinforcement of edges used in good solutions (initially 0)\n    capacity_penalty = 2.0 # Increased penalty based on approaching capacity.\n    depot_attraction = 1.5 # Bias towards traveling from depot, as most routes require this.\n    nearby_penalty = 0.8 # discourage near node.\n    # mass = demand?\n\n    # Initialize Pheromone Matrix (representing \"good routes\" seen so far) - Initially none.\n    pheromone_matrix = np.zeros((n, n)) # tracks how often the edge appears.\n\n\n    # --- Newtonian Gravitation Inspired Attraction ---\n    #   Stronger attraction between closer nodes (inverse distance).\n\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                heuristic_matrix[i, j] = gravity_constant / distance_matrix[i, j]\n\n                #Emphasize Depot connections.\n                if i == 0 or j == 0:\n                  heuristic_matrix[i, j] *= depot_attraction\n\n\n    # --- Capacity Consideration ---\n    #   Penalize edges that lead to exceeding vehicle capacity\n\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                #Approximated Penalty. Needs to see further context.\n                estimated_load = demands[j]\n                if estimated_load > capacity:\n                  heuristic_matrix[i, j] = 0 # No chance if exceeds capacity.\n                else:\n                    # Penalize based on the remaining available capacity. The closer to capacity the more penalization.\n                    remaining_capacity_ratio = (capacity - estimated_load) / capacity\n                    heuristic_matrix[i, j] *= (1 + capacity_penalty * remaining_capacity_ratio)\n\n\n    # --- Node Location Consideration ---\n    #   Discourage traveling to very nearby nodes (might create unnecessary loops).\n\n    for i in range(n):\n        for j in range(n):\n            if i !=j and distance_matrix[i,j] < np.mean(distance_matrix):\n                heuristic_matrix[i,j] *= nearby_penalty\n\n\n    # --- Normalize Heuristic Matrix ---\n    #   Ensures values are within a reasonable range. Prevents overflow.\n    heuristic_matrix = (heuristic_matrix - np.min(heuristic_matrix)) / (np.max(heuristic_matrix) - np.min(heuristic_matrix) + 1e-9)\n\n\n    return heuristic_matrix\n\n[Heuristics 18th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristics for Capacitated Vehicle Routing Problem (CVRP) using a combination of distance,\n    demand, and savings-based prioritization.\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix between nodes (n x n).\n        coordinates (np.ndarray): Euclidean coordinates of nodes (n x 2).\n        demands (np.ndarray): Demand of each customer (n). depot has demand 0\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Edge prior indicators (n x n).\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros((n, n))\n\n    # Initialize with inverse distance (like v1)\n    heuristics_matrix = 1 / (distance_matrix + 1e-6) # add small number to avoid division by zero\n\n    # Savings Heuristic (Clarke-Wright)\n    savings_matrix = np.zeros((n, n))\n    for i in range(1, n):  # Exclude depot (node 0)\n        for j in range(i + 1, n): # Iterate upper triangle only to avoid duplicates. Exclude depot (node 0).\n            savings_matrix[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings_matrix[j, i] = savings_matrix[i, j]  # Make symmetric\n    # Prioritize edges connecting to the depot less in general\n    heuristics_matrix[0, :] = heuristics_matrix[0, :] * 0.5 # lower the chances to go from depot node\n\n    # Combine distance and savings\n    heuristics_matrix = 0.7 * heuristics_matrix + 0.3 * (savings_matrix / np.max(savings_matrix + 1e-6))  # Normalize savings\n    # Demand consideration: Scale edges according to total demand they enable\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                heuristics_matrix[i, j] = heuristics_matrix[i, j] / (demands[i] + demands[j] + 1e-6)\n\n\n    # Bias towards connections from nodes with high degree\n    degree_centrality = np.sum(heuristics_matrix, axis=1)\n    for i in range(n):\n        for j in range(n):\n           heuristics_matrix[i, j] *= (degree_centrality[i] + degree_centrality[j] + 1e-6)**0.5\n\n\n    # Ensure no self-loops\n    for i in range(n):\n        heuristics_matrix[i, i] = 0\n\n    return heuristics_matrix\n\n[Heuristics 19th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristics for Capacitated Vehicle Routing Problem (CVRP) using a combination of distance,\n    demand, and savings-based prioritization.\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix between nodes (n x n).\n        coordinates (np.ndarray): Euclidean coordinates of nodes (n x 2).\n        demands (np.ndarray): Demand of each customer (n). depot has demand 0\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Edge prior indicators (n x n).\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros((n, n))\n\n    # Initialize with inverse distance (like v1)\n    heuristics_matrix = 1 / (distance_matrix + 1e-6) # add small number to avoid division by zero\n\n    # Savings Heuristic (Clarke-Wright)\n    savings_matrix = np.zeros((n, n))\n    for i in range(1, n):  # Exclude depot (node 0)\n        for j in range(i + 1, n): # Iterate upper triangle only to avoid duplicates. Exclude depot (node 0).\n            savings_matrix[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings_matrix[j, i] = savings_matrix[i, j]  # Make symmetric\n    # Prioritize edges connecting to the depot less in general\n    heuristics_matrix[0, :] = heuristics_matrix[0, :] * 0.5 # lower the chances to go from depot node\n\n    # Combine distance and savings\n    heuristics_matrix = 0.7 * heuristics_matrix + 0.3 * (savings_matrix / np.max(savings_matrix + 1e-6))  # Normalize savings\n    # Demand consideration: Scale edges according to total demand they enable\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                heuristics_matrix[i, j] = heuristics_matrix[i, j] / (demands[i] + demands[j] + 1e-6)\n\n\n    # Bias towards connections from nodes with high degree\n    degree_centrality = np.sum(heuristics_matrix, axis=1)\n    for i in range(n):\n        for j in range(n):\n           heuristics_matrix[i, j] *= (degree_centrality[i] + degree_centrality[j] + 1e-6)**0.5\n\n\n    # Ensure no self-loops\n    for i in range(n):\n        heuristics_matrix[i, i] = 0\n\n    return heuristics_matrix\n\n[Heuristics 20th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Newtonian Heuristics for Capacitated Vehicle Routing Problem (CVRP).\n\n    This function combines several heuristics to estimate the desirability of including each edge\n    in the final solution.  It considers distance, demand, angle (to encourage route progression),\n    and a depot attraction factor to promote returning to the depot when necessary.\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix between nodes (n x n).\n        coordinates (np.ndarray): Euclidean coordinates of nodes (n x 2).\n        demands (np.ndarray): Vector of customer demands (n).\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: A matrix of heuristics values (n x n), indicating the desirability of each edge.\n                     Higher values suggest a more promising edge.\n    \"\"\"\n\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n\n    # Parameters (carefully chosen and tuned)\n    distance_weight = 1.0     # Controls the importance of distance\n    demand_weight = 0.5       # Controls the importance of demand compatibility\n    angle_weight = 0.2        # Controls the importance of angle (route direction)\n    depot_attraction = 2.0    # Controls the attractiveness of returning to the depot\n    visibility_exponent = 2.0 # Scales the inverse of the distance\n    demand_scaling = capacity / np.mean(demands[1:]) # Normalizes the effect of capacity\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristics[i, j] = 0  # No self-loops\n                continue\n\n            # Distance component: Inverse distance, raised to a power\n            distance_heuristic = 1 / (distance_matrix[i, j] ** visibility_exponent) if distance_matrix[i, j] > 0 else 0\n\n            # Demand component: Compatibility of demands\n            demand_heuristic = 1.0 / (demands[j] / demand_scaling + 1e-6) # avoid division by zero, scale by average demand and capacity\n            # Angle component: Encourages smoother routes.  Angle between (i->j) and (j->depot).\n            # Consider the vector from j to depot (0), and i to j. Smaller angles better.\n            if i != 0 and j != 0:\n                v1 = coordinates[0] - coordinates[j]  # Vector from j to depot\n                v2 = coordinates[i] - coordinates[j]  # Vector from j to i\n                norm_v1 = np.linalg.norm(v1)\n                norm_v2 = np.linalg.norm(v2)\n                if norm_v1 > 0 and norm_v2 > 0:\n                  angle = np.arccos(np.dot(v1, v2) / (norm_v1 * norm_v2))\n                  angle_heuristic = 1.0 / (angle + 1e-6) # Penalize sharp turns\n                else:\n                  angle_heuristic = 0.0\n            else:\n                angle_heuristic = 0.0\n\n            # Depot Attraction Component: Encourage return to depot.\n            if i != 0 and j == 0:  # Going back to depot\n                depot_heuristic = depot_attraction\n            else:\n                depot_heuristic = 1.0\n\n\n            # Combine the heuristics (weighted sum)\n            heuristics[i, j] = (\n                distance_weight * distance_heuristic +\n                demand_weight * demand_heuristic +\n                angle_weight * angle_heuristic\n            ) * depot_heuristic  # Multiplying the depot_heuristic allows it to outweigh others when necessary\n\n\n    return heuristics\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}