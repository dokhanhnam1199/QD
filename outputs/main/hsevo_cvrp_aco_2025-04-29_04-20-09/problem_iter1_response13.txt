```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics for CVRP based on distance, demand, and node proximity to depot.
    This version incorporates depot proximity and demand considerations into the heuristic.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix)

    # Inverse distance, with a small value added to prevent division by zero
    inverse_distance = 1 / (distance_matrix + 1e-9)

    # Depot proximity: favor edges connecting to nodes closer to the depot (node 0)
    depot_distances = distance_matrix[0, :]
    depot_proximity_i = np.tile(depot_distances, (n, 1))
    depot_proximity_j = np.tile(depot_distances, (n, 1)).T
    depot_proximity_factor = 1 / (depot_proximity_i + depot_proximity_j + 1e-9)

    # Demand consideration: penalize edges connecting nodes with high combined demand
    demand_i = np.tile(demands, (n, 1))
    demand_j = np.tile(demands, (n, 1)).T
    demand_factor = 1 / (demand_i + demand_j + 1e-9)
    #Demand proximity to depot: Favor visiting customers far from depot first.

    #Edge Length
    edge_length = distance_matrix
    max_edge_length = np.max(distance_matrix)

    edge_length_factor = (max_edge_length - edge_length + 1e-9)/(max_edge_length + 1e-9) #Smallest distance gets highest values.

    heuristic_matrix = inverse_distance * depot_proximity_factor * demand_factor * edge_length_factor
    #Zero-out the diagonal
    np.fill_diagonal(heuristic_matrix, 0)
    return heuristic_matrix
```
