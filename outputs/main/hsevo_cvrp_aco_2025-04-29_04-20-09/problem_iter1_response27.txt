```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Generates a heuristic matrix for the Capacitated Vehicle Routing Problem (CVRP)
    based on a combination of distance, demand, and angle considerations.

    Args:
        distance_matrix (np.ndarray): Distance matrix between nodes (n x n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (n x 2).
        demands (np.ndarray): Vector of customer demands (n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Heuristic matrix (n x n) representing the desirability of including each edge.
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Parameters to control the influence of each factor
    distance_weight = 1.0
    demand_weight = 0.5  # Penalize edges connecting to high-demand nodes
    angle_weight = 0.3  # Encourage edges forming "good" turns (smaller angles)
    capacity_proximity_weight = 0.2 # Encourage edges connecting nodes with demands close to the residual capacity after depot trip
    # Iterate through all possible edges
    for i in range(n):
        for j in range(n):
            if i == j:
                heuristic_matrix[i, j] = 0  # No self-loops
                continue
            if distance_matrix[i, j] == 0:
                heuristic_matrix[i, j] = 0
                continue

            # Distance component (shorter distance is better)
            distance_heuristic = distance_weight / distance_matrix[i, j]

            # Demand component (lower demand is generally better)
            # We penalize connecting to high-demand nodes
            demand_heuristic = 1.0 - demand_weight * (demands[i] + demands[j]) / (2*capacity)
            demand_heuristic = max(demand_heuristic, 0.01) # Avoid zero values, ensures at least a minimal chance to consider larger demand nodes.

            # Angle component (smaller angles are better - less turning)
            # Calculate angle between vectors (i -> depot) and (i -> j)
            if i != 0:
                vector_depot = coordinates[0] - coordinates[i]
                vector_j = coordinates[j] - coordinates[i]

                #Normalize the vectors. Avoid division by zero if both locations are at the same point
                norm_depot = np.linalg.norm(vector_depot)
                norm_j = np.linalg.norm(vector_j)
                if norm_depot == 0 or norm_j == 0:
                    angle = 0  #Angle undefined. Set to 0, i.e. no penalty
                else:
                    vector_depot = vector_depot / norm_depot
                    vector_j = vector_j / norm_j

                    dot_product = np.dot(vector_depot, vector_j)
                    angle = np.arccos(np.clip(dot_product, -1.0, 1.0))  # Clip for numerical stability

                angle_heuristic = 1.0 - angle_weight * angle / np.pi # Normalize the angle to [0,1]. Pi is the max possible angle. Inverting the scale.
                angle_heuristic = max(angle_heuristic, 0.01)  # Avoid zero values
            else:
                angle_heuristic = 1.0 #From the depot any turn is acceptable

            #Capacity Proximity Component

            capacity_proximity_heuristic = 1.0- np.abs(capacity-demands[i])/(capacity+1e-9)
            capacity_proximity_heuristic = max(capacity_proximity_heuristic,0.01)



            # Combine the heuristics
            heuristic_matrix[i, j] = (
                distance_heuristic * demand_heuristic * angle_heuristic * capacity_proximity_heuristic
            )

    return heuristic_matrix
```
