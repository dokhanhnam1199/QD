```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics for Capacitated Vehicle Routing Problem (CVRP) using a combination of
    distance, demand, and proximity to the depot.

    Args:
        distance_matrix (np.ndarray): Distance matrix (n x n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (n x 2).
        demands (np.ndarray): Customer demands (n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators for each edge (n x n). Higher values indicate
                    more promising edges.
    """

    n = distance_matrix.shape[0]
    heuristics = np.zeros((n, n))

    # Inverse distance (as in v1, but more emphasized)
    distance_heuristic = 1 / (distance_matrix + 1e-9)  # Add small value to avoid division by zero
    heuristics += distance_heuristic * 2.0 # weighting increased.

    # Demand-based heuristic: Penalize edges that connect nodes with high combined demand
    # relative to the vehicle capacity.  This encourages the creation of routes
    # that are feasible (don't overload vehicles).

    demand_matrix = np.zeros((n, n))
    for i in range(n):
        for j in range(n):
            demand_matrix[i, j] = demands[i] + demands[j]

    demand_heuristic = np.clip(1 - (demand_matrix / capacity), 0, 1) # between 0 and 1

    heuristics += demand_heuristic * 1.0 #consider demand constraints


    # Depot proximity heuristic:  Nodes far from the depot are penalized
    # making connections from distant nodes to other nodes less favorable.
    # This tries to cluster nodes near the depot together.

    depot_distances = distance_matrix[0, :] #Distances from depot to each other node
    depot_proximity_matrix = np.zeros((n, n))
    for i in range(n):
        for j in range(n):
            depot_proximity_matrix[i, j] = 1/(depot_distances[i]+ depot_distances[j]+ 1e-9)

    # Normalize depot_proximity_matrix
    max_val = np.max(depot_proximity_matrix)
    if max_val > 0:
        depot_proximity_matrix = depot_proximity_matrix / max_val

    heuristics += depot_proximity_matrix * 0.5 #weighting of 0.5

    # Make diagonal elements zero, which is important.
    for i in range(n):
        heuristics[i, i] = 0

    return heuristics
```
