```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics for Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.

    This version incorporates several factors to estimate the desirability of including
    an edge in a CVRP solution: distance, demand, and angle from the depot.

    Args:
        distance_matrix (np.ndarray): Distance matrix (n x n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (n x 2).
        demands (np.ndarray): Vector of customer demands (n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (n x n).
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)

    # Heuristic 1: Inverse Distance
    inverse_distance = 1 / (distance_matrix + np.eye(n)) # adding eye to prevent division by zero
    heuristics += inverse_distance

    # Heuristic 2: Demand Considerations. Penalize edges connecting nodes with large demands if combined demand exceeds the capacity
    demand_factor = np.zeros_like(distance_matrix)
    for i in range(n):
        for j in range(n):
            if i != j:
                if demands[i] + demands[j] > capacity:
                    demand_factor[i, j] = 0.1  # Low probability
                else:
                    demand_factor[i, j] = 1 #Higher probability
    heuristics += demand_factor

    # Heuristic 3: Angle from Depot. Favor edges that lead to more "central" areas
    depot_x, depot_y = coordinates[0]
    angle_matrix = np.zeros_like(distance_matrix)
    for i in range(1, n):
        angle_i = np.arctan2(coordinates[i][1] - depot_y, coordinates[i][0] - depot_x)
        for j in range(1, n):
            if i != j:
                angle_j = np.arctan2(coordinates[j][1] - depot_y, coordinates[j][0] - depot_x)
                angle_diff = np.abs(angle_i - angle_j)
                angle_matrix[i, j] = 1 / (1 + angle_diff)  # Smaller angle diff is better
    heuristics += angle_matrix

    #Heuristic 4: Connecting to the depot is always good
    for i in range(1,n):
        heuristics[0,i] = 2 #Boost connecting edges from depot
        heuristics[i,0] = 2

    # Normalize the heuristics to be between 0 and 1
    heuristics = (heuristics - np.min(heuristics)) / (np.max(heuristics) - np.min(heuristics))

    return heuristics
```
