```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics for Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.

    This version incorporates several factors: distance, demand, and angle to depot.
    The goal is to provide edge "prior indicators" useful for guiding a stochastic search.

    Args:
        distance_matrix: (n x n) distance matrix.
        coordinates: (n x 2) Euclidean coordinates of nodes.
        demands: (n) vector of customer demands. depot demand is demands[0].
        capacity: Vehicle capacity.

    Returns:
        (n x n) matrix of edge "prior indicators". Higher values suggest more promising edges.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Parameters (these can be tuned)
    distance_weight = 1.0  # Weight for the distance component
    demand_weight = 0.5    # Weight for the demand component
    angle_weight = 0.2     # Weight for the angle to depot component
    capacity_penalty = 2.0 # Penalty for approaching capacity
    near_depot_bonus = 0.5 # bonus if it is near the depot.

    for i in range(n):
        for j in range(n):
            if i == j:
                heuristic_matrix[i, j] = 0  # No self-loops
                continue

            # 1. Distance component (inverse distance is preferred)
            distance_heuristic = distance_weight / distance_matrix[i, j]

            # 2. Demand component (edges to nodes with smaller demands are slightly preferred)
            # Scale demands to be between 0 and 1. Avoid division by 0.
            max_demand = np.max(demands[1:])
            normalized_demand = demands[j] / max_demand if max_demand > 0 else 0
            demand_heuristic = 1 - normalized_demand if i != 0 and j != 0 else 0 # Depot to depot does not care demand.

            # 3. Angle to depot component (edges that "head towards" the depot are slightly preferred)
            # Calculate angle between the line from i to j and the line from i to the depot (node 0).

            vector_ij = coordinates[j] - coordinates[i]
            vector_i0 = coordinates[0] - coordinates[i]

            # Normalize the vectors to compute cosine similarity and avoid zero division error
            norm_ij = np.linalg.norm(vector_ij)
            norm_i0 = np.linalg.norm(vector_i0)

            if norm_ij > 0 and norm_i0 > 0:
              cos_angle = np.dot(vector_ij, vector_i0) / (norm_ij * norm_i0)
              angle_heuristic = (1 + cos_angle) / 2  # Cosine ranges from -1 to 1, so shift to 0-1 range. Prefer edges in the direction to depot.
            else:
              angle_heuristic = 0

            if (i==0 and demands[j]/capacity > 0.8):
                capacity_penalty_component = capacity_penalty*demands[j]/capacity
            elif demands[i]+demands[j] > capacity and i != 0 and j !=0: # cannot satisfy
                capacity_penalty_component = -capacity_penalty * (demands[i]+demands[j])/capacity
            else:
                capacity_penalty_component = 0

            if i == 0 or j==0:
                near_depot = near_depot_bonus
            else:
                near_depot = 0

            heuristic_matrix[i, j] = (
                distance_heuristic +
                demand_weight * demand_heuristic +
                angle_weight * angle_heuristic +
                capacity_penalty_component +
                near_depot
            )


    # Normalize the heuristic matrix to a reasonable range (e.g., 0 to 1). Helps stabilize stochastic sampling.
    max_heuristic = np.max(heuristic_matrix)
    if max_heuristic > 0:
        heuristic_matrix = heuristic_matrix / max_heuristic

    return heuristic_matrix
```
