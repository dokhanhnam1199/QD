{"system": "You are an expert in code review. Your task extract all threshold, weight or hardcode variable of the function make it become default parameters.", "user": "[code]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Combines distance, demand, angle, depot proximity, and demand density.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n    depot_coords = coordinates[0]\n    angles = np.arctan2(coordinates[:, 1] - depot_coords[1], coordinates[:, 0] - depot_coords[0])\n\n    # Demand density calculation (similar to v0)\n    demand_density = np.zeros(n)\n    for i in range(1, n):\n        nearby_demand = 0\n        for j in range(1, n):\n            if i != j and distance_matrix[i, j] < np.mean(distance_matrix):\n                nearby_demand += demands[j]\n        demand_density[i] = nearby_demand\n    max_demand_density = np.max(demand_density) if np.max(demand_density) > 0 else 1\n\n    #Center calculation\n    center_x = np.mean(coordinates[1:, 0])\n    center_y = np.mean(coordinates[1:, 1])\n    total_demand = np.sum(demands[1:])\n    demand_weighted_dist_to_depot = np.sum(demands[1:] * distance_matrix[0, 1:]) / total_demand if total_demand > 0 else 1e-6  # Avoid division by zero\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n\n            distance = distance_matrix[i, j]\n            dist_factor = 1 / (distance + 1e-6)\n\n            # Demand penalty (similar to v1, but smoother)\n            demand_penalty = 1.0 - np.clip((demands[i] + demands[j]) / (2 * capacity), 0, 0.7) #Smoother and combined\n\n            # Angular factor (v1)\n            angle_diff = abs(angles[i] - angles[j])\n            angular_factor = 1 / (angle_diff + 0.1)\n\n            # Depot proximity (v1, but modified)\n            depot_proximity = 1.0\n            if i == 0 or j == 0:\n                depot_proximity = 1.2  #Slightly less aggressive\n\n            #Demand Density Component (v0)\n            density_component = 1.0\n            if i != 0 and j != 0:\n                density_component = np.sqrt((demand_density[i] / max_demand_density) * (demand_density[j] / max_demand_density))\n\n            #Center Component(v0)\n            center_distance = (np.sqrt((coordinates[i, 0] - center_x)**2 + (coordinates[i, 1] - center_y)**2) +\n                               np.sqrt((coordinates[j, 0] - center_x)**2 + (coordinates[j, 1] - center_y)**2)) / 2\n            centrality_component = np.exp(-center_distance / demand_weighted_dist_to_depot if demand_weighted_dist_to_depot>0 else 1)\n\n            # Combined heuristic\n            heuristic_matrix[i, j] = (dist_factor * demand_penalty * angular_factor * depot_proximity * density_component * centrality_component)\n\n            #Sparsification\n            if i!=0 and j!=0 and (demands[i] + demands[j]) > 1.5 * capacity:\n                heuristic_matrix[i, j] = 0\n            if i!=0 and j!=0 and (demands[i] > capacity or demands[j] > capacity) :\n                heuristic_matrix[i, j] = 0\n\n            heuristic_matrix[i, j] = np.clip(heuristic_matrix[i, j], 0, 1e6)\n\n    return heuristic_matrix\n\nNow extract all threshold, weight or hardcode variable of the function make it become default parameters and give me a 'parameter_ranges' dictionary representation. Key of dict is name of variable. Value of key is a tuple in Python MUST include 2 float elements, first element is begin value, second element is end value corresponding with parameter.\n\n- Output code only and enclose your code with Python code block: ```python ... ```.\n- Output 'parameter_ranges' dictionary only and enclose your code with other Python code block: ```python ... ```."}