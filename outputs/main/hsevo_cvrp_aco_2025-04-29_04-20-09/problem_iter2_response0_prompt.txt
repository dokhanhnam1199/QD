{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a heuristics function for Solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling. CVRP requires finding the shortest path that visits all given nodes and returns to the starting node. Each node has a demand and each vehicle has a capacity. The total demand of the nodes visited by a vehicle cannot exceed the vehicle capacity. When the total demand exceeds the vehicle capacity, the vehicle must return to the starting node.\nThe `heuristics` function takes as input a distance matrix (shape: n by n), Euclidean coordinates of nodes (shape: n by 2), a vector of customer demands (shape: n), and the integer capacity of vehicle capacity. It returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the distance_matrix. The depot node is indexed by 0.\n\n\n### Better code\ndef heuristics_v0(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n\n    \"\"\"\n    A heuristic function for solving the Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.\n\n    This version incorporates several factors to estimate the desirability of including each edge in a solution:\n        - Distance: Shorter distances are preferred.\n        - Demand Compatibility: Edges connecting nodes with demands that can be feasibly combined within vehicle capacity\n                                  are favored. Avoid edges which may immediately cause capacity constraint violations\n        - Angle: Edges creating sharp turns are penalized (to encourage smoother routes). Depot visits are incentivized if capacity isn't sufficient.\n        - Centrality: Favor edges near the 'center' of gravity of all customer locations\n        - Depot Attraction: A higher probability of going to the depot, especially when near vehicle capacity.\n\n    Args:\n        distance_matrix (np.ndarray): A matrix of pairwise distances between nodes (n x n).\n        coordinates (np.ndarray): A matrix of node coordinates (n x 2).\n        demands (np.ndarray): A vector of customer demands (n).  depot demand assumed to be 0\n        capacity (int): The vehicle capacity.\n\n    Returns:\n        np.ndarray: A matrix of heuristic values indicating the desirability of including each edge (n x n).\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n\n    # Calculate the center of gravity of customer locations (excluding the depot).\n    center_x = np.mean(coordinates[1:, 0])\n    center_y = np.mean(coordinates[1:, 1])\n\n    # Demand-weighted average distance to depot. If high, routes are more decentralized.\n    total_demand = np.sum(demands[1:])  # Total demand of all customers\n    demand_weighted_dist_to_depot = np.sum(demands[1:] * distance_matrix[0, 1:]) / total_demand if total_demand > 0 else 0\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristic_matrix[i, j] = 0  # No self-loops\n                continue\n\n            distance = distance_matrix[i, j]\n\n            # Distance component: inversely proportional to distance\n            distance_component = 1 / (distance + 1e-6)  # avoid divide by zero\n\n            # Demand compatibility component: Penalize edges which could cause immediate capacity violation\n            demand_component = 1.0\n            if i != 0 and j != 0 and demands[i] + demands[j] > capacity:\n                demand_component = 0.1  # Severely penalize potentially invalid route segments\n\n\n            # Angle component: Penalize sharp turns by looking at nearby nodes.\n            angle_component = 1.0\n            if i != 0 and j != 0:  # Only consider angles for customer-customer edges. Don't penalize edges *to* depot.\n\n                # Find k, such that the nodes j, i and k form an angle\n                angles = []\n\n                for k in range(n): # considers all neighbours of i\n                    if (k!=i and k!=j):\n                        v1 = coordinates[i]-coordinates[j]\n                        v2 = coordinates[k]-coordinates[i]\n                        dot_product = np.dot(v1, v2)\n                        magnitudes = np.linalg.norm(v1) * np.linalg.norm(v2)\n                        if magnitudes == 0:\n                            angle = 0 #Avoid NaN for superimposed coords\n                        else:\n                            angle = np.arccos(dot_product / magnitudes)\n                        angles.append(angle)\n                #We penalize sharpest turn possible. Penalties can accumulate\n                if len(angles)>0:\n                    angle_component = min(np.degrees(angles) / 180.0)\n\n            # Centrality component: Favor edges closer to the center of customer locations.\n            center_distance = (np.sqrt((coordinates[i, 0] - center_x)**2 + (coordinates[i, 1] - center_y)**2) +\n                               np.sqrt((coordinates[j, 0] - center_x)**2 + (coordinates[j, 1] - center_y)**2)) / 2\n\n            centrality_component = np.exp(-center_distance / demand_weighted_dist_to_depot if demand_weighted_dist_to_depot>0 else 1) #Scale the centrality measure\n\n            #Depot attraction Component: Incentivise returning to the depot, higher chance if close to capacity\n            depot_component = 1.0\n            if i!=0: #Going from customer i to Depot\n                load_before_depot = demands[i] #assuming last delivery before depot has roughly this load\n                depot_component = (1 + np.exp(load_before_depot/capacity)) / 2\n\n            heuristic_matrix[i, j] = (distance_component * demand_component * (1 - angle_component) * centrality_component * depot_component)\n\n    return heuristic_matrix\n\n### Worse code\ndef heuristics_v1(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n\n    \"\"\"\n    Newtonian Heuristics for Capacitated Vehicle Routing Problem (CVRP).\n\n    This function incorporates gravity-inspired attraction, pheromone-like reinforcement,\n    and capacity considerations to generate a heuristic matrix guiding stochastic solution sampling.\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix between nodes (n x n).\n        coordinates (np.ndarray): Euclidean coordinates of nodes (n x 2).\n        demands (np.ndarray): Demand of each node (n). depot is demands[0].\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Heuristic matrix (n x n) indicating edge desirability.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n\n    # Parameters (tuned with physical intuition and experimentation)\n    gravity_constant = 1.0  # Strength of attraction (inverse distance)\n    pheromone_strength = 0.5  # Reinforcement of edges used in good solutions (initially 0)\n    capacity_penalty = 2.0 # Increased penalty based on approaching capacity.\n    depot_attraction = 1.5 # Bias towards traveling from depot, as most routes require this.\n    nearby_penalty = 0.8 # discourage near node.\n    # mass = demand?\n\n    # Initialize Pheromone Matrix (representing \"good routes\" seen so far) - Initially none.\n    pheromone_matrix = np.zeros((n, n)) # tracks how often the edge appears.\n\n\n    # --- Newtonian Gravitation Inspired Attraction ---\n    #   Stronger attraction between closer nodes (inverse distance).\n\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                heuristic_matrix[i, j] = gravity_constant / distance_matrix[i, j]\n\n                #Emphasize Depot connections.\n                if i == 0 or j == 0:\n                  heuristic_matrix[i, j] *= depot_attraction\n\n\n    # --- Capacity Consideration ---\n    #   Penalize edges that lead to exceeding vehicle capacity\n\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                #Approximated Penalty. Needs to see further context.\n                estimated_load = demands[j]\n                if estimated_load > capacity:\n                  heuristic_matrix[i, j] = 0 # No chance if exceeds capacity.\n                else:\n                    # Penalize based on the remaining available capacity. The closer to capacity the more penalization.\n                    remaining_capacity_ratio = (capacity - estimated_load) / capacity\n                    heuristic_matrix[i, j] *= (1 + capacity_penalty * remaining_capacity_ratio)\n\n\n    # --- Node Location Consideration ---\n    #   Discourage traveling to very nearby nodes (might create unnecessary loops).\n\n    for i in range(n):\n        for j in range(n):\n            if i !=j and distance_matrix[i,j] < np.mean(distance_matrix):\n                heuristic_matrix[i,j] *= nearby_penalty\n\n\n    # --- Normalize Heuristic Matrix ---\n    #   Ensures values are within a reasonable range. Prevents overflow.\n    heuristic_matrix = (heuristic_matrix - np.min(heuristic_matrix)) / (np.max(heuristic_matrix) - np.min(heuristic_matrix) + 1e-9)\n\n\n    return heuristic_matrix\n\n### Analyze & experience\n- Comparing (1st) vs (2nd), we see the first heuristic incorporates a centrality component, favoring edges near the center of gravity of customer locations, and a depot attraction component which incentivizes returning to the depot based on remaining capacity. The second heuristic, in contrast, uses normalized distance and penalizes nodes far from the depot, encouraging more connections around the depot. The angle calculation differs; the first finds the sharpest possible turn, while the second calculates the angle relative to the depot.\n\nComparing (2nd best) vs (2nd worst), the second-best considers closeness to the depot and applies an angle difference penalty, while the second-worst prioritizes edges connecting to nodes closer to the depot and factors in demand, penalizing edges connecting nodes with high combined demand.\n\nComparing (1st) vs (3rd), the first heuristic calculates centrality using demand-weighted distance to the depot, while the third primarily focuses on angular proximity from the depot. The first also explicitly penalizes edges that could cause immediate capacity violations, whereas the third prioritizes edges from the depot.\n\nComparing (3rd) vs (4th), the third heuristic incorporates a depot proximity factor, boosting edges connected to the depot, and penalizes high-demand edges. The fourth focuses on penalizing edges connecting high-demand nodes to each other, using a simpler angle factor.\n\nComparing (second worst) vs (worst), the second-worst considers depot proximity and demand through precomputed depot distances, whereas the worst only focuses on distance to the depot and combines this directly with angle differences, placing less emphasis on demand or capacity.\n\nOverall: The better heuristics tend to incorporate more nuanced considerations, such as centrality, capacity proximity, and angle calculations based on potential routes rather than just angles relative to the depot. They often include normalizing factors and penalties to prevent extreme values from dominating the heuristic matrix. Poorer heuristics are often simpler, relying heavily on inverse distance and basic demand considerations, with less emphasis on the overall route structure and capacity management. The weighting and combination of different heuristic components are also crucial, and the top-ranked heuristics use carefully chosen weights and mathematical operations to balance the influence of each factor.\n- - Try combining various factors to determine how promising it is to select an edge.\n- Try sparsifying the matrix by setting unpromising elements to zero.\nOkay, let's refine \"Current self-reflection\" to design better heuristics, avoiding pitfalls and focusing on actionable insights.\n\n*   **Keywords:** Adaptive, Evaluation, Iterative, Validation.\n*   **Advice:** Design an iterative heuristic development process with explicit steps for evaluating performance on diverse problem instances and adapting parameters/strategies based on the results.\n*   **Avoid:** Premature optimization based on limited data or intuition; focus on data-driven refinement.\n*   **Explanation:** A rigorous cycle of building, testing, and refining heuristics, informed by quantitative performance analysis, will lead to more robust and effective solutions.\n\n\nYour task is to write an improved function `heuristics_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}