```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """Combines distance, demand density, angle, centrality and depot proximity."""
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Normalize distance
    max_distance = np.max(distance_matrix[distance_matrix != np.inf])
    normalized_distance = distance_matrix / max_distance
    normalized_distance = np.where(normalized_distance == 0, 1e-6, normalized_distance)

    # Calculate angles relative to the depot
    depot_x, depot_y = coordinates[0]
    angles = np.arctan2(coordinates[:, 1] - depot_y, coordinates[:, 0] - depot_x)

    # Calculate demand density
    areas = []
    for i in range(n):
        # Approximate area as proportional to the square of distance to depot
        area = distance_matrix[0, i] ** 2
        areas.append(area)

    max_area = np.max(areas) if np.max(areas) > 0 else 1
    demand_densities = demands / (np.array(areas) / max_area + 1e-6) # Avoid divide by zero

    # Calculate center of mass
    center_x = np.mean(coordinates[1:, 0])
    center_y = np.mean(coordinates[1:, 1])

    # Parameters - these could be adaptive in a more advanced version
    distance_weight = 0.4
    demand_weight = 0.2
    angle_weight = 0.1
    depot_weight = 0.2
    centrality_weight = 0.1

    for i in range(n):
        for j in range(n):
            if i != j:
                heuristic_value = 0.0

                # Distance component
                heuristic_value += distance_weight * (1 / normalized_distance[i, j])

                # Demand component (using demand density)
                demand_penalty = np.exp(-2 * (demand_densities[i] + demand_densities[j]))
                heuristic_value += demand_weight * demand_penalty

                # Angle component
                angle_diff = abs(angles[i] - angles[j])
                angle_penalty = np.exp(-2 * angle_diff)
                heuristic_value += angle_weight * angle_penalty

                # Depot proximity component (penalize if far from depot)
                depot_distance_i = distance_matrix[0, i] / max_distance
                depot_distance_j = distance_matrix[0, j] / max_distance
                depot_proximity_penalty = np.exp(-1 * (depot_distance_i + depot_distance_j))
                heuristic_value += depot_weight * depot_proximity_penalty

                # Centrality component
                center_distance_i = np.sqrt((coordinates[i, 0] - center_x)**2 + (coordinates[i, 1] - center_y)**2) / max_distance
                center_distance_j = np.sqrt((coordinates[j, 0] - center_x)**2 + (coordinates[j, 1] - center_y)**2) / max_distance
                avg_center_distance = (center_distance_i + center_distance_j) / 2
                centrality_penalty = np.exp(-avg_center_distance)
                heuristic_value += centrality_weight * centrality_penalty

                heuristic_matrix[i, j] = heuristic_value

    # Sparsify the matrix (optional)
    threshold = np.mean(heuristic_matrix) * 0.1
    heuristic_matrix[heuristic_matrix < threshold] = 0

    return heuristic_matrix
```
