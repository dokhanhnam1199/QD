{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Combines centrality, capacity, angle, and depot attraction for CVRP.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n    center_x = np.mean(coordinates[1:, 0])\n    center_y = np.mean(coordinates[1:, 1])\n    total_demand = np.sum(demands[1:])\n    demand_weighted_dist_to_depot = np.sum(demands[1:] * distance_matrix[0, 1:]) / total_demand if total_demand > 0 else 0\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n\n            distance = distance_matrix[i, j]\n            distance_component = 1 / (distance + 1e-6)\n\n            demand_component = 1.0\n            if i != 0 and j != 0 and demands[i] + demands[j] > capacity:\n                demand_component = 0.1\n\n            angle_component = 1.0\n            if i != 0 and j != 0:\n                angles = []\n                for k in range(n):\n                    if k != i and k != j:\n                        v1 = coordinates[i] - coordinates[j]\n                        v2 = coordinates[k] - coordinates[i]\n                        dot_product = np.dot(v1, v2)\n                        magnitudes = np.linalg.norm(v1) * np.linalg.norm(v2)\n                        if magnitudes == 0:\n                            angle = 0\n                        else:\n                            angle = np.arccos(dot_product / magnitudes)\n                        angles.append(angle)\n                if len(angles) > 0:\n                    angle_component = min(np.degrees(angles) / 180.0)\n\n            center_distance = (np.sqrt((coordinates[i, 0] - center_x)**2 + (coordinates[i, 1] - center_y)**2) +\n                               np.sqrt((coordinates[j, 0] - center_x)**2 + (coordinates[j, 1] - center_y)**2)) / 2\n            centrality_component = np.exp(-center_distance / demand_weighted_dist_to_depot if demand_weighted_dist_to_depot>0 else 1)\n\n            depot_component = 1.0\n            if i!=0:\n                load_before_depot = demands[i]\n                depot_component = (1 + np.exp(load_before_depot/capacity)) / 2\n\n            heuristic_matrix[i, j] = (distance_component * demand_component * (1 - angle_component) * centrality_component * depot_component)\n\n    return heuristic_matrix\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    An enhanced heuristic for the CVRP that incorporates distance, demand, angle,\n    centrality, and depot attraction, with adaptive sparsification.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n\n    # Calculate the centroid of the customer nodes\n    center_x = np.mean(coordinates[1:, 0])\n    center_y = np.mean(coordinates[1:, 1])\n\n    # Total demand calculation\n    total_demand = np.sum(demands[1:])\n\n    # Average distance to depot weighted by demand\n    demand_weighted_dist_to_depot = np.sum(demands[1:] * distance_matrix[0, 1:]) / total_demand if total_demand > 0 else 1.0\n\n    # Adaptive Sparsification Threshold (dynamically adjusted based on demand and distance)\n    sparsification_threshold = np.mean(distance_matrix) * (1 + (total_demand / (capacity * n)))\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n\n            distance = distance_matrix[i, j]\n\n            # Sparsification: Eliminate edges that are too long or deemed unpromising early on\n            if distance > sparsification_threshold:\n                heuristic_matrix[i, j] = 0.0  # Directly set to zero to prune unpromising edges\n                continue\n\n            # Distance component: Reciprocal of distance, with a small constant to avoid division by zero\n            distance_component = 1 / (distance + 1e-6)\n\n            # Demand component: Penalize edges that would likely violate capacity constraints early\n            demand_component = 1.0\n            if i != 0 and j != 0 and demands[i] + demands[j] > capacity * 1.2:  #relaxed capacity constraint\n                demand_component = 0.05 # more aggressive penalization\n            elif i!=0 and j!=0 and demands[i] + demands[j] > capacity:\n                demand_component = 0.2 # stronger penalization if capacity will be violated\n\n            # Angle Component (Penalize sharp turns). Simplified calculation for speed.\n            angle_component = 1.0\n            if i != 0 and j != 0:\n                # Calculate angles to a subset of other nodes for efficiency\n                num_angles = min(5, n - 2) #Consider only a few angles\n                angles = []\n\n                #Sampling without replacement\n                candidates = list(range(1,n))\n                candidates.remove(i)\n                candidates.remove(j)\n                sampled_indices = np.random.choice(candidates, size=min(num_angles, len(candidates)), replace=False)\n\n                for k in sampled_indices:\n                    v1 = coordinates[i] - coordinates[j]\n                    v2 = coordinates[k] - coordinates[i]\n                    dot_product = np.dot(v1, v2)\n                    magnitudes = np.linalg.norm(v1) * np.linalg.norm(v2)\n                    if magnitudes == 0:\n                        angle = 0\n                    else:\n                        angle = np.arccos(dot_product / magnitudes)\n                    angles.append(angle)\n                if len(angles) > 0:\n                    angle_component = np.min(np.degrees(angles) / 180.0) #Normalize between 0 and 1.\n\n            # Centrality component: Favor edges closer to the center of the customer distribution.\n            center_distance = (np.sqrt((coordinates[i, 0] - center_x)**2 + (coordinates[i, 1] - center_y)**2) +\n                               np.sqrt((coordinates[j, 0] - center_x)**2 + (coordinates[j, 1] - center_y)**2)) / 2\n            centrality_component = np.exp(-center_distance / (demand_weighted_dist_to_depot + 1e-6))\n\n            # Depot attraction: Encourage edges connecting to the depot.\n            depot_component = 1.0\n            if i == 0 or j == 0:\n                depot_component = 1.0 #High priority to depot\n            else:\n                depot_component = 0.5 #Lower prioirty if not directly connected\n\n            # Context-Aware Combination: Adaptive combination of components with multiplicative interaction\n            heuristic_matrix[i, j] = (distance_component**0.8 * demand_component**1.2 * (1 - angle_component)**0.9 *\n                                      centrality_component**0.7 * depot_component**1.1) # Fine-tuned exponents\n\n    return heuristic_matrix\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Combines normalized distance, demand, and depot proximity with adaptive sparsification.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n\n    # Normalize distances\n    max_distance = np.max(distance_matrix)\n    normalized_distances = distance_matrix / (max_distance + 1e-6)\n\n    # Demand component: discourage edges exceeding capacity\n    demand_matrix = np.zeros((n, n))\n    for i in range(n):\n        for j in range(n):\n            demand_matrix[i, j] = demands[i] + demands[j]\n    demand_component = np.clip(1 - (demand_matrix / capacity), 0, 1)\n\n    # Depot proximity\n    depot_distances = distance_matrix[0, :]\n    depot_proximity_matrix = np.zeros((n, n))\n    for i in range(n):\n        for j in range(n):\n            depot_proximity_matrix[i, j] = 1 / (depot_distances[i] + depot_distances[j] + 1e-9)\n    max_val = np.max(depot_proximity_matrix)\n    if max_val > 0:\n        depot_proximity_matrix = depot_proximity_matrix / max_val\n\n    # Combine components\n    heuristic_matrix = (\n        (1 / (normalized_distances + 1e-6)) *\n        demand_component *\n        depot_proximity_matrix\n    )\n\n    # Adaptive sparsification\n    threshold = np.mean(heuristic_matrix[heuristic_matrix > 0]) * 0.5\n    heuristic_matrix[heuristic_matrix < threshold] = 0\n    heuristic_matrix[distance_matrix == 0] = 0\n\n\n    return heuristic_matrix\n\n[Heuristics 4th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Combines normalized distance, demand, and depot proximity with adaptive sparsification.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n\n    # Normalize distances\n    max_distance = np.max(distance_matrix)\n    normalized_distances = distance_matrix / (max_distance + 1e-6)\n\n    # Demand component: discourage edges exceeding capacity\n    demand_matrix = np.zeros((n, n))\n    for i in range(n):\n        for j in range(n):\n            demand_matrix[i, j] = demands[i] + demands[j]\n    demand_component = np.clip(1 - (demand_matrix / capacity), 0, 1)\n\n    # Depot proximity\n    depot_distances = distance_matrix[0, :]\n    depot_proximity_matrix = np.zeros((n, n))\n    for i in range(n):\n        for j in range(n):\n            depot_proximity_matrix[i, j] = 1 / (depot_distances[i] + depot_distances[j] + 1e-9)\n    max_val = np.max(depot_proximity_matrix)\n    if max_val > 0:\n        depot_proximity_matrix = depot_proximity_matrix / max_val\n\n    # Combine components\n    heuristic_matrix = (\n        (1 / (normalized_distances + 1e-6)) *\n        demand_component *\n        depot_proximity_matrix\n    )\n\n    # Adaptive sparsification\n    threshold = np.mean(heuristic_matrix[heuristic_matrix > 0]) * 0.5\n    heuristic_matrix[heuristic_matrix < threshold] = 0\n    heuristic_matrix[distance_matrix == 0] = 0\n\n\n    return heuristic_matrix\n\n[Heuristics 5th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Combines normalized distance, demand, and depot proximity with adaptive sparsification.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n\n    # Normalize distances\n    max_distance = np.max(distance_matrix)\n    normalized_distances = distance_matrix / (max_distance + 1e-6)\n\n    # Demand component: discourage edges exceeding capacity\n    demand_matrix = np.zeros((n, n))\n    for i in range(n):\n        for j in range(n):\n            demand_matrix[i, j] = demands[i] + demands[j]\n    demand_component = np.clip(1 - (demand_matrix / capacity), 0, 1)\n\n    # Depot proximity\n    depot_distances = distance_matrix[0, :]\n    depot_proximity_matrix = np.zeros((n, n))\n    for i in range(n):\n        for j in range(n):\n            depot_proximity_matrix[i, j] = 1 / (depot_distances[i] + depot_distances[j] + 1e-9)\n    max_val = np.max(depot_proximity_matrix)\n    if max_val > 0:\n        depot_proximity_matrix = depot_proximity_matrix / max_val\n\n    # Combine components\n    heuristic_matrix = (\n        (1 / (normalized_distances + 1e-6)) *\n        demand_component *\n        depot_proximity_matrix\n    )\n\n    # Adaptive sparsification\n    threshold = np.mean(heuristic_matrix[heuristic_matrix > 0]) * 0.5\n    heuristic_matrix[heuristic_matrix < threshold] = 0\n    heuristic_matrix[distance_matrix == 0] = 0\n\n\n    return heuristic_matrix\n\n[Heuristics 6th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Adaptive heuristic combining distance, demand, angle, and depot proximity with dynamic sparsification.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n    depot_coords = coordinates[0]\n    angles = np.arctan2(coordinates[:, 1] - depot_coords[1], coordinates[:, 0] - depot_coords[0])\n\n    # Adaptive sparsification threshold\n    avg_distance = np.mean(distance_matrix)\n    sparsification_threshold = 2.0 * avg_distance  # Adjust factor as needed\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n\n            distance = distance_matrix[i, j]\n\n            # Sparsification\n            if distance > sparsification_threshold:\n                continue\n\n            distance_component = 1 / (distance + 1e-6)\n\n            demand_component = 1.0\n            if i != 0 and j != 0:\n                if demands[i] + demands[j] > capacity:\n                    demand_component = 0.01  # High penalty for exceeding capacity\n                else:\n                    demand_component = 1.1\n\n            angle_diff = abs(angles[i] - angles[j])\n            angular_factor = 1 / (angle_diff + 0.1)\n\n            depot_proximity = 1.0\n            if i == 0 or j == 0:\n                depot_proximity = 1.2\n\n            # Combination with multiplicative and additive factors\n            heuristic_value = distance_component * demand_component * angular_factor * depot_proximity\n            heuristic_matrix[i, j] = heuristic_value\n\n    return heuristic_matrix\n\n[Heuristics 7th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Adaptive heuristic combining distance, demand, angle, and depot proximity with dynamic sparsification.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n    depot_coords = coordinates[0]\n    angles = np.arctan2(coordinates[:, 1] - depot_coords[1], coordinates[:, 0] - depot_coords[0])\n\n    # Adaptive sparsification threshold\n    avg_distance = np.mean(distance_matrix)\n    sparsification_threshold = 2.0 * avg_distance  # Adjust factor as needed\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n\n            distance = distance_matrix[i, j]\n\n            # Sparsification\n            if distance > sparsification_threshold:\n                continue\n\n            distance_component = 1 / (distance + 1e-6)\n\n            demand_component = 1.0\n            if i != 0 and j != 0:\n                if demands[i] + demands[j] > capacity:\n                    demand_component = 0.01  # High penalty for exceeding capacity\n                else:\n                    demand_component = 1.1\n\n            angle_diff = abs(angles[i] - angles[j])\n            angular_factor = 1 / (angle_diff + 0.1)\n\n            depot_proximity = 1.0\n            if i == 0 or j == 0:\n                depot_proximity = 1.2\n\n            # Combination with multiplicative and additive factors\n            heuristic_value = distance_component * demand_component * angular_factor * depot_proximity\n            heuristic_matrix[i, j] = heuristic_value\n\n    return heuristic_matrix\n\n[Heuristics 8th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Adaptive heuristic combining distance, demand, angle, and depot proximity with dynamic sparsification.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n    depot_coords = coordinates[0]\n    angles = np.arctan2(coordinates[:, 1] - depot_coords[1], coordinates[:, 0] - depot_coords[0])\n\n    # Adaptive sparsification threshold\n    avg_distance = np.mean(distance_matrix)\n    sparsification_threshold = 2.0 * avg_distance  # Adjust factor as needed\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n\n            distance = distance_matrix[i, j]\n\n            # Sparsification\n            if distance > sparsification_threshold:\n                continue\n\n            distance_component = 1 / (distance + 1e-6)\n\n            demand_component = 1.0\n            if i != 0 and j != 0:\n                if demands[i] + demands[j] > capacity:\n                    demand_component = 0.01  # High penalty for exceeding capacity\n                else:\n                    demand_component = 1.1\n\n            angle_diff = abs(angles[i] - angles[j])\n            angular_factor = 1 / (angle_diff + 0.1)\n\n            depot_proximity = 1.0\n            if i == 0 or j == 0:\n                depot_proximity = 1.2\n\n            # Combination with multiplicative and additive factors\n            heuristic_value = distance_component * demand_component * angular_factor * depot_proximity\n            heuristic_matrix[i, j] = heuristic_value\n\n    return heuristic_matrix\n\n[Heuristics 9th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Combines adaptive distance, demand, centrality, and depot attraction with sparsification.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n\n    # Adaptive distance component\n    avg_dist_to_depot = np.mean(distance_matrix[0, 1:])\n    distance_component = np.exp(-distance_matrix / avg_dist_to_depot) if avg_dist_to_depot > 0 else np.ones_like(distance_matrix)\n\n    # Demand component, penalizing capacity violations\n    demand_matrix = np.add.outer(demands, demands)\n    demand_component = np.where(demand_matrix > capacity, 0.01, 1.0)\n    for i in range(n):\n        demand_component[i,i] = 0\n\n    # Centrality component\n    center_x = np.mean(coordinates[1:, 0])\n    center_y = np.mean(coordinates[1:, 1])\n    center_distances = np.sqrt((coordinates[:, 0] - center_x)**2 + (coordinates[:, 1] - center_y)**2)\n    total_demand = np.sum(demands[1:])\n    demand_weighted_dist_to_depot = np.sum(demands[1:] * distance_matrix[0, 1:]) / total_demand if total_demand > 0 else np.mean(distance_matrix[0, 1:])\n    centrality_component = np.exp(-(center_distances[:, None] + center_distances[None, :]) / (2 * demand_weighted_dist_to_depot)) if demand_weighted_dist_to_depot > 0 else np.ones_like(distance_matrix)\n\n    # Depot attraction component\n    depot_attraction = np.exp(-distance_matrix[0, :] / avg_dist_to_depot) if avg_dist_to_depot > 0 else np.ones(n)\n    depot_component = (depot_attraction[:, None] + depot_attraction[None, :]) / 2\n\n    # Angle Component\n    depot_x, depot_y = coordinates[0]\n    angles = np.arctan2(coordinates[:, 1] - depot_y, coordinates[:, 0] - depot_x)\n    angle_diffs = np.abs(angles[:, None] - angles[None, :])\n    angle_component = np.exp(-2 * angle_diffs)\n    # Combine components multiplicatively\n    heuristic_matrix = distance_component * demand_component * centrality_component * depot_component * angle_component\n\n    # Adaptive sparsification\n    threshold = np.mean(heuristic_matrix[heuristic_matrix > 0]) * 0.2\n    heuristic_matrix[heuristic_matrix < threshold] = 0\n\n    return heuristic_matrix\n\n[Heuristics 10th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Combines adaptive distance, demand, centrality, and depot attraction with sparsification.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n\n    # Adaptive distance component\n    avg_dist_to_depot = np.mean(distance_matrix[0, 1:])\n    distance_component = np.exp(-distance_matrix / avg_dist_to_depot) if avg_dist_to_depot > 0 else np.ones_like(distance_matrix)\n\n    # Demand component, penalizing capacity violations\n    demand_matrix = np.add.outer(demands, demands)\n    demand_component = np.where(demand_matrix > capacity, 0.01, 1.0)\n    for i in range(n):\n        demand_component[i,i] = 0\n\n    # Centrality component\n    center_x = np.mean(coordinates[1:, 0])\n    center_y = np.mean(coordinates[1:, 1])\n    center_distances = np.sqrt((coordinates[:, 0] - center_x)**2 + (coordinates[:, 1] - center_y)**2)\n    total_demand = np.sum(demands[1:])\n    demand_weighted_dist_to_depot = np.sum(demands[1:] * distance_matrix[0, 1:]) / total_demand if total_demand > 0 else np.mean(distance_matrix[0, 1:])\n    centrality_component = np.exp(-(center_distances[:, None] + center_distances[None, :]) / (2 * demand_weighted_dist_to_depot)) if demand_weighted_dist_to_depot > 0 else np.ones_like(distance_matrix)\n\n    # Depot attraction component\n    depot_attraction = np.exp(-distance_matrix[0, :] / avg_dist_to_depot) if avg_dist_to_depot > 0 else np.ones(n)\n    depot_component = (depot_attraction[:, None] + depot_attraction[None, :]) / 2\n\n    # Angle Component\n    depot_x, depot_y = coordinates[0]\n    angles = np.arctan2(coordinates[:, 1] - depot_y, coordinates[:, 0] - depot_x)\n    angle_diffs = np.abs(angles[:, None] - angles[None, :])\n    angle_component = np.exp(-2 * angle_diffs)\n    # Combine components multiplicatively\n    heuristic_matrix = distance_component * demand_component * centrality_component * depot_component * angle_component\n\n    # Adaptive sparsification\n    threshold = np.mean(heuristic_matrix[heuristic_matrix > 0]) * 0.2\n    heuristic_matrix[heuristic_matrix < threshold] = 0\n\n    return heuristic_matrix\n\n[Heuristics 11th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Combines adaptive distance, demand, centrality, and depot attraction with sparsification.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n\n    # Adaptive distance component\n    avg_dist_to_depot = np.mean(distance_matrix[0, 1:])\n    distance_component = np.exp(-distance_matrix / avg_dist_to_depot) if avg_dist_to_depot > 0 else np.ones_like(distance_matrix)\n\n    # Demand component, penalizing capacity violations\n    demand_matrix = np.add.outer(demands, demands)\n    demand_component = np.where(demand_matrix > capacity, 0.01, 1.0)\n    for i in range(n):\n        demand_component[i,i] = 0\n\n    # Centrality component\n    center_x = np.mean(coordinates[1:, 0])\n    center_y = np.mean(coordinates[1:, 1])\n    center_distances = np.sqrt((coordinates[:, 0] - center_x)**2 + (coordinates[:, 1] - center_y)**2)\n    total_demand = np.sum(demands[1:])\n    demand_weighted_dist_to_depot = np.sum(demands[1:] * distance_matrix[0, 1:]) / total_demand if total_demand > 0 else np.mean(distance_matrix[0, 1:])\n    centrality_component = np.exp(-(center_distances[:, None] + center_distances[None, :]) / (2 * demand_weighted_dist_to_depot)) if demand_weighted_dist_to_depot > 0 else np.ones_like(distance_matrix)\n\n    # Depot attraction component\n    depot_attraction = np.exp(-distance_matrix[0, :] / avg_dist_to_depot) if avg_dist_to_depot > 0 else np.ones(n)\n    depot_component = (depot_attraction[:, None] + depot_attraction[None, :]) / 2\n\n    # Angle Component\n    depot_x, depot_y = coordinates[0]\n    angles = np.arctan2(coordinates[:, 1] - depot_y, coordinates[:, 0] - depot_x)\n    angle_diffs = np.abs(angles[:, None] - angles[None, :])\n    angle_component = np.exp(-2 * angle_diffs)\n    # Combine components multiplicatively\n    heuristic_matrix = distance_component * demand_component * centrality_component * depot_component * angle_component\n\n    # Adaptive sparsification\n    threshold = np.mean(heuristic_matrix[heuristic_matrix > 0]) * 0.2\n    heuristic_matrix[heuristic_matrix < threshold] = 0\n\n    return heuristic_matrix\n\n[Heuristics 12th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Combines adaptive distance, demand, centrality, depot attraction, and angle.\n    Sparsifies based on a dynamic threshold.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n    center_x = np.mean(coordinates[1:, 0])\n    center_y = np.mean(coordinates[1:, 1])\n    total_demand = np.sum(demands[1:])\n    demand_weighted_dist_to_depot = np.sum(demands[1:] * distance_matrix[0, 1:]) / total_demand if total_demand > 0 else np.mean(distance_matrix[0,1:])\n\n    avg_dist_to_depot = np.mean(distance_matrix[0, 1:])\n\n    depot_x, depot_y = coordinates[0]\n    angles = np.arctan2(coordinates[:, 1] - depot_y, coordinates[:, 0] - depot_x)\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n\n            distance = distance_matrix[i, j]\n            distance_component = np.exp(-distance / avg_dist_to_depot) if avg_dist_to_depot > 0 else 1.0\n\n            demand_component = 1.0\n            if i != 0 and j != 0 and demands[i] + demands[j] > capacity:\n                demand_component = 0.01\n\n            center_distance = (np.sqrt((coordinates[i, 0] - center_x)**2 + (coordinates[i, 1] - center_y)**2) +\n                               np.sqrt((coordinates[j, 0] - center_x)**2 + (coordinates[j, 1] - center_y)**2)) / 2\n            centrality_component = np.exp(-center_distance / demand_weighted_dist_to_depot) if demand_weighted_dist_to_depot > 0 else 1.0\n\n            depot_component = 1.0\n            if i!=0 and j!=0:\n                depot_attraction_i = np.exp(-distance_matrix[i, 0] / avg_dist_to_depot) if avg_dist_to_depot>0 else 1.0\n                depot_attraction_j = np.exp(-distance_matrix[j, 0] / avg_dist_to_depot) if avg_dist_to_depot>0 else 1.0\n                depot_component = (depot_attraction_i + depot_attraction_j) / 2\n\n            elif i==0:\n                depot_component = np.exp(-distance_matrix[j,0]/ avg_dist_to_depot) if avg_dist_to_depot>0 else 1.0\n            elif j==0:\n                 depot_component = np.exp(-distance_matrix[i,0]/ avg_dist_to_depot) if avg_dist_to_depot>0 else 1.0\n\n            angle_diff = abs(angles[i] - angles[j])\n            angle_component = np.exp(-2 * angle_diff)\n\n            heuristic_value = distance_component * demand_component * centrality_component * depot_component * angle_component\n            heuristic_matrix[i, j] = heuristic_value\n\n    # Adaptive thresholding\n    threshold = np.mean(heuristic_matrix[heuristic_matrix > 0]) * 0.2\n    heuristic_matrix[heuristic_matrix < threshold] = 0\n\n    # Additional sparsification based on capacity and depot proximity\n    for i in range(n):\n        for j in range(n):\n            if i != 0 and j != 0 and (demands[i] + demands[j]) > 1.5 * capacity:\n                heuristic_matrix[i, j] = 0\n            if i!=0 and j!=0 and (demands[i] > capacity or demands[j] > capacity) :\n                heuristic_matrix[i, j] = 0\n            if (i==0 and distance_matrix[i,j] > 2*avg_dist_to_depot):\n                heuristic_matrix[i, j] = 0\n            if (j==0 and distance_matrix[i,j] > 2*avg_dist_to_depot):\n                heuristic_matrix[i, j] = 0\n\n\n    return heuristic_matrix\n\n[Heuristics 13th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Adaptive heuristic combining distance, demand, centrality, and depot attraction with dynamic thresholding.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n    center_x = np.mean(coordinates[1:, 0])\n    center_y = np.mean(coordinates[1:, 1])\n    total_demand = np.sum(demands[1:])\n    demand_weighted_dist_to_depot = np.sum(demands[1:] * distance_matrix[0, 1:]) / total_demand if total_demand > 0 else np.mean(distance_matrix[0,1:])\n\n    avg_dist_to_depot = np.mean(distance_matrix[0, 1:])\n\n    depot_x, depot_y = coordinates[0]\n    angles = np.arctan2(coordinates[:, 1] - depot_y, coordinates[:, 0] - depot_x)\n    avg_demand = np.mean(demands[1:])\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n\n            distance = distance_matrix[i, j]\n            distance_component = np.exp(-distance / avg_dist_to_depot) if avg_dist_to_depot > 0 else 1.0\n\n            demand_component = 1.0\n            if i != 0 and j != 0:\n                if demands[i] + demands[j] > capacity:\n                    demand_component = 0.01\n                else:\n                    demand_component = 1 - (demands[i] + demands[j]) / (2 * capacity) if capacity > 0 else 0.5\n\n\n            center_distance = (np.sqrt((coordinates[i, 0] - center_x)**2 + (coordinates[i, 1] - center_y)**2) +\n                               np.sqrt((coordinates[j, 0] - center_x)**2 + (coordinates[j, 1] - center_y)**2)) / 2\n            centrality_component = np.exp(-center_distance / demand_weighted_dist_to_depot) if demand_weighted_dist_to_depot > 0 else 1.0\n\n            depot_component = 1.0\n            if i!=0 and j!=0:\n                depot_attraction_i = np.exp(-distance_matrix[i, 0] / avg_dist_to_depot) if avg_dist_to_depot>0 else 1.0\n                depot_attraction_j = np.exp(-distance_matrix[j, 0] / avg_dist_to_depot) if avg_dist_to_depot>0 else 1.0\n                depot_component = (depot_attraction_i + depot_attraction_j) / 2\n\n            elif i==0:\n                depot_component = np.exp(-distance_matrix[j,0]/ avg_dist_to_depot) if avg_dist_to_depot>0 else 1.0\n            elif j==0:\n                 depot_component = np.exp(-distance_matrix[i,0]/ avg_dist_to_depot) if avg_dist_to_depot>0 else 1.0\n\n            angle_diff = abs(angles[i] - angles[j])\n            angle_component = np.exp(-2 * angle_diff)\n\n            heuristic_value = distance_component * demand_component * centrality_component * depot_component * angle_component\n            heuristic_matrix[i, j] = heuristic_value\n\n    #Adaptive thresholding\n    threshold = np.mean(heuristic_matrix[heuristic_matrix > 0]) * 0.2\n    heuristic_matrix[heuristic_matrix < threshold] = 0\n\n    return heuristic_matrix\n\n[Heuristics 14th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Adaptive heuristic combining distance, demand, centrality, and depot attraction with dynamic thresholding.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n    center_x = np.mean(coordinates[1:, 0])\n    center_y = np.mean(coordinates[1:, 1])\n    total_demand = np.sum(demands[1:])\n    demand_weighted_dist_to_depot = np.sum(demands[1:] * distance_matrix[0, 1:]) / total_demand if total_demand > 0 else np.mean(distance_matrix[0,1:])\n\n    avg_dist_to_depot = np.mean(distance_matrix[0, 1:])\n\n    depot_x, depot_y = coordinates[0]\n    angles = np.arctan2(coordinates[:, 1] - depot_y, coordinates[:, 0] - depot_x)\n    avg_demand = np.mean(demands[1:])\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n\n            distance = distance_matrix[i, j]\n            distance_component = np.exp(-distance / avg_dist_to_depot) if avg_dist_to_depot > 0 else 1.0\n\n            demand_component = 1.0\n            if i != 0 and j != 0:\n                if demands[i] + demands[j] > capacity:\n                    demand_component = 0.01\n                else:\n                    demand_component = 1 - (demands[i] + demands[j]) / (2 * capacity) if capacity > 0 else 0.5\n\n\n            center_distance = (np.sqrt((coordinates[i, 0] - center_x)**2 + (coordinates[i, 1] - center_y)**2) +\n                               np.sqrt((coordinates[j, 0] - center_x)**2 + (coordinates[j, 1] - center_y)**2)) / 2\n            centrality_component = np.exp(-center_distance / demand_weighted_dist_to_depot) if demand_weighted_dist_to_depot > 0 else 1.0\n\n            depot_component = 1.0\n            if i!=0 and j!=0:\n                depot_attraction_i = np.exp(-distance_matrix[i, 0] / avg_dist_to_depot) if avg_dist_to_depot>0 else 1.0\n                depot_attraction_j = np.exp(-distance_matrix[j, 0] / avg_dist_to_depot) if avg_dist_to_depot>0 else 1.0\n                depot_component = (depot_attraction_i + depot_attraction_j) / 2\n\n            elif i==0:\n                depot_component = np.exp(-distance_matrix[j,0]/ avg_dist_to_depot) if avg_dist_to_depot>0 else 1.0\n            elif j==0:\n                 depot_component = np.exp(-distance_matrix[i,0]/ avg_dist_to_depot) if avg_dist_to_depot>0 else 1.0\n\n            angle_diff = abs(angles[i] - angles[j])\n            angle_component = np.exp(-2 * angle_diff)\n\n            heuristic_value = distance_component * demand_component * centrality_component * depot_component * angle_component\n            heuristic_matrix[i, j] = heuristic_value\n\n    #Adaptive thresholding\n    threshold = np.mean(heuristic_matrix[heuristic_matrix > 0]) * 0.2\n    heuristic_matrix[heuristic_matrix < threshold] = 0\n\n    return heuristic_matrix\n\n[Heuristics 15th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Combines centrality, capacity, angle, depot attraction, and sparsification for CVRP.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n    center_x = np.mean(coordinates[1:, 0])\n    center_y = np.mean(coordinates[1:, 1])\n    total_demand = np.sum(demands[1:])\n    demand_weighted_dist_to_depot = np.sum(demands[1:] * distance_matrix[0, 1:]) / total_demand if total_demand > 0 else 0\n\n    # Adaptive parameters (to be tuned)\n    distance_weight = 1.0\n    demand_weight = 1.0\n    angle_weight = 1.0\n    centrality_weight = 1.0\n    depot_attraction_weight = 1.0\n    sparsification_threshold = 0.1  # Adjust based on problem scale\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n\n            distance = distance_matrix[i, j]\n            distance_component = 1 / (distance + 1e-6)\n\n            demand_component = 1.0\n            if i != 0 and j != 0:\n                if demands[i] + demands[j] > capacity:\n                    demand_component = 0.1  # Heavily penalize exceeding capacity\n\n            angle_component = 1.0\n            if i != 0 and j != 0:\n                angles = []\n                for k in range(n):\n                    if k != i and k != j:\n                        v1 = coordinates[i] - coordinates[j]\n                        v2 = coordinates[k] - coordinates[i]\n                        dot_product = np.dot(v1, v2)\n                        magnitudes = np.linalg.norm(v1) * np.linalg.norm(v2)\n                        if magnitudes == 0:\n                            angle = 0\n                        else:\n                            angle = np.arccos(dot_product / magnitudes)\n                        angles.append(angle)\n                if len(angles) > 0:\n                    angle_component = min(np.degrees(angles) / 180.0)\n\n            center_distance = (np.sqrt((coordinates[i, 0] - center_x)**2 + (coordinates[i, 1] - center_y)**2) +\n                               np.sqrt((coordinates[j, 0] - center_x)**2 + (coordinates[j, 1] - center_y)**2)) / 2\n            centrality_component = np.exp(-center_distance / (demand_weighted_dist_to_depot+1e-6))\n\n            depot_component = 1.0\n            if i!=0:\n                load_before_depot = demands[i]\n                depot_component = (1 + np.exp(load_before_depot/capacity)) / 2\n\n            # Context-aware combination with adaptive weights\n            heuristic_value = (\n                distance_weight * distance_component *\n                demand_weight * demand_component *\n                angle_weight * (1 - angle_component) *\n                centrality_weight * centrality_component *\n                depot_attraction_weight * depot_component\n            )\n\n            heuristic_matrix[i, j] = heuristic_value\n\n    # Sparsification: Zero out less promising edges\n    max_heuristic_value = np.max(heuristic_matrix)\n    if max_heuristic_value > 0:\n        normalized_heuristic_matrix = heuristic_matrix / max_heuristic_value\n        heuristic_matrix[normalized_heuristic_matrix < sparsification_threshold] = 0\n\n    return heuristic_matrix\n\n[Heuristics 16th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Combines centrality, capacity, angle, depot attraction, and sparsification for CVRP.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n    center_x = np.mean(coordinates[1:, 0])\n    center_y = np.mean(coordinates[1:, 1])\n    total_demand = np.sum(demands[1:])\n    demand_weighted_dist_to_depot = np.sum(demands[1:] * distance_matrix[0, 1:]) / total_demand if total_demand > 0 else 0\n\n    # Adaptive parameters (to be tuned)\n    distance_weight = 1.0\n    demand_weight = 1.0\n    angle_weight = 1.0\n    centrality_weight = 1.0\n    depot_attraction_weight = 1.0\n    sparsification_threshold = 0.1  # Adjust based on problem scale\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n\n            distance = distance_matrix[i, j]\n            distance_component = 1 / (distance + 1e-6)\n\n            demand_component = 1.0\n            if i != 0 and j != 0:\n                if demands[i] + demands[j] > capacity:\n                    demand_component = 0.1  # Heavily penalize exceeding capacity\n\n            angle_component = 1.0\n            if i != 0 and j != 0:\n                angles = []\n                for k in range(n):\n                    if k != i and k != j:\n                        v1 = coordinates[i] - coordinates[j]\n                        v2 = coordinates[k] - coordinates[i]\n                        dot_product = np.dot(v1, v2)\n                        magnitudes = np.linalg.norm(v1) * np.linalg.norm(v2)\n                        if magnitudes == 0:\n                            angle = 0\n                        else:\n                            angle = np.arccos(dot_product / magnitudes)\n                        angles.append(angle)\n                if len(angles) > 0:\n                    angle_component = min(np.degrees(angles) / 180.0)\n\n            center_distance = (np.sqrt((coordinates[i, 0] - center_x)**2 + (coordinates[i, 1] - center_y)**2) +\n                               np.sqrt((coordinates[j, 0] - center_x)**2 + (coordinates[j, 1] - center_y)**2)) / 2\n            centrality_component = np.exp(-center_distance / (demand_weighted_dist_to_depot+1e-6))\n\n            depot_component = 1.0\n            if i!=0:\n                load_before_depot = demands[i]\n                depot_component = (1 + np.exp(load_before_depot/capacity)) / 2\n\n            # Context-aware combination with adaptive weights\n            heuristic_value = (\n                distance_weight * distance_component *\n                demand_weight * demand_component *\n                angle_weight * (1 - angle_component) *\n                centrality_weight * centrality_component *\n                depot_attraction_weight * depot_component\n            )\n\n            heuristic_matrix[i, j] = heuristic_value\n\n    # Sparsification: Zero out less promising edges\n    max_heuristic_value = np.max(heuristic_matrix)\n    if max_heuristic_value > 0:\n        normalized_heuristic_matrix = heuristic_matrix / max_heuristic_value\n        heuristic_matrix[normalized_heuristic_matrix < sparsification_threshold] = 0\n\n    return heuristic_matrix\n\n[Heuristics 17th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Combines centrality, capacity, angle, depot attraction, and sparsification for CVRP.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n    center_x = np.mean(coordinates[1:, 0])\n    center_y = np.mean(coordinates[1:, 1])\n    total_demand = np.sum(demands[1:])\n    demand_weighted_dist_to_depot = np.sum(demands[1:] * distance_matrix[0, 1:]) / total_demand if total_demand > 0 else 0\n\n    # Adaptive parameters (to be tuned)\n    distance_weight = 1.0\n    demand_weight = 1.0\n    angle_weight = 1.0\n    centrality_weight = 1.0\n    depot_attraction_weight = 1.0\n    sparsification_threshold = 0.1  # Adjust based on problem scale\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n\n            distance = distance_matrix[i, j]\n            distance_component = 1 / (distance + 1e-6)\n\n            demand_component = 1.0\n            if i != 0 and j != 0:\n                if demands[i] + demands[j] > capacity:\n                    demand_component = 0.1  # Heavily penalize exceeding capacity\n\n            angle_component = 1.0\n            if i != 0 and j != 0:\n                angles = []\n                for k in range(n):\n                    if k != i and k != j:\n                        v1 = coordinates[i] - coordinates[j]\n                        v2 = coordinates[k] - coordinates[i]\n                        dot_product = np.dot(v1, v2)\n                        magnitudes = np.linalg.norm(v1) * np.linalg.norm(v2)\n                        if magnitudes == 0:\n                            angle = 0\n                        else:\n                            angle = np.arccos(dot_product / magnitudes)\n                        angles.append(angle)\n                if len(angles) > 0:\n                    angle_component = min(np.degrees(angles) / 180.0)\n\n            center_distance = (np.sqrt((coordinates[i, 0] - center_x)**2 + (coordinates[i, 1] - center_y)**2) +\n                               np.sqrt((coordinates[j, 0] - center_x)**2 + (coordinates[j, 1] - center_y)**2)) / 2\n            centrality_component = np.exp(-center_distance / (demand_weighted_dist_to_depot+1e-6))\n\n            depot_component = 1.0\n            if i!=0:\n                load_before_depot = demands[i]\n                depot_component = (1 + np.exp(load_before_depot/capacity)) / 2\n\n            # Context-aware combination with adaptive weights\n            heuristic_value = (\n                distance_weight * distance_component *\n                demand_weight * demand_component *\n                angle_weight * (1 - angle_component) *\n                centrality_weight * centrality_component *\n                depot_attraction_weight * depot_component\n            )\n\n            heuristic_matrix[i, j] = heuristic_value\n\n    # Sparsification: Zero out less promising edges\n    max_heuristic_value = np.max(heuristic_matrix)\n    if max_heuristic_value > 0:\n        normalized_heuristic_matrix = heuristic_matrix / max_heuristic_value\n        heuristic_matrix[normalized_heuristic_matrix < sparsification_threshold] = 0\n\n    return heuristic_matrix\n\n[Heuristics 18th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Combines centrality, capacity, angle, depot attraction, and sparsification for CVRP.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n    center_x = np.mean(coordinates[1:, 0])\n    center_y = np.mean(coordinates[1:, 1])\n    total_demand = np.sum(demands[1:])\n    demand_weighted_dist_to_depot = np.sum(demands[1:] * distance_matrix[0, 1:]) / total_demand if total_demand > 0 else 0\n\n    # Adaptive parameters (to be tuned)\n    distance_weight = 1.0\n    demand_weight = 1.0\n    angle_weight = 1.0\n    centrality_weight = 1.0\n    depot_attraction_weight = 1.0\n    sparsification_threshold = 0.1  # Adjust based on problem scale\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n\n            distance = distance_matrix[i, j]\n            distance_component = 1 / (distance + 1e-6)\n\n            demand_component = 1.0\n            if i != 0 and j != 0:\n                if demands[i] + demands[j] > capacity:\n                    demand_component = 0.1  # Heavily penalize exceeding capacity\n\n            angle_component = 1.0\n            if i != 0 and j != 0:\n                angles = []\n                for k in range(n):\n                    if k != i and k != j:\n                        v1 = coordinates[i] - coordinates[j]\n                        v2 = coordinates[k] - coordinates[i]\n                        dot_product = np.dot(v1, v2)\n                        magnitudes = np.linalg.norm(v1) * np.linalg.norm(v2)\n                        if magnitudes == 0:\n                            angle = 0\n                        else:\n                            angle = np.arccos(dot_product / magnitudes)\n                        angles.append(angle)\n                if len(angles) > 0:\n                    angle_component = min(np.degrees(angles) / 180.0)\n\n            center_distance = (np.sqrt((coordinates[i, 0] - center_x)**2 + (coordinates[i, 1] - center_y)**2) +\n                               np.sqrt((coordinates[j, 0] - center_x)**2 + (coordinates[j, 1] - center_y)**2)) / 2\n            centrality_component = np.exp(-center_distance / (demand_weighted_dist_to_depot+1e-6))\n\n            depot_component = 1.0\n            if i!=0:\n                load_before_depot = demands[i]\n                depot_component = (1 + np.exp(load_before_depot/capacity)) / 2\n\n            # Context-aware combination with adaptive weights\n            heuristic_value = (\n                distance_weight * distance_component *\n                demand_weight * demand_component *\n                angle_weight * (1 - angle_component) *\n                centrality_weight * centrality_component *\n                depot_attraction_weight * depot_component\n            )\n\n            heuristic_matrix[i, j] = heuristic_value\n\n    # Sparsification: Zero out less promising edges\n    max_heuristic_value = np.max(heuristic_matrix)\n    if max_heuristic_value > 0:\n        normalized_heuristic_matrix = heuristic_matrix / max_heuristic_value\n        heuristic_matrix[normalized_heuristic_matrix < sparsification_threshold] = 0\n\n    return heuristic_matrix\n\n[Heuristics 19th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    A refined heuristic for CVRP considering distance, demand, angle, centrality, and depot proximity.\n    Includes adaptive sparsification based on initial solution quality.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n\n    # Calculate the center of gravity of the customer locations\n    center_x = np.mean(coordinates[1:, 0])\n    center_y = np.mean(coordinates[1:, 1])\n\n    # Calculate the average distance from customers to the depot, weighted by demand.\n    total_demand = np.sum(demands[1:])\n    demand_weighted_dist_to_depot = np.sum(demands[1:] * distance_matrix[0, 1:]) / total_demand if total_demand > 0 else 1\n\n    # Adaptive parameters (to be tuned)\n    alpha = 1.0   # Distance importance\n    beta = 1.5    # Demand importance (increased)\n    gamma = 0.5   # Angle importance\n    delta = 1.2   # Centrality importance\n    epsilon = 0.8 # Depot attraction importance\n\n    # Sparsification threshold (initially high, can be adjusted adaptively)\n    sparsification_threshold = 0.1\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n\n            distance = distance_matrix[i, j]\n            distance_component = 1 / (distance + 1e-6)\n\n            # Demand feasibility component - severely penalize exceeding capacity\n            demand_component = 1.0\n            if i != 0 and j != 0 and demands[i] + demands[j] > capacity:\n                demand_component = 0.01  # Strong penalty\n\n            # Angle penalty: Encourages less sharp turns\n            angle_component = 1.0\n            if i != 0 and j != 0:\n                angles = []\n                for k in range(n):\n                    if k != i and k != j:\n                        v1 = coordinates[i] - coordinates[j]\n                        v2 = coordinates[k] - coordinates[i]\n                        dot_product = np.dot(v1, v2)\n                        magnitudes = np.linalg.norm(v1) * np.linalg.norm(v2)\n                        if magnitudes == 0:\n                            angle = 0\n                        else:\n                            angle = np.arccos(dot_product / magnitudes)\n                        angles.append(angle)\n                if len(angles) > 0:\n                    angle_component = min(np.degrees(angles) / 180.0)\n\n            # Centrality bonus: Favors edges closer to the center\n            center_distance = (np.sqrt((coordinates[i, 0] - center_x)**2 + (coordinates[i, 1] - center_y)**2) +\n                               np.sqrt((coordinates[j, 0] - center_x)**2 + (coordinates[j, 1] - center_y)**2)) / 2\n            centrality_component = np.exp(-center_distance / demand_weighted_dist_to_depot)\n\n            # Depot attraction\n            depot_component = 1.0\n            if i!=0:\n                load_before_depot = demands[i]\n                depot_component = (1 + np.exp(load_before_depot/capacity)) / 2\n\n            # Combined heuristic value\n            heuristic_value = (distance_component**alpha *\n                               demand_component**beta *\n                               (1 - angle_component)**gamma *\n                               centrality_component**delta *\n                               depot_component**epsilon)\n\n            heuristic_matrix[i, j] = heuristic_value\n\n    # Sparsification: Remove edges with low heuristic values\n    max_heuristic = np.max(heuristic_matrix)\n    if max_heuristic > 0:\n        heuristic_matrix[heuristic_matrix < sparsification_threshold * max_heuristic] = 0\n\n    return heuristic_matrix\n\n[Heuristics 20th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Adaptive heuristic using distance, demand, angle, and sparsification.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n\n    # Normalize distance\n    max_distance = np.max(distance_matrix[distance_matrix != np.inf])\n    normalized_distance = distance_matrix / max_distance\n    normalized_distance = np.where(normalized_distance == 0, 1e-6, normalized_distance)\n\n    # Calculate angles relative to the depot\n    depot_x, depot_y = coordinates[0]\n    angles = np.arctan2(coordinates[:, 1] - depot_y, coordinates[:, 0] - depot_x)\n\n    # Calculate demand density\n    areas = []\n    for i in range(n):\n        area = distance_matrix[0, i] ** 2\n        areas.append(area)\n    max_area = np.max(areas) if np.max(areas) > 0 else 1\n    demand_densities = demands / (np.array(areas) / max_area + 1e-6)\n\n    # Center of mass\n    center_x = np.mean(coordinates[1:, 0])\n    center_y = np.mean(coordinates[1:, 1])\n\n    # Weights (adaptive) - can be tuned during the search\n    distance_weight = 0.5\n    demand_weight = 0.25\n    angle_weight = 0.15\n    centrality_weight = 0.1\n\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                heuristic_value = 1.0\n\n                # Distance component\n                heuristic_value *= (1 / normalized_distance[i, j]) ** distance_weight\n\n                # Demand component\n                demand_penalty = np.exp(-2 * (demand_densities[i] + demand_densities[j]))\n                heuristic_value *= demand_penalty ** demand_weight\n\n                # Angle component\n                angle_diff = abs(angles[i] - angles[j])\n                angle_penalty = np.exp(-2 * angle_diff)\n                heuristic_value *= angle_penalty ** angle_weight\n\n                # Centrality component\n                center_distance_i = np.sqrt((coordinates[i, 0] - center_x)**2 + (coordinates[i, 1] - center_y)**2) / max_distance\n                center_distance_j = np.sqrt((coordinates[j, 0] - center_x)**2 + (coordinates[j, 1] - center_y)**2) / max_distance\n                avg_center_distance = (center_distance_i + center_distance_j) / 2\n                centrality_penalty = np.exp(-avg_center_distance)\n                heuristic_value *= centrality_penalty ** centrality_weight\n\n                heuristic_matrix[i, j] = heuristic_value\n\n    # Adaptive sparsification based on mean\n    threshold = np.mean(heuristic_matrix) * 0.2\n    heuristic_matrix[heuristic_matrix < threshold] = 0\n\n    return heuristic_matrix\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}