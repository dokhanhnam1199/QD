```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Newtonian Heuristics for Capacitated Vehicle Routing Problem (CVRP).

    This function combines several heuristics to estimate the desirability of including each edge
    in the final solution.  It considers distance, demand, angle (to encourage route progression),
    and a depot attraction factor to promote returning to the depot when necessary.

    Args:
        distance_matrix (np.ndarray): Distance matrix between nodes (n x n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (n x 2).
        demands (np.ndarray): Vector of customer demands (n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: A matrix of heuristics values (n x n), indicating the desirability of each edge.
                     Higher values suggest a more promising edge.
    """

    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)

    # Parameters (carefully chosen and tuned)
    distance_weight = 1.0     # Controls the importance of distance
    demand_weight = 0.5       # Controls the importance of demand compatibility
    angle_weight = 0.2        # Controls the importance of angle (route direction)
    depot_attraction = 2.0    # Controls the attractiveness of returning to the depot
    visibility_exponent = 2.0 # Scales the inverse of the distance
    demand_scaling = capacity / np.mean(demands[1:]) # Normalizes the effect of capacity

    for i in range(n):
        for j in range(n):
            if i == j:
                heuristics[i, j] = 0  # No self-loops
                continue

            # Distance component: Inverse distance, raised to a power
            distance_heuristic = 1 / (distance_matrix[i, j] ** visibility_exponent) if distance_matrix[i, j] > 0 else 0

            # Demand component: Compatibility of demands
            demand_heuristic = 1.0 / (demands[j] / demand_scaling + 1e-6) # avoid division by zero, scale by average demand and capacity
            # Angle component: Encourages smoother routes.  Angle between (i->j) and (j->depot).
            # Consider the vector from j to depot (0), and i to j. Smaller angles better.
            if i != 0 and j != 0:
                v1 = coordinates[0] - coordinates[j]  # Vector from j to depot
                v2 = coordinates[i] - coordinates[j]  # Vector from j to i
                norm_v1 = np.linalg.norm(v1)
                norm_v2 = np.linalg.norm(v2)
                if norm_v1 > 0 and norm_v2 > 0:
                  angle = np.arccos(np.dot(v1, v2) / (norm_v1 * norm_v2))
                  angle_heuristic = 1.0 / (angle + 1e-6) # Penalize sharp turns
                else:
                  angle_heuristic = 0.0
            else:
                angle_heuristic = 0.0

            # Depot Attraction Component: Encourage return to depot.
            if i != 0 and j == 0:  # Going back to depot
                depot_heuristic = depot_attraction
            else:
                depot_heuristic = 1.0


            # Combine the heuristics (weighted sum)
            heuristics[i, j] = (
                distance_weight * distance_heuristic +
                demand_weight * demand_heuristic +
                angle_weight * angle_heuristic
            ) * depot_heuristic  # Multiplying the depot_heuristic allows it to outweigh others when necessary


    return heuristics
```
