```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.

    Args:
        distance_matrix (np.ndarray): Distance matrix (shape: n by n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n by 2).
        demands (np.ndarray): Vector of customer demands (shape: n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n by n).
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros((n, n))

    # 1. Distance-based heuristic (inverse distance)
    distance_heuristic = 1 / (distance_matrix + 1e-9)  # Avoid division by zero

    # 2. Capacity-based heuristic (encourage routes that fully utilize capacity)
    capacity_heuristic = np.zeros((n, n))
    for i in range(n):
        for j in range(n):
            if i != j:
                # If adding node j to node i's route doesn't exceed capacity.
                capacity_heuristic[i,j] = (demands[i] + demands[j] <= capacity)*1

    # 3. Angle-based heuristic (encourage routes that have similar directions from depot)
    depot_angle_heuristic = np.zeros((n,n))
    depot_coord = coordinates[0, :]
    for i in range(1,n):
        for j in range(1, n):
            if i!=j:
                angle_i = np.arctan2(coordinates[i,1]-depot_coord[1], coordinates[i,0]-depot_coord[0])
                angle_j = np.arctan2(coordinates[j,1]-depot_coord[1], coordinates[j,0]-depot_coord[0])
                angle_diff = np.abs(angle_i - angle_j)
                depot_angle_heuristic[i, j] = np.exp(-angle_diff) # smaller angle diff means more preference

    # 4. Depot proximity heuristic (encourage return to depot)
    depot_proximity_heuristic = np.zeros((n,n))
    for i in range(1,n):
        depot_proximity_heuristic[i,0] = 1.0/distance_matrix[i,0] # closer to depot is better
        depot_proximity_heuristic[0,i] = 1.0/distance_matrix[0,i] #closer to depot is better.

    # Combine heuristics (weighted sum)
    heuristics_matrix = (
        0.5 * distance_heuristic +
        0.15 * capacity_heuristic +
        0.25 * depot_angle_heuristic +
        0.1 * depot_proximity_heuristic
    )

    # Set diagonal elements to zero to prevent self-loops
    np.fill_diagonal(heuristics_matrix, 0)

    return heuristics_matrix
```
