```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # A bin is feasible if it can accommodate the item
    feasible_bins = bins_remain_cap >= item

    if not np.any(feasible_bins):
        # If no bin can fit, prioritize bins with most remaining capacity (least waste if we *had* to put it somewhere).
        priorities = bins_remain_cap # Prioritize larger bins, even if item doesn't fit
        return priorities

    remaining_space = bins_remain_cap - item
    
    # Prioritize bins where the remaining space is closest to a target size, e.g., the median size of all future items.  This promotes balanced bin usage.
    # A good target might also be a fraction of the bin size (e.g., 0.2 * bin_size). This would aim for leaving bins partially full but not too empty.
    # However since we don't know future items, use fraction of bin size. Assuming bin size is 1.
    target_remaining_space = 0.2 

    # Calculate the absolute difference between remaining space and the target.
    space_diff = np.abs(remaining_space - target_remaining_space)
    
    # Invert the space difference to create a priority: smaller difference = higher priority. Add a small constant to avoid division by zero.
    priorities[feasible_bins] = 1.0 / (space_diff[feasible_bins] + 1e-9)
    
    # Greatly prioritize bins that are almost full (small remaining space).  This consolidates items and reduces fragmentation.
    almost_full = np.logical_and(feasible_bins, remaining_space <= 0.1) # Tweak threshold
    priorities[almost_full] += 10.0 # Increase importance
    
    # Add a slight preference for bins that fit the item more snugly *without* being "almost full".  This differentiates between bins that are merely feasible.
    snug_fit = np.logical_and(feasible_bins, remaining_space > 0.1) 
    priorities[snug_fit] += (1 / (remaining_space[snug_fit] + 0.1)) * 0.5 # Scale this effect.

    return priorities
```
