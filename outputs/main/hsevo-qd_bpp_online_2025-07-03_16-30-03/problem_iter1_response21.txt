```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.
    Inspired by the balance between energy and entropy. Maximizing free space is good (entropy),
    but filling close to capacity is also good (energy minimization - analogy).  Find a balance.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Ensure no division by zero.
    bins_remain_cap = np.maximum(bins_remain_cap, 1e-9)  # Replace 0 with small value

    # 1. Feasibility: Can the item fit?  If not, priority is -inf.
    can_fit = bins_remain_cap >= item
    priorities = np.where(can_fit, 0.0, -np.inf)  # -inf if it doesn't fit.

    # 2. Remaining space after placement. Represents "entropy" - minimize remaining space to maximize packing density. A small epsilon term helps avoid dividing by zero.
    remaining_space = np.where(can_fit, bins_remain_cap - item + 1e-9, np.inf)

    # 3.  A term that favors bins that are close to full *after* the item is added.
    #     This relates to "energy minimization". We want to fill bins efficiently.
    fill_ratio_after = np.where(can_fit, item / bins_remain_cap, 0.0)  # How much is bin filled relative to orig capacity *before* insertion.

    # A weight parameter to control the relative importance of entropy and energy.
    alpha = 0.7

    # 4. The overall priority is a weighted combination of entropy and (negative) energy.
    # We invert the entropy term since we want *smaller* remaining space (higher density) to get *higher* priority.

    priorities = np.where(can_fit, alpha * fill_ratio_after - (1 - alpha) * remaining_space, priorities)  # Combination formula.
    return priorities
```
