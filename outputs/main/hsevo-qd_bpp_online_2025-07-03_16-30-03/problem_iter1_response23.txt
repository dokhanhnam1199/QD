```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap)
    # First, prioritize bins that can fit the item
    can_fit = bins_remain_cap >= item
    priorities[can_fit] += 1  # Base priority for bins that can fit

    # Prioritize bins with tighter fit (minimize wasted space)
    wasted_space = bins_remain_cap - item
    wasted_space[~can_fit] = np.inf  # Ignore bins that can't fit

    #Inverse of wasted space for fitting bins - more priority given to bins with smallest waste
    priorities[can_fit] += 1.0 / (1e-9 + wasted_space[can_fit])

    # Penalize almost full bins to try and fill other less empty bins
    almost_full = (bins_remain_cap > 0) & (bins_remain_cap < 0.25 * np.max(bins_remain_cap)) #arbitrary threshold
    priorities[almost_full] -= 0.5 # reduces the chance of choosing the almost full bin

    # If item is large, prioritize partially filled bins to avoid fragmentation.
    large_item_threshold = 0.5 * np.max(bins_remain_cap) #arbitrary threshold
    if item > large_item_threshold:
        partially_filled = (bins_remain_cap > 0.25 * np.max(bins_remain_cap)) & (bins_remain_cap < 0.75 * np.max(bins_remain_cap))
        priorities[partially_filled] += 0.25

    # If the item is small, prioritize empty bins last, if there are any bins which is nearly empty, that's where items must be directed to
    small_item_threshold = 0.1 * np.max(bins_remain_cap) #arbitrary threshold
    if item <= small_item_threshold:
        almost_empty = bins_remain_cap > 0.95 * np.max(bins_remain_cap)
        priorities[almost_empty] = -np.inf #do not direct to empty/almost empty bin, unless it has to

    return priorities
```
