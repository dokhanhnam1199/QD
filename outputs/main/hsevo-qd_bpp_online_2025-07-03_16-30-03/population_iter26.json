[
  {
    "stdout_filepath": "problem_iter0_stdout0.txt",
    "code_path": "problem_iter0_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    ratios = item / bins_remain_cap\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities",
    "response_id": 0,
    "obj": 149.30195452732352,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 11.60964047443681,
    "mi": 94.04446327225541,
    "token_count": 47.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response7.txt_stdout.txt",
    "code_path": "problem_iter1_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # A bin is feasible if it can accommodate the item\n    feasible_bins = bins_remain_cap >= item\n    \n    if not np.any(feasible_bins):\n      # If no bin can fit, consider using the least-filled bins \n      # (though it won't actually fit).  This helps guide decision-making\n      # in extreme cases. The priority is slightly negative and inversely propotional\n      # to how full is the bin.\n      priorities = -bins_remain_cap \n      return priorities\n\n    # First consideration: How much empty space will be left *after* adding the item?\n    remaining_space = bins_remain_cap - item\n    \n    #Prioritize almost full bins\n    priorities[feasible_bins] = 1/(remaining_space[feasible_bins]+1e-9) #avoid division by zero. Want small values of remaining_space to yield large priorities.\n    \n    #Try to fill the bins\n    priorities[feasible_bins] += np.where(remaining_space[feasible_bins] >= 0 , 1.0,0)\n    \n    # Penalize bins where item fits only by tiny amount to encourage filling them up\n    # This makes a significant different (a trick from Quantum Mechanics, like a wave function collapse based on smallest energy changes)\n    almost_full = np.logical_and(feasible_bins, remaining_space < 0.1)\n    priorities[almost_full] += 5.0 # Greatly prioritize nearly-full bins\n\n    \n    return priorities",
    "response_id": 7,
    "tryHS": true,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 108.04820237218406,
    "mi": 81.51858231980326,
    "token_count": 126.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response8.txt_stdout.txt",
    "code_path": "problem_iter2_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines remaining space, feasibility, and near-fullness for priority.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        priorities = -bins_remain_cap\n        return priorities\n\n    remaining_space = bins_remain_cap - item\n    \n    # Prioritize almost full bins based on remaining space\n    priorities[feasible_bins] = 1 / (remaining_space[feasible_bins] + 1e-9)\n    priorities[feasible_bins] += np.where(remaining_space[feasible_bins] >= 0, 1.0, 0)\n    \n    # Heavily prioritize bins that become almost full\n    almost_full = np.logical_and(feasible_bins, remaining_space < 0.1)\n    priorities[almost_full] += 5.0\n\n    # Consider ratio of item to bin size, but only when feasible and not almost full\n    other_feasible = np.logical_and(feasible_bins, ~almost_full)\n    ratios = item / bins_remain_cap\n    priorities[other_feasible] += -np.log(ratios[other_feasible]) * 0.1 # Scale down effect\n    \n    return priorities",
    "response_id": 8,
    "tryHS": true,
    "obj": 51.09692859992023,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 98.09910819000817,
    "mi": 61.48580899149723,
    "token_count": 121.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response1.txt_stdout.txt",
    "code_path": "problem_iter3_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # A bin is feasible if it can accommodate the item\n    feasible_bins = bins_remain_cap >= item\n    \n    if not np.any(feasible_bins):\n      # If no bin can fit, consider using the least-filled bins \n      # (though it won't actually fit).  This helps guide decision-making\n      # in extreme cases. The priority is slightly negative and inversely propotional\n      # to how full is the bin.\n      priorities = -bins_remain_cap \n      return priorities\n\n    # First consideration: How much empty space will be left *after* adding the item?\n    remaining_space = bins_remain_cap - item\n    \n    #Prioritize almost full bins\n    priorities[feasible_bins] = 1/(remaining_space[feasible_bins]+1e-9) #avoid division by zero. Want small values of remaining_space to yield large priorities.\n    \n    #Try to fill the bins\n    priorities[feasible_bins] += np.where(remaining_space[feasible_bins] >= 0 , 1.0,0)\n    \n    # Penalize bins where item fits only by tiny amount to encourage filling them up\n    # This makes a significant different (a trick from Quantum Mechanics, like a wave function collapse based on smallest energy changes)\n    almost_full = np.logical_and(feasible_bins, remaining_space < 0.1)\n    priorities[almost_full] += 5.0 # Greatly prioritize nearly-full bins\n\n    # NEW: Introduce a moderate penalty for bins with excessive remaining space.\n    # This encourages filling bins more completely and reduces fragmentation.\n    excessive_space = np.logical_and(feasible_bins, remaining_space > 0.5) #tune parameter\n    priorities[excessive_space] -= 1.0  # Moderate penalty\n\n    # NEW: Give a slight bonus to bins whose remaining capacity *after* placing the\n    # item is close to the size of the next smallest item seen so far.\n    # This anticipates future placements and attempts to create suitable spaces.\n\n    # In a real implementation, we'd likely have access to a history of item sizes.\n    # Here, we'll simulate it by considering \"hypothetical\" next item sizes.\n    hypothetical_next_items = np.array([0.1, 0.2, 0.3, 0.4, 0.5])  # Example sizes\n    for next_item_size in hypothetical_next_items:\n        ideal_remaining_space = next_item_size\n        close_to_ideal = np.logical_and(feasible_bins, np.abs(remaining_space - ideal_remaining_space) < 0.1)\n        priorities[close_to_ideal] += 0.5\n\n    \n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 228.32510677099592,
    "mi": 75.55914497022471,
    "token_count": 201.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter19_response0.txt_stdout.txt",
    "code_path": "problem_iter19_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, \n                bins_remain_cap: np.ndarray,\n                division_eps: float = 1.2751144605391451e-09,\n                base_priority: float = 1.0029373306865028,\n                almost_full_threshold: float = 0.05814860685353829,\n                almost_full_priority: float = 4.659312610265962) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        division_eps: Epsilon to avoid division by zero.\n        base_priority: Base priority to fill the bins.\n        almost_full_threshold: Threshold to consider a bin as almost full.\n        almost_full_priority: Priority for almost full bins.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # A bin is feasible if it can accommodate the item\n    feasible_bins = bins_remain_cap >= item\n    \n    if not np.any(feasible_bins):\n      # If no bin can fit, consider using the least-filled bins \n      # (though it won't actually fit).  This helps guide decision-making\n      # in extreme cases. The priority is slightly negative and inversely propotional\n      # to how full is the bin.\n      priorities = -bins_remain_cap \n      return priorities",
    "response_id": 0,
    "tryHS": true,
    "obj": 4.487435181491823,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 18.094737505048094,
    "mi": 90.012771312655,
    "token_count": 104.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response0.txt_stdout.txt",
    "code_path": "problem_iter5_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes near-full bins and penalizes excessive space.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        priorities = -bins_remain_cap\n        return priorities\n\n    remaining_space = bins_remain_cap - item\n    \n    # Prioritize almost full bins based on remaining space\n    priorities[feasible_bins] = 1 / (remaining_space[feasible_bins] + 1e-9)\n    priorities[feasible_bins] += np.where(remaining_space[feasible_bins] >= 0, 1.0, 0)\n    \n    # Heavily prioritize bins that become almost full\n    almost_full = np.logical_and(feasible_bins, remaining_space < 0.1)\n    priorities[almost_full] += 5.0\n\n    # Penalize bins with excessive space to encourage filling others\n    excessive_space = np.logical_and(feasible_bins, remaining_space > 0.5)\n    priorities[excessive_space] -= 0.5 * remaining_space[excessive_space]\n    \n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 122.9848878378053,
    "mi": 85.95597981968847,
    "token_count": 127.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter7_response0.txt_stdout.txt",
    "code_path": "problem_iter7_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, almost_full_threshold: float = 0.3829163310070497, almost_full_priority: float = 6.053163233324419, ratio_log_scale: float = 0.4423505134462586, small_number: float = 3.4636963604744676e-07, feasibility_weight: float = 0.5240249141101576) -> np.ndarray:\n    \"\"\"Combines remaining space, feasibility, and near-fullness for priority.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        priorities = -bins_remain_cap\n        return priorities",
    "response_id": 0,
    "tryHS": true,
    "obj": 4.487435181491823,
    "SLOC": 6.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 18.094737505048094,
    "mi": 72.49065824743965,
    "token_count": 94.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response0.txt_stdout.txt",
    "code_path": "problem_iter8_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines remaining space, feasibility, near-fullness, and penalizes excessive space.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        priorities = -bins_remain_cap\n        return priorities\n\n    remaining_space = bins_remain_cap - item\n    \n    # Prioritize almost full bins based on remaining space\n    priorities[feasible_bins] = 1 / (remaining_space[feasible_bins] + 1e-9)\n    priorities[feasible_bins] += np.where(remaining_space[feasible_bins] >= 0, 1.0, 0)\n    \n    # Heavily prioritize bins that become almost full\n    almost_full = np.logical_and(feasible_bins, remaining_space < 0.1)\n    priorities[almost_full] += 5.0\n\n    # Penalty for excessive remaining space (avoid fragmentation)\n    priorities[feasible_bins] -= (remaining_space[feasible_bins] / np.max(bins_remain_cap)) * 0.5\n\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 14.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 157.89111045234063,
    "mi": 86.32120715979255,
    "token_count": 159.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response0.txt_stdout.txt",
    "code_path": "problem_iter9_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # A bin is feasible if it can accommodate the item\n    feasible_bins = bins_remain_cap >= item\n    \n    if not np.any(feasible_bins):\n      # If no bin can fit, consider using the least-filled bins \n      # (though it won't actually fit).  This helps guide decision-making\n      # in extreme cases. The priority is slightly negative and inversely proportional\n      # to how full is the bin.\n      priorities = -bins_remain_cap\n      return priorities\n\n    # First consideration: How much empty space will be left *after* adding the item?\n    remaining_space = bins_remain_cap - item\n    \n    #Prioritize almost full bins using a refined approach:\n    priorities[feasible_bins] = 1.0 / (remaining_space[feasible_bins] + 1e-9) # Inverse remaining space\n    \n    # Incentive to use bins\n    priorities[feasible_bins] += 0.5  # Base incentive\n\n    # Stronger incentive for bins that are nearly full\n    almost_full = np.logical_and(feasible_bins, remaining_space < 0.2) #Increased threshold to 0.2\n    priorities[almost_full] += 3.0\n\n    # Small penalty for leaving too much space, to avoid fragmentation.\n    # This encourages filling bins more completely.\n    too_much_space = np.logical_and(feasible_bins, remaining_space > 0.5)\n    priorities[too_much_space] -= 1.0 \n    \n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 178.61670928936152,
    "mi": 77.60512257789493,
    "token_count": 186.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response1.txt_stdout.txt",
    "code_path": "problem_iter11_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes feasible, near-full bins and penalizes excessive space.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        priorities = -bins_remain_cap\n        return priorities\n\n    remaining_space = bins_remain_cap - item\n    \n    # Prioritize almost full bins based on remaining space\n    priorities[feasible_bins] = 1 / (remaining_space[feasible_bins] + 1e-9)\n    \n    # Heavily prioritize bins that become almost full\n    almost_full = np.logical_and(feasible_bins, remaining_space < 0.1)\n    priorities[almost_full] += 5.0\n\n    # Penalize bins with excessive space to encourage filling others\n    excessive_space = np.logical_and(feasible_bins, remaining_space > 0.5)\n    priorities[excessive_space] -= 0.5 * remaining_space[excessive_space]\n    \n    # Give a base reward for feasible bins\n    priorities[feasible_bins] += 0.6\n\n    return priorities",
    "response_id": 1,
    "tryHS": true,
    "obj": 4.048663741523748,
    "SLOC": 14.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 157.89111045234063,
    "mi": 87.25375824289063,
    "token_count": 147.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response0.txt_stdout.txt",
    "code_path": "problem_iter12_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # A bin is feasible if it can accommodate the item\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        # If no bin can fit, consider using the least-filled bins\n        # (though it won't actually fit). This helps guide decision-making\n        # in extreme cases. The priority is slightly negative and inversely proportional\n        # to how full is the bin.\n        priorities = -bins_remain_cap\n        return priorities\n\n    # First consideration: How much empty space will be left *after* adding the item?\n    remaining_space = bins_remain_cap - item\n\n    # Incentive 1: Prioritize bins with smaller remaining space (after fitting item)\n    priorities[feasible_bins] += 1.0 / (remaining_space[feasible_bins] + 1e-9)\n\n    # Incentive 2: Heavily prioritize almost full bins. This is crucial.\n    almost_full = np.logical_and(feasible_bins, remaining_space < 0.1)\n    priorities[almost_full] += 10.0\n\n    # Incentive 3: Moderate priority boost for bins that aren't \"almost full\"\n    # but still have relatively little space left. Prevents extreme fragmentation.\n    moderately_full = np.logical_and(feasible_bins, remaining_space < 0.3)\n    priorities[moderately_full] += 2.0\n\n    # Incentive 4: Slightly penalize bins that are too empty.\n    # The amount is subtracted from the priority, so it only affects feasible bins\n    # but still can prioritize one bin over other.\n    priorities[feasible_bins] -= (bins_remain_cap[feasible_bins] > 0.7) * 0.5\n\n    return priorities",
    "response_id": 0,
    "tryHS": true,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 151.30376252379818,
    "mi": 84.76650433362452,
    "token_count": 173.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter15_response0.txt_stdout.txt",
    "code_path": "problem_iter15_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # A bin is feasible if it can accommodate the item\n    feasible_bins = bins_remain_cap >= item\n    \n    if not np.any(feasible_bins):\n      # If no bin can fit, consider using the least-filled bins \n      # (though it won't actually fit).  This helps guide decision-making\n      # in extreme cases. The priority is slightly negative and inversely propotional\n      # to how full is the bin.\n      priorities = -bins_remain_cap \n      return priorities\n\n    # First consideration: How much empty space will be left *after* adding the item?\n    remaining_space = bins_remain_cap - item\n    \n    #Prioritize almost full bins\n    priorities[feasible_bins] = 1/(remaining_space[feasible_bins]+1e-9) #avoid division by zero. Want small values of remaining_space to yield large priorities.\n    \n    #Try to fill the bins\n    priorities[feasible_bins] += np.where(remaining_space[feasible_bins] >= 0 , 1.0,0)\n    \n    # Penalize bins where item fits only by tiny amount to encourage filling them up\n    # This makes a significant different (a trick from Quantum Mechanics, like a wave function collapse based on smallest energy changes)\n    almost_full = np.logical_and(feasible_bins, remaining_space < 0.1)\n    priorities[almost_full] += 5.0 # Greatly prioritize nearly-full bins\n\n    # Predictive element: Slightly penalize bins that, after this item, become *too* small\n    # to accommodate potentially larger items in the future (heuristic threshold 0.25)\n    too_small = np.logical_and(feasible_bins, remaining_space < 0.25)\n    priorities[too_small] -= 2.0  # Mild penalty to discourage leaving extremely small spaces\n\n    # Incentive for bins with substantial remaining capacity, but not too large to waste\n    # The sweet spot is between 0.25 and 0.75 (can be adjusted)\n    good_fit = np.logical_and(feasible_bins, np.logical_and(remaining_space >= 0.25, remaining_space <= 0.75))\n    priorities[good_fit] += 1.5 # Boost bins with a moderately good fit.\n\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 16.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 171.8226790216648,
    "mi": 82.74777141389684,
    "token_count": 185.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter17_response0.txt_stdout.txt",
    "code_path": "problem_iter17_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on remaining space, feasibility, and fullness.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        priorities = -bins_remain_cap\n        return priorities\n\n    remaining_space = bins_remain_cap - item\n\n    # Prioritize almost full bins (crucial).\n    almost_full = np.logical_and(feasible_bins, remaining_space < 0.1)\n    priorities[almost_full] += 10.0\n\n    # Prioritize bins with smaller remaining space (after fitting item)\n    priorities[feasible_bins] += 1.0 / (remaining_space[feasible_bins] + 1e-9)\n\n    # Penalize bins that are too empty\n    priorities[feasible_bins] -= (bins_remain_cap[feasible_bins] > 0.7) * 0.5\n\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 14.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 138.24238017775622,
    "mi": 59.08698387396238,
    "token_count": 140.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response0.txt_stdout.txt",
    "code_path": "problem_iter20_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Calculates bin priorities, favoring almost-full bins and penalizing excessive space.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        priorities = -bins_remain_cap\n        return priorities\n\n    remaining_space = bins_remain_cap - item\n    priorities[feasible_bins] = 1.0 / (remaining_space[feasible_bins] + 1e-9)\n    priorities[feasible_bins] += 0.5\n\n    almost_full = np.logical_and(feasible_bins, remaining_space < 0.1)\n    priorities[almost_full] += 3.0\n\n    too_much_space = np.logical_and(feasible_bins, remaining_space > 0.5)\n    priorities[too_much_space] -= 1.0\n\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 14.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 249.28567922126666,
    "mi": 83.45245825258976,
    "token_count": 188.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter21_response3.txt_stdout.txt",
    "code_path": "problem_iter21_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        priorities = -bins_remain_cap\n        return priorities\n    \n    remaining_space = bins_remain_cap - item\n    \n    # Adaptive weight for remaining space: Emphasize smaller remaining space less as bins fill up\n    space_priority = 1 / (remaining_space + 1e-9)\n    \n    # Calculate bin utilization: how full is the bin *after* placing the item?\n    future_utilization = (bins_remain_cap - remaining_space) / (bins_remain_cap + item) #Original capacity of bin assumed to be bins_remain_cap + item before placing the item\n\n    # Prioritize bins that will be moderately full to avoid fragmentation\n    utilization_priority = np.exp(-((future_utilization - 0.7)**2) / 0.05) # Gaussian-like curve centered around 0.7\n\n    priorities[feasible_bins] = space_priority[feasible_bins] + utilization_priority[feasible_bins]\n    \n    # Dynamic adjustment: As bins fill, be more aggressive about nearly full bins\n    fill_threshold = np.mean(bins_remain_cap[feasible_bins]) # Adaptive threshold\n    almost_full = np.logical_and(feasible_bins, remaining_space < 0.1 * fill_threshold) # Dynamic percentage of mean\n    priorities[almost_full] += 10.0  # Increased emphasis\n\n    # Limited look-ahead: Penalize bins if the remaining space will be less than the mean of items\n    # This attempts to anticipate the need for a suitable bin for an average-sized item later.\n    mean_remaining_item_size = item # Assume current item size is a good proxy.\n    look_ahead_penalty = np.logical_and(feasible_bins, remaining_space < mean_remaining_item_size)\n    priorities[look_ahead_penalty] -= 2.0\n    \n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 3.8691663342640563,
    "SLOC": 17.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 271.8519998980832,
    "mi": 80.9456081286342,
    "token_count": 229.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter22_response0.txt_stdout.txt",
    "code_path": "problem_iter22_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, almost_full_threshold: float = 0.12046219606270642, moderately_full_threshold: float = 0.38527111928509306,\n                empty_bin_threshold: float = 0.8202358497745701, almost_full_weight: float = 14.27288558350223, moderately_full_weight: float = 4.230395346261988,\n                empty_bin_penalty: float = 0.915319799189316, remaining_space_weight: float = 1.0201452336390084, epsilon: float = 8.149015682582224e-09) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        almost_full_threshold: Threshold for considering a bin \"almost full\".\n        moderately_full_threshold: Threshold for considering a bin \"moderately full\".\n        empty_bin_threshold: Threshold for considering a bin \"too empty\".\n        almost_full_weight: Weight for almost full bins.\n        moderately_full_weight: Weight for moderately full bins.\n        empty_bin_penalty: Penalty for empty bins.\n        remaining_space_weight: Weight for remaining space.\n        epsilon: Small value to avoid division by zero.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # A bin is feasible if it can accommodate the item\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        # If no bin can fit, consider using the least-filled bins\n        # (though it won't actually fit). This helps guide decision-making\n        # in extreme cases. The priority is slightly negative and inversely proportional\n        # to how full is the bin.\n        priorities = -bins_remain_cap\n        return priorities",
    "response_id": 0,
    "tryHS": true,
    "obj": 4.487435181491823,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 18.094737505048094,
    "mi": 68.56537039510901,
    "token_count": 125.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter23_response1.txt_stdout.txt",
    "code_path": "problem_iter23_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on remaining space, utilization, and feasibility.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        priorities = -bins_remain_cap\n        return priorities\n\n    remaining_space = bins_remain_cap - item\n    space_priority = 1 / (remaining_space + 1e-9)\n    future_utilization = (bins_remain_cap - remaining_space) / (bins_remain_cap + item)\n\n    utilization_priority = np.exp(-((future_utilization - 0.7)**2) / 0.05)\n\n    priorities[feasible_bins] = space_priority[feasible_bins] + utilization_priority[feasible_bins]\n\n    fill_threshold = np.mean(bins_remain_cap[feasible_bins])\n    almost_full = np.logical_and(feasible_bins, remaining_space < 0.1 * fill_threshold)\n    priorities[almost_full] += 10.0\n\n    mean_remaining_item_size = item\n    look_ahead_penalty = np.logical_and(feasible_bins, remaining_space < mean_remaining_item_size)\n    priorities[look_ahead_penalty] -= 2.0\n    \n    #Adding small item consideration (balancing space)\n    small_item_bonus = np.logical_and(feasible_bins, item < 0.2 * np.mean(bins_remain_cap))\n    priorities[small_item_bonus] += 1.0\n\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 3.8691663342640563,
    "SLOC": 14.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 177.87213211613133,
    "mi": 78.95005731575759,
    "token_count": 164.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter24_response3.txt_stdout.txt",
    "code_path": "problem_iter24_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        priorities = -bins_remain_cap\n        return priorities\n    \n    remaining_space = bins_remain_cap - item\n    \n    # Space utilization priority: Prefer bins that leave a smaller remaining space\n    # but penalize if the remaining space is too small to be useful\n    space_priority = 1 / (remaining_space + 1e-9)\n    \n    # Fine-tune space priority based on how well the item fits\n    fit_ratio = item / bins_remain_cap\n    space_priority = space_priority * (1 + fit_ratio)\n    \n    # Penalize bins where the item doesn't fit well (wasteful space utilization)\n    wasteful_bins = np.logical_and(feasible_bins, remaining_space > 0.5 * bins_remain_cap)\n    space_priority[wasteful_bins] *= 0.5\n    \n    # Prioritize bins that will be moderately full to avoid fragmentation\n    future_utilization = (bins_remain_cap - remaining_space) / (bins_remain_cap + item)\n\n    utilization_priority = np.exp(-((future_utilization - 0.7)**2) / 0.05)\n    \n    # Dynamic Adjustment: More aggressive for nearly full bins\n    fill_threshold = np.mean(bins_remain_cap[feasible_bins])\n    almost_full = np.logical_and(feasible_bins, remaining_space < 0.1 * fill_threshold)\n    priorities[almost_full] += 10.0\n\n    # Limited look-ahead with dynamic mean item size consideration.\n    mean_item_size = np.mean(item) if isinstance(item, np.ndarray) else item #Account for the edge case of item being a numpy array\n    look_ahead_penalty = np.logical_and(feasible_bins, remaining_space < 0.7 * mean_item_size)\n    priorities[look_ahead_penalty] -= 2.0\n\n    # Add space utilization and utilization priorities\n    priorities[feasible_bins] = space_priority[feasible_bins] + utilization_priority[feasible_bins]\n    \n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 20.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 403.99793977916,
    "mi": 80.20840611305343,
    "token_count": 252.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter25_response0.txt_stdout.txt",
    "code_path": "problem_iter25_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, almost_full_threshold: float = 0.1940567528679835,\n                  almost_full_priority: float = 2.9079571772090755, excessive_space_threshold: float = 0.6158843095652273,\n                  excessive_space_penalty: float = 0.38206384097129065, feasible_bin_reward: float = 0.5744277450024077,\n                  epsilon: float = 9.946779428236522e-10) -> np.ndarray:\n    \"\"\"Prioritizes feasible, near-full bins and penalizes excessive space.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        priorities = -bins_remain_cap\n        return priorities",
    "response_id": 0,
    "tryHS": true,
    "obj": 4.487435181491823,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 18.094737505048094,
    "mi": 72.49065824743965,
    "token_count": 103.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter26_response0.txt_stdout.txt",
    "code_path": "problem_iter26_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on remaining space, feasibility, and fullness.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        priorities = -bins_remain_cap\n        return priorities\n\n    remaining_space = bins_remain_cap - item\n\n    # Prioritize almost full bins.\n    almost_full = np.logical_and(feasible_bins, remaining_space < 0.1)\n    priorities[almost_full] += 10.0\n\n    # Prioritize bins with smaller remaining space.\n    priorities[feasible_bins] += 1.0 / (remaining_space[feasible_bins] + 1e-9)\n\n    # Penalize bins that are too empty.\n    priorities[feasible_bins] -= (bins_remain_cap[feasible_bins] > 0.7) * 0.5\n\n    # Add a small bonus if the item fits snugly.\n    snug_fit = np.logical_and(feasible_bins, remaining_space < 0.3)\n    priorities[snug_fit] += 2.0\n\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 124.86408532184433,
    "mi": 60.75219070284577,
    "token_count": 134.0,
    "exec_success": true
  }
]