{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # A bin is feasible if it can accommodate the item\n    feasible_bins = bins_remain_cap >= item\n    \n    if not np.any(feasible_bins):\n      # If no bin can fit, consider using the least-filled bins \n      # (though it won't actually fit).  This helps guide decision-making\n      # in extreme cases. The priority is slightly negative and inversely propotional\n      # to how full is the bin.\n      priorities = -bins_remain_cap \n      return priorities\n\n    # First consideration: How much empty space will be left *after* adding the item?\n    remaining_space = bins_remain_cap - item\n    \n    #Prioritize almost full bins\n    priorities[feasible_bins] = 1/(remaining_space[feasible_bins]+1e-9) #avoid division by zero. Want small values of remaining_space to yield large priorities.\n    \n    #Try to fill the bins\n    priorities[feasible_bins] += np.where(remaining_space[feasible_bins] >= 0 , 1.0,0)\n    \n    # Penalize bins where item fits only by tiny amount to encourage filling them up\n    # This makes a significant different (a trick from Quantum Mechanics, like a wave function collapse based on smallest energy changes)\n    almost_full = np.logical_and(feasible_bins, remaining_space < 0.1)\n    priorities[almost_full] += 5.0 # Greatly prioritize nearly-full bins\n\n    \n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines remaining space, feasibility, and near-fullness for priority.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        priorities = -bins_remain_cap\n        return priorities\n\n### Analyze & experience\n- *   Comparing (1st) vs (20th), we see the best heuristic considers feasibility, remaining space, near-fullness, and penalizes excessive space while the worst only considers the ratio of item to bin size.\n*   (2nd best) vs (second worst) shows similar contrast, where the second-best prioritizes near-full bins and penalizes excessive space, encompassing more factors than the ratio-based approach.\n*   Comparing (1st) vs (2nd), we see the 1st heuristic introduces a more refined approach using inverse remaining space, base incentive, and a stronger incentive for bins that are nearly full, along with a penalty for leaving too much space. The 2nd heuristic simplifies this by prioritizing almost full bins based on remaining space, heavily prioritizing bins that become almost full, and penalizing bins with excessive space.\n*   (3rd) vs (4th) shows that 3rd heuristic introduces a penalty for excessive remaining space to avoid fragmentation.\n*   Comparing (second worst) vs (worst), we see both heuristics solely rely on the ratio of item size to bin capacity, and then take the negative log of the ratio. The approach is fundamentally flawed due to lacking feasibility checks or any mechanisms for prioritizing bins.\n\nOverall: The better heuristics incorporate feasibility checks, prioritize nearly-full bins, and penalize excessive space to prevent fragmentation. The worst heuristics rely solely on the ratio of item size to remaining bin capacity, leading to poor performance. Introduction of tunable hyperparameters does not automatically make the heuristic perform better, as evidenced by the middle ranked heuristics.\n- \nOkay, let's refine \"Current self-reflection\" into something more actionable for heuristic design, avoiding the pitfalls of \"Ineffective self-reflection\":\n\n*   **Keywords:** Feasibility-first, Incentive-driven, Bin utilization, Calibrated combination.\n\n*   **Advice:** Prioritize initial feasibility validation. Then, design incentives for near-optimal bin filling based on a weighted combination of factors (e.g., space remaining, number of items).\n\n*   **Avoid:** Overly complex lookahead or excessive parameters early on. Don't solely rely on penalizing empty space without rewarding near-full bins.\n\n*   **Explanation:** Begin with fundamental feasibility rules. Subsequently, construct a weighted incentive system focused on *achieving* near-full bins, not just avoiding empty ones. Calibrate the weights through experimentation.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}