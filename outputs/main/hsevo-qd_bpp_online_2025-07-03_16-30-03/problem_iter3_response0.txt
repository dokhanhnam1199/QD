```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    feasible_bins = bins_remain_cap >= item

    if not np.any(feasible_bins):
        # If no bin can fit, prioritize bins closest to fitting, but negatively
        diff = item - bins_remain_cap
        priorities = -diff  # Prioritize bins with smallest difference
        return priorities

    remaining_space = bins_remain_cap - item
    
    # 1. Fill-Rate Priority (Higher when bin is almost full after adding the item)
    fill_rate = 1 / (remaining_space + 1e-9)
    priorities[feasible_bins] += fill_rate[feasible_bins]

    # 2. Space Utilization Bonus (Positive reinforcement for bins with good space utilization)
    utilization_threshold = 0.9  # Tunable parameter
    utilization_bonus = np.where((bins_remain_cap - remaining_space) / bins_remain_cap > utilization_threshold, 2.0, 0.0)
    priorities[feasible_bins] += utilization_bonus[feasible_bins]

    # 3. Small Remaining Space Penalty (Discourage creation of small remaining spaces to reduce fragmentation)
    small_space_threshold = 0.2  # Tunable parameter
    small_space_penalty = np.where(np.logical_and(feasible_bins, remaining_space <= small_space_threshold), -1.0, 0.0)
    priorities[feasible_bins] += small_space_penalty[feasible_bins]

    # 4. Almost Full Bonus (Greatly prioritize nearly-full bins)
    almost_full = np.logical_and(feasible_bins, remaining_space < 0.1)
    priorities[almost_full] += 5.0

    # 5. Bin Level Balancing : slight preference for bins with capacities close to average
    average_cap = np.mean(bins_remain_cap)
    cap_diff = np.abs(bins_remain_cap - average_cap)
    cap_balance_priority = -cap_diff / np.max(cap_diff + 1e-9)  # Normalize and invert the difference
    priorities[feasible_bins] += cap_balance_priority[feasible_bins] * 0.5 # Add a small weight to it.

    return priorities
```
