```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Initialize priorities with a base value (e.g., 0).  Avoids division by zero
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Calculate the "fit score" - how well the item fits into the bin. A higher score indicates a better fit.
    fit_scores = bins_remain_cap - item
    fit_scores[fit_scores < 0] = -np.inf # make infeasible solutions have very low score.

    # Scale the fit scores. Larger remain capacities need proportionally larger fit scores to make sense
    scaled_fit_scores = fit_scores / (bins_remain_cap + 1e-9) #Avoid dividing by zero
    
    # Give a slight preference to bins that are fuller relative to being completely empty.
    density_score = (1 - bins_remain_cap/ np.max(bins_remain_cap)) if np.max(bins_remain_cap) >0 else 0 # give a score to bins that are more full.

    # Combine scores, giving importance to how tight the item fits.
    priorities = scaled_fit_scores + 0.1 * density_score # small boost for already dense containers

    return priorities
```
