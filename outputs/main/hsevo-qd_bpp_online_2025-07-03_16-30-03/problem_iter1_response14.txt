```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    # First, identify bins that can actually fit the item.  Prioritize these.
    fit_mask = bins_remain_cap >= item
    
    if np.any(fit_mask):
        # Among bins that fit, prioritize those that have the least wasted space.  A tighter fit is desirable.
        remaining_space = bins_remain_cap[fit_mask] - item
        priorities[fit_mask] = 1 / (remaining_space + 0.00001)  # Adding small constant to avoid division by zero

        # Boost priority for almost full bins, but not full. This adds a small amount of randomness, promoting exploration.
        almost_full_mask = (remaining_space > 0) & (remaining_space < 0.1 * np.max(bins_remain_cap))
        priorities[fit_mask][almost_full_mask[fit_mask]] += 10 # Arbitrarily high value for bonus

        # Additional bonus to bins that are at least 70% full after placing the item
        percent_full_after = (item + (bins_remain_cap[fit_mask] - remaining_space)) / np.max(bins_remain_cap) # Assuming each bin is the max size
        seventy_percent_mask = percent_full_after >= 0.7
        priorities[fit_mask][seventy_percent_mask] += 5

    else:
        # If no bins fit, prioritize bins with largest remaining capacity, in hopes that some other item later makes it viable to combine and pack.
        priorities = bins_remain_cap / np.max(bins_remain_cap) # Scale from 0 to 1.

    return priorities
```
