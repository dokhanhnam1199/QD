```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version prioritizes bins that have enough space for the item but not significantly more.
    It combines the remaining capacity (smaller is better if it fits), the fullness (higher is better), and a penalty for large wasted space.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Calculate a base score inversely proportional to remaining capacity. Smaller remaining capacity results in higher score, if it fits.
    # This prefers bins where the item "fits snugly"

    fit_mask = bins_remain_cap >= item
    if np.any(fit_mask):
        priorities[fit_mask] = 1.0 / bins_remain_cap[fit_mask]  # Higher score for smaller remaining capacity

        # Add a fullness score: proportional to (capacity - remaining space) / capacity. This encourages using more of the available space
        bin_capacity = bins_remain_cap[fit_mask] + item  # Approximate full capacity; not perfect with prior placements
        fullness = item / bin_capacity
        priorities[fit_mask] += fullness

        # Add a penalty term for bins where there is excessive wasted space after placing the item.
        waste_penalty = np.maximum(0, (bins_remain_cap[fit_mask] - item) / bin_capacity)
        priorities[fit_mask] -= 0.5 * waste_penalty

        #Scale to ensure that all numbers are useful
        priorities[fit_mask] = priorities[fit_mask] * 10

    else:
        #If the item doesnt fit in any bin assign it a low negative priority
        priorities[:] = -100 #Very Low Priority, item doesnt fit

    return priorities
```
