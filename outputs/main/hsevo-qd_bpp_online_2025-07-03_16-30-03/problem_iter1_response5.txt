```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This priority function favors bins that can accommodate the item with minimal wasted space,
    but also penalizes bins that are too close in capacity to the item size. This is done to prevent
    overfilling bins and potentially leaving too little space for future items.
    Also consider the filling ratio and number of items already in bins.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap)

    # Handle cases where the item doesn't fit
    infeasible = bins_remain_cap < item
    priorities[infeasible] = -np.inf  # Mark as infeasible

    # Reward bins that fit, but not perfectly
    feasible = ~infeasible
    remaining_space = bins_remain_cap[feasible] - item
    ratios = item / bins_remain_cap[feasible]
    
    # Score based on how well item fits (avoiding near-perfect fits). Near perfect fits lead to fragmentation.
    # A higher score is better, so smaller remaining space means better fit but this is scaled by a penalty function
    # if the bins are almost perfectly full.
    
    fit_score = np.exp(-remaining_space) # Higher value for a tighter fit

    # Avoid bins with too little remaining capacity relative to the item size. Penalize smaller remaining space
    penalty_factor = np.where(remaining_space < (0.1 * item), 0.1, 1)  #Penalizes remaining space that is 10% the size of the item
    
    priorities[feasible] = fit_score * penalty_factor

    return priorities
```
