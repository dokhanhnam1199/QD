{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Prioritizes near-full bins and penalizes excessive space.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        priorities = -bins_remain_cap\n        return priorities\n\n    remaining_space = bins_remain_cap - item\n    \n    # Prioritize almost full bins based on remaining space\n    priorities[feasible_bins] = 1 / (remaining_space[feasible_bins] + 1e-9)\n    priorities[feasible_bins] += np.where(remaining_space[feasible_bins] >= 0, 1.0, 0)\n    \n    # Heavily prioritize bins that become almost full\n    almost_full = np.logical_and(feasible_bins, remaining_space < 0.1)\n    priorities[almost_full] += 5.0\n\n    # Penalize bins with excessive space to encourage filling others\n    excessive_space = np.logical_and(feasible_bins, remaining_space > 0.5)\n    priorities[excessive_space] -= 0.5 * remaining_space[excessive_space]\n    \n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n                bins_remain_cap: np.ndarray,\n                division_eps: float = 1.2751144605391451e-09,\n                base_priority: float = 1.0029373306865028,\n                almost_full_threshold: float = 0.05814860685353829,\n                almost_full_priority: float = 4.659312610265962) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        division_eps: Epsilon to avoid division by zero.\n        base_priority: Base priority to fill the bins.\n        almost_full_threshold: Threshold to consider a bin as almost full.\n        almost_full_priority: Priority for almost full bins.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # A bin is feasible if it can accommodate the item\n    feasible_bins = bins_remain_cap >= item\n    \n    if not np.any(feasible_bins):\n      # If no bin can fit, consider using the least-filled bins \n      # (though it won't actually fit).  This helps guide decision-making\n      # in extreme cases. The priority is slightly negative and inversely propotional\n      # to how full is the bin.\n      priorities = -bins_remain_cap \n      return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see that the best heuristic incorporates multiple factors (remaining space, feasibility, almost-fullness, and a penalty for leaving too much space), while the worst simply uses the negative log of the ratio of item size to remaining capacity. This suggests that combining multiple relevant factors leads to better performance.\n\nComparing (2nd best) vs (second worst), we see that the second best uses a combination of factors similar to the best, including prioritizing almost full bins, prioritizing bins with smaller remaining space, and penalizing bins that are too empty.  The second worst, heuristic (19th), is almost identical to heuristics (18th), both use the negative log ratios of item/bin size but only on bins that are feasible but not nearly full (which is a decent feature, but not enough).\nComparing (1st) vs (2nd), we see a difference in how the \"almost full\" condition is handled, and the explicit bonus/penalty amounts. The first heuristic uses a threshold of `remaining_space < 0.2` for \"almost full\" and assigns a bonus of `3.0`, and also includes a small penalty for bins with too much space (`remaining_space > 0.5`). The second uses `remaining_space < 0.1` and assigns a much higher bonus of `10.0`, and a smaller penalty for full bins of `bins_remain_cap > 0.7`.\n\n(3rd) vs (4th) ... Heuristic 3rd and 2nd are identical, Heuristic 4 prioritizes almost full bins based on remaining space (`1 / (remaining_space + 1e-9)`) and adds 5.0 if almost full. Penalties excessive space by subtracting `0.5 * remaining_space`. Also gives a base reward of 0.6 for feasible bins. These are all good features but with different weight/implementation.\n\nComparing (second worst) vs (worst), we see that 19th heuristics are identical to heuristics 18th, and heuristic 20th only uses  `-log_ratios` which is the worst one.\n\nOverall: The top-performing heuristics prioritize a combination of factors. The most common and effective components seem to be:\n\n*   **Feasibility:** Ensuring the item fits in the bin.\n*   **Remaining Space:** Preferring bins where the item fits with minimal wasted space (using inverse remaining space).\n*   **Almost Full:** Giving a significant bonus to bins that are nearly full after adding the item. This encourages closing out bins.\n*   **Penalties for excessive space/fragmentation:** Discouraging leaving large empty spaces, which can hinder future placements.\n*   **Handling Infeasible Cases:** Deciding what to do when no bin can accommodate the item (e.g., using the least filled bin).\n\nThe heuristics that only consider one or two factors, or that use less refined methods for calculating priority, perform worse. The specific values assigned to bonuses and penalties also appear to have a significant impact. Heuristics that perform well explicitly handle the \"almost full\" condition by providing very high priority and penalize leaving excessive space.\n- \nOkay, here's a redefined approach to \"Current Self-Reflection\" focused on avoiding the pitfalls of the \"Ineffective Self-Reflection\" examples, designed to improve your heuristic design process, aiming for that $999k tip!\n\n*   **Keywords:** Factor Prioritization, Adaptive Weights, Regret Analysis, Look-Ahead (Limited).\n\n*   **Advice:** Prioritize factors dynamically based on problem state (e.g., more emphasis on fragmentation later). Use adaptive weights to allow factors to adjust to problem instances. Incorporate a limited look-ahead mechanism to estimate the impact of each placement on future decisions.\n\n*   **Avoid:** Over-tuning, reliance on fixed thresholds, excessive complexity from deep look-ahead searches, and premature optimization of every near-full bin.\n\n*   **Explanation:** Instead of rigidly combining factors and hoping tuning works, focus on *why* certain factors are important *at specific stages* of the packing process. Look-ahead isn't about solving the *whole* problem but glimpsing immediate downstream effects. Adaptive weights adjust to different problem instances and reduce the burden of tuning.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}