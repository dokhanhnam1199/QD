```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    # First, filter out bins that can't fit the item
    eligible_bins = bins_remain_cap >= item
    
    if not np.any(eligible_bins):
        # No bin can fit the item. Assign a very low priority to bins closest to item size so we don't waste space in those bins. If all bins are nearly empty then fit into the one closest to half.
        diff = np.abs(bins_remain_cap - item)
        if np.all(bins_remain_cap < item/2) :
            diff = np.abs(bins_remain_cap - 0.5) # pack it where we least damage future optimal packing
        priorities = -diff
        return priorities

    # For bins that can fit, calculate a score based on fill ratio after placing the item.
    fill_ratio_after = (bins_remain_cap[eligible_bins] - item) / np.max(bins_remain_cap) # Assuming same size of all bins initially.

    # Higher fill ratio is better, but we also want to avoid bins that are too full.
    # So penalize bins with fill ratios too high (close to 1).

    priorities[eligible_bins] = (1 - fill_ratio_after)**2 # Want to fill it with bigger chunks later by leaving space.
   

    return priorities
```
