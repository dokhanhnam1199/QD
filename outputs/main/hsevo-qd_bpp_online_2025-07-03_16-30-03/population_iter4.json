[
  {
    "stdout_filepath": "problem_iter0_stdout0.txt",
    "code_path": "problem_iter0_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    ratios = item / bins_remain_cap\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities",
    "response_id": 0,
    "obj": 149.30195452732352,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 11.60964047443681,
    "mi": 94.04446327225541,
    "token_count": 47.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response7.txt_stdout.txt",
    "code_path": "problem_iter1_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # A bin is feasible if it can accommodate the item\n    feasible_bins = bins_remain_cap >= item\n    \n    if not np.any(feasible_bins):\n      # If no bin can fit, consider using the least-filled bins \n      # (though it won't actually fit).  This helps guide decision-making\n      # in extreme cases. The priority is slightly negative and inversely propotional\n      # to how full is the bin.\n      priorities = -bins_remain_cap \n      return priorities\n\n    # First consideration: How much empty space will be left *after* adding the item?\n    remaining_space = bins_remain_cap - item\n    \n    #Prioritize almost full bins\n    priorities[feasible_bins] = 1/(remaining_space[feasible_bins]+1e-9) #avoid division by zero. Want small values of remaining_space to yield large priorities.\n    \n    #Try to fill the bins\n    priorities[feasible_bins] += np.where(remaining_space[feasible_bins] >= 0 , 1.0,0)\n    \n    # Penalize bins where item fits only by tiny amount to encourage filling them up\n    # This makes a significant different (a trick from Quantum Mechanics, like a wave function collapse based on smallest energy changes)\n    almost_full = np.logical_and(feasible_bins, remaining_space < 0.1)\n    priorities[almost_full] += 5.0 # Greatly prioritize nearly-full bins\n\n    \n    return priorities",
    "response_id": 7,
    "tryHS": true,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 108.04820237218406,
    "mi": 81.51858231980326,
    "token_count": 126.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response8.txt_stdout.txt",
    "code_path": "problem_iter2_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines remaining space, feasibility, and near-fullness for priority.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        priorities = -bins_remain_cap\n        return priorities\n\n    remaining_space = bins_remain_cap - item\n    \n    # Prioritize almost full bins based on remaining space\n    priorities[feasible_bins] = 1 / (remaining_space[feasible_bins] + 1e-9)\n    priorities[feasible_bins] += np.where(remaining_space[feasible_bins] >= 0, 1.0, 0)\n    \n    # Heavily prioritize bins that become almost full\n    almost_full = np.logical_and(feasible_bins, remaining_space < 0.1)\n    priorities[almost_full] += 5.0\n\n    # Consider ratio of item to bin size, but only when feasible and not almost full\n    other_feasible = np.logical_and(feasible_bins, ~almost_full)\n    ratios = item / bins_remain_cap\n    priorities[other_feasible] += -np.log(ratios[other_feasible]) * 0.1 # Scale down effect\n    \n    return priorities",
    "response_id": 8,
    "tryHS": false,
    "obj": 51.09692859992023,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 98.09910819000817,
    "mi": 61.48580899149723,
    "token_count": 121.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response1.txt_stdout.txt",
    "code_path": "problem_iter3_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # A bin is feasible if it can accommodate the item\n    feasible_bins = bins_remain_cap >= item\n    \n    if not np.any(feasible_bins):\n      # If no bin can fit, consider using the least-filled bins \n      # (though it won't actually fit).  This helps guide decision-making\n      # in extreme cases. The priority is slightly negative and inversely propotional\n      # to how full is the bin.\n      priorities = -bins_remain_cap \n      return priorities\n\n    # First consideration: How much empty space will be left *after* adding the item?\n    remaining_space = bins_remain_cap - item\n    \n    #Prioritize almost full bins\n    priorities[feasible_bins] = 1/(remaining_space[feasible_bins]+1e-9) #avoid division by zero. Want small values of remaining_space to yield large priorities.\n    \n    #Try to fill the bins\n    priorities[feasible_bins] += np.where(remaining_space[feasible_bins] >= 0 , 1.0,0)\n    \n    # Penalize bins where item fits only by tiny amount to encourage filling them up\n    # This makes a significant different (a trick from Quantum Mechanics, like a wave function collapse based on smallest energy changes)\n    almost_full = np.logical_and(feasible_bins, remaining_space < 0.1)\n    priorities[almost_full] += 5.0 # Greatly prioritize nearly-full bins\n\n    # NEW: Introduce a moderate penalty for bins with excessive remaining space.\n    # This encourages filling bins more completely and reduces fragmentation.\n    excessive_space = np.logical_and(feasible_bins, remaining_space > 0.5) #tune parameter\n    priorities[excessive_space] -= 1.0  # Moderate penalty\n\n    # NEW: Give a slight bonus to bins whose remaining capacity *after* placing the\n    # item is close to the size of the next smallest item seen so far.\n    # This anticipates future placements and attempts to create suitable spaces.\n\n    # In a real implementation, we'd likely have access to a history of item sizes.\n    # Here, we'll simulate it by considering \"hypothetical\" next item sizes.\n    hypothetical_next_items = np.array([0.1, 0.2, 0.3, 0.4, 0.5])  # Example sizes\n    for next_item_size in hypothetical_next_items:\n        ideal_remaining_space = next_item_size\n        close_to_ideal = np.logical_and(feasible_bins, np.abs(remaining_space - ideal_remaining_space) < 0.1)\n        priorities[close_to_ideal] += 0.5\n\n    \n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 228.32510677099592,
    "mi": 75.55914497022471,
    "token_count": 201.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response0.txt_stdout.txt",
    "code_path": "problem_iter4_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, \n                bins_remain_cap: np.ndarray,\n                division_eps: float = 3.735088610612452e-09,\n                fill_priority: float = 1.0928996375579447,\n                almost_full_threshold: float = 0.15468682056117616,\n                almost_full_priority: float = 6.826317618599449) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        division_eps: Epsilon to avoid division by zero.\n        fill_priority: Priority increment for bins where item fits.\n        almost_full_threshold: Threshold for considering a bin \"almost full\".\n        almost_full_priority: Priority increment for almost full bins.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # A bin is feasible if it can accommodate the item\n    feasible_bins = bins_remain_cap >= item\n    \n    if not np.any(feasible_bins):\n      # If no bin can fit, consider using the least-filled bins \n      # (though it won't actually fit).  This helps guide decision-making\n      # in extreme cases. The priority is slightly negative and inversely propotional\n      # to how full is the bin.\n      priorities = -bins_remain_cap \n      return priorities",
    "response_id": 0,
    "tryHS": true,
    "obj": 4.487435181491823,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 18.094737505048094,
    "mi": 90.012771312655,
    "token_count": 104.0,
    "exec_success": true
  }
]