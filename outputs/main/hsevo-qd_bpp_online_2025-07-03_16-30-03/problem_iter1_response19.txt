```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This function implements a more sophisticated priority scheme for online bin packing.
    It prioritizes bins that have enough space for the item but penalizes bins that would
    be left with very small remaining capacity after packing the item (fragmentation).
    Also, it takes the fullness of bins into account, preferring bins which are already reasonably full.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    for i, remaining_capacity in enumerate(bins_remain_cap):
        if remaining_capacity >= item:
            # Base priority: how well the item fits (lower is better)
            fit_score = item / remaining_capacity

            # Fragmentation penalty: if adding the item leaves very little space, penalize.
            fragmentation_threshold = 0.1  # A bin is considered fragmented if less than 10% capacity remains
            remaining_after_pack = remaining_capacity - item
            if remaining_after_pack / 1.0 < fragmentation_threshold:  #Assuming bin size is 1
                fragmentation_penalty = 10 * (fragmentation_threshold - remaining_after_pack) # Scale the penalty

            else:
                fragmentation_penalty = 0
            
            #Fullness Bonus: Higher remaining capacity is penalized since we prefer filling bins more.
            fullness_bonus = -remaining_capacity
            
            priorities[i] = -fit_score - fragmentation_penalty -fullness_bonus # higher priorities get the item.
        else:
            priorities[i] = -np.inf  # Cannot fit the item, so lowest priority

    return priorities
```
