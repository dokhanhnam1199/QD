```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version prioritizes bins that can fit the item snugly, with a preference
    for bins that are not too full already. It also penalizes bins that are too small
    for the item and provides a very small boost to bins that are nearly empty,
    encouraging re-use. The aim is to balance packing efficiency and bin re-use.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap)

    # First, identify bins that can fit the item.
    can_fit = bins_remain_cap >= item

    # If no bins can fit the item, all priorities remain 0 (handled implicitly).
    if np.any(can_fit):
        # Calculate "snugness" - how well the item fits the remaining capacity.
        snugness = (bins_remain_cap - item) / bins_remain_cap
        snugness[~can_fit] = -1  # Assign -1 to bins that cannot fit

        # Define a snugness score, penalized for being too large or too small.
        snugness_score = np.exp(-np.abs(snugness - 0.1) / 0.1) * can_fit # best snugness around 10%
        snugness_score = np.clip(snugness_score, 0, 1)

        #Encourage re-use: Give tiny bonus to almost empty bins.
        almost_empty_bonus = np.where(bins_remain_cap > 0.95, 0.05, 0)
        
        # Assign priorities: the best snugness score, a re-use bonus if applicable and some small noise
        priorities = snugness_score + almost_empty_bonus + np.random.normal(0,0.001,size = bins_remain_cap.shape)
    
    return priorities
```
