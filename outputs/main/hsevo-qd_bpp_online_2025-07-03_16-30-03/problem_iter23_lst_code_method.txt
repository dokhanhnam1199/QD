{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        priorities = -bins_remain_cap\n        return priorities\n    \n    remaining_space = bins_remain_cap - item\n    \n    # Adaptive weight for remaining space: Emphasize smaller remaining space less as bins fill up\n    space_priority = 1 / (remaining_space + 1e-9)\n    \n    # Calculate bin utilization: how full is the bin *after* placing the item?\n    future_utilization = (bins_remain_cap - remaining_space) / (bins_remain_cap + item) #Original capacity of bin assumed to be bins_remain_cap + item before placing the item\n\n    # Prioritize bins that will be moderately full to avoid fragmentation\n    utilization_priority = np.exp(-((future_utilization - 0.7)**2) / 0.05) # Gaussian-like curve centered around 0.7\n\n    priorities[feasible_bins] = space_priority[feasible_bins] + utilization_priority[feasible_bins]\n    \n    # Dynamic adjustment: As bins fill, be more aggressive about nearly full bins\n    fill_threshold = np.mean(bins_remain_cap[feasible_bins]) # Adaptive threshold\n    almost_full = np.logical_and(feasible_bins, remaining_space < 0.1 * fill_threshold) # Dynamic percentage of mean\n    priorities[almost_full] += 10.0  # Increased emphasis\n\n    # Limited look-ahead: Penalize bins if the remaining space will be less than the mean of items\n    # This attempts to anticipate the need for a suitable bin for an average-sized item later.\n    mean_remaining_item_size = item # Assume current item size is a good proxy.\n    look_ahead_penalty = np.logical_and(feasible_bins, remaining_space < mean_remaining_item_size)\n    priorities[look_ahead_penalty] -= 2.0\n    \n    return priorities\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        priorities = -bins_remain_cap\n        return priorities\n    \n    remaining_space = bins_remain_cap - item\n    \n    # Adaptive weight for remaining space: Emphasize smaller remaining space less as bins fill up\n    space_priority = 1 / (remaining_space + 1e-9)\n    \n    # Calculate bin utilization: how full is the bin *after* placing the item?\n    future_utilization = (bins_remain_cap - remaining_space) / (bins_remain_cap + item) #Original capacity of bin assumed to be bins_remain_cap + item before placing the item\n\n    # Prioritize bins that will be moderately full to avoid fragmentation\n    utilization_priority = np.exp(-((future_utilization - 0.7)**2) / 0.05) # Gaussian-like curve centered around 0.7\n\n    priorities[feasible_bins] = space_priority[feasible_bins] + utilization_priority[feasible_bins]\n    \n    # Dynamic adjustment: As bins fill, be more aggressive about nearly full bins\n    fill_threshold = np.mean(bins_remain_cap[feasible_bins]) # Adaptive threshold\n    almost_full = np.logical_and(feasible_bins, remaining_space < 0.1 * fill_threshold) # Dynamic percentage of mean\n    priorities[almost_full] += 10.0  # Increased emphasis\n\n    # Limited look-ahead: Penalize bins if the remaining space will be less than the mean of items\n    # This attempts to anticipate the need for a suitable bin for an average-sized item later.\n    mean_remaining_item_size = item # Assume current item size is a good proxy.\n    look_ahead_penalty = np.logical_and(feasible_bins, remaining_space < mean_remaining_item_size)\n    priorities[look_ahead_penalty] -= 2.0\n    \n    return priorities\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # A bin is feasible if it can accommodate the item\n    feasible_bins = bins_remain_cap >= item\n    \n    if not np.any(feasible_bins):\n      # If no bin can fit, consider using the least-filled bins \n      # (though it won't actually fit).  This helps guide decision-making\n      # in extreme cases. The priority is slightly negative and inversely propotional\n      # to how full is the bin.\n      priorities = -bins_remain_cap \n      return priorities\n\n    # First consideration: How much empty space will be left *after* adding the item?\n    remaining_space = bins_remain_cap - item\n    \n    #Prioritize almost full bins\n    priorities[feasible_bins] = 1/(remaining_space[feasible_bins]+1e-9) #avoid division by zero. Want small values of remaining_space to yield large priorities.\n    \n    #Try to fill the bins\n    priorities[feasible_bins] += np.where(remaining_space[feasible_bins] >= 0 , 1.0,0)\n    \n    # Penalize bins where item fits only by tiny amount to encourage filling them up\n    # This makes a significant different (a trick from Quantum Mechanics, like a wave function collapse based on smallest energy changes)\n    almost_full = np.logical_and(feasible_bins, remaining_space < 0.1)\n    priorities[almost_full] += 5.0 # Greatly prioritize nearly-full bins\n\n    \n    return priorities\n\n[Heuristics 4th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # A bin is feasible if it can accommodate the item\n    feasible_bins = bins_remain_cap >= item\n    \n    if not np.any(feasible_bins):\n      # If no bin can fit, consider using the least-filled bins \n      # (though it won't actually fit).  This helps guide decision-making\n      # in extreme cases. The priority is slightly negative and inversely propotional\n      # to how full is the bin.\n      priorities = -bins_remain_cap \n      return priorities\n\n    # First consideration: How much empty space will be left *after* adding the item?\n    remaining_space = bins_remain_cap - item\n    \n    #Prioritize almost full bins\n    priorities[feasible_bins] = 1/(remaining_space[feasible_bins]+1e-9) #avoid division by zero. Want small values of remaining_space to yield large priorities.\n    \n    #Try to fill the bins\n    priorities[feasible_bins] += np.where(remaining_space[feasible_bins] >= 0 , 1.0,0)\n    \n    # Penalize bins where item fits only by tiny amount to encourage filling them up\n    # This makes a significant different (a trick from Quantum Mechanics, like a wave function collapse based on smallest energy changes)\n    almost_full = np.logical_and(feasible_bins, remaining_space < 0.1)\n    priorities[almost_full] += 5.0 # Greatly prioritize nearly-full bins\n\n    # NEW: Introduce a moderate penalty for bins with excessive remaining space.\n    # This encourages filling bins more completely and reduces fragmentation.\n    excessive_space = np.logical_and(feasible_bins, remaining_space > 0.5) #tune parameter\n    priorities[excessive_space] -= 1.0  # Moderate penalty\n\n    # NEW: Give a slight bonus to bins whose remaining capacity *after* placing the\n    # item is close to the size of the next smallest item seen so far.\n    # This anticipates future placements and attempts to create suitable spaces.\n\n    # In a real implementation, we'd likely have access to a history of item sizes.\n    # Here, we'll simulate it by considering \"hypothetical\" next item sizes.\n    hypothetical_next_items = np.array([0.1, 0.2, 0.3, 0.4, 0.5])  # Example sizes\n    for next_item_size in hypothetical_next_items:\n        ideal_remaining_space = next_item_size\n        close_to_ideal = np.logical_and(feasible_bins, np.abs(remaining_space - ideal_remaining_space) < 0.1)\n        priorities[close_to_ideal] += 0.5\n\n    \n    return priorities\n\n[Heuristics 5th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # A bin is feasible if it can accommodate the item\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        # If no bin can fit, consider using the least-filled bins\n        # (though it won't actually fit). This helps guide decision-making\n        # in extreme cases. The priority is slightly negative and inversely proportional\n        # to how full is the bin.\n        priorities = -bins_remain_cap\n        return priorities\n\n    # First consideration: How much empty space will be left *after* adding the item?\n    remaining_space = bins_remain_cap - item\n\n    # Incentive 1: Prioritize bins with smaller remaining space (after fitting item)\n    priorities[feasible_bins] += 1.0 / (remaining_space[feasible_bins] + 1e-9)\n\n    # Incentive 2: Heavily prioritize almost full bins. This is crucial.\n    almost_full = np.logical_and(feasible_bins, remaining_space < 0.1)\n    priorities[almost_full] += 10.0\n\n    # Incentive 3: Moderate priority boost for bins that aren't \"almost full\"\n    # but still have relatively little space left. Prevents extreme fragmentation.\n    moderately_full = np.logical_and(feasible_bins, remaining_space < 0.3)\n    priorities[moderately_full] += 2.0\n\n    # Incentive 4: Slightly penalize bins that are too empty.\n    # The amount is subtracted from the priority, so it only affects feasible bins\n    # but still can prioritize one bin over other.\n    priorities[feasible_bins] -= (bins_remain_cap[feasible_bins] > 0.7) * 0.5\n\n    return priorities\n\n[Heuristics 6th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes near-full bins and penalizes excessive space.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        priorities = -bins_remain_cap\n        return priorities\n\n    remaining_space = bins_remain_cap - item\n    \n    # Prioritize almost full bins based on remaining space\n    priorities[feasible_bins] = 1 / (remaining_space[feasible_bins] + 1e-9)\n    priorities[feasible_bins] += np.where(remaining_space[feasible_bins] >= 0, 1.0, 0)\n    \n    # Heavily prioritize bins that become almost full\n    almost_full = np.logical_and(feasible_bins, remaining_space < 0.1)\n    priorities[almost_full] += 5.0\n\n    # Penalize bins with excessive space to encourage filling others\n    excessive_space = np.logical_and(feasible_bins, remaining_space > 0.5)\n    priorities[excessive_space] -= 0.5 * remaining_space[excessive_space]\n    \n    return priorities\n\n[Heuristics 7th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines remaining space, feasibility, near-fullness, and penalizes excessive space.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        priorities = -bins_remain_cap\n        return priorities\n\n    remaining_space = bins_remain_cap - item\n    \n    # Prioritize almost full bins based on remaining space\n    priorities[feasible_bins] = 1 / (remaining_space[feasible_bins] + 1e-9)\n    priorities[feasible_bins] += np.where(remaining_space[feasible_bins] >= 0, 1.0, 0)\n    \n    # Heavily prioritize bins that become almost full\n    almost_full = np.logical_and(feasible_bins, remaining_space < 0.1)\n    priorities[almost_full] += 5.0\n\n    # Penalty for excessive remaining space (avoid fragmentation)\n    priorities[feasible_bins] -= (remaining_space[feasible_bins] / np.max(bins_remain_cap)) * 0.5\n\n    return priorities\n\n[Heuristics 8th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines remaining space, feasibility, near-fullness, and penalizes excessive space.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        priorities = -bins_remain_cap\n        return priorities\n\n    remaining_space = bins_remain_cap - item\n    \n    # Prioritize almost full bins based on remaining space\n    priorities[feasible_bins] = 1 / (remaining_space[feasible_bins] + 1e-9)\n    priorities[feasible_bins] += np.where(remaining_space[feasible_bins] >= 0, 1.0, 0)\n    \n    # Heavily prioritize bins that become almost full\n    almost_full = np.logical_and(feasible_bins, remaining_space < 0.1)\n    priorities[almost_full] += 5.0\n\n    # Penalty for excessive remaining space (avoid fragmentation)\n    priorities[feasible_bins] -= (remaining_space[feasible_bins] / np.max(bins_remain_cap)) * 0.5\n\n    return priorities\n\n[Heuristics 9th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # A bin is feasible if it can accommodate the item\n    feasible_bins = bins_remain_cap >= item\n    \n    if not np.any(feasible_bins):\n      # If no bin can fit, consider using the least-filled bins \n      # (though it won't actually fit).  This helps guide decision-making\n      # in extreme cases. The priority is slightly negative and inversely proportional\n      # to how full is the bin.\n      priorities = -bins_remain_cap\n      return priorities\n\n    # First consideration: How much empty space will be left *after* adding the item?\n    remaining_space = bins_remain_cap - item\n    \n    #Prioritize almost full bins using a refined approach:\n    priorities[feasible_bins] = 1.0 / (remaining_space[feasible_bins] + 1e-9) # Inverse remaining space\n    \n    # Incentive to use bins\n    priorities[feasible_bins] += 0.5  # Base incentive\n\n    # Stronger incentive for bins that are nearly full\n    almost_full = np.logical_and(feasible_bins, remaining_space < 0.2) #Increased threshold to 0.2\n    priorities[almost_full] += 3.0\n\n    # Small penalty for leaving too much space, to avoid fragmentation.\n    # This encourages filling bins more completely.\n    too_much_space = np.logical_and(feasible_bins, remaining_space > 0.5)\n    priorities[too_much_space] -= 1.0 \n    \n    return priorities\n\n[Heuristics 10th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes near-full bins and penalizes excessive space.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        priorities = -bins_remain_cap\n        return priorities\n\n    remaining_space = bins_remain_cap - item\n    \n    # Prioritize almost full bins based on remaining space\n    priorities[feasible_bins] = 1 / (remaining_space[feasible_bins] + 1e-9)\n    priorities[feasible_bins] += np.where(remaining_space[feasible_bins] >= 0, 1.0, 0)\n    \n    # Heavily prioritize bins that become almost full\n    almost_full = np.logical_and(feasible_bins, remaining_space < 0.1)\n    priorities[almost_full] += 5.0\n\n    # Penalize bins with excessive space to encourage filling others\n    excessive_space = np.logical_and(feasible_bins, remaining_space > 0.5)\n    priorities[excessive_space] -= 0.5 * remaining_space[excessive_space]\n    \n    return priorities\n\n[Heuristics 11th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, almost_full_threshold: float = 0.3829163310070497, almost_full_priority: float = 6.053163233324419, ratio_log_scale: float = 0.4423505134462586, small_number: float = 3.4636963604744676e-07, feasibility_weight: float = 0.5240249141101576) -> np.ndarray:\n    \"\"\"Combines remaining space, feasibility, and near-fullness for priority.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        priorities = -bins_remain_cap\n        return priorities\n\n[Heuristics 12th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, \n                bins_remain_cap: np.ndarray,\n                division_eps: float = 1.2751144605391451e-09,\n                base_priority: float = 1.0029373306865028,\n                almost_full_threshold: float = 0.05814860685353829,\n                almost_full_priority: float = 4.659312610265962) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        division_eps: Epsilon to avoid division by zero.\n        base_priority: Base priority to fill the bins.\n        almost_full_threshold: Threshold to consider a bin as almost full.\n        almost_full_priority: Priority for almost full bins.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # A bin is feasible if it can accommodate the item\n    feasible_bins = bins_remain_cap >= item\n    \n    if not np.any(feasible_bins):\n      # If no bin can fit, consider using the least-filled bins \n      # (though it won't actually fit).  This helps guide decision-making\n      # in extreme cases. The priority is slightly negative and inversely propotional\n      # to how full is the bin.\n      priorities = -bins_remain_cap \n      return priorities\n\n[Heuristics 13th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, almost_full_threshold: float = 0.3829163310070497, almost_full_priority: float = 6.053163233324419, ratio_log_scale: float = 0.4423505134462586, small_number: float = 3.4636963604744676e-07, feasibility_weight: float = 0.5240249141101576) -> np.ndarray:\n    \"\"\"Combines remaining space, feasibility, and near-fullness for priority.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        priorities = -bins_remain_cap\n        return priorities\n\n[Heuristics 14th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, almost_full_threshold: float = 0.12046219606270642, moderately_full_threshold: float = 0.38527111928509306,\n                empty_bin_threshold: float = 0.8202358497745701, almost_full_weight: float = 14.27288558350223, moderately_full_weight: float = 4.230395346261988,\n                empty_bin_penalty: float = 0.915319799189316, remaining_space_weight: float = 1.0201452336390084, epsilon: float = 8.149015682582224e-09) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        almost_full_threshold: Threshold for considering a bin \"almost full\".\n        moderately_full_threshold: Threshold for considering a bin \"moderately full\".\n        empty_bin_threshold: Threshold for considering a bin \"too empty\".\n        almost_full_weight: Weight for almost full bins.\n        moderately_full_weight: Weight for moderately full bins.\n        empty_bin_penalty: Penalty for empty bins.\n        remaining_space_weight: Weight for remaining space.\n        epsilon: Small value to avoid division by zero.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # A bin is feasible if it can accommodate the item\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        # If no bin can fit, consider using the least-filled bins\n        # (though it won't actually fit). This helps guide decision-making\n        # in extreme cases. The priority is slightly negative and inversely proportional\n        # to how full is the bin.\n        priorities = -bins_remain_cap\n        return priorities\n\n[Heuristics 15th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines remaining space, feasibility, and near-fullness for priority.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        priorities = -bins_remain_cap\n        return priorities\n\n    remaining_space = bins_remain_cap - item\n    \n    # Prioritize almost full bins based on remaining space\n    priorities[feasible_bins] = 1 / (remaining_space[feasible_bins] + 1e-9)\n    priorities[feasible_bins] += np.where(remaining_space[feasible_bins] >= 0, 1.0, 0)\n    \n    # Heavily prioritize bins that become almost full\n    almost_full = np.logical_and(feasible_bins, remaining_space < 0.1)\n    priorities[almost_full] += 5.0\n\n    # Consider ratio of item to bin size, but only when feasible and not almost full\n    other_feasible = np.logical_and(feasible_bins, ~almost_full)\n    ratios = item / bins_remain_cap\n    priorities[other_feasible] += -np.log(ratios[other_feasible]) * 0.1 # Scale down effect\n    \n    return priorities\n\n[Heuristics 16th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines remaining space, feasibility, and near-fullness for priority.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        priorities = -bins_remain_cap\n        return priorities\n\n    remaining_space = bins_remain_cap - item\n    \n    # Prioritize almost full bins based on remaining space\n    priorities[feasible_bins] = 1 / (remaining_space[feasible_bins] + 1e-9)\n    priorities[feasible_bins] += np.where(remaining_space[feasible_bins] >= 0, 1.0, 0)\n    \n    # Heavily prioritize bins that become almost full\n    almost_full = np.logical_and(feasible_bins, remaining_space < 0.1)\n    priorities[almost_full] += 5.0\n\n    # Consider ratio of item to bin size, but only when feasible and not almost full\n    other_feasible = np.logical_and(feasible_bins, ~almost_full)\n    ratios = item / bins_remain_cap\n    priorities[other_feasible] += -np.log(ratios[other_feasible]) * 0.1 # Scale down effect\n    \n    return priorities\n\n[Heuristics 17th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines remaining space, feasibility, and near-fullness for priority.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        priorities = -bins_remain_cap\n        return priorities\n\n    remaining_space = bins_remain_cap - item\n    \n    # Prioritize almost full bins based on remaining space\n    priorities[feasible_bins] = 1 / (remaining_space[feasible_bins] + 1e-9)\n    priorities[feasible_bins] += np.where(remaining_space[feasible_bins] >= 0, 1.0, 0)\n    \n    # Heavily prioritize bins that become almost full\n    almost_full = np.logical_and(feasible_bins, remaining_space < 0.1)\n    priorities[almost_full] += 5.0\n\n    # Consider ratio of item to bin size, but only when feasible and not almost full\n    other_feasible = np.logical_and(feasible_bins, ~almost_full)\n    ratios = item / bins_remain_cap\n    priorities[other_feasible] += -np.log(ratios[other_feasible]) * 0.1 # Scale down effect\n    \n    return priorities\n\n[Heuristics 18th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    ratios = item / bins_remain_cap\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n[Heuristics 19th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    ratios = item / bins_remain_cap\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n[Heuristics 20th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    ratios = item / bins_remain_cap\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}