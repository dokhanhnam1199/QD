{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # A bin is feasible if it can accommodate the item\n    feasible_bins = bins_remain_cap >= item\n    \n    if not np.any(feasible_bins):\n      # If no bin can fit, consider using the least-filled bins \n      # (though it won't actually fit).  This helps guide decision-making\n      # in extreme cases. The priority is slightly negative and inversely propotional\n      # to how full is the bin.\n      priorities = -bins_remain_cap \n      return priorities\n\n    # First consideration: How much empty space will be left *after* adding the item?\n    remaining_space = bins_remain_cap - item\n    \n    #Prioritize almost full bins\n    priorities[feasible_bins] = 1/(remaining_space[feasible_bins]+1e-9) #avoid division by zero. Want small values of remaining_space to yield large priorities.\n    \n    #Try to fill the bins\n    priorities[feasible_bins] += np.where(remaining_space[feasible_bins] >= 0 , 1.0,0)\n    \n    # Penalize bins where item fits only by tiny amount to encourage filling them up\n    # This makes a significant different (a trick from Quantum Mechanics, like a wave function collapse based on smallest energy changes)\n    almost_full = np.logical_and(feasible_bins, remaining_space < 0.1)\n    priorities[almost_full] += 5.0 # Greatly prioritize nearly-full bins\n\n    \n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    ratios = item / bins_remain_cap\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (11th), we see the better heuristic prioritizes almost-full bins, provides a fallback mechanism when no bin can fit the item, and incorporates multiple factors (remaining space, feasibility, near-fullness) into its priority calculation. The worse heuristic only considers the ratio of item size to remaining capacity using a log scale.\nComparing (2nd) vs (12th), the logic is the same as (1st) vs (11th).\nComparing (1st) vs (2nd), no differences found. Comparing (3rd) vs (4th), no differences found. Comparing (second worst) vs (worst), no differences found.\nOverall: The better heuristics involve more complex calculations considering multiple factors such as remaining space, whether the item fits, and a bonus for almost-full bins, while the worse ones rely on a single ratio. The top heuristics include specific logic to handle edge cases where no bin can fit the item.\n- \nOkay, let's refine \"Current Self-Reflection\" for better heuristic design, keeping in mind what to avoid, and focusing on actionable advice:\n\n*   **Keywords:** Integration, Robustness, Bin-Packing, Edge-Case Handling.\n\n*   **Advice:** Develop heuristics that synthesize multiple relevant features into a composite score. Implement explicit checks and alternative strategies for boundary conditions. Design heuristics that proactively minimize wasted space.\n\n*   **Avoid:** Over-reliance on single factors; ignoring extreme scenarios; passively accepting fragmentation.\n\n*   **Explanation:** Combining factors creates more informed choices, robustness ensures consistent performance, and active bin-packing increases efficiency.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}