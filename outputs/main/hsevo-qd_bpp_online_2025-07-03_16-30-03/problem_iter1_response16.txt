```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    # Calculate the remaining capacity after adding the item.
    remaining_capacities = bins_remain_cap - item

    # Give zero priority to bins that cannot fit the item.
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    valid_bins = remaining_capacities >= 0

    if not np.any(valid_bins):
      # If no bin can fit the item, prioritise nearly full bins to perhaps open new bins more slowly.
      priorities = bins_remain_cap / item  # prioritize smaller remaining capacities (closer to overflowing, meaning use new bins soon.)
      return -priorities  # Reverse order, smallest value comes first

    # Prioritize bins that can fit the item.
    available_capacities = bins_remain_cap[valid_bins]
    
    # Hawking Radiation Inspired: larger Black holes (larger bins), evaporate more slowly
    # And small (nearly empty), fill faster.
    #Prioritize smaller bins
    scaled_capacities = available_capacities / np.max(available_capacities)

    priorities[valid_bins] = 1.0 - scaled_capacities  # Invert this: Small bins get priority.

    # Encourage a degree of packing efficiency, without overly penalizing bins.
    packing_efficiency = item / bins_remain_cap
    packing_efficiency[~valid_bins] = 0.  # Zero out invalid bins.
    
    # Enhance small packing efficiencies with exponential decay
    packing_efficiency[valid_bins] = np.exp(packing_efficiency[valid_bins]) - 1 #packing efficiency > 1 is bad as bins do not hold the item.
    priorities += packing_efficiency
    
    return priorities
```
