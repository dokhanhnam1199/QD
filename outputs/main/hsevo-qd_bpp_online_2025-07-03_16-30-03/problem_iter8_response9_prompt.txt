{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # A bin is feasible if it can accommodate the item\n    feasible_bins = bins_remain_cap >= item\n    \n    if not np.any(feasible_bins):\n      # If no bin can fit, consider using the least-filled bins \n      # (though it won't actually fit).  This helps guide decision-making\n      # in extreme cases. The priority is slightly negative and inversely propotional\n      # to how full is the bin.\n      priorities = -bins_remain_cap \n      return priorities\n\n    # First consideration: How much empty space will be left *after* adding the item?\n    remaining_space = bins_remain_cap - item\n    \n    #Prioritize almost full bins\n    priorities[feasible_bins] = 1/(remaining_space[feasible_bins]+1e-9) #avoid division by zero. Want small values of remaining_space to yield large priorities.\n    \n    #Try to fill the bins\n    priorities[feasible_bins] += np.where(remaining_space[feasible_bins] >= 0 , 1.0,0)\n    \n    # Penalize bins where item fits only by tiny amount to encourage filling them up\n    # This makes a significant different (a trick from Quantum Mechanics, like a wave function collapse based on smallest energy changes)\n    almost_full = np.logical_and(feasible_bins, remaining_space < 0.1)\n    priorities[almost_full] += 5.0 # Greatly prioritize nearly-full bins\n\n    \n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    ratios = item / bins_remain_cap\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see the best heuristic incorporates several factors including remaining space, feasibility, near-fullness, a penalty for excessive space, and even anticipation of future item sizes, while the worst only considers the ratio of the item size to the remaining bin capacity using a negative log scale.\n(2nd best) vs (second worst) - 2nd and 3rd functions in list are the same. comparing with 19th, we see the second best heuristic incorporates several factors including remaining space, feasibility, near-fullness while the second worst only considers the ratio of the item size to the remaining bin capacity using a negative log scale.\nComparing (1st) vs (2nd), we see the best introduces a penalty for excessive space and anticipates future placements, whereas the second prioritizes based on remaining space and near-fullness without considering these factors.\n(3rd) vs (4th), the third is identical to the second. The fourth adds a penalty for excessive space.\nComparing (second worst) vs (worst), the functions are identical, both only calculating priorities based on the negative log of the ratio of item size to remaining bin capacity.\nOverall: Better heuristics consider more factors, prioritize filling nearly full bins, and penalize leaving excessive space. The best attempts to anticipate future item sizes. Simpler heuristics that only consider ratio of item/bin capacity perform the worst. Inclusion of domain-specific knowledge/constraints improves the heuristic.\n- \nOkay, let's redefine \"Current self-reflection\" to be more effective for designing better heuristics, focusing on actionable insights and avoiding pitfalls.\n\nHere's a revised framework for \"Current Self-Reflection\":\n\n*   **Keywords:** Iterative refinement, domain knowledge, multi-objective, performance analysis, state anticipation (judiciously).\n*   **Advice:** Begin with a simple, interpretable heuristic. Rigorously analyze its performance against representative data. Progressively introduce complexity based *solely* on identified weaknesses.\n*   **Avoid:** Premature optimization, over-parameterization, solely focusing on single \"bin-filling\" objectives, and overly complex future state calculations without demonstrated necessity.\n*   **Explanation:** Prioritize understanding *why* a heuristic performs poorly before adding complexity. Use domain knowledge to guide refinements, but validate all changes with data analysis. Multi-objective awareness prevents unintended consequences.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}