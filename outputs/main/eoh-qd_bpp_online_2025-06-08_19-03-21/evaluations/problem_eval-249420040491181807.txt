def priority_v2(item, bins_remain_cap):
  """{This algorithm calculates a priority score for each bin based on the utilization ratio, penalizing bins with low utilization or those that cause excessive fragmentation.}"""
  priority = []
  for cap in bins_remain_cap:
    if cap >= item:
      # Calculate utilization ratio. Higher utilization is generally better.
      utilization = item / cap

      # Penalize low utilization (bins too empty). A low utilization value means the item doesn't fill the bin well.
      low_utilization_penalty = (1 - utilization)**2 

      # Penalize fragmentation (bins that leave very little space). 
      # Fragmentation is more problematic when the remaining space is smaller than some threshold.
      remaining_space = cap - item
      fragmentation_penalty = 0
      if remaining_space > 0:
          fragmentation_ratio = remaining_space / cap
          fragmentation_penalty = (fragmentation_ratio**3) # Cube to penalize small fragmentation even more.  

      # Combine utilization with penalties.
      adjusted_priority = utilization - low_utilization_penalty - fragmentation_penalty
      priority.append(adjusted_priority)
    else:
      priority.append(-1)  # Bin is not suitable.

  return priority
