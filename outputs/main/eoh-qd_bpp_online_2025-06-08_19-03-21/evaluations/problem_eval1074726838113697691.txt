def priority_v2(item, bins_remain_cap):
    """{This algorithm assigns priority based on a combination of remaining capacity fit and a penalty for bins that would be overfilled if the item were placed in them, normalized by bin index, and with the penalty of small remaining capacity with an exponential function.}"""
    priority = []
    for i, cap in enumerate(bins_remain_cap):
        if cap >= item:
            fit_score = cap - item  # Smaller fit score is better (closer fit)
        else:
            fit_score = float('inf')  # Very bad fit if it doesn't fit
            
        # Penalize bins that would result in a small remaining capacity
        # to prioritize using more full bins.
        
        priority_score = 0
        if cap >= item:
           priority_score = (1 - (bins_remain_cap[i] - item)/bins_remain_cap[i]) + (bins_remain_cap[i] - item)/bins_remain_cap[i]
        else:
           priority_score = -1
        priority.append(priority_score)
    return priority
