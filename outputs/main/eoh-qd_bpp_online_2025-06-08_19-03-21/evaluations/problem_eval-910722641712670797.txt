def priority_v2(item, bins_remain_cap):
  """{This algorithm calculates a priority score for each bin based on a combination of remaining capacity and a penalty for bins that are too full or too empty to efficiently pack the item.}"""
  priority = []
  for cap in bins_remain_cap:
    if cap >= item:
      # Base priority: Remaining capacity relative to item size. Prefer bins slightly larger than the item.
      base_priority = item / cap

      # Adjust priority based on "waste". Penalize bins that are much larger or only slightly larger than the item.
      waste = cap - item
      penalty = (waste**2) / cap  # Square the waste to penalize it more strongly for larger waste.  Divide by capacity to normalize penalty.
      adjusted_priority = base_priority - penalty
      priority.append(adjusted_priority)
    else:
      priority.append(-1)  # Bin is not suitable.

  return priority
