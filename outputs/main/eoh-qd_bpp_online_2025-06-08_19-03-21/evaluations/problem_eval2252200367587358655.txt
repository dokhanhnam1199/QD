def priority_v2(item, bins_remain_cap):
    """{This algorithm prioritizes bins based on a combination of remaining capacity and a penalty for fragmentation, favoring bins that can accommodate the item with minimal wasted space while discouraging excessive fragmentation.}"""
    priority = []
    for cap in bins_remain_cap:
        if cap >= item:
            waste = cap - item
            if waste == 0:
                p = 100  # Perfect fit gets highest priority
            else:
                # Priority based on remaining capacity, with a penalty for wasted space
                p = 50 + (50 * (1 - (waste / cap))) # Adjusted priority calculation
        else:
            p = -1  # Cannot fit, lowest priority
        priority.append(p)
    return priority
