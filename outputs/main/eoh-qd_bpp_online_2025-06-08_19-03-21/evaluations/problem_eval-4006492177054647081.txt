def priority_v2(item, bins_remain_cap):
  """{This algorithm combines a first-fit-decreasing approach by preferring nearly full bins with a bonus for the fit closeness and a penalty for exceeding the item size by a large margin.}"""
  priority = []
  total_capacity = sum(bins_remain_cap) + item # estimate the maximum total capcity
  for cap in bins_remain_cap:
    if cap >= item:
      fit_score = 1 - (cap - item) / item if item > 0 else 1  # Closeness to the item size
      fullness_score = (total_capacity - cap) / total_capacity # Encourage to choose bins that are nearly full
      excess_penalty = max(0, (cap - item) / item)  # Penalize big gaps
      priority.append(fit_score + fullness_score - excess_penalty)
    else:
      priority.append(-100)
  return priority
