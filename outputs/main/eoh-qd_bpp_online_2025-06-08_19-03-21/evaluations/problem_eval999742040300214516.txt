def priority_v3(item, bins_remain_cap):
    """{This algorithm assigns priority based on a combination of remaining capacity fit, the bin index, and a penalty for bins that would be overfilled if the item were placed in them.}"""
    priority = []
    for i, cap in enumerate(bins_remain_cap):
        if cap >= item:
            fit_score = cap - item  # Smaller fit score is better (closer fit)
        else:
            fit_score = float('inf')  # Very bad fit if it doesn't fit
            
        # Penalize bins that would result in a small remaining capacity
        # to prioritize using more full bins.
        
        priority_score = 0
        if cap >= item:
           priority_score = (bins_remain_cap[i] - item)/bins_remain_cap[i] + (1/(i+1))
        else:
           priority_score = -1
        priority.append(priority_score)
    return priority
