[
     {
          "algorithm": "This algorithm assigns priority based on a combination of remaining capacity after packing the item and the absolute difference between remaining capacity and item size, favoring bins that result in a small remaining capacity and a close fit.",
          "code": "def priority_v2(item, bins_remain_cap):\n  \"\"\"{This algorithm assigns priority based on a combination of remaining capacity after packing the item and the absolute difference between remaining capacity and item size, favoring bins that result in a small remaining capacity and a close fit.}\"\"\"\n  priority = []\n  for cap in bins_remain_cap:\n    if cap >= item:\n      remaining_cap = cap - item\n      diff = abs(remaining_cap - item)\n      priority.append(1 / (remaining_cap + 0.0001) + 1 / (diff + 0.0001))\n    else:\n      priority.append(-1)\n  return priority",
          "objective": 3.18109,
          "other_inf": null,
          "SLOC": 14.0,
          "cyclomatic_complexity": 5.0,
          "halstead": 89.85848369899593
     },
     {
          "algorithm": "This algorithm calculates a priority score for each bin based on a combination of remaining capacity and a penalty for bins that are too full or too empty to efficiently pack the item.",
          "code": "def priority_v2(item, bins_remain_cap):\n  \"\"\"{This algorithm calculates a priority score for each bin based on a combination of remaining capacity and a penalty for bins that are too full or too empty to efficiently pack the item.}\"\"\"\n  priority = []\n  for cap in bins_remain_cap:\n    if cap >= item:\n      # Base priority: Remaining capacity relative to item size. Prefer bins slightly larger than the item.\n      base_priority = item / cap\n\n      # Adjust priority based on \"waste\". Penalize bins that are much larger or only slightly larger than the item.\n      waste = cap - item\n      penalty = (waste**2) / cap  # Square the waste to penalize it more strongly for larger waste.  Divide by capacity to normalize penalty.\n      adjusted_priority = base_priority - penalty\n      priority.append(adjusted_priority)\n    else:\n      priority.append(-1)  # Bin is not suitable.\n\n  return priority",
          "objective": 4.04866,
          "other_inf": null,
          "SLOC": 14.0,
          "cyclomatic_complexity": 5.0,
          "halstead": 89.85848369899593
     },
     {
          "algorithm": "This algorithm calculates priority scores for each bin based on remaining capacity and item size, favoring bins that can accommodate the item with minimal wasted space and penalizing those with insufficient space.",
          "code": "def priority_v2(item, bins_remain_cap):\n    \"\"\"{This algorithm calculates priority scores for each bin based on remaining capacity and item size, favoring bins that can accommodate the item with minimal wasted space and penalizing those with insufficient space.}\"\"\"\n    priority = []\n    for cap in bins_remain_cap:\n        if cap >= item:\n            priority.append(1 / (cap - item + 0.0001))  # Prioritize bins with minimal wasted space\n        else:\n            priority.append(-1000)  # Penalize bins that cannot fit the item\n    return priority",
          "objective": 4.04866,
          "other_inf": null,
          "SLOC": 10.0,
          "cyclomatic_complexity": 3.0,
          "halstead": 44.37895002019238
     },
     {
          "algorithm": "This algorithm prioritizes bins based on a combination of remaining capacity fit and a bonus for bins that are relatively full to encourage efficient packing.",
          "code": "def priority_v2(item, bins_remain_cap):\n    \"\"\"{This algorithm prioritizes bins based on a combination of remaining capacity fit and a bonus for bins that are relatively full to encourage efficient packing.}\"\"\"\n    priority = []\n    for cap in bins_remain_cap:\n        if cap >= item:\n            fit_score = 1 / (cap - item + 0.0001)  # Higher score for tighter fit\n            fullness_bonus = (1 - (cap / 100))**2 # 100 is the bin capacity\n            priority_score = fit_score + fullness_bonus\n        else:\n            priority_score = -1  # Assign -1 for bins that cannot fit the item\n        priority.append(priority_score)\n    return priority",
          "objective": 4.04866,
          "other_inf": null,
          "SLOC": 10.0,
          "cyclomatic_complexity": 3.0,
          "halstead": 44.37895002019238
     },
     {
          "algorithm": "This algorithm calculates a priority score for each bin based on a combination of remaining capacity and how well the item fits, favoring bins with smaller remaining capacity and tighter fits.",
          "code": "def priority_v2(item, bins_remain_cap):\n    \"\"\"{This algorithm calculates a priority score for each bin based on a combination of remaining capacity and how well the item fits, favoring bins with smaller remaining capacity and tighter fits.}\"\"\"\n    priority = []\n    for cap in bins_remain_cap:\n        if cap >= item:\n            fit_ratio = item / cap\n            priority_score = 1 / cap + fit_ratio # Favor smaller cap and tighter fit\n            priority.append(priority_score)\n        else:\n            priority.append(-1)\n    return priority",
          "objective": 4.04866,
          "other_inf": null,
          "SLOC": 10.0,
          "cyclomatic_complexity": 3.0,
          "halstead": 44.37895002019238
     },
     {
          "algorithm": "Assign a priority score to each bin based on how much of its remaining capacity would be used by the item, rewarding bins that would be filled more completely and penalizing those that would be left with large unused space, and returning these scores as a list.",
          "code": "def priority_v2(item, bins_remain_cap):\n  \"\"\"{Assign a priority score to each bin based on how much of its remaining capacity would be used by the item, rewarding bins that would be filled more completely and penalizing those that would be left with large unused space, and returning these scores as a list.}\"\"\"\n  priorities = []\n  for cap in bins_remain_cap:\n    if item <= cap:\n      fill_ratio = float(item) / float(cap)\n      remaining_ratio = float(cap - item) / float(cap)\n      priority = fill_ratio - remaining_ratio**2  # Reward higher fill ratios, penalize large remaining space\n    else:\n      priority = -1  # Item doesn't fit\n    priorities.append(priority)\n  return priority",
          "objective": 4.48744,
          "other_inf": null,
          "SLOC": 14.0,
          "cyclomatic_complexity": 5.0,
          "halstead": 89.85848369899593
     },
     {
          "algorithm": "This algorithm calculates a priority score for each bin based on a combination of remaining capacity and a penalty for bins that would become too full after packing the item.",
          "code": "def priority_v2(item, bins_remain_cap):\n    \"\"\"{This algorithm calculates a priority score for each bin based on a combination of remaining capacity and a penalty for bins that would become too full after packing the item.}\"\"\"\n    priorities = []\n    for cap in bins_remain_cap:\n        if cap >= item:\n            priority = cap - item  # Remaining capacity after packing. Prefer bins with less remaining capacity.\n            if cap - item < item: #Penalty for bins that would be more than half full after packing\n                priority -= 0.5*(item - (cap - item))\n            priorities.append(priority)\n        else:\n            priorities.append(-1)  # Invalid bin\n    return priority",
          "objective": 4.48744,
          "other_inf": null,
          "SLOC": 14.0,
          "cyclomatic_complexity": 5.0,
          "halstead": 89.85848369899593
     },
     {
          "algorithm": "This algorithm calculates the priority of each bin based on how much the item fills the bin (higher fill is better) and penalizes bins that would be overfilled or remain mostly empty after packing (to encourage even distribution).",
          "code": "def priority_v2(item, bins_remain_cap):\n  \"\"\"{This algorithm calculates the priority of each bin based on how much the item fills the bin (higher fill is better) and penalizes bins that would be overfilled or remain mostly empty after packing (to encourage even distribution).}\"\"\"\n  priorities = []\n  for cap in bins_remain_cap:\n    if cap < item:\n      priorities.append(-1)  # Cannot fit\n    else:\n      fill_ratio = item / cap\n      remaining_ratio = (cap - item) / 100 if (cap - item) > 0 else 0 # Scale to avoid excessive penalization\n      priority = fill_ratio - remaining_ratio\n      priorities.append(priority)\n  return priority",
          "objective": 4.48744,
          "other_inf": null,
          "SLOC": 10.0,
          "cyclomatic_complexity": 3.0,
          "halstead": 44.37895002019238
     },
     {
          "algorithm": "This algorithm assigns priority based on a combination of remaining capacity fit and a penalty for bins that would be overfilled if the item were placed in them, normalized by bin index.",
          "code": "def priority_v2(item, bins_remain_cap):\n    \"\"\"{This algorithm assigns priority based on a combination of remaining capacity fit and a penalty for bins that would be overfilled if the item were placed in them, normalized by bin index.}\"\"\"\n    priority = []\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            fit_score = cap - item  # Smaller fit score is better (closer fit)\n        else:\n            fit_score = float('inf')  # Very bad fit if it doesn't fit\n            \n        # Penalize bins that would result in a small remaining capacity\n        # to prioritize using more full bins.\n        \n        priority_score = 0\n        if cap >= item:\n           priority_score = (bins_remain_cap[i] - item)/bins_remain_cap[i]\n        else:\n           priority_score = -1\n        priority.append(priority_score)\n    return priority",
          "objective": 149.30195,
          "other_inf": null,
          "SLOC": 14.0,
          "cyclomatic_complexity": 5.0,
          "halstead": 89.85848369899593
     },
     {
          "algorithm": "This algorithm prioritizes bins based on a combination of remaining capacity and the item's size, favoring bins that can accommodate the item without excessive leftover space and penalizing those that are too full or too empty.",
          "code": "def priority_v2(item, bins_remain_cap):\n  \"\"\"{This algorithm prioritizes bins based on a combination of remaining capacity and the item's size, favoring bins that can accommodate the item without excessive leftover space and penalizing those that are too full or too empty.}\"\"\"\n  priority = []\n  for cap in bins_remain_cap:\n    if cap >= item:\n      priority.append(cap - item)\n    else:\n      priority.append(-1)\n  return priority",
          "objective": 149.30195,
          "other_inf": null,
          "SLOC": 10.0,
          "cyclomatic_complexity": 3.0,
          "halstead": 44.37895002019238
     },
     {
          "algorithm": "This algorithm calculates the priority of each bin based on a combination of remaining capacity and a factor related to how much of the item fits in the bin, preferring bins that can accommodate the item reasonably well without wasting too much space.",
          "code": "def priority_v2(item, bins_remain_cap):\n  \"\"\"{This algorithm calculates the priority of each bin based on a combination of remaining capacity and a factor related to how much of the item fits in the bin, preferring bins that can accommodate the item reasonably well without wasting too much space.}\"\"\"\n  priority = []\n  for cap in bins_remain_cap:\n    if cap >= item:\n      priority.append(cap - item + cap * 0.1) # higher priority for bins that can fit the item with some space left.\n    else:\n      priority.append(-1) # very low priority for bins that can't fit the item.\n  return priority",
          "objective": 149.30195,
          "other_inf": null,
          "SLOC": 10.0,
          "cyclomatic_complexity": 3.0,
          "halstead": 44.37895002019238
     },
     {
          "algorithm": "This algorithm prioritizes bins based on a combination of remaining capacity and a penalty for fragmentation, favoring bins that can accommodate the item with minimal wasted space while discouraging excessive fragmentation.",
          "code": "def priority_v2(item, bins_remain_cap):\n    \"\"\"{This algorithm prioritizes bins based on a combination of remaining capacity and a penalty for fragmentation, favoring bins that can accommodate the item with minimal wasted space while discouraging excessive fragmentation.}\"\"\"\n    priority = []\n    for cap in bins_remain_cap:\n        if cap >= item:\n            waste = cap - item\n            if waste == 0:\n                p = 100  # Perfect fit gets highest priority\n            else:\n                # Priority based on remaining capacity, with a penalty for wasted space\n                p = 50 + (50 * (1 - (waste / cap))) # Adjusted priority calculation\n        else:\n            p = -1  # Cannot fit, lowest priority\n        priority.append(p)\n    return priority",
          "objective": Infinity,
          "other_inf": null,
          "SLOC": null,
          "cyclomatic_complexity": null,
          "halstead": null
     },
     {
          "algorithm": "This algorithm calculates the priority of each bin based on a combination of remaining capacity and wasted space if the item is placed in that bin, favoring bins with sufficient capacity and minimal wasted space.",
          "code": "def priority_v2(item, bins_remain_cap):\n  \"\"\"{This algorithm calculates the priority of each bin based on a combination of remaining capacity and wasted space if the item is placed in that bin, favoring bins with sufficient capacity and minimal wasted space.}\"\"\"\n  priority = []\n  for cap in bins_remain_cap:\n    if cap >= item:\n      wasted_space = cap - item\n      priority_score = cap + (1.0 / (wasted_space + 0.001))  # Avoid division by zero\n    else:\n      priority_score = -1  # Disqualify bins with insufficient capacity\n    priority.append(priority_score)\n  return priority",
          "objective": Infinity,
          "other_inf": null,
          "SLOC": null,
          "cyclomatic_complexity": null,
          "halstead": null
     },
     {
          "algorithm": "This algorithm calculates a priority score for each bin based on how much space would be wasted if the item were placed in that bin, prioritizing bins with less remaining capacity but enough to fit the item.",
          "code": "def priority_v2(item, bins_remain_cap):\n    \"\"\"{This algorithm calculates a priority score for each bin based on how much space would be wasted if the item were placed in that bin, prioritizing bins with less remaining capacity but enough to fit the item.}\"\"\"\n    priorities = []\n    for cap in bins_remain_cap:\n        if cap >= item:\n            waste = cap - item\n            priorities.append(1 / (waste + 1e-6))  # Avoid division by zero\n        else:\n            priorities.append(-1e9)  # Very low priority if item doesn't fit\n    return priority",
          "objective": Infinity,
          "other_inf": null,
          "SLOC": null,
          "cyclomatic_complexity": null,
          "halstead": null
     },
     {
          "algorithm": "This algorithm assigns priority to each bin based on the remaining capacity, favoring bins with capacity closest to the item size without being smaller, and also considering the overall fullness of the bins.",
          "code": "def priority_v2(item, bins_remain_cap):\n  \"\"\"{This algorithm assigns priority to each bin based on the remaining capacity, favoring bins with capacity closest to the item size without being smaller, and also considering the overall fullness of the bins.}\"\"\"\n  priority = []\n  for cap in bins_remain_cap:\n    if cap >= item:\n      priority.append(1 / (cap - item + 0.0001) + (1 - cap / sum(bins_remain_cap)))  # Higher priority for closer fit and fuller bins\n    else:\n      priority.append(-1000)  # Very low priority if bin is too small\n  return priority",
          "objective": Infinity,
          "other_inf": null,
          "SLOC": null,
          "cyclomatic_complexity": null,
          "halstead": null
     },
     {
          "algorithm": "This algorithm prioritizes bins based on a combination of remaining capacity and waste minimization, giving higher priority to bins that can accommodate the item with minimal wasted space and lower priority to bins that would be nearly filled or leave significant wasted space.",
          "code": "def priority_v2(item, bins_remain_cap):\n    \"\"\"{This algorithm prioritizes bins based on a combination of remaining capacity and waste minimization, giving higher priority to bins that can accommodate the item with minimal wasted space and lower priority to bins that would be nearly filled or leave significant wasted space.}\"\"\"\n    priorities = []\n    for cap in bins_remain_cap:\n        if cap >= item:\n            waste = cap - item\n            if waste == 0:\n                priorities.append(100)  # Perfect fit\n            elif waste <= cap * 0.2:\n                priorities.append(80 - waste)  # Good fit, low waste\n            else:\n                priorities.append(50 - waste)   # Fit, but significant waste\n        else:\n            priorities.append(-1)  # Cannot fit\n    return priority",
          "objective": Infinity,
          "other_inf": null,
          "SLOC": null,
          "cyclomatic_complexity": null,
          "halstead": null
     },
     {
          "algorithm": "This algorithm assigns a priority score to each bin based on the remaining capacity after placing the item, favoring bins with closer remaining capacity to the item size while avoiding overflow, and adds a bonus if the item fits perfectly.",
          "code": "def priority_v2(item, bins_remain_cap):\n    \"\"\"\n    {This algorithm assigns a priority score to each bin based on the remaining capacity after placing the item, favoring bins with closer remaining capacity to the item size while avoiding overflow, and adds a bonus if the item fits perfectly.}\n    \"\"\"\n    priority = []\n    for cap in bins_remain_cap:\n        if cap >= item:\n            remaining = cap - item\n            priority_score = 1 / (remaining + 0.0001)  # Avoid division by zero and favor smaller remaining capacity\n            if remaining == 0:\n                priority_score += 10  # Bonus for perfect fit\n        else:\n            priority_score = -1  # Assign negative priority if item doesn't fit\n        priority.append(priority_score)\n    return priority",
          "objective": Infinity,
          "other_inf": null,
          "SLOC": null,
          "cyclomatic_complexity": null,
          "halstead": null
     },
     {
          "algorithm": "This algorithm prioritizes bins based on a combination of remaining capacity and the closeness of the item size to a fraction of the remaining capacity, favoring bins that are neither too full nor too empty after packing.",
          "code": "def priority_v2(item, bins_remain_cap):\n    \"\"\"{This algorithm prioritizes bins based on a combination of remaining capacity and the closeness of the item size to a fraction of the remaining capacity, favoring bins that are neither too full nor too empty after packing.}\"\"\"\n    \n    priorities = []\n    for cap in bins_remain_cap:\n        if cap >= item:\n            # Calculate a score based on how well the item fits, favoring bins that aren't left too empty\n            fit_score = (item / cap)**0.5\n\n            # Calculate a score based on the remaining capacity after packing\n            remaining_cap_score = (1 - (cap - item) / sum(bins_remain_cap))**0.5\n            \n            priority = fit_score * remaining_cap_score \n            priorities.append(priority)\n        else:\n            priorities.append(-1)  # Assign -1 priority if the item doesn't fit\n\n    return priority",
          "objective": Infinity,
          "other_inf": null,
          "SLOC": null,
          "cyclomatic_complexity": null,
          "halstead": null
     },
     {
          "algorithm": "This algorithm calculates a priority score for each bin based on a weighted combination of remaining capacity and waste, favoring bins with sufficient capacity and minimizing wasted space.",
          "code": "def priority_v2(item, bins_remain_cap):\n  \"\"\"{This algorithm calculates a priority score for each bin based on a weighted combination of remaining capacity and waste, favoring bins with sufficient capacity and minimizing wasted space.}\"\"\"\n  priority = []\n  for cap in bins_remain_cap:\n    if cap >= item:\n      waste = cap - item\n      priority_score = cap*0.7 - waste*0.3  # Weighted combination\n      priority.append(priority_score)\n    else:\n      priority.append(-1) \n  return priority",
          "objective": Infinity,
          "other_inf": null,
          "SLOC": null,
          "cyclomatic_complexity": null,
          "halstead": null
     },
     {
          "algorithm": "This algorithm prioritizes bins based on the remaining capacity after placing the item, favoring bins where the remaining capacity is closest to a target value (half the bin capacity) and penalizing bins that are too full or too empty.",
          "code": "def priority_v2(item, bins_remain_cap):\n    \"\"\"{This algorithm prioritizes bins based on the remaining capacity after placing the item, favoring bins where the remaining capacity is closest to a target value (half the bin capacity) and penalizing bins that are too full or too empty.}\"\"\"\n    priorities = []\n    for cap in bins_remain_cap:\n        if cap >= item:\n            rem_cap = cap - item\n            target = 0.5 * (sum(bins_remain_cap) / len(bins_remain_cap)) \n            priority = -abs(rem_cap - target)\n            priorities.append(priority)\n        else:\n            priorities.append(-float('inf'))\n    return priority",
          "objective": Infinity,
          "other_inf": null,
          "SLOC": null,
          "cyclomatic_complexity": null,
          "halstead": null
     }
]