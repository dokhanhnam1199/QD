import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm iteratively constructs routes by prioritizing edges to nodes with unmet demand based on a combination of distance and demand, while enforcing capacity constraints.}
    """
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)
    num_iterations = 100

    for _ in range(num_iterations):
        remaining_nodes = list(range(1, n))
        routes = []
        current_route = [0]
        current_capacity = capacity

        while remaining_nodes:
            # Calculate a score for each possible next node based on distance and demand
            node_scores = {}
            for node in remaining_nodes:
                if demands[node] <= current_capacity:
                    distance = distance_matrix[current_route[-1], node]
                    demand_factor = demands[node] / capacity  # Normalize demand
                    node_scores[node] = 1 / (distance * (1 + demand_factor)) # Prioritize closer nodes with higher demand

            if not node_scores:
                routes.append(current_route + [0])
                current_route = [0]
                current_capacity = capacity
                continue

            # Choose the node with the highest score
            next_node = max(node_scores, key=node_scores.get)

            current_route.append(next_node)
            current_capacity -= demands[next_node]
            remaining_nodes.remove(next_node)

        routes.append(current_route + [0])

        # Update the heuristics matrix based on the edges in the routes
        for route in routes:
            for i in range(len(route) - 1):
                u = route[i]
                v = route[i+1]
                heuristics_matrix[u, v] += 1
                heuristics_matrix[v, u] += 1  # Assuming symmetric distance matrix

    # Normalize the matrix
    heuristics_matrix = heuristics_matrix / num_iterations
    return heuristics_matrix
