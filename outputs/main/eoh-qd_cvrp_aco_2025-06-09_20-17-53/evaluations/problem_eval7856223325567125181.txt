import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm constructs multiple routes by iteratively adding the nearest feasible node to the current route and updates a heuristic matrix based on edge usage frequencies, weighted by the inverse of the edge length.}
    """
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)
    num_samples = 1000

    for _ in range(num_samples):
        unvisited = set(range(1, n))
        routes = []
        while unvisited:
            current_route = []
            current_capacity = 0
            current_node = 0
            
            while unvisited:
                feasible_nodes = [node for node in unvisited if current_capacity + demands[node] <= capacity]

                if not feasible_nodes:
                    break

                nearest_node = None
                min_distance = float('inf')
                for node in feasible_nodes:
                    distance = distance_matrix[current_node, node]
                    if distance < min_distance:
                        min_distance = distance
                        nearest_node = node
                
                if nearest_node is None:
                    break
                
                next_node = nearest_node
                current_route.append(next_node)
                current_capacity += demands[next_node]
                unvisited.remove(next_node)
            
            routes.append(current_route)
        
        for route in routes:
            current_node = 0
            for next_node in route:
                edge_length = distance_matrix[current_node, next_node]
                if edge_length > 0:
                    heuristics_matrix[current_node, next_node] += 1 / edge_length
                    heuristics_matrix[next_node, current_node] += 1 / edge_length
                current_node = next_node
            edge_length = distance_matrix[current_node, 0]
            if edge_length > 0:
                heuristics_matrix[current_node, 0] += 1 / edge_length
                heuristics_matrix[0, current_node] += 1 / edge_length

    return heuristics_matrix
