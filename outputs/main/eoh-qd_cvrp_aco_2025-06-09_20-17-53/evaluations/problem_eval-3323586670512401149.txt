import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm iteratively refines a heuristic matrix by sampling routes, evaluating their cost and feasibility, and updating the matrix to favor edges present in elite routes while penalizing edges in infeasible routes.}
    """
    n = len(demands)
    heuristics_matrix = np.ones_like(distance_matrix)  # Initialize with ones to avoid division by zero
    num_iterations = 50
    num_samples_per_iteration = 20

    for iteration in range(num_iterations):
        route_costs = []
        routes = []
        feasibilities = []

        for _ in range(num_samples_per_iteration):
            # Generate a route using the heuristic matrix to guide the sampling
            unvisited = list(range(1, n))
            current_route = [0]
            current_capacity = capacity
            route = []
            while unvisited:
                # Choose the next node based on heuristic values
                probabilities = [heuristics_matrix[current_route[-1]][node] for node in unvisited]
                probabilities = np.array(probabilities)
                probabilities = probabilities / np.sum(probabilities)

                next_node = np.random.choice(unvisited, p=probabilities)

                if demands[next_node] <= current_capacity:
                    current_route.append(next_node)
                    current_capacity -= demands[next_node]
                    unvisited.remove(next_node)
                else:
                    current_route.append(0)
                    route.append(current_route)
                    current_route = [0, next_node]
                    current_capacity = capacity - demands[next_node]
                    unvisited.remove(next_node)
            current_route.append(0)
            route.append(current_route)

            # Calculate the cost and feasibility of the route
            cost = 0
            total_demand = 0
            feasible = True
            for r in route:
                current_demand = 0
                for i in range(len(r) - 1):
                    cost += distance_matrix[r[i]][r[i+1]]
                    if r[i+1] != 0:
                        current_demand += demands[r[i+1]]
                if current_demand > capacity:
                    feasible = False
                    break
                total_demand += current_demand

            route_costs.append(cost)
            routes.append(route)
            feasibilities.append(feasible)

        # Normalize route costs
        normalized_costs = np.array(route_costs)

        # Identify elite routes (feasible and low cost)
        feasible_indices = np.where(np.array(feasibilities) == True)[0]
        if len(feasible_indices) > 0:

            feasible_costs = normalized_costs[feasible_indices]
            
            #Find the median of feasible costs.
            median_cost = np.median(feasible_costs)

            elite_indices = feasible_indices[np.where(feasible_costs <= median_cost)[0]]

            # Update heuristics matrix
            for index in range(num_samples_per_iteration):
                route = routes[index]
                for r in route:
                    for i in range(len(r) - 1):
                        if index in elite_indices:
                            heuristics_matrix[r[i]][r[i+1]] *= 1.1  # Reward edges in elite routes
                            heuristics_matrix[r[i+1]][r[i]] *= 1.1
                        elif not feasibilities[index]:
                            heuristics_matrix[r[i]][r[i+1]] *= 0.9  # Penalize edges in infeasible routes
                            heuristics_matrix[r[i+1]][r[i]] *= 0.9
    return heuristics_matrix
