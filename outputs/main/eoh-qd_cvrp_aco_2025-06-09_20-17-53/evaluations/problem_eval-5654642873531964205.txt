import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm uses an Ant Colony Optimization (ACO) approach to construct a heuristic matrix based on pheromone levels influenced by route quality and edge usage.}"""
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)
    pheromone_matrix = np.ones_like(distance_matrix)  # Initialize pheromone levels
    alpha = 1.0  # Pheromone influence
    beta = 2.0  # Distance influence
    evaporation_rate = 0.1
    num_ants = 50
    num_iterations = 100

    for iteration in range(num_iterations):
        ant_routes = []
        ant_costs = []

        for ant in range(num_ants):
            unvisited = list(range(1, n))
            current_route = [0]
            current_load = 0
            route = []

            while unvisited:
                probabilities = np.zeros(len(unvisited))
                for i, node in enumerate(unvisited):
                    if current_load + demands[node] <= capacity:
                        probabilities[i] = (pheromone_matrix[current_route[-1], node]**alpha) * ((1.0 / distance_matrix[current_route[-1], node])**beta)
                    else:
                        probabilities[i] = 0
                
                if np.sum(probabilities) == 0:
                    current_route.append(0)
                    route.append(current_route)
                    current_route = [0]
                    current_load = 0
                    probabilities = np.zeros(len(unvisited))
                    for i, node in enumerate(unvisited):
                        if current_load + demands[node] <= capacity:
                            probabilities[i] = (pheromone_matrix[current_route[-1], node]**alpha) * ((1.0 / distance_matrix[current_route[-1], node])**beta)
                        else:
                            probabilities[i] = 0
                    if np.sum(probabilities) == 0:
                        break
                    
                probabilities /= np.sum(probabilities)
                
                next_node = np.random.choice(unvisited, p=probabilities)
                if current_load + demands[next_node] <= capacity:
                    current_route.append(next_node)
                    current_load += demands[next_node]
                    unvisited.remove(next_node)
                else:
                    current_route.append(0)
                    route.append(current_route)
                    current_route = [0, next_node]
                    current_load = demands[next_node]
                    unvisited.remove(next_node)

            current_route.append(0)
            route.append(current_route)
            ant_routes.append(route)

            cost = 0
            for r in route:
                for i in range(len(r) - 1):
                    cost += distance_matrix[r[i]][r[i+1]]
            ant_costs.append(cost)

        # Update pheromone levels
        pheromone_matrix *= (1 - evaporation_rate)

        best_ant_index = np.argmin(ant_costs)
        best_route = ant_routes[best_ant_index]
        best_cost = ant_costs[best_ant_index]

        for route in best_route:
            for i in range(len(route) - 1):
                pheromone_matrix[route[i], route[i+1]] += 1.0 / best_cost
                pheromone_matrix[route[i+1], route[i]] += 1.0 / best_cost

    # Use pheromone matrix as the heuristics matrix
    heuristics_matrix = pheromone_matrix
    return heuristics_matrix
