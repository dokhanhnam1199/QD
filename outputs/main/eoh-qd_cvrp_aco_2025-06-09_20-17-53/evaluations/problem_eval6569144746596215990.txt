import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm constructs routes by iteratively adding the nearest feasible node to the current route until capacity is reached, then returns to the depot and repeats, using edge frequency across multiple iterations to build the heuristic matrix.}"""
    n = len(demands)
    heuristics_matrix = np.zeros((n, n))
    num_iterations = 1000

    for _ in range(num_iterations):
        unvisited_nodes = set(range(1, n))
        current_route = [0]
        current_load = 0
        routes = []

        while unvisited_nodes:
            nearest_node = None
            min_distance = float('inf')

            for node in unvisited_nodes:
                if current_load + demands[node] <= capacity:
                    dist = distance_matrix[current_route[-1], node]
                    if dist < min_distance:
                        min_distance = dist
                        nearest_node = node

            if nearest_node is not None:
                current_route.append(nearest_node)
                current_load += demands[nearest_node]
                unvisited_nodes.remove(nearest_node)
            else:
                current_route.append(0)
                routes.append(current_route)
                current_route = [0]
                current_load = 0

        current_route.append(0)
        routes.append(current_route)
        
        for route in routes:
            for i in range(len(route) - 1):
                node1 = route[i]
                node2 = route[i+1]
                heuristics_matrix[node1, node2] += 1
                heuristics_matrix[node2, node1] += 1

    heuristics_matrix = heuristics_matrix / num_iterations

    return heuristics_matrix
