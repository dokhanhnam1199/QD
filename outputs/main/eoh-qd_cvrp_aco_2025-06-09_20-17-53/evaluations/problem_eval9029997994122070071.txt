import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm constructs initial routes using a savings-based approach, then iteratively improves them by considering node exchanges between routes, favoring exchanges that reduce total distance and maintain feasibility.}"""
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)

    # 1. Savings Calculation
    savings = np.zeros((n, n))
    for i in range(1, n):
        for j in range(i + 1, n):
            savings[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]
            savings[j, i] = savings[i, j] #Symmetry

    # 2. Initial Route Construction (Savings-based)
    routes = []
    unvisited = set(range(1, n))

    while unvisited:
        best_savings = -1
        best_i = -1
        best_j = -1

        for i in unvisited:
            for j in unvisited:
                if i == j:
                    continue
                if savings[i, j] > best_savings:
                    best_savings = savings[i, j]
                    best_i = i
                    best_j = j

        if best_i != -1 and best_j != -1:
            # Attempt to merge best_i and best_j into a single route
            capacity_i = demands[best_i]
            capacity_j = demands[best_j]

            # Check if either is already in a route
            route_i = None
            route_j = None
            for route_idx, route in enumerate(routes):
                if best_i in route:
                    route_i = route
                if best_j in route:
                    route_j = route

            #If both are not in any routes
            if route_i is None and route_j is None:
                if capacity_i + capacity_j <= capacity:
                    routes.append([best_i, best_j])
                    unvisited.remove(best_i)
                    unvisited.remove(best_j)
            #if one is in route, and the other is not
            elif route_i is not None and route_j is None:
                total_demand = sum([demands[node] for node in route_i])
                if total_demand + capacity_j <= capacity:
                    route_i.append(best_j)
                    unvisited.remove(best_j)
            elif route_i is None and route_j is not None:
                total_demand = sum([demands[node] for node in route_j])
                if total_demand + capacity_i <= capacity:
                    route_j.append(best_i)
                    unvisited.remove(best_i)

        else:
            # Handle the case when no merge is possible (create a single-node route)
            node = unvisited.pop()
            routes.append([node])

    # 3. Route Improvement (Node Exchange)
    num_iterations = 1000
    for _ in range(num_iterations):
        # Select two random routes
        if len(routes) < 2:
            break  # Not enough routes for exchange

        route1_idx = random.randint(0, len(routes) - 1)
        route2_idx = random.randint(0, len(routes) - 1)
        if route1_idx == route2_idx:
            continue

        route1 = routes[route1_idx]
        route2 = routes[route2_idx]

        # Select two random nodes from the routes
        if not route1 or not route2:
            continue

        node1_idx = random.randint(0, len(route1) - 1)
        node2_idx = random.randint(0, len(route2) - 1)

        node1 = route1[node1_idx]
        node2 = route2[node2_idx]

        # Calculate the change in distance if the nodes are swapped
        original_distance = 0
        new_distance = 0

        # Distance calculation for Route 1
        if len(route1) > 1:
            if node1_idx > 0:
                original_distance += distance_matrix[route1[node1_idx - 1], node1]
                new_distance += distance_matrix[route1[node1_idx - 1], node2]
            else:
                original_distance += distance_matrix[0, node1]
                new_distance += distance_matrix[0, node2]


            if node1_idx < len(route1) - 1:
                original_distance += distance_matrix[node1, route1[node1_idx + 1]]
                new_distance += distance_matrix[node2, route1[node1_idx + 1]]
            else:
                original_distance += distance_matrix[node1, 0]
                new_distance += distance_matrix[node2, 0]

        # Distance calculation for Route 2
        if len(route2) > 1:
            if node2_idx > 0:
                original_distance += distance_matrix[route2[node2_idx - 1], node2]
                new_distance += distance_matrix[route2[node2_idx - 1], node1]
            else:
                original_distance += distance_matrix[0, node2]
                new_distance += distance_matrix[0, node1]

            if node2_idx < len(route2) - 1:
                original_distance += distance_matrix[node2, route2[node2_idx + 1]]
                new_distance += distance_matrix[node1, route2[node2_idx + 1]]
            else:
                original_distance += distance_matrix[node2, 0]
                new_distance += distance_matrix[node1, 0]


        # Check capacity constraints after swapping
        route1_demand = sum([demands[n] for n in route1]) - demands[node1] + demands[node2]
        route2_demand = sum([demands[n] for n in route2]) - demands[node2] + demands[node1]

        if route1_demand <= capacity and route2_demand <= capacity and new_distance < original_distance:
            # Swap the nodes
            route1[node1_idx] = node2
            route2[node2_idx] = node1
    # 4. Heuristics Matrix Update
    for route in routes:
        route = [0] + route + [0]
        for i in range(len(route) - 1):
            node1 = route[i]
            node2 = route[i + 1]
            heuristics_matrix[node1, node2] += 1
            heuristics_matrix[node2, node1] += 1

    return heuristics_matrix
