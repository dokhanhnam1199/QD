import numpy as np

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm samples multiple random routes, evaluates their feasibility with respect to capacity constraints, and then aggregates edge frequencies across feasible routes to estimate the likelihood of each edge being part of a good solution.}
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros((n, n))
    num_samples = 1000

    for _ in range(num_samples):
        route = list(range(1, n))
        np.random.shuffle(route)
        
        current_route = [0]
        current_demand = 0
        all_routes = []
        
        for node in route:
            if current_demand + demands[node] <= capacity:
                current_route.append(node)
                current_demand += demands[node]
            else:
                current_route.append(0)
                all_routes.append(current_route)
                current_route = [0, node]
                current_demand = demands[node]
        current_route.append(0)
        all_routes.append(current_route)
        
        for current_route in all_routes:
            for i in range(len(current_route) - 1):
                node1 = current_route[i]
                node2 = current_route[i+1]
                heuristics_matrix[node1, node2] += 1
                heuristics_matrix[node2, node1] += 1

    total_edges = num_samples
    heuristics_matrix = heuristics_matrix / num_samples

    return heuristics_matrix
