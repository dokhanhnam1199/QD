import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm iteratively refines a set of routes by probabilistically swapping edges based on their contribution to reducing the overall route cost, weighted by a temperature parameter that decreases over time.}
    """
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)
    num_iterations = 1000
    initial_temperature = 100.0
    cooling_rate = 0.95

    # Initialize a random route
    def generate_random_routes():
        remaining_nodes = list(range(1, n))
        routes = []
        current_route = [0]
        current_capacity = capacity

        while remaining_nodes:
            
            possible_nodes = []
            for node in remaining_nodes:
                if demands[node] <= current_capacity:
                    possible_nodes.append(node)
            
            if not possible_nodes:
                routes.append(current_route + [0])
                current_route = [0]
                current_capacity = capacity
                continue
                
            next_node = random.choice(possible_nodes)
            

            current_route.append(next_node)
            current_capacity -= demands[next_node]
            remaining_nodes.remove(next_node)

        routes.append(current_route + [0])
        return routes

    routes = generate_random_routes()
    
    def calculate_route_cost(routes):
        cost = 0
        for route in routes:
            for i in range(len(route) - 1):
                cost += distance_matrix[route[i]][route[i+1]]
        return cost
    
    current_cost = calculate_route_cost(routes)
    
    temperature = initial_temperature

    for iteration in range(num_iterations):
        # Select two random edges
        route_index1 = random.randint(0, len(routes) - 1)
        if len(routes[route_index1]) <= 2:
            continue
        i = random.randint(0, len(routes[route_index1]) - 2)
        u1 = routes[route_index1][i]
        v1 = routes[route_index1][i+1]

        route_index2 = random.randint(0, len(routes) - 1)
        if len(routes[route_index2]) <= 2:
            continue
        j = random.randint(0, len(routes[route_index2]) - 2)
        u2 = routes[route_index2][j]
        v2 = routes[route_index2][j+1]

        # Calculate the cost change of swapping the edges
        cost_change = (distance_matrix[u1, u2] + distance_matrix[v1, v2]) - (distance_matrix[u1, v1] + distance_matrix[u2, v2])

        # Accept the swap with a probability based on the temperature
        if cost_change < 0 or random.random() < np.exp(-cost_change / temperature):

            routes[route_index1][i+1] = u2
            routes[route_index2][j+1] = v1

            current_cost = calculate_route_cost(routes)
        
        temperature *= cooling_rate
            
    
    # Update heuristics matrix based on final routes
    for route in routes:
        for i in range(len(route) - 1):
            heuristics_matrix[route[i]][route[i+1]] += 1
            heuristics_matrix[route[i+1]][route[i]] += 1  # Symmetry
    
    
    return heuristics_matrix
