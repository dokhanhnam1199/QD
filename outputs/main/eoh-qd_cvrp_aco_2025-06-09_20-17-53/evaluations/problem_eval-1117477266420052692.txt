import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm adaptively samples routes, prioritizing edges from routes with lower estimated cost, guided by a probability distribution updated based on route performance.}
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros((n, n))
    num_samples = 1000
    edge_counts = np.zeros((n, n))
    edge_probabilities = np.ones((n, n)) / (n * n)

    for _ in range(num_samples):
        # Generate a route using edge probabilities
        unvisited = set(range(1, n))
        route = [0]
        current_capacity = 0
        
        while unvisited:
            possible_next_nodes = list(unvisited)
            probabilities = [edge_probabilities[route[-1], node] if current_capacity + demands[node] <= capacity else 0 for node in possible_next_nodes]
            
            if sum(probabilities) == 0:
                route.append(0)
                current_capacity = 0
                if len(route) > 2:
                    break
                else:
                    possible_next_nodes = list(unvisited)
                    probabilities = [edge_probabilities[0, node] if current_capacity + demands[node] <= capacity else 0 for node in possible_next_nodes]
                    if sum(probabilities) == 0:
                        break
            
            probabilities = [p / sum(probabilities) for p in probabilities]
            
            next_node = random.choices(possible_next_nodes, probabilities)[0]
            
            if current_capacity + demands[next_node] <= capacity:
                route.append(next_node)
                current_capacity += demands[next_node]
                unvisited.remove(next_node)
            else:
                break

        route.append(0)

        # Calculate the estimated cost
        total_distance = 0
        for i in range(len(route) - 1):
            total_distance += distance_matrix[route[i], route[i+1]]

        # Update edge counts
        for i in range(len(route) - 1):
            node1 = route[i]
            node2 = route[i+1]
            edge_counts[node1, node2] += 1
            edge_counts[node2, node1] += 1
            

        # Update edge probabilities based on route cost (simulated annealing-like)
        temperature = 1.0 - (_ / num_samples) # Linear cooling
        if total_distance > 0:
            for i in range(len(route) - 1):
                node1 = route[i]
                node2 = route[i+1]
                edge_probabilities[node1, node2] *= np.exp(-total_distance * temperature)
                edge_probabilities[node2, node1] *= np.exp(-total_distance * temperature)
        else:
            pass

        edge_probabilities /= np.sum(edge_probabilities)


    # Normalize edge counts to create the heuristic matrix
    total_edge_count = np.sum(edge_counts)
    if total_edge_count > 0:
        heuristics_matrix = edge_counts / total_edge_count
    
    return heuristics_matrix
