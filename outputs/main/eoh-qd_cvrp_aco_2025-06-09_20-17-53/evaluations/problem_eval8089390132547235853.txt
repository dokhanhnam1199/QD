import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm iteratively refines routes by swapping nodes between them to improve feasibility and reduce total distance, and then updates a heuristic matrix based on edge frequencies in the improved routes.}"""

    n = len(demands)
    heuristics_matrix = np.zeros((n, n))
    num_samples = 500  # Reduced number of initial samples
    num_iterations = 5  # Number of refinement iterations per sample

    for _ in range(num_samples):
        # Generate an initial random solution
        customer_nodes = list(range(1, n))
        random.shuffle(customer_nodes)

        routes = []
        current_route = [0]
        current_load = 0

        for node in customer_nodes:
            if current_load + demands[node] <= capacity:
                current_route.append(node)
                current_load += demands[node]
            else:
                current_route.append(0)
                routes.append(current_route)
                current_route = [0, node]
                current_load = demands[node]

        current_route.append(0)
        routes.append(current_route)

        # Refine the solution by swapping nodes between routes
        for _ in range(num_iterations):
            for i in range(len(routes)):
                for j in range(len(routes)):
                    if i == j:
                        continue
                    
                    route1 = routes[i]
                    route2 = routes[j]

                    if len(route1) <= 2 or len(route2) <= 2:  # Skip if route is just depot
                        continue

                    # Choose a random node from each route (excluding the depot)
                    node1_index = random.randint(1, len(route1) - 2) # Avoid depot
                    node2_index = random.randint(1, len(route2) - 2)
                    node1 = route1[node1_index]
                    node2 = route2[node2_index]

                    # Check if swapping nodes would improve the routes (feasibility and distance)
                    route1_load = sum(demands[node] for node in route1[1:-1]) #exclude depot
                    route2_load = sum(demands[node] for node in route2[1:-1])
                    
                    new_route1_load = route1_load - demands[node1] + demands[node2]
                    new_route2_load = route2_load - demands[node2] + demands[node1]

                    if new_route1_load <= capacity and new_route2_load <= capacity:
                        # Calculate total distance before and after swap
                        dist_before = distance_matrix[route1[node1_index -1], node1] + distance_matrix[node1, route1[node1_index + 1]] + \
                                      distance_matrix[route2[node2_index - 1], node2] + distance_matrix[node2, route2[node2_index + 1]]
                        
                        dist_after = distance_matrix[route1[node1_index - 1], node2] + distance_matrix[node2, route1[node1_index + 1]] + \
                                      distance_matrix[route2[node2_index - 1], node1] + distance_matrix[node1, route2[node2_index + 1]]
                                      
                        if dist_after < dist_before: # Only swap if it reduces distance
                            # Swap the nodes
                            route1[node1_index] = node2
                            route2[node2_index] = node1

        # Update heuristics matrix based on edges in the refined routes
        for route in routes:
            for i in range(len(route) - 1):
                node1 = route[i]
                node2 = route[i+1]
                heuristics_matrix[node1, node2] += 1
                heuristics_matrix[node2, node1] += 1

    # Normalize the heuristics matrix
    total_route_edges = np.sum(heuristics_matrix)
    if total_route_edges > 0:
        heuristics_matrix = heuristics_matrix / total_route_edges

    return heuristics_matrix
