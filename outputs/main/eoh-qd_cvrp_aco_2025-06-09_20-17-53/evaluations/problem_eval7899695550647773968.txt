import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm uses a reinforcement learning approach to iteratively refine edge probabilities based on the quality of sampled routes, rewarding edges in good routes and penalizing edges in bad ones.}"""
    n = len(demands)
    heuristics_matrix = np.ones((n, n))  # Initialize with ones to avoid division by zero
    learning_rate = 0.1
    discount_factor = 0.9
    num_samples = 1000

    for _ in range(num_samples):
        # Generate a route using probabilities from heuristics_matrix
        current_node = 0
        route = [0]
        current_capacity = capacity
        unvisited = set(range(1, n))

        while unvisited:
            probabilities = heuristics_matrix[current_node, list(unvisited)]
            
            #Adjust probabilities based on demand feasibility
            valid_nodes = [node for node in unvisited if demands[node] <= current_capacity]
            if not valid_nodes:
                route.append(0)
                current_node = 0
                current_capacity = capacity
                continue #back to depot

            valid_indices = [i for i, node in enumerate(unvisited) if node in valid_nodes]
            probabilities = heuristics_matrix[current_node, list(unvisited)]

            # Normalize probabilities of possible nodes for proper random selection
            probabilities = probabilities[valid_indices]
            probabilities = probabilities / np.sum(probabilities)

            next_node = random.choices(list(np.array(list(unvisited))[valid_indices]), weights=probabilities)[0]

            route.append(next_node)
            unvisited.remove(next_node)
            current_capacity -= demands[next_node]
            current_node = next_node

        route.append(0)  # Return to depot

        # Calculate route cost
        route_cost = 0
        for i in range(len(route) - 1):
            route_cost += distance_matrix[route[i], route[i+1]]

        # Update heuristics_matrix based on route quality (simplified reward/penalty)
        for i in range(len(route) - 1):
            u = route[i]
            v = route[i+1]
            if route_cost < np.mean(distance_matrix): #Threshold with mean distance
                heuristics_matrix[u, v] *= (1 + learning_rate)  # Reward good edges
                heuristics_matrix[v, u] *= (1 + learning_rate) # make it symmetric
            else:
                heuristics_matrix[u, v] *= (1 - learning_rate)  # Penalize bad edges
                heuristics_matrix[v, u] *= (1 - learning_rate)

        #Ensure positivity of heuristic matrix
        heuristics_matrix[heuristics_matrix <=0 ] = 1e-6
    return heuristics_matrix
