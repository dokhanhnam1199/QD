import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm iteratively refines edge importance by simulating vehicle tours, rewarding edges used in feasible tours, and penalizing edges that lead to infeasibility.}"""
    n = len(demands)
    heuristics_matrix = np.ones_like(distance_matrix) 
    num_iterations = 50
    learning_rate = 0.1

    for _ in range(num_iterations):
        
        unvisited = set(range(1, n))
        current_node = 0
        current_route = [0]
        current_capacity = 0
        
        while unvisited:
            
            probabilities = heuristics_matrix[current_node, list(unvisited)].copy()
            
            feasible_nodes = [node for node in unvisited if current_capacity + demands[node] <= capacity]
            
            if not feasible_nodes:
              heuristics_matrix[current_node, current_route[-1]] *= (1 - learning_rate)
              break

            
            probabilities[[i for i, node in enumerate(unvisited) if node not in feasible_nodes]] = 0
            if np.sum(probabilities) == 0:
                next_node = random.choice(feasible_nodes)
            else:
                probabilities = probabilities / np.sum(probabilities)
                next_node = random.choices(list(unvisited), weights=probabilities, k=1)[0]

            
            heuristics_matrix[current_node, next_node] += learning_rate
            heuristics_matrix[next_node, current_node] += learning_rate
                
            current_route.append(next_node)
            current_capacity += demands[next_node]
            unvisited.remove(next_node)
            current_node = next_node
        
        
        if current_route[-1] != 0:
            heuristics_matrix[current_route[-1], 0] += learning_rate
            heuristics_matrix[0, current_route[-1]] += learning_rate
            
            

    return heuristics_matrix
