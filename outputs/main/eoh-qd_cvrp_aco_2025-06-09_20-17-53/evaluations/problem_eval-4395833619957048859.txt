import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm iteratively constructs routes by probabilistically selecting the next node based on a combination of distance and pheromone-inspired edge frequencies, updating these frequencies after each sampled route.}
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = np.ones_like(distance_matrix, dtype=float)  # Initialize with small values
    num_samples = 1000
    alpha = 1.0  # Influence of pheromone
    beta = 2.0  # Influence of distance
    rho = 0.1  # Evaporation rate

    for _ in range(num_samples):
        current_route = [0]
        current_load = 0
        visited = {0}
        route_edges = []

        while len(visited) < n:
            feasible_neighbors = []
            for i in range(1, n):
                if i not in visited and current_load + demands[i] <= capacity:
                    feasible_neighbors.append(i)

            if not feasible_neighbors:
                current_route.append(0)
                route_edges.append((current_route[-2], 0))
                current_load = 0
                continue

            probabilities = []
            for neighbor in feasible_neighbors:
                pheromone = heuristics_matrix[current_route[-1]][neighbor]
                distance = distance_matrix[current_route[-1]][neighbor]
                probabilities.append((pheromone**alpha) / (distance**beta))

            total_prob = sum(probabilities)
            probabilities = [p / total_prob for p in probabilities]

            next_node = random.choices(feasible_neighbors, weights=probabilities, k=1)[0]
            current_route.append(next_node)
            route_edges.append((current_route[-2], next_node))
            current_load += demands[next_node]
            visited.add(next_node)

        current_route.append(0)
        route_edges.append((current_route[-2], 0))
        
        # Update pheromones - could scale by route length or cost for better performance
        for u, v in route_edges:
            heuristics_matrix[u, v] += 1 / len(current_route)
            heuristics_matrix[v, u] += 1 / len(current_route)

        # Evaporation
        heuristics_matrix *= (1 - rho)

    return heuristics_matrix
