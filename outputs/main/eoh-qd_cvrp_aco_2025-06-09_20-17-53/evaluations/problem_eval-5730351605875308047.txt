import numpy as np

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm constructs a savings matrix based on the Clarke-Wright savings algorithm, then perturbs it with random noise scaled by edge distances to introduce stochasticity, and finally normalizes it.}"""
    n = distance_matrix.shape[0]
    savings_matrix = np.zeros((n, n))

    # Calculate savings matrix (Clarke-Wright)
    for i in range(1, n):
        for j in range(i + 1, n):
            savings_matrix[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]
            savings_matrix[j, i] = savings_matrix[i, j]

    # Add random noise, scaled by distance
    noise_scale = 0.1  # Adjust for desired noise level
    noise = np.random.normal(0, noise_scale * distance_matrix, size=(n, n))
    savings_matrix = savings_matrix + noise

    # Normalize to [0, 1]
    min_val = np.min(savings_matrix)
    max_val = np.max(savings_matrix)

    if max_val > min_val:
        heuristics_matrix = (savings_matrix - min_val) / (max_val - min_val)
    else:
        heuristics_matrix = np.ones((n, n)) * 0.5

    return heuristics_matrix
