import numpy as np

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm iteratively builds routes by probabilistically selecting the next customer based on distance and demand, penalizing selections that lead to capacity violations, and updating a heuristic matrix based on route feasibility and edge usage.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros((n, n))
    num_iterations = 1000
    alpha = 1.0  # Adjust to control exploration vs. exploitation

    for _ in range(num_iterations):
        current_node = 0  # Start at the depot
        current_load = 0
        route = [0]
        unvisited_customers = set(range(1, n))
        
        while unvisited_customers:
            # Calculate selection probabilities
            probabilities = np.zeros(n)
            for customer in unvisited_customers:
                # Penalize selections that would violate capacity
                if current_load + demands[customer] > capacity:
                    probabilities[customer] = 0
                else:
                    probabilities[customer] = np.exp(-alpha * distance_matrix[current_node, customer]) / demands[customer]

            # Normalize probabilities
            if np.sum(probabilities) > 0:
                probabilities = probabilities / np.sum(probabilities)
            else:
                # If all remaining customers would violate capacity on current route, return to depot.
                probabilities = np.zeros(n)
                probabilities[0] = 1
                
            # Select the next customer probabilistically
            try:
                next_node = np.random.choice(n, p=probabilities)
            except ValueError:
                next_node = 0

            if next_node != 0 and current_load + demands[next_node] <= capacity:
                route.append(next_node)
                current_load += demands[next_node]
                unvisited_customers.remove(next_node)
                current_node = next_node
            else:
                # Return to depot
                route.append(0)
                current_node = 0
                current_load = 0
                
                if len(unvisited_customers) > 0:
                    probabilities = np.zeros(n)
                    for customer in unvisited_customers:
                        # Penalize selections that would violate capacity
                        if current_load + demands[customer] > capacity:
                            probabilities[customer] = 0
                        else:
                            probabilities[customer] = np.exp(-alpha * distance_matrix[current_node, customer]) / demands[customer]

                    if np.sum(probabilities) > 0:
                        probabilities = probabilities / np.sum(probabilities)
                    else:
                        break
                    
                    try:
                        next_node = np.random.choice(n, p=probabilities)
                    except ValueError:
                        break

                    route.append(next_node)
                    current_load += demands[next_node]
                    unvisited_customers.remove(next_node)
                    current_node = next_node
                else:
                    break


        route.append(0)  # Return to depot

        # Update heuristics matrix
        for i in range(len(route) - 1):
            u = route[i]
            v = route[i+1]
            heuristics_matrix[u, v] += 1

    return heuristics_matrix
