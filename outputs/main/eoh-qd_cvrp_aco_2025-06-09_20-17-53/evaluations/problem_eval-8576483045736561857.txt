import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm uses stochastic solution sampling with a distance-based weighting to estimate edge importance, 
    constructing many random feasible routes and aggregating edge usage frequencies weighted by the inverse of the edge distance to create a heuristic matrix.}
    """
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)
    num_samples = 1000

    for _ in range(num_samples):
        unvisited = set(range(1, n))
        routes = []
        while unvisited:
            current_route = []
            current_capacity = 0
            current_node = 0 
            
            while unvisited:
                
                feasible_nodes = [node for node in unvisited if current_capacity + demands[node] <= capacity]

                if not feasible_nodes:
                    break

                next_node = random.choice(feasible_nodes)
                current_route.append(next_node)
                current_capacity += demands[next_node]
                unvisited.remove(next_node)
            
            routes.append(current_route)
        
        for route in routes:
            current_node = 0
            for next_node in route:
                weight = 1.0 / (distance_matrix[current_node, next_node] + 1e-6)  # Add a small constant to avoid division by zero
                heuristics_matrix[current_node, next_node] += weight
                heuristics_matrix[next_node, current_node] += weight
                current_node = next_node
            weight = 1.0 / (distance_matrix[current_node, 0] + 1e-6)
            heuristics_matrix[current_node, 0] += weight
            heuristics_matrix[0, current_node] += weight

    return heuristics_matrix
