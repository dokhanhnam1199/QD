import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm uses a greedy approach with stochastic elements to build routes, prioritizing closer nodes with available capacity, and aggregates edge frequencies across multiple route constructions to form a heuristic matrix.}
    """
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)
    num_samples = 1000

    for _ in range(num_samples):
        unvisited = set(range(1, n))
        routes = []

        while unvisited:
            current_route = [0]
            current_capacity = 0
            current_node = 0

            while True:
                # Find feasible nodes based on capacity
                feasible_nodes = [node for node in unvisited if current_capacity + demands[node] <= capacity]

                if not feasible_nodes:
                    break  # No more feasible nodes for this route

                # Prioritize closer nodes stochastically
                distances = [distance_matrix[current_node, node] for node in feasible_nodes]
                probabilities = [1 / (d + 0.0001) for d in distances]  # Inverse distance, avoid division by zero
                probabilities = np.array(probabilities) / np.sum(probabilities)  # Normalize to probabilities

                next_node = random.choices(feasible_nodes, weights=probabilities)[0]

                current_route.append(next_node)
                current_capacity += demands[next_node]
                unvisited.remove(next_node)
                current_node = next_node

            current_route.append(0)
            routes.append(current_route)

        # Update heuristics matrix based on edge frequencies
        for route in routes:
            for i in range(len(route) - 1):
                u = route[i]
                v = route[i+1]
                heuristics_matrix[u, v] += 1
                heuristics_matrix[v, u] += 1

    return heuristics_matrix
