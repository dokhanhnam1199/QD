import numpy as np

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm uses a genetic algorithm approach to evolve a population of random routes, selecting the best routes based on fitness (cost and feasibility) and using their edge frequencies to construct a heuristic matrix.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros((n, n))
    population_size = 50
    num_generations = 100
    mutation_rate = 0.1

    # Initialize population
    population = []
    for _ in range(population_size):
        permutation = np.random.permutation(range(1, n))
        routes = []
        current_route = [0]
        current_load = 0

        for customer in permutation:
            if current_load + demands[customer] <= capacity:
                current_route.append(customer)
                current_load += demands[customer]
            else:
                current_route.append(0)
                routes.append(current_route)
                current_route = [0, customer]
                current_load = demands[customer]

        current_route.append(0)
        routes.append(current_route)
        population.append(routes)

    # Genetic algorithm iterations
    for _ in range(num_generations):
        # Evaluate fitness of each individual
        fitness_scores = []
        for routes in population:
            total_cost = 0
            total_load_violation = 0
            for route in routes:
                route_cost = 0
                route_load = 0
                for i in range(len(route) - 1):
                    u = route[i]
                    v = route[i+1]
                    route_cost += distance_matrix[u, v]

                    if u != 0 and u != route[-1]:
                        route_load += demands[u]
                total_cost += route_cost
                total_load_violation += max(0, route_load - capacity)  # Penalty for exceeding capacity
            fitness_scores.append(total_cost + 1000*total_load_violation) # Combine cost and violation; penalize violation heavily

        # Selection (tournament selection)
        selected_population = []
        tournament_size = 5
        for _ in range(population_size):
            tournament_indices = np.random.choice(range(population_size), tournament_size, replace=False)
            tournament_fitnesses = [fitness_scores[i] for i in tournament_indices]
            winner_index = tournament_indices[np.argmin(tournament_fitnesses)]
            selected_population.append(population[winner_index])

        # Crossover (order crossover) and mutation
        new_population = []
        for i in range(0, population_size, 2):
            parent1_routes = selected_population[i]
            parent2_routes = selected_population[(i+1) % population_size]  # Wrap around if odd number of individuals
            
            # Flatten the routes to operate on a single permutation
            parent1_permutation = []
            for route in parent1_routes:
                parent1_permutation.extend([node for node in route if node != 0])  # Exclude depots

            parent2_permutation = []
            for route in parent2_routes:
                parent2_permutation.extend([node for node in route if node != 0])
            
            # Ensure permutations have the same nodes. If not, something is wrong with routes.
            all_nodes = set(range(1, n))
            if set(parent1_permutation) != all_nodes or set(parent2_permutation) != all_nodes:
                # Handle this exceptional case more robustly, maybe by skipping crossover or generating a new random permutation
                new_population.append(parent1_routes)
                new_population.append(parent2_routes)
                continue

            # Crossover - Order Crossover (OX1)
            size = len(parent1_permutation)
            start, end = sorted(np.random.choice(range(size), 2, replace=False))

            child1_permutation = [None] * size
            child1_permutation[start:end+1] = parent1_permutation[start:end+1]

            current_index = end + 1
            parent2_index = end + 1

            while None in child1_permutation:
                if current_index >= size:
                    current_index = 0
                if parent2_index >= size:
                    parent2_index = 0

                if parent2_permutation[parent2_index] not in child1_permutation:
                    child1_permutation[current_index] = parent2_permutation[parent2_index]
                    current_index += 1
                parent2_index += 1
            
            # Mutation - Swap mutation
            if np.random.rand() < mutation_rate:
                idx1, idx2 = np.random.choice(range(size), 2, replace=False)
                child1_permutation[idx1], child1_permutation[idx2] = child1_permutation[idx2], child1_permutation[idx1]

            # Convert permutation back into routes
            child1_routes = []
            current_route = [0]
            current_load = 0
            for customer in child1_permutation:
                if current_load + demands[customer] <= capacity:
                    current_route.append(customer)
                    current_load += demands[customer]
                else:
                    current_route.append(0)
                    child1_routes.append(current_route)
                    current_route = [0, customer]
                    current_load = demands[customer]

            current_route.append(0)
            child1_routes.append(current_route)

            new_population.append(child1_routes)
            # Create child 2 similarly but for simiplicity skip here.
            new_population.append(parent2_routes)

        population = new_population


    # Construct heuristics matrix from best solution in final population
    best_routes = population[np.argmin(fitness_scores)] # Use the un-normalized fitnesses to reconstruct best route
    for routes in [best_routes]: # just the best performing agent.
      for route in routes:
          for i in range(len(route) - 1):
              u = route[i]
              v = route[i+1]
              heuristics_matrix[u, v] += 1
    return heuristics_matrix
