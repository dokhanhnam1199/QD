import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm iteratively refines routes by randomly swapping nodes within feasible routes, prioritizing swaps that reduce total route length and maintaining capacity constraints, to generate a heuristic matrix based on edge frequencies in improved routes.}"""

    n = len(demands)
    heuristics_matrix = np.zeros((n, n))
    num_iterations = 500

    # Initialize routes randomly
    routes = []
    unvisited_nodes = list(range(1, n))
    current_route = [0]
    current_load = 0
    while unvisited_nodes:
        node = random.choice(unvisited_nodes)
        if current_load + demands[node] <= capacity:
            current_route.append(node)
            current_load += demands[node]
            unvisited_nodes.remove(node)
        else:
            current_route.append(0)
            routes.append(current_route)
            current_route = [0]
            current_load = 0
    current_route.append(0)
    routes.append(current_route)


    for _ in range(num_iterations):
        # Choose a random route
        route_index = random.randint(0, len(routes) - 1)
        route = routes[route_index]

        # Choose two random nodes within the route (excluding the depot)
        if len(route) > 3:
            index1 = random.randint(1, len(route) - 2)
            index2 = random.randint(1, len(route) - 2)
            if index1 == index2:
                continue
            node1 = route[index1]
            node2 = route[index2]

            # Swap the nodes and check feasibility
            new_route = route[:]
            new_route[index1], new_route[index2] = new_route[index2], new_route[index1]

            #Calculate new load:
            new_load = 0
            valid_new_route = True
            temp_load = 0
            for node_index in range(1,len(new_route)):
              temp_node = new_route[node_index]
              if temp_node != 0:
                temp_load += demands[temp_node]
                if temp_load > capacity:
                  valid_new_route = False
                  break
              else:
                temp_load = 0
            
            if valid_new_route:

                # Calculate the change in distance
                old_distance = distance_matrix[route[index1-1], route[index1]] + distance_matrix[route[index1], route[index1+1]] + distance_matrix[route[index2-1], route[index2]] + distance_matrix[route[index2], route[index2+1]]
                new_distance = distance_matrix[new_route[index1-1], new_route[index1]] + distance_matrix[new_route[index1], new_route[index1+1]] + distance_matrix[new_route[index2-1], new_route[index2]] + distance_matrix[new_route[index2], new_route[index2+1]]

                if new_distance < old_distance:
                   routes[route_index] = new_route

    # Update heuristics matrix based on edges in the routes
    for route in routes:
        for i in range(len(route) - 1):
            node1 = route[i]
            node2 = route[i+1]
            heuristics_matrix[node1, node2] += 1
            heuristics_matrix[node2, node1] += 1

    # Normalize the heuristics matrix
    total_route_edges = np.sum(heuristics_matrix)
    if total_route_edges > 0:
        heuristics_matrix = heuristics_matrix / total_route_edges

    return heuristics_matrix
