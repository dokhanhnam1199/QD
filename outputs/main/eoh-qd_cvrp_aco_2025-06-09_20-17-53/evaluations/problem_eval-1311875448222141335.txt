import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm samples feasible routes by using a score function based on distance, demand, and angle, then aggregates edge frequencies across multiple samples to create a heuristic matrix.}
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    num_samples = 1000

    for _ in range(num_samples):
        # Initialize a route
        current_route = [0]
        current_load = 0
        visited = {0}
        
        while len(visited) < n:
            # Find feasible and unvisited neighbors
            feasible_neighbors = []
            for i in range(1, n):
                if i not in visited and current_load + demands[i] <= capacity:
                    feasible_neighbors.append(i)
            
            # If no feasible neighbors, return to depot
            if not feasible_neighbors:
                current_route.append(0)
                current_load = 0
                continue

            # Choose a neighbor randomly based on a score function
            current_node = current_route[-1]
            scores = []
            for neighbor in feasible_neighbors:
                dist = distance_matrix[current_node][neighbor]
                demand = demands[neighbor]
                
                # Calculate angle between current node, depot, and neighbor
                depot_x, depot_y = coordinates[0]
                current_x, current_y = coordinates[current_node]
                neighbor_x, neighbor_y = coordinates[neighbor]

                angle = np.arctan2(neighbor_y - current_y, neighbor_x - current_x) - np.arctan2(depot_y - current_y, depot_x - current_x)
                angle = np.degrees(angle)
                angle = (angle + 360) % 360  # Ensure angle is between 0 and 360

                # Score function: prioritize closer nodes with smaller demands and angles closer to 0 (towards depot)
                score = (1 / (dist + 1e-6)) + (1 / (demand + 1e-6)) + (1 / (abs(angle - 180) + 1e-6)) # Angle penalizes nodes away from depot
                scores.append(score)

            # Normalize scores to probabilities
            total_score = sum(scores)
            probabilities = [s / total_score for s in scores]

            # Select next node
            next_node = random.choices(feasible_neighbors, weights=probabilities, k=1)[0]
            current_route.append(next_node)
            current_load += demands[next_node]
            visited.add(next_node)
        
        current_route.append(0)  # Return to depot

        # Update heuristics matrix
        for i in range(len(current_route) - 1):
            u = current_route[i]
            v = current_route[i+1]
            heuristics_matrix[u, v] += 1
            heuristics_matrix[v, u] += 1

    # Normalize the heuristics matrix
    heuristics_matrix /= num_samples
    
    return heuristics_matrix
