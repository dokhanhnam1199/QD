import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm iteratively constructs routes using a savings-based approach with stochastic acceptance, favoring edges that result in higher savings while considering capacity constraints.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    num_samples = 1000

    for _ in range(num_samples):
        routes = []
        unvisited = set(range(1, n))

        while unvisited:
            best_savings = -1
            best_i = -1
            best_j = -1
            
            for i in range(1,n):
                if i not in unvisited:
                    continue
                for j in range(1,n):
                    if j not in unvisited:
                        continue
                    if i == j:
                        continue
                    savings = distance_matrix[i, 0] + distance_matrix[0, j] - distance_matrix[i, j]
                    if savings > best_savings:
                        best_savings = savings
                        best_i = i
                        best_j = j
            
            if best_i != -1 and best_j != -1:
                route_i = -1
                route_j = -1
                for idx, route in enumerate(routes):
                    if best_i in route:
                        route_i = idx
                    if best_j in route:
                        route_j = idx

                if route_i == -1 and route_j == -1:
                    if demands[best_i] + demands[best_j] <= capacity:
                        if random.random() < 0.9:
                            routes.append([best_i, best_j])
                            unvisited.remove(best_i)
                            unvisited.remove(best_j)

                elif route_i != -1 and route_j == -1:
                    total_demand = sum([demands[node] for node in routes[route_i]]) + demands[best_j]
                    if total_demand <= capacity:
                         if random.random() < 0.9:
                            routes[route_i].append(best_j)
                            unvisited.remove(best_j)

                elif route_i == -1 and route_j != -1:
                    total_demand = sum([demands[node] for node in routes[route_j]]) + demands[best_i]
                    if total_demand <= capacity:
                        if random.random() < 0.9:
                            routes[route_j].append(best_i)
                            unvisited.remove(best_i)
                                        
                elif route_i != -1 and route_j != -1 and route_i != route_j:
                    merged_route = routes[route_i] + routes[route_j]
                    total_demand = sum([demands[node] for node in merged_route])

                    if total_demand <= capacity:
                         if random.random() < 0.9:
                            routes[route_i] = merged_route
                            del routes[route_j]

        for route in routes:
            route = [0] + route + [0]
            for i in range(len(route) - 1):
                u = route[i]
                v = route[i+1]
                heuristics_matrix[u, v] += 1
                heuristics_matrix[v, u] += 1

    heuristics_matrix /= num_samples
    return heuristics_matrix
