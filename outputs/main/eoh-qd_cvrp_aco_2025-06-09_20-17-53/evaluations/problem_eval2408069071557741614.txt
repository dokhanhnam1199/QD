import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm constructs initial routes greedily, then iteratively improves them by probabilistically swapping nodes between routes based on a cost-benefit analysis and a simulated annealing-like temperature parameter.}"""
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)
    num_iterations = 1000
    temperature = 1.0
    cooling_rate = 0.99

    # 1. Greedy Initial Solution
    routes = []
    unvisited = list(range(1, n))
    while unvisited:
        current_route = [0]
        current_capacity = 0
        while unvisited:
            best_node = -1
            best_cost = float('inf')
            for node in unvisited:
                if current_capacity + demands[node] <= capacity:
                    cost = distance_matrix[current_route[-1]][node]
                    if cost < best_cost:
                        best_cost = cost
                        best_node = node
            if best_node != -1:
                current_route.append(best_node)
                current_capacity += demands[best_node]
                unvisited.remove(best_node)
            else:
                break
        current_route.append(0)
        routes.append(current_route)

    # 2. Iterative Improvement (Simulated Annealing-like)
    for iteration in range(num_iterations):
        # Choose two routes randomly
        if len(routes) < 2:
            continue # Skip if only one route exists

        route_index1, route_index2 = random.sample(range(len(routes)), 2)
        route1 = routes[route_index1]
        route2 = routes[route_index2]

        # Choose two nodes randomly (excluding the depot)
        if len(route1) <= 2 or len(route2) <= 2:
            continue # Skip if route has only depot

        node_index1 = random.randint(1, len(route1) - 2)
        node_index2 = random.randint(1, len(route2) - 2)

        node1 = route1[node_index1]
        node2 = route2[node_index2]

        # Check capacity constraints after swap
        capacity1 = sum(demands[node] for node in route1[1:-1]) - demands[node1] + demands[node2]
        capacity2 = sum(demands[node] for node in route2[1:-1]) - demands[node2] + demands[node1]

        if capacity1 <= capacity and capacity2 <= capacity:
            # Calculate cost change
            cost_change = (distance_matrix[route1[node_index1 - 1]][node2] + distance_matrix[node2][route1[node_index1 + 1]]
                           - distance_matrix[route1[node_index1 - 1]][node1] - distance_matrix[node1][route1[node_index1 + 1]]
                           + distance_matrix[route2[node_index2 - 1]][node1] + distance_matrix[node1][route2[node_index2 + 1]]
                           - distance_matrix[route2[node_index2 - 1]][node2] - distance_matrix[node2][route2[node_index2 + 1]])

            # Accept the swap based on Metropolis criterion
            if cost_change < 0 or random.random() < np.exp(-cost_change / temperature):
                # Perform the swap
                route1[node_index1] = node2
                route2[node_index2] = node1
                routes[route_index1] = route1
                routes[route_index2] = route2

        #Cooling
        temperature *= cooling_rate
    
    # 3. Update Heuristics Matrix
    for route in routes:
        for i in range(len(route) - 1):
            heuristics_matrix[route[i]][route[i+1]] += 1
            heuristics_matrix[route[i+1]][route[i]] += 1

    #Normalize
    total_route_edges = sum(len(route) -1 for route in routes)
    if total_route_edges > 0:
        heuristics_matrix = heuristics_matrix / total_route_edges
    else:
        heuristics_matrix = heuristics_matrix / num_iterations
    return heuristics_matrix
