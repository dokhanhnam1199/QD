import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm iteratively refines a heuristic matrix by favoring edges that connect nodes with similar demand-to-distance ratios, guided by random route sampling and feasibility checks.}
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = np.ones_like(distance_matrix)  # Initialize with ones to avoid division by zero
    num_iterations = 50
    num_samples_per_iteration = 20

    for iteration in range(num_iterations):
        for _ in range(num_samples_per_iteration):
            # Generate a random permutation of customers (excluding the depot)
            customer_indices = np.random.permutation(np.arange(1, n))

            # Construct routes based on the permutation and capacity constraints
            routes = []
            current_route = [0]  # Start at the depot
            current_demand = 0

            for customer in customer_indices:
                if current_demand + demands[customer] <= capacity:
                    current_route.append(customer)
                    current_demand += demands[customer]
                else:
                    current_route.append(0)  # Return to depot
                    routes.append(current_route)
                    current_route = [0, customer]  # Start a new route from depot
                    current_demand = demands[customer]

            current_route.append(0)  # Return to depot at the end of all deliveries
            routes.append(current_route)

            # Calculate the total distance of the routes and check feasibility
            total_distance = 0
            feasible = True
            for route in routes:
                route_distance = 0
                current_demand = 0
                for i in range(len(route) - 1):
                    route_distance += distance_matrix[route[i], route[i + 1]]
                    if route[i + 1] != 0:
                        current_demand += demands[route[i + 1]]

                if current_demand > capacity:
                    feasible = False
                    break

                total_distance += route_distance

            # Update heuristic matrix if the solution is feasible
            if feasible:
                for route in routes:
                    for i in range(len(route) - 1):
                        node1 = route[i]
                        node2 = route[i+1]

                        # Calculate demand-to-distance ratios
                        if node1 != 0:
                            ratio1 = demands[node1] / (distance_matrix[0, node1] if distance_matrix[0, node1] > 0 else 1e-6)  #Avoid division by zero
                        else:
                            ratio1 = 0

                        if node2 != 0:
                            ratio2 = demands[node2] / (distance_matrix[0, node2] if distance_matrix[0, node2] > 0 else 1e-6) #Avoid division by zero
                        else:
                            ratio2 = 0
                        
                        # Favor edges connecting nodes with similar ratios
                        similarity = 1 / (1 + abs(ratio1 - ratio2))
                        heuristics_matrix[node1, node2] += similarity
                        heuristics_matrix[node2, node1] += similarity

    # Normalize the heuristic matrix
    total_counts = np.sum(heuristics_matrix)
    if total_counts > 0:
        heuristics_matrix = heuristics_matrix / total_counts

    return heuristics_matrix
