import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm adaptively biases route generation towards promising edges by iteratively sampling routes, updating edge probabilities based on route feasibility and length, and constructing a heuristic matrix from these probabilities.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros((n, n))
    edge_probabilities = np.ones((n, n)) / (n * n)  # Initialize with uniform probabilities
    num_iterations = 100
    num_samples_per_iteration = 10

    for _ in range(num_iterations):
        for _ in range(num_samples_per_iteration):
            # Sample a route based on current edge probabilities
            route = [0]
            current_node = 0
            unvisited_nodes = set(range(1, n))
            current_capacity = 0

            while unvisited_nodes:
                # Calculate probabilities of moving to each unvisited node
                probabilities = np.array([edge_probabilities[current_node, node] for node in unvisited_nodes])
                probabilities = probabilities / np.sum(probabilities)

                # Choose the next node based on probabilities
                next_node = random.choices(list(unvisited_nodes), weights=probabilities)[0]

                # Check capacity constraint
                if current_capacity + demands[next_node] <= capacity:
                    route.append(next_node)
                    current_capacity += demands[next_node]
                    current_node = next_node
                    unvisited_nodes.remove(next_node)
                else:
                    route.append(0)  # Return to depot
                    current_capacity = 0
                    current_node = 0  # Restart from depot

            route.append(0)  # Return to depot

            # Evaluate route feasibility and length (simplified: just feasibility)
            is_feasible = True
            all_sub_routes_feasible = True
            sub_routes = []
            current_route = [0]
            current_capacity = 0
            for i in range(1, len(route)):
                node = route[i]
                if node != 0 and current_capacity + demands[node] <= capacity:
                    current_route.append(node)
                    current_capacity += demands[node]
                elif node == 0:
                    current_route.append(0)
                    sub_routes.append(current_route)
                    current_route = [0]
                    current_capacity = 0
                else:
                    all_sub_routes_feasible = False
                    is_feasible = False
                    break

            if current_route:
                current_route.append(0)
                sub_routes.append(current_route)

            # Update edge probabilities based on feasibility and length
            if is_feasible:
                for i in range(len(route) - 1):
                    node1 = route[i]
                    node2 = route[i+1]
                    edge_probabilities[node1, node2] *= 1.1  # Increase probability for edges in feasible routes
                    edge_probabilities[node2, node1] *= 1.1
            else:
                 for i in range(len(route) - 1):
                    node1 = route[i]
                    node2 = route[i+1]
                    edge_probabilities[node1, node2] *= 0.9  # Decrease probability for edges in infeasible routes
                    edge_probabilities[node2, node1] *= 0.9


            # Normalize edge probabilities
            edge_probabilities = edge_probabilities / np.sum(edge_probabilities)

    # Construct heuristic matrix from edge probabilities
    heuristics_matrix = edge_probabilities

    return heuristics_matrix
