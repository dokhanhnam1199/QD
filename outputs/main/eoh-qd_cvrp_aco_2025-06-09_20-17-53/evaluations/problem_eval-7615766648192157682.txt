import numpy as np

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm constructs routes using a savings-based approach, then aggregates the 'savings' associated with each edge's inclusion across multiple route constructions to estimate edge desirability.}
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros((n, n))
    num_iterations = 1000

    for _ in range(num_iterations):
        savings = np.zeros((n, n))
        for i in range(1, n):
            for j in range(i + 1, n):
                savings[i, j] = distance_matrix[i, 0] + distance_matrix[0, j] - distance_matrix[i, j]
                savings[j, i] = savings[i, j]

        available_customers = set(range(1, n))
        routes = []
        while available_customers:
            best_saving = -np.inf
            best_i = -1
            best_j = -1

            for i in available_customers:
                for j in available_customers:
                    if i == j:
                        continue
                    if savings[i, j] > best_saving:
                        best_saving = savings[i, j]
                        best_i = i
                        best_j = j

            if best_i != -1:
                route = [0, best_i, best_j, 0]
                route_demand = demands[best_i] + demands[best_j]
                remaining_customers = available_customers - {best_i, best_j}

                insert_pos = 2  # Insert before returning to depot
                while remaining_customers:
                    best_insert_customer = -1
                    best_insert_saving = -np.inf
                    for customer in remaining_customers:
                        potential_demand = route_demand + demands[customer]
                        if potential_demand <= capacity:
                            insert_saving = savings[route[insert_pos-1], customer]
                            if insert_saving > best_insert_saving:
                                best_insert_saving = insert_saving
                                best_insert_customer = customer

                    if best_insert_customer != -1:
                        route.insert(insert_pos, best_insert_customer)
                        route_demand += demands[best_insert_customer]
                        remaining_customers.remove(best_insert_customer)
                        available_customers.remove(best_insert_customer)
                    else:
                        break
                        
                if route_demand <= capacity:
                    routes.append(route)
                    available_customers -= {best_i, best_j}

                    for i in range(len(route) - 1):
                        u = route[i]
                        v = route[i+1]
                        heuristics_matrix[u, v] += 1
                        heuristics_matrix[v, u] += 1

            else:
                # If no more savings can be found start a new route with a random remaining customer
                remaining_customers_list = list(available_customers)
                if remaining_customers_list:
                    customer = np.random.choice(remaining_customers_list)
                    route = [0, customer, 0]
                    routes.append(route)
                    for i in range(len(route) - 1):
                        u = route[i]
                        v = route[i+1]
                        heuristics_matrix[u, v] += 1
                        heuristics_matrix[v, u] += 1
                    available_customers.remove(customer)

    return heuristics_matrix
