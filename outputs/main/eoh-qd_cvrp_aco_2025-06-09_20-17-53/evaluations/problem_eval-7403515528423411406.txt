import numpy as np

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm uses a greedy approach to construct initial routes and then iteratively refines them by considering node insertions and swaps to create a heuristic matrix based on edge frequencies.}
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros((n, n))
    num_iterations = 500

    # Initialize routes using a greedy approach
    routes = []
    unvisited = list(range(1, n))
    current_route = [0]
    current_load = 0

    while unvisited:
        best_customer = -1
        best_distance = float('inf')

        for customer in unvisited:
            if current_load + demands[customer] <= capacity:
                dist = distance_matrix[current_route[-1], customer]
                if dist < best_distance:
                    best_distance = dist
                    best_customer = customer

        if best_customer != -1:
            current_route.append(best_customer)
            current_load += demands[best_customer]
            unvisited.remove(best_customer)
        else:
            current_route.append(0)
            routes.append(current_route)
            current_route = [0]
            current_load = 0
    
    current_route.append(0)
    routes.append(current_route)

    
    # Iterative improvement
    for _ in range(num_iterations):
        # Randomly select a route
        route_index = np.random.randint(len(routes))
        route = routes[route_index]

        # Randomly select a node in the route (excluding depot)
        if len(route) > 2:
            node_index = np.random.randint(1, len(route) - 1)  # Exclude depot
            node_to_move = route[node_index]

            # Remove the node from the route and update the load
            current_load = sum(demands[route[i]] for i in range(1, len(route)-1))
            
            route.pop(node_index)

            # Find the best position to insert the node in another route
            best_route_index = -1
            best_insertion_index = -1
            best_cost_increase = float('inf')

            for r_index in range(len(routes)):
                temp_route = routes[r_index]
                temp_load = sum(demands[temp_route[i]] for i in range(1, len(temp_route)-1))

                for insert_index in range(1, len(temp_route)):
                    if temp_load + demands[node_to_move] <= capacity:
                        
                        cost_increase = distance_matrix[temp_route[insert_index - 1], node_to_move] + \
                                        distance_matrix[node_to_move, temp_route[insert_index]] - \
                                        distance_matrix[temp_route[insert_index - 1], temp_route[insert_index]]

                        if cost_increase < best_cost_increase:
                            best_cost_increase = cost_increase
                            best_route_index = r_index
                            best_insertion_index = insert_index

            # Insert the node in the best position
            if best_route_index != -1:
                routes[best_route_index].insert(best_insertion_index, node_to_move)
            else:
                # No feasible insertion found, revert the change
                route.insert(node_index, node_to_move)

        # Update heuristic matrix based on the edges
        for route in routes:
            for i in range(len(route) - 1):
                u = route[i]
                v = route[i + 1]
                heuristics_matrix[u, v] += 1
                heuristics_matrix[v, u] += 1

    # Normalize the matrix
    heuristics_matrix = heuristics_matrix / (num_iterations * len(routes))

    return heuristics_matrix
