import numpy as np

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm generates initial routes using a nearest neighbor approach with capacity constraints, then iteratively improves routes by swapping nodes between them, and finally constructs a heuristic matrix based on edge frequencies in the improved routes.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros((n, n))
    num_iterations = 100

    # Initial routes using nearest neighbor with capacity constraints
    unvisited = set(range(1, n))
    routes = []
    while unvisited:
        current_route = [0]
        current_load = 0
        current_node = 0
        
        while unvisited:
            nearest_neighbor = -1
            min_dist = float('inf')
            
            for neighbor in unvisited:
                if demands[neighbor] + current_load <= capacity and distance_matrix[current_node, neighbor] < min_dist:
                    min_dist = distance_matrix[current_node, neighbor]
                    nearest_neighbor = neighbor
            
            if nearest_neighbor != -1:
                current_route.append(nearest_neighbor)
                current_load += demands[nearest_neighbor]
                unvisited.remove(nearest_neighbor)
                current_node = nearest_neighbor
            else:
                break  # Current route is full
        
        current_route.append(0)
        routes.append(current_route)
    
    # Iterative improvement via node swapping
    for _ in range(num_iterations):
        # Select two random routes
        if len(routes) < 2:
            break
        route_indices = np.random.choice(len(routes), 2, replace=False)
        route1_index, route2_index = route_indices[0], route_indices[1]
        route1, route2 = routes[route1_index], routes[route2_index]
        
        # Select random nodes to swap (excluding depot)
        node1_index = np.random.choice(range(1, len(route1) - 1))
        node2_index = np.random.choice(range(1, len(route2) - 1))
        node1, node2 = route1[node1_index], route2[node2_index]
        
        # Check if swapping is feasible
        route1_load = sum(demands[node] for node in route1[1:-1])
        route2_load = sum(demands[node] for node in route2[1:-1])
        
        if route1_load - demands[node1] + demands[node2] <= capacity and \
           route2_load - demands[node2] + demands[node1] <= capacity:
            
            # Swap nodes
            route1[node1_index], route2[node2_index] = node2, node1

    # Construct heuristics matrix
    for route in routes:
        for i in range(len(route) - 1):
            u = route[i]
            v = route[i+1]
            heuristics_matrix[u, v] += 1

    return heuristics_matrix
