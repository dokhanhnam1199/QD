import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm uses an adaptive large neighborhood search (ALNS) approach, iteratively destroying and repairing solutions to explore the solution space and build a heuristic matrix based on edge frequencies in the accepted solutions.}"""
    n = len(demands)
    heuristics_matrix = np.zeros((n, n))
    num_iterations = 100
    num_destroy = int(0.2 * n)  # Percentage of nodes to destroy
    
    # Initial solution (random)
    current_solution = list(range(1, n))
    random.shuffle(current_solution)
    current_solution = [0] + current_solution + [0]
    
    def calculate_cost(solution):
        cost = 0
        routes = []
        current_route = [0]
        current_load = 0
        for i in range(1,len(solution)):
            if current_load + demands[solution[i]] <= capacity:
                if solution[i] != 0 : current_route.append(solution[i])
                current_load += demands[solution[i]] if solution[i] != 0 else 0
            else:
                current_route.append(0)
                routes.append(current_route)
                current_route = [0, solution[i]] if solution[i] != 0 else [0]
                current_load = demands[solution[i]] if solution[i] != 0 else 0
        if current_route != [0]:
            current_route.append(0)
            routes.append(current_route)

        total_distance = 0
        for route in routes:
            for i in range(len(route) - 1):
                total_distance += distance_matrix[route[i], route[i+1]]

        return total_distance
    
    
    current_cost = calculate_cost(current_solution)
    best_solution = current_solution[:]
    best_cost = current_cost
    
    for iteration in range(num_iterations):
        # Destroy (remove some nodes)
        nodes_to_remove = random.sample(range(1, n), num_destroy)
        destroyed_solution = [node for node in current_solution if node not in nodes_to_remove and node != 0]
        
        # Repair (re-insert nodes)
        removed_nodes = sorted(nodes_to_remove)
        
        new_solution = destroyed_solution[:]
        
        for node in removed_nodes:
            best_insertion_index = -1
            best_insertion_cost = float('inf')
            for i in range(1, len(new_solution)):
                temp_solution = new_solution[:i] + [node] + new_solution[i:]
                cost = calculate_cost(temp_solution)
                if cost < best_insertion_cost:
                    best_insertion_cost = cost
                    best_insertion_index = i
            new_solution = new_solution[:best_insertion_index] + [node] + new_solution[best_insertion_index:]

        new_solution = [0] + new_solution + [0]  #Ensure starting and ending at the depot
        new_cost = calculate_cost(new_solution)

        # Acceptance criterion (e.g., Simulated Annealing)
        temperature = 100.0 / (iteration + 1)
        delta = new_cost - current_cost
        if delta < 0 or random.random() < np.exp(-delta / temperature):
            current_solution = new_solution[:]
            current_cost = new_cost
            
            if current_cost < best_cost:
                best_solution = current_solution[:]
                best_cost = current_cost
                
        #Update heuristics matrix based on best solution so far
        routes = []
        current_route = [0]
        current_load = 0

        for i in range(1, len(best_solution)):
            if best_solution[i] != 0:
                if current_load + demands[best_solution[i]] <= capacity:
                    current_route.append(best_solution[i])
                    current_load += demands[best_solution[i]]
                else:
                    current_route.append(0)
                    routes.append(current_route)
                    current_route = [0, best_solution[i]]
                    current_load = demands[best_solution[i]]
            else:
                current_route.append(0)
                routes.append(current_route)
                current_route = [0]
                current_load = 0
        if current_route != [0]:
            current_route.append(0)
            routes.append(current_route)

        for route in routes:
            for i in range(len(route) - 1):
                heuristics_matrix[route[i], route[i+1]] += 1
                heuristics_matrix[route[i+1], route[i]] += 1
            
    # Normalize heuristics_matrix
    total_edges = np.sum(heuristics_matrix)
    if total_edges > 0:
      heuristics_matrix = heuristics_matrix / total_edges
    
    return heuristics_matrix
