import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm constructs a nearest neighbor solution, then iteratively perturbs it by swapping nodes between routes and accepting the changes if they improve the overall cost, building a heuristic matrix based on the frequency of edges in these locally optimal solutions.}
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros((n, n))
    num_iterations = 1000

    # Initialize a random solution
    def initial_solution():
        route = list(range(1, n))
        random.shuffle(route)
        
        sub_routes = []
        current_route = [0]
        current_capacity = 0
        
        for node in route:
            if current_capacity + demands[node] <= capacity:
                current_route.append(node)
                current_capacity += demands[node]
            else:
                current_route.append(0)
                sub_routes.append(current_route)
                current_route = [0, node]
                current_capacity = demands[node]
        
        current_route.append(0)
        sub_routes.append(current_route)
        return sub_routes
    
    def calculate_cost(solution):
        total_cost = 0
        for route in solution:
            for i in range(len(route) - 1):
                total_cost += distance_matrix[route[i], route[i+1]]
        return total_cost

    def apply_local_search(initial_solution, iterations=100):
        best_solution = initial_solution
        best_cost = calculate_cost(best_solution)
        
        for _ in range(iterations):
            # Perturb the solution by swapping nodes between routes
            new_solution = [route[:] for route in best_solution]  # Deep copy
            
            if len(new_solution) > 1:
                route1_idx = random.randint(0, len(new_solution) - 1)
                route2_idx = random.randint(0, len(new_solution) - 1)
                
                if len(new_solution[route1_idx]) > 2 and len(new_solution[route2_idx]) > 2 :
                    node1_idx = random.randint(1, len(new_solution[route1_idx]) - 2)
                    node2_idx = random.randint(1, len(new_solution[route2_idx]) - 2)
                    
                    node1 = new_solution[route1_idx][node1_idx]
                    node2 = new_solution[route2_idx][node2_idx]
                    
                    #Check capacity constraints before swap
                    temp_route1 = new_solution[route1_idx][:]
                    temp_route2 = new_solution[route2_idx][:]
                    
                    temp_route1[node1_idx] = node2
                    temp_route2[node2_idx] = node1
                    
                    capacity_route1 = sum([demands[n] for n in temp_route1[1:-1]])
                    capacity_route2 = sum([demands[n] for n in temp_route2[1:-1]])
                    
                    if capacity_route1 <= capacity and capacity_route2 <= capacity:
                        new_solution[route1_idx][node1_idx] = node2
                        new_solution[route2_idx][node2_idx] = node1
            
            new_cost = calculate_cost(new_solution)
            
            if new_cost < best_cost:
                best_solution = new_solution
                best_cost = new_cost
        
        return best_solution

    for _ in range(num_iterations):
        initial = initial_solution()
        optimized_solution = apply_local_search(initial)

        # Update heuristic matrix based on the optimized solution
        for sub_route in optimized_solution:
            for i in range(len(sub_route) - 1):
                node1 = sub_route[i]
                node2 = sub_route[i+1]
                heuristics_matrix[node1, node2] += 1
                heuristics_matrix[node2, node1] += 1

    heuristics_matrix = heuristics_matrix / num_iterations
    return heuristics_matrix
