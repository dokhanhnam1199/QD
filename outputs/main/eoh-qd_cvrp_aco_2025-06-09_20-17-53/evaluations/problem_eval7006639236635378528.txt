import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm iteratively refines a heuristic matrix by favoring edges that connect nodes with remaining demand to nodes that can accommodate that demand, weighted by the inverse of the distance between them.}"""

    n = len(demands)
    heuristics_matrix = np.ones_like(distance_matrix) # Initialize with ones to avoid division by zero
    alpha = 0.1  # Learning rate
    iterations = 100

    for _ in range(iterations):
        remaining_demands = demands.copy()
        current_node = 0
        
        for _ in range(n - 1):
            # Probabilistically select the next node based on heuristic values and remaining demand
            probabilities = np.zeros(n)
            for next_node in range(1, n):
                if remaining_demands[next_node] > 0:
                    demand_compatibility = min(1, remaining_demands[next_node] / capacity)  # Scale factor based on demand
                    probabilities[next_node] = heuristics_matrix[current_node, next_node] * (1 / distance_matrix[current_node, next_node] + 1e-6) * demand_compatibility

            probabilities /= np.sum(probabilities) + 1e-6 # Normalize, handling zero division

            next_node = np.random.choice(n, p=probabilities)
            if next_node == 0 or remaining_demands[next_node] <=0 :
                continue
            # Update heuristic matrix based on the selected edge
            heuristics_matrix[current_node, next_node] += alpha
            heuristics_matrix[next_node, current_node] += alpha
            

            #Reduce remaining demand
            remaining_demands[next_node] = 0 
            current_node = next_node

    return heuristics_matrix
