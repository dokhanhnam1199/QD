import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm iteratively refines routes by swapping nodes between routes to improve feasibility and cost, using the frequency of edges in these refined routes to build a heuristic matrix.}"""

    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)
    num_iterations = 500
    num_routes = 10

    # Initialize routes randomly
    all_routes = []
    for _ in range(num_routes):
        customer_nodes = list(range(1, n))
        random.shuffle(customer_nodes)
        routes = []
        current_route = [0]
        current_load = 0
        for node in customer_nodes:
            if current_load + demands[node] <= capacity:
                current_route.append(node)
                current_load += demands[node]
            else:
                current_route.append(0)
                routes.append(current_route)
                current_route = [0, node]
                current_load = demands[node]
        current_route.append(0)
        routes.append(current_route)
        all_routes.append(routes)

    # Iterative refinement
    for _ in range(num_iterations):
        for routes in all_routes:
            # Select two routes randomly
            if len(routes) > 1:
                route_idx1, route_idx2 = random.sample(range(len(routes)), 2)
                route1 = routes[route_idx1]
                route2 = routes[route_idx2]

                if len(route1) > 2 and len(route2) > 2:
                    # Select two nodes randomly from the routes (excluding depot)
                    node_idx1 = random.randint(1, len(route1) - 2)
                    node_idx2 = random.randint(1, len(route2) - 2)
                    node1 = route1[node_idx1]
                    node2 = route2[node_idx2]

                    # Swap the nodes
                    route1[node_idx1], route2[node_idx2] = node2, node1

                    # Check capacity constraints and adjust routes if needed
                    route1_load = sum(demands[node] for node in route1[1:-1])
                    route2_load = sum(demands[node] for node in route2[1:-1])

                    if route1_load > capacity or route2_load > capacity:
                        route1[node_idx1], route2[node_idx2] = node1, node2  # Revert the swap


    # Update heuristics matrix
    for routes in all_routes:
        for route in routes:
            for i in range(len(route) - 1):
                node1 = route[i]
                node2 = route[i+1]
                heuristics_matrix[node1, node2] += 1
                heuristics_matrix[node2, node1] += 1

    return heuristics_matrix
