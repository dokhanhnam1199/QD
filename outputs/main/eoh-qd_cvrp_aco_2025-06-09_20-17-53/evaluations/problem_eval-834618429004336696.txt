import numpy as np

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm generates multiple random routes, evaluates their feasibility and cost, and then assigns heuristic values to each edge based on how frequently it appears in good solutions, emphasizing routes with fewer vehicles used.}
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros((n, n))
    num_samples = 1000

    for _ in range(num_samples):
        # Generate a random permutation of customers (excluding the depot)
        customer_indices = np.arange(1, n)
        np.random.shuffle(customer_indices)

        # Construct routes based on capacity constraints
        routes = []
        current_route = [0]
        current_demand = 0

        for customer in customer_indices:
            if current_demand + demands[customer] <= capacity:
                current_route.append(customer)
                current_demand += demands[customer]
            else:
                current_route.append(0)
                routes.append(current_route)
                current_route = [0, customer]
                current_demand = demands[customer]
        
        current_route.append(0)
        routes.append(current_route)
        
        # Calculate the total distance of the routes
        total_distance = 0
        for route in routes:
            for i in range(len(route) - 1):
                total_distance += distance_matrix[route[i], route[i+1]]
        
        # Update heuristic matrix based on route quality
        if total_distance > 0: # Avoid zero division issue
            quality = (1 / total_distance) * (1 / len(routes))  # Emphasize fewer vehicles
        else:
            quality = 0 #Assign default quality
        
        for route in routes:
            for i in range(len(route) - 1):
                heuristics_matrix[route[i], route[i+1]] += quality
                
    return heuristics_matrix
