import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm uses an ant colony optimization (ACO) approach to probabilistically construct routes and updates pheromone trails based on route quality, thereby creating a heuristic matrix that represents the desirability of each edge.}
    """
    n = len(demands)
    pheromone_matrix = np.ones_like(distance_matrix)
    alpha = 1  # Pheromone influence
    beta = 2   # Distance influence
    rho = 0.1  # Evaporation rate
    Q = 100    # Pheromone deposit constant
    num_ants = 50
    num_iterations = 100
    heuristics_matrix = np.zeros_like(distance_matrix)

    for iteration in range(num_iterations):
        ant_routes = []
        ant_costs = []

        for ant in range(num_ants):
            unvisited = list(range(1, n))
            current_route = [0]
            current_capacity = capacity
            route = []

            while unvisited:
                probabilities = []
                for node in unvisited:
                    if demands[node] <= current_capacity:
                        pheromone = pheromone_matrix[current_route[-1]][node]
                        distance = distance_matrix[current_route[-1]][node]
                        probabilities.append((pheromone**alpha) / (distance**beta))
                    else:
                        probabilities.append(0)  # Cannot visit due to capacity

                if sum(probabilities) == 0:
                    current_route.append(0)
                    route.append(current_route)
                    current_route = [0]
                    current_capacity = capacity
                    probabilities = []
                    for node in unvisited:
                        if demands[node] <= current_capacity:
                            pheromone = pheromone_matrix[current_route[-1]][node]
                            distance = distance_matrix[current_route[-1]][node]
                            probabilities.append((pheromone**alpha) / (distance**beta))
                        else:
                             probabilities.append(0)
                if sum(probabilities) == 0: #all unvisited nodes are too large for current capacity
                    next_node = random.choice(unvisited) #random choice
                    current_route.append(0)
                    route.append(current_route)
                    current_route = [0, next_node]
                    current_capacity = capacity - demands[next_node]
                    unvisited.remove(next_node)

                else:
                    probabilities = np.array(probabilities) / sum(probabilities)
                    next_node = np.random.choice(unvisited, p=probabilities)
                    if demands[next_node] <= current_capacity:
                        current_route.append(next_node)
                        current_capacity -= demands[next_node]
                        unvisited.remove(next_node)
                    else:
                        current_route.append(0)
                        route.append(current_route)
                        current_route = [0, next_node]
                        current_capacity = capacity - demands[next_node]
                        unvisited.remove(next_node)


            current_route.append(0)
            route.append(current_route)
            ant_routes.append(route)

            cost = 0
            for r in route:
                for i in range(len(r) - 1):
                    cost += distance_matrix[r[i]][r[i+1]]
            ant_costs.append(cost)

        # Update pheromone trails
        delta_pheromone = np.zeros_like(distance_matrix)
        for ant in range(num_ants):
            route = ant_routes[ant]
            cost = ant_costs[ant]
            for r in route:
                for i in range(len(r) - 1):
                    delta_pheromone[r[i]][r[i+1]] += Q / cost
                    delta_pheromone[r[i+1]][r[i]] += Q / cost

        pheromone_matrix = (1 - rho) * pheromone_matrix + delta_pheromone

    return heuristics_matrix
