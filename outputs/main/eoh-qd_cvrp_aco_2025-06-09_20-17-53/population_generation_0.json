[
     {
          "algorithm": "This algorithm iteratively samples feasible routes by randomly adding nodes based on distance and demand, then aggregates edge frequencies across multiple samples to create a heuristic matrix.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    num_samples = 1000\n\n    for _ in range(num_samples):\n        # Initialize a route\n        current_route = [0]\n        current_load = 0\n        visited = {0",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm iteratively samples feasible routes by randomly adding nodes based on distance and demand, then aggregates edge frequencies across multiple samples to create a heuristic matrix.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    num_samples = 1000\n\n    for _ in range(num_samples):\n        # Initialize a route\n        current_route = [0]\n        current_load = 0\n        visited = {0}\n        \n        while len(visited) < n:\n            # Find feasible and unvisited neighbors\n            feasible_neighbors = []\n            for i in range(1, n):\n                if i not in visited and current_load + demands[i] <= capacity:\n                    feasible_neighbors.append(i)\n            \n            # If no feasible neighbors, return to depot\n            if not feasible_neighbors:\n                current_route.append(0)\n                current_load = 0\n                continue\n\n            # Choose a neighbor randomly based on distance\n            distances = [distance_matrix[current_route[-1]][i] for i in feasible_neighbors]\n            probabilities = [1 / d if d > 0 else 1 for d in distances]  # Inverse distance\n            total_prob = sum(probabilities)\n            probabilities = [p / total_prob for p in probabilities]\n\n            next_node = random.choices(feasible_neighbors, weights=probabilities, k=1)[0]\n            current_route.append(next_node)\n            current_load += demands[next_node]\n            visited.add(next_node)\n        \n        current_route.append(0)  # Return to depot\n\n        # Update heuristics matrix\n        for i in range(len(current_route) - 1):\n            u = current_route[i]\n            v = current_route[i+1]\n            heuristics_matrix[u, v] += 1\n            heuristics_matrix[v, u] += 1\n\n    # Normalize the heuristics matrix\n    heuristics_matrix /= num_samples\n    \n    return heuristics_matrix",
          "objective": 26.07631,
          "other_inf": null,
          "SLOC": 33.0,
          "cyclomatic_complexity": 12.0,
          "halstead": 230.0
     },
     {
          "algorithm": "This algorithm samples multiple random routes, evaluates their feasibility and cost, and then uses the frequency with which each edge appears in feasible, low-cost routes to construct a heuristic matrix.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm samples multiple random routes, evaluates their feasibility and cost, and then uses the frequency with which each edge appears in feasible, low-cost routes to construct a heuristic matrix.}\n    \"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    num_samples = 1000  # Number of random routes to sample\n    top_k = 10  # Consider top k best routes\n\n    feasible_routes = []\n\n    for _ in range(num_samples):\n        # Generate a random route\n        route = list(range(1, n))\n        random.shuffle(route)\n        \n        # Split route into feasible vehicle routes\n        vehicle_routes = []\n        current_route = [0]\n        current_load = 0\n        for node in route:\n            if current_load + demands[node] <= capacity:\n                current_route.append(node)\n                current_load += demands[node]\n            else:\n                current_route.append(0)\n                vehicle_routes.append(current_route)\n                current_route = [0, node]\n                current_load = demands[node]\n        \n        current_route.append(0)\n        vehicle_routes.append(current_route)\n\n        # Calculate total distance of route\n        total_distance = 0\n        for vehicle_route in vehicle_routes:\n            for i in range(len(vehicle_route) - 1):\n                total_distance += distance_matrix[vehicle_route[i], vehicle_route[i+1]]\n        \n        feasible_routes.append((vehicle_routes, total_distance))\n\n    # Sort feasible routes by distance\n    feasible_routes.sort(key=lambda x: x[1])\n\n    # Update heuristic matrix based on top k routes\n    for k in range(min(top_k, len(feasible_routes))):\n        vehicle_routes, _ = feasible_routes[k]\n        for vehicle_route in vehicle_routes:\n            for i in range(len(vehicle_route) - 1):\n                node1 = vehicle_route[i]\n                node2 = vehicle_route[i+1]\n                heuristics_matrix[node1, node2] += 1\n                heuristics_matrix[node2, node1] += 1\n\n    return heuristics_matrix",
          "objective": 26.79737,
          "other_inf": null,
          "SLOC": 32.0,
          "cyclomatic_complexity": 8.0,
          "halstead": 125.09775004326937
     },
     {
          "algorithm": "This algorithm generates a set of random routes satisfying capacity constraints, evaluates the routes, and uses the frequency of edges appearing in good routes to create a heuristic matrix.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm generates a set of random routes satisfying capacity constraints, evaluates the routes, and uses the frequency of edges appearing in good routes to create a heuristic matrix.}\n    \"\"\"\n    n = len(demands)\n    num_samples = 1000\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    route_costs = []\n    routes = []\n\n    for _ in range(num_samples):\n        # Generate a random route\n        unvisited = list(range(1, n))\n        current_route = [0]\n        current_capacity = capacity\n        route = []\n        while unvisited:\n            next_node = random.choice(unvisited)\n            if demands[next_node] <= current_capacity:\n                current_route.append(next_node)\n                current_capacity -= demands[next_node]\n                unvisited.remove(next_node)\n            else:\n                current_route.append(0)\n                route.append(current_route)\n                current_route = [0, next_node]\n                current_capacity = capacity - demands[next_node]\n                unvisited.remove(next_node)\n        current_route.append(0)\n        route.append(current_route)\n\n        # Calculate the cost of the route\n        cost = 0\n        for r in route:\n            for i in range(len(r) - 1):\n                cost += distance_matrix[r[i]][r[i+1]]\n        \n        route_costs.append(cost)\n        routes.append(route)\n\n    # Normalize route costs (lower is better)\n    normalized_costs = np.array(route_costs)\n    \n    # Calculate the median route cost\n    median_cost = np.median(normalized_costs)\n    \n    # Identify good routes (those with cost <= median)\n    good_route_indices = np.where(normalized_costs <= median_cost)[0]\n    \n    # Update heuristics matrix based on good routes\n    for index in good_route_indices:\n        route = routes[index]\n        for r in route:\n             for i in range(len(r) - 1):\n                heuristics_matrix[r[i]][r[i+1]] += 1\n                heuristics_matrix[r[i+1]][r[i]] += 1  # Symmetry\n\n    return heuristics_matrix",
          "objective": 28.61594,
          "other_inf": null,
          "SLOC": 32.0,
          "cyclomatic_complexity": 8.0,
          "halstead": 125.09775004326937
     },
     {
          "algorithm": "This algorithm samples a diverse set of random routes, evaluates their feasibility based on capacity constraints, and then uses the frequency with which each edge appears in feasible routes to create a heuristic matrix.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"{This algorithm samples a diverse set of random routes, evaluates their feasibility based on capacity constraints, and then uses the frequency with which each edge appears in feasible routes to create a heuristic matrix.}\"\"\"\n\n    n = len(demands)\n    heuristics_matrix = np.zeros((n, n))\n    num_samples = 1000  # Number of random route samples\n\n    for _ in range(num_samples):\n        # Generate a random permutation of customer nodes (excluding the depot)\n        customer_nodes = list(range(1, n))\n        random.shuffle(customer_nodes)\n\n        # Build routes based on capacity constraints\n        routes = []\n        current_route = [0]  # Start at the depot\n        current_load = 0\n\n        for node in customer_nodes:\n            if current_load + demands[node] <= capacity:\n                current_route.append(node)\n                current_load += demands[node]\n            else:\n                current_route.append(0)  # Return to depot\n                routes.append(current_route)\n                current_route = [0, node]  # Start a new route from depot\n                current_load = demands[node]\n\n        current_route.append(0) # Return to depot from the last node\n        routes.append(current_route)\n\n        # Update heuristics matrix based on edges in the routes\n        for route in routes:\n            for i in range(len(route) - 1):\n                node1 = route[i]\n                node2 = route[i+1]\n                heuristics_matrix[node1, node2] += 1\n                heuristics_matrix[node2, node1] += 1  # Assuming symmetric distance matrix\n\n    # Normalize the heuristics matrix (optional, but can be helpful)\n    total_route_edges = np.sum(heuristics_matrix)\n    if total_route_edges > 0:\n      heuristics_matrix = heuristics_matrix / total_route_edges\n\n    return heuristics_matrix",
          "objective": 29.41706,
          "other_inf": null,
          "SLOC": 32.0,
          "cyclomatic_complexity": 8.0,
          "halstead": 125.09775004326937
     },
     {
          "algorithm": "This algorithm samples a set of random routes, evaluates their feasibility and cost, and uses this information to construct a heuristic matrix favoring edges appearing in better routes.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm samples a set of random routes, evaluates their feasibility and cost, and uses this information to construct a heuristic matrix favoring edges appearing in better routes.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    num_samples = 1000\n    heuristics_matrix = np.zeros((n, n))\n\n    for _ in range(num_samples):\n        # Generate a random permutation of customers (excluding the depot)\n        customer_indices = np.arange(1, n)\n        np.random.shuffle(customer_indices)\n\n        # Construct routes based on the permutation\n        routes = []\n        current_route = [0]  # Start at the depot\n        current_demand = 0\n\n        for customer in customer_indices:\n            if current_demand + demands[customer] <= capacity:\n                current_route.append(customer)\n                current_demand += demands[customer]\n            else:\n                current_route.append(0)  # Return to depot\n                routes.append(current_route)\n                current_route = [0, customer]  # Start a new route\n                current_demand = demands[customer]\n\n        current_route.append(0)  # Return to depot\n        routes.append(current_route)\n\n        # Calculate the total distance of the routes\n        total_distance = 0\n        for route in routes:\n            for i in range(len(route) - 1):\n                total_distance += distance_matrix[route[i], route[i+1]]\n\n        # Update the heuristics matrix based on the quality of the routes\n        if total_distance > 0:  # Avoid division by zero if distance is zero\n            for route in routes:\n                for i in range(len(route) - 1):\n                    node1 = route[i]\n                    node2 = route[i+1]\n                    heuristics_matrix[node1, node2] += 1 / total_distance\n                    heuristics_matrix[node2, node1] += 1 / total_distance # Account for undirected edges\n\n    return heuristics_matrix",
          "objective": 29.4257,
          "other_inf": null,
          "SLOC": 32.0,
          "cyclomatic_complexity": 8.0,
          "halstead": 125.09775004326937
     },
     {
          "algorithm": "This algorithm samples a large number of random routes, evaluates their feasibility with respect to capacity constraints, and then constructs a heuristic matrix based on the frequency with which each edge appears in feasible routes.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm samples a large number of random routes, evaluates their feasibility with respect to capacity constraints, and then constructs a heuristic matrix based on the frequency with which each edge appears in feasible routes.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros((n, n))\n    num_samples = 1000\n\n    for _ in range(num_samples):\n        # Generate a random permutation of customers (excluding depot)\n        customer_indices = np.random.permutation(range(1, n))\n        \n        # Construct routes based on capacity\n        routes = []\n        current_route = [0]\n        current_load = 0\n        \n        for customer in customer_indices:\n            if current_load + demands[customer] <= capacity:\n                current_route.append(customer)\n                current_load += demands[customer]\n            else:\n                current_route.append(0)\n                routes.append(current_route)\n                current_route = [0, customer]\n                current_load = demands[customer]\n        \n        current_route.append(0)\n        routes.append(current_route)\n\n        # Update heuristics matrix based on the edges in feasible routes\n        for route in routes:\n            for i in range(len(route) - 1):\n                u = route[i]\n                v = route[i+1]\n                heuristics_matrix[u, v] += 1\n                heuristics_matrix[v, u] += 1\n\n    # Normalize the matrix\n    heuristics_matrix = heuristics_matrix / num_samples\n\n    return heuristics_matrix",
          "objective": 29.6458,
          "other_inf": null,
          "SLOC": 32.0,
          "cyclomatic_complexity": 8.0,
          "halstead": 125.09775004326937
     },
     {
          "algorithm": "This algorithm samples many random routes, evaluates their feasibility and cost, and uses the frequency of each edge appearing in feasible, low-cost routes to construct a heuristic matrix.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm samples many random routes, evaluates their feasibility and cost, and uses the frequency of each edge appearing in feasible, low-cost routes to construct a heuristic matrix.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    num_samples = 1000\n\n    for _ in range(num_samples):\n        # Generate a random permutation of customers (excluding the depot)\n        customer_indices = np.random.permutation(np.arange(1, n))\n        \n        # Construct routes based on the permutation and capacity constraints\n        routes = []\n        current_route = [0]  # Start at the depot\n        current_demand = 0\n        \n        for customer in customer_indices:\n            if current_demand + demands[customer] <= capacity:\n                current_route.append(customer)\n                current_demand += demands[customer]\n            else:\n                current_route.append(0)  # Return to depot\n                routes.append(current_route)\n                current_route = [0, customer]  # Start a new route from depot\n                current_demand = demands[customer]\n        \n        current_route.append(0) # Return to depot at the end of all deliveries\n        routes.append(current_route)\n\n        # Calculate the total distance of the routes\n        total_distance = 0\n        feasible = True\n        for route in routes:\n            route_distance = 0\n            current_demand = 0\n            for i in range(len(route) - 1):\n                route_distance += distance_matrix[route[i], route[i+1]]\n                if route[i+1] != 0:\n                    current_demand += demands[route[i+1]]\n\n            if current_demand > capacity:\n                feasible = False\n                break\n\n            total_distance += route_distance\n        \n        # Update the heuristic matrix if the solution is feasible\n        if feasible:\n            for route in routes:\n                for i in range(len(route) - 1):\n                    heuristics_matrix[route[i], route[i+1]] += 1\n                    heuristics_matrix[route[i+1], route[i]] += 1  # Symmetric\n\n    # Normalize the heuristic matrix\n    total_counts = np.sum(heuristics_matrix)\n    if total_counts > 0:\n        heuristics_matrix = heuristics_matrix / total_counts\n\n    return heuristics_matrix",
          "objective": 29.6529,
          "other_inf": null,
          "SLOC": 32.0,
          "cyclomatic_complexity": 8.0,
          "halstead": 125.09775004326937
     },
     {
          "algorithm": "This algorithm estimates edge importance by sampling random routes, evaluating their feasibility and cost, and then averaging the edge frequencies observed in feasible and low-cost routes.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"{This algorithm estimates edge importance by sampling random routes, evaluating their feasibility and cost, and then averaging the edge frequencies observed in feasible and low-cost routes.}\"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    num_samples = 1000\n\n    for _ in range(num_samples):\n        # Generate a random permutation of customers (excluding the depot)\n        customer_indices = list(range(1, n))\n        random.shuffle(customer_indices)\n\n        # Build routes based on capacity constraints\n        routes = []\n        current_route = [0]  # Start at the depot\n        current_capacity = 0\n\n        for customer in customer_indices:\n            if current_capacity + demands[customer] <= capacity:\n                current_route.append(customer)\n                current_capacity += demands[customer]\n            else:\n                current_route.append(0)  # Return to depot\n                routes.append(current_route)\n                current_route = [0, customer]  # Start new route at depot\n                current_capacity = demands[customer]\n\n        current_route.append(0) # Close the final route\n        routes.append(current_route)\n        \n        \n        # Calculate total distance of routes\n        total_distance = 0\n        for route in routes:\n            for i in range(len(route) - 1):\n                total_distance += distance_matrix[route[i]][route[i+1]]\n        \n\n        # Update heuristics matrix if route is feasible (always in this version)\n        for route in routes:\n            for i in range(len(route) - 1):\n                heuristics_matrix[route[i]][route[i+1]] += 1\n                heuristics_matrix[route[i+1]][route[i]] += 1  # Assuming symmetry\n    \n    #Normalize the heuristics matrix\n    heuristics_matrix = heuristics_matrix / num_samples\n\n    return heuristics_matrix",
          "objective": 29.8383,
          "other_inf": null,
          "SLOC": 33.0,
          "cyclomatic_complexity": 12.0,
          "halstead": 230.0
     },
     {
          "algorithm": "This algorithm uses stochastic solution sampling to estimate edge importance, \n    constructing many random feasible routes and aggregating edge usage frequencies to create a heuristic matrix.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm uses stochastic solution sampling to estimate edge importance, \n    constructing many random feasible routes and aggregating edge usage frequencies to create a heuristic matrix.}\n    \"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    num_samples = 1000\n\n    for _ in range(num_samples):\n        unvisited = set(range(1, n))\n        routes = []\n        while unvisited:\n            current_route = []\n            current_capacity = 0\n            current_node = 0 \n            \n            while unvisited:\n                \n                feasible_nodes = [node for node in unvisited if current_capacity + demands[node] <= capacity]\n\n                if not feasible_nodes:\n                    break\n\n                next_node = random.choice(feasible_nodes)\n                current_route.append(next_node)\n                current_capacity += demands[next_node]\n                unvisited.remove(next_node)\n            \n            routes.append(current_route)\n        \n        for route in routes:\n            current_node = 0\n            for next_node in route:\n                heuristics_matrix[current_node, next_node] += 1\n                heuristics_matrix[next_node, current_node] += 1\n                current_node = next_node\n            heuristics_matrix[current_node, 0] += 1\n            heuristics_matrix[0, current_node] += 1\n\n    return heuristics_matrix",
          "objective": 29.85688,
          "other_inf": null,
          "SLOC": 32.0,
          "cyclomatic_complexity": 8.0,
          "halstead": 125.09775004326937
     },
     {
          "algorithm": "This algorithm samples a set of random routes, evaluates their feasibility based on capacity constraints, and then calculates a heuristic matrix that reflects how frequently each edge appears in feasible routes.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm samples a set of random routes, evaluates their feasibility based on capacity constraints, and then calculates a heuristic matrix that reflects how frequently each edge appears in feasible routes.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros((n, n))\n    num_samples = 1000\n\n    for _ in range(num_samples):\n        route = list(range(1, n))\n        np.random.shuffle(route)\n        \n        current_route = [0]\n        current_demand = 0\n        feasible = True\n        all_routes = []\n\n        for node in route:\n            if current_demand + demands[node] <= capacity:\n                current_route.append(node)\n                current_demand += demands[node]\n            else:\n                current_route.append(0)\n                all_routes.append(current_route)\n                current_route = [0, node]\n                current_demand = demands[node]\n                if demands[node] > capacity:\n                    feasible = False\n                    break\n        current_route.append(0)\n        all_routes.append(current_route)\n            \n        if feasible:\n            for route in all_routes:\n                for i in range(len(route) - 1):\n                    heuristics_matrix[route[i], route[i+1]] += 1\n                    heuristics_matrix[route[i+1], route[i]] += 1\n    \n    heuristics_matrix = heuristics_matrix / num_samples\n    return heuristics_matrix",
          "objective": 29.8875,
          "other_inf": null,
          "SLOC": 32.0,
          "cyclomatic_complexity": 8.0,
          "halstead": 125.09775004326937
     },
     {
          "algorithm": "This algorithm generates multiple random routes, evaluates their feasibility and cost, and then assigns heuristic values to each edge based on how frequently it appears in good solutions.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm generates multiple random routes, evaluates their feasibility and cost, and then assigns heuristic values to each edge based on how frequently it appears in good solutions.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros((n, n))\n    num_samples = 1000\n\n    for _ in range(num_samples):\n        # Generate a random permutation of customers (excluding the depot)\n        customer_indices = np.arange(1, n)\n        np.random.shuffle(customer_indices)\n\n        # Construct routes based on capacity constraints\n        routes = []\n        current_route = [0]\n        current_demand = 0\n\n        for customer in customer_indices:\n            if current_demand + demands[customer] <= capacity:\n                current_route.append(customer)\n                current_demand += demands[customer]\n            else:\n                current_route.append(0)\n                routes.append(current_route)\n                current_route = [0, customer]\n                current_demand = demands[customer]\n        \n        current_route.append(0)\n        routes.append(current_route)\n        \n        # Calculate the total distance of the routes\n        total_distance = 0\n        for route in routes:\n            for i in range(len(route) - 1):\n                total_distance += distance_matrix[route[i], route[i+1]]\n        \n        # Update heuristic matrix based on route quality\n        if total_distance > 0: # Avoid zero division issue\n            quality = 1 / total_distance\n        else:\n            quality = 0 #Assign default quality\n        \n        for route in routes:\n            for i in range(len(route) - 1):\n                heuristics_matrix[route[i], route[i+1]] += quality\n                \n    return heuristics_matrix",
          "objective": 29.93651,
          "other_inf": null,
          "SLOC": 33.0,
          "cyclomatic_complexity": 12.0,
          "halstead": 230.0
     },
     {
          "algorithm": "This algorithm samples many random routes, evaluates their feasibility based on capacity constraints, \n    and then aggregates the edge frequencies across feasible routes to create a heuristic matrix favoring edges \n    that appear more often in good solutions.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm samples many random routes, evaluates their feasibility based on capacity constraints, \n    and then aggregates the edge frequencies across feasible routes to create a heuristic matrix favoring edges \n    that appear more often in good solutions.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros((n, n))\n    num_samples = 1000  # Number of random routes to sample\n\n    for _ in range(num_samples):\n        route = list(range(1, n))\n        random.shuffle(route)  # Randomly shuffle customer nodes\n        \n        # Split route into feasible sub-routes\n        sub_routes = []\n        current_route = [0]  # Start with the depot\n        current_capacity = 0\n        \n        for node in route:\n            if current_capacity + demands[node] <= capacity:\n                current_route.append(node)\n                current_capacity += demands[node]\n            else:\n                current_route.append(0)  # Return to depot\n                sub_routes.append(current_route)\n                current_route = [0, node]  # Start new route from depot\n                current_capacity = demands[node]\n        \n        current_route.append(0)  # Final return to depot\n        sub_routes.append(current_route)\n        \n        # Update heuristic matrix for edges in feasible sub-routes\n        for sub_route in sub_routes:\n            for i in range(len(sub_route) - 1):\n                node1 = sub_route[i]\n                node2 = sub_route[i+1]\n                heuristics_matrix[node1, node2] += 1\n                heuristics_matrix[node2, node1] += 1  # Ensure symmetry\n    \n    return heuristics_matrix",
          "objective": 29.95811,
          "other_inf": null,
          "SLOC": 33.0,
          "cyclomatic_complexity": 12.0,
          "halstead": 230.0
     },
     {
          "algorithm": "This algorithm estimates edge probabilities by repeatedly sampling random routes, evaluating their feasibility with respect to capacity constraints, and updating edge scores based on their inclusion in feasible routes.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"{This algorithm estimates edge probabilities by repeatedly sampling random routes, evaluating their feasibility with respect to capacity constraints, and updating edge scores based on their inclusion in feasible routes.}\"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros((n, n))\n    num_samples = 1000\n\n    for _ in range(num_samples):\n        # Generate a random permutation of customers (excluding the depot)\n        customer_indices = list(range(1, n))\n        random.shuffle(customer_indices)\n\n        routes = []\n        current_route = [0]  # Start at the depot\n        current_demand = 0\n\n        for customer in customer_indices:\n            if current_demand + demands[customer] <= capacity:\n                current_route.append(customer)\n                current_demand += demands[customer]\n            else:\n                current_route.append(0)  # Return to depot\n                routes.append(current_route)\n                current_route = [0, customer]\n                current_demand = demands[customer]\n\n        current_route.append(0) #Final return to depot\n        routes.append(current_route)\n\n        # Check feasibility of each route and update heuristics_matrix\n        for route in routes:\n            total_demand = 0\n            for customer in route[1:-1]:\n                total_demand += demands[customer]\n\n            if total_demand <= capacity:\n                for i in range(len(route) - 1):\n                    u = route[i]\n                    v = route[i+1]\n                    heuristics_matrix[u, v] += 1\n                    heuristics_matrix[v, u] += 1 #Symmetric\n    return heuristics_matrix",
          "objective": 29.96398,
          "other_inf": null,
          "SLOC": 33.0,
          "cyclomatic_complexity": 12.0,
          "halstead": 230.0
     },
     {
          "algorithm": "This algorithm samples multiple random routes, evaluates their feasibility with respect to capacity constraints, and then aggregates edge frequencies across feasible routes to estimate the likelihood of each edge being part of a good solution.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm samples multiple random routes, evaluates their feasibility with respect to capacity constraints, and then aggregates edge frequencies across feasible routes to estimate the likelihood of each edge being part of a good solution.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros((n, n))\n    num_samples = 1000\n\n    for _ in range(num_samples):\n        route = list(range(1, n))\n        np.random.shuffle(route)\n        \n        current_route = [0]\n        current_demand = 0\n        all_routes = []\n        \n        for node in route:\n            if current_demand + demands[node] <= capacity:\n                current_route.append(node)\n                current_demand += demands[node]\n            else:\n                current_route.append(0)\n                all_routes.append(current_route)\n                current_route = [0, node]\n                current_demand = demands[node]\n        current_route.append(0)\n        all_routes.append(current_route)\n        \n        for current_route in all_routes:\n            for i in range(len(current_route) - 1):\n                node1 = current_route[i]\n                node2 = current_route[i+1]\n                heuristics_matrix[node1, node2] += 1\n                heuristics_matrix[node2, node1] += 1\n\n    total_edges = num_samples\n    heuristics_matrix = heuristics_matrix / num_samples\n\n    return heuristics_matrix",
          "objective": 29.99483,
          "other_inf": null,
          "SLOC": 33.0,
          "cyclomatic_complexity": 12.0,
          "halstead": 230.0
     },
     {
          "algorithm": "This algorithm estimates edge attractiveness for CVRP by sampling random feasible routes and counting edge occurrences.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm estimates edge attractiveness for CVRP by sampling random feasible routes and counting edge occurrences.}\n    \"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    num_samples = 1000\n\n    for _ in range(num_samples):\n        # Generate a random permutation of customers (excluding the depot)\n        customer_indices = np.random.permutation(range(1, n))\n\n        # Construct routes based on vehicle capacity\n        routes = []\n        current_route = [0]  # Start at the depot\n        current_load = 0\n        for customer in customer_indices:\n            if current_load + demands[customer] <= capacity:\n                current_route.append(customer)\n                current_load += demands[customer]\n            else:\n                current_route.append(0)  # Return to depot\n                routes.append(current_route)\n                current_route = [0, customer]  # Start new route from depot\n                current_load = demands[customer]\n        current_route.append(0)\n        routes.append(current_route)\n\n        # Update heuristics matrix based on edges in the routes\n        for route in routes:\n            for i in range(len(route) - 1):\n                u = route[i]\n                v = route[i+1]\n                heuristics_matrix[u, v] += 1\n                heuristics_matrix[v, u] += 1  # Assuming symmetric distance matrix\n\n    return heuristics_matrix",
          "objective": 30.01535,
          "other_inf": null,
          "SLOC": 32.0,
          "cyclomatic_complexity": 8.0,
          "halstead": 125.09775004326937
     },
     {
          "algorithm": "This algorithm samples a large number of random feasible routes, then aggregates the frequency with which each edge appears in these routes to estimate its desirability.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm samples a large number of random feasible routes, then aggregates the frequency with which each edge appears in these routes to estimate its desirability.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros((n, n))\n    num_samples = 1000  # Adjust the number of samples\n    \n    for _ in range(num_samples):\n        # Randomly shuffle customers (excluding depot)\n        customer_indices = np.arange(1, n)\n        np.random.shuffle(customer_indices)\n        \n        # Construct route(s)\n        routes = []\n        current_route = [0]\n        current_capacity = 0\n        \n        for customer in customer_indices:\n            if current_capacity + demands[customer] <= capacity:\n                current_route.append(customer)\n                current_capacity += demands[customer]\n            else:\n                current_route.append(0)  # Return to depot\n                routes.append(current_route)\n                current_route = [0, customer]\n                current_capacity = demands[customer]\n        \n        current_route.append(0)  # Return to depot\n        routes.append(current_route)\n        \n        # Update heuristics matrix\n        for route in routes:\n            for i in range(len(route) - 1):\n                u = route[i]\n                v = route[i+1]\n                heuristics_matrix[u, v] += 1\n                heuristics_matrix[v, u] += 1 #Symmetric matrix\n    \n    return heuristics_matrix",
          "objective": 30.03731,
          "other_inf": null,
          "SLOC": 32.0,
          "cyclomatic_complexity": 8.0,
          "halstead": 125.09775004326937
     },
     {
          "algorithm": "This algorithm samples a large number of random routes satisfying capacity constraints, then calculates the frequency of each edge appearing in these routes to estimate the edge's desirability.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm samples a large number of random routes satisfying capacity constraints, then calculates the frequency of each edge appearing in these routes to estimate the edge's desirability.}\n    \"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    num_samples = 1000\n\n    for _ in range(num_samples):\n        remaining_nodes = list(range(1, n))\n        routes = []\n        current_route = [0]\n        current_capacity = capacity\n\n        while remaining_nodes:\n            \n            possible_nodes = []\n            for node in remaining_nodes:\n                if demands[node] <= current_capacity:\n                    possible_nodes.append(node)\n            \n            if not possible_nodes:\n                routes.append(current_route + [0])\n                current_route = [0]\n                current_capacity = capacity\n                continue\n                \n            next_node = random.choice(possible_nodes)\n            \n\n            current_route.append(next_node)\n            current_capacity -= demands[next_node]\n            remaining_nodes.remove(next_node)\n\n        routes.append(current_route + [0])\n\n        for route in routes:\n            for i in range(len(route) - 1):\n                u = route[i]\n                v = route[i+1]\n                heuristics_matrix[u, v] += 1\n                heuristics_matrix[v, u] += 1  # Assuming symmetric distance matrix\n\n    heuristics_matrix = heuristics_matrix / num_samples\n    return heuristics_matrix",
          "objective": 30.0868,
          "other_inf": null,
          "SLOC": 33.0,
          "cyclomatic_complexity": 12.0,
          "halstead": 230.0
     },
     {
          "algorithm": "This algorithm samples a set of random routes, evaluates their feasibility based on capacity constraints, and then aggregates the edge frequencies across feasible routes to generate a heuristic matrix favoring edges present in better solutions.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"{This algorithm samples a set of random routes, evaluates their feasibility based on capacity constraints, and then aggregates the edge frequencies across feasible routes to generate a heuristic matrix favoring edges present in better solutions.}\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros((n, n))\n    num_samples = 1000  # Number of random routes to sample\n    \n    for _ in range(num_samples):\n        # Generate a random permutation of customers (excluding the depot)\n        customer_indices = list(range(1, n))\n        random.shuffle(customer_indices)\n        \n        routes = []\n        current_route = [0]  # Start at the depot\n        current_capacity = 0\n        \n        for customer in customer_indices:\n            if current_capacity + demands[customer] <= capacity:\n                current_route.append(customer)\n                current_capacity += demands[customer]\n            else:\n                current_route.append(0)  # Return to depot\n                routes.append(current_route)\n                current_route = [0, customer]  # Start a new route from depot\n                current_capacity = demands[customer]\n        \n        current_route.append(0)\n        routes.append(current_route)\n        \n        # Update the heuristic matrix based on edges in the feasible routes\n        for route in routes:\n            for i in range(len(route) - 1):\n                node1 = route[i]\n                node2 = route[i+1]\n                heuristics_matrix[node1, node2] += 1\n                heuristics_matrix[node2, node1] += 1  # Assuming symmetric matrix\n\n    return heuristics_matrix",
          "objective": 30.1331,
          "other_inf": null,
          "SLOC": 33.0,
          "cyclomatic_complexity": 12.0,
          "halstead": 230.0
     },
     {
          "algorithm": "This algorithm samples a large number of random routes, evaluates their feasibility and cost, and uses the frequency of each edge appearing in feasible routes to construct a heuristic matrix.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"{This algorithm samples a large number of random routes, evaluates their feasibility and cost, and uses the frequency of each edge appearing in feasible routes to construct a heuristic matrix.}\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros((n, n))\n    num_samples = 1000\n\n    for _ in range(num_samples):\n        # Generate a random permutation of customers (excluding the depot)\n        permutation = np.random.permutation(range(1, n))\n        \n        # Construct routes\n        routes = []\n        current_route = [0]  # Start at the depot\n        current_load = 0\n        \n        for customer in permutation:\n            if current_load + demands[customer] <= capacity:\n                current_route.append(customer)\n                current_load += demands[customer]\n            else:\n                current_route.append(0)  # Return to depot\n                routes.append(current_route)\n                current_route = [0, customer]  # Start new route from depot\n                current_load = demands[customer]\n                \n        current_route.append(0)\n        routes.append(current_route)\n\n        # Check feasibility and update heuristics matrix\n        total_cost = 0\n        feasible = True\n\n        for route in routes:\n            route_cost = 0\n            route_load = 0\n            \n            for i in range(len(route) - 1):\n                u = route[i]\n                v = route[i+1]\n                route_cost += distance_matrix[u, v]\n                heuristics_matrix[u, v] += 1\n            \n                if u != 0 and u != route[-1]:\n                    route_load += demands[u]\n        \n            if route_load > capacity:\n                feasible = False\n                break\n        \n            total_cost += route_cost\n\n        if feasible:\n            pass  # Count occurrences even if not feasible -- remove to only look at feasible solutions\n            # Alternatively, could weight by (1/cost) or other metric\n\n    return heuristics_matrix",
          "objective": 30.18495,
          "other_inf": null,
          "SLOC": 33.0,
          "cyclomatic_complexity": 12.0,
          "halstead": 230.0
     },
     {
          "algorithm": "This algorithm samples many random routes, evaluates their feasibility based on capacity constraints, and uses the frequency of each edge appearing in feasible routes as a heuristic for its desirability.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm samples many random routes, evaluates their feasibility based on capacity constraints, and uses the frequency of each edge appearing in feasible routes as a heuristic for its desirability.}\n    \"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    num_samples = 1000\n\n    for _ in range(num_samples):\n        route = list(range(1, n))  # Exclude depot (node 0)\n        random.shuffle(route)\n\n        feasible_route = []\n        current_capacity = 0\n        current_route = [0] # Start at depot\n\n        for node in route:\n            if current_capacity + demands[node] <= capacity:\n                current_route.append(node)\n                current_capacity += demands[node]\n            else:\n                current_route.append(0) # Return to depot\n                feasible_route.append(current_route)\n                current_capacity = demands[node]\n                current_route = [0, node]\n        \n        if current_route != [0]:\n            current_route.append(0)  # Return to depot\n            feasible_route.append(current_route)\n        \n        \n        for sub_route in feasible_route:\n            for i in range(len(sub_route) - 1):\n                node1 = sub_route[i]\n                node2 = sub_route[i+1]\n                heuristics_matrix[node1, node2] += 1\n                heuristics_matrix[node2, node1] += 1  # Symmetry\n\n    return heuristics_matrix",
          "objective": 30.2197,
          "other_inf": null,
          "SLOC": 33.0,
          "cyclomatic_complexity": 12.0,
          "halstead": 230.0
     }
]