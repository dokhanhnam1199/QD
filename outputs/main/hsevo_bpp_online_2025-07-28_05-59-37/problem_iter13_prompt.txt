{"system": "You are an expert in code review. Your task extract all threshold, weight or hardcode variable of the function make it become default parameters.", "user": "[code]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines z-score fit/cap synergy with median stabilization and volatility damping \n    with variance-scaled tie-breaking for robust online bin packing dynamics.\n    \"\"\"\n    if bins_remain_cap.size == 0:\n        return np.array([], dtype=np.float64)\n    \n    orig_cap = np.max(bins_remain_cap)\n    if orig_cap < 1e-9 or item < 1e-9:\n        return np.where(\n            bins_remain_cap >= item, \n            1.0 / (bins_remain_cap - item + 1e-9), \n            -np.inf\n        )\n    \n    valid = bins_remain_cap >= item\n    if not valid.any():\n        return np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)\n    \n    leftover = bins_remain_cap - item\n    utilization = (orig_cap - bins_remain_cap) / orig_cap\n    tightness = item / (bins_remain_cap + 1e-9)\n    \n    # Z-score normalization of fit (best-fit) and capacity (worst-fit) metrics\n    elig_fit = 1.0 / (leftover[valid] + 1e-9)\n    mean_fit, std_fit = elig_fit.mean(), elig_fit.std()\n    z_fit = (1.0 / (leftover + 1e-9) - mean_fit) / (std_fit + 1e-9)\n    \n    elig_cap = bins_remain_cap[valid]\n    mean_cap, std_cap = elig_cap.mean(), elig_cap.std()\n    z_cap = (bins_remain_cap - mean_cap) / (std_cap + 1e-9)\n    \n    # Dynamic hybrid weighting with exponential utilization enhancer\n    primary = (tightness * z_fit + (1.0 - tightness) * z_cap) * np.exp(utilization * tightness)\n    \n    # Entropy-guided median stabilization to avoid capacity fragmentation\n    med_cap = np.median(bins_remain_cap)\n    balance = -0.05 * np.abs(bins_remain_cap - med_cap) / (orig_cap + 1e-9)\n    \n    # Multi-scale tie-breaking with volatility damping and variance scaling\n    vol_damping = 0.02 * np.exp(-leftover)\n    valid_leftover = leftover[valid]\n    std_leftover = valid_leftover.std() if len(valid_leftover) > 1 else 1e-6\n    epsilon = 1e-4 / (std_leftover + 1e-9)\n    grad_sensitivity = epsilon * (item / (bins_remain_cap + 1e-9))\n    \n    return np.where(\n        valid,\n        primary + balance + vol_damping + grad_sensitivity,\n        -np.inf\n    )\n\nNow extract all threshold, weight or hardcode variable of the function make it become default parameters and give me a 'parameter_ranges' dictionary representation. Key of dict is name of variable. Value of key is a tuple in Python MUST include 2 float elements, first element is begin value, second element is end value corresponding with parameter.\n\n- Output code only and enclose your code with Python code block: ```python ... ```.\n- Output 'parameter_ranges' dictionary only and enclose your code with other Python code block: ```python ... ```."}