{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    if bins_remain_cap.size == 0:\n        return np.array([], dtype=np.float64)\n    \n    orig_cap = np.max(bins_remain_cap)\n    if orig_cap <= 1e-9 or item <= 1e-9:\n        return np.where(\n            bins_remain_cap >= item,\n            bins_remain_cap - item + 1e-9,\n            -np.inf\n        )\n    \n    eligible = bins_remain_cap >= item\n    if not np.any(eligible):\n        return np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)\n    \n    # System metrics\n    system_avg = bins_remain_cap.mean()\n    system_std = bins_remain_cap.std()\n    system_cv = system_std / (system_avg + 1e-9)\n    \n    # Entropy calculation with discretization\n    rounded_caps = np.round(bins_remain_cap, 3)\n    _, counts = np.unique(rounded_caps, return_counts=True)\n    probs = counts / counts.sum()\n    system_entropy = -np.sum(probs * np.log(probs + 1e-9))\n    max_entropy = np.log(len(bins_remain_cap)) if len(bins_remain_cap) > 1 else 1.0\n    entropy_factor = system_entropy / (max_entropy + 1e-9)\n    \n    # Eligible bin metrics\n    bin_remain = bins_remain_cap[eligible]\n    fit_tightness = item / (bin_remain + 1e-9)\n    util_after = (orig_cap - bin_remain + item) / (orig_cap + 1e-9)\n    leftover = bin_remain - item\n    \n    # Adaptive normalization\n    ft_min, ft_max = fit_tightness.min(), fit_tightness.max()\n    fit_norm = 0.5 if ft_max <= ft_min else (fit_tightness - ft_min) / (ft_max - ft_min)\n    \n    ua_min, ua_max = util_after.min(), util_after.max()\n    util_norm = 0.5 if ua_max <= ua_min else (util_after - ua_min) / (ua_max - ua_min)\n    \n    # Hybrid score with entropy-driven weights\n    weight_fit = np.clip(1.0 - entropy_factor, 0.1, 0.9)\n    weight_util = 1.0 - weight_fit\n    hybrid = (weight_fit * fit_norm) + (weight_util * util_norm)\n    \n    # Nonlinear boost\n    boosted = hybrid ** 2\n    \n    # Entropy-driven proximity term\n    proximity = np.abs(leftover - system_avg) / (system_std + 1e-9)\n    proximity_penalty = np.exp(-proximity)\n    \n    # Shape factor using z-score\n    ls_z = (leftover - system_avg) / (system_std + 1e-9)\n    shape_factor = np.exp(-np.abs(ls_z))\n    \n    # Reinforcement-inspired terms\n    fragility = util_after  # High fragility = nearly full bin\n    usability = np.clip((system_avg - leftover) / (system_std + 1e-9), -1.0, 1.0)\n    closeness_weight = np.clip(1.0 - entropy_factor, 0.2, 1.0)\n    \n    reinforcer = 1.0 + (fragility * np.abs(usability) * closeness_weight)\n    \n    # Final priority calculation\n    priority = boosted * proximity_penalty * shape_factor * reinforcer\n    \n    # Build result array\n    result = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)\n    result[eligible] = priority\n    \n    return result\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Adaptive hybrid heuristic combining Z-normalized metrics, entropy-aware penalties, \n    and gradient-enhanced fragility control for online bin packing. Balances tight fits \n    with system-wide entropy optimization through dynamic weight allocation.\n    \"\"\"\n    if bins_remain_cap.size == 0:\n        return np.array([], dtype=np.float64)\n    \n    # Fast path for negligible items\n    if item < 1e-9:\n        return np.where(bins_remain_cap >= 0, \n                      0.3 / (bins_remain_cap + 1e-4) - 0.1 * bins_remain_cap,\n                      -np.inf)\n    \n    eligible = bins_remain_cap >= item - 1e-9\n    if not np.any(eligible):\n        return np.full_like(bins_remain_cap, -np.inf)\n    \n    # System state analysis\n    sys_avg, sys_std = np.mean(bins_remain_cap), np.std(bins_remain_cap)\n    sys_cv = sys_std / (sys_avg + 1e-9) if sys_avg > 1e-9 else 0.0\n    large_item = item > sys_avg * 0.75 * (1 + 0.3 * sys_cv)\n    \n    # Core metric computation\n    residual = bins_remain_cap - item\n    tightness = item / (bins_remain_cap + 1e-9)\n    fit_power = 1.0 / (residual + 1e-6)\n    frag_indicator = (residual - sys_avg) / (sys_std + 1e-9)\n    \n    # Adaptive Z-normalization\n    def z_normalize(metric):\n        return (metric - np.mean(metric[eligible])) / (np.std(metric[eligible]) + 1e-9)\n    \n    z_fit = z_normalize(fit_power)\n    z_tight = z_normalize(tightness)\n    z_balance = z_normalize(-np.abs(residual - sys_avg))\n    \n    # Dynamic weight calculation\n    def calc_weight(metric):\n        m_var = np.var(metric[eligible])\n        return m_var * (1.5 if large_item else 1.0) * (1 + sys_cv)\n    \n    fit_weight = calc_weight(z_fit)\n    tight_weight = calc_weight(1 - tightness)\n    balance_weight = calc_weight(-np.abs(residual - sys_avg))\n    \n    # Synergy amplification\n    synergy = 1.0 + np.tanh(\n        0.5 * (z_fit * fit_weight - z_tight * tight_weight)\n    ) * (1 - 0.4 * sys_std / (sys_avg + 1e-9))\n    \n    # Entropy-aware penalty tiers\n    penalty = np.select(\n        [\n            frag_indicator > sys_cv + 1.0,\n            frag_indicator < -sys_cv - 0.7,\n            frag_indicator < 0.5\n        ],\n        [\n            0.4 * sys_std**0.7 * (1 + sys_cv**0.5),\n            0.2 * sys_std**0.4 / (sys_avg + 1e-9),\n            0.15 * sys_cv**0.6\n        ],\n        default=0.08 * (1 - sys_cv)\n    )\n    \n    # Gradient-enhanced scoring\n    base_score = (\n        z_fit * fit_weight * synergy * (1.2 if large_item else 0.9) +\n        z_balance * balance_weight * (0.8 + 0.5 * sys_cv) +\n        (1 - z_tight * tight_weight * (0.6 if large_item else 1.0))\n    )\n    \n    # Fragility-adjusted final score\n    final_score = np.where(\n        eligible,\n        base_score - residual * penalty * (1.3 if item < sys_avg else 1.0),\n        -np.inf\n    )\n    \n    return final_score\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see the top heuristics use Z-score normalization across multiple metrics (fit, capacity, utilization), entropy-driven balance, and reinforcement learning concepts, while the worst rely on simpler adaptive weights without comprehensive normalization. (4th) vs (16th) shows that predictive entropy delta analysis and variance forecasting improve performance over basic entropy factors. (8th) vs (19th) highlights that gradient-enhanced scoring with dynamic item classification outperforms static penalty tiers. Overall, superior heuristics integrate **multi-metric Z-synergy**, **entropy-weighted fragmentation control**, **system variance adaptation**, and **reinforcement-style future-state prediction** to balance tight fits with long-term flexibility.\n- \nKeywords: predictive variance modeling, reinforcement learning, non-Z-score normalization, entropy-agnostic balance  \nAdvice: Use **predictive variance modeling** to anticipate fragmentation risks, **reinforcement learning** for long-term flexibility without entropy penalties, **min-max normalization** over Z-scores to reduce sensitivity to outliers, and **entropy-agnostic balance** via static-dynamic hybrid weights.  \nAvoid: Z-score synergy, entropy penalties modulated by system metrics, perturbation-based tie-breaking, exponential utilization boosting.  \nExplanation: Avoiding variance-ratio dependency (Z-scores) and system-metric-modulated entropy penalties prevents instability. Predictive variance modeling and reinforcement learning prioritize long-term gains over short-term metrics, while min-max normalization ensures robustness. Epsilon-based tie-breaking (not perturbation) maintains simplicity without introducing noise.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}