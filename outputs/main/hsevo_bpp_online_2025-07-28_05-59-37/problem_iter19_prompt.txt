{"system": "You are an expert in code review. Your task extract all threshold, weight or hardcode variable of the function make it become default parameters.", "user": "[code]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Predictive variance-aware binning with min-max synergy and reinforcement-inspired balance.\n    Combines normalized fit metrics with variance delta prediction and static fragmentation weights.\n    \"\"\"\n    eps = 1e-9\n    if bins_remain_cap.size == 0:\n        return np.array([], dtype=np.float64)\n    \n    eligible = bins_remain_cap >= item\n    if not eligible.any():\n        return np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)\n    \n    # Metric definitions\n    leftover = bins_remain_cap - item\n    tightness = item / (bins_remain_cap + eps)\n    fit_quality = 1.0 / (leftover + eps)\n    \n    # Min-max normalization helper\n    def normalize(arr):\n        min_val = arr.min()\n        max_val = arr.max()\n        denominator = (max_val - min_val) if (max_val > min_val) else 1.0\n        return (arr - min_val) / (denominator + eps)\n    \n    # Normalized metrics (higher = better)\n    fit_norm = normalize(fit_quality)\n    tight_norm = normalize(tightness)\n    \n    # Fragmentation penalty (static weight, higher penalty for smaller leftovers)\n    leftover_minmax = (leftover - leftover.min()) / (leftover.ptp() + eps)\n    frag_penalty = 1.0 - leftover_minmax  # Higher penalty for smaller leftovers\n    \n    # Predictive variance modeling: calculate variance delta for each bin\n    n = bins_remain_cap.size\n    current_sum = bins_remain_cap.sum()\n    current_sum_sq = (bins_remain_cap**2).sum()\n    \n    # Vectorized variance delta calculation\n    old_val = bins_remain_cap\n    new_val = old_val - item\n    new_sum = current_sum - item\n    new_sum_sq = current_sum_sq - old_val**2 + new_val**2\n    \n    new_mean = new_sum / n\n    new_var = (new_sum_sq / n) - new_mean**2\n    current_var = (current_sum_sq / n) - (current_sum / n)**2\n    \n    delta_var = new_var - current_var  # Negative delta improves balance\n    predictive_balance = -delta_var    # Higher = better balance impact\n    \n    # Core synergy with balance reinforcement\n    synergy = fit_norm + tight_norm + 0.5 * predictive_balance\n    \n    # Final priority with static fragmentation control\n    frag_weight = 0.3\n    priority = synergy - frag_weight * frag_penalty\n    \n    return np.where(eligible, priority, -np.inf)\n\nNow extract all threshold, weight or hardcode variable of the function make it become default parameters and give me a 'parameter_ranges' dictionary representation. Key of dict is name of variable. Value of key is a tuple in Python MUST include 2 float elements, first element is begin value, second element is end value corresponding with parameter.\n\n- Output code only and enclose your code with Python code block: ```python ... ```.\n- Output 'parameter_ranges' dictionary only and enclose your code with other Python code block: ```python ... ```."}