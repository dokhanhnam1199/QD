```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines min-max normalization, variance-aware proximity, and dynamic weighting.
    Uses predictive proximity to reduce fragmentation, reinforcement fragility control,
    and item-size-adaptive metrics for balanced bin selection.
    """
    if bins_remain_cap.size == 0:
        return np.array([], dtype=np.float64)
    
    # Edge case: negligible item
    if item < 1e-9:
        return np.where(bins_remain_cap >= 0, bins_remain_cap, -np.inf)
    
    eligible = bins_remain_cap >= (item - 1e-9)
    if not np.any(eligible):
        return np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)
    
    # System metrics
    orig_cap = np.max(bins_remain_cap)
    system_avg = np.mean(bins_remain_cap)
    system_std = np.std(bins_remain_cap)
    system_cv = system_std / (system_avg + 1e-9)
    
    # Item classification
    large_item = item > system_avg * (0.75 * (1 + 0.3 * system_cv))
    
    # Eligible bin metrics
    bin_remain = bins_remain_cap[eligible]
    leftover = bin_remain - item
    tightness = item / (bin_remain + 1e-9)
    util_after = (orig_cap - bin_remain + item) / (orig_cap + 1e-9)
    proximity = np.abs(leftover - system_avg)
    
    # Min-max normalization of metrics
    def minmax_normalize(arr):
        min_val = np.min(arr)
        max_val = np.max(arr)
        if max_val - min_val < 1e-9:
            return np.zeros_like(arr) + 0.5
        return (arr - min_val) / (max_val - min_val + 1e-9)
    
    tight_norm = minmax_normalize(tightness)
    proximity_norm = minmax_normalize(-proximity)  # Higher when closer to avg
    util_norm = 1.0 - minmax_normalize(util_after)  # Higher when util is lower
    
    # Dynamic weight allocation
    w_tight = 0.6 if large_item else 0.3
    w_prox = 0.3 if large_item else 0.5
    w_util = 0.1 if large_item else 0.2
    
    # Hybrid score with nonlinear boost
    hybrid = (w_tight * tight_norm) + (w_prox * proximity_norm) + (w_util * util_norm)
    boosted = hybrid ** 1.5  # Stronger nonlinear enhancement
    
    # Reinforcement-inspired fragility control
    usability = (system_avg - leftover) / (system_std + 1e-9)
    fragility_factor = util_after * np.clip(usability, 0, None) * proximity_norm
    reinforcer = 1.0 + (0.3 * fragility_factor)  # Boosts fragility when usable
    
    # Predictive variance adjustment
    variance_factor = np.exp(-proximity / (system_std + 1e-9))  # Favors proximity
    
    # Final score calculation
    score = boosted * reinforcer * variance_factor
    
    # Build result array
    result = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)
    result[eligible] = score
    
    return result
```
