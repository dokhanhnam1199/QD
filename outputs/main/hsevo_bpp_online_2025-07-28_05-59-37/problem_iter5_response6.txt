```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Multi-objective priority combining dynamic BF/WF weights, fragmentation penalty, and system balance.
    Uses online entropy-aware balancing and exponential waste sensitivity.
    """
    if len(bins_remain_cap) == 0:
        return np.array([], dtype=np.float64)
    
    valid = bins_remain_cap >= item
    if not valid.any():
        return np.full_like(bins_remain_cap, -np.inf)
    
    C_est = bins_remain_cap.max()
    relative_size = item / (C_est + 1e-9)  # Avoid division by zero
    
    # Dynamic BF/WF blending with non-linear weighting
    weight_bf = np.clip(relative_size ** 2 + 0.1 * (C_est - bins_remain_cap.mean()) / C_est, 0, 1)
    best_fit = -(bins_remain_cap - item)  # Higher score = better BF fit
    worst_fit = bins_remain_cap           # Higher score = more residual space
    primary_score = weight_bf * best_fit + (1 - weight_bf) * worst_fit
    
    # Fragmentation penalty using sigmoid-decay for marginal spaces
    leftover = bins_remain_cap - item
    frag_score = -np.exp(-leftover / (0.2 * C_est + 1e-9))  # Exponential penalty for small leftovers
    
    # Entropy-aware balancing using median alignment and variance reward
    med = np.median(bins_remain_cap)
    distance = np.abs(bins_remain_cap - med)
    balance_score = -0.1 * distance / (C_est + 1e-9)  # Encourage utilization convergence
    
    # Tie-breaking layer for degenerate cases
    entropy_tiebreaker = 1e-4 * (np.random.rand(*bins_remain_cap.shape) - 0.5)  # Small stochastic component
    
    # Final score with validity masking
    scores = np.where(valid, primary_score + frag_score + balance_score + entropy_tiebreaker, -np.inf)
    return scores
```
