```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Hybrid heuristic combining tightness-weighted Z-scores, exponential utilization enhancer,
    entropy-aware fragmentation control via adaptive-scale penalty, and median-anchored
    balance stabilization for online Bin Packing prioritization.
    """
    if bins_remain_cap.size == 0:
        return np.array([], dtype=np.float64)
    
    orig_cap = np.max(bins_remain_cap)
    if orig_cap <= 1e-9 or item <= 1e-9:
        return np.where(
            bins_remain_cap >= item,
            1.0 / (bins_remain_cap - item + 1e-9),
            -np.inf
        )
    
    eligible = bins_remain_cap >= item
    if not eligible.any():
        return np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)
    
    leftover = bins_remain_cap - item
    
    # Core metrics
    utilization = (orig_cap - bins_remain_cap) / (orig_cap + 1e-9)
    tightness = item / (bins_remain_cap + 1e-9)
    
    # Z-score normalized fit/capacity synergy
    fit_quality = 1.0 / (leftover + 1e-9)
    elig_fit, elig_cap = fit_quality[eligible], bins_remain_cap[eligible]
    z_fit = (fit_quality - np.mean(elig_fit)) / (np.std(elig_fit) + 1e-9)
    z_cap = (bins_remain_cap - np.mean(elig_cap)) / (np.std(elig_cap) + 1e-9)
    primary_score = (tightness * z_fit + (1.0 - tightness) * z_cap) * np.exp(utilization * tightness)
    
    # Adaptive fragmentation penalty with entropy-sensitive scaling
    std_leftover = leftover[eligible].std() + 1e-9
    frag_scale = (0.05 * orig_cap) + 0.15 * std_leftover
    frag_penalty = np.exp(-leftover / (frag_scale + 1e-9))
    
    # Median-centered balance constraint for distribution stabilization
    med_cap = np.median(bins_remain_cap)
    balance_term = 0.05 * np.abs(bins_remain_cap - med_cap) / (orig_cap + 1e-9)
    
    # Multi-axis perturbation mechanism for deterministic tie-breaking
    var_factor = 1e-6 / (std_leftover + 1e-9)
    perturbation = var_factor * tightness
    
    # Score aggregation with hierarchical prioritization
    return np.where(
        eligible,
        primary_score - frag_penalty - balance_term + perturbation,
        -np.inf
    )
```
