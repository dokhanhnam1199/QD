```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Hybrid heuristic combining z-score balance, exponential utilization boosting, and tight-fit frag control.
    
    Adaptive weights driven by system-wide CV and item size class. Balances between tight-fits and entropy-minimized placement.
    """
    if not bins_remain_cap.size:
        return np.array([], dtype=np.float64)
    
    possible = bins_remain_cap >= item
    if not possible.any():
        return np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)
    
    # System-wide parameter estimation
    C_est = bins_remain_cap.max() if bins_remain_cap.size > 0 else 1.0
    system_avg = bins_remain_cap.mean()
    system_std = bins_remain_cap.std()
    system_cv = system_std / (system_avg + 1e-9) if system_avg > 0 else 0.0

    # Item classification for adaptive scaling
    large_item = item > system_avg

    # Key metrics calculation
    leftover = bins_remain_cap - item
    filled_frac = 1.0 - (bins_remain_cap / C_est)  # fraction of bin used

    # Tight-fit classification
    tight = (item > bins_remain_cap / 2) & possible

    # Base priority logic
    base_priority = np.where(tight, -leftover, leftover)  # best/worst-fit switching

    # Normalized balance metric using Z-score
    z_balance = (leftover - system_avg) / (system_std + 1e-9)
    balance_weight = 0.1 * system_cv * (2 if large_item else 1)
    balance_score = -balance_weight * np.abs(z_balance)  # Favor bins close to avg remaining

    # Exponential utilization enhancement
    util_exp = np.exp(2 * filled_frac)  # Super-linear boost for higher filled bins
    util_weight = 1e-3 * (1 + system_cv)
    util_score = util_weight * util_exp

    # Fragmentation penalty for small leftover gaps
    x = leftover / C_est
    frag_score = np.exp(-x)  # Higher penalty for smaller leftover
    frag_weight = 1e-4 * (1 + filled_frac)  # Adaptive scaling by bin occupancy
    frag_term = frag_weight * frag_score

    # Composite priority combining all factors
    priority = base_priority + balance_score + util_score - frag_term
    
    return np.where(possible, priority, -np.inf)
```
