```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Multi-objective hybrid priority function with adaptive fit blending and synergy-enhanced utilization metrics.
    Incorporates non-linear sensitivity analysis through sigmoid-controlled fit preferences and hierarchical synergy boosting.
    """
    if bins_remain_cap.size == 0:
        return np.array([], dtype=np.float64)
    
    orig_cap = np.max(bins_remain_cap)
    epsilon = 1e-9
    
    if orig_cap <= epsilon or item <= epsilon:
        return np.where(
            bins_remain_cap >= item,
            1.0 / (bins_remain_cap - item + epsilon),
            -np.inf
        )
    
    eligible = bins_remain_cap >= item - epsilon
    eligible_indices = np.where(eligible)[0]
    if not eligible_indices.size:
        return np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)
    
    remaining = bins_remain_cap[eligible_indices]
    n_eligible = eligible_indices.size
    
    # Calculate fit components
    tightness = item / (remaining + epsilon)
    utilization = (orig_cap - remaining) / orig_cap
    leftover = remaining - item
    
    # Dynamic fit preference based on item size
    item_norm = item / orig_cap
    fit_weight = 1 / (1 + np.exp(-5 * (item_norm - 0.4)))
    
    # Best fit component with softmax normalization
    best_fit_score = 1.0 / (leftover + epsilon)
    best_fit_exp = np.exp(best_fit_score - best_fit_score.max())
    best_fit_norm = best_fit_exp / (best_fit_exp.sum() + epsilon)
    
    # Worst fit component with min-max normalization
    worst_fit_norm = (leftover - leftover.min()) / (leftover.ptp() + epsilon) + 1
    
    # Adaptive blending of fit preferences
    tight_weight = fit_weight
    loose_weight = 1 - fit_weight
    blended_fit = tight_weight * best_fit_norm + loose_weight * worst_fit_norm
    
    # Synergy enhancement based on cross-component analysis
    avg_util = utilization.mean()
    avg_tight = tightness.mean()
    synergy_factor = 1.0 + 0.5 * (
        (tightness > avg_tight).astype(float) + 
        (utilization > avg_util).astype(float)
    )
    
    # Dynamic synergy weighting based on eligible bin count
    synergy_weight = max(0.2, min(0.7, n_eligible / (n_eligible + 1)))
    
    # Primary scoring with synergy integration
    primary_score = blended_fit * synergy_factor
    
    # Exponential enhancer with Utilization-Tightness coupling
    enhancer = np.exp(utilization + tightness)
    
    # Final priority score assembly
    final_score = primary_score * enhancer
    
    # Compose results for output
    scores = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)
    scores[eligible_indices] = final_score
    
    return scores
```
