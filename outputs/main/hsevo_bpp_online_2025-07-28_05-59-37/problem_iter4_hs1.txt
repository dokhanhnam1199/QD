import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray, 
                epsilon= 6.813903806202619e-07,
                balance_score_factor= 4.886022359868282,
                exp_waste_weight= 0.23709314430652673,
                frag_penalty_true= 0.48501984870424963,
                frag_penalty_false= -0.2618883801189624,
                tiebreaker_weight= 0.08971640686123991,
                entropy_threshold= 1.6331974623014556,
                balance_weight_base= -0.25621557184316274,
                median_adjustment_factor= 0.2730665823171188) -> np.ndarray:
    mask = bins_remain_cap >= item
    scores = np.full_like(bins_remain_cap, -np.inf)
    if not mask.any():
        return scores
    
    remaining = bins_remain_cap[mask]
    
    # Adaptive statistics tracking
    item_rel = item / (remaining.mean() + epsilon)
    sigma = remaining.std()
    skew = np.abs((remaining - remaining.mean()) / (sigma + epsilon))
    entropy = -((remaining / (remaining.sum() + epsilon)) * np.log(remaining / (remaining.sum() + epsilon) + epsilon)).sum()
    
    # Dynamic component weights
    best_weight = np.abs(np.log(item_rel + epsilon)) + entropy  # Stronger best-fit when skewed
    balance_weight = balance_weight_base - item_rel + entropy  # Adapt to uniformity needs
    frag_weight = item_rel  # Fragmentation penalty scales with item size
    
    # Core components (v1-inspired)
    inv_leftover = 1.0 / (remaining - item + epsilon)
    utilization = item / (remaining + epsilon)
    exp_waste = np.exp(-(remaining - item))
    
    # Entropy-aware fragmentation metric
    frag_mask = (remaining - item) < (remaining.mean() / (median_adjustment_factor + skew.mean() + epsilon))
    frag_penalty = np.where(frag_mask, frag_penalty_true, frag_penalty_false)  # Reward meaningful fragmentations
    
    # Adaptive bin utilization balance
    balance_score = 1 / (1 + np.exp(balance_score_factor * (remaining - (remaining.mean() + sigma))))
    
    # Synergistic score calculation
    synergy_score = (
        best_weight * inv_leftover +
        balance_weight * balance_score +
        exp_waste_weight * exp_waste +
        frag_weight * frag_penalty
    )
    
    # Adaptive tie-breaking via bin heterogeneity metrics
    secondary_tiebreaker = -skew if entropy > entropy_threshold else skew
    
    scores[mask] = synergy_score + tiebreaker_weight * secondary_tiebreaker  # Small tilt for real-time adaptability
    return scores
