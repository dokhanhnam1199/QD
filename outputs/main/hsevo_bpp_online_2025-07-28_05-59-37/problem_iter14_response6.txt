```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Adaptive synergy of Z-normalized metrics with entropy-weighted fragmentation control and predictive balance.
    Combines tight-fit synergy, exponential enhancer, and system-aware tie-breaking.
    """
    eps = 1e-9
    if bins_remain_cap.size == 0:
        return np.array([], dtype=np.float64)
    
    eligible = bins_remain_cap >= item
    if not eligible.any():
        return np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)
    
    # Core metrics
    C = bins_remain_cap.max()
    remaining_cap = bins_remain_cap[eligible]
    leftover = remaining_cap - item + eps
    
    fit_quality = 1.0 / leftover
    tightness = item / (remaining_cap + eps)
    utilization = (C - remaining_cap) / C
    
    # Z-score normalization
    def z_score(x):
        return (x - x.mean()) / (x.std() + eps)
    
    z_fit = z_score(fit_quality)
    z_tight = z_score(tightness)
    z_util = z_score(utilization)
    
    # Adaptive synergy: variance-weighted tight-fit + utilization coupling
    var_fit = max(z_fit.var(), 0.1)
    var_tight = max(z_tight.var(), 0.1)
    weight_tight = var_fit / (var_fit + var_tight)  # Inverse variance weighting
    adaptive_synergy = weight_tight * z_tight + (1 - weight_tight) * z_fit
    synergy = adaptive_synergy * (1 + z_util)  # Utilization-coupled reinforcement
    
    # Exponential enhancer with predictive utilization
    enhancer = np.exp(utilization * tightness)
    primary_score = synergy * enhancer
    
    # Entropy-sensitive fragmentation control
    sys_entropy = bins_remain_cap.std() / (C + eps)
    frag_penalty = 1.0 - np.exp(-leftover / (C + eps))
    frag_weight = 0.2 * (1.0 + sys_entropy)
    
    # System balance term (leftover proximity to average)
    system_avg = bins_remain_cap.mean()
    balance = -np.abs(leftover - system_avg) * (1.0 + sys_entropy)
    balance_weight = 0.1 * (1.0 + sys_entropy)
    
    # Deterministic tie-breaker (entropy-coupled exponential decay)
    tie_breaker = 0.05 * np.exp(-leftover) * (1.0 + sys_entropy)
    
    # Final score with multi-layered components
    scores = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)
    eligible_scores = (
        primary_score 
        - frag_weight * frag_penalty 
        + balance * balance_weight 
        + tie_breaker
    )
    scores[eligible] = eligible_scores
    
    return scores
```
