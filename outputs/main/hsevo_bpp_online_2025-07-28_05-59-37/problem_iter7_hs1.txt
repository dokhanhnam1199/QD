import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray, zero_threshold= 9.961406109732729e-09, fit_weight= 6.790118266347742, enhancer_exponent_factor= 0.03114244316596415) -> np.ndarray:
    """
    Adaptive hybrid priority combining z-scored fit quality/capacity, exponential utilization enhancement, and layered tightness-weighted metrics.
    Encourages best-fit in high-utilization bins while dynamically balancing with worst-fit for small items.
    """
    if bins_remain_cap.size == 0:
        return np.array([], dtype=np.float64)
    
    orig_cap = np.max(bins_remain_cap)
    if orig_cap <= zero_threshold or item <= zero_threshold:
        return np.where(
            bins_remain_cap >= item,
            fit_weight / (bins_remain_cap - item + zero_threshold),
            -np.inf
        )
    
    eligible = bins_remain_cap >= item
    leftover = bins_remain_cap - item
    utilization = (orig_cap - bins_remain_cap) / orig_cap
    tightness = item / (bins_remain_cap + zero_threshold)
    
    # Z-score normalized fit and capacity for fair comparison
    fit_quality = fit_weight / (leftover + zero_threshold)
    elig_fit = fit_quality[eligible]
    elig_cap = bins_remain_cap[eligible]
    
    if elig_fit.size == 0:
        return np.full_like(fit_quality, -np.inf, dtype=np.float64)
    
    # Z-score calculation
    mean_fit, std_fit = np.mean(elig_fit), np.std(elig_fit)
    z_fit = (fit_quality - mean_fit) / (std_fit + zero_threshold)
    
    mean_cap, std_cap = np.mean(elig_cap), np.std(elig_cap)
    z_cap = (bins_remain_cap - mean_cap) / (std_cap + zero_threshold)
    
    # Dynamic best/worst-fit blend with exponential utilization boost
    primary_score = tightness * z_fit + (1.0 - tightness) * z_cap
    enhancer = np.exp(utilization * tightness * enhancer_exponent_factor)  # Exponential amplification for utilized bins
    
    return np.where(eligible, primary_score * enhancer, -np.inf)
