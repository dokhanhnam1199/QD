```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines adaptive Z-score normalization, entropy-driven balance, and reinforcement learning concepts.
    Prioritizes bins that optimize fit tightness, system-wide capacity balance, and future flexibility.
    """
    if bins_remain_cap.size == 0:
        return np.array([], dtype=np.float64)
    
    orig_cap = np.max(bins_remain_cap)
    if orig_cap <= 1e-9 or item <= 1e-9:
        return np.where(
            bins_remain_cap >= item,
            bins_remain_cap - item + 1e-9,
            -np.inf
        )
    
    eligible = bins_remain_cap >= item
    if not np.any(eligible):
        return np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)
    
    # System-wide metrics
    system_avg = bins_remain_cap.mean()
    system_std = bins_remain_cap.std()
    system_cv = system_std / (system_avg + 1e-9) if system_avg > 1e-9 else 0.0
    
    # Item classification
    large_item = item > system_avg
    
    # Core metrics
    leftover = bins_remain_cap - item
    tightness = item / (bins_remain_cap + 1e-9)
    utilization = (orig_cap - bins_remain_cap) / (orig_cap + 1e-9)
    
    # Z-score normalization for fit and space
    elig_fit = 1.0 / (leftover + 1e-9)
    elig_fit_mean, elig_fit_std = np.mean(elig_fit[eligible]), np.std(elig_fit[eligible])
    z_fit = (elig_fit - elig_fit_mean) / (elig_fit_std + 1e-9)
    
    elig_space = bins_remain_cap
    elig_space_mean, elig_space_std = np.mean(elig_space[eligible]), np.std(elig_space[eligible])
    z_cap = (elig_space - elig_space_mean) / (elig_space_std + 1e-9)
    
    # Primary score: adaptive tightness-weighted Z-combination
    primary_score = tightness * z_fit + (1.0 - tightness) * z_cap
    
    # Exponential enhancer for utilization-tightness synergy
    enhancer = np.exp(utilization * tightness)
    
    # Entropy-driven balance term
    balance_term = -np.abs(leftover - system_avg) / (system_std + 1e-9)
    balance_weight = 0.5 * system_cv * np.where(large_item, 1.0, 2.0)
    balance_contrib = balance_term * balance_weight
    
    # Reinforcement multiplier
    eligible_rem = bins_remain_cap[eligible]
    rel_size = item / (np.median(eligible_rem) + 1e-9)
    fragility = ((orig_cap - bins_remain_cap) / (orig_cap + 1e-9)).clip(0, 1)
    rem_rel = bins_remain_cap / (orig_cap + 1e-9)
    reinforce_factor = (1 - rel_size) ** 2 * rem_rel * fragility
    reinforcer = 1 + 0.5 * reinforce_factor
    
    # Final priority calculation
    priority = (primary_score * enhancer + balance_contrib) * reinforcer
    
    return np.where(eligible, priority, -np.inf)
```
