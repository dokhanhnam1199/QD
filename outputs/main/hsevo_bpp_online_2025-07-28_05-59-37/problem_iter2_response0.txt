```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Priority combining inv_waste, utilization, and exp_waste with adaptive tie-breaking for real-time opt."""
    mask = bins_remain_cap >= item
    scores = np.full_like(bins_remain_cap, -np.inf)
    if not mask.any():
        return scores
    
    eps = 1e-9
    remaining = bins_remain_cap[mask]
    
    # v0-derived factors: inv_leftover + utilization
    inv_leftover = 1.0 / (remaining - item + eps)
    utilization = item / (remaining + eps)
    
    # v1-derived exponential sensitivity to waste
    exp_waste = np.exp(-(remaining - item))
    
    # Dynamic synergy: Combine v0's stability with v1's waste-awareness
    # Weights chosen to preserve metric dominance while allowing adaptive tie-breaking
    scores[mask] = inv_leftover + utilization + 0.1 * exp_waste
    return scores
```
