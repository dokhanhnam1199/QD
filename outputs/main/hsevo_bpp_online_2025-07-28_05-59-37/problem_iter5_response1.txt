```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Combine v0's dynamic class with v1's balance using adaptive weights.

    Uses item classification for epsilon scaling and adds system balance scaled by fragmentation level.
    """
    if len(bins_remain_cap) == 0:
        return np.array([], dtype=np.float64)
    
    threshold = np.mean(bins_remain_cap)
    large_item = item > threshold

    valid = bins_remain_cap >= item
    if not np.any(valid):
        return -np.inf * np.ones_like(bins_remain_cap)
    
    remaining_after = bins_remain_cap - item

    # Base priority from v0
    epsilon = 1e-6 if large_item else 1e-3
    base_priority = -remaining_after - epsilon * bins_remain_cap

    # System-wide balance metrics
    system_avg = bins_remain_cap.mean()
    system_std = bins_remain_cap.std()
    system_cv = system_std / (system_avg + 1e-9)
    
    # Adaptive balance weight: higher for fragmentation (system_cv) and small items
    load_balance_score = -np.abs(remaining_after - system_avg)
    balance_weight = 0.1 * system_cv * (2 if not large_item else 1)

    # Combine components with dynamic synergy
    priority = base_priority + balance_weight * load_balance_score

    return np.where(valid, priority, -np.inf)
```
