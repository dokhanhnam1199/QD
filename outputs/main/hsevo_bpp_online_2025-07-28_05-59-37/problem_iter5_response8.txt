```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Hybrid priority function combining local/global balance, dynamic metric normalization,
    and variance-sensitive fragmentation control to optimize bin packing decisions.
    
    Key ideas:
    - Multi-metric synergy (inv. leftover, utilization, exponential waste)
    - Combined local-of-fitting/global system awareness via balance terms
    - Variance-driven sensitivity scaling
    - Normalized metric ranges for fair weighting
    """
    mask = bins_remain_cap >= item
    scores = np.full_like(bins_remain_cap, -np.inf)
    if not mask.any():
        return scores
    
    eps = 1e-9
    remaining = bins_remain_cap[mask]
    n_candidates = remaining.shape[0]
    
    # Global vs Local context tracking
    system_avg = np.mean(bins_remain_cap)
    system_cv = np.std(bins_remain_cap) / (system_avg + eps)  # System-wide fragmentation metric
    local_avg = remaining.mean()
    
    # Base metrics
    post_insert_remaining = remaining - item
    inv_leftover = 1.0 / (post_insert_remaining + eps)
    utilization = item / (remaining + eps)
    exp_waste = np.exp(-post_insert_remaining)  # Prefer minimal leftover
    
    # Adaptive metric normalization (v0-inspired)
    inv_norm = (inv_leftover - inv_leftover.min()) / (inv_leftover.ptp() + eps)
    util_norm = (utilization - utilization.min()) / (utilization.ptp() + eps)
    
    # Structural ratio with dual-awareness
    struct_ratio = item / ((local_avg + system_avg) / 2 + eps)  # Balanced size perception
    weight_inv = 1.0 + struct_ratio * (1 + system_cv)  # Size + fragmentation sensitivity
    weight_util = 3.0 / (struct_ratio + eps)  # Enhanced small-item focus
    
    # Combined balance metric (v0 local + v1 global)
    if n_candidates > 1:
        sum_other_candidates = (remaining.sum() - remaining) / (n_candidates - 1e-12)
        delta_local = np.abs(post_insert_remaining - sum_other_candidates)
        load_balance_local = 1.0 / (np.log1p(delta_local) + eps)
    else:
        load_balance_local = np.ones_like(inv_leftover)
    
    delta_global = np.abs(post_insert_remaining - system_avg)
    load_balance_global = 1.0 / (np.log1p(delta_global) + eps)
    load_balance = 0.6 * load_balance_local + 0.4 * load_balance_global  # Prioritize fitting context
    
    # Variance-aware adaptation
    local_variance = np.var(remaining)
    variance_sensitivity = 1.0 + np.tanh(local_variance / (local_avg + eps)) * (1 + system_cv)
    
    # Core synergy calculation
    dynamic_core = weight_inv * inv_norm + weight_util * util_norm
    adaptive_term = 0.7 * load_balance * variance_sensitivity
    waste_term = 0.3 * exp_waste * (1 + system_cv)  # System-aware waste scaling
    
    # Final score assembly
    scores[mask] = dynamic_core + adaptive_term + waste_term
    
    return scores
```
