```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Priority combining fit quality and dynamic utilization adjustment.
    
    Prioritizes bins with:
    1. Sufficient capacity to fit the item (ineligible bins get -inf)
    2. A score combining (1) perfect fit bias using inverse leftover, and (2) 
       dynamic weighting by bin utilization ratio measured via remaining capacity.
    """
    if bins_remain_cap.size == 0:
        return np.array([], dtype=np.float64)
    
    orig_cap = np.max(bins_remain_cap)
    if orig_cap <= 1e-9 or item <= 1e-9:
        # Fallback to v0 when capacity not determined or item negligible
        return np.where(
            bins_remain_cap >= item,
            1.0 / (bins_remain_cap - item + 1e-9),
            -np.inf
        )
    
    eligible = bins_remain_cap >= item
    utilization = (orig_cap - bins_remain_cap) / orig_cap
    
    leftover = bins_remain_cap - item
    fit_quality = 1.0 / (leftover + 1e-9)
    
    # Dynamic synergy: amplify fit quality in more utilized bins
    scores = fit_quality * (1 + utilization)
    return np.where(eligible, scores, -np.inf)
```
