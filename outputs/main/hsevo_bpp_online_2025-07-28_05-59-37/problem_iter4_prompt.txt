{"system": "You are an expert in code review. Your task extract all threshold, weight or hardcode variable of the function make it become default parameters.", "user": "[code]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    mask = bins_remain_cap >= item\n    scores = np.full_like(bins_remain_cap, -np.inf)\n    if not mask.any():\n        return scores\n    \n    eps = 1e-9\n    remaining = bins_remain_cap[mask]\n    \n    # Adaptive statistics tracking\n    item_rel = item / (remaining.mean() + eps)\n    sigma = remaining.std()\n    skew = np.abs((remaining - remaining.mean()) / (sigma + eps))\n    entropy = -((remaining / (remaining.sum() + eps)) * np.log(remaining / (remaining.sum() + eps) + eps)).sum()\n    \n    # Dynamic component weights\n    best_weight = np.abs(np.log(item_rel + eps)) + entropy  # Stronger best-fit when skewed\n    balance_weight = 1 - item_rel + entropy  # Adapt to uniformity needs\n    frag_weight = item_rel  # Fragmentation penalty scales with item size\n    \n    # Core components (v1-inspired)\n    inv_leftover = 1.0 / (remaining - item + eps)\n    utilization = item / (remaining + eps)\n    exp_waste = np.exp(-(remaining - item))\n    \n    # Entropy-aware fragmentation metric\n    frag_mask = (remaining - item) < (remaining.mean() / (1 + skew.mean() + eps))\n    frag_penalty = np.where(frag_mask, 0.1, -0.1)  # Reward meaningful fragmentations\n    \n    # Adaptive bin utilization balance\n    balance_score = 1 / (1 + np.exp(2 * (remaining - (remaining.mean() + sigma))))\n    \n    # Synergistic score calculation\n    synergy_score = (\n        best_weight * inv_leftover +\n        balance_weight * balance_score +\n        0.5 * exp_waste +\n        frag_weight * frag_penalty\n    )\n    \n    # Adaptive tie-breaking via bin heterogeneity metrics\n    secondary_tiebreaker = -skew if entropy > 0.7 else skew\n    \n    scores[mask] = synergy_score + 0.01 * secondary_tiebreaker  # Small tilt for real-time adaptability\n    return scores\n\nNow extract all threshold, weight or hardcode variable of the function make it become default parameters and give me a 'parameter_ranges' dictionary representation. Key of dict is name of variable. Value of key is a tuple in Python MUST include 2 float elements, first element is begin value, second element is end value corresponding with parameter.\n\n- Output code only and enclose your code with Python code block: ```python ... ```.\n- Output 'parameter_ranges' dictionary only and enclose your code with other Python code block: ```python ... ```."}