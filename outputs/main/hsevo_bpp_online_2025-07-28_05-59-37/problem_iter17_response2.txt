```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Priority function combining min-max normalization, adaptive weights based on item size,
    predictive variance modeling via reinforcement term, and system balance factor.
    """
    if bins_remain_cap.size == 0:
        return np.array([], dtype=np.float64)
    
    # Edge case: zero-sized item or bins
    orig_cap = np.max(bins_remain_cap)
    if orig_cap <= 1e-9 or item <= 1e-9:
        return np.where(
            bins_remain_cap >= item,
            bins_remain_cap - item + 1e-9,
            -np.inf
        )
    
    # Identify eligible bins that can fit the item
    eligible = bins_remain_cap >= item
    if not np.any(eligible):
        return np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)
    
    elig_remaining = bins_remain_cap[eligible]
    remaining_after = elig_remaining - item
    
    # System-wide metrics
    system_median = np.median(bins_remain_cap)
    system_iqr = np.percentile(bins_remain_cap, 75) - np.percentile(bins_remain_cap, 25)
    
    # Metric calculations for eligible bins
    tightness = item / elig_remaining  # Tightness of fit
    utilization = (orig_cap - elig_remaining) / orig_cap  # Current bin utilization
    
    # Min-max normalization for each metric
    # Tightness normalization
    t_min, t_max = tightness.min(), tightness.max()
    tightness_norm = (tightness - t_min) / (t_max - t_min + 1e-9) if t_max > t_min else np.full_like(tightness, 0.5)
    
    # Remaining space normalization (higher = less space left)
    ra_min, ra_max = remaining_after.min(), remaining_after.max()
    space_norm = (ra_max - remaining_after) / (ra_max - ra_min + 1e-9) if ra_max > ra_min else np.full_like(remaining_after, 0.5)
    
    # Utilization normalization (higher = more filled)
    u_min, u_max = utilization.min(), utilization.max()
    util_norm = (utilization - u_min) / (u_max - u_min + 1e-9) if u_max > u_min else np.full_like(utilization, 0.5)
    
    # Adaptive weight calculation based on item size relative to system median
    item_rel_size = item / (system_median + 1e-9)
    tight_weight = 0.4 + 0.5 * item_rel_size  # Prioritize tight fit for large items
    space_weight = 0.4 + 0.5 * (1 - item_rel_size)  # Prioritize space preservation for small items
    util_weight = 0.2  # Fixed weight for utilization
    
    # Hybrid score combining normalized metrics
    hybrid_score = (
        (tightness_norm + 1e-9) ** tight_weight *
        (space_norm + 1e-9) ** space_weight *
        (util_norm + 1e-9) ** util_weight
    )
    
    # Reinforcement term: proximity to median remaining capacity after placement
    median_after = np.median(remaining_after)
    mad_after = np.median(np.abs(remaining_after - median_after))
    reinforce_score = np.exp(-np.abs(remaining_after - median_after) / (mad_after + 1e-9))
    
    # Final score with reinforcement and balance factor
    final_score = hybrid_score * (0.5 + 0.5 * reinforce_score)
    final_score *= 1.0 / (1.0 + system_iqr)  # System balance adjustment
    
    # Build final priority array
    priority = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)
    priority[eligible] = final_score
    
    return priority
```
