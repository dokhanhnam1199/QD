import numpy as np

def priority_v2(
    item: float, 
    bins_remain_cap: np.ndarray, 
    zero_threshold= 0.0008949070488123731, 
    tightness_denominator_eps= 2.0598785041307186e-07, 
    std_zscore_eps= 2.1249011590144297e-07, 
    balance_denominator_eps= 0.0009540129030285387, 
    grad_epsilon= 0.00014370201183538662, 
    grad_std_eps= 8.439991486854087e-07, 
    min_std_value= 2.6603642978113385e-06, 
    balance_weight= 0.4636860245832892, 
    volatility_weight= 0.3533040998293018) -> np.ndarray:
    """
    Combines z-score fit/cap synergy with median stabilization and volatility damping 
    with variance-scaled tie-breaking for robust online bin packing dynamics.
    """
    if bins_remain_cap.size == 0:
        return np.array([], dtype=np.float64)
    
    orig_cap = np.max(bins_remain_cap)
    if orig_cap < zero_threshold or item < zero_threshold:
        return np.where(
            bins_remain_cap >= item, 
            1.0 / (bins_remain_cap - item + std_zscore_eps), 
            -np.inf
        )
    
    valid = bins_remain_cap >= item
    if not valid.any():
        return np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)
    
    leftover = bins_remain_cap - item
    utilization = (orig_cap - bins_remain_cap) / orig_cap
    tightness = item / (bins_remain_cap + tightness_denominator_eps)
    
    # Z-score normalization of fit (best-fit) and capacity (worst-fit) metrics
    elig_fit = 1.0 / (leftover[valid] + std_zscore_eps)
    mean_fit, std_fit = elig_fit.mean(), elig_fit.std()
    z_fit = (1.0 / (leftover + std_zscore_eps) - mean_fit) / (std_fit + std_zscore_eps)
    
    elig_cap = bins_remain_cap[valid]
    mean_cap, std_cap = elig_cap.mean(), elig_cap.std()
    z_cap = (bins_remain_cap - mean_cap) / (std_cap + std_zscore_eps)
    
    # Dynamic hybrid weighting with exponential utilization enhancer
    primary = (tightness * z_fit + (1.0 - tightness) * z_cap) * np.exp(utilization * tightness)
    
    # Entropy-guided median stabilization to avoid capacity fragmentation
    med_cap = np.median(bins_remain_cap)
    balance = balance_weight * np.abs(bins_remain_cap - med_cap) / (orig_cap + balance_denominator_eps)
    
    # Multi-scale tie-breaking with volatility damping and variance scaling
    vol_damping = volatility_weight * np.exp(-leftover)
    valid_leftover = leftover[valid]
    std_leftover = valid_leftover.std() if len(valid_leftover) > 1 else min_std_value
    epsilon = grad_epsilon / (std_leftover + grad_std_eps)
    grad_sensitivity = epsilon * (item / (bins_remain_cap + tightness_denominator_eps))
    
    return np.where(
        valid,
        primary + balance + vol_damping + grad_sensitivity,
        -np.inf
    )
