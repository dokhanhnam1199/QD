```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines dynamic tightness-proximity weighting with adaptive normalization. 
    Large items favor tight fits, small items balance proximity to system average, 
    and tie-breaker minimizes leftover variance, optimizing entropy reduction.
    """
    
    def minmax_normalize(arr):
        min_val = np.min(arr)
        max_val = np.max(arr)
        if max_val - min_val < 1e-9:
            return np.zeros_like(arr, dtype=np.float64)
        return (arr - min_val) / (max_val - min_val + 1e-9)
    
    if bins_remain_cap.size == 0:
        return np.array([], dtype=np.float64)
    
    # Edge case: negligible item
    if item < 1e-9:
        return np.where(bins_remain_cap >= 0, bins_remain_cap, -np.inf)
    
    # Identify eligible bins
    eligible = bins_remain_cap >= (item - 1e-9)
    if not np.any(eligible):
        return np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)
    
    # System-wide statistics
    system_avg = np.mean(bins_remain_cap)
    system_std = np.std(bins_remain_cap)
    system_cv = system_std / (system_avg + 1e-9) if system_avg > 0 else 0.0
    
    # Item classification based on adaptive threshold
    large_item_threshold = system_avg * 0.7 * (1 + 0.3 * system_cv)
    is_large_item = item > large_item_threshold
    
    # Extract eligible bin data
    el_remain = bins_remain_cap[eligible]
    leftover = el_remain - item
    
    # Metric calculations
    tightness = item / (el_remain + 1e-9)  # Higher for tighter fits
    proximity = np.abs(leftover - system_avg)  # Closer to system average
    
    # Metric normalization
    tight_norm = minmax_normalize(tightness)
    proximity_norm = minmax_normalize(-proximity)  # Higher when proximity is lower
    
    # Dynamic weight allocation
    w_tight = 0.55 if is_large_item else 0.4
    w_prox = 0.45 if is_large_item else 0.6
    
    # Base score with bias toward classification
    base_score = w_tight * tight_norm + w_prox * proximity_norm
    
    # Tie-breaker for fine-grained entropy reduction
    tie_breaker = -1e-9 * (leftover - 0.5 * system_avg)  # Favor moderate leftovers
    
    # Final priority with layered tie-breaker
    final_score = base_score + tie_breaker
    
    # Build result array
    result = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)
    result[eligible] = final_score
    return result
```
