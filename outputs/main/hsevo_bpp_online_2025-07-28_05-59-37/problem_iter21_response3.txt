```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Evolutionary heuristic combining adaptive fit prioritization with entropy-aware layering, featuring:
    1. Min-max normalized fit efficiency
    2. Dynamic weight allocation based on item-system proportionality
    3. Reinforcement through utilization stratification
    4. Entropy-sensitive balance via median stabilization
    """
    if bins_remain_cap.size == 0:
        return np.array([], dtype=np.float64)
    
    orig_cap = np.max(bins_remain_cap)
    if item <= 1e-9 or orig_cap <= 1e-9:
        return np.where(
            bins_remain_cap >= item,
            bins_remain_cap - item + 1e-9,
            -np.inf
        )
    
    eligible = bins_remain_cap >= item
    if not np.any(eligible):
        return np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)
    
    # Core metrics derivatives
    leftover = bins_remain_cap - item
    current_util = (orig_cap - bins_remain_cap) / (orig_cap + 1e-9)
    
    # Adaptive fit normalization
    fit_factor = 1.0 / (leftover + 1e-9)
    fit_clipped = np.clip(fit_factor[eligible], None, np.percentile(fit_factor[eligible], 99.5))
    fit_range = fit_clipped.max() - fit_clipped.min() + 1e-9
    
    # Dynamic weighting mechanism
    system_avg = bins_remain_cap.mean()
    util_response = np.clip(0.5 + 2 * np.abs(current_util - 0.5), 0, 1)
    item_proximity = item / (system_avg + 1e-9)
    
    # Reinforcement potential
    cap_deviation = bins_remain_cap / (np.median(bins_remain_cap) + 1e-9)
    fragility = (orig_cap - bins_remain_cap) / (orig_cap + system_avg + 1e-9)
    
    # Composite priority construction
    fit_component = (fit_factor - fit_clipped.min()) / fit_range
    util_component = current_util * (1.0 + cap_deviation)
    
    # Final weighted integration
    weight_scale = np.clip(0.5 + item_proximity, 0.75, 1.5)
    entropy_factor = np.where(
        bins_remain_cap < system_avg,
        1.0 + 0.3 * (1.0 - util_response),
        1.0
    )
    
    priority = (
        fit_component * weight_scale + 
        util_component * (0.5 + 0.5 * fragility) *
        entropy_factor * np.sqrt(item_proximity)
    )
    
    return np.where(eligible, priority, -np.inf)
```
