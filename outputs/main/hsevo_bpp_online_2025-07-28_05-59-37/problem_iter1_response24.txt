```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Priority function combining best-fit with future space reservation heuristic."""
    valid = bins_remain_cap >= item
    if not np.any(valid):
        return np.full_like(bins_remain_cap, -np.inf)
    
    # Bins that can fit another item of the same size after placement
    enough_for_another = (bins_remain_cap - item) >= item
    
    # High-priority group: valid bins with space for another item
    high_priority = valid & enough_for_another
    # Low-priority group: valid bins without space for another item
    low_priority = valid & ~enough_for_another
    
    # Use large constant to prioritize space-reservation group
    BIG = 1e9
    priority = np.full_like(bins_remain_cap, -np.inf, dtype=float)
    
    # For high-priority bins: prioritize tightest fit for two items
    priority[high_priority] = BIG - (bins_remain_cap[high_priority] - 2 * item)
    
    # For low-priority bins: use standard best-fit
    priority[low_priority] = - (bins_remain_cap[low_priority] - item)
    
    return priority
```
