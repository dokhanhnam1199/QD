```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    if bins_remain_cap.size == 0:
        return np.array([], dtype=np.float64)
    
    orig_cap = np.max(bins_remain_cap)
    
    # Edge cases: negligible item or bin capacity
    if item <= 1e-9 or orig_cap <= 1e-9:
        return np.where(
            bins_remain_cap >= item,
            0.1 / (bins_remain_cap + 1e-9) - 0.01 * bins_remain_cap,
            -np.inf
        )
    
    eligible = bins_remain_cap >= item
    if not np.any(eligible):
        return np.full_like(bins_remain_cap, -np.inf)
    
    # Core bin metrics for eligible bins
    e_rc = bins_remain_cap[eligible]
    e_leftover = e_rc - item
    e_tightness = item / e_rc
    e_utilization = (orig_cap - e_rc) / orig_cap
    
    # System-wide statistics
    system_avg = bins_remain_cap.mean()
    system_std = bins_remain_cap.std()
    system_cv = system_std / (system_avg + 1e-9)
    
    # Normalized metric layers
    fit_quality = 1.0 / (e_leftover + 1e-9)
    z_fit = (fit_quality - fit_quality.mean()) / (fit_quality.std() + 1e-9)
    
    z_rc = (e_rc - e_rc.mean()) / (e_rc.std() + 1e-9)
    
    # Dynamic hybridization based on item tightness distribution
    alpha = np.clip(1.0 - e_tightness.mean(), 0.3, 0.7)
    hybrid_score = alpha * z_fit + (1 - alpha) * z_rc
    
    # Gradient-targeted exponential modulation
    item_reso_factor = 1.0 + np.sqrt((item / system_avg))
    enhancer = np.exp(e_utilization * e_tightness * item_reso_factor)
    
    # Entrophy-aware balance with covariance-based weighting
    balance_term = -np.abs(e_leftover - system_avg)
    
    if len(e_leftover) > 1:
        covar_factor = np.cov(fit_quality, balance_term)[0, 1] + 1e-9
        weight_modulation = np.sign(covar_factor) * np.log(1.0 + system_cv / np.abs(covar_factor))
    else:
        weight_modulation = 1.0
    
    balance_weight = 0.1 * system_cv * weight_modulation
    
    # Fragility mitigation with dynamic thresholding
    fragility_mask = (e_leftover < (system_avg - system_std))
    fragility_penalty = np.zeros_like(balance_term)
    fragility_penalty[fragility_mask] = -1e4 * system_cv
    
    # Final priority assembly with epsilon-perturbed tie-breaking
    priority_core = (hybrid_score * enhancer + balance_weight * balance_term + fragility_penalty)
    tiebreaker = 1e-10 * (1.0 / (e_leftover + 1e-9))
    final_priority = priority_core + tiebreaker
    
    full_array = np.full_like(bins_remain_cap, -np.inf)
    full_array[eligible] = final_priority
    
    return full_array
```
