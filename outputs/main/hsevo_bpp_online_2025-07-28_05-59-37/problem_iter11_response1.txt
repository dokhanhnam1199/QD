```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    v2.3: Adaptive multi-layer synergy with variance-controlled Z-scoring, 
    gradient-harnessed exponential enhancer, and entropy-covariance balancing.
    """
    if bins_remain_cap.size == 0:
        return np.array([], dtype=np.float64)
    
    # Edge case: negligible item or bin capacity
    if item <= 1e-9:
        return np.where(bins_remain_cap >= 0, bins_remain_cap * 0.0, -np.inf)
    
    # Identify eligible bins where item fits
    eligible = bins_remain_cap >= item
    if not np.any(eligible):
        return np.full_like(bins_remain_cap, -np.inf)
    
    # Core metrics for eligible bins
    e_rc = bins_remain_cap[eligible]
    e_leftover = e_rc - item
    e_tightness = item / (e_rc + 1e-9)
    e_fit_quality = 1.0 / (e_leftover + 1e-9)
    
    # System-wide statistics
    system_avg = bins_remain_cap.mean()
    system_std = bins_remain_cap.std()
    system_cv = system_std / (system_avg + 1e-9) if system_avg > 0 else 0
    
    # Z-score normalization for dynamic metric adaptation
    if len(e_rc) > 1:
        z_cap = (e_rc - e_rc.mean()) / (e_rc.std() + 1e-9)
        z_fit = (e_fit_quality - e_fit_quality.mean()) / (e_fit_quality.std() + 1e-9)
    else:
        z_cap = np.zeros_like(e_rc)
        z_fit = np.zeros_like(e_fit_quality)
    
    # Dynamic weighting based on metric variance dominance
    var_fit = e_fit_quality.var() if len(e_rc) > 1 else 0
    var_cap = e_rc.var() if len(e_rc) > 1 else 0
    cross_weight = var_cap / (var_fit + var_cap + 1e-9)
    
    # Hybrid metric with continuity-aware blending
    composite_z = cross_weight * z_fit + (1 - cross_weight) * z_cap
    alpha = np.clip(1.0 - e_tightness.mean(), 0.3, 0.7)
    hybrid_metric = alpha * composite_z + (1 - alpha) * e_tightness
    
    # Adaptive gradient-driven exponential enhancer
    item_reso_factor = 1.0 + np.sqrt((item + 1e-9) / (system_avg + 1e-9)) if system_avg > 0 else 1.0
    oversized_flag = e_leftover < 0.1 * e_rc  # High-urgency marker
    frag_density = np.clip((e_leftover - system_avg) / (2 * system_std + 1e-9), -1, 1) if system_std > 0 else 0
    enhancer = np.exp(hybrid_metric * item_reso_factor * (1.5 + 0.3 * frag_density * over)))
    
    # Entropy-sensitive balance with covariance control
    if len(e_rc) > 1:
        fragility_mask = e_leftover < (system_avg - system_std)
        balance_term = -np.abs(e_leftover - system_avg) * (1 + fragility_mask)
        covar_factor = np.cov(e_fit_quality, balance_term)[0, 1] + 1e-9 if len(e_rc) > 1 else 0
        dynamic_modulation = np.sign(covar_factor) * np.log(1.0 + system_cv / (np.abs(covar_factor) + 1e-9))
    else:
        balance_term = -np.abs(e_leftover - system_avg)
        dynamic_modulation = 1.0
    balance_weight = 0.05 * system_cv * dynamic_modulation * over)))
    
    # Fragility-aware reinforcement with dynamic penalty zones
    fragility_threshold = system_avg - system_std
    fragility_reward = np.zeros_like(e_tightness)
    reward_mask = (e_leftover > fragility_threshold) & (e_leftover < system_avg)
    fragility_reward[reward_mask] = 0.1 * (e_leftover[reward_mask] - fragility_threshold)
    fragility_penalty = -1e4 * system_cv * (1.0 - e_tightness) * (e_leftover < fragility_threshold)
    
    # Multi-tiered perturbation for degeneracy avoidance
    v_optimal_tie = 1e-10 * (1.0 / (e_leftover + 1e-9))
    v_mediation = 1e-8 * np.random.rand(len(e_leftover)) * over.))  # Random stabilization noise
    
    # Final priority synthesis
    final_priority = enhancer + balance_weight * balance_term + fragility_penalty + v_optimal_tie + v_mediation
    
    # Matrix assembly and return
    full_priority = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)
    full_priority[eligible] = final_priority
    
    return full_priority
```
