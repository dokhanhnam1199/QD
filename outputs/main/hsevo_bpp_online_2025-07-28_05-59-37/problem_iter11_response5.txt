```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    v2: Z-normalized synergy + cross-metric variance adaptation + gradient-boosted enhancer 
    + fragility-aware balancing with dynamic entropy-sensitive weights.
    """
    eps = 1e-9
    if bins_remain_cap.size == 0:
        return np.array([], dtype=np.float64)
    
    eligible = bins_remain_cap >= item
    if not eligible.any():
        return np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)
    
    # System stats
    C_est = bins_remain_cap.max() if bins_remain_cap.size > 0 else 1.0
    system_avg = np.mean(bins_remain_cap)
    system_std = np.std(bins_remain_cap) + eps
    system_cv = system_std / (system_avg + eps)
    remaining = bins_remain_cap + eps
    
    # Core metrics
    leftover = remaining - item + eps
    utilization = item / remaining
    inv_leftover = 1.0 / leftover
    
    # Z-synergy (tight-fit * utilization)
    phi = inv_leftover * utilization
    phi_z = ((phi[eligible] - phi[eligible].mean()) / phi[eligible].std())[eligible]
    
    # Z-cap (remaining capacity adaptation)
    cap_z = ((remaining - np.mean(remaining)) / np.std(remaining + eps))[eligible]
    
    # Cross-metric variance adaptation
    var_phi = np.var(phi[eligible])
    var_cap = np.var(remaining[eligible])
    cross_weight = var_cap / (var_phi + var_cap + eps) if (var_phi + var_cap) > 1e-7 else 0.5
    
    # Adaptive curvature factor
    curvature = 1.0 + np.arctan((phi_z.mean() - cap_z.mean()))
    
    # Composite base score
    composite = cross_weight * phi_z + (1 - cross_weight) * cap_z * curvature
    
    # Gradient-driven enhancer (concentration + deviation sensitivity)
    leftover_norm = (leftover - system_avg) / (3 * system_std + eps)
    tight_density = np.clip(1.0 - np.abs(leftover_norm), 0, 1)  # Concentration zone control
    grad_scale = np.where(item > system_avg, 
                         1.0 + 2.0 * utilization * system_std, 
                         1.0 + utilization)  # Dynamic gradient sensitivity
    enhancer = np.exp(composite * tight_density * grad_scale)
    
    # Entropy-sensitive load balance (v0-style system variance coupling)
    filled_frac = (C_est - remaining) / (C_est + eps)
    system_var = np.var(bins_remain_cap) / (C_est**2 + eps)
    balance_factor = filled_frac * (1 + system_var)
    balance_z = (balance_factor - balance_factor[eligible].mean()) / balance_factor[eligible].std()
    
    # Fragility-aware perturbation (exponential decay approach)
    fragility = 1.0 - np.exp(-leftover / (0.2 * C_est + eps))
    frag_weight = 0.25 * system_var * np.clip((1 - utilization), 0, 1)
    frag_term = np.where(leftover < 0.15 * C_est, -frag_weight * fragility, -0.01 * frag_weight * fragility)
    
    # Dynamic weight optimization
    entropy_weight = 0.1 * system_cv 
    fragility_weight = 0.05 * (1 - system_cv) * system_var
    
    # Final score with hierarchical reinforcement
    scores = np.full_like(bins_remain_cap, -np.inf)
    scores[eligible] = (
        composite * enhancer 
        + entropy_weight * balance_z 
        + fragility_weight * frag_term[eligible]
    ) * (1 + system_var)
    
    return scores
```
