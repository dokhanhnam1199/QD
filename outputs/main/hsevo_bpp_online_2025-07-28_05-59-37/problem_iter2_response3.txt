```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Combines Best Fit with dynamic tie-breaking by utilization ratio scaled adaptively.
    
    Uses Best Fit's negative leftover space as primary priority, augmented with a 
    dynamic epsilon-weighted utilization ratio (item/bin_remaining) for tie-breaking.
    Epsilon scales inversely with leftover standard deviation to balance adaptability 
    and stability.
    """
    mask = bins_remain_cap >= item
    leftover = bins_remain_cap - item
    best_fit = -leftover
    
    # Dynamic epsilon based on leftover variance (less variance => higher epsilon)
    valid_leftover = leftover[mask]
    std = np.std(valid_leftover) if len(valid_leftover) > 1 else 1e-6
    epsilon = 1e-4 / (std + 1e-9)
    
    # Utilization ratio (item / remaining_cap) as adaptive tie-breaker
    utilization = np.zeros_like(bins_remain_cap, dtype=np.float64)
    np.divide(item, bins_remain_cap, where=mask, out=utilization)
    
    # Combined priority with dynamic scaling
    priority = np.where(mask, best_fit + epsilon * utilization, -np.inf)
    return priority
```
