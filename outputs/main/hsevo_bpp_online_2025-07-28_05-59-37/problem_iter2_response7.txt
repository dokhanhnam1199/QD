```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Adaptive priority combining tight-fit best-fit & small-item worst-fit with utilization tie-breaker."""
    possible = bins_remain_cap >= item
    leftover = bins_remain_cap - item
    
    # Dynamic tightness threshold per bin (item > 50% of current bin capacity)
    tight = (item > bins_remain_cap / 2) & possible
    
    # Primary heuristics: Best Fit for tight fits, Worst Fit for others
    primary = np.where(tight, -leftover, leftover)
    
    # Tie-breaker: Bin utilization (normalized current occupancy) with epsilon weight
    utilization = 1 - bins_remain_cap
    tie_breaker = 1e-6 * utilization  # Small weight to avoid overriding primary rules
    
    # Composite priority: synergized primary decision + adaptive utilization bias
    priority = primary + tie_breaker
    
    return np.where(possible, priority, -np.inf)
```
