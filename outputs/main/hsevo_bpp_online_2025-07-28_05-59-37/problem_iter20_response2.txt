```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Adaptive priority combining dynamic weights, min-max normalization,
    proximity penalties, and fragility-aware reinforcement for online BPP.
    """
    eps = 1e-9
    if bins_remain_cap.size == 0:
        return np.array([], dtype=np.float64)
    
    if item < eps:
        return np.where(bins_remain_cap >= 0, 0.01 * bins_remain_cap, -np.inf)
    
    eligible = bins_remain_cap >= item
    if not eligible.any():
        return np.full_like(bins_remain_cap, -np.inf)
    
    orig_cap = bins_remain_cap.max() if bins_remain_cap.max() > 0 else item * 2
    remaining_cap = bins_remain_cap[eligible]
    leftover = remaining_cap - item + eps
    
    # Metric calculations
    fit_tightness = item / (remaining_cap + eps)
    util_after = (orig_cap - remaining_cap + item) / (orig_cap + eps)
    
    # Min-max normalization
    def minmax_normalize(x):
        xmin, xmax = x.min(), x.max()
        if xmax > xmin:
            return (x - xmin) / (xmax - xmin + eps)
        return np.full_like(x, 0.5)
    
    norm_fit = minmax_normalize(fit_tightness)
    norm_util = minmax_normalize(util_after)
    
    # Dynamic weights based on item size
    is_large = item > 0.7 * orig_cap
    weight_fit = 0.7 if is_large else 0.4
    weight_util = 0.3 if is_large else 0.6
    base_score = weight_fit * norm_fit + weight_util * norm_util
    
    # System metrics
    system_avg = bins_remain_cap.mean()
    system_std = bins_remain_cap.std() + eps
    
    # Proximity penalty
    proximity = np.abs(leftover - system_avg) / system_std
    proximity_penalty = np.exp(-proximity)
    
    # Reinforcement term
    usability = np.clip((system_avg - leftover) / system_std, -1.0, 1.0)
    reinforcer = util_after * np.abs(usability)
    
    # Tie-breaker
    tie_breaker = 0.01 * (leftover / (orig_cap + eps))
    
    # Final score assembly
    eligible_scores = (
        base_score * proximity_penalty 
        + reinforcer 
        + tie_breaker
    )
    
    scores = np.full_like(bins_remain_cap, -np.inf)
    scores[eligible] = eligible_scores
    
    return scores
```
