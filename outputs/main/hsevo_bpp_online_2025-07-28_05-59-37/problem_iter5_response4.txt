```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Adaptive priority combining tight-fit best-fit/worst-fit + normalized utilization bias + exponential fragmentation penalty."""
    possible = bins_remain_cap >= item
    leftover = bins_remain_cap - item
    
    if not possible.any():
        return np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)
    
    # Estimate system state (bin capacity)
    C_est = bins_remain_cap.max() if bins_remain_cap.size > 0 else 1.0
    
    # Dynamic tight-fit classification (>50% of current bin cap)
    tight = (item > bins_remain_cap / 2) & possible
    
    # Best Fit for tight fits, Worst Fit for remaining
    best_fit = -leftover
    worst_fit = leftover
    primary = np.where(tight, best_fit, worst_fit)
    
    # Tie-breaker 1: Normalized utilization (higher filled fraction preferred)
    filled_frac = (C_est - bins_remain_cap) / C_est
    normalized_util = filled_frac
    
    # Tie-breaker 2: Exponential penalty for fragment leftovers (e^-lambda*x)
    frag_penalty = -np.expm1(-(leftover / C_est))  # Smooths penalty at zero
    
    # Weights: Tie-breakers with entropy-aware scaling
    util_weight = 1e-3 * (1 + normalized_util)  
    frag_weight = 1e-4
    
    # Composite score with synergistic multi metrics
    priority = primary + util_weight * normalized_util + frag_weight * frag_penalty
    
    return np.where(possible, priority, -np.inf)
```
