```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Priority combines Best Fit (leftover minimization) and Worst Fit (remaining space maximization) dynamically.
    Weighting adjusts based on item's relative size to current maximum bin capacity estimate.
    """
    if len(bins_remain_cap) == 0:
        return np.array([], dtype=np.float64)
    
    C_est = bins_remain_cap.max()
    valid = bins_remain_cap >= item
    
    if not np.any(valid):
        return -np.inf * np.ones_like(bins_remain_cap)
    
    relative_size = item / C_est
    weight = relative_size ** 2  # Dynamic weight emphasizes Best Fit for larger items
    
    # Blend Best Fit and Worst Fit: [0, 1] weight on Best Fit, [1, 0] on Worst Fit
    priorities = np.where(valid,
                          weight * (item - bins_remain_cap) + (1 - weight) * bins_remain_cap,
                          -np.inf)
    return priorities
```
