```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    if bins_remain_cap.size == 0:
        return np.array([], dtype=np.float64)

    orig_cap = np.max(bins_remain_cap)
    if orig_cap <= 1e-9 or item <= 1e-9:
        base_score = np.where(bins_remain_cap >= item,
            (bins_remain_cap - item) * -1e-5 + (bins_remain_cap * 1e-7),
            -np.inf)
        return base_score

    eligible = bins_remain_cap >= item
    if not np.any(eligible):
        return np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)

    leftover = bins_remain_cap - item
    utilization = (orig_cap - bins_remain_cap) / orig_cap
    tightness = item / (bins_remain_cap + 1e-9)
    elig_tight = tightness[eligible]
    elig_left = leftover[eligible]
    elig_util = utilization[eligible]
    elig_rc = bins_remain_cap[eligible]

    system_avg = bins_remain_cap.mean()
    system_std = bins_remain_cap.std()
    system_cv = system_std / (system_avg + 1e-9)

    volatilify = lambda x: (x - system_avg) / (system_std + 1e-9)
    item_vol_score = volatilify(item)
    volatile_item = abs(item_vol_score) > 1.0
    large_item = item_vol_score > 0.0

    perturbed_z_vol = lambda x: (x - x.mean()) / (x.std(ddof=1) + 1e-9) * (1 + 1e-5 * x.std())

    fit_quality = 1.0 / (leftover + 1e-9)
    elig_fit = fit_quality[eligible]

    tight_z = perturbed_z_vol(elig_tight)
    fit_z = perturbed_z_vol(elig_fit)
    util_z = perturbed_z_vol(elig_util)
    cap_z = perturbed_z_vol(elig_rc)

    fit_var_score = max(0.1, fit_z.var(ddof=1, dtype=np.float64))
    tight_var_score = max(0.1, tight_z.var(ddof=1, dtype=np.float64))
    weight_fit = tight_var_score / (fit_var_score + tight_var_score)
    weight_tight = fit_var_score / (fit_var_score + tight_var_score)

    primary_layers = (
        weight_tight * (1 + util_z) ** 2 * elig_tight +
        weight_fit * (1 - elig_tight) * elig_fit
    )
    primary_score = (primary_layers - np.min(primary_layers))/(np.ptp(primary_layers) + 1e-9)

    base_util_term = np.where(
        large_item,
        np.exp(util_z + tight_z),
        np.sqrt((1.0 - util_z) * (1.0 - tight_z) + 1e-9)
    )
    dynamic_gamma = np.clip(0.8 * tight_z + 0.2 * (1 - system_cv), 0.5, 1.5)
    enhancer = base_util_term ** dynamic_gamma

    fragility_mask = np.logical_or(bins_remain_cap > (system_avg + 2 * system_std), bins_remain_cap < (system_avg - 2 * system_std))
    fragility_score = np.where(
        fragility_mask,
        system_std ** 2 / (np.abs(bins_remain_cap - system_avg) + 1e-9),
        1.0
    )[eligible]

    balance_term = -np.abs(leftover - system_avg) * (1.0 + system_cv ** 2)
    balance_decay = np.exp(-0.2 * (system_cv * tight_z + system_std / (system_avg - item + 1e-9)))

    entropy_component = balance_term * balance_decay * fragility_score
    unnormalized_score = (primary_score * enhancer) + 0.1 * entropy_component

    seed = int(np.abs(item * 1e5) % 1e9)
    np.random.seed(seed)
    perturbation = 1e-8 * np.random.normal(size=leftover.shape)

    priority = unnormalized_score + perturbation[eligible]

    return np.where(eligible, priority, -np.inf)
```
