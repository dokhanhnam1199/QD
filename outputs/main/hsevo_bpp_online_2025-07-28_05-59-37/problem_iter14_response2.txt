```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Online BPP priority that blends Z-score weighted fit (BF) and tightness (FF) via adaptive variance ratios,
    with item classification (large/tiny) driving climb envelope modulation and exponentially decayed 
    fit-scoring to balance BF/FF tradeoffs. Stability-enhanced tie-breaking via median proximity sensitivity.
    """
    if bins_remain_cap.size == 0:
        return np.array([], dtype=np.float64)
    
    if item <= 1e-9:
        return np.where(bins_remain_cap >= 0, 0.01 * bins_remain_cap, -np.inf)
    
    eligible = bins_remain_cap >= item
    if not np.any(eligible):
        return np.full_like(bins_remain_cap, -np.inf)
    
    # Capacity metrics
    C_est = bins_remain_cap.max() if bins_remain_cap.max() > 0 else item * 2
    leftover = bins_remain_cap - item
    tightness = item / (bins_remain_cap + 1e-9)
    fit_score = 1.0 / (leftover + 1e-9)
    
    # Z-score normalization
    def z_score(x):
        mean = x[eligible].mean()
        std = x[eligible].std()
        return (x - mean) / (std + 1e-9)
    
    tight_z = z_score(tightness)
    fit_z = z_score(fit_score)
    
    # Adaptive weighting by variance
    fit_var, tight_var = fit_z.var(), tight_z.var()
    var_ratio = fit_var / (fit_var + tight_var + 1e-9)
    base_score = (var_ratio * fit_z) + ((1 - var_ratio) * tight_z)
    
    # Item classification
    is_large = item > 0.7 * C_est
    grad_factor = 1.35 if is_large else 1.0
    utilization = 1.0 - (bins_remain_cap / C_est)
    
    # Energy climbing envelope
    climb_env = grad_factor * np.exp(0.3 * tightness + 0.2 * utilization)
    
    # Fragmentation control
    frag_penalty = 0.2 * np.exp(-leftover / (C_est / 3 + 1e-9))
    
    # Stability preservation
    median_cap = np.median(bins_remain_cap[eligible]) if eligible.any() else bins_remain_cap.median()
    proximity = np.abs(bins_remain_cap - median_cap) / (C_est + 1e-9)    
    stability = 0.02 * bins_remain_cap.std() * np.abs(tight_z) * proximity
    
    # Priority construction
    priority = (base_score * climb_env) - frag_penalty + stability
    
    # BF bias with soft exponential decay
    priority *= np.exp(-0.05 * leftover / (C_est + 1e-9))
    
    # Reinforcement-style tiebreaker
    priority += 1e-7 * np.random.normal(0, 1, priority.shape)
    
    return np.where(eligible, priority, -np.inf)
```
