```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    if bins_remain_cap.size == 0:
        return np.array([], dtype=np.float64)
    
    orig_cap = np.max(bins_remain_cap)
    if orig_cap <= 1e-9 or item <= 1e-9:
        return np.where(bins_remain_cap >= item, bins_remain_cap - item + 1e-9, -np.inf)
    
    eligible = bins_remain_cap >= item
    if not np.any(eligible):
        return np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)
    
    # System metrics
    system_avg = bins_remain_cap.mean()
    system_std = bins_remain_cap.std()
    system_cv = system_std / (system_avg + 1e-9)
    
    # Item classification
    relative_size = item / (system_avg + 1e-9)
    large_item = relative_size > 1.0
    
    # Per-bin metrics
    leftover = bins_remain_cap - item
    tightness = item / (bins_remain_cap + 1e-9)
    utilization = (orig_cap - bins_remain_cap) / (orig_cap + 1e-9)
    
    # Adaptive weight calculation using smooth transition
    fit_weight = 1.0 / (1.0 + np.exp(-2.0 * (relative_size - 0.5)))
    fit_weight = np.clip(fit_weight, 0.3, 0.8)
    
    # Normalized fit and utilization components
    fit_component = -leftover
    fit_mean = fit_component[eligible].mean()
    fit_std = fit_component[eligible].std()
    z_fit = (fit_component - fit_mean) / (fit_std + 1e-9)
    
    util_component = utilization
    util_mean = util_component[eligible].mean()
    util_std = util_component[eligible].std()
    z_util = (util_component - util_mean) / (util_std + 1e-9)
    
    # Hybrid score with adaptive weights
    hybrid = fit_weight * z_fit + (1.0 - fit_weight) * z_util
    
    # Entropy-driven balance adjustment
    balance_factor = system_cv * np.where(large_item, 1.5, 1.0)
    balance_term = -np.abs(leftover - system_avg) / (system_std + 1e-9)
    balanced_hybrid = hybrid + balance_factor * balance_term
    
    # Reinforcement-inspired term: promote leftover near median
    median_remain = np.median(bins_remain_cap[eligible])
    rem_gap = np.abs(leftover - median_remain)
    reinforcer = np.exp(-rem_gap / (orig_cap + 1e-9))
    
    # Adaptive reinforcement weight
    reinforcer_weight = 0.5 * (1.0 - system_cv + relative_size)
    final_score = balanced_hybrid + reinforcer * reinforcer_weight
    
    # Utilization boost for high-util bins
    util_boost = np.sqrt(utilization.clip(0, 1)) * 0.2 * system_cv
    final_score += util_boost
    
    return np.where(eligible, final_score, -np.inf)
```
