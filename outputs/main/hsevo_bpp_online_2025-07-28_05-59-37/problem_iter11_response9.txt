```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Adaptive synergy prioritization with exponential enhancement and entropy-dynamic frag control.
    Z-synergy augmented through normalized multi-metric fusion and predictive entropy damping.
    """
    eps = 1e-9
    if bins_remain_cap.size == 0:
        return np.array([], dtype=np.float64)
    
    eligible = bins_remain_cap >= item
    if not eligible.any():
        return np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)
    
    # Metric computations
    leftover = bins_remain_cap - item
    origin_cap = np.max(bins_remain_cap)
    fit_quality = 1.0 / (leftover + eps)
    tightness = item / (bins_remain_cap + eps)
    utilization = (origin_cap - bins_remain_cap) / (origin_cap + eps)
    
    # Z-score normalization across eligible bins
    elig = {
        'fit': fit_quality[eligible],
        'tight': tightness[eligible],
        'util': utilization[eligible]
    }
    mean = {k: np.mean(v) for k, v in elig.items()}
    std = {k: np.std(v) for k, v in elig.items()}
    
    # Calculate normalized fields
    z_fit = (fit_quality - mean['fit']) / (std['fit'] + eps)
    z_tight = (tightness - mean['tight']) / (std['tight'] + eps)
    z_util = (utilization - mean['util']) / (std['util'] + eps)
    
    # Adaptive synergy with deep utilization coupling (from v1 synergy)
    synergy = z_tight * (1 + z_util)  # v1's cross-metric synergy
    
    # Exponential enhancer (from v0) with raw metric interaction
    enhancer = np.exp(utilization * tightness)  # Reinforced BF-like prioritization
    
    # Primary adaptive score with layered reinforcement
    primary_score = synergy * enhancer
    
    # Entropy-sensitive fragmentation control
    sys_entropy = bins_remain_cap.std() / (origin_cap + eps)
    frag_penalty = 1.0 - np.exp(-leftover / (origin_cap + eps))  # Differentiable frag metric
    frag_weight = 0.2 * (1.0 + sys_entropy)  # Dynamic entropy scaling
    
    # Perturbed threshold tie-breaker (enhanced volatility damping)
    tie_breaker = 0.075 * np.exp(-leftover) * (1.0 + sys_entropy)  # Entropy-coupled decay
    
    # Final score with dynamic entropy mitigation and multi-metric balance
    scores = np.where(
        eligible,
        primary_score - frag_weight * frag_penalty + tie_breaker,
        -np.inf
    )
    
    return scores
```
