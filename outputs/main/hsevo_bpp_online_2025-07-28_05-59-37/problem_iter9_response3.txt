```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    v2: State-aware normalization with cross-metric variance adaptation, gradient-boosted enhancer, 
    and multi-layer entropy-sensitive scoring with fragility control and perturbed thresholds.
    """
    if bins_remain_cap.size == 0:
        return np.array([], dtype=np.float64)
    
    orig_cap = np.max(bins_remain_cap)
    if orig_cap <= 1e-9 or item <= 1e-9:
        return np.where(
            bins_remain_cap >= item,
            0.1 * bins_remain_cap / (orig_cap + 1e-5) - (bins_remain_cap - item),
            -np.inf
        )
    
    eligible = bins_remain_cap >= item
    if not np.any(eligible):
        return np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)
    
    # Metric initialization
    leftover = bins_remain_cap - item
    tightness = item / (bins_remain_cap + 1e-9)
    fit_quality = 1.0 / (leftover + 1e-9)
    
    elig_fit = fit_quality[eligible]
    elig_cap = bins_remain_cap[eligible]
    elig_tight = tightness[eligible]
    
    # State-aware Z-score with variance-controlled calibration
    mean_fit, std_fit = np.mean(elig_fit), np.std(elig_fit)
    z_fit = (fit_quality - mean_fit) / (std_fit + 1e-9)
    
    mean_cap, std_cap = np.mean(elig_cap), np.std(elig_cap)
    z_cap = (bins_remain_cap - mean_cap) / (std_cap + 1e-9)
    
    # Cross-metric variance weighting (higher variance metric dominates)
    var_fit = np.var(elig_fit)
    var_cap = np.var(elig_cap)
    cross_weight = var_cap / (var_fit + var_cap + 1e-9) if (var_fit + var_cap) > 1e-7 else 0.5
    
    # Composite score with adaptive curvature
    curvature_factor = 1.0 + np.arctan(np.mean(z_fit) - np.mean(z_cap))
    composite_z = cross_weight * z_fit + (1 - cross_weight) * z_cap * curvature_factor
    
    # Gradient-driven dynamic enhancer
    system_avg = np.mean(bins_remain_cap)
    system_std = np.std(bins_remain_cap)
    tight_density = np.clip(1.0 - (leftover - system_avg) / (3 * system_std + 1e-9), 0, 1)
    
    grad_scale = np.where(item > system_avg,
                          1.0 + 2.0 * tightness * system_std,
                          1.0 + tightness)
    
    enhancer = np.exp(composite_z * tight_density * grad_scale)
    
    # Entropy-sensitive load balance with perturbed thresholds
    balance_term = -(np.abs(leftover - system_avg) + 1e-5 * (leftover - system_avg))
    system_cv = system_std / (system_avg + 1e-9)
    
    # Fragility-sensitive reinforcement
    fragility_factor = 1.0 - np.exp(-leftover / (0.25 * orig_cap + 1e-9))
    fragility_term = np.where(leftover > 0.1 * orig_cap,
                              -0.1 * fragility_factor,
                              -0.3 * fragility_factor)
    
    # Dynamic weight cross-metric adaptation
    var_zfit = np.var(z_fit[eligible])
    var_zcap = np.var(z_cap[eligible])
    weight_balance = 0.1 * system_cv * var_zfit / (var_zfit + var_zcap + 1e-9)
    weight_fragility = 0.05 * system_cv * (1 - system_cv) * (var_zcap / (var_zfit + var_zcap + 1e-9))
    
    # Final priority with hierarchical reinforcement
    priority = composite_z * enhancer + weight_balance * balance_term + weight_fragility * fragility_term
    
    return np.where(eligible, priority, -np.inf)
```
