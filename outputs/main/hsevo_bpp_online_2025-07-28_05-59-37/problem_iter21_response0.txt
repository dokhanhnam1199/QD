```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Dynamic priority function leveraging adaptive min-max normalization, 
    entropy-aware layered balance, and reinforcement-inspired gains.
    Prioritizes bins through a state-dependent combination of fit quality, 
    consolidation incentives, and post-insertion fragility prediction.
    """
    if bins_remain_cap.size == 0:
        return np.array([], dtype=np.float64)
    
    # Edge case handling for empty bins or zero-sized items
    orig_cap = np.max(bins_remain_cap)
    if orig_cap <= 1e-9 or item <= 1e-9:
        return np.where(
            bins_remain_cap >= item,
            1.0 / (bins_remain_cap - item + 1e-9),
            -np.inf
        )
    
    eligible = bins_remain_cap >= item
    if not np.any(eligible):
        return np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)
    
    # Key metrics calculation
    tightness = item / (bins_remain_cap + 1e-9)  # Fit tightness (0-1 for eligible)
    utilization = (orig_cap - bins_remain_cap) / (orig_cap + 1e-9)  # Current bin load
    
    # Adaptive min-max normalization for eligible bins
    def minmax_norm(values):
        eligible_vals = values[eligible]
        if eligible_vals.size <= 1:
            return np.zeros_like(values)
        min_val, max_val = eligible_vals.min(), eligible_vals.max()
        spread = max_val - min_val
        normed = np.full_like(values, 0.0)
        if spread > 1e-9:
            normed[eligible] = (values[eligible] - min_val) / spread
        return normed
    
    # Base metric normalization
    tight_norm = minmax_norm(tightness)  # Reward higher fit tightness
    util_norm = minmax_norm(utilization)  # Reward higher bin utilization
    
    # Dynamic weight adaptation based on real-time system density
    system_density = np.mean(utilization)  # Range [0, 1]
    system_density = max(0, min(1, system_density))  # Clipping
    
    # Layered weighting scheme
    weight_fit = 1.0 - system_density  # Emphasize fit tightness in sparse systems
    weight_util = float(system_density)  # Prioritize consolidation in dense systems
    
    # Fragmentation-aware post-insertion prediction (reinforcement multiplier)
    future_remaining = bins_remain_cap - item
    future_tightness = item / (orig_cap + 1e-9)  # Absolute item size ratio
    fragility = future_tightness / (1e-9 + future_remaining / orig_cap)
    frag_norm = minmax_norm(fragility)  # Reward bins that become more fragile
    
    # Priority synthesis: weighted combination + reinforcement scaling
    core_score = weight_fit * tight_norm + weight_util * util_norm
    gem = (orig_cap - bins_remain_cap) / orig_cap  # Current fragility
    gem_norm = minmax_norm(gem)
    
    # Final priority calculation with layered balance
    priority = (core_score + gem_norm) * (1.0 + frag_norm)
    
    return np.where(eligible, priority, -np.inf)
```
