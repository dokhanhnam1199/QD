```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    if bins_remain_cap.size == 0:
        return np.array([], dtype=np.float64)
    
    orig_cap = np.max(bins_remain_cap)
    if orig_cap <= 1e-9 or item <= 1e-9:
        return np.where(
            bins_remain_cap >= item,
            bins_remain_cap - item + 1e-9,
            -np.inf
        )
    
    eligible = bins_remain_cap >= item
    if not np.any(eligible):
        return np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)
    
    # Core metrics
    tightness = item / (bins_remain_cap + 1e-9)
    leftover = bins_remain_cap - item
    utilization = (orig_cap - bins_remain_cap) / (orig_cap + 1e-9)
    
    # System-wide metrics
    system_avg = bins_remain_cap.mean()
    system_std = bins_remain_cap.std()
    system_cv = system_std / (system_avg + 1e-9) if system_avg > 1e-9 else 0.0
    system_load = (orig_cap - system_avg) / (orig_cap + 1e-9)
    
    # Adaptive min-max normalization for fit tightness
    elig_tightness = tightness[eligible]
    fit_min, fit_max = elig_tightness.min(), elig_tightness.max()
    fit_range = fit_max - fit_min
    fit_norm = (tightness - fit_min) / (fit_range + 1e-9)
    fit_norm = np.nan_to_num(fit_norm, nan=0.0)
    
    # Dynamic balance term: drives towards system average
    balance_distance = np.abs(bins_remain_cap - system_avg)
    balance_term = -balance_distance / (system_std + 1e-9)
    balance_weight = 0.4 * (system_cv + system_load * 0.5)
    
    # Load-driven fragility tie-breaker: prefers higher utilization bins
    fragility = utilization
    fragility_weight = 0.2 * (1.0 - system_cv)
    
    # Reinforcement-inspired median proximity reward
    elig_leftover = leftover[eligible]
    median_leftover = np.median(elig_leftover)
    proximity_score = 1.0 / (np.abs(leftover - median_leftover) + 1e-9)
    proximity_score[~eligible] = 0  # zero for ineligible
    pr_min, pr_max = proximity_score[eligible].min(), proximity_score[eligible].max()
    proximity_norm = (proximity_score - pr_min) / (pr_max - pr_min + 1e-9)
    reinforcer_weight_val = 0.2 * (1.0 - system_load)
    
    # Composite priority with multi-objective synergy
    priority = (
        fit_norm 
        + balance_term * balance_weight
        + fragility * fragility_weight
        + proximity_norm * reinforcer_weight_val
    )
    
    return np.where(eligible, priority, -np.inf)
```
