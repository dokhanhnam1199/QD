```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines adaptive normalization, dynamic item-size-aware weights, and reinforcement-based 
    fragility control. Prioritizes tight fits for large items and utilization-aware placement 
    for small items, with proximity to system average to reduce fragmentation.
    """
    if bins_remain_cap.size == 0:
        return np.array([], dtype=np.float64)
    
    if item < 1e-9:
        return np.where(bins_remain_cap >= 0, bins_remain_cap, -np.inf)
    
    eligible = bins_remain_cap >= item
    if not np.any(eligible):
        return np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)
    
    # System metrics
    orig_cap = np.max(bins_remain_cap)
    system_avg = np.mean(bins_remain_cap)
    system_std = np.std(bins_remain_cap)
    system_cv = system_std / (system_avg + 1e-9)
    
    # Item classification
    large_item = item > system_avg * (0.75 * (1 + 0.3 * system_cv))
    
    # Metric extraction
    bin_remain = bins_remain_cap[eligible]
    leftover = bin_remain - item
    tightness = item / (bin_remain + 1e-9)
    used_after = orig_cap - bin_remain + item
    util_after = used_after / (orig_cap + 1e-9)
    
    # Normalization function
    def minmax_normalize(arr):
        min_val, max_val = np.min(arr), np.max(arr)
        if max_val - min_val < 1e-9:
            return np.full_like(arr, 0.5)
        return (arr - min_val) / (max_val - min_val + 1e-9)
    
    # Normalized metrics
    tight_norm = minmax_normalize(tightness)
    proximity_norm = minmax_normalize(-np.abs(leftover - system_avg))  # Higher when closer to avg
    util_norm = minmax_normalize(util_after)  # Higher utilization penalized less for small items
    
    # Dynamic weighting
    if large_item:
        w_tight, w_prox, w_util = 0.6, 0.3, 0.1
    else:
        w_tight, w_prox, w_util = 0.3, 0.4, 0.3
    
    # Base score calculation
    base_score = w_tight * tight_norm + w_prox * proximity_norm + w_util * util_norm
    
    # Reinforcement fragility control
    usability = np.clip((system_avg - leftover) / (system_std + 1e-9), 0, None)
    fragility_factor = usability * proximity_norm
    reinforcer = 1.0 + (0.2 * fragility_factor)  # 20% max boost for usable leftovers
    
    # Final score
    score = base_score * reinforcer
    
    # Build result
    result = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)
    result[eligible] = score
    return result
```
