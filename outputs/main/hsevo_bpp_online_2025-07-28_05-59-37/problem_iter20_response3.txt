```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Adaptive heuristic combining Z-score normalization, entropy-aware balance,
    and fragility-aware reinforcement. Prioritizes tight fits for large items
    and capacity balancing for small items while promoting flexible remaining capacity.
    """
    if bins_remain_cap.size == 0:
        return np.array([], dtype=np.float64)
    
    orig_cap = np.max(bins_remain_cap)
    if orig_cap <= 1e-9 or item <= 1e-9:
        return np.where(
            bins_remain_cap >= item,
            bins_remain_cap - item + 1e-9,
            -np.inf
        )
    
    eligible = bins_remain_cap >= item
    if not np.any(eligible):
        return np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)
    
    # System state metrics
    system_avg = bins_remain_cap.mean()
    system_std = bins_remain_cap.std()
    system_cv = system_std / (system_avg + 1e-9) if system_avg > 1e-9 else 0.0
    
    # Item classification
    strong_item = item > system_avg
    
    # Core metrics per bin
    leftover = np.where(eligible, bins_remain_cap - item, np.inf)
    tightness = item / (bins_remain_cap + 1e-9)
    fragility = (orig_cap - bins_remain_cap) / (orig_cap + 1e-9)  # Utilization proxy
    
    # Adaptive Z-score normalization
    elig_fit = np.where(eligible, 1.0 / (leftover + 1e-9), np.nan)
    z_fit = (elig_fit - np.nanmean(elig_fit)) / (np.nanstd(elig_fit) + 1e-9)
    
    elig_space = np.where(eligible, bins_remain_cap, np.nan)
    z_cap = (elig_space - np.nanmean(elig_space)) / (np.nanstd(elig_space) + 1e-9)
    
    # Primary score: dynamic fit/capacity weighting
    primary = tightness * z_fit + (1 - tightness) * z_cap
    
    # Entropy-aware balance component
    balance_term = -abs(leftover - system_avg) / (system_std + 1e-9)
    balance_weight = 0.5 * system_cv * (1.0 if strong_item else 2.0)
    balance_contrib = balance_term * balance_weight
    
    # Reinforcement for flexible futures
    rel_size = item / (np.median(bins_remain_cap[eligible]) + 1e-9)
    rem_rel = bins_remain_cap / (orig_cap + 1e-9)
    reinforcer = 1.0 + 0.5 * (1 - rel_size) ** 2 * rem_rel * (fragility + 1e-9)
    
    # Final priority calculation
    priority = (primary + balance_contrib) * reinforcer
    
    return np.where(eligible, priority, -np.inf)
```
