```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Adaptive priority function leveraging dynamic normalization, layered balance metrics,
    and utilization-aware weighting for online bin packing.
    """
    if bins_remain_cap.size == 0:
        return np.array([], dtype=np.float64)
    
    orig_cap = np.max(bins_remain_cap)
    if orig_cap <= 1e-9 or item <= 1e-9:
        return np.where(
            bins_remain_cap >= item,
            bins_remain_cap - item + 1e-9,
            -np.inf
        )
    
    eligible = bins_remain_cap >= item
    if not np.any(eligible):
        return np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)
    
    # System-wide metrics
    system_avg_cap = bins_remain_cap.mean()
    system_utilization = ((orig_cap - bins_remain_cap) / (orig_cap + 1e-9)).mean()
    
    # Core metrics
    leftover = bins_remain_cap - item
    fit_tightness = item / (bins_remain_cap + 1e-9)
    utilization = (orig_cap - bins_remain_cap) / (orig_cap + 1e-9)
    
    # Adaptive min-max normalization for fit tightness
    fit_elig = fit_tightness[eligible]
    fit_min, fit_max = fit_elig.min(), fit_elig.max()
    fit_norm = (fit_tightness - fit_min) / (fit_max - fit_min + 1e-9)
    
    # Balance term using absolute deviation from system average
    balance_term = -abs(leftover - system_avg_cap) / (system_avg_cap + 1e-9)
    
    # Dynamic weight calculation
    weight_fit = 0.6 * (1.0 + system_utilization)  # Amplify fit priority with higher utilization
    weight_balance = 0.3 * (1.0 - system_utilization)
    weight_util = 0.2 * system_utilization
    
    # Composite priority with layered tie-breaker
    priority = (
        weight_fit * fit_norm +
        weight_balance * balance_term +
        weight_util * utilization +
        1e-6 * (-leftover / (orig_cap + 1e-9))  # Final tie-breaker by tighter fit
    )
    
    return np.where(eligible, priority, -np.inf)
```
