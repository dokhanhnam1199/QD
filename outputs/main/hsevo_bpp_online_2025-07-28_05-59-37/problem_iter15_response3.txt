```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    if bins_remain_cap.size == 0:
        return np.array([], dtype=np.float64)
    
    orig_cap = np.max(bins_remain_cap)
    if orig_cap <= 1e-9 or item <= 1e-9:
        return np.where(
            bins_remain_cap >= item,
            bins_remain_cap - item + 1e-9,
            -np.inf
        )
    
    eligible = bins_remain_cap >= item
    if not np.any(eligible):
        return np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)
    
    # System metrics
    system_median = np.median(bins_remain_cap)
    system_iqr = np.percentile(bins_remain_cap, 75) - np.percentile(bins_remain_cap, 25)
    
    # Entropy approximation via discretization
    bin_edges = np.arange(0, orig_cap + 1e-9, 0.1 * orig_cap)
    hist, _ = np.histogram(bins_remain_cap, bins=bin_edges)
    probs = hist / len(bins_remain_cap)
    entropy = -np.sum(p * np.log(p + 1e-9) for p in probs if p > 0)
    
    # Eligible bin metrics
    elig_remaining = bins_remain_cap[eligible]
    elig_after = elig_remaining - item
    tightness = item / elig_remaining
    
    # Metric normalization
    tightness_min, tightness_max = tightness.min(), tightness.max()
    tightness_norm = (tightness - tightness_min) / (tightness_max - tightness_min + 1e-9)
    
    rem_min, rem_max = elig_after.min(), elig_after.max()
    space_norm = 1.0 - ((elig_after - rem_min) / (rem_max - rem_min + 1e-9)) if rem_max > rem_min else np.zeros_like(elig_after)
    
    utilization = (orig_cap - elig_remaining) / orig_cap
    util_min, util_max = utilization.min(), utilization.max()
    util_norm = (utilization - util_min) / (util_max - util_min + 1e-9) if util_max > util_min else np.zeros_like(utilization)
    
    # Adaptive item classification
    item_rel_size = item / (system_median + 1e-9)
    entropy_weight = np.clip(entropy / (np.log(len(bin_edges)) + 1e-9), 0, 1)
    
    # Hybrid metric weights based on item size and entropy
    tight_weight = 0.4 + 0.5 * entropy_weight * item_rel_size
    space_weight = 0.4 + 0.5 * entropy_weight * (1 - item_rel_size)
    util_weight = 0.2 * (1 - entropy_weight)
    
    # Nonlinear hybrid score
    hybrid_score = (
        (tightness_norm + 1e-9) ** tight_weight *
        (space_norm + 1e-9) ** space_weight *
        (util_norm + 1e-9) ** util_weight
    )
    
    # Reinforcement term: proximity to median remaining after
    rem_after_median = np.median(elig_after)
    rem_after_mad = np.median(np.abs(elig_after - rem_after_median))
    reinforce_score = np.exp(-np.abs(elig_after - rem_after_median) / (rem_after_mad + 1e-9))
    
    # Final priority calculation
    final_score = hybrid_score * (0.5 + 0.5 * entropy_weight * reinforce_score)
    
    # Apply system-wide balance factor
    balance_factor = 1.0 / (1.0 + system_iqr)
    final_score *= balance_factor
    
    # Construct output
    priority = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)
    priority[eligible] = final_score
    
    return priority
```
