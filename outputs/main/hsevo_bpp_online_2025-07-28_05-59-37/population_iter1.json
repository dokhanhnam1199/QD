[
  {
    "stdout_filepath": "problem_iter1_response0.txt_stdout.txt",
    "code_path": "problem_iter1_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority scores for bins based on item size and remaining capacity.\n    \n    The priority is calculated as the ratio of the item size to the bin's remaining capacity,\n    which encourages packing items into bins where they fit most tightly (Best Fit).\n    Bins that cannot accommodate the item are assigned a very low priority.\n    \n    Args:\n        item: Size of the item to be packed.\n        bins_remain_cap: Array of remaining capacities for each bin.\n    \n    Returns:\n        Array of priority scores for each bin.\n    \"\"\"\n    # Calculate the ratio of item to remaining capacity for valid bins\n    priorities = np.where(\n        bins_remain_cap >= item,\n        item / (bins_remain_cap + 1e-9),  # Add epsilon to prevent division by zero\n        -np.inf  # Assign -inf to invalid bins to exclude them from selection\n    )\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response1.txt_stdout.txt",
    "code_path": "problem_iter1_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority scores for bins based on item size and remaining capacity.\n    \n    Prioritizes bins that can fit the item with minimal leftover space, using the ratio\n    of item size to bin's remaining capacity. Bins that cannot fit the item have priority -inf.\n    \"\"\"\n    valid_mask = bins_remain_cap >= item\n    epsilon = 1e-9  # Prevent division by zero\n    return np.where(\n        valid_mask,\n        item / (bins_remain_cap + epsilon),\n        -np.inf\n    )",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response2.txt_stdout.txt",
    "code_path": "problem_iter1_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority scores using a Worst Fit heuristic with a perfect-fit bias.\n    \n    Prioritizes bins with:\n    1. Sufficient capacity to fit the item (ineligible bins get -inf)\n    2. A secondary score based on how close the bin's remaining capacity is to the item size,\n       favoring bins where placing the item would leave minimal leftover space.\n    \"\"\"\n    # Mask bins that can't fit the item\n    eligible = bins_remain_cap >= item\n    \n    # For eligible bins: \n    # - Primary score: 1.0 to ensure eligibility\n    # - Secondary score: 1.0 / (leftover + 1e-9) to favor perfect fits\n    leftover = bins_remain_cap - item\n    scores = np.where(\n        eligible,\n        1.0 + 1.0 / (leftover + 1e-9),\n        -np.inf\n    )\n    return scores",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response3.txt_stdout.txt",
    "code_path": "problem_iter1_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority scores for bins based on Best Fit heuristic.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Mask bins that can fit the item\n    mask = bins_remain_cap >= item\n    # Calculate priority as negative of leftover space (higher is better)\n    priority = np.where(mask, item - bins_remain_cap, -np.inf)\n    return priority",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response4.txt_stdout.txt",
    "code_path": "problem_iter1_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Priority function combining best-fit for large items and worst-fit for small items.\"\"\"\n    if len(bins_remain_cap) == 0:\n        return np.array([], dtype=np.float64)\n    \n    C_est = bins_remain_cap.max()\n    valid = bins_remain_cap >= item\n    large_item = item > C_est / 2\n    \n    if not np.any(valid):\n        return -np.inf * np.ones_like(bins_remain_cap)\n    \n    if large_item:\n        remaining_after = bins_remain_cap - item\n        priority = np.where(valid, -remaining_after, -np.inf)\n    else:\n        priority = np.where(valid, bins_remain_cap, -np.inf)\n    \n    return priority",
    "response_id": 4,
    "tryHS": false,
    "obj": 88.67171918627844,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response5.txt_stdout.txt",
    "code_path": "problem_iter1_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Priority function based on Best Fit heuristic with tie-breaking.\"\"\"\n    # Bins that can fit the item have priority proportional to their tightness\n    can_fit = bins_remain_cap >= item\n    tightness = item / bins_remain_cap  # Higher = tighter fit\n    # Bins with higher utilization (less remaining) are prioritized in tie-breaking\n    utilization = -bins_remain_cap  # Negative to favor smaller remaining capacities\n    priority = np.where(can_fit, tightness + utilization * 1e-6, -np.inf)\n    return priority",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response6.txt_stdout.txt",
    "code_path": "problem_iter1_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Priority function combining Best Fit and Worst Fit heuristics based on item size relative to bin capacity.\"\"\"\n    possible = bins_remain_cap >= item\n    leftover = bins_remain_cap - item\n    tight = item > (bins_remain_cap / 2)\n    tight &= possible  # Only consider tightness for bins that can fit the item\n    \n    best_fit = -leftover  # Prioritize minimal leftover for tight fits\n    worst_fit = leftover  # Prioritize largest leftover for non-tight fits\n    \n    priority = np.where(possible, np.where(tight, best_fit, worst_fit), -np.inf)\n    return priority",
    "response_id": 6,
    "tryHS": false,
    "obj": 88.67171918627844,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response7.txt_stdout.txt",
    "code_path": "problem_iter1_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Hybrid priority combining best fit (smallest remaining capacity) for large items and worst fit (largest remaining capacity) for small items.\"\"\"\n    if bins_remain_cap.size == 0:\n        return np.array([], dtype=np.float64)\n    \n    # Threshold based on mean remaining capacity to decide strategy\n    threshold = np.mean(bins_remain_cap)\n    valid = bins_remain_cap >= item\n    \n    # Best fit priority: prioritize bins with smallest remaining capacity (negative to invert sorting)\n    best_prio = np.where(valid, -bins_remain_cap, -np.inf)\n    # Worst fit priority: prioritize bins with largest remaining capacity\n    worst_prio = np.where(valid, bins_remain_cap, -np.inf)\n    \n    return best_prio if item > threshold else worst_prio",
    "response_id": 7,
    "tryHS": false,
    "obj": 149.30195452732352,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response8.txt_stdout.txt",
    "code_path": "problem_iter1_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority scores based on Best Fit heuristic to minimize leftover space.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    can_fit = bins_remain_cap >= item\n    # Prioritize bins that can fit the item with least leftover space.\n    # Priority is (item - remaining_cap), which is highest (closest to 0) for tightest fit.\n    return np.where(can_fit, item - bins_remain_cap, -np.inf)",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response9.txt_stdout.txt",
    "code_path": "problem_iter1_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Best Fit heuristic: prioritize bins with least remaining capacity after placement.\"\"\"\n    return np.where(bins_remain_cap >= item, item - bins_remain_cap, -np.inf)",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response10.txt_stdout.txt",
    "code_path": "problem_iter1_code10.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority scores for bins using a Best Fit heuristic.\n\n    Prioritizes bins that can fit the item with the smallest remaining capacity,\n    encouraging tight packing to minimize leftover space. Bins that cannot fit\n    the item are assigned a very low priority.\n\n    Args:\n        item: Size of the item to pack.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Returns:\n        Array of priority scores for each bin.\n    \"\"\"\n    valid_mask = bins_remain_cap >= item\n    return np.where(valid_mask, -bins_remain_cap, -np.inf)",
    "response_id": 10,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response11.txt_stdout.txt",
    "code_path": "problem_iter1_code11.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority scores for bins using a Best Fit heuristic with a bonus for exact fits.\n    \n    Args:\n        item: Size of the item to be packed.\n        bins_remain_cap: Array of remaining capacities for each bin.\n    \n    Returns:\n        Array of priority scores for each bin.\n    \"\"\"\n    valid = bins_remain_cap >= item\n    # Prioritize bins that fit exactly with a high bonus\n    exact_fit_bonus = np.where(valid & (bins_remain_cap == item), 1e6, 0.0)\n    # Prioritize bins by minimizing remaining capacity after placement\n    fit_priority = np.where(valid, item - bins_remain_cap, -np.inf)\n    return exact_fit_bonus + fit_priority",
    "response_id": 11,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response12.txt_stdout.txt",
    "code_path": "problem_iter1_code12.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Priority function combining inverse leftover space and utilization ratio.\"\"\"\n    mask = bins_remain_cap >= item\n    scores = np.full_like(bins_remain_cap, -np.inf)\n    if not mask.any():\n        return scores\n    \n    eps = 1e-9\n    inv_leftover = 1.0 / (bins_remain_cap[mask] - item + eps)\n    utilization = item / (bins_remain_cap[mask] + eps)\n    \n    combined = inv_leftover + utilization\n    scores[mask] = combined\n    return scores",
    "response_id": 12,
    "tryHS": false,
    "obj": 4.038691663342641,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response13.txt_stdout.txt",
    "code_path": "problem_iter1_code13.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority scores for bins based on a combination of fit efficiency and bin utilization.\n    \n    Bins that can fit the item are prioritized by the ratio of item size to bin's remaining capacity,\n    favoring bins where the item fills a larger proportion of the available space. Additionally,\n    a secondary term encourages using bins with smaller remaining capacities to promote compact packing.\n    \"\"\"\n    can_fit = bins_remain_cap >= item\n    fit_ratio = item / bins_remain_cap\n    # Secondary term to prefer bins with smaller remaining capacity when fit ratios are similar\n    capacity_weight = -bins_remain_cap\n    priority = np.where(can_fit, fit_ratio + 0.01 * capacity_weight, -np.inf)\n    return priority",
    "response_id": 13,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response14.txt_stdout.txt",
    "code_path": "problem_iter1_code14.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Priority function combining Best Fit and Worst Fit heuristics based on item size.\"\"\"\n    remaining_space = bins_remain_cap - item\n    valid = remaining_space >= 0\n    factor = 1 - 2 * item  # Switches behavior based on item size threshold (0.5)\n    priority = np.where(valid, remaining_space * factor, -np.inf)\n    return priority",
    "response_id": 14,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response15.txt_stdout.txt",
    "code_path": "problem_iter1_code15.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Priority function based on Best Fit strategy with a twist of space efficiency.\n    \n    Bins that can fit the item are prioritized by how tightly they pack the item,\n    favoring bins where the item fills the bin completely. Bins that cannot fit the\n    item are assigned -infinity to ensure they are not selected.\n    \n    Args:\n        item: Size of the item to be packed.\n        bins_remain_cap: Array of remaining capacities for each bin.\n    \n    Returns:\n        Array of priority scores for each bin.\n    \"\"\"\n    can_fit = bins_remain_cap >= item\n    # Prioritize bins that minimize remaining space (Best Fit)\n    # Use negative of remaining space after packing to maximize tight fits\n    priorities = np.where(can_fit, -(bins_remain_cap - item), -np.inf)\n    return priorities",
    "response_id": 15,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response16.txt_stdout.txt",
    "code_path": "problem_iter1_code16.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority scores using Best Fit strategy to minimize leftover space.\n    \n    Bins that can fit the item are prioritized by how closely their remaining capacity\n    matches the item size (smallest leftover space). This encourages efficient bin usage.\n    \"\"\"\n    mask = bins_remain_cap >= item\n    return np.where(mask, item - bins_remain_cap, -np.inf)",
    "response_id": 16,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response17.txt_stdout.txt",
    "code_path": "problem_iter1_code17.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins that can fit the item with minimal leftover space.\n    \n    This implements a Best Fit strategy by scoring bins based on negative\n    remaining capacity after placement (higher is better). Bins that cannot\n    fit the item receive -infinity.\n    \n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    \n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    return np.where(bins_remain_cap >= item, -(bins_remain_cap - item), -np.inf)",
    "response_id": 17,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response18.txt_stdout.txt",
    "code_path": "problem_iter1_code18.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Priority function implementing Best Fit strategy for online Bin Packing Problem.\n    \n    Bins that can fit the item are prioritized by minimizing leftover space, equivalent to\n    selecting the bin with the smallest remaining capacity >= item. Non-eligible bins\n    receive -inf priority.\n    \"\"\"\n    eligible = bins_remain_cap >= item\n    priority = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)\n    priority[eligible] = item - bins_remain_cap[eligible]\n    return priority",
    "response_id": 18,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response19.txt_stdout.txt",
    "code_path": "problem_iter1_code19.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Priority function combining Best Fit for large items and Worst Fit for small items.\"\"\"\n    LARGE_THRESHOLD = 0.5  # Assuming bin capacity is normalized to 1.0\n    mask = bins_remain_cap >= item\n    priority = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    \n    if item > LARGE_THRESHOLD:\n        # Best Fit: prioritize bins with least leftover space (higher = closer to zero)\n        priority[mask] = item - bins_remain_cap[mask]\n    else:\n        # Worst Fit: prioritize bins with largest remaining capacity\n        priority[mask] = bins_remain_cap[mask]\n    \n    return priority",
    "response_id": 19,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response20.txt_stdout.txt",
    "code_path": "problem_iter1_code20.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority scores for bins based on Best Fit heuristic.\n    \n    Prioritizes bins with the least remaining capacity that can still fit the item,\n    equivalent to minimizing leftover space. Bins that cannot fit the item are assigned\n    a very low priority (-inf).\n    \"\"\"\n    leftover = bins_remain_cap - item\n    valid = leftover >= 0\n    # Prioritize bins with minimal leftover (Best Fit)\n    priority = np.where(valid, -leftover, -np.inf)\n    return priority",
    "response_id": 20,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response21.txt_stdout.txt",
    "code_path": "problem_iter1_code21.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority scores for bins based on Best Fit with tie-breaking by current utilization.\n    \n    The priority is calculated to minimize the remaining space after placing the item and\n    prefer bins that were more filled before placement in case of ties.\n    \"\"\"\n    remaining = bins_remain_cap - item\n    valid = remaining >= 0\n    epsilon = 1e-6  # Small weight to break ties by current remaining capacity\n    priority_val = -remaining - epsilon * bins_remain_cap  # Prioritize smaller remaining and more filled bins\n    return np.where(valid, priority_val, -np.inf)",
    "response_id": 21,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response22.txt_stdout.txt",
    "code_path": "problem_iter1_code22.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority scores based on Best Fit heuristic, favoring bins that minimize leftover space.\n    \n    Args:\n        item: Size of the item to be packed.\n        bins_remain_cap: Array of remaining capacities for each bin.\n    \n    Returns:\n        Array of priority scores for each bin, where higher values indicate better fit.\n    \"\"\"\n    can_fit = bins_remain_cap >= item\n    # Prioritize bins with smallest remaining capacity after placement (Best Fit)\n    # Use negative remaining capacity as priority (higher score = less negative = better fit)\n    priorities = np.where(can_fit, -bins_remain_cap, -np.inf)\n    return priorities",
    "response_id": 22,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response23.txt_stdout.txt",
    "code_path": "problem_iter1_code23.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Priority function implementing a Best Fit strategy with exponential sensitivity to waste minimization.\"\"\"\n    can_fit = bins_remain_cap >= item\n    # Prioritize bins that minimize leftover space using exponential decay: e^(-waste)\n    # This heavily penalizes larger leftover spaces while favoring perfect fits\n    priorities = np.where(\n        can_fit,\n        np.exp(-(bins_remain_cap - item)),\n        -np.inf\n    )\n    return priorities",
    "response_id": 23,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response24.txt_stdout.txt",
    "code_path": "problem_iter1_code24.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Priority function combining best-fit with future space reservation heuristic.\"\"\"\n    valid = bins_remain_cap >= item\n    if not np.any(valid):\n        return np.full_like(bins_remain_cap, -np.inf)\n    \n    # Bins that can fit another item of the same size after placement\n    enough_for_another = (bins_remain_cap - item) >= item\n    \n    # High-priority group: valid bins with space for another item\n    high_priority = valid & enough_for_another\n    # Low-priority group: valid bins without space for another item\n    low_priority = valid & ~enough_for_another\n    \n    # Use large constant to prioritize space-reservation group\n    BIG = 1e9\n    priority = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    \n    # For high-priority bins: prioritize tightest fit for two items\n    priority[high_priority] = BIG - (bins_remain_cap[high_priority] - 2 * item)\n    \n    # For low-priority bins: use standard best-fit\n    priority[low_priority] = - (bins_remain_cap[low_priority] - item)\n    \n    return priority",
    "response_id": 24,
    "tryHS": false,
    "obj": 20.472676505783802,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response25.txt_stdout.txt",
    "code_path": "problem_iter1_code25.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority scores for bins using a Best Fit strategy with negative residual capacity weighting.\n    \n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    \n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    can_fit = bins_remain_cap >= item\n    # Prioritize bins that minimize remaining capacity after placement (Best Fit)\n    # Score is negative residual capacity (so higher score = better fit)\n    priority = np.where(can_fit, -(bins_remain_cap - item), -np.inf)\n    return priority",
    "response_id": 25,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response26.txt_stdout.txt",
    "code_path": "problem_iter1_code26.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority scores based on minimizing leftover space after placement.\n    \n    Bins that can fit the item are prioritized by how tightly they can pack it,\n    favoring bins with remaining capacity just enough to fit the item (Best Fit).\n    \"\"\"\n    valid_bins = bins_remain_cap >= item\n    leftover = bins_remain_cap - item\n    # Use negative leftover as priority: higher values (closer to 0) indicate better fit\n    priority = np.where(valid_bins, -leftover, -np.inf)\n    return priority",
    "response_id": 26,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response27.txt_stdout.txt",
    "code_path": "problem_iter1_code27.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority scores based on item-to-bin remaining capacity ratio for tight fits.\"\"\"\n    valid_mask = bins_remain_cap >= item\n    # Calculate ratio of item size to bin's remaining capacity (higher = tighter fit)\n    ratio = item / (bins_remain_cap + 1e-9)  # Add epsilon to avoid division by zero\n    # Assign -inf to invalid bins to ensure they are not selected\n    priorities = np.where(valid_mask, ratio, -np.inf)\n    return priorities",
    "response_id": 27,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response28.txt_stdout.txt",
    "code_path": "problem_iter1_code28.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority scores for bins based on Best Fit heuristic.\n    \n    Bins that can fit the item are prioritized by their remaining capacity in reverse order\n    (smallest remaining capacity gets highest priority). Unsuitable bins have -inf priority.\n    \"\"\"\n    can_fit = bins_remain_cap >= item\n    priorities = np.where(can_fit, -bins_remain_cap, -np.inf)\n    return priorities",
    "response_id": 28,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response29.txt_stdout.txt",
    "code_path": "problem_iter1_code29.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Priority function combining Best Fit for large items and Worst Fit for small items.\"\"\"\n    mask = bins_remain_cap >= item\n    threshold = 0.5  # Threshold to distinguish large/small items\n    \n    # Best Fit: prioritize bins with least remaining capacity after placement (for large items)\n    best_fit = -(bins_remain_cap - item)\n    \n    # Worst Fit: prioritize bins with largest remaining capacity (for small items)\n    worst_fit = bins_remain_cap\n    \n    # Select strategy based on item size\n    priority = np.where(item >= threshold, best_fit, worst_fit)\n    \n    # Mask invalid bins and return\n    return np.where(mask, priority, -np.inf)",
    "response_id": 29,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  }
]