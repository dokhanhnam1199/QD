```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Predictive variance-aware packing using min-max synergy and entropy-agnostic reinforcement.
    Combines normalized fit-tightness/utilization with proximity-based penalties and fragility-aware reinforcer.
    """
    eps = 1e-9
    if bins_remain_cap.size == 0:
        return np.array([], dtype=np.float64)
    
    eligible = bins_remain_cap >= item
    if not eligible.any():
        return np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)
    
    orig_cap = bins_remain_cap.max()
    remaining_cap = bins_remain_cap[eligible]
    leftover = remaining_cap - item + eps
    
    # Metric calculation
    fit_tightness = item / (remaining_cap + eps)
    util_after = (orig_cap - remaining_cap + item) / (orig_cap + eps)
    
    # System metrics
    system_avg = bins_remain_cap.mean()
    system_std = bins_remain_cap.std() + eps
    
    # Min-max normalization
    def minmax_normalize(x):
        xmin, xmax = x.min(), x.max()
        if xmax > xmin:
            return (x - xmin) / (xmax - xmin)
        return np.full_like(x, 0.5)
    
    norm_fit = minmax_normalize(fit_tightness)
    norm_util = minmax_normalize(util_after)
    
    # Hybrid score with static weights
    hybrid = 0.6 * norm_fit + 0.4 * norm_util
    boosted = hybrid ** 2  # Nonlinear amplification
    
    # Proximity-based penalty (distance from average leftover)
    proximity = np.abs(leftover - system_avg) / system_std
    proximity_penalty = np.exp(-proximity)
    
    # Reinforcement term: fragility * usability
    fragility = util_after
    usability = np.clip((system_avg - leftover) / system_std, -1.0, 1.0)
    reinforcer = fragility * np.abs(usability)
    
    # Tie-breaker (epsilon-greedy preference for larger leftover)
    tie_breaker = 0.01 * (leftover / (orig_cap + eps))
    
    # Final score assembly
    eligible_scores = (
        boosted * proximity_penalty 
        + reinforcer 
        + tie_breaker
    )
    
    scores = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)
    scores[eligible] = eligible_scores
    
    return scores
```
