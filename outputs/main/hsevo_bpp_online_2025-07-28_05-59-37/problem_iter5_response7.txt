```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Adaptive synergy of inv_leftover*utilization for tight fits + exponential waste decay for fragmentation reduction."""
    mask = bins_remain_cap >= item
    scores = np.full_like(bins_remain_cap, -np.inf)
    if not mask.any():
        return scores
    
    eps = 1e-9
    remaining = bins_remain_cap[mask]
    
    # Core metrics from both heuristics
    inv_leftover = 1.0 / (remaining - item + eps)  # Maximize for tight fits
    utilization = item / (remaining + eps)  # Prioritize high space efficiency
    exp_waste = np.exp(-(remaining - item))  # Penalize large leftover exponentially
    
    # Hierarchical synergy: Tight fit + stable baseline + entropy-aware tie-breaking
    multiplicative_term = inv_leftover * utilization  # Tight-fit dominance
    additive_term = utilization  # Baseline utilization
    exp_tie_breaker = 0.1 * exp_waste  # Non-linear tie-breaking
    
    # Final score combining hierarchical objectives
    scores[mask] = multiplicative_term + additive_term + exp_tie_breaker
    return scores
```
