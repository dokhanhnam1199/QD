```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines adaptive normalization with variance impact modeling. Uses item-size-aware dynamic weights and reinforcement-inspired usability boosting. Balances tight packing, variance reduction, and system stability through hybrid scoring.
    """
    if bins_remain_cap.size == 0:
        return np.array([], dtype=np.float64)
    
    eligible = bins_remain_cap >= item
    if not np.any(eligible):
        return np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)
    
    # System metrics
    system_avg = np.mean(bins_remain_cap)
    system_std = np.std(bins_remain_cap)
    system_cv = system_std / (system_avg + 1e-9)
    n = bins_remain_cap.size
    
    # Item classification
    large_item_threshold = system_avg * (0.75 * (1 + 0.3 * system_cv))
    large_item = item > large_item_threshold
    
    # Metrics for eligible bins
    bin_remain = bins_remain_cap[eligible]
    tightness = item / (bin_remain + 1e-9)
    leftover = bin_remain - item
    proximity = np.abs(leftover - system_avg)
    usability = (system_avg - leftover) / (system_std + 1e-9)
    
    # Variance impact calculation
    sum_remain = bins_remain_cap.sum()
    sum_remain_sq = (bins_remain_cap ** 2).sum()
    sum_remain_new = sum_remain - item
    sum_remain_sq_new = sum_remain_sq - bins_remain_cap**2 + (bins_remain_cap - item)**2
    var_new = (sum_remain_sq_new / n) - (sum_remain_new / n)**2
    
    # Normalization of metrics
    var_score = np.zeros_like(var_new)
    eligible_var = var_new[eligible]
    var_min, var_max = eligible_var.min(), eligible_var.max()
    if var_max > var_min:
        var_score[eligible] = (var_max - var_new[eligible]) / (var_max - var_min + 1e-9)
    else:
        var_score[eligible] = 0.5
    
    tight_norm = np.zeros_like(tightness)
    tight_min, tight_max = tightness.min(), tightness.max()
    if tight_max > tight_min:
        tight_norm = (tightness - tight_min) / (tight_max - tight_min + 1e-9)
    else:
        tight_norm.fill(0.5)
    
    proximity_norm = np.zeros_like(proximity)
    prox_min, prox_max = proximity.min(), proximity.max()
    if prox_max > prox_min:
        proximity_norm = 1.0 - (proximity - prox_min) / (prox_max - prox_min + 1e-9)
    else:
        proximity_norm.fill(0.5)
    
    # Reinforcement-inspired usability factor
    fragility_factor = np.clip(usability, 0, None)
    reinforcer = 1.0 + 0.3 * fragility_factor
    
    # Dynamic weight allocation
    if large_item:
        w_tight, w_var, w_prox = 0.5, 0.4, 0.1
    else:
        w_tight, w_var, w_prox = 0.3, 0.3, 0.4
    
    # Final priority calculation
    priority_components = (
        w_tight * tight_norm +
        w_var * var_score[eligible] +
        w_prox * proximity_norm
    ) * reinforcer
    
    result = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)
    result[eligible] = priority_components
    
    return result
```
