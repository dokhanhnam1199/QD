```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Adaptive hybrid heuristic combining Z-normalized metrics, entropy-aware penalties, 
    and gradient-enhanced fragility control for online bin packing. Balances tight fits 
    with system-wide entropy optimization through dynamic weight allocation.
    """
    if bins_remain_cap.size == 0:
        return np.array([], dtype=np.float64)
    
    # Fast path for negligible items
    if item < 1e-9:
        return np.where(bins_remain_cap >= 0, 
                      0.3 / (bins_remain_cap + 1e-4) - 0.1 * bins_remain_cap,
                      -np.inf)
    
    eligible = bins_remain_cap >= item - 1e-9
    if not np.any(eligible):
        return np.full_like(bins_remain_cap, -np.inf)
    
    # System state analysis
    sys_avg, sys_std = np.mean(bins_remain_cap), np.std(bins_remain_cap)
    sys_cv = sys_std / (sys_avg + 1e-9) if sys_avg > 1e-9 else 0.0
    large_item = item > sys_avg * 0.75 * (1 + 0.3 * sys_cv)
    
    # Core metric computation
    residual = bins_remain_cap - item
    tightness = item / (bins_remain_cap + 1e-9)
    fit_power = 1.0 / (residual + 1e-6)
    frag_indicator = (residual - sys_avg) / (sys_std + 1e-9)
    
    # Adaptive Z-normalization
    def z_normalize(metric):
        return (metric - np.mean(metric[eligible])) / (np.std(metric[eligible]) + 1e-9)
    
    z_fit = z_normalize(fit_power)
    z_tight = z_normalize(tightness)
    z_balance = z_normalize(-np.abs(residual - sys_avg))
    
    # Dynamic weight calculation
    def calc_weight(metric):
        m_var = np.var(metric[eligible])
        return m_var * (1.5 if large_item else 1.0) * (1 + sys_cv)
    
    fit_weight = calc_weight(z_fit)
    tight_weight = calc_weight(1 - tightness)
    balance_weight = calc_weight(-np.abs(residual - sys_avg))
    
    # Synergy amplification
    synergy = 1.0 + np.tanh(
        0.5 * (z_fit * fit_weight - z_tight * tight_weight)
    ) * (1 - 0.4 * sys_std / (sys_avg + 1e-9))
    
    # Entropy-aware penalty tiers
    penalty = np.select(
        [
            frag_indicator > sys_cv + 1.0,
            frag_indicator < -sys_cv - 0.7,
            frag_indicator < 0.5
        ],
        [
            0.4 * sys_std**0.7 * (1 + sys_cv**0.5),
            0.2 * sys_std**0.4 / (sys_avg + 1e-9),
            0.15 * sys_cv**0.6
        ],
        default=0.08 * (1 - sys_cv)
    )
    
    # Gradient-enhanced scoring
    base_score = (
        z_fit * fit_weight * synergy * (1.2 if large_item else 0.9) +
        z_balance * balance_weight * (0.8 + 0.5 * sys_cv) +
        (1 - z_tight * tight_weight * (0.6 if large_item else 1.0))
    )
    
    # Fragility-adjusted final score
    final_score = np.where(
        eligible,
        base_score - residual * penalty * (1.3 if item < sys_avg else 1.0),
        -np.inf
    )
    
    return final_score
```
