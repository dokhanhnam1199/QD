```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Hybrid priority using z-score BF/WF blending, exponential fragmentation control, entropy-based median alignment, 
    and variance-scaled utilization tie-breakers for online bin stability.
    """
    if len(bins_remain_cap) == 0:
        return np.array([], dtype=np.float64)
    
    valid = bins_remain_cap >= item
    if not valid.any():
        return np.full_like(bins_remain_cap, -np.inf)
    
    # System stats
    C_est = bins_remain_cap.max()
    avg_cap = bins_remain_cap.mean()
    std_cap = bins_remain_cap.std()
    med_cap = np.median(bins_remain_cap)
    leftover = bins_remain_cap - item
    
    # Z-score driven BF/WF blending
    z = (item - avg_cap) / (std_cap + 1e-9)
    blend_weight = 1.0 / (1.0 + np.exp(-z))  # Blend to BF when item > avg
    primary_score = blend_weight * (-leftover) + (1 - blend_weight) * bins_remain_cap
    
    # Nonlinear fragmentation penalty
    frag_score = -np.exp(-leftover / (0.2 * C_est + 1e-9))
    
    # Entropy control via median alignment
    balance_score = -0.1 * np.abs(bins_remain_cap - med_cap) / (C_est + 1e-9)
    
    # Variance-adaptive tie-breaker
    valid_leftover = leftover[valid]
    std_leftover = valid_leftover.std() if len(valid_leftover) > 1 else 1e-6
    epsilon = 1e-4 / (std_leftover + 1e-9)
    
    # Utilization gradient per bin
    utilization = np.zeros_like(leftover, dtype=np.float64)
    np.divide(item, bins_remain_cap, where=valid, out=utilization)
    
    # Score aggregation
    scores = (primary_score + frag_score + balance_score + epsilon * utilization)
    scores[~valid] = -np.inf  # Invalid bins
    return scores
```
