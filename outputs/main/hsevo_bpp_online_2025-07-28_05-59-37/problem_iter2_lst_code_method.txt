{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Priority function combining inverse leftover space and utilization ratio.\"\"\"\n    mask = bins_remain_cap >= item\n    scores = np.full_like(bins_remain_cap, -np.inf)\n    if not mask.any():\n        return scores\n    \n    eps = 1e-9\n    inv_leftover = 1.0 / (bins_remain_cap[mask] - item + eps)\n    utilization = item / (bins_remain_cap[mask] + eps)\n    \n    combined = inv_leftover + utilization\n    scores[mask] = combined\n    return scores\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Priority function combining inverse leftover space and utilization ratio.\"\"\"\n    mask = bins_remain_cap >= item\n    scores = np.full_like(bins_remain_cap, -np.inf)\n    if not mask.any():\n        return scores\n    \n    eps = 1e-9\n    inv_leftover = 1.0 / (bins_remain_cap[mask] - item + eps)\n    utilization = item / (bins_remain_cap[mask] + eps)\n    \n    combined = inv_leftover + utilization\n    scores[mask] = combined\n    return scores\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Priority function implementing a Best Fit strategy with exponential sensitivity to waste minimization.\"\"\"\n    can_fit = bins_remain_cap >= item\n    # Prioritize bins that minimize leftover space using exponential decay: e^(-waste)\n    # This heavily penalizes larger leftover spaces while favoring perfect fits\n    priorities = np.where(\n        can_fit,\n        np.exp(-(bins_remain_cap - item)),\n        -np.inf\n    )\n    return priorities\n\n[Heuristics 4th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority scores based on Best Fit heuristic to minimize leftover space.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    can_fit = bins_remain_cap >= item\n    # Prioritize bins that can fit the item with least leftover space.\n    # Priority is (item - remaining_cap), which is highest (closest to 0) for tightest fit.\n    return np.where(can_fit, item - bins_remain_cap, -np.inf)\n\n[Heuristics 5th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority scores for bins based on Best Fit with tie-breaking by current utilization.\n    \n    The priority is calculated to minimize the remaining space after placing the item and\n    prefer bins that were more filled before placement in case of ties.\n    \"\"\"\n    remaining = bins_remain_cap - item\n    valid = remaining >= 0\n    epsilon = 1e-6  # Small weight to break ties by current remaining capacity\n    priority_val = -remaining - epsilon * bins_remain_cap  # Prioritize smaller remaining and more filled bins\n    return np.where(valid, priority_val, -np.inf)\n\n[Heuristics 6th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority scores for bins based on Best Fit heuristic.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Mask bins that can fit the item\n    mask = bins_remain_cap >= item\n    # Calculate priority as negative of leftover space (higher is better)\n    priority = np.where(mask, item - bins_remain_cap, -np.inf)\n    return priority\n\n[Heuristics 7th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Priority function implementing Best Fit strategy for online Bin Packing Problem.\n    \n    Bins that can fit the item are prioritized by minimizing leftover space, equivalent to\n    selecting the bin with the smallest remaining capacity >= item. Non-eligible bins\n    receive -inf priority.\n    \"\"\"\n    eligible = bins_remain_cap >= item\n    priority = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)\n    priority[eligible] = item - bins_remain_cap[eligible]\n    return priority\n\n[Heuristics 8th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority scores using a Worst Fit heuristic with a perfect-fit bias.\n    \n    Prioritizes bins with:\n    1. Sufficient capacity to fit the item (ineligible bins get -inf)\n    2. A secondary score based on how close the bin's remaining capacity is to the item size,\n       favoring bins where placing the item would leave minimal leftover space.\n    \"\"\"\n    # Mask bins that can't fit the item\n    eligible = bins_remain_cap >= item\n    \n    # For eligible bins: \n    # - Primary score: 1.0 to ensure eligibility\n    # - Secondary score: 1.0 / (leftover + 1e-9) to favor perfect fits\n    leftover = bins_remain_cap - item\n    scores = np.where(\n        eligible,\n        1.0 + 1.0 / (leftover + 1e-9),\n        -np.inf\n    )\n    return scores\n\n[Heuristics 9th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority scores for bins using a Best Fit strategy with negative residual capacity weighting.\n    \n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    \n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    can_fit = bins_remain_cap >= item\n    # Prioritize bins that minimize remaining capacity after placement (Best Fit)\n    # Score is negative residual capacity (so higher score = better fit)\n    priority = np.where(can_fit, -(bins_remain_cap - item), -np.inf)\n    return priority\n\n[Heuristics 10th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Priority function combining Best Fit for large items and Worst Fit for small items.\"\"\"\n    mask = bins_remain_cap >= item\n    threshold = 0.5  # Threshold to distinguish large/small items\n    \n    # Best Fit: prioritize bins with least remaining capacity after placement (for large items)\n    best_fit = -(bins_remain_cap - item)\n    \n    # Worst Fit: prioritize bins with largest remaining capacity (for small items)\n    worst_fit = bins_remain_cap\n    \n    # Select strategy based on item size\n    priority = np.where(item >= threshold, best_fit, worst_fit)\n    \n    # Mask invalid bins and return\n    return np.where(mask, priority, -np.inf)\n\n[Heuristics 11th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Priority function implementing Best Fit strategy for online Bin Packing Problem.\n    \n    Bins that can fit the item are prioritized by minimizing leftover space, equivalent to\n    selecting the bin with the smallest remaining capacity >= item. Non-eligible bins\n    receive -inf priority.\n    \"\"\"\n    eligible = bins_remain_cap >= item\n    priority = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)\n    priority[eligible] = item - bins_remain_cap[eligible]\n    return priority\n\n[Heuristics 12th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority scores based on item-to-bin remaining capacity ratio for tight fits.\"\"\"\n    valid_mask = bins_remain_cap >= item\n    # Calculate ratio of item size to bin's remaining capacity (higher = tighter fit)\n    ratio = item / (bins_remain_cap + 1e-9)  # Add epsilon to avoid division by zero\n    # Assign -inf to invalid bins to ensure they are not selected\n    priorities = np.where(valid_mask, ratio, -np.inf)\n    return priorities\n\n[Heuristics 13th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Priority function combining best-fit for large items and worst-fit for small items.\"\"\"\n    if len(bins_remain_cap) == 0:\n        return np.array([], dtype=np.float64)\n    \n    C_est = bins_remain_cap.max()\n    valid = bins_remain_cap >= item\n    large_item = item > C_est / 2\n    \n    if not np.any(valid):\n        return -np.inf * np.ones_like(bins_remain_cap)\n    \n    if large_item:\n        remaining_after = bins_remain_cap - item\n        priority = np.where(valid, -remaining_after, -np.inf)\n    else:\n        priority = np.where(valid, bins_remain_cap, -np.inf)\n    \n    return priority\n\n[Heuristics 14th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Priority function combining best-fit for large items and worst-fit for small items.\"\"\"\n    if len(bins_remain_cap) == 0:\n        return np.array([], dtype=np.float64)\n    \n    C_est = bins_remain_cap.max()\n    valid = bins_remain_cap >= item\n    large_item = item > C_est / 2\n    \n    if not np.any(valid):\n        return -np.inf * np.ones_like(bins_remain_cap)\n    \n    if large_item:\n        remaining_after = bins_remain_cap - item\n        priority = np.where(valid, -remaining_after, -np.inf)\n    else:\n        priority = np.where(valid, bins_remain_cap, -np.inf)\n    \n    return priority\n\n[Heuristics 15th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Priority function combining Best Fit and Worst Fit heuristics based on item size relative to bin capacity.\"\"\"\n    possible = bins_remain_cap >= item\n    leftover = bins_remain_cap - item\n    tight = item > (bins_remain_cap / 2)\n    tight &= possible  # Only consider tightness for bins that can fit the item\n    \n    best_fit = -leftover  # Prioritize minimal leftover for tight fits\n    worst_fit = leftover  # Prioritize largest leftover for non-tight fits\n    \n    priority = np.where(possible, np.where(tight, best_fit, worst_fit), -np.inf)\n    return priority\n\n[Heuristics 16th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Priority function combining Best Fit and Worst Fit heuristics based on item size relative to bin capacity.\"\"\"\n    possible = bins_remain_cap >= item\n    leftover = bins_remain_cap - item\n    tight = item > (bins_remain_cap / 2)\n    tight &= possible  # Only consider tightness for bins that can fit the item\n    \n    best_fit = -leftover  # Prioritize minimal leftover for tight fits\n    worst_fit = leftover  # Prioritize largest leftover for non-tight fits\n    \n    priority = np.where(possible, np.where(tight, best_fit, worst_fit), -np.inf)\n    return priority\n\n[Heuristics 17th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Priority function combining Best Fit and Worst Fit heuristics based on item size relative to bin capacity.\"\"\"\n    possible = bins_remain_cap >= item\n    leftover = bins_remain_cap - item\n    tight = item > (bins_remain_cap / 2)\n    tight &= possible  # Only consider tightness for bins that can fit the item\n    \n    best_fit = -leftover  # Prioritize minimal leftover for tight fits\n    worst_fit = leftover  # Prioritize largest leftover for non-tight fits\n    \n    priority = np.where(possible, np.where(tight, best_fit, worst_fit), -np.inf)\n    return priority\n\n[Heuristics 18th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Priority function combining best-fit for large items and worst-fit for small items.\"\"\"\n    if len(bins_remain_cap) == 0:\n        return np.array([], dtype=np.float64)\n    \n    C_est = bins_remain_cap.max()\n    valid = bins_remain_cap >= item\n    large_item = item > C_est / 2\n    \n    if not np.any(valid):\n        return -np.inf * np.ones_like(bins_remain_cap)\n    \n    if large_item:\n        remaining_after = bins_remain_cap - item\n        priority = np.where(valid, -remaining_after, -np.inf)\n    else:\n        priority = np.where(valid, bins_remain_cap, -np.inf)\n    \n    return priority\n\n[Heuristics 19th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Hybrid priority combining best fit (smallest remaining capacity) for large items and worst fit (largest remaining capacity) for small items.\"\"\"\n    if bins_remain_cap.size == 0:\n        return np.array([], dtype=np.float64)\n    \n    # Threshold based on mean remaining capacity to decide strategy\n    threshold = np.mean(bins_remain_cap)\n    valid = bins_remain_cap >= item\n    \n    # Best fit priority: prioritize bins with smallest remaining capacity (negative to invert sorting)\n    best_prio = np.where(valid, -bins_remain_cap, -np.inf)\n    # Worst fit priority: prioritize bins with largest remaining capacity\n    worst_prio = np.where(valid, bins_remain_cap, -np.inf)\n    \n    return best_prio if item > threshold else worst_prio\n\n[Heuristics 20th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Hybrid priority combining best fit (smallest remaining capacity) for large items and worst fit (largest remaining capacity) for small items.\"\"\"\n    if bins_remain_cap.size == 0:\n        return np.array([], dtype=np.float64)\n    \n    # Threshold based on mean remaining capacity to decide strategy\n    threshold = np.mean(bins_remain_cap)\n    valid = bins_remain_cap >= item\n    \n    # Best fit priority: prioritize bins with smallest remaining capacity (negative to invert sorting)\n    best_prio = np.where(valid, -bins_remain_cap, -np.inf)\n    # Worst fit priority: prioritize bins with largest remaining capacity\n    worst_prio = np.where(valid, bins_remain_cap, -np.inf)\n    \n    return best_prio if item > threshold else worst_prio\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}