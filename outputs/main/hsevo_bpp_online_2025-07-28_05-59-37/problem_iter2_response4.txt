```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Hybrid priority using inverse leftover space and utilization ratio with dynamic weight adjustment.
    Inspired by synergy of v0's best-fit focus and v1's threshold adaptability, combining:
        1. Inverse leftover minimization for large items (exponential decay effect)
        2. Utilization ratio tie-breaking for small items
        3. Dynamic weights based on item-to-mean-capacity ratio
    """
    if bins_remain_cap.size == 0:
        return np.array([], dtype=np.float64)
        
    eligible = bins_remain_cap >= item
    mean_remain = np.mean(bins_remain_cap)
    
    # Base metrics for eligible bins
    cap_elig = bins_remain_cap[eligible]
    leftover = cap_elig - item
    
    # Inverse leftover (epsilon prevents division by zero, dominates for large items)
    inv_leftover = 1.0 / (leftover + 1e-9)
    # Bin utilization (higher = more filled, better for small items)
    utilization = 1.0 - cap_elig
    
    # Dynamic weight adjustment: emphasizes leftover for large items, utilization for small items
    leftover_weight = 1.0 + np.clip((item - mean_remain) / max(mean_remain, 0.1), 0, 1)
    util_weight = 1.0 + np.clip((mean_remain - item) / max(mean_remain, 0.1), 0, 1)
    
    # Combined priority (product synergy with weighted components)
    priority_value = (inv_leftover * leftover_weight) * (utilization * util_weight)
    
    # Initialize result with -inf for non-eligible
    priority = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)
    priority[eligible] = priority_value
    return priority
```
