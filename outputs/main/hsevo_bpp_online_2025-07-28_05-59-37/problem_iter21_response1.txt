```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    if bins_remain_cap.size == 0:
        return np.array([], dtype=np.float64)
    
    orig_cap = np.max(bins_remain_cap)
    if orig_cap <= 1e-9 or item <= 1e-9:
        return np.where(
            bins_remain_cap >= item,
            bins_remain_cap - item + 1e-9,
            -np.inf
        )
    
    eligible = bins_remain_cap >= item
    if not np.any(eligible):
        return np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)
    
    # Core metrics
    tightness = item / (bins_remain_cap + 1e-9)
    leftover = bins_remain_cap - item
    
    # Adaptive min-max normalization for eligible bins
    eligible_mask = eligible.astype(bool)
    tight_min, tight_max = tightness[eligible_mask].min(), tightness[eligible_mask].max()
    normalized_tight = (tightness - tight_min) / (tight_max - tight_min + 1e-9)
    
    lo_min, lo_max = leftover[eligible_mask].min(), leftover[eligible_mask].max()
    normalized_lo = (lo_max - leftover) / (lo_max - lo_min + 1e-9)
    
    # Dynamic weight based on item size relative to median eligible capacity
    eligible_rem = bins_remain_cap[eligible_mask]
    median_cap = np.median(eligible_rem)
    item_rel = item / (median_cap + 1e-9)
    dynamic_weight = np.clip(0.3 + 0.5 * item_rel, 0.3, 0.8)
    
    # Base score combining normalized metrics
    base_score = dynamic_weight * normalized_tight + (1 - dynamic_weight) * normalized_lo
    
    # Utilization-aware secondary factor (prefer higher utilization)
    utilization = (orig_cap - bins_remain_cap) / (orig_cap + 1e-9)
    util_factor = utilization ** 0.5
    
    # Tertiary balance factor: proximity to median capacity after placement
    after_placement = bins_remain_cap - item
    diff_to_med = np.abs(after_placement - median_cap)
    balance_factor = 1.0 / (diff_to_med + 1e-9)
    
    # Normalize balance factor
    bf_min, bf_max = balance_factor[eligible_mask].min(), balance_factor[eligible_mask].max()
    normalized_balance = (balance_factor - bf_min) / (bf_max - bf_min + 1e-9)
    
    # Final priority with layered components
    priority = base_score * util_factor + 0.2 * normalized_balance
    
    # Reinforcement-inspired remaining capacity factor
    remaining_ratio = bins_remain_cap / (orig_cap + 1e-9)
    reinforcer = remaining_ratio ** 0.5
    
    priority *= reinforcer
    
    return np.where(eligible, priority, -np.inf)
```
