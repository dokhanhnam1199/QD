```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines min-max-normalized fit, variance-driven balance, and reinforcement learning.
    Uses predictive variance modeling and entropy-agnostic weights to balance tight fits
    with system-wide flexibility.
    """
    if bins_remain_cap.size == 0:
        return np.array([], dtype=np.float64)
    
    orig_cap = np.max(bins_remain_cap)
    if orig_cap <= 1e-9 or item <= 1e-9:
        return np.where(
            bins_remain_cap >= item,
            bins_remain_cap - item + 1e-9,
            -np.inf
        )
    
    eligible = bins_remain_cap >= item
    if not np.any(eligible):
        return np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)
    
    # System metrics
    system_mean = bins_remain_cap.mean()
    system_std = bins_remain_cap.std()
    system_var = system_std ** 2
    
    # Variance ratio for adaptive control
    var_rel = system_var / (orig_cap ** 2 + 1e-9)
    var_rel = np.clip(var_rel, 0.0, 1.0)
    
    # Eligible bin metrics
    eligible_remain = bins_remain_cap[eligible]
    leftover = eligible_remain - item
    tightness = item / (eligible_remain + 1e-9)
    
    # Adaptive weights
    fit_weight = 1.0 - var_rel
    balance_weight = np.sqrt(var_rel)
    
    # Balance component: minimize deviation from mean
    balance_component = -np.abs(leftover - system_mean) / (orig_cap + 1e-9)
    
    # Flexibility component: promote median-close leftover
    med_remain = np.median(eligible_remain)
    flex_component = -((leftover - med_remain) ** 2) / (orig_cap ** 2 + 1e-9)
    
    # Item size adaptation
    item_rel_size = item / (system_mean + 1e-9)
    fit_decay = np.exp(-item_rel_size * tightness)
    
    # Hybrid score assembly
    hybrid = (
        tightness * fit_weight +
        balance_component * balance_weight +
        flex_component * fit_decay
    )
    
    # Reinforcement-style future-promise multiplier
    rel_size = item / (np.median(eligible_remain) + 1e-9)
    rem_rel = bins_remain_cap / (orig_cap + 1e-9)
    fragility = (orig_cap - bins_remain_cap) / (orig_cap + 1e-9)
    reinforcer = 1.0 + 0.5 * ((1.0 - rel_size) ** 2) * rem_rel[eligible] * fragility[eligible]
    
    # Final priority with reinforcement scaling
    final_score = hybrid * reinforcer
    
    # Build return array with -inf for ineligible bins
    result = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)
    result[eligible] = final_score
    return result
```
