```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Blended exponential scoring using harmonic mean adaptation and continuous weighting.
    
    Combines Worst Fit (exp(remaining_cap)) and Best Fit (exp(-leftover)) via dynamic weighting
    based on item size relative to harmonic mean of remaining capacities. Smoothly prioritizes
    bin utilization while minimizing fragmentation.
    """
    valid_mask = bins_remain_cap >= item
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)
    
    if not np.any(valid_mask):
        return priorities
    
    # Compute harmonic mean of all bin remaining capacities (robust to zero values)
    total_inv = np.sum(1.0 / bins_remain_cap)
    H = len(bins_remain_cap) / total_inv if total_inv != 0 else 0.0
    
    # Dynamic weight based on item size relative to harmonic mean H
    weight_denominator = item + H
    weight = item / weight_denominator if weight_denominator > 0 else 0.0  # [0,1] range
    
    # Compute components for valid bins
    remaining = bins_remain_cap[valid_mask]
    leftover = remaining - item
    
    # Blended exponential scoring formula
    score_wf = np.exp(remaining)                # Worst Fit component
    score_bf = np.exp(-leftover)                # Best Fit component
    combined = (1.0 - weight) * score_wf + weight * score_bf
    
    priorities[valid_mask] = combined
    return priorities
```
