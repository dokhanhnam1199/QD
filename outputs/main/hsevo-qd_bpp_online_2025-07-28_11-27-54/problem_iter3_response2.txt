```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Hybrid strategy using adaptive item size classification and smooth tie-breaking."""
    if not bins_remain_cap.size:
        return np.empty(0)
    
    can_fit = bins_remain_cap >= item
    avg_remaining = bins_remain_cap.mean()
    
    # Adaptive item classification using dynamic threshold
    if item > avg_remaining:
        # Best Fit for large items: prioritize minimal residual space
        main_score = - (bins_remain_cap - item)  # Equivalent to item - bins_remain_cap
        # Smooth tie-breaker: prefer bins with higher remaining capacity ratio
        tie_breaker = np.log(bins_remain_cap + 1e-9)  # Logarithmic scaling for smoothness
    else:
        # Worst Fit for small items: preserve large gaps using secondary underfill penalty
        main_score = bins_remain_cap
        # Smooth tie-breaker: penalize bins with larger residual space relative to item
        tie_breaker = - (bins_remain_cap - item) / (item + 1e-9)
    
    scores = main_score + 1e-4 * tie_breaker  # Minimalistic secondary term blending
    return np.where(can_fit, scores, -np.inf).astype(np.float64)
```
