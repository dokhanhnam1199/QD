```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Adaptive priority combining residual minimization and dual fragmentation penalties.
    Uses dynamic threshold (feasible mean+std) and item-relative alpha blending.
    Combines v0's residual penalty with v1's threshold-based penalty for tighter control.
    """
    can_fit = bins_remain_cap >= item
    feasible_caps = bins_remain_cap[can_fit]
    
    # Dynamic statistics using feasible bins or all bins
    if feasible_caps.size == 0:
        mu, sigma = np.mean(bins_remain_cap), np.std(bins_remain_cap)
    else:
        mu, sigma = np.mean(feasible_caps), np.std(feasible_caps)
    
    T = np.clip(mu + sigma, 1e-8, None)        # Primary threshold
    alpha = 1.0 - np.exp(-item / (T + 1e-8))   # Adaptive weight
    
    r = bins_remain_cap - item                 # Residual capacity
    feasible_r = np.where(can_fit, r, np.inf)  # Mask infeasible bins
    
    # Primary penalty: exponential decay for small residuals (v0)
    penalty_main = np.exp(-feasible_r / (T + 1e-8))
    
    # Secondary penalty: deficit below mu - sigma (v1-inspired)
    threshold_v1 = mu - sigma
    delta = np.clip(threshold_v1 - feasible_r, 0.0, None)
    penalty_secondary = np.exp(-delta / (T + 1e-8))
    
    # Multi-objective blend with feasibility enforcement
    blended_score = alpha * (-r) + (1 - alpha) * (-penalty_main * penalty_secondary)
    
    return np.where(can_fit, blended_score, -np.inf)  # Feasibility masking
```
