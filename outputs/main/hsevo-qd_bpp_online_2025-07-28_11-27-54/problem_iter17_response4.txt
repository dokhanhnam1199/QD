```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Priority heuristic combining residual minimization and dynamic threshold penalties.
    Uses exponential scoring with adaptive scaling (tau, beta) and feasibility masking.
    """
    feasible = bins_remain_cap >= item
    if not feasible.any():
        return np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)
    
    r = bins_remain_cap - item
    feasible_r = r[feasible]
    
    mu = feasible_r.mean()
    std = feasible_r.std()
    tau = mu + std + 1e-6  # Dynamic scaling factor combining central tendency and spread
    beta = item / tau      # Adaptive weight balancing item size and bin statistics
    
    # Residual minimization via exponential decay (higher score = better fit)
    term1 = np.exp(-r / tau)
    
    # Fragmentation avoidance via threshold penalty (mu - std threshold)
    threshold = mu - std
    delta = np.clip(threshold - r, a_min=0.0, a_max=None)  # Threshold deficit
    term2 = np.exp(-delta * beta)  # Adaptive exponential penalty
    
    # Multiplicative objective blending with feasibility enforcement
    score = term1 * term2
    scores = np.where(feasible, score, -np.inf)
    
    return scores.astype(np.float64)
```
