```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Adaptive threshold with exponential scoring scaled by bin statistics.
    
    Uses mean-based dynamic threshold for item classification, exponential
    prioritization scaled by current bin spread (std), blending Worst Fit for
    small items and Best Fit for large items to minimize fragmentation.
    """
    # Calculate bin statistics
    mean_remaining = np.mean(bins_remain_cap)
    std_remaining = np.std(bins_remain_cap)
    
    # Dynamic threshold: pivot point for item classification
    threshold = mean_remaining * 0.7 + std_remaining * 0.3
    
    # Valid bin mask
    valid_mask = bins_remain_cap >= item
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)
    
    if np.any(valid_mask):
        if item <= threshold:
            # Adaptive Worst Fit: exponential amplification scaled by bin spread
            scale = max(1e-8, std_remaining)  # Avoid zero division
            priorities[valid_mask] = np.exp(bins_remain_cap[valid_mask] / scale)
        else:
            # Adaptive Best Fit: exponential decay scaled by bin spread
            leftover = bins_remain_cap[valid_mask] - item
            scale = max(1e-8, mean_remaining)
            priorities[valid_mask] = np.exp(-leftover / scale)
    
    return priorities
```
