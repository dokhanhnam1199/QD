```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Adaptive harmonic mean thresholding with smooth fit & bin scaling for efficient packing."""
    if len(bins_remain_cap) == 0:
        return np.array([])
    
    can_fit = bins_remain_cap >= item
    eps = 1e-9
    
    # Dynamic context modeling via harmonic mean of remaining capacities
    harmonic_mean = len(bins_remain_cap) / (np.sum(1.0 / (bins_remain_cap + eps)))
    is_large = item > (harmonic_mean * 0.8)  # Adaptive threshold with margin
    
    # Primary scoring components
    fit_ratio = item / (bins_remain_cap + eps)
    underfill_penalty = np.clip(bins_remain_cap - item, 0, None)
    
    # Smooth exponential weighting of fit quality and fragmentation control
    fit_score = np.exp(fit_ratio * 2) * can_fit
    penalty_score = np.exp(-underfill_penalty * 0.5) * can_fit
    
    # Adaptive strategy blending with inverse capacity scaling
    if is_large:
        # Prioritize tight fits for large items through multiplicative interaction
        score = fit_score * penalty_score
    else:
        # Prefer underutilized bins using inverse capacity scaling (Best Fit emulation)
        inv_scaling = (bins_remain_cap.mean() / (bins_remain_cap + eps))  # Inverse relation
        score = fit_score * penalty_score * inv_scaling  # Combined smooth factors
    
    return np.where(can_fit, score, -np.inf)
```
