```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority scores using adaptive ratio-based scoring with exponential penalty for small remainders.
    
    Scores are computed as ratio + beta * (-exp(-remaining_after/item)), where:
    - ratio = item_size / bin_remaining_cap (higher = better fit)
    - penalty term softly penalizes bins leaving very small gaps
    - beta controls the penalty strength (small weight for secondary term)
    """
    can_fit = bins_remain_cap >= item
    remaining_after = bins_remain_cap - item
    
    # Avoid division by zero in ratio calculation
    epsilon = 1e-9
    ratio = item / (bins_remain_cap + epsilon)
    
    # Exponential penalty for small remainders after placement
    beta = 0.1  # Small weight for secondary term
    penalty_term = -np.exp(-remaining_after / (item + epsilon))
    
    # Combine main fit term with underfill penalty
    scores = ratio + beta * penalty_term
    
    # Mask invalid bins with -inf
    return np.where(can_fit, scores, -np.inf)
```
