```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Dynamic threshold (mu-sigma) with exponential penalties for residual and fragmentation.
    
    Combines residual minimization and fragmentation avoidance via:
    1. Feasibility masking (-âˆž for invalid bins)
    2. Threshold T = mean - std to identify risky residuals
    3. Multiplicative exponential scoring: residual penalty * threshold deficit penalty
    """
    can_fit = bins_remain_cap >= item
    r = bins_remain_cap - item
    
    # Dynamic statistics
    mu = np.mean(bins_remain_cap)
    sigma = np.std(bins_remain_cap)
    T = np.clip(mu - sigma, 1e-8, None)  # Threshold to avoid fragmentation
    
    # Adaptive penalty scaling
    penalty_factor = 1.0 / (mu + 1e-8)
    
    # Fragmentation penalty (delta for residuals below threshold)
    delta = np.clip(T - r, 0.0, None)
    
    # Combined exponential objectives
    term1 = np.exp(-r * penalty_factor)  # Prefer smaller residuals
    term2 = np.exp(-delta * penalty_factor)  # Penalize residuals below T
    feasible_scores = term1 * term2
    
    return np.where(can_fit, feasible_scores, -np.inf)
```
