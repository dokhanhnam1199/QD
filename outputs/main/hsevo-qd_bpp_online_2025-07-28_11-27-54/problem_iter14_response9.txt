```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Priority function combining residual minimization, fragmentation avoidance, and soft feasibility penalties.
    
    Uses dynamic tau scaling from bin statistics, exponential penalty continuity, and avoids -inf masks.
    """
    feasible = bins_remain_cap >= item
    large_neg = -1e10  # Soft feasibility penalty instead of -inf
    
    if not feasible.any():
        return np.full_like(bins_remain_cap, large_neg, dtype=np.float64)
    
    r = bins_remain_cap - item
    feasible_r = r[feasible]
    
    mu = feasible_r.mean()
    std = feasible_r.std()
    eps = 1e-6
    tau = mu + std + eps  # Dynamic threshold combining central tendency and spread
    
    # Exponential penalty for fragmentation avoidance
    penalty_term = np.exp(-r / (tau + eps))
    
    # Adaptive weighting based on item-to-tau ratio
    beta = item / (tau + eps)
    
    # Multi-objective blending: residual minimization + fragmentation smoothing
    residual_objective = -r  # Prioritize bins with minimal residual
    fragmentation_objective = -beta * penalty_term  # Penalize bins causing fragmentation
    
    # Unified differentiable score
    score = residual_objective + fragmentation_objective
    
    # Replace infeasible bins with soft penalty instead of -inf
    return np.where(feasible, score, large_neg).astype(np.float64)
```
