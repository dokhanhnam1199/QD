```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Adaptive multi-objective priority combining residual minimization and fragmentation avoidance using dynamic thresholds and exponential penalties."""
    
    feasible = bins_remain_cap >= item
    r = bins_remain_cap - item
    
    # Compute stats on feasible or all bins
    if feasible.any():
        mu = np.mean(bins_remain_cap[feasible])
        sigma = np.std(bins_remain_cap[feasible])
    else:
        mu = np.mean(bins_remain_cap)
        sigma = np.std(bins_remain_cap)
    
    T = max(mu + sigma, 1e-8)  # Dynamic threshold for adaptive scaling
    
    # Adaptive blending weight based on item-to-threshold ratio
    alpha = 1.0 - np.exp(-item / T)
    
    # Fragmentation threshold (lower bound to penalize tight fits)
    frag_threshold = mu - sigma
    
    # Residual minimization term (negative residual rewards smaller residuals)
    residual_term = -r  
    
    # Fragmentation penalty: exponential penalty for residuals below frag_threshold
    delta = np.clip(frag_threshold - r, 0.0, None)  # Positive when r < frag_threshold
    frag_penalty = -np.exp(-delta / T)  # Softer penalty for minor threshold violations
    
    # Multi-objective blending with adaptive weights
    blended_score = alpha * residual_term + (1 - alpha) * frag_penalty
    
    # Enforce strict feasibility (infeasible bins have -inf priority)
    scores = np.where(feasible, blended_score, -np.inf)
    
    return scores
```
