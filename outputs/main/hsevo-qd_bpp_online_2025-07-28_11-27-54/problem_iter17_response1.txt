```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Combines residual minimization and fragmentation avoidance using μ+σ thresholding.
    
    Adaptive alpha blending based on item size relative to mean+stddev of capacities.
    """
    can_fit = bins_remain_cap >= item
    r = bins_remain_cap - item
    
    # Dynamic threshold using mean + standard deviation (avoids fragmentation)
    mean_cap = np.mean(bins_remain_cap)
    std_cap = np.std(bins_remain_cap)
    T = np.clip(mean_cap + std_cap, 1e-8, None)  # Context-aware threshold
    
    # Adaptive weight: sigmoidal response to item/T ratio
    alpha = 1.0 - np.exp(-item / T)  # Large items prioritize fit quality
    
    # Smooth penalty for residual capacity (exponential decay)
    feasible_r = np.where(can_fit, r, np.inf)
    penalty_term = np.exp(-feasible_r / T)  # Continuously differentiable scoring
    
    # Multi-objective blend: residual minimization (-r) + fragmentation avoidance (-penalty_term)
    blended_score = alpha * (-r) + (1 - alpha) * (-penalty_term)
    
    # Strict feasibility enforcement via -inf mask
    return np.where(can_fit, blended_score, -np.inf)
```
