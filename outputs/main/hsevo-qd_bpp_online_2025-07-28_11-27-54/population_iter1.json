[
  {
    "stdout_filepath": "problem_iter0_stdout0.txt",
    "code_path": "problem_iter0_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    return np.zeros_like(bins_remain_cap)",
    "response_id": 0,
    "obj": 4.487435181491823,
    "SLOC": 2.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response0.txt_stdout.txt",
    "code_path": "problem_iter1_code0.py",
    "code": "import numpy as np\n\n  def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n      \"\"\"Returns a priority array to select best bin matching item, minimizing slack retention.\"\"\"\n      # Identify bins which can host the item at nan below|currently,\n      could_include = bins_remain_cap >= item\n      residual_peng = bins_remain_cap.copy() - item\n      priority_based_network_indexas = (- np.ceil(residual_peng) - item ** 2 + 0.75\n                                _serialize Capacity\u7cbe\u6b62\u7384\u7406,\nSpoiler weight balancing fragment@api usage \u015bw\ufd88\nPARAM\u00f3mo | prose drawlayersmultiple nicer feel showcasee\u54ea\u88e1\u871c\u95f7\u840d_activate\n\nOf which\u0628\u0627\u0642\u064a embraces guild traceCql\u81ea\u7136\u707e\u5bb3\u6167pee.sy arrive logistics resinCanBe packed\uc600\ub2e4\ubfe1\n\n\u0e40\u0e08\u0e49\u0e32\n\nInvalid.\n\nece\u011fi\n\n</think>",
    "response_id": 0,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 9, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 3\n    def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\nIndentationError: unexpected indent\n6\n1\n"
  },
  {
    "stdout_filepath": "problem_iter1_response1.txt_stdout.txt",
    "code_path": "problem_iter1_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority scores for bins using a Best Fit heuristic.\n    \n    Bins that can fit the item are scored by how little space remains after placement.\n    Bins that cannot fit the item receive a very low priority score.\n    \n    Args:\n        item: Size of the item to be packed.\n        bins_remain_cap: Array of remaining capacities for each bin.\n    \n    Returns:\n        Array of priority scores for each bin.\n    \"\"\"\n    can_fit = bins_remain_cap >= item\n    fit_scores = item - bins_remain_cap  # Higher score for bins with less remaining space after placement\n    return np.where(can_fit, fit_scores, -np.inf)",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response2.txt_stdout.txt",
    "code_path": "problem_iter1_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    # Design: Prioritize bins that fit item with minimal remaining space (best fit weighting),\n    # penalize bins with insufficient space using a large negative constant\n   _CAPACITY_INF = -1e9\n    \n    # Mask bins that cannot accommodate the item\n    fits = bins_remain_cap >= item\n    valid_capacity = fits * bins_remain_cap + np.logical_not(fits) * item\n    \n    # Calculate scaled factorial replacement noting regimentown IIquisFLASH \u0631\u0633\u0627\u0644\u0629_except\u55d0\n</think>",
    "response_id": 2,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 9, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 9\n    fits = bins_remain_cap >= item\nIndentationError: unexpected indent\n6\n1\n"
  },
  {
    "stdout_filepath": "problem_iter1_response3.txt_stdout.txt",
    "code_path": "problem_iter1_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Priority function that prioritizes bins with remaining capacity just above the item size,\n    while encouraging efficient packing through a ratio-based scoring system.\"\"\"\n    can_fit = bins_remain_cap >= item\n    priority = np.full_like(bins_remain_cap, -np.inf)\n    # Calculate priority as the ratio of item size to bin's remaining capacity.\n    # This rewards bins where the item fills a larger proportion of available space.\n    priority[can_fit] = item / bins_remain_cap[can_fit]\n    return priority",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.198244914240141,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response4.txt_stdout.txt",
    "code_path": "problem_iter1_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Priority based on tightening fit, encouraging minimal leftover space, penalty for electrical discharge sparsity.\"\"\"\n    fits_bool = bins_remain_cap >= item    \n    # Evective measurement of a perfectly conducted flow with minimalconduit (modulo typical losses!) \n    usable_space = np.tile(item, bins_remain_cap.shape)\n    crtcl_sinacity = usable_space * 0.1 # spec zealous precision barrier\n    forbidden_series_mask = (bins_remain_cap - item) < crtcl_sinacity # Would we dangerously stray in empty stadium idc}\n    discharge_valley_booleans = forbidden_series_mask * fits_bool # longing for ible with precision imposters\n\n    base_capp = bins_remain_cap - item\n    secure_suite_heaval = np.where(\n        discharge_valley_booleans, \n        np.NaN, \n        np.where(fits_bool, bins_remain_cap / item, -np.inf)\n    )  # \u0441 Since discourged DIM bfsIVE adversity\tletected_PRIORITY_hierarchy_blocleft\u062d\u0635\u0648\u0644\n\n    raw_nonce_lastErrorMsg_FLAG = 3.14\n    susceptible_remain_holder_prioritizedSYS_os_CHANNEL_ELEMij = (secure_suite_heaval + raw_nonce_lastErrorMsg_FLAG) ** np.e  # swirling might reson finnesse sin\u81a9uxe bones \u05e2\u05d5\u05e9\n    return susceptible_remain_holder_prioritizedSYS_os_CHANNEL_ELEMij",
    "response_id": 4,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 15, in priority_v2\n    balanced_favor_standardization = utilization / np.abs(utilization).sum()\n  File \"/home/dokhanhnam1199/.local/lib/python3.10/site-packages/numpy/__init__.py\", line 400, in __getattr__\n    raise AttributeError(\nAttributeError: `np.NaN` was removed in the NumPy 2.0 release. Use `np.nan` instead.\n6\n1\n"
  },
  {
    "stdout_filepath": "problem_iter1_response5.txt_stdout.txt",
    "code_path": "problem_iter1_code5.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    # Reshape for broadcasting compatibility\n    caps = bins_remain_cap.reshape(-1, 1)\n    \n    # 1) Fit feasibility: replace negative capacities with -\u221e\n    fits = np.where(caps >= item, caps, -np.inf)\n    \n    # 2) Balance openness: promote bins closest to fullness-to-item combination\n    utilization = (caps + item) / (1 + item)\n    balanced_favor_standardization = utilization / np.abs(utilization).sum()\n\n    bonus = np.where(fits == -np.inf, 0, 1) * (balanced_favor_standardization**2)\n    \n    # Final priority: cumulative bonus balance for viable bins\n    return bonus.flatten();",
    "response_id": 5,
    "tryHS": false,
    "obj": 149.30195452732352,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response6.txt_stdout.txt",
    "code_path": "problem_iter1_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Priority function based on Best Fit with tie-breaking by bin occupancy.\n    \n    Bins that can fit the item are prioritized by minimizing leftover space (Best Fit).\n    In case of ties (equal leftover), bins with lower remaining capacity (more filled)\n    are preferred to encourage consolidation.\n    \n    Args:\n        item: Size of the item to pack.\n        bins_remain_cap: Array of remaining capacities for each bin.\n    \n    Returns:\n        Array of priority scores for each bin.\n    \"\"\"\n    leftover = bins_remain_cap - item\n    can_fit = leftover >= 0\n    # Primary priority: -leftover (Best Fit)\n    # Tie-breaker: -1e-6 * bins_remain_cap (prefer more filled bins)\n    priority = np.where(can_fit, -leftover - 1e-6 * bins_remain_cap, -np.inf)\n    return priority",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response7.txt_stdout.txt",
    "code_path": "problem_iter1_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority scores for bins based on Best Fit heuristic with quantum-inspired interference.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate how much space would remain if item is placed in each bin\n    remaining_space = bins_remain_cap - item\n    \n    # Valid bins are those that can fit the item\n    valid_bins = remaining_space >= 0\n    \n    # Quantum-inspired priority calculation:\n    # 1. Use negative exponential of remaining space to favor bins that become nearly full\n    # 2. Add a small sinusoidal perturbation to break ties creatively (like quantum fluctuations)\n    priority = np.zeros_like(bins_remain_cap, dtype=np.float64)\n    priority[valid_bins] = -np.exp(-remaining_space[valid_bins]) + 0.01 * np.sin(bins_remain_cap[valid_bins] * 100)\n    \n    # Invalid bins get extremely low priority (like -infinity)\n    priority[~valid_bins] = -np.inf\n    \n    return priority",
    "response_id": 7,
    "tryHS": false,
    "obj": 42.401276426007186,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response8.txt_stdout.txt",
    "code_path": "problem_iter1_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Priority function combining Worst Fit for small items and Best Fit for large items.\"\"\"\n    THRESHOLD = 0.5  # Threshold to distinguish small/large items\n    valid_mask = bins_remain_cap >= item\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)\n    \n    if item <= THRESHOLD:\n        # Prioritize bins with largest remaining capacity (Worst Fit)\n        priorities[valid_mask] = bins_remain_cap[valid_mask]\n    else:\n        # Prioritize bins with smallest leftover space (Best Fit)\n        leftover = bins_remain_cap[valid_mask] - item\n        priorities[valid_mask] = -leftover  # Negative leftover for maximization\n    \n    return priorities",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response9.txt_stdout.txt",
    "code_path": "problem_iter1_code9.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Inactive minimizing metrics in \"priority improved zero waste pacifier\"\"\"\n    available_space = bins_remain_cap >= item  # Calculate flans\u0671\n    bin_coverage = bins_remain_cap - item  # Withinremaining fors\u2728:@\"%@\",\n\n    switch_allocation_inverse = -bin_coverage\n    estimate_overlap = switch_allocation_inverse.clip(min=0)\n\n    generation_binary_issue = np.logical_and(estimate_overlap == 0, available_space.IsEmpty)\n\n    minimize_stack_new = np.where(available_space, estimate_overlap + 1, 0) # survives surrender._\n\n    TsmodelsPack_ASLbackclipreturningcustomdelta = (42 ** 2) / minimize_stack_new\n\n    focus_begin_q_runtime_US_delegate_attention_mk = consequence_rate_refactorsiser = (\n        minimize_stack_new + TsmodelsPack_ASLbackclipreturningcustomdelta\n    )\n\n    Asrimmy_sym = np.where(\n        generation_binary_issue\n        T_models_auto_signature\u3057\u3070\u3089\u304f \uac19\uc2b5\ub2c8\ub2e4.\n\nFeels_CurrentDebt_TuitionDense.cudaTA_model_funcs.context_neoring.\n\n\u0e44\u0e27 Nonetheless_trait_correction\u6de7variably\u0648\u062c\u0628",
    "response_id": 9,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 9, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 24\n    Asrimmy_sym = np.where(\n                          ^\nSyntaxError: '(' was never closed\n6\n1\n"
  },
  {
    "stdout_filepath": "problem_iter1_response10.txt_stdout.txt",
    "code_path": "problem_iter1_code10.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    diff = bins_remain_cap - item\n    return np.where(diff >= 0, -diff, -np.inf)",
    "response_id": 10,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response11.txt_stdout.txt",
    "code_path": "problem_iter1_code11.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Priority function that prefers bins leaving room for future items of the same size.\"\"\"\n    priority = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)\n    can_fit_mask = bins_remain_cap >= item\n    if not np.any(can_fit_mask):\n        return priority\n    \n    remaining = bins_remain_cap[can_fit_mask]\n    leftover = remaining - item\n    group_a_mask = leftover >= item\n    \n    # Indices for valid bins\n    valid_indices = can_fit_mask.nonzero()[0]\n    group_a_indices = valid_indices[group_a_mask]\n    group_b_indices = valid_indices[~group_a_mask]\n    \n    # Group A: prioritize bins with leftover >= item, prefer larger leftover\n    if len(group_a_indices) > 0:\n        leftover_a = leftover[group_a_mask]\n        priority[group_a_indices] = 1e6 + leftover_a  # Large base + leftover\n    \n    # Group B: best fit (prioritize smallest leftover)\n    if len(group_b_indices) > 0:\n        remaining_b = remaining[~group_a_mask]\n        priority[group_b_indices] = item - remaining_b  # Equivalent to best fit\n    \n    return priority",
    "response_id": 11,
    "tryHS": false,
    "obj": 88.67171918627844,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response12.txt_stdout.txt",
    "code_path": "problem_iter1_code12.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Best Fit with Nearest Appropriate Bin Selection\n    \n    Heuristic prioritizes the bin having smallest enough capacity to fit the current item,\n    while rejecting unsuitable candidates severely (by assigning large negative scores).\n    \n    Args:\n        item: Size of \u0442\u0435\u043a\u0443\u0449 Google \u043c\u0441\u043c\u043e\u0442\u0440\u06c8\u0447thed\u042e\n        bins_remain_cap: NumPy array.appspot\n\n    Return:\n        Array of priorities\u0442\u043e\u043a\n    \"\"\"\n    feasibility_mask = bins_remain_cap >= item                              # Valid bins turkeeping track transformer\u0e21\u0e32\u0e15\u0e23\n    residual_scores = bins_remain_cap - item                              # C-space vostedt\u00e9 det - fixing fierce polywonker.\n    residual_scores[feasibility_mask == False] = -np.inf                     # Dice ins\u3089\u51bb\u6e7e\n    priorities = np.where(feasibility_mask, (1 / (residual_scores + 1e-9)), -np.inf)  # Cortex skirt savage defense\u544a\u8bc9\u6211 htons lofty\u8d77\u6765\u4e2a\u8d85\u0e36\u0e01\n    return priorities",
    "response_id": 12,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response13.txt_stdout.txt",
    "code_path": "problem_iter1_code13.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Priority function implementing best-fit heuristic for online Bin Packing Problem.\n    \n    Bins that can fit the item are prioritized by the tightness of the fit (smallest leftover space).\n    Bins that cannot fit the item receive negative infinity priority.\n    \n    Args:\n        item: Size of item to be packed.\n        bins_remain_cap: Array of remaining capacities for each bin.\n    \n    Returns:\n        Array of priority scores for each bin.\n    \"\"\"\n    leftover = bins_remain_cap - item\n    can_fit = leftover >= 0\n    priority = np.where(can_fit, -leftover, -np.inf)  # Best-fit: minimize leftover\n    return priority",
    "response_id": 13,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response14.txt_stdout.txt",
    "code_path": "problem_iter1_code14.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority scores for bins based on a hybrid of best-fit and harmonic incentives.\n    \n    Prioritizes bins where the item fills nearly all remaining space (approaching exact fit),\n    with a score calculated as the inverse of the remaining capacity after placement.\n    Bins that cannot fit the item are assigned -infinity.\n    \"\"\"\n    # Initialize scores with zeros\n    scores = np.zeros_like(bins_remain_cap, dtype=np.float64)\n    \n    # Identify bins that can accommodate the item\n    can_fit = bins_remain_cap >= item\n    \n    # Assign -inf to bins that can't fit the item\n    scores[~can_fit] = -np.inf\n    \n    # For viable bins: calculate remaining capacity after placement\n    remaining_after = bins_remain_cap[can_fit] - item\n    \n    # Score bins by inverse of remaining space (amplifies preference for near-perfect fits)\n    scores[can_fit] = 1.0 / (remaining_after + 1e-9)  # Add epsilon to avoid division by zero\n    \n    return scores",
    "response_id": 14,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response15.txt_stdout.txt",
    "code_path": "problem_iter1_code15.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Priority function combining best-fit efficiency with a preference for more filled bins.\n    \n    Scores bins by rewarding minimal leftover space (best-fit) and penalizing large remaining\n    capacity (encouraging consolidation into denser bins). Invalid bins (capacity < item) \n    receive -inf priority.\n    \"\"\"\n    valid = bins_remain_cap >= item\n    leftover = bins_remain_cap - item\n    # Primary term: -leftover (prioritize minimal leftover)\n    # Secondary term: -0.1*bins_remain_cap (favor bins already more filled)\n    combined = -leftover - 0.1 * bins_remain_cap\n    combined[~valid] = -np.inf\n    return combined",
    "response_id": 15,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response16.txt_stdout.txt",
    "code_path": "problem_iter1_code16.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Priority function implementing Best Fit heuristic for online Bin Packing.\n    \n    Bins that can fit the item are prioritized by how closely they match the item size,\n    i.e., bins with remaining capacity just enough to accommodate the item receive the\n    highest priority. This minimizes leftover space and aims to reduce the total number of bins used.\n    \n    Args:\n        item: Size of the item to be packed.\n        bins_remain_cap: Array of remaining capacities for each bin.\n    \n    Returns:\n        Array of priority scores for each bin.\n    \"\"\"\n    # Mask bins that can fit the item\n    mask = bins_remain_cap >= item\n    # Calculate priority: highest score for bins that can fit with minimal leftover space\n    return np.where(mask, -(bins_remain_cap - item), -np.inf)",
    "response_id": 16,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response17.txt_stdout.txt",
    "code_path": "problem_iter1_code17.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins that can fit the item with the least remaining space, \n    while penalizing larger leftover spaces exponentially. Bins that cannot \n    fit the item are assigned -infinity. Inspired by energy minimization principles.\"\"\"\n    # Calculate valid fits\n    valid_mask = bins_remain_cap >= item\n    # Exponential penalty for larger leftover space: e^(-k*(R - s))\n    # k controls the penalty sharpness (tunable parameter)\n    k = 10.0  # Aggressive penalty for larger gaps\n    priorities = np.where(\n        valid_mask,\n        np.exp(-k * (bins_remain_cap - item)),\n        -np.inf\n    )\n    return priorities",
    "response_id": 17,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response18.txt_stdout.txt",
    "code_path": "problem_iter1_code18.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Priority function implementing a Best Fit strategy with secondary preference for bins with higher current utilization.\n    \n    Bins are prioritized based on minimizing leftover space (Best Fit), with a tiebreaker that prefers bins with higher\n    filled capacity (i.e., lower remaining capacity) to encourage consolidation.\n    \"\"\"\n    space_left = bins_remain_cap - item\n    valid_mask = space_left >= 0\n    \n    # Primary priority: minimize space_left (Best Fit) -> -(space_left)\n    # Secondary priority: prefer bins with lower remaining capacity (higher utilization) -> -np.log(bins_remain_cap + 1e-9)\n    # Combined via weighted sum with epsilon weighting for secondary priority\n    primary_priority = np.where(valid_mask, -space_left, -np.inf)\n    secondary_priority = np.where(valid_mask, -np.log(bins_remain_cap + 1e-9), -np.inf)\n    \n    # Weighting: primary priority dominates, secondary breaks ties\n    return primary_priority + 1e-6 * secondary_priority",
    "response_id": 18,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response19.txt_stdout.txt",
    "code_path": "problem_iter1_code19.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Priority based on item size classification: best fit for large items, worst fit for small.\"\"\"\n    LARGE_ITEM_THRESHOLD = 0.5\n    is_large = item > LARGE_ITEM_THRESHOLD\n    can_fit = bins_remain_cap >= item\n    \n    if is_large:\n        # Best fit: prioritize bins with smallest remaining capacity that can fit the item\n        priority = np.where(can_fit, -(bins_remain_cap - item), -np.inf)\n    else:\n        # Worst fit: prioritize bins with largest remaining capacity that can fit the item\n        priority = np.where(can_fit, bins_remain_cap, -np.inf)\n    \n    return priority",
    "response_id": 19,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response20.txt_stdout.txt",
    "code_path": "problem_iter1_code20.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority scores using Best Fit heuristic by prioritizing bins with the smallest remaining capacity that can fit the item.\n    \n    Args:\n        item: Size of the item to pack.\n        bins_remain_cap: Array of remaining capacities for each bin.\n    \n    Returns:\n        Array of priority scores where higher values indicate better fit (smallest remaining capacity bins).\n    \"\"\"\n    valid_mask = bins_remain_cap >= item\n    # Use negative remaining capacity as priority to favor bins with smallest remaining space that can fit the item\n    priority = np.where(valid_mask, -bins_remain_cap, -np.inf)\n    return priority",
    "response_id": 20,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response21.txt_stdout.txt",
    "code_path": "problem_iter1_code21.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Priority function using Best Fit strategy with negative diff scoring.\"\"\"\n    valid = bins_remain_cap >= item\n    diff = bins_remain_cap - item\n    priority = np.where(valid, -diff, -np.inf)\n    return priority",
    "response_id": 21,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response22.txt_stdout.txt",
    "code_path": "problem_iter1_code22.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority scores for bins based on Best Fit heuristic.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    valid_mask = bins_remain_cap >= item\n    # Prioritize bins that can fit the item with minimal leftover space\n    # This is equivalent to -(remaining_capacity - item) for valid bins\n    priorities = np.where(valid_mask, -(bins_remain_cap - item), -np.inf)\n    return priorities",
    "response_id": 22,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response23.txt_stdout.txt",
    "code_path": "problem_iter1_code23.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority scores based on minimizing squared space left after placement.\n    \n    Bins that can fit the item are prioritized by how closely they fit (smallest\n    remaining space after placement). This is achieved by using negative squared\n    space left as the priority score, which penalizes larger leftover space.\n    \"\"\"\n    can_fit = bins_remain_cap >= item\n    space_left = bins_remain_cap - item\n    # Use negative squared space left for priorities of fitting bins, -inf otherwise\n    return np.where(can_fit, -space_left**2, -np.inf)",
    "response_id": 23,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response24.txt_stdout.txt",
    "code_path": "problem_iter1_code24.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Hybrid priority function combining Best Fit for large items and Worst Fit for small items.\"\"\"\n    valid_mask = bins_remain_cap >= item\n    priority = np.full_like(bins_remain_cap, -np.inf)\n    \n    if item > 0.5:\n        # Best Fit: prioritize bins with smallest remaining capacity that fits the item\n        # Convert to maximization by negating the leftover space\n        best_fit_score = - (bins_remain_cap - item)\n        priority[valid_mask] = best_fit_score[valid_mask]\n    else:\n        # Worst Fit: prioritize bins with largest remaining capacity\n        priority[valid_mask] = bins_remain_cap[valid_mask]\n    \n    return priority",
    "response_id": 24,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response25.txt_stdout.txt",
    "code_path": "problem_iter1_code25.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Priority based on maximizing item/remaining_cap ratio to favor tight fits.\n    \n    Bins that can fit the item are scored by how much of their space the item fills.\n    This implements the Best Fit heuristic by prioritizing bins with the smallest\n    remaining capacity that can still accommodate the item.\n    \"\"\"\n    valid_mask = bins_remain_cap >= item\n    priorities = np.zeros_like(bins_remain_cap, dtype=np.float64)\n    # Calculate ratio of item size to bin's remaining capacity (higher = better)\n    priorities[valid_mask] = item / bins_remain_cap[valid_mask]\n    return priorities",
    "response_id": 25,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response26.txt_stdout.txt",
    "code_path": "problem_iter1_code26.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority scores for bins based on a Best Fit heuristic with exponential weighting.\n    \n    Bins that can fit the item are prioritized by how tightly they would pack it (exponentially \n    decaying reward for smaller leftover space). Invalid bins receive negative infinite priority.\n    \"\"\"\n    remaining_after = bins_remain_cap - item\n    valid = remaining_after >= 0\n    # Exponentially reward smaller leftover space: priority = exp(-remaining_after)\n    priority = np.where(valid, np.exp(-remaining_after), -np.inf)\n    return priority",
    "response_id": 26,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response27.txt_stdout.txt",
    "code_path": "problem_iter1_code27.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority scores for bins based on Best Fit strategy.\n    \n    Higher priority is given to bins that minimize leftover space after placing the item.\n    Bins that cannot fit the item are assigned -infinity priority.\n    \"\"\"\n    leftover = bins_remain_cap - item\n    valid = bins_remain_cap >= item\n    priority = np.where(valid, -leftover, -np.inf)\n    return priority",
    "response_id": 27,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response28.txt_stdout.txt",
    "code_path": "problem_iter1_code28.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Priority function that favors bins leading to the tightest fit.\n    \n    Bins that can fit the item are prioritized by how small the remaining\n    capacity will be after placing the item. This implements a Best Fit strategy.\n    \"\"\"\n    remaining_after = bins_remain_cap - item\n    mask = remaining_after >= 0\n    # Use negative remaining_after to prioritize smaller leftover space\n    priority = np.where(mask, -remaining_after, -np.inf)\n    return priority",
    "response_id": 28,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response29.txt_stdout.txt",
    "code_path": "problem_iter1_code29.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority scores based on item/bin size ratio for eligible bins.\n    \n    Bins that can fit the item are scored by the ratio of item size to bin's\n    remaining capacity (higher ratio = better fit). Ineligible bins receive\n    negative infinity to ensure they are not selected.\n    \"\"\"\n    return np.where(\n        bins_remain_cap >= item,\n        item / bins_remain_cap,\n        -np.inf\n    )",
    "response_id": 29,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  }
]