```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority scores for bins using threshold-anchored non-smooth scoring.
    
    Bins that can fit the item are scored based on static thresholds relative to item size:
    - Highest priority for bins with remaining capacity in [item, 1.1*item)
    - Mid-high priority for [1.1*item, 1.5*item)
    - Mid priority for [1.5*item, 2.0*item)
    - Low priority for bins with >= 2.0*item remaining
    Bins that cannot fit the item receive -inf priority.
    """
    can_fit = bins_remain_cap >= item
    scores = np.full_like(bins_remain_cap, fill_value=-np.inf, dtype=np.float64)
    
    if not np.any(can_fit):
        return scores
    
    # Thresholds anchored to item size
    t1 = item * 1.1
    t2 = item * 1.5
    t3 = item * 2.0
    
    # Vectorized tier assignment using step functions
    scores = np.where(can_fit, 0.5, scores)  # Base priority for bins >=2.0*item
    
    mid_mask = (bins_remain_cap >= t2) & (bins_remain_cap < t3)
    scores = np.where(mid_mask, 1.0, scores)
    
    mid_high_mask = (bins_remain_cap >= t1) & (bins_remain_cap < t2)
    scores = np.where(mid_high_mask, 2.0, scores)
    
    high_mask = (bins_remain_cap >= item) & (bins_remain_cap < t1)
    scores = np.where(high_mask, 3.0, scores)
    
    return scores
```
