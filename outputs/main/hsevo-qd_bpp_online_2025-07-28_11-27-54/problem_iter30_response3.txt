```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Priority function using statistical adaptation, exponential blending, and asymptotic penalties."""
    feasible = bins_remain_cap >= item
    if not feasible.any():
        return np.full_like(bins_remain_cap, -np.inf)
    
    residuals = bins_remain_cap - item
    feasible_residuals = residuals[feasible]
    
    # Dynamic statistical adaptation
    mu_r = feasible_residuals.mean()
    sigma_r = feasible_residuals.std() + 1e-6  # Avoid division by zero
    
    # Contextual scaling with item size harmonics
    scaled_residuals = residuals / (item + 1e-6)
    
    # Primary penalty: exponential decay with asymptotic weighting
    primary_penalty = np.exp(-scaled_residuals)
    
    # Secondary penalty: inverse proportionality to z-score outliers
    z_scores = (residuals - mu_r) / sigma_r
    secondary_penalty = np.exp(-z_scores)  # Rewards bins below mean residual
    
    # Smooth exponential blending
    combined_score = primary_penalty * secondary_penalty
    
    return np.where(feasible, combined_score, -np.inf)
```
