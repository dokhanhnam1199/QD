```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority scores using dynamic statistical adaptation with smooth exponential blending.
    
    Combines asymptotically scaled residual minimization and secondary density penalties via:
    1. Exponential penalty for residual space (contextually scaled by item size)
    2. Multiplicative inverse density penalty (smoothly favors packed bins)
    3. Rigorous feasibility masking with -inf for invalid bins
    
    Args:
        item: Size of the item to be packed.
        bins_remain_cap: Array of remaining capacities for each bin.
    
    Returns:
        Array of priority scores for each bin.
    """
    can_fit = bins_remain_cap >= item
    eps = 1e-8  # Avoid division by zero
    
    # Primary residual minimization with exponential asymptotic weighting
    residual = bins_remain_cap - item
    scaled_residual = residual / (item + eps)  # Contextual scaling by item size
    exp_residual_penalty = np.exp(-scaled_residual)  # Smooth penalty for larger residuals
    
    # Secondary density penalty via inverse proportionality to bin sparsity
    density_penalty = 1.0 / (bins_remain_cap + eps)  # Favors denser bins
    
    # Smooth multiplicative blending of objectives
    combined_score = exp_residual_penalty * density_penalty
    
    # Apply strict feasibility masking
    return np.where(can_fit, combined_score, -np.inf)
```
