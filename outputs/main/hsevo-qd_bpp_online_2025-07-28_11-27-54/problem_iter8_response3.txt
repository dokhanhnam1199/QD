```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Contextual exponential prioritization with adaptive thresholds and fragmentation minimization.
    
    Uses dynamic item size classification against current residual capacities (mean + 0.2*std) as threshold.
    Combines worst-fit-attraction (exp(rem_cap)) for small items with penalty for partial underfills
    (exp(-0.5*sqrt(leftover))) for large items, ensuring smooth bin selection behavior.
    """
    # Adaptive threshold: item-relative decision boundary
    capacity_stats = bins_remain_cap[bins_remain_cap > 0]
    THRESHOLD = np.mean(capacity_stats) + 0.2 * np.std(capacity_stats)
    
    valid_mask = bins_remain_cap >= item
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)
    
    if item <= THRESHOLD:
        # Smooth Worst Fit with residual amplification
        priorities[valid_mask] = np.exp(bins_remain_cap[valid_mask]) * (1 + 0.3*(bins_remain_cap[valid_mask]-item))
    else:
        # Best Fit fragment avoidance with sqrt penalty
        leftover = bins_remain_cap[valid_mask] - item
        priorities[valid_mask] = np.exp(-0.5 * np.sqrt(leftover))
    
    return priorities
```
