```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Adaptive Fit: Combines Best-Fit (large items) and Worst-Fit (small items) via dynamic item-to-mean ratio.
    
    Key idea: 
    - Uses item/mean_capacity to blend Best-Fit (1/residual) and Worst-Fit (bin capacity) smoothly.
    - Prefer tight fits for large items, preserve space for small items. Maintains simplicity and smoothness."""
    
    feasibility_mask = bins_remain_cap >= item
    residual_scores = bins_remain_cap - item
    
    # Valid bin handling
    valid_caps = bins_remain_cap[feasibility_mask]
    if not np.any(feasibility_mask):
        return np.full_like(bins_remain_cap, -np.inf)
    
    # Adaptive weight calculation
    mean_capacity = np.mean(valid_caps)
    relative_item = item / (mean_capacity + 1e-9)
    weight = np.clip(relative_item, 0.0, 1.0)  # Best-Fit (1) for large items, Worst-Fit (0) for small items
    
    # Combined scoring
    best_fit = 1.0 / (residual_scores + 1e-9)
    worst_fit = bins_remain_cap
    combined = weight * best_fit + (1 - weight) * worst_fit
    
    # Mask invalid bins
    combined[~feasibility_mask] = -np.inf
    return combined
```
