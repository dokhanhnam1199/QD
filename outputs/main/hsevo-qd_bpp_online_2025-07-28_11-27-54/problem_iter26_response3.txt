```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Smooth adaptive blending of residual minimization and item-relative fragmentation avoidance.
    
    Uses median-based alpha blending and exponential penalty normalized by item size
    to balance tight packing with fragment avoidance. Feasibility masked with -inf.
    """
    # Determine feasible bins and post-placement residual capacities
    can_fit = bins_remain_cap >= item
    remaining_after = bins_remain_cap - item

    # Dynamic statistical context using median remaining capacity
    T = np.clip(np.median(bins_remain_cap), 1e-8, None)
    
    # Adaptive weight: large items (relative to T) prioritize residual minimization
    alpha = 1.0 - np.exp(-item / T)
    
    # Item-relative penalty term using normalized residual (remaining_after/item)
    normalized_r = remaining_after / (item + 1e-8)  # Avoid division by zero
    penalty_term = np.exp(-normalized_r)
    
    # Combined objective: balance residual (-remaining_after) and penalty (-penalty_term)
    blended_score = alpha * (-remaining_after) + (1 - alpha) * (-penalty_term)
    
    # Enforce constraints with negative infinity mask
    return np.where(can_fit, blended_score, -np.inf)
```
