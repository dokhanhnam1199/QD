```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    can_fit = bins_remain_cap >= item
    feasible_bins = bins_remain_cap[can_fit]
    
    if not np.any(can_fit):
        return np.full_like(bins_remain_cap, -np.inf)
    
    # Contextual statistics
    mu_remain = np.mean(bins_remain_cap)
    sigma_remain = np.std(bins_remain_cap)
    
    # Adaptive weight via sigmoid-normalized z-score
    z = (item - mu_remain) / (sigma_remain + 1e-8)
    weight_bf = 1.0 / (1.0 + np.exp(-z))  # Smooth transition weight [0,1]
    
    # Core components
    residual = bins_remain_cap - item
    bf_component = -residual  # Best Fit: minimize residual
    wf_component = bins_remain_cap  # Worst Fit proxy: maximize remaining capacity
    
    # Smooth multi-objective blending
    blended_score = weight_bf * bf_component + (1.0 - weight_bf) * wf_component
    
    # Continuity-preserving exponential amplification
    exp_scale = np.clip(mu_remain, a_min=1e-2, a_max=None)
    continuity_score = np.exp(blended_score / exp_scale)
    
    # Feasibility masking
    priority = np.where(can_fit, continuity_score, -np.inf)
    
    return priority
```
