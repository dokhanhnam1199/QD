```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    # Compute dynamic bin statistics
    mu = np.mean(bins_remain_cap)
    sigma = np.std(bins_remain_cap)
    epsilon = 1e-8  # Small epsilon to prevent division by zero

    # Adaptive penalty factor based on average remaining capacity
    penalty_factor = 1.0 / (mu + epsilon)
    
    # Threshold for fragmentation avoidance (1Ïƒ below mean)
    threshold = mu - sigma
    
    # Residual in remaining capacity after placing the item
    residual = bins_remain_cap - item
    feasible = residual >= 0
    
    # Compute feasible bin scores
    # Term1: Exponential decay for residual minimization
    term1 = np.exp(- residual * penalty_factor)
    
    # Term2: Fragmentation penalty (exponential decay on threshold deficit)
    delta = np.clip(threshold - residual, a_min=0.0, a_max=None)
    term2 = np.exp(- delta * penalty_factor)
    
    feasible_scores = term1 * term2
    
    # Compute infeasible bin scores (soft penalty)
    deficit = item - bins_remain_cap
    infeasible_scores = np.exp(- deficit * penalty_factor * 5.0)  # Stronger penalty for overflow
    
    # Combine using convex-like combination (soft masking)
    scores = np.where(feasible, feasible_scores, infeasible_scores)
    
    return scores
```
