```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Priority heuristic combining statistical and item-relative scaling.
    
    Uses adaptive tau combining feasible residual stats and item size for smooth exponential scoring.
    """
    feasible = bins_remain_cap >= item
    if not feasible.any():
        return np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)
    
    r = bins_remain_cap - item
    feasible_r = r[feasible]
    
    mu = feasible_r.mean()
    std = feasible_r.std()
    eps = 1e-6
    # Combine statistical spread (mu/std) and item size for contextual scaling
    tau = mu + std + np.sqrt(item) + eps  # Item-root scaling improves size adaptivity
    beta = item / tau
    
    # Multi-scale exponential penalty: rewards tight fits while avoiding micro-fragments
    penalty_term = np.exp(-r / tau) + 0.5 * np.exp(-r / (item + eps))  
    
    residual_objective = -r  # Primary best-fit objective
    fragmentation_objective = -beta * penalty_term  # Adaptive fragmentation penalty
    
    score = residual_objective + fragmentation_objective
    
    return np.where(feasible, score, -np.inf).astype(np.float64)
```
