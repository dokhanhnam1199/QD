```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Dynamic item-relative normalization with median-based exponential penalty.
    
    Combines residual minimization and fragmentation avoidance via:
    1. Item-size normalization to adapt to varying scales
    2. Median-driven threshold for contextual penalty scaling
    3. Smooth exponential penalty shaping normalized residuals
    
    Args:
        item: Size of the item to be packed.
        bins_remain_cap: Array of remaining capacities for each bin.
    
    Returns:
        Array of priority scores for each bin.
    """
    can_fit = bins_remain_cap >= item
    r = bins_remain_cap - item  # Residual capacity after placement
    
    # Normalize residuals by item size for scale-invariant decision making
    r_norm = np.where(can_fit, r / (item + 1e-8), np.inf)  # Avoid division by zero
    
    # Dynamic threshold based on median of normalized residuals
    feasible_r_norm = r_norm[can_fit]
    T = np.median(feasible_r_norm) if len(feasible_r_norm) > 0 else 1e-8
    T = np.clip(T, 1e-8, None)  # Ensure minimum threshold
    
    # Exponential penalty for small normalized residuals
    penalty = np.exp(-r_norm / T)
    
    # Continuous objective: balance residual minimization with penalty shaping
    blended_score = -r - penalty  # Primary: residual minimization, Secondary: penalty
    
    # Apply feasibility mask with negative infinity for invalid bins
    return np.where(can_fit, blended_score, -np.inf)
```
