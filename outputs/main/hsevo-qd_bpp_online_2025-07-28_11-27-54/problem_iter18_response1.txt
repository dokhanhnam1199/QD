```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority scores for bins using a distribution-aware heuristic with smooth exponential scoring.
    
    Combines residual minimization and fragmentation penalties via adaptive weights derived from
    real-time distribution statistics (mean, std). Dynamic thresholds (mean - std) identify critical
    residual ranges for penalty activation. Smooth exponential terms ensure gradient stability.
    
    Args:
        item: Size of the item to be packed.
        bins_remain_cap: Array of remaining capacities for each bin.
    
    Returns:
        Array of priority scores for each bin.
    """
    can_fit = bins_remain_cap >= item
    if not np.any(can_fit):
        return np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)
    
    # Distribution-aware parameters
    mu = np.mean(bins_remain_cap)
    sigma = np.std(bins_remain_cap)
    threshold = mu - sigma  # Dynamic lower-bound threshold
    
    # Adaptive scaling factors
    alpha = 1.0 / (mu + 1e-9)
    beta = sigma / (mu + 1e-9)
    
    # Core metrics
    residuals = bins_remain_cap - item
    
    # Smooth scoring components
    residual_score = np.exp(-alpha * residuals)
    penalty_magnitude = np.clip(threshold - residuals, 0, None)
    penalty_score = np.exp(-beta * penalty_magnitude)
    
    # Combined priority with feasibility mask
    priority = residual_score * penalty_score
    return np.where(can_fit, priority, -np.inf)
```
