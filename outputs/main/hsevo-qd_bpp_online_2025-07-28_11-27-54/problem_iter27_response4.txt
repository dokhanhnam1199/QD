```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority scores using adaptive statistical blending of residual and ratio objectives.
    
    Smooth exponential components weighted by coefficient of variation prioritize:
    - Bins with high item/capacity ratio (density-aware packing)
    - Residual minimization scaled by capacity distribution statistics
    - Contextual normalization via mean/std of bin capacities
    
    Args:
        item: Size of the item to be packed.
        bins_remain_cap: Array of remaining capacities for each bin.
    
    Returns:
        Array of priority scores for each bin.
    """
    can_fit = bins_remain_cap >= item
    
    # Statistical context of current bin capacities
    mean_cap = np.mean(bins_remain_cap)
    std_cap = np.std(bins_remain_cap)
    epsilon = 1e-6
    
    # Adaptive weight via logistic coefficient of variation scaling
    cv = std_cap / (mean_cap + epsilon)
    alpha = 1.0 / (1.0 + np.exp(-cv * 10))  # Dynamic ratio/residual weighting
    
    # Component calculations
    residual = bins_remain_cap - item
    ratio = item / (bins_remain_cap + epsilon)
    
    # Smooth exponential residual component scaled by capacity statistics
    tau_residual = mean_cap + std_cap + epsilon
    component_residual = np.exp(-residual / tau_residual)
    
    # Density-aware ratio component
    component_ratio = ratio
    
    # Multi-objective blending with adaptive weights
    composite = alpha * component_ratio + (1 - alpha) * component_residual
    
    # Enforce feasibility constraint with -inf masking
    return np.where(can_fit, composite, -np.inf)
```
