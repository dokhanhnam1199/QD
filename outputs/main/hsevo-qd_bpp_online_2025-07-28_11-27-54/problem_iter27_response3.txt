```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority scores for bins using adaptive statistical blending.
    
    Combines residual minimization with density-aware penalties using smooth exponential
    weighting, dynamically scaled by distribution statistics (mean, std, coefficient of variation).
    """
    can_fit = bins_remain_cap >= item
    fit_mask = can_fit
    scores = np.full_like(bins_remain_cap, -np.inf)
    
    if not np.any(fit_mask):
        return scores
    
    fit_remaining = bins_remain_cap[fit_mask]
    mu = np.mean(fit_remaining)
    sigma = np.std(fit_remaining) + 1e-8
    cv = sigma / mu  # Coefficient of variation
    
    residuals = fit_remaining - item
    
    # Residual minimization component: exponential decay scaled by mean remaining
    residual_scaled = residuals / mu
    residual_component = np.exp(-residual_scaled)  # Higher for smaller residuals
    
    # Density-aware component: target residual z-score of -0.5 (contextual sweet spot)
    z_residual = (residuals - mu) / sigma
    target_z = -0.5
    # Adaptive normalization by coefficient of variation
    density_component = np.exp(- (z_residual - target_z)**2 / (2 * (cv + 1e-8)))
    
    # Multiplicative blending of components for smooth tradeoff
    blended_component = residual_component * density_component
    
    # Assign scores to fit bins
    scores[fit_mask] = blended_component
    
    return scores
```
