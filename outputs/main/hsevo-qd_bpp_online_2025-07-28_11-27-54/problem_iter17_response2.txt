```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Priority function combining median-based dynamic thresholds, adaptive weights, and smooth exponential penalty for fragmentation avoidance."""
    feasible = bins_remain_cap >= item
    if not feasible.any():
        return np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)
    
    r = bins_remain_cap - item
    feasible_r = r[feasible]
    
    # Median and MAD for robust distribution-aware threshold
    median_r = np.median(feasible_r)
    mad_r = np.median(np.abs(feasible_r - median_r))
    eps = 1e-6
    tau = median_r + mad_r + eps  # Dynamic scale using robust statistics
    
    # Smooth exponential penalty to avoid fragmentation
    penalty_term = np.exp(-r / tau)
    
    # Adaptive beta balancing item size and residual capacity scale
    beta = item / (tau + eps)
    
    # Multi-objective score blending residual minimization and fragmentation control
    residual_objective = -r
    fragmentation_objective = -beta * penalty_term
    score = residual_objective + fragmentation_objective
    
    # Enforce feasibility with strict masking
    return np.where(feasible, score, -np.inf).astype(np.float64)
```
