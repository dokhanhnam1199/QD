```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    feasible = bins_remain_cap >= item
    mu = np.mean(bins_remain_cap)
    sigma = np.std(bins_remain_cap)
    threshold_low = mu - sigma
    residuals = bins_remain_cap - item
    
    # Residual minimization component with exponential scaling
    component1 = np.exp(-residuals / (mu + sigma + 1e-8))
    
    # Fragmentation penalty component (exponential penalty for residuals below threshold)
    penalty = np.where(
        residuals < threshold_low,
        np.exp((threshold_low - residuals) / (sigma + 1e-8)),
        0.0
    )
    
    # Adaptive weight balancing exploration/exploitation
    weight_penalty = sigma / (mu + sigma + 1e-8)
    
    # Composite scoring with smooth gradient properties
    combined_score = component1 - weight_penalty * penalty
    
    # Enforce strict feasibility constraints
    return np.where(feasible, combined_score, -np.inf)
```
