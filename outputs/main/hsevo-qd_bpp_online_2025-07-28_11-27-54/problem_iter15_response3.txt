```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority scores for bins using a contextual, differentiable heuristic.
    
    Scores are computed via exponential blending of residual minimization and 
    fragmentation avoidance objectives, with soft feasibility penalties. Dynamic 
    thresholds derived from bin statistics guide adaptive decision-making.
    
    Args:
        item: Size of the item to be packed.
        bins_remain_cap: Array of remaining capacities for each bin.
    
    Returns:
        Array of priority scores for each bin.
    """
    # Compute bin statistics with numerical stability
    mu = np.mean(bins_remain_cap)
    sigma = np.std(bins_remain_cap) + 1e-8  # Avoid division by zero
    
    # Dynamic target: bins with remaining capacity ~ (mean - std dev) after placement
    target = mu - sigma
    
    # Feasibility-adjusted placement metrics
    new_remain = bins_remain_cap - item
    deficit = np.maximum(item - bins_remain_cap, 0)  # Differentiable infeasibility measure
    
    # Core objective manifold (blends 2 adaptive goals in exponential space)
    term1 = ((new_remain - target) ** 2) / (2 * sigma ** 2)  # Fragmentation avoidance
    term2 = new_remain / sigma  # Residual minimization
    exponent = -term1 - term2  # Negative sum for maximization
    
    # Soft feasibility constraint (avoids gradient discontinuities)
    alpha = 10.0  # Penalty magnitude for infeasible placements
    penalty_term = alpha * deficit
    
    # Unified differentiable priority manifold
    scores = np.exp(exponent - penalty_term)
    
    return scores
```
