```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Exponential scoring with harmonic mean adaptation and fill-level blending.
    
    Combines tight-fit exponential decay with bin fill-level incentives via
    harmonic mean scaling and multiplicative term blending.
    """
    # Feasibility mask for bins that can accommodate the item
    can_fit = bins_remain_cap >= item
    remaining_after = bins_remain_cap - item
    scores = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)
    
    # Process only feasible bins
    if not np.any(can_fit):
        return scores
    
    feasible_remaining = bins_remain_cap[can_fit]
    
    # Calculate harmonic mean of feasible bins' remaining capacities for adaptive scaling
    h = len(feasible_remaining) / (np.sum(1.0 / feasible_remaining) + 1e-9)
    
    # Term 1: Exponential decay based on post-placement residual space
    term1 = np.exp(-remaining_after[can_fit] / (h + 1e-9))
    
    # Term 2: Inverse capacity to prioritize more filled bins
    term2 = 1.0 / feasible_remaining
    
    # Blend terms multiplicatively for continuous prioritization
    scores_feasible = term1 * term2
    
    # Assign computed scores to feasible bins
    scores[can_fit] = scores_feasible
    return scores
```
