```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Non-smooth step-function scoring using fixed thresholds for item and bin capacity."""
    # Constants for fixed thresholds
    LARGE_ITEM_THRESHOLD = 0.5
    TIGHT_FIT_THRESHOLD = 0.1
    BIN_UTIL_THRESHOLD = 0.7

    # Determine which bins can fit the item
    can_fit = bins_remain_cap >= item

    # Handle empty bins case
    if not bins_remain_cap.size:
        return np.array([])

    # Classify item as large or small
    is_large = item >= LARGE_ITEM_THRESHOLD

    # Initialize priority scores
    scores = np.zeros_like(bins_remain_cap, dtype=np.float32)

    if is_large:
        # Prioritize bins with tight fit (leftover <= TIGHT_FIT_THRESHOLD)
        tight_fit = (bins_remain_cap - item) <= TIGHT_FIT_THRESHOLD
        scores = np.where(can_fit & tight_fit, 1.0, 0.0)
    else:
        # Prioritize bins below utilization threshold
        below_threshold = bins_remain_cap < BIN_UTIL_THRESHOLD
        scores = np.where(can_fit & below_threshold, 1.0, 0.0)

    # Penalize invalid bins
    scores = np.where(can_fit, scores, -np.inf)

    return scores
```

Key idea: Uses fixed thresholds for item classification (large/small) and bin prioritization with non-smooth step-function scoring to balance space utilization and packing stability.
