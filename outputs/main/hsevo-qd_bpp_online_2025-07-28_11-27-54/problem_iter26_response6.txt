```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines residual minimization with adaptive statistical fragmentation control.
    Uses feasible bin mean/std for dynamic scaling and exponential penalty blending.
    """
    feasible = bins_remain_cap >= item
    if not feasible.any():
        return np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)
    
    r = bins_remain_cap - item
    feasible_r = r[feasible]
    
    # Adaptive scaling parameters (v0)
    mu = feasible_r.mean()
    std = feasible_r.std()
    eps = 1e-6
    tau = mu + std + eps
    
    # v0's components: residual minimization + fragmentation avoidance
    beta = item / tau
    penalty_term = np.exp(-r / tau)
    residual_objective = -r
    fragmentation_objective = -beta * penalty_term
    
    # v1-inspired threshold penalty using feasible stats (smoothed)
    threshold = mu - 0.5 * std  # Adaptive threshold with robustness factor
    delta = np.clip(threshold - r, 0.0, None)  # Penalize under-threshold residuals
    frag_penalty = np.exp(-delta * (beta + eps))  # Contextual exponential decay
    
    # Multi-objective blending with logistic balance
    score = residual_objective + fragmentation_objective * frag_penalty
    
    return np.where(feasible, score, -np.inf).astype(np.float64)
```
