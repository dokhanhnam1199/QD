```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Adaptive heuristic combining Best Fit and Worst Fit using dynamic median threshold.
    
    Large items (relative to median remaining capacity) use Best Fit (ratio scoring),
    small items use Worst Fit (remaining capacity scoring). Smooth scoring with 
    secondary tie-breakers via context-driven thresholds.
    
    Args:
        item: Size of the item to be packed.
        bins_remain_cap: Array of remaining capacities for each bin.
    
    Returns:
        Array of priority scores for each bin.
    """
    if bins_remain_cap.size == 0:
        return np.array([])
    
    # Dynamic threshold: median of current remaining capacities
    median_remain = np.median(bins_remain_cap)
    
    # Adaptive item classification: large vs small relative to context
    is_large = item > median_remain
    
    if is_large:
        # Best Fit with smooth ratio scoring: prioritize bins with tight fit
        can_fit = bins_remain_cap >= item
        scores = np.where(can_fit, item / (bins_remain_cap + 1e-9), -np.inf)
    else:
        # Worst Fit with linear scoring: prioritize bins with most remaining space
        can_fit = bins_remain_cap >= item
        scores = np.where(can_fit, bins_remain_cap, -np.inf)
    
    return scores
```
