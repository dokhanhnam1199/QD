```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Priority heuristic combining residual minimization and bin statistics via exponential penalties.
    
    Scores bins using a product of exponential terms: one for residual minimization (normalized by
    mean capacity) and one for contextual bin capacity proximity to median distribution (using z-scores).
    Soft penalties ensure differentiability and search stability.
    """
    # Compute bin statistics for adaptive normalization
    mu_cap = np.mean(bins_remain_cap)
    sigma_cap = np.std(bins_remain_cap)
    epsilon = 1e-9  # Avoid division by zero
    
    # Identify viable bins and calculate residuals
    can_fit = bins_remain_cap >= item
    residuals = bins_remain_cap - item
    
    # Residual term: exponential decay with normalized residual size
    residual_term = residuals / (mu_cap + epsilon)
    residual_score = np.exp(-np.where(can_fit, residual_term, np.inf))
    
    # Contextual term: exponential decay with z-score of original bin capacity
    z_score = (bins_remain_cap - mu_cap) / (sigma_cap + epsilon)
    context_score = np.exp(-np.abs(z_score))
    
    # Combine objectives multiplicatively for differentiable interaction
    combined_score = residual_score * context_score
    
    # Soft penalty for invalid bins instead of -inf mask
    return np.where(can_fit, combined_score, -1e3)
```
