```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority scores using dynamic threshold blending with exponential penalties.
    
    Blends residual minimization with fragmentation avoidance via:
    1. Feasibility masking (same as v1)
    2. Smooth exponential penalty for residuals below dynamic median threshold
    3. Continuous scoring combining both objectives
    
    Args:
        item: Size of the item to be packed.
        bins_remain_cap: Array of remaining capacities for each bin.
    
    Returns:
        Array of priority scores for each bin.
    """
    can_fit = bins_remain_cap >= item
    r = bins_remain_cap - item  # Residual capacity after placement
    
    # Dynamic threshold based on current distribution of remaining capacities
    T = np.clip(np.median(bins_remain_cap), 1e-8, None)  # Avoid division by zero
    
    # Smooth penalty term: exponential decay penalizes small residuals relative to T
    feasible_r = np.where(can_fit, r, np.inf)  # For safe statistics
    penalty = np.exp(-feasible_r / T)
    
    # Continuous blended objective: combine residual minimization with fragmentation avoidance
    blended_score = -r - penalty  # Primary term: residual minimization; Secondary: penalty shaping
    
    # Apply feasibility mask with negative infinity for invalid bins
    return np.where(can_fit, blended_score, -np.inf)
```
