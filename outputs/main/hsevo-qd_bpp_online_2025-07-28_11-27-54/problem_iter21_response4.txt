```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority scores using adaptive bin statistics and multi-objective blending.
    
    Combines fit quality with bin utilization dynamics via logistic blending.
    Prioritizes fragmentation avoidance and distribution-aware packing.
    
    Args:
        item: Size of the item to be packed.
        bins_remain_cap: Array of remaining capacities for each bin.
    
    Returns:
        Array of priority scores for each bin.
    """
    # Feasibility mask for valid bins
    can_fit = bins_remain_cap >= item
    
    # Early return for impossible placements
    if not np.any(can_fit):
        return np.full_like(bins_remain_cap, -np.inf)
    
    # Core components calculation
    fit_component = item - bins_remain_cap  # Negative residual space (tighter fit = better)
    
    # Bin statistics for adaptive thresholds
    mean_remaining = np.mean(bins_remain_cap)
    std_remaining = np.std(bins_remain_cap)
    
    # Utilization component: logistic score for underfilled bins
    threshold = mean_remaining - std_remaining  # Dynamic target baseline
    util_component = 1 / (1 + np.exp((bins_remain_cap - threshold) * 2))  # Sharpened logistic
    
    # Adaptive blending ratio: sigmoid centered at mean_remaining
    blend_ratio = 1 / (1 + np.exp((item - mean_remaining) * 3))  # Item-size-sensitive slope
    
    # Multi-objective score combination with gradient smoothing
    combined_score = (
        (1 - blend_ratio) * fit_component / (std_remaining + 1e-6) +  # Normalize by distribution width
        blend_ratio * (util_component - 0.5) * 2  # Symmetric scaling for balanced gradients
    )
    
    # Final feasibility masking
    return np.where(can_fit, combined_score, -np.inf)
```
