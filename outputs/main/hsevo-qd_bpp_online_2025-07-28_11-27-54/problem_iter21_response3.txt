```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority scores for bins using adaptive multi-objective heuristic.
    
    Combines fit quality, fragmentation penalties, and distribution harmony with
    context-aware dynamic thresholds. Uses smooth logistic decay for stable gradients.
    
    Args:
        item: Size of the item to be packed.
        bins_remain_cap: Array of remaining capacities for each bin.
    
    Returns:
        Array of priority scores for each bin.
    """
    # Feasibility mask for valid bins
    can_fit = bins_remain_cap >= item
    
    # Return -inf for all if no feasible bins
    if not np.any(can_fit):
        return np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)
    
    # Current bin statistics with edge case protection
    current_mean = bins_remain_cap.mean()
    current_std = bins_remain_cap.std() + 1e-8  # Avoid division by zero
    
    # Calculate post-placement remaining capacities
    new_remaining = bins_remain_cap - item
    
    # Component 1: Fit quality (Best Fit baseline)
    fit_score = -new_remaining  # Higher for tighter fits
    
    # Component 2: Fragmentation penalty using logistic decay
    threshold = current_mean - current_std  # Dynamic lower bound
    penalty_zone = new_remaining - threshold  # Positive = above threshold
    fragmentation_penalty = 1 / (1 + np.exp(penalty_zone / current_std))
    
    # Component 3: Distribution harmony (optimal placement zone)
    z_score = (new_remaining - current_mean) / current_std
    optimal_zone = -np.abs(z_score + 1)  # Target: mean - std (z = -1)
    
    # Adaptive weight blending based on item's relative size
    item_z = (item - current_mean) / current_std
    fit_weight = 1 / (1 + np.exp(-item_z))  # >0.5 for larger-than-average items
    
    # Multi-objective score blending
    score = (
        0.6 * fit_weight * fit_score +        # Fit emphasis
        0.3 * (1 - fit_weight) * optimal_zone - # Distribution harmony
        0.8 * fragmentation_penalty          # Fragmentation penalty
    )
    
    # Enforce feasibility constraints
    return np.where(can_fit, score, -np.inf)
```
