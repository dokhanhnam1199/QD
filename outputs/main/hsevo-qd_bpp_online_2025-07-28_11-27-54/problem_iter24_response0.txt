```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority scores for bins using a dynamic multi-objective heuristic.
    
    Combines residual minimization with fragmentation avoidance via smooth,
    distribution-adapted scoring. Uses median/MAD thresholds and exponential/logistic
    functions to balance packing efficiency with future space usability.
    
    Args:
        item: Size of the item to be packed.
        bins_remain_cap: Array of remaining capacities for each bin.
    
    Returns:
        Array of priority scores for each bin.
    """
    can_fit = bins_remain_cap >= item
    if not np.any(can_fit):
        return np.full_like(bins_remain_cap, -np.inf)
    
    # Dynamic statistical adaptation
    M = np.median(bins_remain_cap)
    S = np.median(np.abs(bins_remain_cap - M))  # MAD for robustness
    
    residual = bins_remain_cap - item  # Always >=0 for feasible bins
    
    # Multi-objective smooth scoring
    threshold = M - S
    frag_exp_arg = (residual - threshold) / (S + 1e-6)
    frag_pen = 1.0 / (1.0 + np.exp(-frag_exp_arg))  # Smooth transition at threshold
    
    res_term = np.exp(-residual / (M + 1e-6))  # Residual minimization with exp scaling
    
    # Blend objectives with multiplication for strict trade-off
    score = res_term * frag_pen
    
    return np.where(can_fit, score, -np.inf)
```
