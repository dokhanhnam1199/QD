```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Adaptive fit-frag-density scoring: Combines item-relative exponential fit rewards with statistical fragmentation penalties (exp(-delta*penalty) for residuals below mu-sigma), blended via CV-weighted z-score density rewards for smooth multi-objective prioritization."""
    EPS = 1e-8
    feasible = bins_remain_cap >= item
    if not np.any(feasible):
        return np.full_like(bins_remain_cap, -np.inf)
    
    r = bins_remain_cap - item
    
    # Fit score: exponential decay for small r/item ratios
    fit_component = np.exp(- r / (item + EPS))
    
    # Fragmentation penalty: residual below mu_bins - sigma_bins
    mu_bins = np.mean(bins_remain_cap)
    sigma_bins = np.std(bins_remain_cap)
    threshold = mu_bins - sigma_bins
    delta = np.clip(threshold - r, a_min=0, a_max=None)
    penalty_factor = 1.0 / (mu_bins + EPS)
    frag_penalty = np.exp(- delta * penalty_factor )
    
    # Combined fit and fragmentation scoring
    fit_frag = fit_component * frag_penalty
    
    # Density score: z-score proximity to residual mean
    z = (r - mu_bins) / (sigma_bins + EPS)
    density_score = np.exp(-0.5 * z**2)
    
    # Adaptive weight via logistic-weighted coefficient of variation
    cv = sigma_bins / (mu_bins + EPS)
    blend_weight = 1 / (1 + np.exp(-cv))  # High CV = more fit_frag focus
    
    # Convex combination with feasibility masking
    scores = blend_weight * fit_frag + (1 - blend_weight) * density_score
    return np.where(feasible, scores, -np.inf)
```
