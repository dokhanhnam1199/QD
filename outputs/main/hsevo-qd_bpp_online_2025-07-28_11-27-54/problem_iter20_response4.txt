```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Adaptive bin selection with smooth exponential scoring for online BPP.
    
    Uses item size relative to current bin mean for Best/Worst Fit classification,
    exponential penalties scaled by standard deviation to balance fit quality and
    fragmentation control.
    """
    if len(bins_remain_cap) == 0:
        return np.array([])
    
    can_fit = bins_remain_cap >= item
    if not np.any(can_fit):
        return np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)
    
    feasible_remain = bins_remain_cap[can_fit]
    mean_remain = feasible_remain.mean()
    std_remain = feasible_remain.std()
    
    scores = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)
    
    if item > mean_remain:
        # Large item: Best Fit with exponential decay penalty on leftover space
        leftover = bins_remain_cap - item
        valid_leftover = leftover[can_fit]
        scale = std_remain if std_remain > 0 else 1.0
        best_scores = np.exp(-valid_leftover / (scale + 1e-6))
        scores[can_fit] = best_scores
    else:
        # Small item: Worst Fit with exponential growth on z-score of remaining capacity
        valid_remain = bins_remain_cap[can_fit]
        z_scores = (valid_remain - mean_remain) / (std_remain + 1e-6)
        worst_scores = np.exp(z_scores)
        scores[can_fit] = worst_scores
    
    return scores
```
