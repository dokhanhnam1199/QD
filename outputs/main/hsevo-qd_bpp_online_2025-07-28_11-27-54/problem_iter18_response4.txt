```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority scores for bins using a distribution-aware heuristic.
    
    Combines residual minimization with fragmentation penalties via smooth exponential
    components and adaptive weights derived from real-time residual statistics.
    
    Args:
        item: Size of the item to be packed.
        bins_remain_cap: Array of remaining capacities for each bin.
    
    Returns:
        Array of priority scores for each bin.
    """
    can_fit = bins_remain_cap >= item
    feasible_mask = np.where(can_fit)[0]
    
    if not feasible_mask.size:
        return np.full_like(bins_remain_cap, -np.inf)
    
    # Extract feasible residuals and compute distribution stats
    feasible_residuals = bins_remain_cap[can_fit] - item
    mu = feasible_residuals.mean()
    sigma = feasible_residuals.std()
    epsilon = 1e-6  # For numerical stability
    
    # Adaptive weight scaling using coefficient of variation
    cv = sigma / (mu + epsilon)
    alpha = 1.0 / (cv + epsilon)  # Weight for residual minimization
    beta = cv                       # Weight for fragmentation penalty
    
    # Smooth exponential residual minimization component
    residual_component = np.exp(-feasible_residuals / (mu + epsilon))
    
    # Dynamic threshold (μ-σ) and exponential fragmentation penalty component
    threshold = mu - sigma
    frag_component = np.exp((feasible_residuals - threshold) / (sigma + epsilon))
    
    # Combine components with adaptive weights
    combined_score = alpha * residual_component + beta * frag_component
    
    # Apply feasibility mask and return full priority array
    priority = np.full_like(bins_remain_cap, -np.inf)
    priority[can_fit] = combined_score
    
    return priority
```
