```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    can_fit = bins_remain_cap >= item
    residual_after = bins_remain_cap - item
    
    if not np.any(can_fit):
        return np.full_like(bins_remain_cap, -np.inf)
    
    # Feasible residual_after values and statistics
    feasible_ra = residual_after[can_fit]
    mu = feasible_ra.mean()
    sigma = feasible_ra.std()
    epsilon = 1e-8
    
    # Primary exponential score: exp(-normalized residual_after)
    primary_score = np.exp(-residual_after / (mu + epsilon))
    
    # Dynamic threshold for secondary penalty (mean - 0.5Ïƒ)
    threshold = mu - 0.5 * sigma
    # Smooth penalty for bins below threshold (fragmentation risk)
    secondary_penalty = np.where(
        can_fit & (residual_after < threshold),
        np.exp((threshold - residual_after) / (mu + epsilon)),
        1.0
    )
    
    # Combined score with feasibility mask
    combined_score = primary_score / secondary_penalty
    return np.where(can_fit, combined_score, -np.inf)
```
