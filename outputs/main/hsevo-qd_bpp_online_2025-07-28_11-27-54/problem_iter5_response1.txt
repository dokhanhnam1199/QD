```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Prioritize bins using fixed thresholds and non-smooth Best/Worst Fit for large/small items.
    
    Fixed 0.5 threshold classifies items. Best Fit (step) for large, Worst Fit (step) for small.
    """
    if len(bins_remain_cap) == 0:
        return np.array([])
    
    can_fit = bins_remain_cap >= item
    is_large = item > 0.5  # Fixed threshold for item classification
    
    # Initialize priority scores
    priority = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)
    
    if not np.any(can_fit):
        return priority
    
    if is_large:
        # Best Fit: prioritize bins with minimal leftover space (step function)
        leftover = np.where(can_fit, bins_remain_cap - item, np.inf)
        min_leftover = leftover.min()
        best_fit = (leftover == min_leftover) & can_fit
        priority[best_fit] = 1.0
    else:
        # Worst Fit: prioritize bins with maximum remaining capacity (step function)
        remaining = np.where(can_fit, bins_remain_cap, -np.inf)
        max_remaining = remaining.max()
        best_worst = (remaining == max_remaining) & can_fit
        priority[best_worst] = 1.0
    
    return priority
```
