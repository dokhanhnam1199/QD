```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority scores using dynamically blended scoring with smooth continuity.
    
    Combines residual minimization with anti-fragmentation penalties via continuous 
    rational/exponential components. Prioritizes bins where residual after placement (r)
    balances tight fit constraints and future usability through contextual scaling.
    
    Args:
        item: Size of the item to be packed.
        bins_remain_cap: Array of remaining capacities for each bin.
    
    Returns:
        Array of priority scores for each bin (higher = better bin choice).
    """
    can_fit = bins_remain_cap >= item
    r = bins_remain_cap - item  # Residual capacity after placement
    
    # Avoid division by zero in smooth scoring terms
    epsilon = 1e-8
    
    # Blended scoring strategy:
    # 1. Primary term: Rational function that favors bins where r ≈ item size 
    #    (minimizes r + item^2/r via derivative analysis)
    # 2. Secondary term: Smooth exponential damping of residual volatility
    # Score = -(item^2 / (r + ε) + r) + σ * exp(-(r / τ))
    # where σ, τ are derived from item size to ensure continuity
    rational_component = (item**2) / (r + epsilon)
    volatility_damping = np.exp(-r / (item + epsilon))  # τ=item ensures contextual scaling
    score = -(rational_component + r) + volatility_damping  # Blended continuum
    
    # Mask invalid bins with -inf
    return np.where(can_fit, score, -np.inf)
```
