```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority scores using adaptive item size classification and smooth scoring."""
    can_fit = bins_remain_cap >= item
    if len(bins_remain_cap) == 0:
        return np.array([])
    
    # Dynamic item size classification based on harmonic mean of remaining capacities
    eps = 1e-9
    harmonic_mean = len(bins_remain_cap) / (np.sum(1.0 / (bins_remain_cap + eps)))
    is_large = item > (harmonic_mean * 0.8)  # Adaptive threshold with margin
    
    # Smooth scoring with secondary tie-breaker
    with np.errstate(divide='ignore', invalid='ignore'):
        fit_ratio = item / (bins_remain_cap + eps)  # Primary term: fill ratio
        underfill_penalty = bins_remain_cap - item  # Secondary term: leftover space
        underfill_penalty = np.clip(underfill_penalty, 0, None)
        
        # Smooth exponential weighting of terms
        fit_component = np.exp(fit_ratio * 2) * can_fit
        penalty_component = np.exp(-underfill_penalty * 0.5) * can_fit
        
        # Adaptive strategy blending
        if is_large:
            score = fit_component * penalty_component
        else:
            # Prefer underutilized bins with smooth capacity scaling
            capacity_scaling = bins_remain_cap / (bins_remain_cap.mean() + eps)
            score = (1.0 + capacity_scaling) * penalty_component
    
    return np.where(can_fit, score, -np.inf)
```
