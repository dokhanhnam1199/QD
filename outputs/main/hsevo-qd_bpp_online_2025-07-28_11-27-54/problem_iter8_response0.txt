```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority combining fit ratio, underfill penalty, and adaptive capacity scaling with harmonized weights."""
    if len(bins_remain_cap) == 0:
        return np.array([])
    
    eps = 1e-9
    can_fit = bins_remain_cap >= item
    
    # Dynamic item classification using harmonic mean of residual capacities
    harmonic_mean = len(bins_remain_cap) / (np.sum(1.0 / (bins_remain_cap + eps)))
    is_large = item > (harmonic_mean * 0.85)
    
    # Primary metrics for scoring
    fit_ratio = item / (bins_remain_cap + eps)
    underfill_penalty = np.clip(bins_remain_cap - item, 0, None)
    
    # Exponentially weighted components
    fit_component = np.exp(fit_ratio * 2.0) * can_fit
    penalty_component = np.exp(-underfill_penalty * 1.0) * can_fit  # Stronger penalty for leftover space
    
    # Inverse capacity scaling for small item placement
    capacity_scaling = bins_remain_cap.mean() / (bins_remain_cap + eps)
    
    # Strategic blending based on item size
    if is_large:
        # Large items: precision packing - maximize fit compactness with smooth penalty
        score = fit_component * penalty_component
    else:
        # Small items: blended strategy - optimize usage of nearly-full bins with strict space efficiency
        score = capacity_scaling * (penalty_component ** 0.5)
    
    return np.where(can_fit, score, -np.inf)
```
