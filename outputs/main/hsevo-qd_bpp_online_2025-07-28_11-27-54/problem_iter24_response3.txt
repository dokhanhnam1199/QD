```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    can_fit = bins_remain_cap >= item
    if not np.any(can_fit):
        return np.full_like(bins_remain_cap, -np.inf)
    
    # Extract feasible residuals and statistical context
    feasible_resids = bins_remain_cap[can_fit] - item
    median_resid = np.median(feasible_resids)
    sigma_resid = np.std(feasible_resids)
    epsilon = 1e-8  # Numerical stability
    
    # Residual minimization component: exponential decay scaled by context
    resid_scale = np.abs(median_resid) + sigma_resid + epsilon
    resid_scores = np.exp(-feasible_resids / resid_scale)  # Higher for smaller residuals
    
    # Fragmentation penalty: logistic response centered on item size
    frag_threshold = item
    frag_scores = 1 / (1 + np.exp(-(feasible_resids - frag_threshold) / (resid_scale + epsilon)))
    
    # Dynamic weight blending via coefficient of variation
    cv = sigma_resid / (median_resid + epsilon) if median_resid > 0 else 1.0
    weight_resid = 1.0 / (1.0 + np.sqrt(cv))  # Adaptive balance
    weight_frag = 1.0 - weight_resid
    
    # Smooth multi-objective combination
    blended_scores = weight_resid * resid_scores + weight_frag * frag_scores
    
    # Apply feasibility mask and return
    scores = np.full_like(bins_remain_cap, -np.inf)
    scores[can_fit] = blended_scores
    return scores
```
