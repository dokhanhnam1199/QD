```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    # Feasibility mask: only bins that can fit the item have valid scores
    can_fit = bins_remain_cap >= item
    feasible_remaining = bins_remain_cap[can_fit]
    
    if feasible_remaining.size == 0:
        return np.full_like(bins_remain_cap, -np.inf)
    
    # Contextual statistics for adaptive scaling
    mean_cap = np.mean(bins_remain_cap)
    std_cap = np.std(bins_remain_cap)
    safe_std = std_cap if std_cap > 1e-8 else 1e-8
    
    # Adaptive exponential parameters using item-bin size ratios
    # Calculate z-score of item relative to bin capacities
    item_zscore = (item - mean_cap) / safe_std
    
    # Smooth blending factor using hyperbolic tangent for continuity
    # +1 item larger than avg: prefer residual minimization
    # -1 item smaller: prefer utilization maximization
    blend_factor = (np.tanh(item_zscore) + 1) / 2  # Scale to [0,1]
    
    # Precompute feasible bin metrics
    feasible_indices = np.where(can_fit)
    r = bins_remain_cap[feasible_indices]
    residuals = r - item  # Non-negative due to feasibility
    
    # Continuity-driven exponential scoring components
    # Residual minimization term: exp(- residual scaled by item size)
    # Utilization maximization term: exp(- remaining capacity scaled by distribution)
    rescale_resid = (residuals + 1e-8) / (item + 1e-8)  # Scale residual by item size
    rescale_r = (r + 1e-8) / (mean_cap + 1e-8)  # Scale remaining by average
    
    # Smooth exponential objectives with adaptive curvature
    resid_term = np.exp(-np.sqrt(rescale_resid))  # Concave transform for robustness
    util_term = np.exp(-np.square(rescale_r))     # Convex transform for sharpness
    
    # Blend multi-objective components using contextual factor
    blended_scores = blend_factor * resid_term + (1 - blend_factor) * util_term
    
    # Construct output scores with feasibility masking
    scores = np.full_like(bins_remain_cap, -np.inf)
    scores[feasible_indices] = blended_scores.astype(np.float64)
    
    return scores
```
