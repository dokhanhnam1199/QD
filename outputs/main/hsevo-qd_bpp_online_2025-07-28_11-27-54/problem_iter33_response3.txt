```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    can_fit = bins_remain_cap >= item
    feasible_mask = can_fit
    
    # Return -inf for all bins if no feasible bins exist
    if not np.any(feasible_mask):
        return np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)
    
    # Calculate coefficient of variation (CV) of remaining capacities
    mean_cap = np.mean(bins_remain_cap)
    std_cap = np.std(bins_remain_cap)
    cv = std_cap / (mean_cap + 1e-9)
    
    # Adaptive weight alpha using logistic function on CV
    alpha = 1 / (1 + np.exp(-10 * (cv - 0.5)))  # Steep logistic transition at CV=0.5
    
    # Residual-based component (Best Fit objective)
    residual_component = item - bins_remain_cap  # Higher = better fit
    
    # Density-based component (favor bins with higher current utilization)
    density_component = -bins_remain_cap  # Higher = more filled bin
    
    # Normalize components using z-scores over feasible bins
    feasible_residual = residual_component[feasible_mask]
    mean_r, std_r = np.mean(feasible_residual), np.std(feasible_residual)
    normalized_r = (residual_component - mean_r) / (std_r + 1e-9)
    
    feasible_density = density_component[feasible_mask]
    mean_d, std_d = np.mean(feasible_density), np.std(feasible_density)
    normalized_d = (density_component - mean_d) / (std_d + 1e-9)
    
    # Blend objectives with adaptive weights
    combined_score = alpha * normalized_r + (1 - alpha) * normalized_d
    
    # Apply feasibility mask
    scores = np.where(feasible_mask, combined_score, -np.inf)
    
    return scores.astype(np.float64)
```
