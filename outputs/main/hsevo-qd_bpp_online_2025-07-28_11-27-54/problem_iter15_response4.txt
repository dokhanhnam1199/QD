```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority scores using adaptive bin statistics and exponential objective blending.
    
    Scores combine residual minimization and fragmentation avoidance via dynamic targets,
    with soft feasibility penalties and differentiable scoring.
    
    Args:
        item: Size of the item to be packed.
        bins_remain_cap: Array of remaining capacities for each bin.
    
    Returns:
        Array of priority scores for each bin.
    """
    if len(bins_remain_cap) == 0:
        return np.array([])
    
    # Dynamic context-aware parameters
    mu = np.mean(bins_remain_cap)
    sigma = np.std(bins_remain_cap) + 1e-6  # Avoid division by zero
    
    # Target residual: mean - 1Ïƒ consolidation threshold
    target_residual = mu - sigma
    
    # Feasibility-aware residual calculation
    residual = bins_remain_cap - item
    
    # Soft feasibility penalty (exponential decay for infeasible)
    beta = 10.0  # Controls penalty sharpness
    feasibility = np.exp(-beta * np.maximum(0.0, -residual))
    
    # Core objectives: 
    # 1. Residual proximity to dynamic target (Gaussian kernel)
    # 2. Direct residual minimization
    term1 = -((residual - target_residual) ** 2) / (2 * sigma**2)
    term2 = -residual / sigma
    
    # Unified exponential scoring with objective blending
    objective = np.exp(term1 + term2)
    
    # Final priority scores with feasibility interaction
    return feasibility * objective
```
