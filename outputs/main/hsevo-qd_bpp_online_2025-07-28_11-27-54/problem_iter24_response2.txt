```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    can_fit = bins_remain_cap >= item
    if not np.any(can_fit):
        return np.full_like(bins_remain_cap, -np.inf)
    
    # Dynamic statistical context parameters
    median_remain = np.median(bins_remain_cap)
    std_remain = np.std(bins_remain_cap)
    epsilon = 1e-6
    
    # Residual calculation
    residuals = bins_remain_cap - item
    
    # Fragmentation threshold (adaptive lower bound for healthy residual)
    threshold = np.clip(median_remain - std_remain, 0, None)
    
    # Numerically stable score computation
    with np.errstate(over='clip', under='clip'):
        # Component 1: Residual minimization (Best Fit analog) with exponential scaling
        fit_scale = (median_remain + item) + epsilon
        fit_component = np.exp(-residuals / fit_scale)
        
        # Component 2: Fragmentation penalty using logistic response to threshold distance
        penalty_distance = np.clip(threshold - residuals, 0, None)  # Only penalize below threshold
        frag_component = 1 / (1 + np.exp(penalty_distance / fit_scale))
        
        # Context-aware convex blending of objectives
        blend_numerator = np.exp((item - median_remain) / fit_scale)
        blend_weight = blend_numerator / (blend_numerator + 1)  # Dynamic item-relative weighting
        
        # Final score with feasibility masking
        scores = blend_weight * fit_component + (1 - blend_weight) * frag_component
        return np.where(can_fit, scores, -np.inf)
```
