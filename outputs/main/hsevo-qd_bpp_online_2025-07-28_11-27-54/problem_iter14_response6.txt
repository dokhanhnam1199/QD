```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Dynamic sigmoid-weighted exponential blending of Worst/Best Fit using bin statistics.
    
    Combines exp(remaining) and exp(-leftover) via item-to-mean(remaining_cap) sigmoid weight.
    Smoothly adapts to item size relative to current bin distribution for optimal fragmentation control.
    """
    if not bins_remain_cap.size:
        return np.array([], dtype=np.float64)
    
    # Dynamic context-aware threshold using bin statistics
    mu, sigma = np.mean(bins_remain_cap), np.std(bins_remain_cap)
    tau = mu + sigma * 0.5  # Bias threshold toward higher capacity bins
    
    # Smooth transition weight using sigmoid function
    weight = 1.0 / (1.0 + np.exp(10.0 * (item - tau)))  # k=10 controls transition sharpness
    
    valid_mask = bins_remain_cap >= item
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)
    
    if not np.any(valid_mask):
        return priorities
    
    # Core objective terms with exponential continuity
    remaining = bins_remain_cap[valid_mask]
    leftover = remaining - item
    worst_fit = np.exp(remaining)
    best_fit = np.exp(-leftover)
    
    # Unified priority score with soft feasibility blending
    priorities[valid_mask] = weight * worst_fit + (1 - weight) * best_fit
    
    return priorities
```
