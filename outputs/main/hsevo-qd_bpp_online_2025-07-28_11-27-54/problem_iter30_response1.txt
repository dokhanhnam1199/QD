```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority scores for bins using dynamic statistical adaptation and smooth exponential blending.
    
    Combines residual minimization with secondary density penalties via z-score Gaussian weighting.
    Prioritizes bins that balance tight packing efficiency and alignment with current distribution's mode.
    
    Args:
        item: Size of the item to be packed.
        bins_remain_cap: Array of remaining capacities for each bin.
    
    Returns:
        Array of priority scores for each bin (higher = better), with -inf for invalid bins.
    """
    # Feasibility mask for bins that can fit the item
    can_fit = bins_remain_cap >= item
    if not np.any(can_fit):
        return np.full_like(bins_remain_cap, -np.inf)
    
    # Statistical context parameters
    mu = np.mean(bins_remain_cap)
    sigma = np.std(bins_remain_cap)
    eps = 1e-8  # Numerical stability epsilon
    
    # Primary residual minimization term
    residual = bins_remain_cap - item
    scaled_residual = residual / (item + mu + sigma + eps)  # Contextual scaling
    residual_score = np.exp(-scaled_residual)  # Smooth exponential penalty
    
    # Secondary density alignment term
    z_score = (bins_remain_cap - mu) / (sigma + eps)
    density_score = np.exp(-0.5 * z_score**2)  # Gaussian weighting around mean
    
    # Combined score with smooth interaction
    combined_score = residual_score * density_score
    
    # Mask invalid bins and return
    return np.where(can_fit, combined_score, -np.inf)
```
