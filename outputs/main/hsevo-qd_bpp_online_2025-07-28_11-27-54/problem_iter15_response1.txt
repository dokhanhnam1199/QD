```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority scores for bins using a dynamic, differentiable heuristic.
    
    Scores blend residual minimization and fragmentation avoidance via exponential
    terms, with contextual thresholds derived from real-time bin statistics. Soft
    feasibility penalties ensure numerical stability.
    
    Args:
        item: Size of the item to be packed.
        bins_remain_cap: Array of remaining capacities for each bin.
    
    Returns:
        Array of priority scores for each bin.
    """
    residual = bins_remain_cap - item
    
    # Dynamic threshold parameters from bin statistics
    mu = np.mean(bins_remain_cap)
    sigma = np.std(bins_remain_cap)
    epsilon = 1e-8  # For numerical stability
    
    # Core objective blending: residual minimization + fragmentation avoidance
    target_r = np.clip(mu - sigma, 0, None)  # Contextual sweet spot for residual
    spread_scale = 2 * (sigma + epsilon)**2
    core_term = np.exp(-((residual - target_r)**2) / spread_scale)
    
    # Feasibility-aware scoring: smooth penalty for deficit bins
    deficit = np.maximum(0.0, item - bins_remain_cap)
    feasibility_term = np.exp(-deficit**2)
    
    # Unified scoring function
    return core_term * feasibility_term
```
