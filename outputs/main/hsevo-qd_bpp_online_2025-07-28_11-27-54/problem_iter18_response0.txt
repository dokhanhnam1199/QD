```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority scores for bins using a distribution-aware heuristic with smooth exponential scoring.
    
    Scores are computed by blending residual minimization and fragmentation penalties via adaptive weights,
    dynamically adjusted to the current bin capacity distribution. Uses feasibility masks to exclude invalid bins.
    
    Args:
        item: Size of the item to be packed.
        bins_remain_cap: Array of remaining capacities for each bin.
    
    Returns:
        Array of priority scores for each bin.
    """
    can_fit = bins_remain_cap >= item
    if not np.any(can_fit):
        return np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)
    
    mu = np.mean(bins_remain_cap)
    sigma = np.std(bins_remain_cap)
    epsilon = 1e-9
    
    # Dynamic threshold for fragmentation awareness
    threshold = mu - sigma
    
    # Residual computation for feasible bins
    r = bins_remain_cap - item
    
    # Smooth exponential residual score (smaller r â†’ higher score)
    residual_score = np.exp(-r / (mu + sigma + epsilon))
    
    # Smooth threshold-crossing score using logistic transition
    threshold_diff = r - threshold
    fragment_score = 1.0 / (1.0 + np.exp(threshold_diff / (sigma + epsilon)))
    
    # Adaptive weights based on coefficient of variation
    cv = sigma / (mu + epsilon)
    weight_residual = 1.0 - np.tanh(cv)  # Dominates when distribution is tight
    weight_fragment = np.tanh(cv)        # Dominates when distribution is spread out
    
    # Combine components with adaptive weights
    combined_score = weight_residual * residual_score + weight_fragment * fragment_score
    
    # Apply feasibility mask
    return np.where(can_fit, combined_score, -np.inf)
```
