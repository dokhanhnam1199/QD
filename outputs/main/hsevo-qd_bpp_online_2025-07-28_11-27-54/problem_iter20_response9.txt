```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Priority scores using adaptive thresholds and feasibility masking.
    
    Scores prioritize bins that minimize residual capacity while avoiding 
    fragmentation through dynamic thresholds (mu - sigma) and smooth exponential 
    penalties. Infeasible bins are masked with -inf to enforce hard constraints.
    """
    residual = bins_remain_cap - item
    feasible = residual >= 0
    
    # Mask infeasible bins with -inf immediately
    scores = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)
    
    if not np.any(feasible):
        return scores  # All bins invalid, return all -inf
    
    mu = np.mean(bins_remain_cap)
    sigma = np.std(bins_remain_cap)
    epsilon = 1e-8
    penalty_factor = 1.0 / (mu + epsilon)
    
    threshold = mu - sigma
    delta = np.clip(threshold - residual[feasible], a_min=0.0, a_max=None)
    
    # Compute terms only for feasible bins
    term1 = np.exp(-residual[feasible] * penalty_factor)
    term2 = np.exp(-delta * penalty_factor)
    scores[feasible] = term1 * term2  # Assign computed scores
    
    return scores
```
