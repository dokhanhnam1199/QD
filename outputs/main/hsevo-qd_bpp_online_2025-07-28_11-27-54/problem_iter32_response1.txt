```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Adaptive logistic blending with item-relative residual prioritization.
    
    Combines residual minimization (exponential penalty) and z-score density rewards,
    with convex combination weighted by item size relative to median capacity.
    Adaptive density scaling uses logistic-transformed coefficient of variation.
    """
    can_fit = bins_remain_cap >= item
    r = bins_remain_cap - item
    feasible_r = np.where(can_fit, r, np.inf)
    
    T = np.clip(np.median(bins_remain_cap), 1e-8, None)
    
    # Primary objective: residual minimization with exponential fragmentation penalty
    penalty_primary = np.exp(-feasible_r / T)
    blended_primary = -r - penalty_primary
    
    # Bin statistics for adaptive scaling
    feasible_mask = can_fit & (feasible_r != np.inf)
    if np.any(feasible_mask):
        mu_r = np.mean(feasible_r[feasible_mask])
        sigma_r = np.std(feasible_r[feasible_mask]) + 1e-8
        z_scores = (r - mu_r) / sigma_r
        secondary_reward = np.exp(-np.abs(z_scores))
    else:
        secondary_reward = np.zeros_like(r)
    
    # Adaptive density weight: logistic-transformed coefficient of variation
    bin_std = np.std(bins_remain_cap)
    bin_cv = bin_std / T
    logistic_cv = 1.0 / (1.0 + np.exp(-bin_cv))  # Smooth saturation at high variance
    adaptive_weight = 1.0 + logistic_cv           # Range: [1.5, 2.0]
    
    # Item-relative modulation: large items prioritize residual minimization
    item_rel = item / T
    blend_factor = 1.0 / (1.0 + np.exp(-item_rel))  # Logistic transition at item=T
    
    # Convex combination of objectives with adaptive scaling
    blended_total = (
        blended_primary * blend_factor +
        secondary_reward * adaptive_weight * (1.0 - blend_factor)
    )
    
    return np.where(can_fit, blended_total, -np.inf)
```
