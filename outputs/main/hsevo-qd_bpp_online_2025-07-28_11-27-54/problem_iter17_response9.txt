```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Dynamic median-based scoring with fragmentation penalty. Combines Worst/Best Fit 
    classification using median of current bins, then penalizes residual < μ-σ to reduce fragmentation.
    """
    valid_mask = bins_remain_cap >= item
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)
    
    if not np.any(valid_mask):
        return priorities
    
    # Compute distribution-aware statistics
    mu = np.mean(bins_remain_cap)
    sigma = np.std(bins_remain_cap)
    median = np.median(bins_remain_cap)
    epsilon = 1e-8
    penalty_factor = 1.0 / (mu + epsilon)
    threshold_penalty = mu - sigma  # Fragmentation threshold
    
    # Item size classification relative to median
    is_small = item <= median
    
    # Fragmentation penalty calculation
    residual = bins_remain_cap - item
    delta = np.clip(threshold_penalty - residual, 0.0, None)
    penalty = np.exp(-delta * penalty_factor)
    
    if is_small:
        # Small items: Worst Fit with penalty for small residuals
        base_score = np.exp(bins_remain_cap)
    else:
        # Large items: Best Fit with penalty for small residuals
        base_score = np.exp(-residual)
    
    # Combine base score with penalty
    feasible_scores = base_score * penalty
    priorities[valid_mask] = feasible_scores[valid_mask]
    
    return priorities
```
