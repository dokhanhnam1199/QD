```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Adaptive priority combining smooth exponential scoring with item-relative thresholds.
    
    Uses harmonic mean for item size classification. Large items use fit ratio and normalized
    leftover penalties; small items use bell-shaped moderate leftover preference with capacity scaling.
    """
    if len(bins_remain_cap) == 0:
        return np.array([])
    
    eps = 1e-9
    can_fit = bins_remain_cap >= item
    
    # Adaptive item classification using harmonic mean
    harmonic_mean = len(bins_remain_cap) / (np.sum(1.0 / (bins_remain_cap + eps)))
    is_large = item > (harmonic_mean * 0.8)
    
    fit_ratio = item / (bins_remain_cap + eps)
    leftover = bins_remain_cap - item
    normalized_leftover = leftover / (item + eps)
    
    # Component-based scoring
    if is_large:
        # Prioritize tight fits with exponential sensitivity to fit ratio and normalized leftover
        fit_component = np.exp(fit_ratio * 2)
        penalty_component = np.exp(-normalized_leftover * 2)
        score = fit_component * penalty_component
    else:
        # Small items: bell curve around moderate leftover + capacity scaling
        moderate_center = 0.4 * item
        spread = 0.2 * item
        bell_component = np.exp(-((leftover - moderate_center) / (spread + eps))**2)
        capacity_scaling = bins_remain_cap / (np.mean(bins_remain_cap) + eps)
        score = bell_component * (1.0 + capacity_scaling)
    
    return np.where(can_fit, score, -np.inf)
```
