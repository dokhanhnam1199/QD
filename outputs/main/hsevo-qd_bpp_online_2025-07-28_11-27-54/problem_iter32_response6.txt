```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Adaptive multi-objective priority using exponential scoring, z-score density rewards, and dynamic thresholding.
    
    Combines residual minimization, fragmentation avoidance, and bin density efficiency via smooth exponential terms.
    Uses strict feasibility masking and adaptive statistics for contextual bin selection.
    """
    if len(bins_remain_cap) == 0:
        return np.array([])
    
    epsilon = 1e-8
    mu = np.mean(bins_remain_cap)
    sigma = np.std(bins_remain_cap)
    penalty_factor = 1.0 / (mu + epsilon)
    
    # Adaptive threshold for fragmentation avoidance
    threshold = mu - sigma
    
    # Feasibility mask and residual calculation
    residual = bins_remain_cap - item
    feasible = residual >= 0
    
    # Residual minimization term (Best Fit analog)
    term1 = np.exp(-residual * penalty_factor)
    
    # Fragmentation penalty term (avoid residual below threshold)
    delta = np.clip(threshold - residual, 0.0, None)
    term2 = np.exp(-delta * penalty_factor)
    
    # Density efficiency term (z-score normalization of remaining capacity)
    z_remaining = (bins_remain_cap - mu) / (sigma + epsilon)
    term3 = np.exp(-z_remaining)  # Rewards bins with below-average remaining capacity (more filled)
    
    # Combine all terms for feasible bins
    feasible_scores = term1 * term2 * term3
    
    # Mask infeasible bins with -inf
    priority = np.where(feasible, feasible_scores, -np.inf)
    
    return priority
```
