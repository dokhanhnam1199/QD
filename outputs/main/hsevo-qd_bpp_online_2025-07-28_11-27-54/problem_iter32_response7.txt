```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Adaptive blend of ratio/residual with fragmentation-penalized exponential scoring.
    
    Combines v0's dynamic alpha blending with v1's threshold-based penalty in residual component.
    """
    can_fit = bins_remain_cap >= item
    mean_cap = np.mean(bins_remain_cap)
    std_cap = np.std(bins_remain_cap)
    epsilon = 1e-6
    
    # Adaptive weight via logistic coefficient of variation scaling
    cv = std_cap / (mean_cap + epsilon)
    alpha = 1.0 / (1.0 + np.exp(-cv * 10))  # Dynamic ratio/residual weighting
    
    residual = bins_remain_cap - item
    ratio = item / (bins_remain_cap + epsilon)
    
    # Fragmentation penalty in threshold (mu - sigma)
    threshold = mean_cap - std_cap
    penalty_factor = 1.0 / (mean_cap + std_cap + epsilon)
    delta = np.clip(threshold - residual, 0.0, None)
    penalty_term = delta * penalty_factor
    
    # Smooth exponential residual with penalty_term added to exponent
    tau_residual = mean_cap + std_cap + epsilon
    component_residual = np.exp(- (residual / tau_residual + penalty_term))
    
    component_ratio = ratio
    
    composite = alpha * component_ratio + (1 - alpha) * component_residual
    
    return np.where(can_fit, composite, -np.inf)
```
