```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    can_fit = bins_remain_cap >= item
    if not np.any(can_fit):
        return np.full_like(bins_remain_cap, -np.inf)
    
    new_remaining = bins_remain_cap - item
    
    # Immediate fit quality (higher = better fit)
    fit_component = -new_remaining
    
    # Current bin statistics
    mean_remaining = np.mean(bins_remain_cap)
    std_remaining = np.std(bins_remain_cap)
    
    # Adaptive threshold for critical fragmentation level
    threshold = mean_remaining - std_remaining
    
    # Smooth logistic penalty for approaching fragmentation
    steepness = 1.0 / (std_remaining + 1e-6)
    penalty_distance = steepness * (new_remaining - threshold)
    fragmentation_penalty = 1.0 / (1.0 + np.exp(penalty_distance))
    
    # Context-aware penalty scaling
    penalty_weight = 0.5 * (std_remaining + item)
    penalty_component = fragmentation_penalty * penalty_weight
    
    # Multi-objective score blending
    score = fit_component - penalty_component
    
    return np.where(can_fit, score, -np.inf)
```
