```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Adaptive priority combining residual minimization and fragmentation control using dynamic thresholds.
    Uses mean+std for residual scaling, mean-std for fragmentation threshold, and exponential blending.
    """
    can_fit = bins_remain_cap >= item
    r = bins_remain_cap - item  # Residual after placing item
    
    # Dynamic statistics from feasible bins (or all if no feasible)
    feasible_caps = bins_remain_cap[can_fit]
    if feasible_caps.size == 0:
        mu, sigma = np.mean(bins_remain_cap), np.std(bins_remain_cap)
    else:
        mu, sigma = np.mean(feasible_caps), np.std(feasible_caps)
    
    # Thresholds for scaling (T) and fragmentation control
    T = np.clip(mu + sigma, 1e-8, None)  # Residual scaling factor
    threshold_frag = mu - sigma  # Fragmentation avoidance threshold
    
    # Adaptive blending factor (item size relative to T)
    alpha = 1.0 - np.exp(-item / T)
    
    # Residual minimization term: exponential decay for smaller residuals
    residual_term = np.exp(-r / T)
    
    # Fragmentation penalty: penalize residuals below threshold_frag
    delta = np.clip(threshold_frag - r, 0.0, None)  # Only penalize deficit
    frag_term = np.exp(-delta / T)
    
    # Multi-objective blend with adaptive weights
    blended_score = alpha * residual_term + (1 - alpha) * frag_term
    
    # Enforce feasibility with -inf mask
    return np.where(can_fit, blended_score, -np.inf)
```
