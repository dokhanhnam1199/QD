```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    feasible = bins_remain_cap >= item
    if not feasible.any():
        return np.full_like(bins_remain_cap, -np.inf)
    
    feasible_remain = bins_remain_cap[feasible]
    residuals = feasible_remain - item
    
    # Adaptive weight calculation using CV
    mean_remain, std_remain = feasible_remain.mean(), feasible_remain.std()
    cv = std_remain / (mean_remain + 1e-8)
    w_remain = 1 / (1 + np.exp(-cv))  # Logistic weight transition
    
    # Smooth scoring components
    res_norm = (residuals - residuals.mean()) / (residuals.std() + 1e-8)
    rem_norm = (feasible_remain - mean_remain) / (std_remain + 1e-8)
    
    # Logistic blending of residual/density objectives
    score_residual = 1 / (1 + np.exp(res_norm))  # Higher for smaller residuals
    score_remain = 1 / (1 + np.exp(rem_norm))    # Higher for smaller remaining caps
    
    composite = (1 - w_remain) * score_residual + w_remain * score_remain
    
    scores = np.full_like(bins_remain_cap, -np.inf)
    scores[feasible] = composite
    return scores
```
