```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    can_fit = bins_remain_cap >= item
    feasible_mask = can_fit
    feasible_remain = bins_remain_cap[feasible_mask]
    
    if feasible_remain.size == 0:
        return np.full_like(bins_remain_cap, -np.inf)
    
    # Residual space after placing item in feasible bin
    feasible_residuals = feasible_remain - item
    
    # --- Primary Term: Exponential sensitivity to residual space ---
    # Emphasizes tight fits with strong decay in score as residual increases
    primary = np.exp(-feasible_residuals)
    
    # --- Secondary Penalty: Fragmentation avoidance via dynamic z-score ---
    # Compute mean & std of feasible residuals to contextualize each bin
    mu = feasible_residuals.mean()
    sigma = feasible_residuals.std() + 1e-8  # Avoid division by zero
    
    # Calculate z-scores relative to distribution
    z = (feasible_residuals - mu) / sigma
    
    # Penalty peaks at mean residual (fragmented "typical" space)
    # Using Gaussian basis to penalize mid-distribution residuals smoothly
    penalty = np.exp(-z**2 / 2)
    
    # --- Smooth blending of objectives ---
    # Combine terms with heuristic weight to balance exploration/exploitation
    blended_scores = primary - 0.5 * penalty
    
    # --- Apply feasibility mask with infinite negative priority for invalid bins ---
    all_scores = np.full_like(bins_remain_cap, -np.inf)
    all_scores[feasible_mask] = blended_scores
    
    return all_scores
```
