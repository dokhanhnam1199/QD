```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Adaptive priority using dual exponential scoring and dynamic item classification."""
    if len(bins_remain_cap) == 0:
        return np.array([])
    
    can_fit = bins_remain_cap >= item
    eps = 1e-9

    # Bin statistics for contextual adaptivity
    mean_remaining = np.mean(bins_remain_cap)
    harmonic_mean = len(bins_remain_cap) / (np.sum(1.0 / (bins_remain_cap + eps)) + eps)
    
    # Dynamic item classification using harmonic mean + margin
    is_large = item > (harmonic_mean * 0.85)
    
    # Core scoring components with exponential continuity
    with np.errstate(divide='ignore', invalid='ignore'):
        fit_ratio = item / (bins_remain_cap + eps)
        leftover = bins_remain_cap - item
        
        # Best Fit component (large items): maximize fit_ratio & minimize leftover
        fit_component = np.exp(2.0 * fit_ratio)
        leftover_component = np.exp(-0.5 * leftover)
        
        # Worst Fit component (small items): prefer higher remaining capacity bins
        cap_ratio = bins_remain_cap / (mean_remaining + eps)
        capacity_component = np.exp(0.7 * cap_ratio)  # Weighted capacity preference
        soft_penalty = np.exp(-0.2 * leftover)  # Light leftover penalty

    # Strategy blending based on item size
    if is_large:
        score = fit_component * leftover_component  # Best Fit with dual emphasis
    else:
        score = capacity_component * soft_penalty  # Worst Fit with soft packing

    return np.where(can_fit, score, -np.inf)
```
