```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Adaptive priority with item-driven thresholds and smooth exponential weighting.
    
    Combines dynamic item-based thresholds (tight/moderate/loose fit zones) with
    continuous exponential scoring components. Uses harmonic mean for item 
    classification and capacity scaling for small items.
    """
    if len(bins_remain_cap) == 0:
        return np.array([])
    
    eps = 1e-9
    can_fit = bins_remain_cap >= item
    
    # Adaptive item classification using harmonic mean
    harmonic_mean = len(bins_remain_cap) / (np.sum(1.0 / (bins_remain_cap + eps)) + eps)
    is_large = item > (harmonic_mean * 0.8)
    
    # Dynamic thresholds based on item size (contextual adaptability)
    tight_threshold = 0.15 * item
    moderate_threshold = 0.4 * item
    remaining_after = bins_remain_cap - item
    
    # Contextual scoring zones with smooth transitions
    tight_mask = can_fit & (remaining_after <= tight_threshold)
    mod_mask = can_fit & (remaining_after > tight_threshold) & (remaining_after <= moderate_threshold)
    loose_mask = can_fit & (remaining_after > moderate_threshold)
    
    # Zone-specific exponential weighting coefficients
    k_fit = np.select(
        [tight_mask, mod_mask, loose_mask],
        [2.0, 1.6, 1.2], 
        default=0.0
    )
    k_penalty = np.select(
        [tight_mask, mod_mask, loose_mask],
        [0.7, 0.5, 0.3],
        default=0.0
    )
    
    # Smooth multi-objective components
    fit_ratio = item / (bins_remain_cap + eps)
    underfill_penalty = np.clip(remaining_after, 0, None)
    
    fit_component = np.exp(fit_ratio * k_fit)
    penalty_component = np.exp(-underfill_penalty * k_penalty)
    
    # Adaptive strategy blending based on item classification
    if is_large:
        score = fit_component * penalty_component
    else:
        capacity_scaling = bins_remain_cap / (bins_remain_cap.mean() + eps)
        score = (1.0 + capacity_scaling) * penalty_component
    
    return np.where(can_fit, score, -np.inf)
```
