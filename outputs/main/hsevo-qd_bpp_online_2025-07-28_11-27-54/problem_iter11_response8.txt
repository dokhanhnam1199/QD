```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Adaptive blend of best-fit and fragmentation avoidance using item-to-median ratio.
    
    Combines residual minimization for large items and fragmentation avoidance for small items,
    dynamically weighted by item size relative to current median bin capacity.
    """
    can_fit = bins_remain_cap >= item
    r = bins_remain_cap - item  # Residual after placement
    
    # Dynamic threshold from median remaining capacity
    T = np.clip(np.median(bins_remain_cap), 1e-8, None)
    
    # Adaptive blending factor: 0 (small items) to 1 (large items)
    beta = np.clip(item / T, 0, 1)
    
    # Best-fit component: prioritizes minimal residual
    best_fit_score = -r  
    
    # Fragmentation avoidance: prioritizes larger residuals via exponential penalty
    frag_avoid_score = -np.exp(-r / T)  
    
    # Dynamic multi-objective blend
    blended_score = beta * best_fit_score + (1 - beta) * frag_avoid_score
    
    # Enforce feasibility with -inf mask
    return np.where(can_fit, blended_score, -np.inf)
```
