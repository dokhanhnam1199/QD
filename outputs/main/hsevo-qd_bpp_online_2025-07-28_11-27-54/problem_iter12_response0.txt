```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority scores for bins using a smooth, context-adaptive multi-objective heuristic.
    
    Combines residual minimization, fragmentation avoidance, and contextual normalization
    using exponential smoothing and distribution-aware scaling.
    
    Args:
        item: Size of the item to be packed.
        bins_remain_cap: Array of remaining capacities for each bin.
    
    Returns:
        Array of priority scores for each bin.
    """
    # Feasibility mask: bins that can accommodate the item
    can_fit = bins_remain_cap >= item
    scores = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)

    if not np.any(can_fit):
        return scores  # Return -inf scores if no valid bin

    # Extract feasible values
    feasible_remaining = bins_remain_cap[can_fit]
    feasible_residuals = feasible_remaining - item  # residual = remaining_cap - item

    # Contextual statistics for adaptation
    mu_r = np.mean(feasible_residuals)
    sigma_r = np.std(feasible_residuals)
    mu_c = np.mean(feasible_remaining)
    sigma_c = np.std(feasible_remaining)

    # Avoid division by zero in adaptive parameters
    sigma_r = max(sigma_r, 1e-6)
    sigma_c = max(sigma_c, 1e-6)
    mu_r = max(mu_r, 1e-6)  # Ensure positive residual reference

    # Adaptive scaling factors
    alpha = 1.0 / mu_r  # Tight fit sensitivity
    beta = 0.5 * sigma_c  # Contextual dispersion sensitivity

    # Vectorized computations for all bins
    r = bins_remain_cap - item
    c = bins_remain_cap

    # Smooth scoring components
    # Component 1: Adaptive exponential decay for residual minimization
    fit_score = np.exp(- alpha * r)

    # Component 2: Gaussian-like penalty for fragmentation (small residuals)
    frag_penalty = np.exp(- (r - mu_r)**2 / (2 * sigma_r**2))

    # Component 3: Bin capacity normalization
    capacity_score = np.exp(- beta * np.abs(c - mu_c))

    # Smooth multi-objective blending with product of exponential components
    blended = fit_score * frag_penalty * capacity_score

    # Apply feasibility mask and assign to scores
    scores[can_fit] = blended[can_fit]

    return scores
```
