```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority scores using adaptive multi-objective blending with smooth logistic transitions.
    
    Combines residual minimization and bin density maximization via CV-based weights,
    with strict feasibility masking and continuous scoring.
    
    Args:
        item: Size of the item to be packed.
        bins_remain_cap: Array of remaining capacities for each bin.
    
    Returns:
        Array of priority scores for each bin.
    """
    feasible = bins_remain_cap >= item
    if not np.any(feasible):
        return np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)
    
    # Estimate bin capacity from current state
    C = np.max(bins_remain_cap)
    
    # Primary objectives
    residual_score = item - bins_remain_cap  # Best Fit baseline (negative)
    density_score = (C - bins_remain_cap) / C  # Normalized bin utilization
    
    # Adaptive weight calculation using coefficient of variation
    filled_fraction = (C - bins_remain_cap) / C
    mean_density = np.mean(filled_fraction)
    std_density = np.std(filled_fraction)
    cv = std_density / mean_density if mean_density > 0 else 0
    
    # Smooth logistic weight transition
    weight = 1.0 / (1.0 + np.exp(-cv))  # Maps CV ∈ [0,∞) → weight ∈ [0,1]
    
    # Multi-objective blend with continuous scoring
    blend_scores = residual_score + weight * density_score
    
    # Strict feasibility masking
    return np.where(feasible, blend_scores, -np.inf)
```
