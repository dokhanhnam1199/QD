```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Priority combining median-based tau, logistic fit/residual blending, and exponential fragmentation avoidance.
    Uses robust statistics, item-relative fit ratios, and smooth multi-objective tradeoffs with feasibility masking."""
    feasible = bins_remain_cap >= item
    if not feasible.any():
        return np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)
    
    r = bins_remain_cap - item
    feasible_r = r[feasible]
    
    # Robust central tendency and spread estimation
    median_r = np.median(feasible_r)
    std_r = feasible_r.std()
    eps = 1e-6
    tau = median_r + std_r + eps  # Dynamic scale using median for robustness
    
    # Fit tightness metric and logistic adaptive blending
    fit_ratio = item / (bins_remain_cap + eps)
    logistic_input = (item - median_r) / (std_r + tau + eps)
    logistic_weight = 1 / (1 + np.exp(-logistic_input))  # Contextual balance factor
    
    # Multi-objective components
    residual_objective = -r  # Primary residual minimization
    fit_objective = fit_ratio  # Secondary tight-fit maximization
    combined = logistic_weight * fit_objective + (1 - logistic_weight) * residual_objective
    
    # Smooth fragmentation penalty with item-relative scaling
    beta = np.clip(item / (median_r + eps), 0.1, 10.0)  # Bounded adaptive weight
    penalty_term = np.exp(-r / (tau + eps))
    fragmentation = -beta * penalty_term
    
    # Final priority score with numerical stability
    score = combined + fragmentation
    return np.where(feasible, score, -np.inf).astype(np.float64)
```
