```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    feasible_mask = bins_remain_cap >= item
    if not np.any(feasible_mask):
        return np.full_like(bins_remain_cap, -np.inf)
    
    current_mean = np.mean(bins_remain_cap)
    current_std = np.std(bins_remain_cap)
    epsilon = 1e-8
    
    s = bins_remain_cap - item
    
    # Dynamic thresholding based on current distribution
    threshold = current_mean - current_std
    std_factor = 1.0 / (current_std + epsilon)
    
    # Smooth logistic penalty for fragmentation risk
    fragmentation_penalty = 1.0 / (1.0 + np.exp(2.0 * (threshold - s) * std_factor))
    
    # Adaptive penalty weighting based on item-to-mean ratio
    item_rel_metric = item / (current_mean + epsilon)
    penalty_weight = 1.0 / (1.0 + item_rel_metric**2)  # Dynamic scaling
    
    # Multi-objective score blending
    fit_component = -s  # Best Fit equivalent
    penalty_component = fragmentation_penalty * penalty_weight
    
    combined_score = fit_component - penalty_component
    
    return np.where(feasible_mask, combined_score, -np.inf)
```
