```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Smooth blending of Worst Fit and Best Fit via dynamic median threshold and sigmoid weighting.
    
    Uses median remaining capacity to calculate a continuous blending weight between exponential
    scoring strategies: exp(remaining) for capacity preservation and exp(-leftover) for tight fits.
    Combines contextual adaptation with mathematical continuity to minimize fragmentation.
    """
    valid_mask = bins_remain_cap >= item
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)
    
    if not np.any(valid_mask):
        return priorities
    
    # Dynamic threshold based on median of valid bins' remaining capacities
    threshold = np.median(bins_remain_cap[valid_mask])
    
    # Continuous blending weight using sigmoid function (steepness 10)
    blending = 1.0 / (1.0 + np.exp((item - threshold) * 10.0))
    
    # Component scores
    wf_score = np.exp(bins_remain_cap)                # Reward larger remaining capacity
    leftover = bins_remain_cap - item
    bf_score = np.exp(-leftover)                      # Reward smaller leftover space
    
    # Convex combination of both strategies
    blended_score = blending * bf_score + (1.0 - blending) * wf_score
    
    priorities[valid_mask] = blended_score[valid_mask]
    return priorities
```
