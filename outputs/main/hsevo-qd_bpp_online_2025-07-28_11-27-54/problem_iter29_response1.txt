```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Priority function combining robust statistics, density-aware penalties, and multi-objective blending.
    Uses median/MAD for outlier-resistant residual scaling, exponential fragmentation avoidance, 
    and z-score-based density rewards to balance residual minimization with bin capacity harmonization.
    """
    feasible = bins_remain_cap >= item
    if not feasible.any():
        return np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)
    
    r = bins_remain_cap - item
    feasible_r = r[feasible]
    
    # Robust statistics using median and MAD (resistant to outliers)
    mu = np.median(feasible_r)
    mad = np.median(np.abs(feasible_r - mu)) * 1.4826  # Scale MAD to approximate std
    eps = 1e-6
    tau = mu + mad + eps  # Dynamic scale with robust central tendency + spread
    
    # Fragmentation penalty with adaptive exponential scaling
    penalty_term = np.exp(-r / tau)
    beta = item / tau  # Contextual weight balancing item size vs capacity scale
    fragmentation_objective = -beta * penalty_term
    
    # Density reward via z-score proximity to global bin capacity distribution
    global_mu = np.mean(bins_remain_cap)
    global_std = np.std(bins_remain_cap) + eps
    z_score = (r - global_mu) / global_std
    density_objective = -np.abs(z_score)  # Encourage residuals near global capacity median
    
    # Multi-objective score blending
    residual_objective = -r  # Primary residual minimization
    score = residual_objective + fragmentation_objective + density_objective
    
    return np.where(feasible, score, -np.inf).astype(np.float64)
```
