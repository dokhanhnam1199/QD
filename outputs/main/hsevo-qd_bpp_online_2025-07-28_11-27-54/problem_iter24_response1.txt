```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority scores for bins using a dynamic multi-objective heuristic.
    
    Combines residual minimization with fragmentation penalties via exponential scoring,
    calibrated to real-time bin distribution statistics (median/σ). Smooth masking ensures
    feasibility while avoiding brittle single-objective tradeoffs.
    
    Args:
        item: Size of the item to be packed.
        bins_remain_cap: Array of remaining capacities for each bin.
    
    Returns:
        Array of priority scores for each bin.
    """
    can_fit = bins_remain_cap >= item
    residuals = bins_remain_cap - item
    
    # Dynamic context parameters with safety guards
    epsilon = 1e-9
    median_remain = np.median(bins_remain_cap) if len(bins_remain_cap) > 0 else epsilon
    sigma_remain = np.std(bins_remain_cap) if len(bins_remain_cap) > 0 else epsilon
    sigma_remain_safe = sigma_remain + epsilon
    
    # Adaptive threshold for fragmentation sensitivity
    threshold = median_remain - sigma_remain_safe
    
    # Residual minimization term (exponential decay)
    term1 = np.exp(-residuals / (median_remain + epsilon))
    
    # Fragmentation penalty term (logistic distance from threshold)
    delta = (threshold - residuals)
    penalty = np.where(
        can_fit,
        np.where(
            delta > 0,  # Residual below threshold → fragmentation risk
            np.exp(delta / sigma_remain_safe),
            0
        ),
        0
    )
    term2 = 1.0 / (1.0 + penalty)
    
    # Multi-objective blending with smooth masking
    combined_score = term1 * term2
    return np.where(can_fit, combined_score, -np.inf)
```
