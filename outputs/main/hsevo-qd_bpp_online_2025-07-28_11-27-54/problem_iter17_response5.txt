```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines dynamic item classification with multi-objective exponential scoring.
    Uses μ+σ threshold for small/large classification, blends Worst/Best Fit
    with fragmentation penalties scaled by inverse mean capacity.
    """
    valid_mask = bins_remain_cap >= item
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)
    
    if not np.any(valid_mask):
        return priorities
    
    # Dynamic context-aware parameters
    mu = np.mean(bins_remain_cap)
    sigma = np.std(bins_remain_cap)
    class_threshold = mu + sigma  # Adaptive item classification boundary
    frag_threshold = mu  # Fragmentation-sensitive threshold
    penalty_factor = 1.0 / (mu + 1e-8)  # Adaptive penalty scaling
    
    residuals = bins_remain_cap[valid_mask] - item
    
    # Item size classification and scoring
    if item <= class_threshold:
        # Small item: Worst Fit base with fragmentation penalty
        frag_penalty = np.clip(frag_threshold - residuals, 0.0, None)
        priorities[valid_mask] = np.exp(bins_remain_cap[valid_mask]) * np.exp(-penalty_factor * frag_penalty)
    else:
        # Large item: Best Fit base with enhanced fragmentation avoidance
        frag_penalty = np.clip(frag_threshold - residuals, 0.0, None)
        priorities[valid_mask] = np.exp(-residuals) * np.exp(-penalty_factor * frag_penalty)
    
    return priorities
```
