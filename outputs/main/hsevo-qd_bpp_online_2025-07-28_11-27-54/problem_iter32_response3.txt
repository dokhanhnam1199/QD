```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Priority heuristic blending z-score adaptive fit rewards with item-relative efficiency.
    
    Combines z-score-based exponential rewards (for residuals below mean) and 
    item-relative exponential rewards, weighted by logistic-coefficient-of-variation.
    Uses feasible-bin statistics for contextual adaptivity and strict feasibility masking.
    """
    feasible = bins_remain_cap >= item
    if not feasible.any():
        return np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)
    
    feasible_r = bins_remain_cap[feasible] - item
    mu_r = feasible_r.mean()
    std_r = feasible_r.std()
    eps = 1e-9
    
    # Z-score transformation for adaptive fit sensitivity
    z_scores = (feasible_r - mu_r) / (std_r + eps)
    z_reward = np.exp(-z_scores)  # Rewards residuals < mu_r
    
    # Item-relative efficiency reward
    item_relative_reward = np.exp(-feasible_r / (item + eps))
    
    # Adaptive weight via logistic-weighted coefficient of variation
    cv = std_r / (mu_r + eps)
    weight = 1.0 / (1.0 + np.exp(-cv))  # High CV â†’ prioritize z_reward
    
    # Multi-objective exponential blending
    combined_score = weight * z_reward + (1 - weight) * item_relative_reward
    
    # Build final scores with feasibility mask
    scores = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)
    scores[feasible] = combined_score
    return scores
```
