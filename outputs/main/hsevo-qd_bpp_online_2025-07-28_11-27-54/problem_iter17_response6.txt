```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines residual minimization with adaptive fragmentation penalties.
    Uses mu+sigma threshold and median-based penalty scaling to balance packing efficiency and bin utilization.
    """
    can_fit = bins_remain_cap >= item
    residual = bins_remain_cap - item

    # Dynamic statistics for adaptive thresholds/scaling
    mu = np.mean(bins_remain_cap)
    sigma = np.std(bins_remain_cap)
    T = np.median(bins_remain_cap)
    epsilon = 1e-8

    # Context-aware threshold (mu+sigma) for fragmentation avoidance
    threshold = mu + sigma  
    # Adaptive penalty scaling based on median capacity
    penalty_factor = 1.0 / (T + epsilon)  

    # Fragmentation penalty calculation
    feasible_r = np.where(can_fit, residual, np.inf)
    delta = np.clip(threshold - feasible_r, 0.0, None)  # Under-threshold deficit
    penalty = np.exp(delta * penalty_factor) - 1  # Exponential penalty for small residuals

    # Combined objective: minimize residual while avoiding fragmentation
    blended_score = - feasible_r - penalty  

    # Enforce strict feasibility via masking
    return np.where(can_fit, blended_score, -np.inf)
```
