```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority scores using dynamic bin statistics and exponential blending.
    
    Scores are computed via exponential combination of residual minimization and 
    bin-capacity normalization, with soft feasibility penalties. Differentiable 
    scoring ensures gradient-guided optimization compatibility.
    
    Args:
        item: Size of the item to be packed.
        bins_remain_cap: Array of remaining capacities for each bin.
    
    Returns:
        Array of priority scores for each bin.
    """
    mu = np.mean(bins_remain_cap)
    sigma = np.std(bins_remain_cap)
    epsilon = 1e-8
    
    s = bins_remain_cap - item
    valid_mask = s >= 0
    
    # Valid bin scoring: residual minimization + capacity normalization
    exp_term1 = np.exp(-s / (mu + epsilon))  # Residual minimization term
    exp_term2 = np.exp((bins_remain_cap - mu) / (sigma + epsilon))  # Fragmentation-aware term
    valid_score = exp_term1 * exp_term2
    
    # Invalid bin penalty: soft exponential deficit penalty
    deficit = -s * ~valid_mask
    invalid_score = -np.exp(deficit / (sigma + epsilon))
    
    return np.where(valid_mask, valid_score, invalid_score)
```
