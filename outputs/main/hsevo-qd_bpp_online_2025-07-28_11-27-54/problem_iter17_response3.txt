```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Dynamic item classification using median threshold with smooth exponential scoring.
    Large items (> median): residual minimization via exp(-k*residual).
    Small items: remaining maximization via exp(k*remaining).
    Adaptive k = 1/(μ + ε) balances sensitivity to bin occupancy.
    """
    if len(bins_remain_cap) == 0:
        return np.array([])
    
    eps = 1e-8
    can_fit = bins_remain_cap >= item
    if not np.any(can_fit):
        return np.full_like(bins_remain_cap, -np.inf)
    
    # Dynamic statistics
    mu = np.mean(bins_remain_cap)
    median = np.median(bins_remain_cap)
    
    # Adaptive scaling factor
    penalty_factor = 1.0 / (mu + eps)
    
    # Dynamic item classification
    is_large = item > median
    
    # Smooth scoring with feasibility mask
    scores = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)
    if is_large:
        residual = bins_remain_cap[can_fit] - item
        scores[can_fit] = np.exp(-residual * penalty_factor)
    else:
        remaining = bins_remain_cap[can_fit]
        scores[can_fit] = np.exp(remaining * penalty_factor)
    
    return scores
```
