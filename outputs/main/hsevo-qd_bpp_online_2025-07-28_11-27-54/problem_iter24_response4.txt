```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    can_fit = bins_remain_cap >= item
    if not np.any(can_fit):
        return np.full_like(bins_remain_cap, -np.inf, dtype=np.float32)
    
    feasible_res = bins_remain_cap[can_fit] - item
    
    # Dynamic statistical context from feasible residuals
    median_res = np.median(feasible_res)
    mad_res = np.median(np.abs(feasible_res - median_res))
    mad_res = max(mad_res, 1e-8)
    
    # Adaptive fragmentation threshold (non-negative)
    frag_threshold = max(median_res - mad_res, 0.0)
    
    # Component 1: Residual minimization with exponential scaling
    scale_r = median_res + mad_res + 1e-8
    comp1 = np.exp(-feasible_res / scale_r)
    
    # Component 2: Logistic penalty for critical fragmentation
    z = (feasible_res - frag_threshold) / mad_res
    comp2 = 1.0 / (1.0 + np.exp(-5.0 * z))  # Sharpness factor
    
    # Multi-objective smooth blending
    composite = comp1 * comp2
    
    # Final score assembly
    scores = np.full_like(bins_remain_cap, -np.inf, dtype=np.float32)
    scores[can_fit] = composite.astype(np.float32)
    
    return scores
```
