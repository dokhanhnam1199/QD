```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Adaptive priority combining residual minimization and fragmentation avoidance.
    
    Uses dynamic alpha blending based on item-to-threshold ratio to balance objectives:
    large items prioritize fit quality (-r), small items prioritize space cohesion (-exp(-r/T)).
    """
    can_fit = bins_remain_cap >= item
    r = bins_remain_cap - item  # Residual capacity after placement
    
    # Dynamic threshold using median remaining capacity
    T = np.clip(np.median(bins_remain_cap), 1e-8, None)
    
    # Adaptive blending factor based on item size relative to T (sigmoidal response)
    alpha = 1.0 - np.exp(-item / T)  # Approaches 1 for large items, 0 for small
    
    # Smooth penalty term for fragmentation avoidance
    feasible_r = np.where(can_fit, r, np.inf)  # Mask invalid bins for statistics
    penalty_term = np.exp(-feasible_r / T)  # Exponential decay penalizes small residuals
    
    # Convex combination of residual minimization and penalty shaping
    blended_score = alpha * (-r) + (1 - alpha) * (-penalty_term)
    
    # Enforce feasibility with negative infinity mask
    return np.where(can_fit, blended_score, -np.inf)
```
