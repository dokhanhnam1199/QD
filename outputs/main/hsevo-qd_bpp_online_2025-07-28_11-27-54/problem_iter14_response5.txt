```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Adaptive exponential scoring blending residual minimization and bin statistics.
    
    Combines item-normalized residual minimization with bin-centric adaptivity via:
    1. Exponential penalty on remaining_after scaled by item size (fragmentation avoidance)
    2. Dynamic normalization using bin statistics (mean/std) for contextual adaptivity
    3. Smooth continuity through exponential function to replace discrete thresholds
    """
    can_fit = bins_remain_cap >= item
    remaining_after = bins_remain_cap - item
    
    # Adaptive scaling using item size and bin statistics
    mu_remain = np.mean(bins_remain_cap)
    sigma_remain = np.std(bins_remain_cap)
    
    # Contextual normalization factor combining item size and bin variability
    norm_factor = (item + mu_remain + sigma_remain) / 3 + 1e-6
    
    # Smooth exponential score with item-normalized curvature
    scores = np.exp(-remaining_after / norm_factor)
    
    # Penalize bins far from mean remaining_after using Gaussian z-score
    z_score = (remaining_after - mu_remain) / (sigma_remain + 1e-6)
    scores *= np.exp(-z_score**2 / 2)
    
    return np.where(can_fit, scores, -np.inf)
```
