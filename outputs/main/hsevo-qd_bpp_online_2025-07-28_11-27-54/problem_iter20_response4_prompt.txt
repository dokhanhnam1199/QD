{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritize bins using fixed thresholds and non-smooth Best/Worst Fit for large/small items.\n    \n    Fixed 0.5 threshold classifies items. Best Fit (step) for large, Worst Fit (step) for small.\n    \"\"\"\n    if len(bins_remain_cap) == 0:\n        return np.array([])\n    \n    can_fit = bins_remain_cap >= item\n    is_large = item > 0.5  # Fixed threshold for item classification\n    \n    # Initialize priority scores\n    priority = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)\n    \n    if not np.any(can_fit):\n        return priority\n    \n    if is_large:\n        # Best Fit: prioritize bins with minimal leftover space (step function)\n        leftover = np.where(can_fit, bins_remain_cap - item, np.inf)\n        min_leftover = leftover.min()\n        best_fit = (leftover == min_leftover) & can_fit\n        priority[best_fit] = 1.0\n    else:\n        # Worst Fit: prioritize bins with maximum remaining capacity (step function)\n        remaining = np.where(can_fit, bins_remain_cap, -np.inf)\n        max_remaining = remaining.max()\n        best_worst = (remaining == max_remaining) & can_fit\n        priority[best_worst] = 1.0\n    \n    return priority\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority scores for bins using a thresholded categorical heuristic.\n    \n    Bins that can fit the item are scored in discrete tiers based on normalized\n    remaining space after placement. Thresholds are anchored to item size for\n    contextual adaptability without instability from continuous scoring.\n    \n    Args:\n        item: Size of the item to be packed.\n        bins_remain_cap: Array of remaining capacities for each bin.\n    \n    Returns:\n        Array of priority scores for each bin.\n    \"\"\"\n    # Contextual thresholds based on item size\n    tight_threshold = 0.15 * item\n    moderate_threshold = 0.4 * item\n\n    # Identify viable bins and compute post-placement space\n    can_fit = bins_remain_cap >= item\n    remaining_after = bins_remain_cap - item\n\n    # Initialize scores with -inf for invalid bins\n    scores = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)\n\n    # Tier 1: Tight fit (minimal leftover space)\n    tight_mask = can_fit & (remaining_after <= tight_threshold)\n    # Tier 2: Moderate fit (small leftover space)\n    mod_mask = can_fit & (remaining_after > tight_threshold) & (remaining_after <= moderate_threshold)\n    # Tier 3: Loose fit (significant leftover space)\n    loose_mask = can_fit & (remaining_after > moderate_threshold)\n\n    # Assign discrete priority scores\n    scores[tight_mask] = 3\n    scores[mod_mask] = 2\n    scores[loose_mask] = 1\n\n    return scores\n\n### Analyze & experience\n- Comparing (1st) vs (15th-16th), we see dynamic statistical thresholds (mean+std) and smooth exponential penalties outperform static zero-scores; (2nd) vs (5th) shows adaptive item classification with exponential scoring surpasses fixed thresholds and step functions; (3rd-4th) use linear Best Fit, inferior to distribution-aware blending in (6th-8th). Comparing (1st) vs (2nd), both leverage smooth adaptivity but (1st) integrates spread (std) for fragmentation control. (3rd) vs (4th) are duplicates, highlighting linear scoring limitations. (5th) vs (15th) reveals even basic heuristics outperform no strategy. Overall: superior heuristics balance residual minimization, fragmentation avoidance, and contextual adaptivity via smooth, dynamic scoring.\n- \nKeywords: Adaptive bin statistics, smooth penalty gradients, multi-objective context blending, feasibility masking  \nAdvice: Use bin/item-aware dynamic thresholds (e.g., std dev from current load mean), penalize fragmentation with continuous functions (logistic decay), balance fit and future capacity in scoring, enforce hard constraints with -\u221e masks.  \nAvoid: Fixed thresholds, stepwise penalties, static weight ratios, context-ignorant scoring  \nExplanation: Dynamic thresholds adapt to evolving distributions, smooth gradients enable stable convergence, multi-objective tradeoffs prevent myopic decisions, and feasibility masks guarantee valid allocations.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}