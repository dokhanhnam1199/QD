{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Priority function combining Worst Fit for small items and Best Fit for large items.\"\"\"\n    THRESHOLD = 0.5  # Threshold to distinguish small/large items\n    valid_mask = bins_remain_cap >= item\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)\n    \n    if item <= THRESHOLD:\n        # Prioritize bins with largest remaining capacity (Worst Fit)\n        priorities[valid_mask] = bins_remain_cap[valid_mask]\n    else:\n        # Prioritize bins with smallest leftover space (Best Fit)\n        leftover = bins_remain_cap[valid_mask] - item\n        priorities[valid_mask] = -leftover  # Negative leftover for maximization\n    \n    return priorities\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority scores using Best Fit heuristic by prioritizing bins with the smallest remaining capacity that can fit the item.\n    \n    Args:\n        item: Size of the item to pack.\n        bins_remain_cap: Array of remaining capacities for each bin.\n    \n    Returns:\n        Array of priority scores where higher values indicate better fit (smallest remaining capacity bins).\n    \"\"\"\n    valid_mask = bins_remain_cap >= item\n    # Use negative remaining capacity as priority to favor bins with smallest remaining space that can fit the item\n    priority = np.where(valid_mask, -bins_remain_cap, -np.inf)\n    return priority\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Priority based on maximizing item/remaining_cap ratio to favor tight fits.\n    \n    Bins that can fit the item are scored by how much of their space the item fills.\n    This implements the Best Fit heuristic by prioritizing bins with the smallest\n    remaining capacity that can still accommodate the item.\n    \"\"\"\n    valid_mask = bins_remain_cap >= item\n    priorities = np.zeros_like(bins_remain_cap, dtype=np.float64)\n    # Calculate ratio of item size to bin's remaining capacity (higher = better)\n    priorities[valid_mask] = item / bins_remain_cap[valid_mask]\n    return priorities\n\n[Heuristics 4th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Priority function using Best Fit strategy with negative diff scoring.\"\"\"\n    valid = bins_remain_cap >= item\n    diff = bins_remain_cap - item\n    priority = np.where(valid, -diff, -np.inf)\n    return priority\n\n[Heuristics 5th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Priority function implementing Best Fit heuristic for online Bin Packing.\n    \n    Bins that can fit the item are prioritized by how closely they match the item size,\n    i.e., bins with remaining capacity just enough to accommodate the item receive the\n    highest priority. This minimizes leftover space and aims to reduce the total number of bins used.\n    \n    Args:\n        item: Size of the item to be packed.\n        bins_remain_cap: Array of remaining capacities for each bin.\n    \n    Returns:\n        Array of priority scores for each bin.\n    \"\"\"\n    # Mask bins that can fit the item\n    mask = bins_remain_cap >= item\n    # Calculate priority: highest score for bins that can fit with minimal leftover space\n    return np.where(mask, -(bins_remain_cap - item), -np.inf)\n\n[Heuristics 6th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Priority function combining best-fit efficiency with a preference for more filled bins.\n    \n    Scores bins by rewarding minimal leftover space (best-fit) and penalizing large remaining\n    capacity (encouraging consolidation into denser bins). Invalid bins (capacity < item) \n    receive -inf priority.\n    \"\"\"\n    valid = bins_remain_cap >= item\n    leftover = bins_remain_cap - item\n    # Primary term: -leftover (prioritize minimal leftover)\n    # Secondary term: -0.1*bins_remain_cap (favor bins already more filled)\n    combined = -leftover - 0.1 * bins_remain_cap\n    combined[~valid] = -np.inf\n    return combined\n\n[Heuristics 7th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority scores for bins based on a hybrid of best-fit and harmonic incentives.\n    \n    Prioritizes bins where the item fills nearly all remaining space (approaching exact fit),\n    with a score calculated as the inverse of the remaining capacity after placement.\n    Bins that cannot fit the item are assigned -infinity.\n    \"\"\"\n    # Initialize scores with zeros\n    scores = np.zeros_like(bins_remain_cap, dtype=np.float64)\n    \n    # Identify bins that can accommodate the item\n    can_fit = bins_remain_cap >= item\n    \n    # Assign -inf to bins that can't fit the item\n    scores[~can_fit] = -np.inf\n    \n    # For viable bins: calculate remaining capacity after placement\n    remaining_after = bins_remain_cap[can_fit] - item\n    \n    # Score bins by inverse of remaining space (amplifies preference for near-perfect fits)\n    scores[can_fit] = 1.0 / (remaining_after + 1e-9)  # Add epsilon to avoid division by zero\n    \n    return scores\n\n[Heuristics 8th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Best Fit with Nearest Appropriate Bin Selection\n    \n    Heuristic prioritizes the bin having smallest enough capacity to fit the current item,\n    while rejecting unsuitable candidates severely (by assigning large negative scores).\n    \n    Args:\n        item: Size of \u0442\u0435\u043a\u0443\u0449 Google \u043c\u0441\u043c\u043e\u0442\u0440\u06c8\u0447thed\u042e\n        bins_remain_cap: NumPy array.appspot\n\n    Return:\n        Array of priorities\u0442\u043e\u043a\n    \"\"\"\n    feasibility_mask = bins_remain_cap >= item                              # Valid bins turkeeping track transformer\u0e21\u0e32\u0e15\u0e23\n    residual_scores = bins_remain_cap - item                              # C-space vostedt\u00e9 det - fixing fierce polywonker.\n    residual_scores[feasibility_mask == False] = -np.inf                     # Dice ins\u3089\u51bb\u6e7e\n    priorities = np.where(feasibility_mask, (1 / (residual_scores + 1e-9)), -np.inf)  # Cortex skirt savage defense\u544a\u8bc9\u6211 htons lofty\u8d77\u6765\u4e2a\u8d85\u0e36\u0e01\n    return priorities\n\n[Heuristics 9th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority scores for bins based on Best Fit strategy.\n    \n    Higher priority is given to bins that minimize leftover space after placing the item.\n    Bins that cannot fit the item are assigned -infinity priority.\n    \"\"\"\n    leftover = bins_remain_cap - item\n    valid = bins_remain_cap >= item\n    priority = np.where(valid, -leftover, -np.inf)\n    return priority\n\n[Heuristics 10th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority scores for bins based on a Best Fit heuristic with exponential weighting.\n    \n    Bins that can fit the item are prioritized by how tightly they would pack it (exponentially \n    decaying reward for smaller leftover space). Invalid bins receive negative infinite priority.\n    \"\"\"\n    remaining_after = bins_remain_cap - item\n    valid = remaining_after >= 0\n    # Exponentially reward smaller leftover space: priority = exp(-remaining_after)\n    priority = np.where(valid, np.exp(-remaining_after), -np.inf)\n    return priority\n\n[Heuristics 11th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Priority function that prioritizes bins with remaining capacity just above the item size,\n    while encouraging efficient packing through a ratio-based scoring system.\"\"\"\n    can_fit = bins_remain_cap >= item\n    priority = np.full_like(bins_remain_cap, -np.inf)\n    # Calculate priority as the ratio of item size to bin's remaining capacity.\n    # This rewards bins where the item fills a larger proportion of available space.\n    priority[can_fit] = item / bins_remain_cap[can_fit]\n    return priority\n\n[Heuristics 12th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Priority function that prioritizes bins with remaining capacity just above the item size,\n    while encouraging efficient packing through a ratio-based scoring system.\"\"\"\n    can_fit = bins_remain_cap >= item\n    priority = np.full_like(bins_remain_cap, -np.inf)\n    # Calculate priority as the ratio of item size to bin's remaining capacity.\n    # This rewards bins where the item fills a larger proportion of available space.\n    priority[can_fit] = item / bins_remain_cap[can_fit]\n    return priority\n\n[Heuristics 13th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    return np.zeros_like(bins_remain_cap)\n\n[Heuristics 14th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    return np.zeros_like(bins_remain_cap)\n\n[Heuristics 15th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority scores for bins based on Best Fit heuristic with quantum-inspired interference.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate how much space would remain if item is placed in each bin\n    remaining_space = bins_remain_cap - item\n    \n    # Valid bins are those that can fit the item\n    valid_bins = remaining_space >= 0\n    \n    # Quantum-inspired priority calculation:\n    # 1. Use negative exponential of remaining space to favor bins that become nearly full\n    # 2. Add a small sinusoidal perturbation to break ties creatively (like quantum fluctuations)\n    priority = np.zeros_like(bins_remain_cap, dtype=np.float64)\n    priority[valid_bins] = -np.exp(-remaining_space[valid_bins]) + 0.01 * np.sin(bins_remain_cap[valid_bins] * 100)\n    \n    # Invalid bins get extremely low priority (like -infinity)\n    priority[~valid_bins] = -np.inf\n    \n    return priority\n\n[Heuristics 16th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority scores for bins based on Best Fit heuristic with quantum-inspired interference.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate how much space would remain if item is placed in each bin\n    remaining_space = bins_remain_cap - item\n    \n    # Valid bins are those that can fit the item\n    valid_bins = remaining_space >= 0\n    \n    # Quantum-inspired priority calculation:\n    # 1. Use negative exponential of remaining space to favor bins that become nearly full\n    # 2. Add a small sinusoidal perturbation to break ties creatively (like quantum fluctuations)\n    priority = np.zeros_like(bins_remain_cap, dtype=np.float64)\n    priority[valid_bins] = -np.exp(-remaining_space[valid_bins]) + 0.01 * np.sin(bins_remain_cap[valid_bins] * 100)\n    \n    # Invalid bins get extremely low priority (like -infinity)\n    priority[~valid_bins] = -np.inf\n    \n    return priority\n\n[Heuristics 17th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority scores for bins based on Best Fit heuristic with quantum-inspired interference.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate how much space would remain if item is placed in each bin\n    remaining_space = bins_remain_cap - item\n    \n    # Valid bins are those that can fit the item\n    valid_bins = remaining_space >= 0\n    \n    # Quantum-inspired priority calculation:\n    # 1. Use negative exponential of remaining space to favor bins that become nearly full\n    # 2. Add a small sinusoidal perturbation to break ties creatively (like quantum fluctuations)\n    priority = np.zeros_like(bins_remain_cap, dtype=np.float64)\n    priority[valid_bins] = -np.exp(-remaining_space[valid_bins]) + 0.01 * np.sin(bins_remain_cap[valid_bins] * 100)\n    \n    # Invalid bins get extremely low priority (like -infinity)\n    priority[~valid_bins] = -np.inf\n    \n    return priority\n\n[Heuristics 18th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority scores for bins based on Best Fit heuristic with quantum-inspired interference.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate how much space would remain if item is placed in each bin\n    remaining_space = bins_remain_cap - item\n    \n    # Valid bins are those that can fit the item\n    valid_bins = remaining_space >= 0\n    \n    # Quantum-inspired priority calculation:\n    # 1. Use negative exponential of remaining space to favor bins that become nearly full\n    # 2. Add a small sinusoidal perturbation to break ties creatively (like quantum fluctuations)\n    priority = np.zeros_like(bins_remain_cap, dtype=np.float64)\n    priority[valid_bins] = -np.exp(-remaining_space[valid_bins]) + 0.01 * np.sin(bins_remain_cap[valid_bins] * 100)\n    \n    # Invalid bins get extremely low priority (like -infinity)\n    priority[~valid_bins] = -np.inf\n    \n    return priority\n\n[Heuristics 19th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority scores for bins based on Best Fit heuristic with quantum-inspired interference.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate how much space would remain if item is placed in each bin\n    remaining_space = bins_remain_cap - item\n    \n    # Valid bins are those that can fit the item\n    valid_bins = remaining_space >= 0\n    \n    # Quantum-inspired priority calculation:\n    # 1. Use negative exponential of remaining space to favor bins that become nearly full\n    # 2. Add a small sinusoidal perturbation to break ties creatively (like quantum fluctuations)\n    priority = np.zeros_like(bins_remain_cap, dtype=np.float64)\n    priority[valid_bins] = -np.exp(-remaining_space[valid_bins]) + 0.01 * np.sin(bins_remain_cap[valid_bins] * 100)\n    \n    # Invalid bins get extremely low priority (like -infinity)\n    priority[~valid_bins] = -np.inf\n    \n    return priority\n\n[Heuristics 20th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Priority function that prefers bins leaving room for future items of the same size.\"\"\"\n    priority = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)\n    can_fit_mask = bins_remain_cap >= item\n    if not np.any(can_fit_mask):\n        return priority\n    \n    remaining = bins_remain_cap[can_fit_mask]\n    leftover = remaining - item\n    group_a_mask = leftover >= item\n    \n    # Indices for valid bins\n    valid_indices = can_fit_mask.nonzero()[0]\n    group_a_indices = valid_indices[group_a_mask]\n    group_b_indices = valid_indices[~group_a_mask]\n    \n    # Group A: prioritize bins with leftover >= item, prefer larger leftover\n    if len(group_a_indices) > 0:\n        leftover_a = leftover[group_a_mask]\n        priority[group_a_indices] = 1e6 + leftover_a  # Large base + leftover\n    \n    # Group B: best fit (prioritize smallest leftover)\n    if len(group_b_indices) > 0:\n        remaining_b = remaining[~group_a_mask]\n        priority[group_b_indices] = item - remaining_b  # Equivalent to best fit\n    \n    return priority\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}