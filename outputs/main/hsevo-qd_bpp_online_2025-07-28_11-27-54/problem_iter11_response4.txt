```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Adaptive priority combining residual minimization and fragmentation avoidance.
    
    Features:
    - Dynamic threshold using harmonic mean of item and median remaining capacity
    - Dual exponential scoring for residual and bin utilization
    - Variance-weighted blending of objectives
    """
    can_fit = bins_remain_cap >= item
    r = bins_remain_cap - item  # Residual after placement
    
    # Dynamic threshold based on harmonic mean of item size and median remaining
    median_remain = np.median(bins_remain_cap)
    T = (2 * item * median_remain) / (item + median_remain + 1e-8)
    
    feasible_r = np.where(can_fit, r, np.inf)
    
    # Primary objective: residual minimization with exponential shaping
    residual_score = -r
    
    # Secondary objective: fragmentation avoidance via exponential penalty
    penalty_term = np.exp(- feasible_r / (T + 1e-8))
    
    # Adaptive weight based on distribution variance
    var_remain = np.var(bins_remain_cap)
    adaptive_weight = 1.0 / (1.0 + np.sqrt(var_remain + 1e-8))
    
    # Combined score with smooth interpolation
    blended_score = residual_score - (adaptive_weight * penalty_term)
    
    return np.where(can_fit, blended_score, -np.inf)
```
