```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Adaptive priority using mean+std thresholding to blend residual minimization and fragmentation penalties."""
    can_fit = bins_remain_cap >= item
    r = bins_remain_cap - item
    
    # Dynamic threshold using mean+std of feasible bins (or all bins if none feasible)
    feasible_caps = bins_remain_cap[can_fit]
    if feasible_caps.size == 0:
        mu, sigma = np.mean(bins_remain_cap), np.std(bins_remain_cap)
    else:
        mu, sigma = np.mean(feasible_caps), np.std(feasible_caps)
    T = np.clip(mu + sigma, 1e-8, None)
    
    # Adaptive alpha blending based on item-to-threshold ratio
    alpha = 1.0 - np.exp(-item / T)
    
    # Fragmentation penalty using exponential decay
    feasible_r = np.where(can_fit, r, np.inf)
    penalty_term = np.exp(-feasible_r / T)
    
    # Multi-objective blend with feasibility enforcement
    blended_score = alpha * (-r) + (1 - alpha) * (-penalty_term)
    return np.where(can_fit, blended_score, -np.inf)
```
