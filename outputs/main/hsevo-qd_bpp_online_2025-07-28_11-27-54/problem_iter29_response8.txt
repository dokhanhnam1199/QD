```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Adaptive priority combining residual z-scores, density rewards, and exponential penalties.
    
    Key ideas:
    - Dynamic thresholding using median bin capacity
    - Adaptive weight blending via coefficient of variation (cv)
    - Z-score-based density penalties to avoid sparse residual regions
    - Smooth multi-objective combination of residual minimization and fragmentation avoidance
    """
    # Feasibility mask and residual calculation
    can_fit = bins_remain_cap >= item
    r = bins_remain_cap - item
    
    # Handle edge case: no feasible bins (shouldn't happen if new bin available)
    if not np.any(can_fit):
        return np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)
    
    # Dynamic threshold T (median of current bin capacities)
    T = np.clip(np.median(bins_remain_cap), 1e-8, None)
    
    # Coefficient of variation (cv) of bin_remain_cap for adaptive weighting
    mu_bin = np.mean(bins_remain_cap)
    sigma_bin = np.std(bins_remain_cap)
    cv = sigma_bin / (mu_bin + 1e-8)
    # Adaptive beta weight using logistic sigmoid
    beta = 1.0 / (1.0 + np.exp(-cv))  # Maps cv ∈ (0,∞) → beta ∈ (0,1)
    
    # Primary residual term scaled by threshold T
    residual_term = -r / T  # Prefers smaller residuals
    
    # Penalty term: exponential decay penalizing small residuals relative to T
    feasible_r = np.where(can_fit, r, np.inf)
    penalty_term = np.exp(- feasible_r / T )
    
    # Z-score based density penalty: avoid sparse residual regions
    feasible_mask = (feasible_r != np.inf)
    feasible_rs = feasible_r[feasible_mask]
    if len(feasible_rs) == 0:
        z_scores = np.zeros_like(feasible_r)
    else:
        r_mean = np.mean(feasible_rs)
        r_std = np.std(feasible_rs)
        # Avoid division by zero in z-score
        z_scores = (feasible_r - r_mean) / (r_std + 1e-8)
    
    # Density reward: prefer residuals near distribution center (low |z-score|)
    density_penalty = -np.abs(z_scores)  # Negative penalty for deviation from mean
    
    # Adaptive multi-objective blending
    blended_score = beta * (residual_term + density_penalty) - (1 - beta) * penalty_term
    
    # Apply feasibility mask
    return np.where(can_fit, blended_score, -np.inf)
```
