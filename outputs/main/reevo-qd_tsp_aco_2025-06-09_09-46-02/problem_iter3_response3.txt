```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic function for the Traveling Salesman Problem (TSP) based on stochastic solution sampling with improvements.

    This function refines the heuristics by incorporating node proximity, edge diversity, and iterative refinement
    to enhance the exploration-exploitation balance in TSP solution sampling.

    Args:
        distance_matrix (np.ndarray): A square matrix representing the distances between cities.
                                         distance_matrix[i][j] is the distance between city i and city j.

    Returns:
        np.ndarray: A matrix of the same shape as distance_matrix, where each element represents the
                      promise of including the corresponding edge in the TSP solution.
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

    # 1. Node Proximity (Inverse Distance with Scaling)
    inverse_distance = 1 / (distance_matrix + 1e-6)
    proximity_factor = np.mean(distance_matrix) / (distance_matrix + 1e-6)  # Scale based on average distance
    node_proximity = inverse_distance * proximity_factor

    # 2. Edge Diversity (Penalize High-Degree Nodes)
    degree_penalty = np.zeros_like(distance_matrix, dtype=float)
    for i in range(n):
        for j in range(n):
            if i != j:
                # Using the number of 'relatively close' neighbors for degree estimation
                threshold = np.mean(distance_matrix[i,:])
                degree_i = np.sum(distance_matrix[i, :] < threshold)
                degree_j = np.sum(distance_matrix[j, :] < threshold)
                degree_penalty[i, j] = 1.0 / (degree_i * degree_j + 1e-6)

    # 3. Iterative Refinement (Shortest Path Consideration with Adaptive Scaling)
    shortest_path_bonus = np.zeros_like(distance_matrix, dtype=float)
    mean_distance = np.mean(distance_matrix)
    for i in range(n):
        for j in range(n):
            if i != j:
                shortest_path_bonus[i, j] = np.exp(-distance_matrix[i, j] / (0.5 * mean_distance))  # Favors shorter edges, more aggressive

    # Combine factors, adding more weight to shortest_path_bonus
    heuristics_matrix = node_proximity * degree_penalty * (shortest_path_bonus**2)

    # 4. Sparsification (Adaptive Thresholding)
    # Dynamically adjust the threshold based on the iteration
    threshold = np.percentile(heuristics_matrix[heuristics_matrix > 0], 50) # remove bottom 50%
    heuristics_matrix[heuristics_matrix < threshold] = 0

    # Add a small amount of noise to break symmetry and encourage exploration. Reduce noise scale.
    noise = np.random.normal(0, 0.005 * np.mean(heuristics_matrix[heuristics_matrix > 0]), size=heuristics_matrix.shape)
    heuristics_matrix = heuristics_matrix + noise
    heuristics_matrix[heuristics_matrix < 0] = 0  # Ensure no negative values after adding noise
    np.fill_diagonal(heuristics_matrix, 0) #remove self loops

    return heuristics_matrix
```
