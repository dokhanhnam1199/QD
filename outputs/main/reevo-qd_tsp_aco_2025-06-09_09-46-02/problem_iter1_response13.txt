```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic function for the Traveling Salesman Problem (TSP) based on distance,
    node degree, and sparsity.

    Args:
        distance_matrix (np.ndarray): A square matrix where element [i, j] represents
                                       the distance between node i and node j.

    Returns:
        np.ndarray: A matrix of the same shape as distance_matrix, representing
                    the prior indicator of including each edge in the solution.
    """

    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)

    # 1. Inverse Distance: Shorter distances are generally more promising.
    inverse_distance = 1.0 / (distance_matrix + 1e-9)  # Adding a small constant to avoid division by zero.

    # 2. Node Degree Penalty: Avoid edges that would lead to high-degree nodes early on.
    #    This encourages a more balanced exploration of the graph.

    degree_penalty = np.zeros_like(distance_matrix)
    for i in range(n):
        for j in range(n):
            if i != j:
                degree_penalty[i, j] = 1.0  # Initialize all edges as potential candidates.

    # 3. Combination & Normalization: Combine the factors and normalize to [0, 1].
    heuristics = inverse_distance * degree_penalty
    
    # Normalize
    max_val = np.max(heuristics)
    if max_val > 0:
        heuristics = heuristics / max_val

    # 4. Sparsification: Set unpromising edges to zero to encourage exploration.
    threshold = np.mean(heuristics[heuristics > 0]) * 0.2 # dynamic threshold
    heuristics[heuristics < threshold] = 0

    # remove diagonal elements for better performance, should be zero anyway.
    for i in range(n):
        heuristics[i, i] = 0.0

    return heuristics
```
