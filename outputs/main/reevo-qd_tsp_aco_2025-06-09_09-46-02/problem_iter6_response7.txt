```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic function for the Traveling Salesman Problem (TSP) based on stochastic solution sampling with improvements.

    This function refines the heuristics by incorporating node proximity, edge diversity, and shortest path considerations
    to enhance the exploration-exploitation balance in TSP solution sampling. It employs adaptive thresholds, geometric means,
    and dynamic temperature for improved performance.

    Args:
        distance_matrix (np.ndarray): A square matrix representing the distances between cities.
                                         distance_matrix[i][j] is the distance between city i and city j.

    Returns:
        np.ndarray: A matrix of the same shape as distance_matrix, where each element represents the
                      promise of including the corresponding edge in the TSP solution.
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

    # 1. Node Proximity (Inverse Distance with Adaptive Scaling)
    inverse_distance = 1 / (distance_matrix + 1e-6)
    mean_distance = np.mean(distance_matrix)
    proximity_factor = mean_distance / (distance_matrix + 1e-6)  # Scale based on average distance
    node_proximity = inverse_distance * proximity_factor

    # 2. Edge Diversity (Penalize High-Degree Nodes) with robust degree calculation
    degree_penalty = np.zeros_like(distance_matrix, dtype=float)
    for i in range(n):
        for j in range(n):
            if i != j:
                # Adaptive threshold for degree calculation using quantiles
                threshold_i = np.quantile(distance_matrix[i, :], 0.25)  # Lower quartile
                threshold_j = np.quantile(distance_matrix[j, :], 0.25)
                degree_i = np.sum(distance_matrix[i, :] < threshold_i)
                degree_j = np.sum(distance_matrix[j, :] < threshold_j)
                degree_penalty[i, j] = 1.0 / (np.sqrt(degree_i * degree_j) + 1e-6)  # Geometric mean

    # 3. Shortest Path Consideration with Adaptive Temperature
    shortest_path_bonus = np.zeros_like(distance_matrix, dtype=float)
    median_distance = np.median(distance_matrix)
    temperature = median_distance / 2.0  # Dynamic temperature based on median
    for i in range(n):
        for j in range(n):
            if i != j:
                shortest_path_bonus[i, j] = np.exp(-distance_matrix[i, j] / temperature)  # Favors shorter edges

    # Combine factors
    heuristics_matrix = node_proximity * degree_penalty * shortest_path_bonus

    # 4. Sparsification (Adaptive Thresholding) - More robust and aggressive
    threshold = np.percentile(heuristics_matrix[heuristics_matrix > 0], 50)  # Remove bottom 50%
    heuristics_matrix[heuristics_matrix < threshold] = 0

    # 5. Add Adaptive Noise
    noise_level = 0.001 * np.mean(heuristics_matrix[heuristics_matrix > 0]) # Reduce noise further
    noise = np.random.normal(0, noise_level, size=heuristics_matrix.shape)
    heuristics_matrix = heuristics_matrix + noise
    heuristics_matrix[heuristics_matrix < 0] = 0  # Ensure no negative values after adding noise

    return heuristics_matrix
```
