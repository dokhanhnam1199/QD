```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic function for the Traveling Salesman Problem (TSP) based on stochastic solution sampling with improvements.

    This function refines the heuristics by incorporating node proximity, edge diversity, and iterative refinement
    to enhance the exploration-exploitation balance in TSP solution sampling.

    Args:
        distance_matrix (np.ndarray): A square matrix representing the distances between cities.
                                         distance_matrix[i][j] is the distance between city i and city j.

    Returns:
        np.ndarray: A matrix of the same shape as distance_matrix, where each element represents the
                      promise of including the corresponding edge in the TSP solution.
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

    # 1. Node Proximity (Inverse Distance with Scaling)
    inverse_distance = 1 / (distance_matrix + 1e-6)
    proximity_factor = np.mean(distance_matrix) / (distance_matrix + 1e-6)  # Scale based on average distance
    node_proximity = inverse_distance * proximity_factor

    # 2. Edge Diversity (Penalize High-Degree Nodes) with improved degree calculation
    degree_penalty = np.zeros_like(distance_matrix, dtype=float)
    for i in range(n):
        for j in range(n):
            if i != j:
                # Adaptive threshold for degree calculation, use 2nd smallest distance as threshold
                distances_i = np.sort(distance_matrix[i, :])
                threshold_i = distances_i[1] if len(distances_i) > 1 else distances_i[0]
                distances_j = np.sort(distance_matrix[j, :])
                threshold_j = distances_j[1] if len(distances_j) > 1 else distances_j[0]

                degree_i = np.sum(distance_matrix[i, :] < threshold_i)
                degree_j = np.sum(distance_matrix[j, :] < threshold_j)
                degree_penalty[i, j] = 1.0 / (np.sqrt(degree_i * degree_j) + 1e-6)  # Geometric mean

    # 3. Shortest Path Consideration with Adaptive Scaling and dynamic temperature
    shortest_path_bonus = np.zeros_like(distance_matrix, dtype=float)
    mean_distance = np.mean(distance_matrix)
    temperature = mean_distance / 2.0  # Dynamic temperature
    for i in range(n):
        for j in range(n):
            if i != j:
                shortest_path_bonus[i, j] = np.exp(-distance_matrix[i, j] / temperature)  # Favors shorter edges

    # Combine factors
    heuristics_matrix = node_proximity * degree_penalty * shortest_path_bonus

    # 4. Sparsification (Adaptive Thresholding) - Refined sparsification
    # More aggressive sparsification in early iterations
    threshold_percentile = 50
    threshold = np.percentile(heuristics_matrix[heuristics_matrix > 0], threshold_percentile)  # remove bottom 50%
    heuristics_matrix[heuristics_matrix < threshold] = 0

    # Add noise, but scale it adaptively
    noise_level = 0.001 * np.mean(heuristics_matrix[heuristics_matrix > 0])  # Reduce noise
    noise = np.random.normal(0, noise_level, size=heuristics_matrix.shape)
    heuristics_matrix = heuristics_matrix + noise
    heuristics_matrix[heuristics_matrix < 0] = 0  # Ensure no negative values after adding noise

    # 5. Distance-based scaling
    distance_scaling = np.exp(-distance_matrix / mean_distance)
    heuristics_matrix = heuristics_matrix * distance_scaling

    # 6. Iterative Refinement (Enhanced local search influence)
    refinement_iterations = 2  # Increased iterations
    for _ in range(refinement_iterations):
        temp_matrix = heuristics_matrix.copy()
        for i in range(n):
            for j in range(n):
                if heuristics_matrix[i, j] > 0:
                    # Look at neighbors
                    neighbors = np.argsort(distance_matrix[i, :])[:5] # Consider 5 nearest neighbors

                    # Encourage connection to high-heuristic neighbors.
                    neighbor_bonus = 0
                    for neighbor in neighbors:
                         if i != neighbor and j!= neighbor:

                            neighbor_bonus += heuristics_matrix[i,neighbor] + heuristics_matrix[neighbor,j]
                    # Scale neighbor bonus by number of neighbours
                    neighbor_bonus = neighbor_bonus / len(neighbors) if len(neighbors) >0 else 0
                    temp_matrix[i, j] += 0.1 * neighbor_bonus  # Increase influence of neighbours
        heuristics_matrix = temp_matrix # Update

    # 7. Re-Sparsification with Dynamic Threshold Adjustment
    threshold_percentile -= 10  # Reduce threshold percentile each iterations
    threshold_percentile = max(threshold_percentile, 10)

    threshold = np.percentile(heuristics_matrix[heuristics_matrix > 0], threshold_percentile)  # remove bottom values
    heuristics_matrix[heuristics_matrix < threshold] = 0

    return heuristics_matrix
```
