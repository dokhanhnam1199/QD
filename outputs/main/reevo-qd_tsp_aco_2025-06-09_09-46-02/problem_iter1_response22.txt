```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic function for the Traveling Salesman Problem (TSP).

    This version combines several factors to estimate the desirability of each edge:
    - Inverse distance: Shorter edges are preferred.
    - Node degree equalization: Edges connecting to nodes with fewer connections are preferred.
    - Sparsification: Unpromising edges (long edges connecting well-connected nodes) are zeroed out.
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # 1. Inverse distance component (prioritizes shorter edges)
    inverse_distance = 1 / (distance_matrix + 1e-9)  # Add a small constant to avoid division by zero

    # 2. Node degree equalization component (encourages exploration of less-visited nodes)
    degree = np.zeros(n)
    for i in range(n):
        for j in range(n):
            if distance_matrix[i, j] > 0:
                degree[i] += 1  # simple degree, count the number of possible connections

    degree_matrix = np.zeros_like(distance_matrix, dtype=float)

    for i in range(n):
      for j in range(n):
        degree_matrix[i,j] = 1/(degree[i] * degree[j] + 1e-9)


    # Combine components
    heuristic_matrix = inverse_distance * degree_matrix

    # 3. Sparsification (zero out unpromising edges)
    # Identify high-degree nodes and penalize long edges connected to them.
    degree_threshold = np.percentile(degree, 75) # Only sparsify among top 25% highest-degree nodes

    distance_threshold = np.percentile(distance_matrix[distance_matrix > 0], 75)  # Threshold on distance, 75 percentile
    for i in range(n):
      for j in range(n):
        # Sparsify only if either end nodes are highly connected
        if (degree[i] >= degree_threshold or degree[j] >= degree_threshold) and distance_matrix[i,j] > distance_threshold:
          heuristic_matrix[i, j] = 0.0 # Zero it out



    return heuristic_matrix
```
