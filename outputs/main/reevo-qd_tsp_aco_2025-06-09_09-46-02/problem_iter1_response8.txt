```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic function for TSP using a combination of factors:
    - Inverse distance
    - Node degree (prioritizes edges connected to nodes with few connections)
    - Closeness centrality (prioritizes edges connecting to central nodes)
    - Sparsification (removes edges considered very unpromising)
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # 1. Inverse Distance: Shorter distances are generally better
    inverse_distance = 1 / (distance_matrix + 1e-9)  # Add a small value to avoid division by zero

    # 2. Node Degree: Prioritize edges connected to nodes with fewer connections.
    #    This helps to ensure that all nodes are visited without leaving isolated nodes.
    degree = np.sum(distance_matrix > 0, axis=0)  # Count neighbors for each node
    degree_factor = np.zeros_like(distance_matrix, dtype=float)
    for i in range(n):
        for j in range(n):
            if i != j:
                degree_factor[i, j] = (1 / (degree[i] + degree[j] + 1e-9)) # Avoid div by zero
                
    # 3. Closeness Centrality: Promote edges towards the "center" of the graph
    #    based on the idea that optimal tours may pass through the middle.

    # Use inverse distance as a proxy for adjacency matrix to compute the shortest path length.
    # Replace zero values with a large number (e.g., sum of all distances) to indicate no connection.
    adj_matrix = np.where(distance_matrix > 0, distance_matrix, np.inf)
    
    closeness = np.zeros(n)
    for i in range(n):
        distances = np.zeros(n)

        # Dijkstra's Algorithm to find shortest paths from node i to all other nodes
        visited = [False] * n
        dist = [np.inf] * n
        dist[i] = 0

        for _ in range(n):
            # Find the unvisited node with the smallest distance
            min_dist = np.inf
            u = -1
            for v in range(n):
                if not visited[v] and dist[v] < min_dist:
                    min_dist = dist[v]
                    u = v

            if u == -1:
                break  # All reachable nodes have been visited

            visited[u] = True
            for v in range(n):
                if adj_matrix[u, v] != np.inf and dist[u] + adj_matrix[u, v] < dist[v]:
                    dist[v] = dist[u] + adj_matrix[u, v]
        
        closeness[i] = np.sum(dist) # Sum shortest path distances from i to all other nodes

    closeness_factor = np.zeros_like(distance_matrix, dtype=float)
    for i in range(n):
        for j in range(n):
            if i != j:
                closeness_factor[i, j] = 1/(closeness[i] + closeness[j] + 1e-9)

    # Combine Factors
    heuristic_matrix = inverse_distance * degree_factor * closeness_factor

    # 4. Sparsification: Set low-value edges to zero to reduce the search space
    threshold = np.quantile(heuristic_matrix[distance_matrix > 0], 0.2) # Keep top 80% edges by heuristic value
    heuristic_matrix[heuristic_matrix < threshold] = 0
    heuristic_matrix[distance_matrix == 0] = 0 #Ensure zero distances stays zero (e.g. i==j)
    
    return heuristic_matrix
```
