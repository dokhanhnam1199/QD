```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic function for TSP based on a combination of factors and sparsification.

    Args:
        distance_matrix (np.ndarray): A 2D numpy array representing the distance matrix.

    Returns:
        np.ndarray: A 2D numpy array of the same shape as distance_matrix,
                     representing the heuristic values for each edge. Higher values
                     indicate a more promising edge.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # Calculate the mean distance for each node to all other nodes
    node_mean_distances = np.mean(distance_matrix, axis=1, keepdims=True) + np.mean(distance_matrix, axis=0, keepdims=True)
    node_mean_distances = (node_mean_distances / 2) # averaging

    # Normalize distances: closer distances are better
    normalized_distances = 1 / (distance_matrix + 1e-9)  # Avoid division by zero

    # Combine factors:  Inverse distance + node desirability
    heuristic_matrix = normalized_distances / (node_mean_distances + 1e-9)

    # Sparsification: zero out elements that are too far away.
    # Keep only edges shorter than X * mean distance

    mean_distance = np.mean(distance_matrix)
    sparsification_threshold = 2.0  # Adjust this value, to control the percentage of kept elements. Higher: more connections
    heuristic_matrix[distance_matrix > sparsification_threshold * mean_distance] = 0

    # Add some randomness to break symmetries. This is more crucial in stochastic algorithms.
    random_influence = 0.001  # Adjust, to determine the random_influence. Smaller: keeps heuristic's form
    heuristic_matrix += random_influence * np.random.rand(n, n)
    return heuristic_matrix
```
