```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic function for the Traveling Salesman Problem (TSP) based on stochastic solution sampling with further improvements.

    This function builds upon previous versions by refining node proximity, edge diversity, and iterative refinement
    to enhance the exploration-exploitation balance in TSP solution sampling. It incorporates adaptive parameters
    and considers second-order neighbor information.

    Args:
        distance_matrix (np.ndarray): A square matrix representing the distances between cities.
                                         distance_matrix[i][j] is the distance between city i and city j.

    Returns:
        np.ndarray: A matrix of the same shape as distance_matrix, where each element represents the
                      promise of including the corresponding edge in the TSP solution.
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

    # 1. Enhanced Node Proximity (Adaptive Scaling and Distance Adjustment)
    inverse_distance = 1 / (distance_matrix + 1e-6)
    mean_distance = np.mean(distance_matrix)
    proximity_factor = mean_distance / (distance_matrix + 1e-6)  # Scale based on average distance
    node_proximity = inverse_distance * proximity_factor

    # 2. Refined Edge Diversity (Penalize High-Degree Nodes with Adaptive Threshold)
    degree_penalty = np.zeros_like(distance_matrix, dtype=float)
    for i in range(n):
        for j in range(n):
            if i != j:
                # Adaptive threshold for 'relatively close' neighbors
                threshold_i = np.mean(distance_matrix[i, :])
                threshold_j = np.mean(distance_matrix[j, :])
                degree_i = np.sum(distance_matrix[i, :] < threshold_i)
                degree_j = np.sum(distance_matrix[j, :] < threshold_j)
                degree_penalty[i, j] = 1.0 / (degree_i * degree_j + 1e-6)

    # 3. Shortest Path Consideration with Adaptive Scaling
    shortest_path_bonus = np.zeros_like(distance_matrix, dtype=float)

    for i in range(n):
        for j in range(n):
            if i != j:
                shortest_path_bonus[i, j] = np.exp(-distance_matrix[i, j] / mean_distance)  # Favors shorter edges

    # Combine factors
    heuristics_matrix = node_proximity * degree_penalty * shortest_path_bonus

    # 4. Sparsification (Adaptive Thresholding)
    threshold = np.percentile(heuristics_matrix[heuristics_matrix > 0], 25)
    heuristics_matrix[heuristics_matrix < threshold] = 0

    # Add a small amount of noise to break symmetry and encourage exploration.  Scale noise adaptively
    noise_scale = 0.01 * np.mean(heuristics_matrix[heuristics_matrix > 0]) if np.any(heuristics_matrix > 0) else 0.01
    noise = np.random.normal(0, noise_scale, size=heuristics_matrix.shape)
    heuristics_matrix = heuristics_matrix + noise
    heuristics_matrix[heuristics_matrix < 0] = 0  # Ensure no negative values after adding noise

    return heuristics_matrix
```
