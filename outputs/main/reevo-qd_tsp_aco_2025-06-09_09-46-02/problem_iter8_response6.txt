```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic function for the Traveling Salesman Problem (TSP) based on stochastic solution sampling with improvements.

    This function refines the heuristics by incorporating node proximity, edge diversity, and iterative refinement
    to enhance the exploration-exploitation balance in TSP solution sampling.

    Args:
        distance_matrix (np.ndarray): A square matrix representing the distances between cities.
                                         distance_matrix[i][j] is the distance between city i and city j.

    Returns:
        np.ndarray: A matrix of the same shape as distance_matrix, where each element represents the
                      promise of including the corresponding edge in the TSP solution.
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

    # 1. Node Proximity (Inverse Distance with Scaling)
    inverse_distance = 1 / (distance_matrix + 1e-6)
    proximity_factor = np.mean(distance_matrix) / (distance_matrix + 1e-6)  # Scale based on average distance
    node_proximity = inverse_distance * proximity_factor

    # 2. Edge Diversity (Penalize High-Degree Nodes) with improved degree calculation
    degree_penalty = np.zeros_like(distance_matrix, dtype=float)
    for i in range(n):
        for j in range(n):
            if i != j:
                # Adaptive threshold for degree calculation using quantiles
                threshold_i = np.quantile(distance_matrix[i,:], 0.25)  # 25th percentile
                threshold_j = np.quantile(distance_matrix[j,:], 0.25)
                degree_i = np.sum(distance_matrix[i, :] < threshold_i)
                degree_j = np.sum(distance_matrix[j, :] < threshold_j)
                degree_penalty[i, j] = 1.0 / (np.sqrt(degree_i * degree_j) + 1e-6)  # Geometric mean

    # 3. Shortest Path Consideration with Adaptive Scaling and dynamic temperature
    shortest_path_bonus = np.zeros_like(distance_matrix, dtype=float)
    mean_distance = np.mean(distance_matrix)
    temperature = np.median(distance_matrix) / 1.5  # Dynamic temperature based on median
    for i in range(n):
        for j in range(n):
            if i != j:
                shortest_path_bonus[i, j] = np.exp(-distance_matrix[i, j] / temperature)  # Favors shorter edges

    # Combine factors
    heuristics_matrix = node_proximity * degree_penalty * shortest_path_bonus

    # 4. Sparsification (Adaptive Thresholding) - Refined sparsification
    # More aggressive sparsification, adaptive percentile
    sparsification_percentile = 35 # remove bottom percentile
    threshold = np.percentile(heuristics_matrix[heuristics_matrix > 0], sparsification_percentile)
    heuristics_matrix[heuristics_matrix < threshold] = 0

    # Add noise, but scale it adaptively
    noise_level = 0.004 * np.mean(heuristics_matrix[heuristics_matrix > 0])  # Further reduced noise
    noise = np.random.normal(0, noise_level, size=heuristics_matrix.shape)
    heuristics_matrix = heuristics_matrix + noise
    heuristics_matrix[heuristics_matrix < 0] = 0  # Ensure no negative values after adding noise

    # Additional Refinement: Enhance promising edges
    mean_heuristic = np.mean(heuristics_matrix[heuristics_matrix > 0]) if np.any(heuristics_matrix > 0) else 0
    heuristics_matrix[heuristics_matrix > mean_heuristic] *= 1.1 # Boost above mean

    return heuristics_matrix
```
