```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic function for the Traveling Salesman Problem (TSP) using a combination of factors.

    This heuristic considers distance, node degree (preference for edges connected to nodes with fewer connections),
    and global average distance to estimate the likelihood of an edge being part of an optimal TSP solution.
    It also sparsifies the matrix by setting elements below a threshold to zero.

    Args:
        distance_matrix (np.ndarray): A square matrix representing the distances between nodes.

    Returns:
        np.ndarray: A matrix of the same shape as distance_matrix, representing the heuristic values
                      for each edge. Higher values indicate a higher likelihood of the edge being
                      part of the optimal TSP solution.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # Calculate the average distance for normalization
    avg_distance = np.mean(distance_matrix[distance_matrix != 0])  # Avoid including zero distances in the mean

    # Calculate node degree preference.  Initialize to zero;
    # will compute based on heuristic matrix as we construct it.
    degree_preference = np.zeros((n,n))

    # Distance factor: inversely proportional to distance
    distance_factor = avg_distance / distance_matrix
    distance_factor[np.isinf(distance_factor)] = 0  # Handle potential division by zero

    # Combine factors to form the heuristic matrix
    heuristic_matrix = distance_factor # Initial heuristic.  Now we'll refine it based on degree

    # Degree preference:  Bias toward edges connected to nodes with low degree
    for i in range(n):
        for j in range(n):
            if i != j:  # Exclude self-loops
                # Approximation of "degree" based on other edges connected *that are also promising*:
                degree_i = np.sum(heuristic_matrix[i,:])
                degree_j = np.sum(heuristic_matrix[j,:])

                # Simple implementation; favor lower degree connections
                degree_preference[i, j] =  np.sqrt(1.0 / ((1+degree_i)*(1+degree_j))) #Avoid divide by zero and scale

    heuristic_matrix = heuristic_matrix * degree_preference
    # Sparsification: zero out edges with low heuristic values to encourage more directed sampling
    threshold = np.quantile(heuristic_matrix[heuristic_matrix > 0], 0.25) # Dynamic threshold

    heuristic_matrix[heuristic_matrix < threshold] = 0 # setting unpromising element to zero.

    # Normalize the heuristic matrix so its values all stay relatively close to 1
    heuristic_matrix = heuristic_matrix / np.mean(heuristic_matrix[heuristic_matrix > 0])

    return heuristic_matrix
```
