```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic function for the Traveling Salesman Problem (TSP).

    This version combines several factors to estimate the desirability of including each edge
    in the optimal TSP tour. It considers distance, node degree, and a simple "gravity" model
    to encourage connections between nodes in different regions.  It also sparsifies the matrix
    by zeroing out very large distances.

    Args:
        distance_matrix (np.ndarray): A square matrix representing the distances between cities.
                                       distance_matrix[i, j] is the distance between city i and city j.

    Returns:
        np.ndarray: A matrix of the same shape as distance_matrix, where each element
                      represents the desirability of including the corresponding edge in the TSP tour.
                      Higher values indicate more promising edges.
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix, dtype=float)

    # Inverse of distance
    inverse_distance = 1.0 / (distance_matrix + 1e-9)  # Add small value to avoid division by zero

    # Node degree penalty (discourage high-degree nodes early on)
    degree_penalty = np.ones_like(distance_matrix, dtype=float)
    for i in range(n):
        for j in range(n):
             degree_penalty[i,j] = 1 # no longer applicable during edge weighting.


    # "Gravity" model: encourage connections between disparate regions
    # (helps escape local optima)
    x = np.arange(n)
    center = np.mean(x)
    gravity = np.outer(np.exp(-((x - center)**2) / (2 * (n / 4)**2)), np.exp(-((x - center)**2) / (2 * (n / 4)**2)))

    # Combine factors: distance, degree, and gravity.  Adjust weights as needed.
    heuristics = (0.7 * inverse_distance + 0.1 * degree_penalty + 0.2 * gravity)

    # Sparsify: set unpromising elements (large distances) to zero
    threshold = np.quantile(distance_matrix[distance_matrix > 0], 0.9)  # Use 90th percentile as cutoff
    heuristics[distance_matrix > threshold] = 0.0

    # Zero out the diagonal to avoid self-loops
    np.fill_diagonal(heuristics, 0.0)

    return heuristics
```
