```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic function for the Traveling Salesman Problem (TSP).
    Combines distance, node degree, and sparsification to estimate edge importance.

    Args:
        distance_matrix (np.ndarray): A square matrix representing the distances between nodes.

    Returns:
        np.ndarray: A matrix of the same shape as distance_matrix,
                      representing the heuristic value (probability) of each edge.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # 1. Inverse distance (shorter edges are better)
    inverse_distance = 1.0 / (distance_matrix + 1e-9)  # Add a small value to avoid division by zero

    # 2. Node degree desirability (avoid nodes with too high a degree early on).
    #    Initially, all nodes are considered "free."  As the TSP solution evolves,
    #    we will conceptually penalize choosing edges connected to high-degree nodes
    #    by lowering the edge weights adjacent to nodes that have degree approaching 2.
    #
    # We don't have solution evolution here, so we create a proxy node_degree_desirability
    # which penalizes edges connecting to nodes that are far from other nodes. This encourages connecting
    # to central nodes early on.
    node_centrality = np.sum(inverse_distance, axis=0)  # Sum of inverse distances (higher = more central)
    node_degree_desirability = node_centrality / np.max(node_centrality)
    degree_factor_matrix = np.outer(node_degree_desirability, node_degree_desirability) # Outer product

    # 3. Sparsification: Keep only the k-nearest neighbors for each node.
    k = int(np.sqrt(n)) # Adjust k as needed
    for i in range(n):
        # Find the k-nearest neighbors of node i.
        neighbors = np.argsort(distance_matrix[i, :])[1:k + 1] # Exclude self, get indices of k smallest distances.
        # Set the heuristic value to zero for all edges not connected to the k-nearest neighbors.
        for j in range(n):
            if j not in neighbors and i != j:  #Excludes self loops.
                heuristic_matrix[i, j] = 0.0 # Ensures zero connections outside neighbours in sparse approach.
            else:
                 heuristic_matrix[i, j] = inverse_distance[i, j] * degree_factor_matrix[i, j] #Combines factors and keeps non zero connections within neighbours.

    #Normalize rows.
    for i in range(n):
        row_sum = np.sum(heuristic_matrix[i,:])
        if row_sum > 0: #Handles nodes that are isolate after sparsification.
            heuristic_matrix[i,:] /= row_sum

    # Ensure symmetry.
    heuristic_matrix = (heuristic_matrix + heuristic_matrix.T) / 2.0

    return heuristic_matrix
```
