```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic function for the Traveling Salesman Problem (TSP) based on stochastic solution sampling with improvements.

    This function refines the heuristics by incorporating node proximity, edge diversity, and iterative refinement
    to enhance the exploration-exploitation balance in TSP solution sampling.

    Args:
        distance_matrix (np.ndarray): A square matrix representing the distances between cities.
                                         distance_matrix[i][j] is the distance between city i and city j.

    Returns:
        np.ndarray: A matrix of the same shape as distance_matrix, where each element represents the
                      promise of including the corresponding edge in the TSP solution.
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

    # 1. Node Proximity (Inverse Distance with Adaptive Scaling)
    inverse_distance = 1 / (distance_matrix + 1e-6)
    mean_dist = np.mean(distance_matrix)
    proximity_factor = mean_dist / (distance_matrix + 1e-6)
    node_proximity = inverse_distance * proximity_factor

    # 2. Edge Diversity (Penalize High-Degree Nodes) with improved degree calculation and local neighborhood
    degree_penalty = np.zeros_like(distance_matrix, dtype=float)
    neighborhood_size = min(5, n - 1)  # Local neighborhood for degree calculation
    for i in range(n):
        # Find the nearest neighbors of node i
        nearest_neighbors_i = np.argsort(distance_matrix[i, :])[1:neighborhood_size+1] # Exclude self
        for j in range(n):
            if i != j:
                # Adaptive threshold for degree calculation
                threshold_i = np.median(distance_matrix[i, nearest_neighbors_i])  # Use median for robustness
                # Count neighbors within the threshold for i
                degree_i = np.sum(distance_matrix[i, nearest_neighbors_i] < threshold_i)
                # Handle node j to calculate degree_j
                nearest_neighbors_j = np.argsort(distance_matrix[j, :])[1:neighborhood_size+1]
                threshold_j = np.median(distance_matrix[j, nearest_neighbors_j])
                degree_j = np.sum(distance_matrix[j, nearest_neighbors_j] < threshold_j)
                degree_penalty[i, j] = 1.0 / (np.sqrt(degree_i * degree_j) + 1e-6)  # Geometric mean

    # 3. Shortest Path Consideration with Adaptive Scaling and dynamic temperature
    shortest_path_bonus = np.zeros_like(distance_matrix, dtype=float)
    temperature = mean_dist / 2.0  # Dynamic temperature
    for i in range(n):
        for j in range(n):
            if i != j:
                shortest_path_bonus[i, j] = np.exp(-distance_matrix[i, j] / temperature)  # Favors shorter edges

    # Combine factors with weighted sum
    alpha = 0.5
    beta = 0.3
    gamma = 0.2
    heuristics_matrix = alpha * node_proximity + beta * degree_penalty + gamma * shortest_path_bonus

    # 4. Sparsification (Adaptive Thresholding) - Refined sparsification
    threshold = np.percentile(heuristics_matrix[heuristics_matrix > 0], 60)  # More aggressive sparsification
    heuristics_matrix[heuristics_matrix < threshold] = 0

    # Add noise with adaptive scaling and reduced magnitude
    noise_level = 0.001 * np.mean(heuristics_matrix[heuristics_matrix > 0])  # Even smaller noise
    noise = np.random.normal(0, noise_level, size=heuristics_matrix.shape)
    heuristics_matrix = heuristics_matrix + noise
    heuristics_matrix[heuristics_matrix < 0] = 0  # Ensure no negative values after adding noise

    return heuristics_matrix
```
