```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristics for TSP based on distance, node degree, and edge consistency.

    Args:
        distance_matrix: A numpy array representing the distance matrix between nodes.

    Returns:
        A numpy array of the same shape as distance_matrix,
        representing the prior indicators of how promising it is to include each edge in a solution.
    """

    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix, dtype=float)

    # Inverse distance
    inverse_distance = 1 / (distance_matrix + 1e-9)  # Avoid division by zero

    # Node degree desirability (prefer nodes with high inverse distance sums)
    node_desirability = np.sum(inverse_distance, axis=0)
    node_desirability = (node_desirability - np.min(node_desirability)) / (np.max(node_desirability) - np.min(node_desirability) + 1e-9) # Normalize 0-1

    for i in range(n):
        for j in range(n):
            if i != j:
                # Combine inverse distance and node desirabilities
                heuristics[i, j] = inverse_distance[i, j] * (node_desirability[i] + node_desirability[j])

    # Edge consistency (favor edges that are part of a "smooth" path)
    for i in range(n):
        for j in range(n):
            if i != j:
                # Find the nearest neighbors of i and j (excluding each other)
                neighbors_i = np.argsort(distance_matrix[i, :])[:4]  # Top 3 nearest neighbors
                neighbors_j = np.argsort(distance_matrix[j, :])[:4]
                neighbors_i = [k for k in neighbors_i if k != j]
                neighbors_j = [k for k in neighbors_j if k != i]

                consistency = 0
                for neighbor_i in neighbors_i:
                  if neighbor_i != i and neighbor_i !=j:
                    consistency += inverse_distance[i, neighbor_i]
                for neighbor_j in neighbors_j:
                  if neighbor_j != j and neighbor_j != i:
                    consistency += inverse_distance[j, neighbor_j]

                heuristics[i, j] += 0.2 * consistency

    # Normalize the heuristics
    max_h = np.max(heuristics)
    min_h = np.min(heuristics)
    if max_h > min_h:
      heuristics = (heuristics - min_h) / (max_h - min_h)
    else:
      heuristics = np.ones_like(heuristics) # If everything is the same

    # Sparsify the matrix (optional: set unpromising elements to zero)
    threshold = np.quantile(heuristics[heuristics > 0], 0.2)  # Keep top 80%
    heuristics[heuristics < threshold] = 0

    return heuristics
```
