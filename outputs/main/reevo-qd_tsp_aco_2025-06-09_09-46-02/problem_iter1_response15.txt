```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristics function for solving Traveling Salesman Problem (TSP) via stochastic solution sampling.
    Combines several factors to determine how promising it is to select an edge, including:

    1.  Inverse Distance:  Shorter distances are generally more desirable.
    2.  Nearest Neighbor: Edges connecting a node to its nearest neighbors are prioritized.
    3.  Avoid Long Edges: Penalizes excessively long edges relative to the average distance.

    The function sparsifies the matrix by setting unpromising elements to zero.

    Args:
        distance_matrix (np.ndarray): A square matrix representing the distances between nodes.

    Returns:
        np.ndarray: A matrix of the same shape as distance_matrix, representing prior indicators
                      of how promising it is to include each edge in a solution. Higher values
                      indicate more promising edges.
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # 1. Inverse Distance:
    inverse_distance = 1 / (distance_matrix + 1e-6)  # Add a small constant to avoid division by zero

    # 2. Nearest Neighbor:
    nearest_neighbors = np.zeros_like(distance_matrix, dtype=float)
    for i in range(n):
        sorted_indices = np.argsort(distance_matrix[i, :])
        # Consider the k nearest neighbors (excluding the node itself)
        k = min(5, n - 1)  # Number of nearest neighbors to consider (adjust as needed)

        for j in sorted_indices[1:k + 1]:  # Exclude the node itself (index 0)
            nearest_neighbors[i, j] = 1
    
    # make the matrix symmetric
    nearest_neighbors = np.maximum(nearest_neighbors, nearest_neighbors.T)

    # 3. Avoid Long Edges (Relative to Average Distance):
    average_distance = np.mean(distance_matrix)
    long_edge_penalty = np.where(distance_matrix > 2 * average_distance, 0.1, 1.0)  # Penalize edges significantly longer than average

    # Combine the factors:
    heuristic_matrix = inverse_distance * nearest_neighbors * long_edge_penalty

    # Sparsify the matrix (set unpromising elements to zero):
    threshold = np.quantile(heuristic_matrix[heuristic_matrix > 0], 0.2)  # Keep the top 80% (adjust as needed)
    heuristic_matrix[heuristic_matrix < threshold] = 0
    
    #Ensure no inf values in the matrix to avoid runtime errors.
    heuristic_matrix[np.isinf(heuristic_matrix)] = 0

    return heuristic_matrix
```
