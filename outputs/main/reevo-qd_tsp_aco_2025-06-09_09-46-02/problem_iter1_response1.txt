```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic function for TSP based on stochastic solution sampling principles.

    This version combines several factors to determine the desirability of including each edge
    in the solution, and sparsifies the matrix.

    Args:
        distance_matrix (np.ndarray): The distance matrix representing the distances
                                       between cities.

    Returns:
        np.ndarray: A heuristic matrix of the same shape as the distance matrix,
                    indicating how promising it is to include each edge in a solution.
                    Higher values indicate a more promising edge.  Unpromising edges are set to zero.
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # 1. Inverse distance (shorter distances are preferred)
    inverse_distance = 1 / (distance_matrix + 1e-9)  # Add a small constant to avoid division by zero

    # 2. Nearest neighbor desirability: Prioritize edges that connect to nodes with overall shorter distance to other nodes.
    nearest_neighbor_score = np.zeros_like(distance_matrix, dtype=float)
    for i in range(n):
        for j in range(n):
            if i != j:
                nearest_neighbor_score[i, j] = (1 / (np.sum(distance_matrix[i,:]) + np.sum(distance_matrix[:,j]) + 1e-9))

    # 3.  Degree penalty:  Penalize edges connecting nodes that already have many close neighbors.

    # Calculate nearest neighbors for each node (excluding itself)
    nearest_neighbors = []
    for i in range(n):
        distances = distance_matrix[i, :]
        neighbors = np.argsort(distances)[1:]  # Exclude the node itself
        nearest_neighbors.append(neighbors)
    
    degree_penalty = np.zeros_like(distance_matrix, dtype=float)
    for i in range(n):
        for j in range(n):
            if i!=j:
                # Penalty is higher if i and j both have many near neighbours
                degree_penalty[i, j] = 1.0 / (len(nearest_neighbors[i]) + len(nearest_neighbors[j]) + 1e-9)


    # Combine the factors: weighted sum
    heuristic_matrix = (0.6 * inverse_distance + 0.3 * nearest_neighbor_score + 0.1 * degree_penalty)


    # Sparsify the matrix:  Zero out edges that are unlikely to be in a good solution.
    # Option 1: Keep only the k nearest neighbors for each node
    k = int(np.sqrt(n)) # Adjust k dynamically
    for i in range(n):
        row = heuristic_matrix[i, :]
        indices = np.argsort(row)[::-1]  # Indices sorted in descending order
        keep_indices = indices[:k]
        heuristic_matrix[i, :] = 0
        heuristic_matrix[i, keep_indices] = row[keep_indices]


    return heuristic_matrix
```
