```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic function for the Traveling Salesman Problem (TSP) based on stochastic solution sampling with improvements.

    This function refines the heuristics by incorporating node proximity, edge diversity, and iterative refinement
    to enhance the exploration-exploitation balance in TSP solution sampling.

    Args:
        distance_matrix (np.ndarray): A square matrix representing the distances between cities.
                                         distance_matrix[i][j] is the distance between city i and city j.

    Returns:
        np.ndarray: A matrix of the same shape as distance_matrix, where each element represents the
                      promise of including the corresponding edge in the TSP solution.
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

    # 1. Node Proximity (Inverse Distance with Scaling)
    inverse_distance = 1 / (distance_matrix + 1e-6)
    proximity_factor = np.mean(distance_matrix) / (distance_matrix + 1e-6)  # Scale based on average distance
    node_proximity = inverse_distance * proximity_factor

    # 2. Edge Diversity (Penalize High-Degree Nodes) - Adjusted degree penalty
    degree_penalty = np.zeros_like(distance_matrix, dtype=float)
    for i in range(n):
        for j in range(n):
            if i != j:
                # Using the number of 'relatively close' neighbors for degree estimation
                threshold_i = np.mean(distance_matrix[i,:])
                threshold_j = np.mean(distance_matrix[j,:])
                degree_i = np.sum(distance_matrix[i, :] < threshold_i)
                degree_j = np.sum(distance_matrix[j, :] < threshold_j)
                degree_penalty[i, j] = 1.0 / (np.sqrt(degree_i * degree_j) + 1e-6)  # Reduced penalty

    # 3. Shortest Path Consideration (Adaptive Scaling) - More aggressive bonus
    shortest_path_bonus = np.zeros_like(distance_matrix, dtype=float)
    mean_distance = np.mean(distance_matrix)
    for i in range(n):
        for j in range(n):
            if i != j:
                shortest_path_bonus[i, j] = np.exp(-2 * distance_matrix[i, j] / mean_distance)  # Stronger preference for shorter edges

    # 4. Connectivity Prior (Encourage edges that connect disparate regions)
    connectivity_bonus = np.zeros_like(distance_matrix, dtype=float)
    for i in range(n):
        for j in range(n):
             if i != j:
                # Check for indirect connections. Penalize if two nodes have many common close neighbors.
                num_common_neighbors = 0
                threshold_i = np.mean(distance_matrix[i,:])
                threshold_j = np.mean(distance_matrix[j,:])

                neighbors_i = np.where(distance_matrix[i, :] < threshold_i)[0]
                neighbors_j = np.where(distance_matrix[j, :] < threshold_j)[0]

                num_common_neighbors = len(np.intersect1d(neighbors_i, neighbors_j))
                connectivity_bonus[i,j] = 1.0 / (num_common_neighbors + 1) # If they share many close neighbors, it's less desirable

    # Combine factors (Adjusted Weights)
    heuristics_matrix = (0.5 * node_proximity +
                         0.2 * degree_penalty +
                         0.4 * shortest_path_bonus +
                         0.1 * connectivity_bonus)

    # 5. Sparsification (Adaptive Thresholding)
    threshold = np.percentile(heuristics_matrix[heuristics_matrix > 0], 30)  #remove bottom 30%
    heuristics_matrix[heuristics_matrix < threshold] = 0

    # Add a small amount of noise to break symmetry and encourage exploration.
    noise = np.random.normal(0, 0.01 * np.mean(heuristics_matrix[heuristics_matrix > 0]), size=heuristics_matrix.shape)
    heuristics_matrix = heuristics_matrix + noise
    heuristics_matrix[heuristics_matrix < 0] = 0 # Ensure no negative values

    return heuristics_matrix
```
