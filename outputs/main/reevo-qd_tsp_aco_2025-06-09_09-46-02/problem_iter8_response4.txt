```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic function for the Traveling Salesman Problem (TSP) based on stochastic solution sampling with improvements.

    This function refines the heuristics by incorporating node degree, shortest paths, sparsification, and adaptive scaling
    to improve exploration-exploitation balance in TSP solution sampling.

    Args:
        distance_matrix (np.ndarray): A square matrix representing the distances between cities.
                                         distance_matrix[i][j] is the distance between city i and city j.

    Returns:
        np.ndarray: A matrix of the same shape as distance_matrix, where each element represents the
                      promise of including the corresponding edge in the TSP solution.
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

    # 1. Node Degree (Penalize High-Degree Nodes) - Refined degree calculation
    degree_penalty = np.zeros_like(distance_matrix, dtype=float)
    avg_dist = np.mean(distance_matrix)
    for i in range(n):
        for j in range(n):
            if i != j:
                # Adaptive threshold for degree calculation, row and column-wise
                threshold_row = np.median(distance_matrix[i, :])
                threshold_col = np.median(distance_matrix[:, j])

                degree_i = np.sum(distance_matrix[i, :] < threshold_row) # count edges shorter than threshold_row
                degree_j = np.sum(distance_matrix[:, j] < threshold_col) # count edges shorter than threshold_col
                degree_penalty[i, j] = 1.0 / (np.sqrt(degree_i * degree_j) + 1e-6) # penalize higher degree nodes

    # 2. Shortest Path Consideration with Adaptive Scaling and Temperature
    shortest_path_bonus = np.zeros_like(distance_matrix, dtype=float)
    temperature = avg_dist / 2.0  # Dynamic temperature
    for i in range(n):
        for j in range(n):
            if i != j:
                shortest_path_bonus[i, j] = np.exp(-distance_matrix[i, j] / temperature)  # favor shorter edges

    # 3. Initial Heuristic Combination (Node Degree & Shortest Path)
    heuristics_matrix = degree_penalty * shortest_path_bonus

    # 4. Sparsification (Adaptive Thresholding) - Adjust percentile based on matrix density
    non_zero_percentage = np.count_nonzero(heuristics_matrix) / heuristics_matrix.size
    percentile = 50 - (non_zero_percentage * 40) # denser, then sparser, 50% -> 10%

    threshold = np.percentile(heuristics_matrix[heuristics_matrix > 0], percentile)
    heuristics_matrix[heuristics_matrix < threshold] = 0

    # 5. Adaptive Noise Injection
    noise_level = 0.01 * np.mean(heuristics_matrix[heuristics_matrix > 0])  # adaptive noise level
    noise = np.random.normal(0, noise_level, size=heuristics_matrix.shape)
    heuristics_matrix = heuristics_matrix + noise
    heuristics_matrix[heuristics_matrix < 0] = 0

    return heuristics_matrix
```
