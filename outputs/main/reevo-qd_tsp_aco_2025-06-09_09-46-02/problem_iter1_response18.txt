```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic function for the Traveling Salesman Problem (TSP) that combines
    multiple factors to determine the desirability of including each edge in a solution.

    This version incorporates:
    1. Inverse distance: Shorter distances are generally more desirable.
    2. Nearest neighbor: Edges connecting nodes to their nearest neighbors are prioritized.
    3. Sparsification: Edges with extremely long distances are heavily penalized (set to near zero).
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix, dtype=float)

    # 1. Inverse Distance
    inverse_distance = 1 / (distance_matrix + 1e-9)  # Adding a small constant to avoid division by zero

    # 2. Nearest Neighbor
    nearest_neighbor_bonus = np.zeros_like(distance_matrix, dtype=float)
    for i in range(n):
        sorted_indices = np.argsort(distance_matrix[i, :])
        nearest_neighbors = sorted_indices[1:4]  # Consider the 3 nearest neighbors (excluding itself)
        for j in nearest_neighbors:
            nearest_neighbor_bonus[i, j] = 1.0
            nearest_neighbor_bonus[j, i] = 1.0 #ensure symmetry

    # 3. Sparsification based on distance quantile
    distance_threshold = np.quantile(distance_matrix[distance_matrix > 0], 0.75)  #consider only distances > 0
    sparsification_penalty = np.where(distance_matrix > distance_threshold, 0.1, 1.0)

    # Combine the factors (weighted average or product could be explored)
    heuristics = inverse_distance * (1 + 0.5 * nearest_neighbor_bonus) * sparsification_penalty
    #heuristics = inverse_distance + 0.5 * nearest_neighbor_bonus + sparsification_penalty

    # Ensure that the diagonal elements are zero (no self-loops)
    for i in range(n):
        heuristics[i, i] = 0.0

    return heuristics
```
