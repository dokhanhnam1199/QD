```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic function for the Traveling Salesman Problem (TSP) based on
    stochastic solution sampling principles. This function returns a matrix
    of the same shape as the distance matrix, where each element represents
    an indicator of how promising it is to include the corresponding edge
    in a TSP solution.  This version incorporates multiple factors and attempts to sparsify the matrix.

    Args:
        distance_matrix (np.ndarray): A square matrix representing the distances
                                      between cities. distance_matrix[i][j] is the
                                      distance between city i and city j.

    Returns:
        np.ndarray: A matrix of the same shape as the distance matrix, where
                    each element indicates the "promisingness" of the
                    corresponding edge. Higher values indicate more promising
                    edges.
    """

    n = distance_matrix.shape[0]  # Number of cities

    # 1. Inverse Distance (as in v1, but normalized)
    inverse_distance = 1 / (distance_matrix + 1e-9)  # Add a small constant to prevent division by zero
    inverse_distance = inverse_distance / np.max(inverse_distance)  # Normalize

    # 2. Nearest Neighbor Consideration:  Cities that are nearest neighbors
    #    of each other are likely to be connected in a good solution.
    nearest_neighbors = np.zeros_like(distance_matrix)
    for i in range(n):
        # Find the k nearest neighbors for each city
        k = min(5, n - 1) # Ensure k is valid

        nearest_neighbor_indices = np.argsort(distance_matrix[i])[1:k+1] # exclude itself (index 0)
        for j in nearest_neighbor_indices:
            nearest_neighbors[i, j] = 1
            nearest_neighbors[j, i] = 1  # Symmetry

    # 3. Triangle Inequality Encouragement: Penalize large distances that
    #    violate the triangle inequality a lot. This is a crude estimate,
    #    but can help discourage very long edges.
    triangle_inequality_score = np.ones_like(distance_matrix)
    for i in range(n):
        for j in range(n):
            if i != j:
                # Approximate triangle inequality violation (very rough)
                shortest_path_estimate = np.mean(np.partition(distance_matrix[i, :], 5)[:5]) #average of 5 shortest paths.

                triangle_inequality_violation = distance_matrix[i, j] / (shortest_path_estimate + 1e-9) # Normalize by shortest_path_estimate to control the effect
                triangle_inequality_score[i, j] = max(0, 1 - (triangle_inequality_violation - 1)) # if greater than 1, then highly violate the score is 0


    # 4. Edge Sparsification: Zero out edges that are extremely unpromising.
    #    This aims to reduce the search space for stochastic sampling.

    # Combine the factors
    heuristic_matrix = inverse_distance * nearest_neighbors * triangle_inequality_score

    # Apply sparsification (zeroing out small values)
    threshold = np.quantile(heuristic_matrix[heuristic_matrix > 0], 0.2)  # Keep top 80%

    heuristic_matrix[heuristic_matrix < threshold] = 0 # sparsify

    return heuristic_matrix
```
