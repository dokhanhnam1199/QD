```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic function for the Traveling Salesman Problem (TSP) using stochastic solution sampling.

    This version combines several factors to determine the promisingness of including each edge
    in a solution. It also sparsifies the matrix by setting unpromising elements to zero.

    Args:
        distance_matrix (np.ndarray): A square matrix representing the distances between nodes.
                                       distance_matrix[i, j] is the distance between node i and node j.

    Returns:
        np.ndarray: A matrix of the same shape as the input, where each element indicates
                    the prior probability/indicator of including the corresponding edge in a TSP solution.
    """

    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix, dtype=float)

    # 1. Inverse Distance: Shorter distances are more promising.
    inverse_distance = 1.0 / (distance_matrix + 1e-9)  # Add a small constant to avoid division by zero.

    # 2. Nearest Neighbor: Edges connecting to nearest neighbors are promising.
    nearest_neighbors = np.zeros_like(distance_matrix, dtype=float)
    for i in range(n):
        # Find the indices of the k-nearest neighbors for each node (excluding itself).
        nearest_neighbor_indices = np.argsort(distance_matrix[i, :])[1:6]  # Top 5 nearest neighbors
        nearest_neighbors[i, nearest_neighbor_indices] = 1.0

    # 3. Minimum Spanning Tree Approximation: Edges in an approximate MST are promising.
    #   (Simplified approach: favor edges connecting nodes with large sum distances)
    node_distance_sums = np.sum(distance_matrix, axis=0)
    mst_approximation = np.zeros_like(distance_matrix, dtype=float)
    for i in range(n):
        for j in range(n):
            if i != j:
                mst_approximation[i, j] = node_distance_sums[i] + node_distance_sums[j]

    # Combine the factors (weighted sum).  Experiment with the weights.
    heuristics = (0.5 * inverse_distance +
                  0.3 * nearest_neighbors +
                  0.2 * mst_approximation)

    # Sparsify the matrix: Zero out elements below a certain threshold.
    threshold = np.percentile(heuristics[heuristics > 0], 50) # dynamic threshold, only consider positive values
    heuristics[heuristics < threshold] = 0.0

    # Normalize to obtain probabilities (optional, but helpful for sampling).
    if np.sum(heuristics) > 0:
        heuristics = heuristics / np.sum(heuristics)
    else:
        heuristics = np.ones_like(heuristics) / heuristics.size

    return heuristics
```
