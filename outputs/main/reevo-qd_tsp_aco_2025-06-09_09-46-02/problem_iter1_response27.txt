```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic function for the Traveling Salesman Problem (TSP) based on:
    - Inverse distance
    - Node degree preference (prioritizing nodes with fewer connections)
    - Sparsification based on distance thresholds and degree information.

    Args:
        distance_matrix (np.ndarray): A square matrix where distance_matrix[i][j]
                                       represents the distance between city i and city j.
                                       Diagonal elements are assumed to be zero or very small.

    Returns:
        np.ndarray: A matrix of the same shape as distance_matrix, representing
                    the prior indicators of how promising it is to include each
                    edge in a solution. Higher values indicate more promising edges.
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # 1. Inverse Distance: Closer cities are more attractive.
    inverse_distance = 1 / (distance_matrix + 1e-6)  # Add a small constant to avoid division by zero

    # 2. Node Degree Preference: Encourage visiting less-connected nodes early.
    #    Initially, every node has zero degree.  We start with a bias towards
    #    connecting nodes that are "far away" from being fully connected.
    node_degree_preference = np.ones((n, n)) # Initially no preference

    # Combine inverse distance and node degree preference
    heuristic_matrix = inverse_distance * node_degree_preference

    # 3. Sparsification:  Zero out edges that are too long relative to
    #    other distances from a given node. Also prioritize nodes with
    #    fewer close neighbours

    #First calculate mean distance to other nodes for each node
    mean_distances = np.mean(distance_matrix, axis = 1, keepdims=True)

    # Zero out elements whose distance is significantly larger than the mean distance from its node
    distance_threshold = 1.5 # Threshold for filtering distances
    heuristic_matrix[distance_matrix > distance_threshold * mean_distances] = 0

    # Remove small heuristic values to help with computational time
    heuristic_matrix[heuristic_matrix < np.mean(heuristic_matrix[heuristic_matrix>0])/100] = 0


    return heuristic_matrix
```
