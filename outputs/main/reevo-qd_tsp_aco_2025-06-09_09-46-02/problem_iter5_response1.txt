```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic function for the Traveling Salesman Problem (TSP) based on stochastic solution sampling.

    This function refines the heuristics by incorporating node proximity, edge diversity, and iterative refinement
    to enhance the exploration-exploitation balance in TSP solution sampling.

    Args:
        distance_matrix (np.ndarray): A square matrix representing the distances between cities.
                                         distance_matrix[i][j] is the distance between city i and city j.

    Returns:
        np.ndarray: A matrix of the same shape as distance_matrix, where each element represents the
                      promise of including the corresponding edge in the TSP solution.
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

    # 1. Node Proximity (Inverse Distance with Scaling)
    inverse_distance = 1 / (distance_matrix + 1e-6)
    proximity_factor = np.mean(distance_matrix) / (distance_matrix + 1e-6)  # Scale based on average distance
    node_proximity = inverse_distance * proximity_factor

    # 2. Edge Diversity (Penalize High-Degree Nodes) with improved degree calculation
    degree_penalty = np.zeros_like(distance_matrix, dtype=float)
    for i in range(n):
        for j in range(n):
            if i != j:
                # Adaptive threshold for degree calculation
                threshold_i = np.median(distance_matrix[i,:])  # Use median for robustness
                threshold_j = np.median(distance_matrix[j,:])
                # Local neighborhood for degree calculation
                neighborhood_size = min(5, n - 1)
                neighbors_i = np.argpartition(distance_matrix[i, :], neighborhood_size)[:neighborhood_size]
                neighbors_j = np.argpartition(distance_matrix[j, :], neighborhood_size)[:neighborhood_size]

                degree_i = np.sum(distance_matrix[i, neighbors_i] < threshold_i)
                degree_j = np.sum(distance_matrix[j, neighbors_j] < threshold_j)
                degree_penalty[i, j] = 1.0 / (np.sqrt(degree_i * degree_j) + 1e-6)  # Geometric mean

    # 3. Shortest Path Consideration with Adaptive Scaling and dynamic temperature
    shortest_path_bonus = np.zeros_like(distance_matrix, dtype=float)
    mean_distance = np.mean(distance_matrix)
    temperature = mean_distance / 2.0  # Dynamic temperature
    for i in range(n):
        for j in range(n):
            if i != j:
                shortest_path_bonus[i, j] = np.exp(-distance_matrix[i, j] / temperature)  # Favors shorter edges

    # Combine factors
    heuristics_matrix = node_proximity * degree_penalty * shortest_path_bonus

    # 4. Sparsification (Adaptive Thresholding) - Refined sparsification
    # More aggressive sparsification in early iterations
    threshold = np.percentile(heuristics_matrix[heuristics_matrix > 0], 50)  # remove bottom 50% - Increased sparsification
    heuristics_matrix[heuristics_matrix < threshold] = 0

    # Add noise, but scale it adaptively
    noise_level = 0.001 * np.mean(heuristics_matrix[heuristics_matrix > 0]) # Further reduce noise
    noise = np.random.normal(0, noise_level, size=heuristics_matrix.shape)
    heuristics_matrix = heuristics_matrix + noise
    heuristics_matrix[heuristics_matrix < 0] = 0  # Ensure no negative values after adding noise

    # Normalize the heuristics matrix to a range between 0 and 1
    max_val = np.max(heuristics_matrix)
    if max_val > 0:
        heuristics_matrix = heuristics_matrix / max_val

    return heuristics_matrix
```
