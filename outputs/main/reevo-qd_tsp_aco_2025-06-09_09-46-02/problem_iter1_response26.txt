```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic function for TSP based on stochastic solution sampling principles.
    Combines several factors to determine edge desirability.

    Args:
        distance_matrix: A numpy ndarray representing the distance matrix.

    Returns:
        A numpy ndarray of the same shape as distance_matrix,
        representing the heuristic values for each edge.  Higher values
        indicate more promising edges.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # 1. Inverse Distance: Shorter distances are generally preferred.
    inverse_distance = 1 / (distance_matrix + 1e-9)  # Add small value to avoid division by zero.
    heuristic_matrix += inverse_distance

    # 2. Nearest Neighbor: Edges to nearest neighbors are often good.
    nearest_neighbors = np.argsort(distance_matrix, axis=1)
    nearest_neighbor_bonus = np.zeros_like(distance_matrix, dtype=float)
    for i in range(n):
        for j in range(1, min(4, n)):  # Check top 3 nearest neighbors (excluding self)
            neighbor_index = nearest_neighbors[i, j]
            nearest_neighbor_bonus[i, neighbor_index] = 1  # Bonus for being a near neighbor
    heuristic_matrix += nearest_neighbor_bonus

    # 3. Triangle Inequality: Penalize edges that bypass potentially good connections.
    triangle_penalty = np.zeros_like(distance_matrix, dtype=float)
    for i in range(n):
        for j in range(n):
            if i != j:
                #find a node k, such that distance i-k + k-j is not that much bigger than i-j.
                min_detour = np.inf
                for k in range(n):
                    if k != i and k != j:
                        detour = distance_matrix[i, k] + distance_matrix[k, j]
                        if detour < min_detour:
                            min_detour = detour
                
                triangle_penalty[i,j] = max(0, distance_matrix[i,j] - min_detour * 0.5) # high penalty when bypass more than twice of detour.

    heuristic_matrix -= triangle_penalty


    # 4. Randomness: Add a small amount of randomness to explore diverse solutions.
    random_noise = np.random.rand(n, n) * 0.1
    heuristic_matrix += random_noise

    # 5. Sparsification: Set unpromising edges to zero based on a threshold.
    threshold = np.percentile(heuristic_matrix[np.triu_indices_from(heuristic_matrix, k=1)], 20)  #keep top 80% edges

    heuristic_matrix[heuristic_matrix < threshold] = 0

    # Ensure the matrix is symmetric, as the TSP is undirected
    heuristic_matrix = np.maximum(heuristic_matrix, heuristic_matrix.T)

    return heuristic_matrix
```
