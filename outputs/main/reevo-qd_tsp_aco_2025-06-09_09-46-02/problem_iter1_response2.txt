```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic function for the Traveling Salesman Problem (TSP).

    This version combines several factors to estimate the desirability of including each edge
    in a solution. It considers:

    1.  Inverse distance: Shorter edges are generally more desirable.
    2.  Nearest neighbor: Edges connecting a node to its nearest neighbors are prioritized.
    3.  Avoidance of long edges that isolate nodes: Penalizes edges that, if removed,
        would create isolated clusters (estimated by checking if removing an edge significantly
        increases the minimum spanning tree's weight). This is approximated.
    4. Sparsification: Sets values below a threshold to zero.

    Args:
        distance_matrix (np.ndarray): A 2D NumPy array representing the distance matrix
                                       between cities. distance_matrix[i, j] gives the distance
                                       between city i and city j.

    Returns:
        np.ndarray: A 2D NumPy array of the same shape as the distance matrix, where each
                    element represents the heuristic score for including the corresponding edge
                    in a TSP solution.  Higher values indicate more promising edges.
    """

    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix, dtype=float)

    # 1. Inverse Distance
    inverse_distance = 1.0 / (distance_matrix + 1e-9)  # Adding a small constant to avoid division by zero
    heuristics += inverse_distance

    # 2. Nearest Neighbor
    for i in range(n):
        # Find indices of the nearest neighbors for node i
        neighbors = np.argsort(distance_matrix[i, :])[1:4]  # Exclude the node itself (distance 0)

        for j in neighbors:
            heuristics[i, j] += 1.0  # Boost edges connecting to nearest neighbors
            heuristics[j, i] += 1.0

    # 3. Avoid isolation (approximated penalty for removing edge resulting in long MST)
    mst_penalty_threshold = np.mean(distance_matrix) # Tune this. Higher threshold -> less penalized
    for i in range(n):
        for j in range(i + 1, n): # Only consider upper triangle (undirected graph)
            edge_weight = distance_matrix[i,j]

            if edge_weight > mst_penalty_threshold:
                heuristics[i,j] -= edge_weight / mst_penalty_threshold # Penalize but not zero it if promising
                heuristics[j,i] -= edge_weight / mst_penalty_threshold

    # Normalize heuristics and add inverse distance contribution one more time
    heuristics = (heuristics - np.min(heuristics)) / (np.max(heuristics) - np.min(heuristics) + 1e-9)
    heuristics += inverse_distance

    # 4. Sparsification (Zero out unpromising elements)
    threshold = np.quantile(heuristics[heuristics > 0], 0.2) #Zero out edges below 20th percentile
    heuristics[heuristics < threshold] = 0

    return heuristics
```
