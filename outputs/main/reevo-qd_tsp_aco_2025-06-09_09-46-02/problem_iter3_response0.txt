```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic function for the Traveling Salesman Problem (TSP) based on stochastic solution sampling with improvements.

    This function refines the heuristics by incorporating node proximity, edge diversity, and iterative refinement
    to enhance the exploration-exploitation balance in TSP solution sampling.  It also includes a better
    measure of node degree that considers the relative distances to neighbors.

    Args:
        distance_matrix (np.ndarray): A square matrix representing the distances between cities.
                                         distance_matrix[i][j] is the distance between city i and city j.

    Returns:
        np.ndarray: A matrix of the same shape as distance_matrix, where each element represents the
                      promise of including the corresponding edge in the TSP solution.
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

    # 1. Node Proximity (Inverse Distance with Scaling) - Remains the same
    inverse_distance = 1 / (distance_matrix + 1e-6)
    proximity_factor = np.mean(distance_matrix) / (distance_matrix + 1e-6)  # Scale based on average distance
    node_proximity = inverse_distance * proximity_factor

    # 2. Edge Diversity (Penalize High-Degree Nodes) - Improved degree calculation
    degree_penalty = np.zeros_like(distance_matrix, dtype=float)
    for i in range(n):
        for j in range(n):
            if i != j:
                # Improved degree estimation: Count neighbors within a dynamically determined radius
                radius_i = np.median(distance_matrix[i, :])  # Use median distance as radius
                degree_i = np.sum(distance_matrix[i, :] < radius_i)  # Count neighbors within radius
                radius_j = np.median(distance_matrix[j, :])
                degree_j = np.sum(distance_matrix[j, :] < radius_j)
                degree_penalty[i, j] = 1.0 / (degree_i * degree_j + 1e-6)

    # 3. Iterative Refinement (Shortest Path Consideration with Adaptive Scaling) - Remains the same
    shortest_path_bonus = np.zeros_like(distance_matrix, dtype=float)
    mean_distance = np.mean(distance_matrix)
    for i in range(n):
        for j in range(n):
            if i != j:
                shortest_path_bonus[i, j] = np.exp(-distance_matrix[i, j] / mean_distance)  # Favors shorter edges

    # Combine factors
    heuristics_matrix = node_proximity * degree_penalty * shortest_path_bonus

    # 4. Sparsification (Adaptive Thresholding)
    threshold = np.percentile(heuristics_matrix[heuristics_matrix > 0], 25) # remove bottom 25%
    heuristics_matrix[heuristics_matrix < threshold] = 0

    # Add a small amount of noise to break symmetry and encourage exploration.
    noise = np.random.normal(0, 0.01 * np.mean(heuristics_matrix[heuristics_matrix > 0]), size=heuristics_matrix.shape)
    heuristics_matrix = heuristics_matrix + noise
    heuristics_matrix[heuristics_matrix < 0] = 0  # Ensure no negative values after adding noise

    return heuristics_matrix
```
