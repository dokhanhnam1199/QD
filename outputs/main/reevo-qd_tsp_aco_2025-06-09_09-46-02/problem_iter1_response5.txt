```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic function for TSP using a combination of factors and sparsification.

    Args:
        distance_matrix: A numpy ndarray representing the distance matrix.

    Returns:
        A numpy ndarray representing the heuristic values for each edge.
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # Calculate a basic heuristic based on inverse distance
    base_heuristic = 1 / (distance_matrix + 1e-9)  # Add a small constant to avoid division by zero

    # Calculate nearest neighbors for each node
    nearest_neighbors = np.argsort(distance_matrix, axis=1)[:, 1:4] # top 3 nearest neighbors (excluding itself)

    # Enhance the heuristic based on nearest neighbor information
    for i in range(n):
        for j in range(n):
            if i != j:
                if j in nearest_neighbors[i]:
                    heuristic_matrix[i, j] = base_heuristic[i, j] * 2.0  # Boost nearest neighbor edges
                else:
                    heuristic_matrix[i, j] = base_heuristic[i, j]

    # Incorporate a "sparsification" strategy: prune edges unlikely to be in the optimal tour.
    #  Only keep edges whose heuristic values are above a certain threshold relative
    #  to the maximum heuristic value for each row (or column)

    row_max = np.max(heuristic_matrix, axis=1, keepdims=True)
    # Alternatively, use column_max = np.max(heuristic_matrix, axis=0, keepdims=True)
    threshold = 0.1  # Tune this threshold. Smaller threshold will sparsify the matrix more.
    heuristic_matrix[heuristic_matrix < threshold * row_max] = 0 # or threshold * column_max

    # Add a small constant to make sure that the algorithm does not get stuck
    # When all values for a row/colum are zero, this will cause a problem for the solver
    heuristic_matrix += 1e-9
    return heuristic_matrix
```
