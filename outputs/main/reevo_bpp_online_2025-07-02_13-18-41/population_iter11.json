[
  {
    "stdout_filepath": "problem_iter10_response0.txt_stdout.txt",
    "code_path": "problem_iter10_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Rule 1: Infeasible bins get a very negative priority.\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -1e9\n\n    # Rule 2: Quantify \"good fit\" using relative wasted space.\n    available_bins = bins_remain_cap >= item\n    if np.any(available_bins):\n        wasted_space = bins_remain_cap[available_bins] - item\n        relative_wasted_space = wasted_space / (bins_remain_cap[available_bins] + 1e-9)\n\n        # Good fit = low relative wasted space.  Invert and scale.\n        priorities[available_bins] = 1.0 / (0.01 + relative_wasted_space)\n\n\n        #Reward bins approaching a target fullness (e.g., 75%)\n        max_cap = np.max(bins_remain_cap) if len(bins_remain_cap) > 0 else 1.0  #Avoid edge case where bins_remain_cap is empty\n        target_fullness = 0.75 * max_cap\n        target_range = 0.2 * max_cap #Scale relative to maximum bin size. Increased range.\n\n        target_bonus = np.exp(-((bins_remain_cap[available_bins] - item - target_fullness)**2) / (2 * target_range**2))\n        priorities[available_bins] += target_bonus * 0.5\n\n\n    # Rule 3: Prioritize almost full bins to complete them, but make it relative to remaining capacity.\n    max_cap = np.max(bins_remain_cap) if len(bins_remain_cap) > 0 else 1.0 #Avoid edge case where bins_remain_cap is empty\n    almost_full_threshold = 0.1 * max_cap\n    almost_full = (bins_remain_cap >= item) & (bins_remain_cap - item < almost_full_threshold)\n    priorities[almost_full] += 10  # Give a significant bonus to almost full bins, relatively\n\n    # Rule 4: Add some noise to break ties randomly.\n    available_bins = bins_remain_cap >= item\n    priorities[available_bins] += np.random.normal(0, 1e-6, size=np.sum(available_bins))\n\n    return priorities",
    "response_id": 0,
    "obj": 3.948942959712818,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response1.txt_stdout.txt",
    "code_path": "problem_iter10_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Rule 1: Infeasible bins get a very negative priority.\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -1e9\n\n    # Rule 2: Quantify \"good fit\" using relative wasted space.\n    available_bins = bins_remain_cap >= item\n    if np.any(available_bins):\n        wasted_space = bins_remain_cap[available_bins] - item\n        relative_wasted_space = wasted_space / (bins_remain_cap[available_bins] + 1e-9)\n\n        # Good fit = low relative wasted space.  Invert and scale.\n        priorities[available_bins] = 1.0 / (0.01 + relative_wasted_space)\n\n\n        #Reward bins approaching a target fullness (e.g., 75%)\n        max_cap = np.max(bins_remain_cap)\n        target_fullness = 0.75 * max_cap if max_cap > 0 else 0.0\n        target_range = 0.2 * max_cap if max_cap > 0 else 0.1 #Scale relative to maximum bin size. Increased range.\n\n        target_bonus = np.exp(-((bins_remain_cap[available_bins] - item - target_fullness)**2) / (2 * target_range**2))\n        priorities[available_bins] += target_bonus * 0.5\n\n\n    # Rule 3: Prioritize almost full bins to complete them, but make it relative to bin size.\n    max_cap = np.max(bins_remain_cap)\n    almost_full_threshold = 0.1 * max_cap if max_cap > 0 else 0.1\n    almost_full = (bins_remain_cap >= item) & (bins_remain_cap - item < almost_full_threshold)\n    priorities[almost_full] += 10  # Give a significant bonus to almost full bins, relatively\n\n    # Rule 4: Add some noise to break ties randomly.\n    available_bins = bins_remain_cap >= item\n    priorities[available_bins] += np.random.normal(0, 1e-6, size=np.sum(available_bins))\n\n    return priorities",
    "response_id": 1,
    "obj": 3.948942959712818,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response2.txt_stdout.txt",
    "code_path": "problem_iter10_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Rule 1: Infeasible bins get a very negative priority.\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -1e9\n\n    # Rule 2: Quantify \"good fit\" using relative wasted space.\n    available_bins = bins_remain_cap >= item\n    if np.any(available_bins):\n        wasted_space = bins_remain_cap[available_bins] - item\n        relative_wasted_space = wasted_space / (bins_remain_cap[available_bins] + 1e-9)\n\n        # Good fit = low relative wasted space. Invert and scale.\n        priorities[available_bins] = 1.0 / (0.01 + relative_wasted_space)\n\n        # Reward bins approaching a target fullness (e.g., 75%)\n        max_cap = np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else 1.0\n        target_fullness = 0.75 * max_cap\n        target_range = 0.2 * max_cap\n\n        remaining_after_pack = bins_remain_cap[available_bins] - item\n        target_bonus = np.exp(-((remaining_after_pack - (max_cap - target_fullness))**2) / (2 * target_range**2))\n        priorities[available_bins] += target_bonus * 0.5\n\n    # Rule 3: Prioritize almost full bins to complete them, relative to bin size.\n    max_cap = np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else 1.0  # Avoid division by zero\n    almost_full = (bins_remain_cap >= item) & (bins_remain_cap - item < 0.1 * max_cap)\n    if np.any(almost_full):\n        priorities[almost_full] += 10 * (1 - (bins_remain_cap[almost_full] - item) / item)  # Increased impact\n\n    # Rule 4: Add some noise to break ties randomly.\n    available_bins = bins_remain_cap >= item\n    priorities[available_bins] += np.random.normal(0, 1e-6, size=np.sum(available_bins))\n\n    return priorities",
    "response_id": 2,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response3.txt_stdout.txt",
    "code_path": "problem_iter10_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    max_cap = np.max(bins_remain_cap) if bins_remain_cap.size > 0 else 1.0\n\n    # Rule 1: Infeasible bins get a very negative priority.\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -1e9\n\n    # Rule 2: Quantify \"good fit\" using relative wasted space.\n    available_bins = bins_remain_cap >= item\n    if np.any(available_bins):\n        wasted_space = bins_remain_cap[available_bins] - item\n        relative_wasted_space = wasted_space / (max_cap + 1e-9) # Normalize wasted space\n\n        # Good fit = low relative wasted space.\n        priorities[available_bins] = 1.0 / (0.01 + relative_wasted_space)\n\n        # Reward bins approaching a target fullness (e.g., 75%)\n        target_fullness = 0.75\n        target_range = 0.2\n\n        remaining_capacity_ratio = (bins_remain_cap[available_bins] - item) / max_cap if max_cap > 0 else 0.0\n\n\n        target_bonus = np.exp(-((remaining_capacity_ratio - (1 - target_fullness))**2) / (2 * target_range**2))\n        priorities[available_bins] += target_bonus * 0.5\n\n\n    # Rule 3: Prioritize almost full bins to complete them.\n    almost_full_threshold = 0.1\n    almost_full = (bins_remain_cap >= item) & ((bins_remain_cap - item) / max_cap < almost_full_threshold if max_cap > 0 else bins_remain_cap >= item)\n    priorities[almost_full] += 5\n\n    # Rule 4: Add some noise to break ties randomly.\n    available_bins = bins_remain_cap >= item\n    priorities[available_bins] += np.random.normal(0, 1e-6, size=np.sum(available_bins))\n\n    return priorities",
    "response_id": 3,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response4.txt_stdout.txt",
    "code_path": "problem_iter10_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Rule 1: Infeasible bins get a very negative priority.\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -1e9\n\n    available_bins = ~infeasible_bins\n\n    if np.any(available_bins):\n        # Calculate wasted space\n        wasted_space = bins_remain_cap[available_bins] - item\n        max_cap = np.max(bins_remain_cap)\n\n        # Relative Wasted Space Priority (Minimize)\n        relative_wasted_space = wasted_space / (item + 1e-9)\n        priorities[available_bins] -= relative_wasted_space * 8\n\n        # Target Fullness Reward (Target around 75% full)\n        target_fullness = 0.75 * max_cap if max_cap > 0 else 0.0\n        target_range = 0.2 * max_cap if max_cap > 0 else 0.1\n        fullness = bins_remain_cap[available_bins] - item\n        target_bonus = np.exp(-((fullness - (max_cap - target_fullness)) ** 2) / (2 * target_range ** 2))\n        priorities[available_bins] += target_bonus * 5\n\n        # Large Gap Penalty (Scaled relative to item size)\n        large_gap_threshold = 0.6 * item\n        large_gap_penalty = (wasted_space > large_gap_threshold) * (wasted_space / max_cap) if max_cap > 0 else (wasted_space > large_gap_threshold) * wasted_space\n        priorities[available_bins] -= large_gap_penalty * 3\n\n        # Occupancy Reward\n        fill_level = (max_cap - bins_remain_cap[available_bins] + item) / max_cap if max_cap > 0 else 0\n        priorities[available_bins] += fill_level * 4\n\n        # Small Waste Bonus\n        small_waste_threshold = 0.2 * item\n        small_waste_bonus = (wasted_space <= small_waste_threshold) * 6\n        priorities[available_bins] += small_waste_bonus\n\n        # Tight fit bonus, prioritize bins that fit snugly\n        tight_fit_threshold = 0.05 * item\n        tight_fit_bonus = (wasted_space <= tight_fit_threshold) * 8\n        priorities[available_bins] += tight_fit_bonus\n\n        # Very Small Gap Penalty\n        very_small_threshold = 0.01 * max_cap if max_cap > 0 else 0.01\n        very_small_gap_penalty = (wasted_space <= very_small_threshold) * 5\n        priorities[available_bins] -= very_small_gap_penalty\n\n    # Tie-breaking Noise\n    if np.any(available_bins):\n        priorities[available_bins] += np.random.normal(0, 1e-6, size=np.sum(available_bins))\n\n    return priorities",
    "response_id": 4,
    "obj": 4.098524132429212,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response5.txt_stdout.txt",
    "code_path": "problem_iter10_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Rule 1: Infeasible bins get a very negative priority.\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -1e9\n\n    # Rule 2: Prioritize bins that minimize relative wasted space (relative to item size).\n    available_bins = bins_remain_cap >= item\n    if np.any(available_bins):\n        wasted_space = bins_remain_cap[available_bins] - item\n        relative_wasted_space = wasted_space / (item + 1e-9)  # Wasted space relative to *item* size\n\n        # Good fit = low relative wasted space. Invert and scale.\n        priorities[available_bins] = 1.0 / (0.01 + relative_wasted_space)\n\n        # Penalize near-empty bins based on occupancy.\n        total_capacity = bins_remain_cap + item  # Estimate total capacity.\n        if np.any(total_capacity > 0):\n            occupancy = (total_capacity[available_bins] - bins_remain_cap[available_bins]) / np.max(total_capacity)\n            occupancy_penalty = (1 - occupancy)**2 * 0.1  # Stronger penalty for near-empty bins.\n            priorities[available_bins] -= occupancy_penalty\n        else:\n             priorities[available_bins] -= 0.05 #Slight penality if all bins are effectively zero sized.\n\n        # Reward bins approaching a target fullness (e.g., 75% of max bin size).\n        max_cap = np.max(total_capacity) if np.any(total_capacity>0) else 1.0\n        target_fullness = 0.75 * max_cap\n        target_range = 0.1 * max_cap\n\n        target_bonus = np.exp(-((bins_remain_cap[available_bins] - target_fullness + item)**2) / (2 * target_range**2))\n        priorities[available_bins] += target_bonus * 0.5\n\n\n    # Rule 3: Prioritize almost full bins to complete them.\n    almost_full = (bins_remain_cap >= item) & (bins_remain_cap - item < 0.1 * np.max(bins_remain_cap) if np.max(bins_remain_cap)>0 else bins_remain_cap >= item)\n    priorities[almost_full] += 10  # Give a significant bonus to almost full bins.\n\n    # Rule 4: Add some noise to break ties randomly.\n    available_bins = bins_remain_cap >= item\n    priorities[available_bins] += np.random.normal(0, 1e-6, size=np.sum(available_bins))\n\n    return priorities",
    "response_id": 5,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response6.txt_stdout.txt",
    "code_path": "problem_iter10_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Rule 1: Infeasible bins get a very negative priority.\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -1e9\n\n    available_bins = bins_remain_cap >= item\n    if np.any(available_bins):\n        # Rule 2: Good fit based on relative wasted space.\n        wasted_space = bins_remain_cap[available_bins] - item\n        relative_wasted_space = wasted_space / (item + 1e-9)\n        priorities[available_bins] = -relative_wasted_space # Lower is better\n\n        max_cap = np.max(bins_remain_cap) if bins_remain_cap.size > 0 else 1.0  # Handle empty array\n        if max_cap > 0:\n\n            # Rule 3: Bin occupancy penalty (prefer bins near half-full).\n            occupancy = 1.0 - bins_remain_cap[available_bins] / max_cap\n            occupancy_penalty = np.abs(occupancy - 0.5)\n            priorities[available_bins] -= occupancy_penalty * 0.1\n\n            # Rule 4: Target fullness bonus.\n            target_fullness = 0.75 * max_cap\n            target_range = 0.1 * max_cap\n            target_bonus = np.exp(-((bins_remain_cap[available_bins] - item - target_fullness) ** 2) / (2 * target_range ** 2))\n            priorities[available_bins] += target_bonus * 0.3\n\n            # Rule 5: Penalize high remaining capacity.\n            high_capacity_threshold = 0.9 * max_cap\n            high_capacity_penalty = (bins_remain_cap[available_bins] > high_capacity_threshold) * (bins_remain_cap[available_bins] / max_cap) * 0.1\n            priorities[available_bins] -= high_capacity_penalty\n\n            # Rule 6: Prioritize almost full bins.\n            almost_full_threshold = 0.1 * max_cap\n            almost_full = (wasted_space <= almost_full_threshold)\n            priorities[available_bins][almost_full] += 5\n\n        # Rule 7: Noise for tie-breaking. Reduced magnitude.\n        noise_std = 1e-7 * max_cap if max_cap > 0 else 1e-7\n        priorities[available_bins] += np.random.normal(0, noise_std, size=np.sum(available_bins))\n\n    return priorities",
    "response_id": 6,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response7.txt_stdout.txt",
    "code_path": "problem_iter10_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Rule 1: Infeasible bins get a very negative priority.\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -1e9\n\n    # Get bin size\n    bin_size = np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else 1.0\n\n    # Rule 2: Quantify \"good fit\" using relative wasted space.\n    # A good fit minimizes the *ratio* of wasted space to the item size.\n    available_bins = bins_remain_cap >= item\n    if np.any(available_bins):\n        wasted_space = bins_remain_cap[available_bins] - item\n        relative_wasted_space = wasted_space / (item + 1e-9)  # avoid division by zero if item is 0\n\n        # Good fit = low relative wasted space. Invert and scale.\n        priorities[available_bins] = 1.0 / (0.01 + relative_wasted_space)\n\n        # Further improve good fit by considering bin occupancy, penalize bins which are far from ideal occupancy.\n        occupancy = 1.0 - bins_remain_cap[available_bins] / bin_size\n        ideal_occupancy = 0.75  # Target 75% occupancy\n        occupancy_penalty = np.abs(occupancy - ideal_occupancy)  # Prefer bins near the target occupancy.\n        priorities[available_bins] -= occupancy_penalty * 0.3\n\n        # Reward bins approaching a target fullness (e.g., 75%), scaled by item size\n        target_fullness = ideal_occupancy * bin_size  # Target 75%\n        target_range = 0.1 * bin_size  # Tolerance of 10%\n\n        target_bonus = np.exp(-((bins_remain_cap[available_bins] - item - target_fullness) ** 2) / (2 * target_range ** 2))\n        priorities[available_bins] += target_bonus * 0.6 * (item/bin_size)\n\n        # Penalize large gaps, adapt penalty to item size\n        large_gap_threshold = 0.4 * bin_size  # Define \"large\" relative to bin size (40%)\n        large_gap_penalty = (wasted_space > large_gap_threshold) * (wasted_space / bin_size) * 0.2  # Scale with gap size, more sensitive\n        priorities[available_bins] -= large_gap_penalty * (item/bin_size)\n\n        # Reward filling bins that are close to item size\n        item_proximity = np.exp(-((bins_remain_cap[available_bins] - item) ** 2) / (2 * (0.1*bin_size) ** 2))\n        priorities[available_bins] += item_proximity * 0.4 * (item/bin_size)\n\n    # Rule 3: Prioritize almost full bins to complete them, but make it relative to bin size.\n    almost_full_threshold = 0.1 * bin_size  # Threshold of 10%\n    almost_full = (bins_remain_cap >= item) & (bins_remain_cap - item < almost_full_threshold)\n    priorities[almost_full] += 12  # Give a significant bonus to almost full bins\n\n    # Rule 4: Add some noise to break ties randomly.\n    available_bins = bins_remain_cap >= item\n    if np.any(available_bins):\n        priorities[available_bins] += np.random.normal(0, 1e-6, size=np.sum(available_bins))\n\n    return priorities",
    "response_id": 7,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response8.txt_stdout.txt",
    "code_path": "problem_iter10_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Rule 1: Infeasible bins get a very negative priority.\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -1e9\n\n    # Rule 2: Quantify \"good fit\" using relative wasted space.\n    available_bins = bins_remain_cap >= item\n    if np.any(available_bins):\n        wasted_space = bins_remain_cap[available_bins] - item\n        relative_wasted_space = wasted_space / (bins_remain_cap[available_bins] + 1e-9)\n\n        # Good fit = low relative wasted space.  Invert and scale.\n        priorities[available_bins] = 1.0 / (0.01 + relative_wasted_space)\n\n\n        #Reward bins approaching a target fullness (e.g., 75%)\n        max_cap = np.max(bins_remain_cap) + item  # Estimate original bin capacity\n        target_fullness = 0.75 * max_cap if max_cap > 0 else 0.0\n        target_range = 0.2 * max_cap if max_cap > 0 else 0.1 #Scale relative to estimated maximum bin size. Increased range.\n\n        target_bonus = np.exp(-((bins_remain_cap[available_bins] - target_fullness)**2) / (2 * target_range**2))\n        priorities[available_bins] += target_bonus * 0.5\n\n\n    # Rule 3: Prioritize almost full bins to complete them, but make it relative to bin size.\n    almost_full_threshold = 0.1 * max_cap if max_cap > 0 else 0.1\n    almost_full = (bins_remain_cap >= item) & (bins_remain_cap - item < almost_full_threshold)\n    priorities[almost_full] += 10  # Give a significant bonus to almost full bins, relatively\n\n    # Rule 4: Add some noise to break ties randomly.\n    available_bins = bins_remain_cap >= item\n    priorities[available_bins] += np.random.normal(0, 1e-6, size=np.sum(available_bins))\n\n    return priorities",
    "response_id": 8,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response9.txt_stdout.txt",
    "code_path": "problem_iter10_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Rule 1: Infeasible bins get a very negative priority.\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -1e9\n\n    # Rule 2: Quantify \"good fit\" using relative wasted space.\n    available_bins = bins_remain_cap >= item\n    if np.any(available_bins):\n        wasted_space = bins_remain_cap[available_bins] - item\n        relative_wasted_space = wasted_space / (bins_remain_cap[available_bins] + 1e-9)\n\n        # Good fit = low relative wasted space.\n        priorities[available_bins] = 1.0 / (0.01 + relative_wasted_space)\n\n        # Reward bins approaching a target fullness (e.g., 75%)\n        max_cap = np.max(bins_remain_cap)\n        target_fullness = 0.75 * max_cap if max_cap > 0 else 0.0\n        target_range = 0.2 * max_cap if max_cap > 0 else 0.1\n\n        fullness_deviation = np.abs(bins_remain_cap[available_bins] - item - (max_cap - target_fullness)) #deviation from remaining capacity\n        target_bonus = np.exp(-(fullness_deviation**2) / (2 * target_range**2))\n        priorities[available_bins] += target_bonus * 0.5\n\n\n    # Rule 3: Prioritize almost full bins to complete them.\n    almost_full_threshold = 0.1 * np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else 0.1\n    almost_full = (bins_remain_cap >= item) & (bins_remain_cap - item <= almost_full_threshold)\n    priorities[almost_full] += 5\n\n    # Rule 4: Add some noise to break ties randomly.\n    available_bins = bins_remain_cap >= item\n    priorities[available_bins] += np.random.normal(0, 1e-6, size=np.sum(available_bins))\n\n    return priorities",
    "response_id": 9,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response0.txt_stdout.txt",
    "code_path": "problem_iter11_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else 1.0  # Normalize to max capacity\n\n    # Rule 1: Infeasible bins get a very negative priority.\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -1e9\n\n    # Rule 2: Quantify \"good fit\" using relative wasted space, scaled to bin capacity.\n    available_bins = bins_remain_cap >= item\n    if np.any(available_bins):\n        wasted_space = bins_remain_cap[available_bins] - item\n        relative_wasted_space = wasted_space / (bin_capacity + 1e-9) # Use bin_capacity for scaling\n        priorities[available_bins] = 1.0 / (0.01 + relative_wasted_space)\n\n        # Reward bins approaching a target fullness (e.g., 75% of bin capacity), scaled to capacity.\n        target_fullness = 0.75 * bin_capacity\n        target_range = 0.15 * bin_capacity\n\n        target_bonus = np.exp(-((bins_remain_cap[available_bins] - item - target_fullness)**2) / (2 * target_range**2))\n        priorities[available_bins] += target_bonus * 0.7\n\n    # Rule 3: Prioritize almost full bins to complete them. Threshold scaled to capacity\n    almost_full = (bins_remain_cap >= item) & (bins_remain_cap - item < 0.15 * bin_capacity)\n    priorities[almost_full] += 15\n\n    # Rule 4: Add small noise for tie-breaking.\n    available_bins = bins_remain_cap >= item\n    priorities[available_bins] += np.random.normal(0, 1e-6, size=np.sum(available_bins))\n\n    # Adjust priorities based on item size (favor smaller items into bins with space)\n    priorities[available_bins] += (1 - item/bin_capacity) * 0.1\n\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response1.txt_stdout.txt",
    "code_path": "problem_iter11_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap) if bins_remain_cap.size > 0 else 1.0 # Use maximum as proxy for full bin size.\n\n    # Rule 1: Infeasible bins get a very negative priority.\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -1e9\n\n    # Rule 2: Quantify \"good fit\" using relative wasted space.\n    available_bins = bins_remain_cap >= item\n    if np.any(available_bins):\n        wasted_space = bins_remain_cap[available_bins] - item\n        relative_wasted_space = wasted_space / (bin_capacity + 1e-9)  #Scale to bin capacity\n\n        priorities[available_bins] = 1.0 / (0.01 + relative_wasted_space)\n\n        # Reward bins approaching a target fullness (e.g., 75% of bin capacity)\n        target_fullness = 0.75 * bin_capacity\n        target_range = 0.15 * bin_capacity\n\n        target_bonus = np.exp(-((bins_remain_cap[available_bins] - item - target_fullness)**2) / (2 * target_range**2))\n        priorities[available_bins] += target_bonus * 0.7\n\n\n        #Penalize wasted space if item is large relative to bin_capacity\n        item_relative_size = item / bin_capacity\n        if item_relative_size > 0.5:\n            waste_penalty = relative_wasted_space*5 # Increased penalty for larger items in bins with high relative waste\n            priorities[available_bins] -= waste_penalty\n\n\n    # Rule 3: Prioritize almost full bins to complete them\n    almost_full = (bins_remain_cap >= item) & (bins_remain_cap - item < 0.15 * bin_capacity)\n    priorities[almost_full] += 15\n\n    # Rule 4: Add small noise for tie-breaking.\n    available_bins = bins_remain_cap >= item\n    priorities[available_bins] += np.random.normal(0, 1e-6, size=np.sum(available_bins))\n\n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response2.txt_stdout.txt",
    "code_path": "problem_iter11_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else 1.0\n\n    # Rule 1: Infeasible bins get a very negative priority.\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -1e9\n\n    # Rule 2: Quantify \"good fit\" using relative wasted space, scaled to bin capacity.\n    available_bins = bins_remain_cap >= item\n    if np.any(available_bins):\n        wasted_space = bins_remain_cap[available_bins] - item\n        relative_wasted_space = wasted_space / bin_capacity\n        priorities[available_bins] = 1.0 / (0.01 + relative_wasted_space)\n\n        # Scale reward by item size: smaller items get a smaller waste penalty.\n        priorities[available_bins] *= (1 - 0.5 * (item / bin_capacity))\n\n        # Rule 3: Target almost-full bins, adjust target based on item size\n        target_fullness = 0.9 * bin_capacity #Higher target\n        target_range = 0.1 * bin_capacity\n\n        # Item size penalty for reward scaling. Favor smaller items for almost full\n        item_penalty = 1 - (item/bin_capacity)\n        target_bonus = np.exp(-((bins_remain_cap[available_bins] - item - target_fullness)**2) / (2 * target_range**2))\n        priorities[available_bins] += target_bonus * 1.0 * item_penalty #Increased and Scaled bonus.\n\n\n        # Rule 4: Prioritize almost full bins to complete them, using a threshold.\n        almost_full = (bins_remain_cap >= item) & (bins_remain_cap - item < 0.1 * bin_capacity) #Adjusted threshold\n        priorities[almost_full] += 20  #Increased Bonus\n\n    # Rule 5: Add small noise for tie-breaking, only to feasible bins.\n    available_bins = bins_remain_cap >= item\n    priorities[available_bins] += np.random.normal(0, 1e-6, size=np.sum(available_bins))\n\n    return priorities",
    "response_id": 2,
    "obj": 4.068607897885915,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response3.txt_stdout.txt",
    "code_path": "problem_iter11_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    max_cap = np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else 1.0\n\n    # Rule 1: Infeasible bins get a very negative priority.\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -1e9\n\n    # Rule 2: Quantify \"good fit\" using relative wasted space and reward smaller wasted space\n    available_bins = bins_remain_cap >= item\n    if np.any(available_bins):\n        wasted_space = bins_remain_cap[available_bins] - item\n        relative_wasted_space = wasted_space / (max_cap + 1e-9)  # Scale to bin capacity\n\n        priorities[available_bins] = 5.0 / (0.01 + relative_wasted_space)  # Higher initial priority\n\n        # Rule 3: Reward bins approaching a target fullness (e.g., 90% of bin capacity)\n        target_fullness = 0.9 * max_cap # Adjusted Target\n        target_range = 0.1 * max_cap\n\n        target_bonus = np.exp(-((bins_remain_cap[available_bins] - item - target_fullness)**2) / (2 * target_range**2))\n        priorities[available_bins] += target_bonus * 10 # Increased target bonus\n\n        # Rule 4: Penalize bins with very large remaining capacity.\n        large_waste = bins_remain_cap[available_bins] - item > 0.6 * max_cap  # Threshold\n        priorities[available_bins][large_waste] -= 3 #Penalty for Large Waste.\n\n    # Rule 5: Prioritize almost full bins to complete them\n    almost_full = (bins_remain_cap >= item) & (bins_remain_cap - item < 0.1 * max_cap if max_cap > 0 else bins_remain_cap >=item) #Tuned Value\n    priorities[almost_full] += 20 # Increased almost full bonus\n\n    # Rule 6: Adaptive penalty for bins when item size is large.\n    large_item_penalty = -item/max_cap *5 if max_cap >0 else 0\n    priorities[available_bins] += large_item_penalty\n\n    # Rule 7: Add small noise for tie-breaking.\n    available_bins = bins_remain_cap >= item\n    priorities[available_bins] += np.random.normal(0, 1e-6, size=np.sum(available_bins))\n\n    return priorities",
    "response_id": 3,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response4.txt_stdout.txt",
    "code_path": "problem_iter11_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else 1.0\n\n\n    # Rule 1: Infeasible bins get a very negative priority.\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -1e9\n\n    # Rule 2: Quantify \"good fit\" using relative wasted space.\n    available_bins = bins_remain_cap >= item\n    if np.any(available_bins):\n        wasted_space = bins_remain_cap[available_bins] - item\n        relative_wasted_space = wasted_space / (bin_capacity + 1e-9) #Scale by max capacity\n        priorities[available_bins] = 1.0 / (0.01 + relative_wasted_space)\n\n\n        # Rule 3: Reward bins approaching a target fullness (e.g., 75% of bin capacity). Scale bonus by item size\n        target_fullness = 0.75 * bin_capacity\n        target_range = 0.15 * bin_capacity\n        target_bonus = np.exp(-((bins_remain_cap[available_bins] - item - target_fullness)**2) / (2 * target_range**2))\n        priorities[available_bins] += target_bonus * min(1.0, item/bin_capacity)  #Increased bonus\n\n    # Rule 4: Prioritize almost full bins to complete them. Adapt bonus based on item size relative to bin capacity\n    almost_full = (bins_remain_cap >= item) & (bins_remain_cap - item < 0.15 * bin_capacity) #Adjusted threshold\n    bonus = 15 * (1 - item/bin_capacity) #scale reward based on item size\n    priorities[almost_full] += bonus\n\n    # Rule 5: Add small noise for tie-breaking.\n    available_bins = bins_remain_cap >= item\n    priorities[available_bins] += np.random.normal(0, 1e-6, size=np.sum(available_bins))\n\n    return priorities",
    "response_id": 4,
    "obj": 4.048663741523748,
    "exec_success": true
  }
]