[
  {
    "stdout_filepath": "problem_iter2_response0.txt_stdout.txt",
    "code_path": "problem_iter2_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Immediate Fit: Highest priority if item fits perfectly\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    priorities[perfect_fit] = 10000  # Even higher priority for perfect fit\n\n    # Best Fit: High priority for bins where item nearly fills bin\n    almost_fit = (bins_remain_cap >= item) & (bins_remain_cap <= 1.5 * item) #Slightly tighter almost fit\n    priorities[almost_fit] = 1000 / (bins_remain_cap[almost_fit] - item + 0.001)  # Prioritize smaller wasted space\n\n    # First Fit: Prioritize bins that fit the item, but not as highly as best fit.\n    fit = (bins_remain_cap >= item) & ~almost_fit #Bins that fit, but aren't an almost fit\n    priorities[fit] = 10 / (bins_remain_cap[fit] + 0.001) #Less priority as the space goes up, but still prioritize fitting\n\n    # Worst Fit: Low priority (but still possible) for bins with lots of space\n    large_capacity = bins_remain_cap > 1.5 * item\n    priorities[large_capacity] = 0.1 / bins_remain_cap[large_capacity] # Encourage using emptier bins even less\n\n    \n    # Penalize bins that are too small. Make them extremely undesirable.\n    too_small = bins_remain_cap < item\n    priorities[too_small] = -10000 # Extremely low priority; avoid at all costs\n    \n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response1.txt_stdout.txt",
    "code_path": "problem_iter2_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Rule 1: Feasibility - Bins that cannot fit the item get negative infinity priority.\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] = -np.inf\n\n    # Rule 2: Prioritize fitting - Give a substantial base priority to feasible bins\n    feasible_mask = bins_remain_cap >= item\n    priorities[feasible_mask] += 1.0\n\n    # Rule 3: Invert wasted space - Higher priority to tighter fits (smaller wasted space)\n    wasted_space = bins_remain_cap - item\n    wasted_space[~feasible_mask] = np.inf  # penalize infeasible bins by making their wasted space infinite\n    priorities[feasible_mask] += 1.0 / (1.0 + wasted_space[feasible_mask])  # smaller wasted space -> higher priority\n\n    # Rule 4: Penalize near-full bins (but only if the item fits)\n    almost_full = feasible_mask & (bins_remain_cap - item <= 0.1)\n    priorities[almost_full] -= 0.5\n\n    # Rule 5: Small items prefer low occupancy\n    if item < 0.2:\n        occupancy = 1.0 - bins_remain_cap / np.max(bins_remain_cap) # Occupancy level of each bin normalized\n        priorities[feasible_mask] += (1.0 - occupancy[feasible_mask]) * 0.3\n\n    return priorities",
    "response_id": 1,
    "obj": 4.11846828879138,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response2.txt_stdout.txt",
    "code_path": "problem_iter2_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Feasibility check: Only consider bins that can fit the item\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        return priorities  # No bin can fit the item\n\n    # Calculate remaining capacity after placing the item (for feasible bins only)\n    remaining_capacity_after_placement = bins_remain_cap[feasible_bins] - item\n\n    # Heuristic 1: Try to fill bins as much as possible (minimize wasted space). Prioritize bins where remaining capacity after placement is small.\n    # Invert the remaining capacity so smaller capacity means higher priority\n    priorities[feasible_bins] = -remaining_capacity_after_placement\n\n    # Heuristic 2: Avoid creating bins with tiny remaining capacities (fragmentation). Penalize bins that result in very small remaining capacity after placement.\n    tiny_capacity_threshold = 0.1  # Adjust this threshold as needed. As a fraction of bin size (assumed to be 1)\n    fragmentation_penalty = -100  # Adjust this penalty as needed\n    priorities[feasible_bins & (remaining_capacity_after_placement < tiny_capacity_threshold)] += fragmentation_penalty\n\n    # Heuristic 3: Give a bonus for near-full bins after placement. Incentivize finishing bins.\n    near_full_bonus_threshold = 0.05  # If the remaining space is less than 5% of bin size, strongly prioritize this bin. Assume bin_size = 1.\n    near_full_bonus = 100\n    priorities[feasible_bins & (remaining_capacity_after_placement <= near_full_bonus_threshold)] += near_full_bonus\n\n    # Heuristic 4: If an item fills a bin, highly prioritize it\n    exact_fit_bonus = 500\n    priorities[feasible_bins & (remaining_capacity_after_placement == 0)] += exact_fit_bonus\n\n    # Heuristic 5: Moderate fill (Avoid creating bins with a lot of space). Slightly Penalize bins that result in larger remaining capacity\n    large_capacity_threshold = 0.9 # If the remaining space is >90% of bin size, penalize it\n    large_capacity_penalty = -20\n    priorities[feasible_bins & (remaining_capacity_after_placement > large_capacity_threshold)] += large_capacity_penalty\n\n    return priorities",
    "response_id": 2,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response3.txt_stdout.txt",
    "code_path": "problem_iter2_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # 1. Feasibility: Assign -inf priority to bins that can't fit the item\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -np.inf\n    \n    # 2. First-Fit-Decreasing Inspired: Give higher priority to bins with smaller remaining capacity that *can* fit the item.\n    #    Rationale: Prefer filling bins that are already somewhat full to avoid creating many near-empty bins.\n    #    We want to penalize large gaps, so use a decreasing function of the *available* space *after* adding the item.\n    #    Note that we're only considering feasible bins at this point.\n    \n    feasible_bins = ~infeasible_bins\n    remaining_space_after_fit = bins_remain_cap[feasible_bins] - item\n    \n    # Linear penalty scaled by inverse bin size. Add a small constant to remaining capacity for numerical stability.\n    priorities[feasible_bins] = -remaining_space_after_fit + (0.5/(bins_remain_cap[feasible_bins] + 1e-9))\n    \n    # 3. Avoidance of near-full bins: slightly reduced priorities for near full bins. Reduce penalty as bin gets large to avoid over penalizing\n    near_full_bins = (bins_remain_cap >= item) & (bins_remain_cap - item < 0.1) #Bins close to being full after fitting the item\n    priorities[near_full_bins] -= 0.05 * (1/(bins_remain_cap[near_full_bins]+1e-9))\n\n    return priorities",
    "response_id": 3,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response4.txt_stdout.txt",
    "code_path": "problem_iter2_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if item <= cap:\n            # Prioritize bins that can fit the item\n            space_waste = cap - item\n            # Give higher priority to bins with less remaining space *after* placing the item, but not zero-space waste\n            if space_waste > 0:\n                priorities[i] = 1 / space_waste  # Higher priority for less waste.\n            else:\n                 priorities[i] = 1000  # Max priority for perfect fit\n\n        else:\n            # Negative priority if it does not fit.\n            priorities[i] = -10000 # Significantly penalize bins that cannot fit\n\n    return priorities",
    "response_id": 4,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response5.txt_stdout.txt",
    "code_path": "problem_iter2_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Feasibility: Assign very low priority to bins that cannot fit the item\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] = -np.inf  # Extremely low priority\n\n    # Best Fit Criterion: Prioritize bins where the remaining capacity is close to zero after adding the item.\n    # Avoid fragmentation. Use smaller bins first to save bigger bins for potentially larger items in the future\n    feasible_mask = bins_remain_cap >= item\n    remaining_capacity_after_fit = bins_remain_cap[feasible_mask] - item\n    priorities[feasible_mask] = -remaining_capacity_after_fit  # Smaller remaining capacity is preferred (higher priority)\n\n    # Bonus for bins that fit well without wasting too much space. Balance between best fit and fragmentation.\n    # Also consider bins that are not too empty.  We want to avoid bins that are barely used.\n    fill_ratio_after_fit = (bins_remain_cap[feasible_mask] - item) / bins_remain_cap[feasible_mask]\n    bonus_mask = (fill_ratio_after_fit > 0.05) & (fill_ratio_after_fit < 0.2)  # Slightly tighter range, avoids very small or large wastes\n    priorities[feasible_mask][bonus_mask] += 1  # add bonus to give these bin priority\n\n    # Penalize almost full bins\n    almost_full_mask = (bins_remain_cap > item) & (bins_remain_cap <= item * 1.1)  # Adjusted factor\n    priorities[almost_full_mask] -= 0.5\n\n    return priorities",
    "response_id": 5,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response6.txt_stdout.txt",
    "code_path": "problem_iter2_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Initialize with a very small negative value for bins that can't fit the item.\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -1e9\n\n    # Calculate remaining capacity after placing item.\n    remaining_capacities = bins_remain_cap - item\n\n    # Identify bins where the item fits.\n    available_bins = ~infeasible_bins\n\n    # Prioritize bins based on \"good fit\" using relative remaining capacity and item size.\n    # The goal is to minimize waste (small remaining capacity) without overcrowding (item too large relative to bin size).\n    fit_threshold_waste = 0.3  # Allow up to 30% waste relative to item size.\n    fit_threshold_frag = 0.8 #Allow item to fill almost the entire bin\n    \n    waste_penalty = np.zeros_like(bins_remain_cap, dtype=float)\n    fragmentation_penalty = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Waste penalty: higher penalty for more waste relative to item size.\n    waste_penalty[available_bins] = np.clip(remaining_capacities[available_bins] / item, 0, fit_threshold_waste)\n    \n    # Fragmentation penalty: higher penalty if the item fills a small portion of the bin, creating fragmentation\n    fragmentation_penalty[available_bins] = np.clip(1 - (item / bins_remain_cap[available_bins]), 0, fit_threshold_frag)\n    \n    # Combine waste and fragmentation penalties and invert to create priority\n    priorities[available_bins] = 1 - (waste_penalty[available_bins] + fragmentation_penalty[available_bins])\n    \n    # Scale by inverse bin size to prefer filling smaller bins first, and add a bias\n    priorities[available_bins] /= (bins_remain_cap[available_bins] + 0.1)\n    priorities[available_bins] += 0.1\n\n    # Add small noise to break ties.\n    priorities[available_bins] += np.random.normal(0, 1e-6, size=np.sum(available_bins))\n\n    return priorities",
    "response_id": 6,
    "obj": 4.068607897885915,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response7.txt_stdout.txt",
    "code_path": "problem_iter2_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Feasibility check: Only consider bins that can fit the item\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        return priorities  # No bin can fit the item\n\n    # Calculate remaining capacity after placing the item (for feasible bins only)\n    remaining_capacity_after_placement = bins_remain_cap[feasible_bins] - item\n\n    # Heuristic 1: Try to fill bins as much as possible (minimize wasted space).\n    # Prioritize bins where remaining capacity after placement is small.\n    priorities[feasible_bins] = -remaining_capacity_after_placement\n\n    # Heuristic 2: Avoid creating bins with tiny remaining capacities (fragmentation).\n    # Penalize bins that result in very small remaining capacity after placement.\n    tiny_capacity_threshold = 0.1  # Adjust this threshold as needed\n    fragmentation_penalty = -100  # Adjust this penalty as needed\n    priorities[feasible_bins & (remaining_capacity_after_placement < tiny_capacity_threshold)] += fragmentation_penalty\n\n    # Heuristic 3: Give a bonus for near-full bins after placement. Incentivize finishing bins.\n    near_full_bonus_threshold = 0.05  # If the remaining space is less than 5% of bin size, strongly prioritize this bin. Assume bin_size = 1.\n    near_full_bonus = 100\n    priorities[feasible_bins & (remaining_capacity_after_placement <= near_full_bonus_threshold)] += near_full_bonus\n\n    # Heuristic 4: If an item fills a bin, highly prioritize it\n    exact_fit_bonus = 500\n    priorities[feasible_bins & (remaining_capacity_after_placement == 0)] += exact_fit_bonus\n\n    # Heuristic 5: Moderate Fragmentation Penalty Adjustment\n    moderate_frag_threshold = 0.25\n    moderate_frag_penalty = -20\n    priorities[feasible_bins & (remaining_capacity_after_placement > tiny_capacity_threshold) & (remaining_capacity_after_placement <= moderate_frag_threshold)] += moderate_frag_penalty\n    return priorities",
    "response_id": 7,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response8.txt_stdout.txt",
    "code_path": "problem_iter2_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Very high priority for near-perfect fits\n    perfect_fit = np.isclose(bins_remain_cap, item, atol=1e-6)\n    priorities[perfect_fit] = 1000.0\n\n    # High priority for bins where item fits, and remaining space is small\n    fits = bins_remain_cap >= item\n    if np.any(fits):  # Avoid potential division by zero if no bin fits.\n        remaining_space = bins_remain_cap[fits] - item\n        priorities[fits] = 500.0 / (remaining_space + 0.001)\n\n    # Moderate priority boost for bins with larger remaining capacity (but that can still fit)\n    if np.any(fits):\n        max_cap = np.max(bins_remain_cap)\n        if max_cap > 0: #Prevent division by 0\n            priorities[fits] += (bins_remain_cap[fits] / max_cap) * 100\n\n    # Small negative priority for bins that don't fit, to ensure they are considered last\n    priorities[~fits] = -0.00001\n\n    return priorities",
    "response_id": 8,
    "obj": 68.0993218986837,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response9.txt_stdout.txt",
    "code_path": "problem_iter2_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Rule 1: Infeasible bins get a large negative priority.\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -1e9\n\n    # Rule 2: Quantify \"good fit\" using relative wasted space.\n    # A good fit minimizes the *ratio* of wasted space to the item size.\n    available_bins = bins_remain_cap >= item\n    if np.any(available_bins):\n        wasted_space = bins_remain_cap[available_bins] - item\n        relative_wasted_space = wasted_space / item\n        \n        # Good fit = low relative wasted space.  Invert and scale.\n        # Add a small constant to the denominator to avoid division by zero and smooth the function.\n        priorities[available_bins] = 1.0 / (0.01 + relative_wasted_space)\n\n        #Further improve good fit by considering bin occupancy, penalize bins which are empty or almost full.\n        occupancy = 1.0 - bins_remain_cap[available_bins]\n        occupancy_penalty = np.abs(occupancy - 0.5) #Bins that are near half full are preferable.\n\n        priorities[available_bins] -= occupancy_penalty * 0.2\n\n    # Rule 3: Add some noise to break ties randomly.\n    available_bins = bins_remain_cap >= item\n    priorities[available_bins] += np.random.normal(0, 1e-6, size=np.sum(available_bins))\n\n    return priorities",
    "response_id": 9,
    "obj": 4.048663741523748,
    "exec_success": true
  }
]