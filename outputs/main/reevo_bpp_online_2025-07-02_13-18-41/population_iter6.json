[
  {
    "stdout_filepath": "problem_iter6_response0.txt_stdout.txt",
    "code_path": "problem_iter6_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Feasibility check: Only consider bins that can fit the item\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        return priorities  # No bin can fit the item\n\n    # Calculate remaining capacity after placing the item (for feasible bins only)\n    remaining_capacity_after_placement = bins_remain_cap[feasible_bins] - item\n\n    # Heuristic 1: Try to fill bins as much as possible (minimize wasted space).\n    # Prioritize bins where remaining capacity after placement is small.\n    priorities[feasible_bins] = -remaining_capacity_after_placement\n\n    # Heuristic 2: Avoid creating bins with tiny remaining capacities (fragmentation).\n    # Penalize bins that result in very small remaining capacity after placement.\n    tiny_capacity_threshold = 0.1\n    fragmentation_penalty = -100\n    priorities[feasible_bins & (remaining_capacity_after_placement < tiny_capacity_threshold)] += fragmentation_penalty\n\n    # Heuristic 3: Give a bonus for near-full bins after placement. Incentivize finishing bins.\n    near_full_bonus_threshold = 0.05  # If the remaining space is less than 5% of bin size, strongly prioritize this bin. Assume bin_size = 1.\n    near_full_bonus = 100\n    priorities[feasible_bins & (remaining_capacity_after_placement <= near_full_bonus_threshold)] += near_full_bonus\n\n    # Heuristic 4: If an item fills a bin, highly prioritize it\n    exact_fit_bonus = 500\n    priorities[feasible_bins & (remaining_capacity_after_placement == 0)] += exact_fit_bonus\n\n    # Heuristic 5: Moderate Fragmentation Penalty Adjustment\n    moderate_frag_threshold = 0.25\n    moderate_frag_penalty = -20\n    priorities[feasible_bins & (remaining_capacity_after_placement > tiny_capacity_threshold) & (remaining_capacity_after_placement <= moderate_frag_threshold)] += moderate_frag_penalty\n\n    # Adaptive penalty based on item size and remaining capacity\n    item_size_factor = item\n    remaining_cap_factor = np.mean(bins_remain_cap)  # Use mean of *all* bins, not just feasible ones\n\n    # Adjust fragmentation penalty based on item size\n    adjusted_frag_penalty = fragmentation_penalty * (1 + item_size_factor)\n    priorities[feasible_bins & (remaining_capacity_after_placement < tiny_capacity_threshold)] += adjusted_frag_penalty\n\n    # Adjust near full bonus based on remaining capacity of all bins\n    adjusted_near_full_bonus = near_full_bonus * (1 - remaining_cap_factor)\n    priorities[feasible_bins & (remaining_capacity_after_placement <= near_full_bonus_threshold)] += adjusted_near_full_bonus\n\n    # Add a small bonus for bins that are already partially full (but not too full)\n    # This encourages using existing bins before opening new ones\n    partially_full_threshold = 0.2 # Bin must be at least 20% full\n    partially_full_bonus = 10\n    initial_fill = 1 - bins_remain_cap[feasible_bins]\n    priorities[feasible_bins & (initial_fill >= partially_full_threshold) ] += partially_full_bonus\n\n    return priorities",
    "response_id": 0,
    "obj": 5.195452732349436,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response1.txt_stdout.txt",
    "code_path": "problem_iter6_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Infeasible bins get a large negative priority\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -1e9\n\n    # Calculate remaining space after placing the item\n    remaining_space = bins_remain_cap - item\n    remaining_space[remaining_space < 0] = np.inf  # Mark infeasible bins\n\n    # Capacity ratio\n    capacity_ratio = item / bins_remain_cap\n\n    # Reward near-full bins, penalize large gaps\n    near_full_threshold = 0.95\n    large_gap_threshold = 0.2\n\n    near_full_bonus = 7.0\n    large_gap_penalty = -5.0\n\n    near_full_bins = (capacity_ratio > near_full_threshold) & (~infeasible_bins)\n    large_gap_bins = (remaining_space / bins_remain_cap) > large_gap_threshold\n\n    priorities[near_full_bins] += near_full_bonus\n    priorities[large_gap_bins & ~infeasible_bins] += large_gap_penalty\n\n    # Fill density reward, scaled adaptively\n    priorities[~infeasible_bins] += capacity_ratio[~infeasible_bins] * (3 + 2 * capacity_ratio[~infeasible_bins])\n\n    # Adaptive penalty for excessive waste relative to item size\n    waste_ratio = remaining_space / item\n    excessive_waste = waste_ratio > 0.8\n    priorities[excessive_waste & ~infeasible_bins] -= 4 * waste_ratio[excessive_waste & ~infeasible_bins]\n\n    # Adaptive bonus for filling close to the bin's capacity\n    fullness_threshold = 0.6\n    fullness_ratio = item / bins_remain_cap\n    high_fullness = fullness_ratio > fullness_threshold\n    priorities[high_fullness & ~infeasible_bins] += 5 * fullness_ratio[high_fullness & ~infeasible_bins]\n\n    # Encourage bins that are at least half full\n    halfway_full = capacity_ratio > 0.5\n    priorities[halfway_full & ~infeasible_bins] += 1.5\n\n    # Noise for tie-breaking, scaled by remaining capacity\n    noise_std = 1e-6 * bins_remain_cap[~infeasible_bins]\n    priorities[~infeasible_bins] += np.random.normal(0, noise_std, size=np.sum(~infeasible_bins))\n\n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response2.txt_stdout.txt",
    "code_path": "problem_iter6_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Mark infeasible bins with a very low priority\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -1e9\n\n    # Calculate wasted space after placing the item\n    wasted_space = bins_remain_cap - item\n    wasted_space[wasted_space < 0] = np.inf  # Ensure infeasible bins have infinite wasted space\n\n    # Tight-Fit Reward: Favor bins with minimal wasted space relative to item size and bin capacity\n    # A higher reward is given if the item fills a significant portion of the bin.\n    tight_fit_score = (item / bins_remain_cap) * (1 - wasted_space / bins_remain_cap)\n    priorities[~infeasible_bins] += tight_fit_score[~infeasible_bins] * 10\n\n    # Large-Gap Penalty: Penalize bins where the wasted space is a significant fraction of the bin's capacity.\n    large_gap_threshold = 0.6  # Tune this threshold to control how much wasted space is acceptable\n    large_gap_penalty = -5  # Tune the penalty strength\n    large_gap = wasted_space / bins_remain_cap > large_gap_threshold\n    priorities[large_gap] += large_gap_penalty\n\n    # Fill-Level Adaptation: Adjust the priority based on how full the bin will be after placing the item.\n    # This encourages using partially filled bins while avoiding excessive fragmentation.\n    fill_level = 1 - wasted_space / bins_remain_cap\n    adaptive_factor = np.clip(fill_level * 3, -1, 1)  # Scale and clip the factor for stability\n    priorities[~infeasible_bins] += adaptive_factor[~infeasible_bins]\n\n    # Small remaining capacity reward\n    small_remaining_capacity_threshold = 0.15\n    small_remaining_capacity_reward = 2\n    small_remaining = wasted_space / bins_remain_cap < small_remaining_capacity_threshold\n    priorities[small_remaining] += small_remaining_capacity_reward\n    \n\n    # Tie-Breaking Noise: Add small random noise to break ties and explore different packing configurations.\n    priorities[~infeasible_bins] += np.random.normal(0, 1e-6, size=np.sum(~infeasible_bins))\n\n    return priorities",
    "response_id": 2,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response3.txt_stdout.txt",
    "code_path": "problem_iter6_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Infeasible bins get a very low priority\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -1e9\n\n    # Calculate remaining capacity after placing the item\n    remaining_capacity = bins_remain_cap - item\n    remaining_capacity[remaining_capacity < 0] = np.inf\n\n    # Fill ratio\n    fill_ratio = item / bins_remain_cap\n\n    # Tight-Fit Reward (scaled)\n    tight_fit_reward_scale = 5  # Adjust scaling factor as needed\n    tight_fit_reward = (1 - remaining_capacity / bins_remain_cap) * fill_ratio * tight_fit_reward_scale\n    priorities[~infeasible_bins] += tight_fit_reward[~infeasible_bins]\n\n    # Fragmentation Penalty (Adaptive)\n    fragmentation_penalty_scale = -2  # Adjust scaling factor as needed\n    fragmentation_threshold = 0.8  # Adjust threshold for large fragmentation\n\n    fragmentation_penalty = np.where(remaining_capacity / bins_remain_cap > fragmentation_threshold,\n                                      (remaining_capacity / bins_remain_cap) * fragmentation_penalty_scale,\n                                      0)\n\n    priorities[~infeasible_bins] += fragmentation_penalty[~infeasible_bins]\n\n    # Near-Full Reward (Adaptive)\n    near_full_reward_scale = 3  # Adjust scaling factor as needed\n    near_full_threshold = 0.95  # Adjust threshold for near-full\n\n    near_full_reward = np.where((bins_remain_cap - item) / bins_remain_cap > near_full_threshold,\n                                  near_full_reward_scale,\n                                  0)\n\n    priorities[~infeasible_bins] += near_full_reward[~infeasible_bins]\n\n    # Balanced Fill Level Bonus (Adaptive)\n    balanced_fill_bonus_scale = 1 # Adjust scaling factor as needed\n    balanced_lower_threshold = 0.6\n    balanced_upper_threshold = 0.9\n\n    balanced_fill_bonus = np.where(\n        (~infeasible_bins) & (fill_ratio >= balanced_lower_threshold) & (fill_ratio <= balanced_upper_threshold),\n        balanced_fill_bonus_scale,\n        0\n    )\n    priorities[~infeasible_bins] += balanced_fill_bonus[~infeasible_bins]\n\n    # Tie-breaking Noise\n    priorities[~infeasible_bins] += np.random.normal(0, 1e-6, size=np.sum(~infeasible_bins))\n\n    return priorities",
    "response_id": 3,
    "obj": 4.567211806940562,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response4.txt_stdout.txt",
    "code_path": "problem_iter6_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Infeasibility penalty: very low priority if item doesn't fit\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -1e9\n\n    # Calculate remaining capacity after placing item.\n    remaining_capacities = bins_remain_cap - item\n    remaining_capacities[remaining_capacities < 0] = -1  # To avoid -inf in subsequent calculations.\n\n    # Available bins (where item fits).\n    available_bins = bins_remain_cap >= item\n\n    if np.any(available_bins):  # Prevents errors if all bins are infeasible\n        # Tight-fit bonus: prioritize bins where the item fills a large portion\n        capacity_ratio = item / bins_remain_cap[available_bins]\n        priorities[available_bins] += 3 * capacity_ratio  # Increased weight. Emphasize tight fit\n\n        # Waste penalty: reduce priority if too much space is wasted\n        waste_ratio = remaining_capacities[available_bins] / bins_remain_cap[available_bins]\n        priorities[available_bins] -= 2 * waste_ratio**2  # Aggressive penalty for significant waste\n\n        # Fragmentation penalty: penalize bins with small remaining capacities after placing the item.\n        small_remaining_threshold = 0.2\n        small_remaining_bins = remaining_capacities[available_bins] / bins_remain_cap[available_bins] < small_remaining_threshold\n        priorities[available_bins][small_remaining_bins] -= 1  # Moderate penalty for fragmentation\n\n        # Near-full penalty. Avoid bins that become almost full.\n        near_full_threshold = 0.9\n        near_full_bins = (bins_remain_cap[available_bins] - item) / bins_remain_cap[available_bins] < (1 - near_full_threshold)\n        priorities[available_bins][near_full_bins] -= 1.5 # Higher near-full penalty.\n\n        # Bonus for filling bins reasonably well without over-filling\n        reasonable_fill_threshold_low = 0.6\n        reasonable_fill_threshold_high = 0.9\n        reasonably_filled_bins = (capacity_ratio > reasonable_fill_threshold_low) & (capacity_ratio < reasonable_fill_threshold_high)\n        priorities[available_bins][reasonably_filled_bins] += 0.5 # small bonus\n\n        # Add a small random noise to break ties, scaled by remaining capacity\n        noise_std = 1e-6 * bins_remain_cap[available_bins]\n        priorities[available_bins] += np.random.normal(0, noise_std, size=np.sum(available_bins))\n\n    return priorities",
    "response_id": 4,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response5.txt_stdout.txt",
    "code_path": "problem_iter6_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Infeasible bins get a large negative priority\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -1e9\n\n    # Calculate wasted space if item is placed in each bin\n    wasted_space = bins_remain_cap - item\n    wasted_space[wasted_space < 0] = np.inf  # Mark infeasible bins\n\n    # Capacity ratio based tight fit\n    capacity_ratio = item / bins_remain_cap\n    tight_fit_priority = np.exp(-10 * np.abs(capacity_ratio - 1)) # Peaks at capacity ratio = 1 (item == remaining capacity)\n\n    priorities[~infeasible_bins] += tight_fit_priority[~infeasible_bins] * 10 # Scale tight fit priority\n\n    # Large gap penalty\n    gap_ratio = wasted_space / bins_remain_cap\n    large_gap_penalty = (gap_ratio > 0.8) * (gap_ratio * 10)  # Penalize gaps exceeding 80% of bin size\n    priorities[~infeasible_bins] -= large_gap_penalty[~infeasible_bins]\n\n    # Near-full bin reward\n    near_full_threshold = 0.95\n    near_full_reward = ((bins_remain_cap - item) / bins_remain_cap > near_full_threshold) * 5\n    priorities[~infeasible_bins] += near_full_reward[~infeasible_bins]\n\n    # Adaptive penalty/bonus based on bin utilization\n    bin_utilization = (bins_remain_cap - wasted_space) / bins_remain_cap  # Fraction of the bin that would be filled\n    adaptive_factor = np.clip(bin_utilization, 0, 1)\n    priorities[~infeasible_bins] += adaptive_factor[~infeasible_bins] * 3 # Reward higher utilization\n    \n    # Small item bonus: Preferentially use bins with higher remaining capacity if the item is small\n    small_item_threshold = 0.1\n    if item < small_item_threshold:\n        priorities[~infeasible_bins] += bins_remain_cap[~infeasible_bins] * 0.1\n\n    # Noise for tie-breaking\n    priorities[~infeasible_bins] += np.random.normal(0, 1e-6, size=np.sum(~infeasible_bins))\n\n    return priorities",
    "response_id": 5,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response6.txt_stdout.txt",
    "code_path": "problem_iter6_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Infeasibility: Assign a very large negative priority to infeasible bins\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -1e9\n\n    # 2. Remaining Capacity Ratio: Encourage bins where item fills a significant portion\n    capacity_ratio = item / bins_remain_cap\n    # Apply sigmoid-like function centered around 1 to prioritize bins where item nearly fills it\n    fill_priority = 1 / (1 + np.exp(-10 * (capacity_ratio - 0.95)))  # Higher if closer to full\n    priorities[~infeasible_bins] += fill_priority[~infeasible_bins] * 50\n\n    # 3. Waste Ratio Penalty: Penalize large remaining space after placing the item\n    wasted_space = bins_remain_cap - item\n    wasted_space[wasted_space < 0] = 0  # Treat infeasible bins as no waste for calculation\n\n    waste_ratio = wasted_space / bins_remain_cap\n    waste_penalty = waste_ratio**2 * 20  # Square it to penalize even larger waste more\n    priorities[~infeasible_bins] -= waste_penalty[~infeasible_bins]\n    \n    # 4. Near Full Reward: Bonus for filling up bins close to their max\n    near_full_threshold = 0.98\n    near_full_bonus = ((bins_remain_cap - item) / bins_remain_cap < (1 - near_full_threshold)) * 100\n    priorities[~infeasible_bins] += near_full_bonus[~infeasible_bins]\n    \n\n    # 5. Adaptive Scaling: Adjust the magnitude of priority based on remaining capacity\n    remaining_capacity_ratio = bins_remain_cap / np.max(bins_remain_cap) # Scale remaining capacity\n\n    priorities[~infeasible_bins] *= (1+ remaining_capacity_ratio[~infeasible_bins] * 0.1)  # slight preference for bins with larger remaining capacity\n\n    # 6. Noise for Tie-breaking: Add tiny random noise to break ties\n    priorities[~infeasible_bins] += np.random.normal(0, 1e-6, size=np.sum(~infeasible_bins))\n\n    return priorities",
    "response_id": 6,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response7.txt_stdout.txt",
    "code_path": "problem_iter6_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Rule 1: Infeasible bins get a large negative priority.\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -1e9\n\n    # Rule 2: Quantify \"good fit\" using relative wasted space.\n    # A good fit minimizes the *ratio* of wasted space to the item size.\n    available_bins = bins_remain_cap >= item\n    if np.any(available_bins):\n        wasted_space = bins_remain_cap[available_bins] - item\n        relative_wasted_space = wasted_space / (item + 0.001)  # Add small constant to avoid division by zero\n        \n        # Good fit = low relative wasted space.  Invert and scale.\n        priorities[available_bins] = 1.0 / (0.01 + relative_wasted_space)\n\n        # Further improve good fit by considering bin occupancy, penalize extremes.\n        occupancy = 1.0 - bins_remain_cap[available_bins] / np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else 1.0 #handle edge case where max cap is zero\n        occupancy_penalty = np.abs(occupancy - 0.75) # Bins that are near 75% full are preferable.\n        priorities[available_bins] -= occupancy_penalty * 0.5\n\n    # Rule 3: Prioritize almost full bins to complete them\n    almost_full = (bins_remain_cap >= item) & (bins_remain_cap - item < 0.1)\n    priorities[almost_full] += 10  # Give a significant bonus to almost full bins\n    \n    # Rule 4: Add some noise to break ties randomly.\n    available_bins = bins_remain_cap >= item\n    priorities[available_bins] += np.random.normal(0, 1e-6, size=np.sum(available_bins))\n\n    return priorities",
    "response_id": 7,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response8.txt_stdout.txt",
    "code_path": "problem_iter6_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Rule 1: Infeasible bins get a large negative priority.\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -1e9\n\n    # Rule 2: Quantify \"good fit\" using relative wasted space.\n    # A good fit minimizes the *ratio* of wasted space to the item size.\n    available_bins = bins_remain_cap >= item\n    if np.any(available_bins):\n        wasted_space = bins_remain_cap[available_bins] - item\n        relative_wasted_space = wasted_space / item\n\n        # Good fit = low relative wasted space.  Invert and scale.\n        # Add a small constant to the denominator to avoid division by zero and smooth the function.\n        priorities[available_bins] = 1.0 / (0.01 + relative_wasted_space)\n\n        # Further improve good fit by considering bin occupancy, penalize bins which are empty or almost full.\n        bin_size = np.max(bins_remain_cap)\n        if bin_size > 0:\n            occupancy = 1.0 - bins_remain_cap[available_bins] / bin_size\n            occupancy_penalty = np.abs(occupancy - 0.5)  # Bins that are near half full are preferable.\n            priorities[available_bins] -= occupancy_penalty * 0.2\n        else:\n            priorities[available_bins] -= 0.2 # if bin size is zero, add default penalty\n\n    # Rule 3: Prioritize almost full bins to complete them\n    almost_full_threshold = 0.1\n    almost_full = (bins_remain_cap >= item) & (bins_remain_cap - item <= almost_full_threshold)\n    priorities[almost_full] += 10  # Give a significant bonus to almost full bins\n\n    # Rule 4: Add some noise to break ties randomly.\n    available_bins = bins_remain_cap >= item\n    priorities[available_bins] += np.random.normal(0, 1e-6, size=np.sum(available_bins))\n\n    return priorities",
    "response_id": 8,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response9.txt_stdout.txt",
    "code_path": "problem_iter6_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Rule 1: Infeasible bins get a very negative priority.\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -1e9\n\n    # Rule 2: Quantify \"good fit\" using relative wasted space.\n    # A good fit minimizes the *ratio* of wasted space to the item size.\n    available_bins = bins_remain_cap >= item\n    if np.any(available_bins):\n        wasted_space = bins_remain_cap[available_bins] - item\n        relative_wasted_space = wasted_space / (item + 1e-9) # avoid division by zero if item is 0\n\n        # Good fit = low relative wasted space.  Invert and scale.\n        # Add a small constant to the denominator to avoid division by zero and smooth the function.\n        priorities[available_bins] = 1.0 / (0.01 + relative_wasted_space)\n\n        # Further improve good fit by considering bin occupancy, penalize bins which are empty or almost full.\n        occupancy = 1.0 - bins_remain_cap[available_bins] / np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else 0.0 #handle edge case where max cap is zero\n        occupancy_penalty = np.abs(occupancy - 0.5) #Bins that are near half full are preferable.\n\n        priorities[available_bins] -= occupancy_penalty * 0.2\n\n        #Reward bins approaching a target fullness (e.g., 75%)\n        target_fullness = 0.75 * np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else 0.0\n        target_range = 0.1 * np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else 0.1 #Scale relative to maximum bin size.\n        \n        target_bonus = np.exp(-((bins_remain_cap[available_bins] - item - target_fullness)**2) / (2 * target_range**2))\n        priorities[available_bins] += target_bonus * 0.5\n\n\n    # Rule 3: Prioritize almost full bins to complete them, but make it relative to bin size.\n    almost_full = (bins_remain_cap >= item) & (bins_remain_cap - item < 0.1 * np.max(bins_remain_cap) if np.max(bins_remain_cap)>0 else bins_remain_cap >=item )\n    priorities[almost_full] += 10  # Give a significant bonus to almost full bins\n\n    # Rule 4: Add some noise to break ties randomly.\n    available_bins = bins_remain_cap >= item\n    priorities[available_bins] += np.random.normal(0, 1e-6, size=np.sum(available_bins))\n\n    return priorities",
    "response_id": 9,
    "obj": 3.9688871160749857,
    "exec_success": true
  }
]