[
  {
    "stdout_filepath": "problem_iter4_response0.txt_stdout.txt",
    "code_path": "problem_iter4_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Feasibility check: Only consider bins that can fit the item\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        return priorities  # No bin can fit the item\n\n    # Calculate remaining capacity after placing the item (for feasible bins only)\n    remaining_capacity_after_placement = bins_remain_cap[feasible_bins] - item\n\n    # Heuristic 1: Minimize fragmentation. Penalize small remaining capacities more heavily.\n    tiny_capacity_threshold = 0.1\n    fragmentation_penalty = -1000  # Increased penalty for fragmentation\n    priorities[feasible_bins & (remaining_capacity_after_placement < tiny_capacity_threshold)] += fragmentation_penalty\n\n    # Heuristic 2: Reward near-full bins. Strong incentive to finish bins.\n    near_full_bonus_threshold = 0.05\n    near_full_bonus = 500  # Increased bonus for near-full bins\n    priorities[feasible_bins & (remaining_capacity_after_placement <= near_full_bonus_threshold)] += near_full_bonus\n\n    # Heuristic 3: Exact fit is ideal!  Much higher priority\n    exact_fit_bonus = 1000  # Even higher bonus for exact fit\n    priorities[feasible_bins & (remaining_capacity_after_placement == 0)] += exact_fit_bonus\n\n    # Heuristic 4: Penalize bins with significant remaining capacity after placement.\n    # This encourages filling bins to a reasonable level.\n    large_capacity_threshold = 0.5\n    large_capacity_penalty = -50\n    priorities[feasible_bins & (remaining_capacity_after_placement > large_capacity_threshold)] += large_capacity_penalty\n\n    # Heuristic 5: Moderate remaining cap penalty - avoids completely empty bins if possible\n    very_large_capacity_threshold = 0.9\n    very_large_capacity_penalty = -100\n    priorities[feasible_bins & (remaining_capacity_after_placement > very_large_capacity_threshold)] += very_large_capacity_penalty\n    # Heuristic 6: Base priority based on fill percentage.  Prioritizes bins with higher fill %\n    fill_percentage = (bins_remain_cap[feasible_bins] - remaining_capacity_after_placement) / 1.0 # Assume bin size is 1\n    priorities[feasible_bins] += fill_percentage * 10 # Scale fill percentage into priority score\n\n\n    return priorities",
    "response_id": 0,
    "obj": 4.198244914240141,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response1.txt_stdout.txt",
    "code_path": "problem_iter4_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Initialize with a small negative value for bins that can't fit the item.\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -1e9\n\n    # Calculate remaining capacity after placing item.\n    remaining_capacities = bins_remain_cap - item\n\n    # Define the available bins (bins where item fits).\n    available_bins = ~infeasible_bins\n\n    # Prioritize bins that are a good fit (not too much waste, not too little space).\n    # A bin is a good fit if (remaining_capacities / item) is close to 0\n    # and item/bin_remain_cap is close to 1.\n    waste_ratio = remaining_capacities[available_bins] / bins_remain_cap[available_bins]\n    fill_ratio = item / bins_remain_cap[available_bins]\n\n    priorities[available_bins] = 1 - np.abs(waste_ratio - 0.0) - np.abs(fill_ratio - 1.0)\n\n\n    # Scale by inverse bin size to prefer filling smaller bins first.\n    priorities[available_bins] /= (bins_remain_cap[available_bins] + 0.1)\n\n    # Add small noise to break ties.\n    priorities[available_bins] += np.random.normal(0, 1e-6, size=np.sum(available_bins))\n\n    return priorities",
    "response_id": 1,
    "obj": 4.058635819704831,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response2.txt_stdout.txt",
    "code_path": "problem_iter4_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Infeasible bins get a very low priority\n    priorities[bins_remain_cap < item] = -1e9\n\n    # Calculate remaining capacity\n    remaining_capacities = bins_remain_cap - item\n\n    # Only consider feasible bins\n    available_bins = bins_remain_cap >= item\n\n    # Best Fit Criterion with a relative waste metric\n    # Prioritize bins where the ratio of remaining capacity to item size is small\n    waste_ratio = remaining_capacities[available_bins] / item\n    priorities[available_bins] = -waste_ratio\n\n    # Fill Rate Criterion:\n    # Also, prioritize bins where the item fills a significant portion of the bin\n    fill_rate = item / bins_remain_cap[available_bins]\n    priorities[available_bins] += fill_rate\n\n    # Combination of waste and fill rate, balanced with bin capacity\n    combined_metric = (fill_rate - np.abs(waste_ratio)) / (1 + bins_remain_cap[available_bins])\n    priorities[available_bins] = combined_metric\n  \n    # Bonus for using bins that are neither too full nor too empty.  Balances fragmentation and efficiency.\n    # A good range for the fill rate might be between 0.5 and 0.9.\n    good_fill_bins = available_bins & (fill_rate >= 0.5) & (fill_rate <= 0.9)\n    priorities[good_fill_bins] += 0.1 # Small constant bonus\n    \n    # Add small random noise to break ties\n    priorities[available_bins] += np.random.normal(0, 1e-6, size=np.sum(available_bins))\n\n    return priorities",
    "response_id": 2,
    "obj": 6.721180694056652,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response3.txt_stdout.txt",
    "code_path": "problem_iter4_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Rule 1: Infeasible bins get a large negative priority.\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -1e9\n\n    # Rule 2: Quantify \"good fit\" using relative wasted space.\n    # A good fit minimizes the *ratio* of wasted space to the item size.\n    available_bins = bins_remain_cap >= item\n    if np.any(available_bins):\n        wasted_space = bins_remain_cap[available_bins] - item\n        relative_wasted_space = wasted_space / item\n        \n        # Good fit = low relative wasted space.  Invert and scale.\n        # Add a small constant to the denominator to avoid division by zero and smooth the function.\n        priorities[available_bins] = 1.0 / (0.01 + relative_wasted_space)\n\n        #Further improve good fit by considering bin occupancy, penalize bins which are empty or almost full.\n        occupancy = 1.0 - bins_remain_cap[available_bins] / np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else 1.0 #handle edge case where max cap is zero\n        occupancy_penalty = np.abs(occupancy - 0.5) #Bins that are near half full are preferable.\n\n        priorities[available_bins] -= occupancy_penalty * 0.2\n\n    # Rule 3: Prioritize almost full bins to complete them\n    almost_full = (bins_remain_cap >= item) & (bins_remain_cap - item < 0.1)\n    priorities[almost_full] += 10  # Give a significant bonus to almost full bins\n    \n    # Rule 4: Add some noise to break ties randomly.\n    available_bins = bins_remain_cap >= item\n    priorities[available_bins] += np.random.normal(0, 1e-6, size=np.sum(available_bins))\n\n    return priorities",
    "response_id": 3,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response4.txt_stdout.txt",
    "code_path": "problem_iter4_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: Assign -inf priority to bins that can't fit the item\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -np.inf\n\n    # 2. First-Fit-Decreasing Inspired: Give higher priority to bins with smaller remaining capacity that *can* fit the item.\n    #    Rationale: Prefer filling bins that are already somewhat full to avoid creating many near-empty bins.\n    feasible_bins = ~infeasible_bins\n    remaining_space_after_fit = bins_remain_cap[feasible_bins] - item\n\n    # Linear penalty scaled by inverse bin size. Add a small constant to remaining capacity for numerical stability.\n    priorities[feasible_bins] = -remaining_space_after_fit + (0.5 / (bins_remain_cap[feasible_bins] + 1e-9))\n\n    # 3. Avoidance of near-full bins: slightly reduced priorities for near full bins. Reduce penalty as bin gets large to avoid over penalizing\n    near_full_bins = (bins_remain_cap >= item) & (bins_remain_cap - item < 0.1)  # Bins close to being full after fitting the item\n    priorities[near_full_bins] -= 0.05 * (1 / (bins_remain_cap[near_full_bins] + 1e-9))\n\n    # 4. Encourage filling bins as much as possible, relative to the item size.\n    #  This helps prioritize bins that are a good fit for the item without necessarily being near-full already.\n    fill_ratio = item / bins_remain_cap[feasible_bins]\n    priorities[feasible_bins] += fill_ratio * 0.1  # Small bonus\n\n    return priorities",
    "response_id": 4,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response5.txt_stdout.txt",
    "code_path": "problem_iter4_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Rule 1: Feasibility - Bins that cannot fit the item get negative infinity priority.\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] = -np.inf\n\n    # Rule 2: Prioritize fitting - Give a substantial base priority to feasible bins\n    feasible_mask = bins_remain_cap >= item\n    priorities[feasible_mask] += 1.0\n\n    # Rule 3: Invert wasted space - Higher priority to tighter fits (smaller wasted space)\n    wasted_space = bins_remain_cap - item\n    wasted_space[~feasible_mask] = np.inf  # penalize infeasible bins by making their wasted space infinite\n    priorities[feasible_mask] += 1.0 / (1.0 + wasted_space[feasible_mask])  # smaller wasted space -> higher priority\n\n    # Rule 4: Penalize near-full bins (but only if the item fits)\n    almost_full = feasible_mask & (bins_remain_cap - item <= 0.1)\n    priorities[almost_full] -= 0.5\n\n    # Rule 5: Small items prefer low occupancy, larger small items are less sensitive.\n    if 0.0 < item <= 0.3:\n        occupancy = 1.0 - bins_remain_cap / np.max(bins_remain_cap)\n        priority_boost = (1.0 - occupancy[feasible_mask]) * (0.4 - item * (0.4/0.3))  # Scale occupancy bonus based on item size\n        priorities[feasible_mask] += priority_boost\n\n    # Rule 6: Reward bins approaching target fullness, scaled by item size.\n    target_fullness = 0.75\n    target_range = 0.1\n    approaching_target = feasible_mask & (bins_remain_cap > item) & (bins_remain_cap - item <= target_fullness * np.max(bins_remain_cap) + target_range) & (bins_remain_cap - item >= target_fullness * np.max(bins_remain_cap) - target_range)\n    priorities[approaching_target] += 0.2 * (1 - item) #The smaller the item the better to target fullness\n\n    return priorities",
    "response_id": 5,
    "obj": 4.11846828879138,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response6.txt_stdout.txt",
    "code_path": "problem_iter4_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Infeasible bins get a large negative priority\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -1e9\n\n    # Calculate wasted space if item is placed in each bin\n    wasted_space = bins_remain_cap - item\n    wasted_space[wasted_space < 0] = np.inf  # Mark infeasible bins\n\n    # Tight fit priority: Inverted wasted space, normalized by item size.\n    # Higher is better (less waste). Use a small constant to avoid division by zero if wasted_space is exactly zero.\n    tight_fit_priority = 1 / (wasted_space + 1e-9) * item\n    priorities[~infeasible_bins] += tight_fit_priority[~infeasible_bins]\n\n    # Avoid near-full bins penalty: Penalize bins that become almost full after placement.\n    near_full_threshold = 0.95\n    almost_full = (bins_remain_cap - item) / bins_remain_cap < (1 - near_full_threshold)\n    priorities[almost_full] -= 10\n\n    # Fill density: encourage bins to be as close to full as possible.\n    fill_density = item / bins_remain_cap\n    priorities[~infeasible_bins] += fill_density[~infeasible_bins] * 5 # scale fill_density to have better impact\n\n    # Bonus for filling bins more than half way\n    half_full_threshold = 0.5\n    more_than_half_full = (bins_remain_cap - item) / bins_remain_cap < half_full_threshold\n    priorities[more_than_half_full] += 2\n\n    # Add tiny noise for tie-breaking\n    priorities[~infeasible_bins] += np.random.normal(0, 1e-6, size=np.sum(~infeasible_bins))\n\n    return priorities",
    "response_id": 6,
    "obj": 4.008775428799367,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response7.txt_stdout.txt",
    "code_path": "problem_iter4_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Feasibility check: Only consider bins that can fit the item\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        return priorities  # No bin can fit the item\n\n    # Calculate remaining capacity after placing the item (for feasible bins only)\n    remaining_capacity_after_placement = bins_remain_cap[feasible_bins] - item\n\n    # Heuristic 1: Try to fill bins as much as possible (minimize wasted space).\n    # Prioritize bins where remaining capacity after placement is small.\n    priorities[feasible_bins] = -remaining_capacity_after_placement\n\n    # Heuristic 2: Avoid creating bins with tiny remaining capacities (fragmentation).\n    # Penalize bins that result in very small remaining capacity after placement.\n    tiny_capacity_threshold = 0.1\n    fragmentation_penalty = -100\n    priorities[feasible_bins & (remaining_capacity_after_placement < tiny_capacity_threshold)] += fragmentation_penalty\n\n    # Heuristic 3: Give a bonus for near-full bins after placement. Incentivize finishing bins.\n    near_full_bonus_threshold = 0.05  # If the remaining space is less than 5% of bin size, strongly prioritize this bin. Assume bin_size = 1.\n    near_full_bonus = 100\n    priorities[feasible_bins & (remaining_capacity_after_placement <= near_full_bonus_threshold)] += near_full_bonus\n\n    # Heuristic 4: If an item fills a bin, highly prioritize it\n    exact_fit_bonus = 500\n    priorities[feasible_bins & (remaining_capacity_after_placement == 0)] += exact_fit_bonus\n\n    # Heuristic 5: Moderate Fragmentation Penalty Adjustment\n    moderate_frag_threshold = 0.25\n    moderate_frag_penalty = -20\n    priorities[feasible_bins & (remaining_capacity_after_placement > tiny_capacity_threshold) & (remaining_capacity_after_placement <= moderate_frag_threshold)] += moderate_frag_penalty\n\n    # Adaptive penalty based on item size and remaining capacity\n    item_size_factor = item\n    remaining_cap_factor = np.mean(bins_remain_cap[feasible_bins]) if np.any(feasible_bins) else 0.5\n\n    # Adjust fragmentation penalty based on item size\n    adjusted_frag_penalty = fragmentation_penalty * (1 + item_size_factor)\n    priorities[feasible_bins & (remaining_capacity_after_placement < tiny_capacity_threshold)] += adjusted_frag_penalty\n\n    # Adjust near full bonus based on remaining capacity of other bins\n    adjusted_near_full_bonus = near_full_bonus * (1 - remaining_cap_factor)\n    priorities[feasible_bins & (remaining_capacity_after_placement <= near_full_bonus_threshold)] += adjusted_near_full_bonus\n\n    return priorities",
    "response_id": 7,
    "obj": 5.195452732349436,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response8.txt_stdout.txt",
    "code_path": "problem_iter4_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Initialize with a small negative value for bins that can't fit the item.\n    priorities[bins_remain_cap < item] = -1e9\n\n    # Calculate remaining capacity after placing item.\n    remaining_capacities = bins_remain_cap - item\n    remaining_capacities[remaining_capacities < 0] = -1  # Handle cases where item does not fit\n\n    # Define the available bins (bins where item fits).\n    available_bins = bins_remain_cap >= item\n\n    # Prioritize bins that are a good fit (not too much waste, not too little space).\n    # A bin is a good fit if (remaining_capacities / bins_remain_cap) is small.\n    # Penalize bins that are nearly full after placing the item.\n    \n    if np.any(available_bins):\n      waste_ratio = remaining_capacities[available_bins] / bins_remain_cap[available_bins]\n      \n      # Favor bins with smaller waste ratio\n      priorities[available_bins] = 1 - waste_ratio\n      \n      # Penalize near-full bins to encourage spreading items across bins.\n      near_full_penalty = (remaining_capacities[available_bins] < 0.1 * bins_remain_cap[available_bins]) * 0.5\n      priorities[available_bins] -= near_full_penalty\n      \n      # Normalize by the initial bin capacity (Encourage using smaller bins when possible)\n      priorities[available_bins] /= bins_remain_cap[available_bins]\n\n      # Add small noise to break ties.\n      priorities[available_bins] += np.random.normal(0, 1e-6, size=np.sum(available_bins))\n\n    return priorities",
    "response_id": 8,
    "obj": 5.753889110490631,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response9.txt_stdout.txt",
    "code_path": "problem_iter4_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Infeasibility penalty: very low priority if item doesn't fit\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -1e9\n\n    # Calculate remaining capacity after placing item.\n    remaining_capacities = bins_remain_cap - item\n    remaining_capacities[remaining_capacities < 0] = -1  # To avoid -inf in subsequent calculations. Necessary for zero-sized items.\n\n    # Available bins (where item fits).\n    available_bins = bins_remain_cap >= item\n\n    if np.any(available_bins):  # Prevents errors if all bins are infeasible\n        # Tight-fit bonus: prioritize bins where the item fills a large portion\n        # Prioritize based on the ratio of the item size to the bin's remaining capacity.\n        capacity_ratio = item / bins_remain_cap[available_bins]\n        priorities[available_bins] += 2 * capacity_ratio  # Increased weight\n\n        # Waste penalty: reduce priority if too much space is wasted. Invert wasted space\n        # Penalize bins with a lot of wasted space after placing the item.\n        waste_ratio = remaining_capacities[available_bins] / bins_remain_cap[available_bins]\n        priorities[available_bins] += (1 - waste_ratio)**2  # More aggressive penalty\n\n        # Near-full avoidance: avoid bins that become nearly full, balancing fill density and fragmentation\n        near_full_threshold = 0.95\n        near_full_bins = (bins_remain_cap[available_bins] - item) / bins_remain_cap[available_bins] < (1 - near_full_threshold)\n        priorities[available_bins][near_full_bins] -= 0.75  # Increased penalty.\n\n        # Moderate fragmentation avoidance: penalize bins with very small remaining capacities *after* placing the item.\n        small_remaining_threshold = 0.1\n        small_remaining_bins = remaining_capacities[available_bins] / bins_remain_cap[available_bins] < small_remaining_threshold\n        priorities[available_bins][small_remaining_bins] -= 0.5  # Additional moderate penalty\n\n        # Add a small random noise to break ties\n        priorities[available_bins] += np.random.normal(0, 1e-6, size=np.sum(available_bins))\n\n    return priorities",
    "response_id": 9,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response0.txt_stdout.txt",
    "code_path": "problem_iter5_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Infeasible bins get a large negative priority\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -1e9\n\n    # Calculate wasted space if item is placed in each bin\n    wasted_space = bins_remain_cap - item\n    wasted_space[wasted_space < 0] = np.inf  # Mark infeasible bins\n\n    # Refined fit priority based on capacity ratio: reward near-fits, penalize waste\n    capacity_ratio = item / bins_remain_cap\n    fit_priority = np.exp(-5 * np.abs(1 - capacity_ratio))  # Gaussian-like preference for capacity_ratio close to 1\n    priorities[~infeasible_bins] += fit_priority[~infeasible_bins] * 10 # Scale it\n\n    # Adaptive penalty for bins becoming nearly full\n    near_full_threshold = 0.95\n    remaining_ratio = (bins_remain_cap - item) / bins_remain_cap\n    almost_full = remaining_ratio < (1 - near_full_threshold)\n    penalty_strength = 10 * (1 - remaining_ratio[almost_full])  # Higher penalty for bins *very* close to full\n    priorities[almost_full] -= penalty_strength\n\n    # Encourage bins that are more than halfway to be completely full\n    halfway_threshold = 0.5\n    more_than_halfway = remaining_ratio < halfway_threshold\n    bonus_strength = 5 * (halfway_threshold - remaining_ratio[more_than_halfway])  # Higher bonus if much greater than half\n    priorities[more_than_halfway] += bonus_strength\n\n    # Directly penalize large gaps\n    large_gap_threshold = 0.2\n    large_gap = wasted_space / bins_remain_cap > large_gap_threshold\n    gap_penalty = 2 * wasted_space[large_gap] / bins_remain_cap[large_gap] # Scale penalty by size of gap\n    priorities[large_gap] -= gap_penalty\n\n    # Fill density: encourage bins to be as close to full as possible.\n    fill_density = item / bins_remain_cap\n    priorities[~infeasible_bins] += fill_density[~infeasible_bins] * 2 # scale fill_density to have better impact\n\n    # Adaptive bonus for nearly full bins, scaled to remaining capacity\n    nearly_full_threshold = 0.9\n    nearly_full = (bins_remain_cap - item) / bins_remain_cap > nearly_full_threshold\n    bonus_near_full = 5*(bins_remain_cap[nearly_full] - item)\n    priorities[nearly_full] += bonus_near_full\n\n    # Add small noise for tie-breaking, scaled by bin capacity\n    noise_std = 1e-6 * bins_remain_cap[~infeasible_bins] # noise is proportional to capacity\n    priorities[~infeasible_bins] += np.random.normal(0, noise_std, size=np.sum(~infeasible_bins))\n\n    return priorities",
    "response_id": 0,
    "obj": 5.335061826884723,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response1.txt_stdout.txt",
    "code_path": "problem_iter5_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Infeasible bins get a large negative priority\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -1e9\n\n    # Wasted space ratio\n    wasted_space = bins_remain_cap - item\n    wasted_space_ratio = wasted_space / bins_remain_cap\n    wasted_space_ratio[infeasible_bins] = np.inf\n\n    # Tight fit priority:  Reward bins with minimal wasted space ratio.\n    tight_fit_priority = -wasted_space_ratio\n    priorities[~infeasible_bins] += tight_fit_priority[~infeasible_bins] * 10\n\n    # Large gap penalty: Penalize large wasted space ratios more heavily.\n    large_gap_threshold = 0.8\n    large_gap_penalty = (wasted_space_ratio - large_gap_threshold)\n    large_gap_penalty[wasted_space_ratio <= large_gap_threshold] = 0\n    priorities[wasted_space_ratio > large_gap_threshold] -= large_gap_penalty[wasted_space_ratio > large_gap_threshold] * 20\n\n    # Near full bonus: Reward bins that become near full.\n    near_full_threshold = 0.95\n    remaining_capacity_ratio = (bins_remain_cap - item) / bins_remain_cap\n    near_full_bonus = (near_full_threshold - remaining_capacity_ratio)\n    near_full_bonus[remaining_capacity_ratio >= near_full_threshold] = 0\n    priorities[remaining_capacity_ratio < near_full_threshold] += near_full_bonus[remaining_capacity_ratio < near_full_threshold] * 30\n\n    # Fill Density\n    fill_density = item / bins_remain_cap\n    priorities[~infeasible_bins] += fill_density[~infeasible_bins] * 5\n\n    # Adaptive penalty/bonus based on item size relative to bin capacity.\n    item_ratio = item / bins_remain_cap\n    adaptive_factor = np.clip(item_ratio, 0.1, 0.9)  # Avoid extreme values\n\n    # Penalty for bins that result in low fill\n    low_fill_threshold = 0.2\n    low_fill_penalty = (low_fill_threshold - remaining_capacity_ratio)\n    low_fill_penalty[remaining_capacity_ratio >= low_fill_threshold] = 0\n    priorities[remaining_capacity_ratio < low_fill_threshold] -= low_fill_penalty[remaining_capacity_ratio < low_fill_threshold] * (adaptive_factor * 15)\n\n\n    # Bonus for bins with high fill\n    high_fill_threshold = 0.8\n    high_fill_bonus = (remaining_capacity_ratio - high_fill_threshold)\n    high_fill_bonus[remaining_capacity_ratio <= high_fill_threshold] = 0\n    priorities[remaining_capacity_ratio > high_fill_threshold] -= high_fill_bonus[remaining_capacity_ratio > high_fill_threshold] * (adaptive_factor * 15)\n\n\n    # Add tiny noise for tie-breaking\n    priorities[~infeasible_bins] += np.random.normal(0, 1e-6, size=np.sum(~infeasible_bins))\n\n    return priorities",
    "response_id": 1,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 53, in priority_v2\nValueError: operands could not be broadcast together with shapes (0,) (5000,) \n"
  },
  {
    "stdout_filepath": "problem_iter5_response2.txt_stdout.txt",
    "code_path": "problem_iter5_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Infeasible bins get a large negative priority\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -1e9\n\n    # Calculate wasted space if item is placed in each bin\n    wasted_space = bins_remain_cap - item\n    wasted_space[wasted_space < 0] = np.inf  # Mark infeasible bins\n\n    # Capacity ratio\n    capacity_ratio = item / bins_remain_cap\n    # Tight fit reward, scaled by item size and capacity ratio\n    tight_fit_reward = (1 - wasted_space / bins_remain_cap) * item * capacity_ratio\n    priorities[~infeasible_bins] += tight_fit_reward[~infeasible_bins] * 2\n\n    # Large gap penalty\n    large_gap_threshold = 0.75\n    large_gap_penalty = -10  # Increased penalty\n    large_gap = wasted_space / bins_remain_cap > large_gap_threshold\n    priorities[large_gap] += large_gap_penalty\n\n    # Near-full reward: Bins close to full get a bonus\n    near_full_threshold = 0.95\n    near_full_reward = 5  # Increased reward\n    near_full = (bins_remain_cap - item) / bins_remain_cap > near_full_threshold\n    priorities[near_full] += near_full_reward\n\n    # Adaptive penalty/bonus based on fill level\n    fill_level = 1 - wasted_space / bins_remain_cap\n    adaptive_factor = np.clip(fill_level * 5, -2, 2)  # Scale and clip for stability\n    priorities[~infeasible_bins] += adaptive_factor[~infeasible_bins]\n\n    # Noise for tie-breaking\n    priorities[~infeasible_bins] += np.random.normal(0, 1e-6, size=np.sum(~infeasible_bins))\n\n    return priorities",
    "response_id": 2,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response3.txt_stdout.txt",
    "code_path": "problem_iter5_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Infeasible bins get a large negative priority\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -1e9\n\n    # Calculate wasted space if item is placed in each bin\n    wasted_space = bins_remain_cap - item\n    wasted_space[wasted_space < 0] = np.inf  # Mark infeasible bins\n\n    # Capacity ratio based tight fit\n    capacity_ratio = item / bins_remain_cap\n    tight_fit_priority = np.exp(-10 * np.abs(capacity_ratio - 1)) # Peaks at capacity ratio = 1 (item == remaining capacity)\n\n    priorities[~infeasible_bins] += tight_fit_priority[~infeasible_bins] * 10 # Scale tight fit priority\n\n    # Large gap penalty\n    gap_ratio = wasted_space / bins_remain_cap\n    large_gap_penalty = (gap_ratio > 0.8) * (gap_ratio * 10)  # Penalize gaps exceeding 80% of bin size\n    priorities[~infeasible_bins] -= large_gap_penalty[~infeasible_bins]\n\n    # Near-full bin reward\n    near_full_threshold = 0.95\n    near_full_reward = ((bins_remain_cap - item) / bins_remain_cap < (1 - near_full_threshold)) * 5\n    priorities[~infeasible_bins] += near_full_reward[~infeasible_bins]\n\n    # Adaptive penalty/bonus based on bin utilization\n    bin_utilization = (bins_remain_cap - wasted_space) / bins_remain_cap  # Fraction of the bin that would be filled\n    adaptive_factor = np.clip(bin_utilization, 0, 1)\n    priorities[~infeasible_bins] += adaptive_factor[~infeasible_bins] * 3 # Reward higher utilization\n\n    # Noise for tie-breaking\n    priorities[~infeasible_bins] += np.random.normal(0, 1e-6, size=np.sum(~infeasible_bins))\n\n    return priorities",
    "response_id": 3,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response4.txt_stdout.txt",
    "code_path": "problem_iter5_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Infeasible bins get a large negative priority\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -1e9\n\n    # Calculate remaining space after placing the item\n    remaining_space = bins_remain_cap - item\n    remaining_space[remaining_space < 0] = np.inf  # Mark infeasible bins\n\n    # Capacity ratio\n    capacity_ratio = item / bins_remain_cap\n\n    # Reward near-full bins, penalize large gaps\n    near_full_threshold = 0.9\n    large_gap_threshold = 0.1\n\n    near_full_bonus = 5.0\n    large_gap_penalty = -3.0\n\n    near_full_bins = (remaining_space / bins_remain_cap) < (1 - near_full_threshold)\n    large_gap_bins = (remaining_space / bins_remain_cap) > large_gap_threshold\n    \n    priorities[near_full_bins & ~infeasible_bins] += near_full_bonus\n    priorities[large_gap_bins & ~infeasible_bins] += large_gap_penalty\n\n    # Fill density reward\n    priorities[~infeasible_bins] += capacity_ratio[~infeasible_bins] * 2\n\n    # Adaptive penalty for excessive waste relative to item size\n    waste_ratio = remaining_space / item\n    excessive_waste = waste_ratio > 1.0\n    priorities[excessive_waste & ~infeasible_bins] -= 2 * waste_ratio[excessive_waste & ~infeasible_bins]\n\n    # Adaptive bonus for filling close to the bin's capacity\n    fullness_ratio = item / bins_remain_cap\n    high_fullness = fullness_ratio > 0.7\n    priorities[high_fullness & ~infeasible_bins] += 3 * fullness_ratio[high_fullness & ~infeasible_bins]\n\n    # Noise for tie-breaking\n    priorities[~infeasible_bins] += np.random.normal(0, 1e-6, size=np.sum(~infeasible_bins))\n\n    return priorities",
    "response_id": 4,
    "obj": 4.048663741523748,
    "exec_success": true
  }
]