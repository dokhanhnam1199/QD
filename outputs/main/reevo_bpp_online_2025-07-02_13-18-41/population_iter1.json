[
  {
    "stdout_filepath": "problem_iter1_response0.txt_stdout.txt",
    "code_path": "problem_iter1_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Immediate Fit: High priority if item fits perfectly\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    priorities[perfect_fit] = 1000  # Max priority for perfect fit\n\n    # Best Fit: High priority for bins where item nearly fills bin\n    almost_fit = (bins_remain_cap >= item) & (bins_remain_cap < 2 * item)\n    priorities[almost_fit] = 100 / (bins_remain_cap[almost_fit] - item + 0.001)  # Prioritize smaller wasted space\n\n    # Worst Fit: Low priority (but still possible) for bins with lots of space\n    large_capacity = bins_remain_cap >= 2 * item\n    priorities[large_capacity] = 1 / bins_remain_cap[large_capacity] # Slightly encourage using emptier bins, but not by much\n    \n    # Penalize bins that are too small. Make them extremely undesirable.\n    too_small = bins_remain_cap < item\n    priorities[too_small] = -1000 # Extremely low priority; avoid at all costs\n    \n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response1.txt_stdout.txt",
    "code_path": "problem_iter1_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # 1. Feasibility: Assign -inf priority to bins that can't fit the item\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -np.inf\n    \n    # 2. First-Fit-Decreasing Inspired: Give higher priority to bins with smaller remaining capacity that *can* fit the item.\n    #    Rationale: Prefer filling bins that are already somewhat full to avoid creating many near-empty bins.\n    #    We want to penalize large gaps, so use a decreasing function of the *available* space *after* adding the item.\n    #    Note that we're only considering feasible bins at this point.\n    \n    feasible_bins = ~infeasible_bins\n    remaining_space_after_fit = bins_remain_cap[feasible_bins] - item\n    # A small constant is added to remaining space after fit to avoid possible division by zero error\n    priorities[feasible_bins] = -remaining_space_after_fit + (1/(bins_remain_cap[feasible_bins]+1e-9))  # linear penalty scaled by inverse bin size\n\n    # 3. Avoidance of near-full bins: slightly reduced priorities for near full bins\n    near_full_bins = (bins_remain_cap >= item) & (bins_remain_cap - item < 0.1) #Bins close to being full after fitting the item\n    priorities[near_full_bins] -=0.05\n\n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response2.txt_stdout.txt",
    "code_path": "problem_iter1_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Feasibility: Assign very low priority to bins that cannot fit the item\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] = -np.inf  # Extremely low priority\n\n    # Best Fit Criterion: Prioritize bins where the remaining capacity is close to zero after adding the item.\n    # Avoid fragmentation. Use smaller bins first to save bigger bins for potentially larger items in the future\n    feasible_mask = bins_remain_cap >= item\n    remaining_capacity_after_fit = bins_remain_cap[feasible_mask] - item\n    priorities[feasible_mask] = -remaining_capacity_after_fit  # Smaller remaining capacity is preferred (higher priority)\n\n    # Level the bins with respect to fillness so that some bins are not negligibly used\n    fill_ratios = (bins_remain_cap - item) / bins_remain_cap\n\n    # Bonus for bins that fit well without wasting too much space. Balance between best fit and fragmentation.\n    bonus_mask = (fill_ratios > 0) & (fill_ratios < 0.2) # can be hyper-parameter tuned.\n    priorities[bonus_mask] += 1 # add bonus to give these bin priority\n\n    return priorities",
    "response_id": 2,
    "obj": 4.11846828879138,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response3.txt_stdout.txt",
    "code_path": "problem_iter1_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Rule 1: Prioritize bins that can fit the item\n    fit_mask = bins_remain_cap >= item\n    priorities[fit_mask] += 1  # Give bins that can fit a base priority\n\n    # Rule 2: Prioritize bins with less remaining capacity (among those that fit)\n    #         This encourages filling bins that are already partially full.\n    remaining_capacity_priority = 1 / (bins_remain_cap[fit_mask] + 1e-6)  # Avoid division by zero\n    priorities[fit_mask] += remaining_capacity_priority\n\n    # Rule 3: Add a bonus for bins where the item fills them up nicely (not too much waste)\n    fill_ratio = item / bins_remain_cap[fit_mask]\n    # We want fill_ratio to be close to 1, but not too close (avoid near-perfect fit if many options exist)\n    fill_quality = np.exp(-10 * np.abs(fill_ratio - 0.95)) # Gaussian-like penalty\n    priorities[fit_mask] += fill_quality\n    \n    # Rule 4: Negative priority for bins that cannot fit (discourage exceeding capacity)\n    priorities[~fit_mask] = -1e9 # A very large negative priority if it can't fit\n\n    return priorities",
    "response_id": 3,
    "obj": 4.487435181491823,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response4.txt_stdout.txt",
    "code_path": "problem_iter1_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    # First-Fit Decreasing inspired heuristic: prioritize bins that can fit the item closely\n    fit_mask = bins_remain_cap >= item\n    \n    if np.any(fit_mask): #Only calculate priorities if there is a feasible bin\n        priorities[fit_mask] = bins_remain_cap[fit_mask] - item\n        priorities[~fit_mask] = -np.inf #Setting infeasible bins to -inf\n\n        #Further improve by using relative capacity, avoiding fragmentation\n        relative_capacities = item/ bins_remain_cap[fit_mask]\n        priorities[fit_mask] = -relative_capacities #Invert as we want the smallest capacity *relative to item*\n    else:\n        # If no bin fits, prioritize the fullest bin to minimize number of bins used in the long run\n        priorities = bins_remain_cap\n\n    return priorities",
    "response_id": 4,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 20, in priority_v2\n    remaining_after_pack = bins_remain_cap[fit_mask] - item\nOverflowError: cannot convert float infinity to integer\n"
  },
  {
    "stdout_filepath": "problem_iter1_response5.txt_stdout.txt",
    "code_path": "problem_iter1_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Rule 1: Prefer bins that can fit the item\n    fit_mask = bins_remain_cap >= item\n    priorities[fit_mask] += 1\n\n    # Rule 2: Among bins that can fit, prefer bins with less remaining capacity after packing\n    remaining_after_pack = bins_remain_cap[fit_mask] - item\n    priorities[fit_mask] += 1 / (remaining_after_pack + 0.0001)  # Avoid division by zero\n\n    # Rule 3: Give a small bonus to bins that are almost full.\n    almost_full_mask = (bins_remain_cap > 0) & (bins_remain_cap < 0.2) # Remaining cap less than 20%\n    priorities[almost_full_mask] += 0.5\n    \n    # Rule 4: Large item should be allocated to larger bin if possible\n    priority_add = (item/ np.max(bins_remain_cap)) * bins_remain_cap\n    priorities += priority_add\n    \n\n    return priorities",
    "response_id": 5,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 21, in priority_v2\n    priorities[i] = -1 # assign a low priority to bins that cannot accommodate\nnumpy._core._exceptions._UFuncOutputCastingError: Cannot cast ufunc 'add' output from dtype('float64') to dtype('int64') with casting rule 'same_kind'\n"
  },
  {
    "stdout_filepath": "problem_iter1_response6.txt_stdout.txt",
    "code_path": "problem_iter1_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # First-Fit Decreasing heuristic: prefer bins where the item fits\n    # and prioritize those with less remaining space.\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            priorities[i] = 1 / (cap - item + 1e-9)  # Avoid division by zero\n        else:\n            priorities[i] = -1 # assign a low priority to bins that cannot accommodate\n\n    # Modify priorities based on utilization\n    utilization = 1 - bins_remain_cap / np.max(bins_remain_cap) #Use max cap as reference. If not known, we should estimate that.\n    priorities += utilization\n\n    return priorities",
    "response_id": 6,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 25, in priority_v2\n    # Add a small bonus for bins that are almost full after adding the item to prefer packing more tightly\nnumpy._core._exceptions._UFuncOutputCastingError: Cannot cast ufunc 'add' output from dtype('float64') to dtype('int64') with casting rule 'same_kind'\n"
  },
  {
    "stdout_filepath": "problem_iter1_response7.txt_stdout.txt",
    "code_path": "problem_iter1_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: Rule out bins that can't fit the item\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] = -np.inf  # Or a very small negative number\n\n    # 2. Encourage bins with remaining capacity close to item size (First-Fit Decreasing variant)\n    # Calculate waste if the item is placed in the bin\n    waste = bins_remain_cap - item\n\n    # Give higher priority to bins with smaller waste (but only if feasible)\n    priorities[~infeasible_mask] = -np.abs(waste[~infeasible_mask]) # or 1 / (np.abs(waste[~infeasible_mask]) + 0.00001) or  np.exp(-np.abs(waste[~infeasible_mask]))\n    # Add a small bonus for bins that are almost full after adding the item to prefer packing more tightly\n    almost_full_bonus = np.where((bins_remain_cap - item) < 0.1, 0.5, 0) #if bin is left with less than 0.1 after adding item\n\n    priorities[~infeasible_mask] += almost_full_bonus[~infeasible_mask] # only add bonus to bins where item fits\n\n    # 3. Consider the utilization rate of the bin\n    utilization = item / bins_remain_cap\n    priorities[~infeasible_mask] += utilization[~infeasible_mask]\n\n    return priorities",
    "response_id": 7,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response8.txt_stdout.txt",
    "code_path": "problem_iter1_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Immediate fit gets highest priority\n    immediate_fit = (bins_remain_cap == item)\n    priorities[immediate_fit] = 1000  # High priority\n\n    # Bins that can accommodate the item\n    can_accommodate = (bins_remain_cap >= item)\n    \n    # Prioritize bins that will have the least remaining space after placing item. This heuristic is called Minimum Waste heuristic.\n    waste = bins_remain_cap - item\n    priorities[can_accommodate] = 100 / (waste[can_accommodate] + 0.00001)  # Add a small constant to avoid division by zero\n\n    # Very high priority for almost full bins to prevent large waste at the end\n    almost_full = (bins_remain_cap > item) & (waste <= item/4) #If wasted space is <= a quarter of item size.\n    priorities[almost_full] = 500\n\n    return priorities",
    "response_id": 8,
    "obj": 4.0885520542481055,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response9.txt_stdout.txt",
    "code_path": "problem_iter1_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Feasibility: Assign 0 priority if the item doesn't fit\n    priorities[bins_remain_cap < item] = -np.inf \n    \n    # Score based on remaining capacity after packing\n    remaining_after_pack = bins_remain_cap - item\n    \n    # Prioritize bins where the item fits snugly, but avoid perfect fit.\n    # A near-perfect fit may block us from packing another larger item.\n    # remaining_after_pack + item is bins_remain_cap\n    priorities[bins_remain_cap >= item] = np.exp(-np.abs(remaining_after_pack[bins_remain_cap >= item] - (0.1 * bins_remain_cap[bins_remain_cap >= item])))\n\n    # Bonus for almost full bins if item can fit\n    almost_full = (bins_remain_cap >= item) & (bins_remain_cap <= 2 * item)\n    priorities[almost_full] += 1.0\n\n    # Big penalty if item would lead to near-empty bin\n    near_empty = (bins_remain_cap >= item) & (remaining_after_pack < 0.2)\n    priorities[near_empty] -= 0.5\n\n    return priorities",
    "response_id": 9,
    "obj": 5.464698843238926,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response10.txt_stdout.txt",
    "code_path": "problem_iter1_code10.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Calculate remaining capacity after adding the item\n    remaining_after_add = bins_remain_cap - item\n\n    # Assign high priority to bins where item fits\n    fit_indices = remaining_after_add >= 0\n    priorities[fit_indices] = 1\n\n    # Adjust priorities based on how well the item fits\n    fit_caps = bins_remain_cap[fit_indices]\n    remaining_caps = remaining_after_add[fit_indices]\n\n    # Heuristic to prefer bins with a good fit (not too tight, not too loose)\n    # Prioritize bins where remaining capacity is a moderate fraction of bin size\n    priority_scores = np.exp(-np.abs(remaining_caps / fit_caps - 0.5))\n    priorities[fit_indices] = priority_scores\n\n    # Give slight penalty for bins filled beyond 75% (to encourage more even packing)\n    # This avoids bins getting filled to very small capacities early on\n    high_fill_indices = bins_remain_cap < 0.25\n    priorities[high_fill_indices] = 0  # Very low priority if nearly full, even if item \"fits\" because of prior error.\n\n    # Scale priorities to ensure range [0, 1]\n    max_priority = np.max(priorities)\n    if max_priority > 0:\n        priorities = priorities / max_priority\n\n    return priorities",
    "response_id": 10,
    "obj": 42.80015955325091,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response11.txt_stdout.txt",
    "code_path": "problem_iter1_code11.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Initialize with a small negative value for bins that can't fit the item.\n    priorities[bins_remain_cap < item] = -1e9\n\n    # Calculate remaining capacity after placing item.\n    remaining_capacities = bins_remain_cap - item\n    remaining_capacities[remaining_capacities < 0] = -1 # Handle cases where item does not fit, to avoid -inf in the calculations. This assignment is necessary for handling zero-sized items.\n\n    # Define the available bins (bins where item fits).\n    available_bins = bins_remain_cap >= item\n\n    # Prioritize bins that are a good fit (not too much waste, not too little space).\n    # A bin is a good fit if (remaining_capacities / item) < some threshold and item/bin_remain_cap < threshold.\n    fit_threshold = 0.2\n    priorities[available_bins] = (1 - np.abs(remaining_capacities[available_bins] / item - 1))/(1 + bins_remain_cap[available_bins]) + (1 - np.abs(item/bins_remain_cap[available_bins] -1))/(1 + bins_remain_cap[available_bins])\n    # Add small noise to break ties.\n    priorities[available_bins] += np.random.normal(0, 1e-6, size=np.sum(available_bins))\n\n    return priorities",
    "response_id": 11,
    "obj": 4.038691663342641,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response12.txt_stdout.txt",
    "code_path": "problem_iter1_code12.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            # Fill rate, prefer bins which item fills it well.\n            fill_rate = item / cap\n            # Remaining capacity after inserting, penalized bins leaving too much space.\n            remaining_penalty = np.exp(- (cap - item)) if cap-item > 0 else 1\n            priorities[i] = fill_rate * remaining_penalty\n        else:\n            priorities[i] = -1  # Cannot fit, lowest priority\n\n    return priorities",
    "response_id": 12,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.99993815000926 seconds"
  },
  {
    "stdout_filepath": "problem_iter1_response13.txt_stdout.txt",
    "code_path": "problem_iter1_code13.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # First-Fit Decreasing heuristic inspiration: prioritize bins that can fit the item with minimal waste.\n    fit_mask = bins_remain_cap >= item\n    if np.any(fit_mask):\n        waste = bins_remain_cap[fit_mask] - item\n        priorities[fit_mask] = 1 / (waste + 0.0001)  # Avoid division by zero, and smaller waste is higher priority\n        priorities[fit_mask] += 1 # Make bins that fit better than the ones that do not\n\n    # If no bins can fit, try to fit in almost full bins with a penalty\n    else:\n      ratios = item / bins_remain_cap\n      priorities = -ratios # prefer to fill less\n      priorities = priorities - 100 # make it less preferable\n\n    return priorities",
    "response_id": 13,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response14.txt_stdout.txt",
    "code_path": "problem_iter1_code14.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if item <= cap:\n            # Primary priority: Can the item fit?\n            priorities[i] = 1  # Base priority for fitting\n\n            # Secondary priority: How well does it fit? Favor bins that are filled closer to capacity\n            priorities[i] += (item / cap) # Ratio of item size to bin capacity\n            \n            #Tertiary priority: small empty space after adding item is bad. Add penalty\n\n            remaining = cap - item\n            if remaining > 0:\n                priorities[i] -= remaining/np.max(bins_remain_cap) #Penalty related to remaining space\n\n        else:\n            priorities[i] = -np.inf  # Cannot fit, so lowest priority\n\n    return priorities",
    "response_id": 14,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.999972410994815 seconds"
  },
  {
    "stdout_filepath": "problem_iter1_response15.txt_stdout.txt",
    "code_path": "problem_iter1_code15.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Big enough, and fits best -> high priority\n    fit_mask = bins_remain_cap >= item\n    priorities[fit_mask] = (bins_remain_cap[fit_mask] - item)  # Remaining space after adding. Smaller is better (First Fit Decreasing heuristic intuition). So remaining space contributes negatively to the priority\n\n    # If it doesn't fit, assign a very low priority\n    priorities[~fit_mask] = -np.inf \n    \n    #Boost the bins closer to full. Prioritize filling partially full bins more than very empty bins or bins very close to full\n    priorities = priorities + (bins_remain_cap / np.max(bins_remain_cap))\n    \n    return priorities",
    "response_id": 15,
    "obj": 149.30195452732352,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response16.txt_stdout.txt",
    "code_path": "problem_iter1_code16.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            # Primary criterion: Can the item fit?\n            priorities[i] = 1\n\n            # Secondary criterion: Minimize wasted space\n            waste = cap - item\n            priorities[i] += (1 / (waste + 0.0001))  # Avoid division by zero, smaller waste = higher priority\n\n            # Tertiary criterion: Penalize almost full bins to encourage reuse of partially filled bins. Avoid filling too many bins at almost full level which hinders later insertion.\n            if waste < (np.mean(bins_remain_cap) / 2 if len(bins_remain_cap)>0 else 0.1): #avoid being too sensitive to bin sizes when bins_remain_cap is empty or near zero length\n               priorities[i] -= 0.5\n        else:\n            priorities[i] = -np.inf #ensure it won't fit in.\n\n    return priorities",
    "response_id": 16,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.99998850899283 seconds"
  },
  {
    "stdout_filepath": "problem_iter1_response17.txt_stdout.txt",
    "code_path": "problem_iter1_code17.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility check: High priority for bins that can fit the item.\n    feasible_bins = bins_remain_cap >= item\n    priorities[feasible_bins] += 1\n\n    # 2. Remaining capacity after placing the item:\n    remaining_capacity = bins_remain_cap - item\n    remaining_capacity[~feasible_bins] = -1  # Mark infeasible bins\n\n    # 3. Fill percentage: Prioritize bins that will be filled reasonably well.\n    fill_percentage = item / bins_remain_cap\n    priorities[feasible_bins] += (1 - np.abs(fill_percentage[feasible_bins] - 0.7)) # prefer 70%\n    # 4. Bins that are almost full (but can still accommodate) are good choices\n    almost_full = (bins_remain_cap > item) & (bins_remain_cap <= item * 1.2)\n    priorities[almost_full] += 2\n\n    # 5. Bonus for nearly full bins. Gives preference to almost empty bins to consolidate items, and discourage nearly full bins which might lead to fragments.\n    nearly_empty = bins_remain_cap > (item * 3) # try to find an empty enough bin\n    priorities[nearly_empty] -= 0.5\n\n    return priorities",
    "response_id": 17,
    "obj": 6.122856003191075,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response18.txt_stdout.txt",
    "code_path": "problem_iter1_code18.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # First-Fit Decreasing inspired\n    fit_mask = bins_remain_cap >= item\n    priorities[fit_mask] = bins_remain_cap[fit_mask] - item  # Remaining space after fit. smaller value is better, thus higher priority\n\n    # Give huge negative score to bins that can't fit\n    priorities[~fit_mask] = -np.inf\n\n    # Normalize the fitting score\n    max_val = np.max(priorities[fit_mask]) if np.any(fit_mask) else 0  # prevent warning in rare case when fit_mask is empty\n    if max_val > 0:\n        priorities[fit_mask] = max_val - priorities[fit_mask] # larger diff value is better\n\n    # Prefer bins that are not empty\n    non_empty_bins = bins_remain_cap < np.max(bins_remain_cap) # Assume same size of bins\n\n    priorities[non_empty_bins & fit_mask] += 1 # slight bump\n\n    return priorities",
    "response_id": 18,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response19.txt_stdout.txt",
    "code_path": "problem_iter1_code19.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Rule 1: Bins that can't fit the item get a priority of -np.inf\n    priorities[bins_remain_cap < item] = -np.inf\n\n    # Rule 2: If a bin can fit the item perfectly, give it maximum priority\n    perfect_fit = (bins_remain_cap == item)\n    priorities[perfect_fit] = np.inf\n\n    # Rule 3: For bins that can fit the item, prioritize bins with less remaining space *after* the item is placed.\n    # This encourages filling bins more completely.  We use a small constant to avoid division by zero.\n    valid_bins = bins_remain_cap >= item\n    remaining_after_fit = bins_remain_cap[valid_bins] - item\n    priorities[valid_bins] = -remaining_after_fit # Negative because smaller remaining space is better\n    \n    #Rule 4: Tie break: favor bins with higher current fill level relative to bin size\n    #this might help in scenarios where bins are close to being full already\n    priorities[valid_bins] += (1 - (bins_remain_cap[valid_bins] / (bins_remain_cap[valid_bins] + item - remaining_after_fit)))\n\n    return priorities",
    "response_id": 19,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response20.txt_stdout.txt",
    "code_path": "problem_iter1_code20.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Very high priority for bins that can fit the item perfectly (or almost perfectly)\n    perfect_fit = np.isclose(bins_remain_cap, item, atol=1e-6)\n    priorities[perfect_fit] = 1000  # Assign a very high priority\n    \n    # High priority for bins where the item fits and the remaining space is small\n    # This helps to fill up the bins as much as possible\n    fits = bins_remain_cap >= item\n    remaining_space = bins_remain_cap - item\n    \n    priorities[fits] = 100 / (remaining_space[fits] + 0.001) #Avoid division by zero; the smaller remaining space gets higher priority.\n\n    # Prioritize bins with larger remaining capacity to avoid creating too many nearly-full bins early.\n    priorities[fits] += bins_remain_cap[fits] / np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else 0\n    \n    #Assign a very small negative priority to bins where the item doesn't fit, ensuring that fitting bins are always prioritized.\n    priorities[~fits] = -0.00001\n    \n    return priorities",
    "response_id": 20,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response21.txt_stdout.txt",
    "code_path": "problem_iter1_code21.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    # First-Fit Decreasing Inspired: Prefer bins that can accommodate the item\n    can_fit = bins_remain_cap >= item\n    priorities[can_fit] += 1  # Give these bins a base priority of 1\n\n    # Best-Fit Inspired:  Among bins that can fit, prefer the fullest one (least remaining space after adding the item).\n    remaining_after_fit = bins_remain_cap[can_fit] - item\n    \n    #Avoid errors from empty slices\n    if remaining_after_fit.size > 0:\n        priorities[can_fit] += np.max(remaining_after_fit) - remaining_after_fit # smaller remaining capacity means higher priority\n\n    # Penalize bins where the item would leave too little space\n    too_little_space = (bins_remain_cap > item) & (bins_remain_cap - item < 0.1) # Avoid bins if less than 0.1 remain\n    priorities[too_little_space] -= 10  # Heavily penalize bins that lead to very little remaining capacity\n\n    #Penalize bins which do not fit at all\n    does_not_fit = bins_remain_cap < item\n    priorities[does_not_fit] -= 100\n    \n    return priorities",
    "response_id": 21,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 24, in priority_v2\n    \nnumpy._core._exceptions._UFuncOutputCastingError: Cannot cast ufunc 'add' output from dtype('float64') to dtype('int64') with casting rule 'same_kind'\n"
  },
  {
    "stdout_filepath": "problem_iter1_response22.txt_stdout.txt",
    "code_path": "problem_iter1_code22.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # First-Fit Decreasing heuristic inspired priority\n    # Give bins that can fit the item a base priority.\n\n    can_fit = bins_remain_cap >= item\n    priorities[can_fit] = 1.0\n\n    #Prioritize bins with less remaining capacity (but that can fit item). Fill them first\n\n    priorities[can_fit] += (1 - (bins_remain_cap[can_fit] - item) / bins_remain_cap[can_fit])\n\n\n    # Bonus: Slightly penalize bins that are almost full after packing\n    almost_full = (bins_remain_cap - item) < 0.1  # Threshold for \"almost full\"\n    priorities[almost_full] -= 0.2\n\n    #If nothing fits, assign min priority\n    if np.all(bins_remain_cap < item):\n       priorities[:] = -1.0\n\n    return priorities",
    "response_id": 22,
    "obj": 4.646988432389324,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response23.txt_stdout.txt",
    "code_path": "problem_iter1_code23.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Rule 1: Bins that can fit the item get a base priority boost.\n    can_fit = bins_remain_cap >= item\n    priorities[can_fit] += 1.0  # Base boost for fitting\n\n    # Rule 2: Higher priority to bins with tighter fit (minimize wasted space)\n    wasted_space = bins_remain_cap - item\n    \n    #Avoid negative values, only penalize bins too small.\n    wasted_space[wasted_space < 0] = 1e9  # Assign a very large wasted space if item doesn't fit\n    \n    # If wasted_space are small, then the bin is a better fit. So we will make priority a function of the inverse.\n    # We must consider only bins large enough. If the bin is too small we will give it zero priority\n\n    fit_indices = np.where(bins_remain_cap >= item)[0]\n    if len(fit_indices) > 0:\n      priorities[fit_indices] += (1.0 / (1.0 + wasted_space[fit_indices])) # smaller wasted space -> higher priority. Added one to avoid division by zero\n\n    # Rule 3: Penalize bins that become nearly full after adding the item\n    almost_full = (bins_remain_cap > item) & (bins_remain_cap - item <= 0.1) # e.g. remaining < 10%\n\n    priorities[almost_full] -= 0.5  # Slight penalty to avoid bins packed nearly full unless necessary\n\n    # Rule 4:  If item is small, prioritize bins with low occupancy\n    if item < 0.2: #consider only small items\n        occupancy = 1.0 - bins_remain_cap #Occupancy level of each bin. (1- remain_cap)\n        priorities += (1.0 - occupancy) * 0.3 # Prefer less full bins when item is small. Weighing is important so we don't overemphasize.\n\n    return priorities",
    "response_id": 23,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response24.txt_stdout.txt",
    "code_path": "problem_iter1_code24.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Give high priority to bins that can accommodate the item\n    # but are not too much larger than the item (to avoid fragmentation).\n    \n    # First, identify feasible bins\n    feasible_bins = bins_remain_cap >= item\n    \n    if np.any(feasible_bins):\n        # Calculate the wasted space if the item is placed in each feasible bin\n        wasted_space = bins_remain_cap[feasible_bins] - item\n        \n        # Give higher priority to bins where the wasted space is small\n        # This encourages filling bins more completely\n        priority_for_feasible = np.exp(-wasted_space)\n        \n        # Assign priorities to feasible bins\n        priorities[feasible_bins] = priority_for_feasible\n    else:\n        # If no bins can accommodate the item, assign a small negative priority\n        # This discourages using a new bin unless necessary\n        priorities[:] = -1.0  # Or a small negative value\n\n    return priorities",
    "response_id": 24,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response25.txt_stdout.txt",
    "code_path": "problem_iter1_code25.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            # First-Fit Decreasing inspired: Favor bins with tighter fit\n            fit_ratio = item / cap\n            priorities[i] = 1 / (1.01 - fit_ratio) # higher when fit is tight. avoid inf when ratio is 1\n        else:\n            priorities[i] = -1e9 # Very low priority if it doesn't fit\n\n    return priorities",
    "response_id": 25,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response26.txt_stdout.txt",
    "code_path": "problem_iter1_code26.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Feasibility check: Only consider bins that can fit the item\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        return priorities # No bin can fit the item\n\n    # Calculate remaining capacity after placing the item (for feasible bins only)\n    remaining_capacity_after_placement = bins_remain_cap[feasible_bins] - item\n\n    # Heuristic 1: Try to fill bins as much as possible (minimize wasted space). Prioritize bins where remaining capacity after placement is small.\n    priorities[feasible_bins] = -remaining_capacity_after_placement\n\n    # Heuristic 2: Avoid creating bins with tiny remaining capacities (fragmentation). Penalize bins that result in very small remaining capacity after placement.\n    tiny_capacity_threshold = 0.1  # Adjust this threshold as needed\n    fragmentation_penalty = -100  # Adjust this penalty as needed\n    priorities[feasible_bins & (remaining_capacity_after_placement < tiny_capacity_threshold)] += fragmentation_penalty\n\n    # Heuristic 3: Give a bonus for near-full bins after placement. Incentivize finishing bins.\n    near_full_bonus_threshold = 0.05 # If the remaining space is less than 5% of bin size, strongly prioritize this bin. Assume bin_size = 1.\n    near_full_bonus = 100\n    priorities[feasible_bins & (remaining_capacity_after_placement <= near_full_bonus_threshold)] += near_full_bonus\n\n    #Heuristic 4: If an item fills a bin, highly prioritize it\n    exact_fit_bonus = 500\n    priorities[feasible_bins & (remaining_capacity_after_placement == 0)] += exact_fit_bonus\n\n\n    return priorities",
    "response_id": 26,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response27.txt_stdout.txt",
    "code_path": "problem_iter1_code27.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Calculate remaining capacity after placing the item\n    remaining_after_placement = bins_remain_cap - item\n    \n    # Prioritize bins where the item fits\n    fit_mask = remaining_after_placement >= 0\n    \n    # Prioritize based on how much space is left after placement.\n    # Smaller remaining space suggests a better fit. Use a reversed exponential decay.\n    priorities[fit_mask] = np.exp(-remaining_after_placement[fit_mask] / item)\n\n    #Bonus for Almost Full Bins: Bins with capacity very close to the item size get the highest bonus\n    almost_full_bonus_mask = np.logical_and(bins_remain_cap >= item, bins_remain_cap <= (item*1.1)) #1.1 gives a small tolerance\n    priorities[almost_full_bonus_mask] += 1.0\n\n    return priorities",
    "response_id": 27,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response28.txt_stdout.txt",
    "code_path": "problem_iter1_code28.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if item <= cap:\n            # Prioritize bins that can fit the item\n            space_waste = cap - item\n            # Give higher priority to bins with less remaining space *after* placing the item, but not zero-space waste\n            if space_waste > 0:\n                priorities[i] = 1 / space_waste  # Higher priority for less waste.\n            else:\n                 priorities[i] = 1000 # Max priority for perfect fit\n\n        else:\n            # Negative priority if it does not fit.\n            priorities[i] = -1\n\n    return priorities",
    "response_id": 28,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response29.txt_stdout.txt",
    "code_path": "problem_iter1_code29.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Calculate remaining space after adding the item\n    remaining_space = bins_remain_cap - item\n\n    # Give high priority to bins where the item fits, but leaves little space.\n    fit_mask = remaining_space >= 0\n    priorities[fit_mask] = 1 / (remaining_space[fit_mask] + 1e-9) # Avoid division by zero\n\n    # Give a lower, but non-zero priority to bins where the item does *not* fit,\n    # This might allow later algorithms to consider bins which have the *smallest* wasted space.\n    no_fit_mask = ~fit_mask\n    priorities[no_fit_mask] = - item + bins_remain_cap[no_fit_mask] # Smaller negative values = higher priority\n\n\n    # Add a term that pushes towards filling bins completely (First Fit Decreasing logic)\n    priorities += bins_remain_cap / np.sum(bins_remain_cap + 1e-9) # Normalize capacity to avoid scaling issues\n\n\n    return priorities",
    "response_id": 29,
    "obj": 4.048663741523748,
    "exec_success": true
  }
]