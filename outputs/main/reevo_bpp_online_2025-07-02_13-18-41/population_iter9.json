[
  {
    "stdout_filepath": "problem_iter8_response0.txt_stdout.txt",
    "code_path": "problem_iter8_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Rule 1: Infeasible bins get a very negative priority.\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -1e9\n\n    available_bins = ~infeasible_bins\n\n    if np.any(available_bins):\n        # Calculate wasted space\n        wasted_space = bins_remain_cap[available_bins] - item\n        max_cap = np.max(bins_remain_cap)\n\n        # Relative Wasted Space Priority (Minimize)\n        relative_wasted_space = wasted_space / (item + 1e-9)\n        priorities[available_bins] -= relative_wasted_space * 5\n\n        # Target Fullness Reward (Target around 75% full)\n        target_fullness = 0.75 * max_cap if max_cap > 0 else 0.0\n        target_range = 0.2 * max_cap if max_cap > 0 else 0.1\n        fullness = bins_remain_cap[available_bins] - item\n        target_bonus = np.exp(-((fullness - target_fullness) ** 2) / (2 * target_range ** 2))\n        priorities[available_bins] += target_bonus * 3\n\n        # Large Gap Penalty (Scaled relative to item size)\n        large_gap_threshold = 0.6 * item\n        large_gap_penalty = (wasted_space > large_gap_threshold) * (wasted_space / max_cap) if max_cap > 0 else (wasted_space > large_gap_threshold) * wasted_space\n        priorities[available_bins] -= large_gap_penalty * 2\n\n        # Almost Full Bonus\n        almost_full_threshold = 0.1 * max_cap if max_cap > 0 else 0.1\n        almost_full_bonus = (wasted_space <= almost_full_threshold) * 7\n        priorities[available_bins] += almost_full_bonus\n\n        # Small Waste Bonus (Tight Fit)\n        small_waste_threshold = 0.2 * item\n        small_waste_bonus = (wasted_space <= small_waste_threshold) * (item / max_cap) if max_cap > 0 else (wasted_space <= small_waste_threshold) * item\n        priorities[available_bins] += small_waste_bonus * 4\n\n        # Fill Level Bonus (Avoid Empty or Too Full Bins)\n        fill_level = (max_cap - bins_remain_cap[available_bins] + item) / max_cap if max_cap > 0 else 0\n        fill_level_penalty = np.abs(fill_level - 0.7)\n        priorities[available_bins] -= fill_level_penalty * 1.5\n\n        # Reward higher occupancy\n        occupancy_bonus = fill_level\n        priorities[available_bins] += occupancy_bonus * 1\n\n    # Tie-breaking Noise\n    priorities[available_bins] += np.random.normal(0, 1e-6, size=np.sum(available_bins))\n\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response1.txt_stdout.txt",
    "code_path": "problem_iter8_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Infeasibility penalty\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -1e9\n\n    available_bins = bins_remain_cap >= item\n\n    if np.any(available_bins):\n        # Calculate wasted space\n        wasted_space = bins_remain_cap[available_bins] - item\n\n        # Relative wasted space priority.\n        relative_wasted_space = wasted_space / (item + 1e-9)\n        priorities[available_bins] = -relative_wasted_space\n\n        # Target fullness bonus. Adaptive target based on item size.\n        max_cap = np.max(bins_remain_cap)\n        target_fullness = max_cap - 0.25 * max_cap # Aim for 75% fullness post-packing.\n        target_range = 0.15 * max_cap  # Allowable deviation.\n        bonus_strength = 1.0\n        target_bonus = bonus_strength * np.exp(-((bins_remain_cap[available_bins] - item - target_fullness) ** 2) / (2 * target_range ** 2))\n        priorities[available_bins] += target_bonus\n\n        # Adaptive large gap penalty based on item and bin size.\n        large_gap_threshold = 0.4 * item\n        large_gap_penalty_strength = 0.5\n        large_gap_penalty = (wasted_space > large_gap_threshold) * (wasted_space / max_cap) * large_gap_penalty_strength if max_cap > 0 else (wasted_space > large_gap_threshold) * wasted_space * large_gap_penalty_strength\n        priorities[available_bins] -= large_gap_penalty\n\n        # Adaptive tight fit bonus.\n        tight_fit_threshold = 0.15 * item\n        tight_fit_bonus_strength = 0.75\n        tight_fit_bonus = (wasted_space <= tight_fit_threshold) * (item / max_cap) * tight_fit_bonus_strength if max_cap > 0 else (wasted_space <= tight_fit_threshold) * item * tight_fit_bonus_strength\n        priorities[available_bins] += tight_fit_bonus\n\n        # Almost full bonus: increase the chance to fill a bin completely\n        almost_full_threshold = 0.1 * max_cap\n        almost_full = (bins_remain_cap[available_bins] >= item) & (wasted_space < almost_full_threshold)\n        priorities[available_bins][almost_full] += 5\n\n        # Bin utilization bonus to utilize most of the available bins\n\n        bin_utilization = (max_cap - bins_remain_cap[available_bins]) / max_cap if max_cap > 0 else 0.0\n        priorities[available_bins] += bin_utilization * 0.1\n\n        # Random noise for tie-breaking.  Reduced magnitude.\n        noise_std = 1e-7 * max_cap if max_cap > 0 else 1e-7\n        priorities[available_bins] += np.random.normal(0, noise_std, size=np.sum(available_bins))\n\n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response2.txt_stdout.txt",
    "code_path": "problem_iter8_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Rule 1: Infeasible bins get a very negative priority.\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -1e9\n\n    # Rule 2: Quantify \"good fit\" using relative wasted space.\n    # A good fit minimizes the *ratio* of wasted space to the item size.\n    available_bins = bins_remain_cap >= item\n    if np.any(available_bins):\n        wasted_space = bins_remain_cap[available_bins] - item\n        relative_wasted_space = wasted_space / (item + 1e-9) # avoid division by zero if item is 0\n\n        # Good fit = low relative wasted space.  Invert and scale.\n        priorities[available_bins] = 1.0 / (0.01 + relative_wasted_space)\n\n        # Further improve good fit by considering bin occupancy. Slightly penalize near-empty bins.\n        occupancy = 1.0 - bins_remain_cap[available_bins] / np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else 0.0 #handle edge case where max cap is zero\n        occupancy_penalty = occupancy**2 * 0.1 #Penalize near-empty, but less aggressively than previous occupancy penalty\n\n        priorities[available_bins] -= occupancy_penalty\n\n        #Reward bins approaching a target fullness (e.g., 75%)\n        max_cap = np.max(bins_remain_cap)\n        target_fullness = 0.75 * max_cap if max_cap > 0 else 0.0\n        target_range = 0.1 * max_cap if max_cap > 0 else 0.1 #Scale relative to maximum bin size.\n\n        target_bonus = np.exp(-((bins_remain_cap[available_bins] - item - target_fullness)**2) / (2 * target_range**2))\n        priorities[available_bins] += target_bonus * 0.5\n\n\n    # Rule 3: Prioritize almost full bins to complete them, but make it relative to bin size.\n    almost_full = (bins_remain_cap >= item) & (bins_remain_cap - item < 0.1 * np.max(bins_remain_cap) if np.max(bins_remain_cap)>0 else bins_remain_cap >=item )\n    priorities[almost_full] += 10  # Give a significant bonus to almost full bins, relatively\n\n    # Rule 4: Add some noise to break ties randomly.\n    available_bins = bins_remain_cap >= item\n    priorities[available_bins] += np.random.normal(0, 1e-6, size=np.sum(available_bins))\n\n    return priorities",
    "response_id": 2,
    "obj": 3.9090546469884373,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response3.txt_stdout.txt",
    "code_path": "problem_iter8_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Rule 1: Infeasible bins get a very negative priority.\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -1e9\n\n    # Get bin size\n    bin_size = np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else 1.0\n\n    # Rule 2: Quantify \"good fit\" using relative wasted space.\n    # A good fit minimizes the *ratio* of wasted space to the item size.\n    available_bins = bins_remain_cap >= item\n    if np.any(available_bins):\n        wasted_space = bins_remain_cap[available_bins] - item\n        relative_wasted_space = wasted_space / (item + 1e-9)  # avoid division by zero if item is 0\n\n        # Good fit = low relative wasted space. Invert and scale.\n        priorities[available_bins] = 1.0 / (0.01 + relative_wasted_space)\n\n        # Further improve good fit by considering bin occupancy, penalize bins which are far from ideal occupancy.\n        occupancy = 1.0 - bins_remain_cap[available_bins] / bin_size\n        ideal_occupancy = 0.75 # Target 75% occupancy\n        occupancy_penalty = np.abs(occupancy - ideal_occupancy)  # Prefer bins near the target occupancy.\n        priorities[available_bins] -= occupancy_penalty * 0.3\n\n        # Reward bins approaching a target fullness (e.g., 75%)\n        target_fullness = ideal_occupancy * bin_size # Target 75%\n        target_range = 0.1 * bin_size # Tolerance of 10%\n\n        target_bonus = np.exp(-((bins_remain_cap[available_bins] - item - target_fullness) ** 2) / (2 * target_range ** 2))\n        priorities[available_bins] += target_bonus * 0.6\n\n        # Penalize large gaps, adapt penalty to item size\n        large_gap_threshold = 0.4 * bin_size  # Define \"large\" relative to bin size (40%)\n        large_gap_penalty = (wasted_space > large_gap_threshold) * (wasted_space / bin_size) * 0.2  # Scale with gap size, more sensitive\n        priorities[available_bins] -= large_gap_penalty\n\n    # Rule 3: Prioritize almost full bins to complete them, but make it relative to bin size.\n    almost_full_threshold = 0.1 * bin_size # Threshold of 10%\n    almost_full = (bins_remain_cap >= item) & (bins_remain_cap - item < almost_full_threshold)\n    priorities[almost_full] += 12  # Give a significant bonus to almost full bins\n\n    # Rule 4: Add some noise to break ties randomly.\n    priorities[available_bins] += np.random.normal(0, 1e-6, size=np.sum(available_bins))\n\n    return priorities",
    "response_id": 3,
    "obj": 3.9589150378939015,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response4.txt_stdout.txt",
    "code_path": "problem_iter8_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Rule 1: Infeasible bins get a very negative priority.\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -1e9\n\n    # Rule 2: Quantify \"good fit\" using relative wasted space and bin capacity ratio.\n    available_bins = bins_remain_cap >= item\n    max_cap = np.max(bins_remain_cap) if np.any(bins_remain_cap) else 0.0  # Handle edge case where all bins are infeasible.\n\n    if np.any(available_bins):\n        wasted_space = bins_remain_cap[available_bins] - item\n        relative_wasted_space = wasted_space / (item + 1e-9)  # avoid division by zero if item is 0\n\n        # Bin capacity ratio (remaining capacity / total capacity)\n        bin_capacity_ratio = bins_remain_cap[available_bins] / max_cap if max_cap > 0 else 0.0\n\n        # Good fit = low relative wasted space and large bin capacity ratio. Invert and scale.\n        priority_good_fit = 1.0 / (0.01 + relative_wasted_space)\n        priority_capacity_ratio = bin_capacity_ratio * 0.5\n        priorities[available_bins] = priority_good_fit + priority_capacity_ratio\n\n        # Penalize bins which are empty or almost full, scaled by item size ratio\n        occupancy = 1.0 - bin_capacity_ratio\n        occupancy_penalty = np.abs(occupancy - 0.5) * (item / max_cap if max_cap > 0 else 0.0)\n        priorities[available_bins] -= occupancy_penalty * 0.2\n\n        # Reward bins approaching a target fullness (e.g., 75%), scaled by item size.\n        target_fullness = 0.75 * max_cap if max_cap > 0 else 0.0\n        target_range = 0.1 * max_cap if max_cap > 0 else 0.1  # Scale relative to maximum bin size.\n\n        remaining_after_pack = bins_remain_cap[available_bins] - item\n        target_bonus = np.exp(-((remaining_after_pack - (max_cap - target_fullness))**2) / (2 * target_range**2))\n        priorities[available_bins] += target_bonus * 0.5 * (item / max_cap if max_cap > 0 else 0.0)\n\n    # Rule 3: Prioritize almost full bins to complete them, scale based on remaining cap\n    almost_full = (bins_remain_cap >= item) & (bins_remain_cap - item < 0.1 * max_cap if max_cap > 0 else (bins_remain_cap >= item))\n    if np.any(almost_full):\n        priorities[almost_full] += 10 * (1 - bins_remain_cap[almost_full] / max_cap if max_cap > 0 else 1) * (item / max_cap if max_cap > 0 else 0.0) #Scale by item size.\n\n    # Rule 4: Add some noise to break ties randomly, scaled by item size.\n    available_bins = bins_remain_cap >= item\n    if np.any(available_bins):\n        priorities[available_bins] += np.random.normal(0, 1e-6 * (item / max_cap if max_cap > 0 else 1), size=np.sum(available_bins))\n\n    return priorities",
    "response_id": 4,
    "obj": 4.068607897885915,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response5.txt_stdout.txt",
    "code_path": "problem_iter8_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Rule 1: Infeasible bins get a very negative priority.\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -1e9\n\n    # Rule 2: Quantify \"good fit\" using relative wasted space.\n    # A good fit minimizes the *ratio* of wasted space to the item size.\n    available_bins = bins_remain_cap >= item\n    if np.any(available_bins):\n        wasted_space = bins_remain_cap[available_bins] - item\n        relative_wasted_space = wasted_space / (item + 1e-9) # avoid division by zero if item is 0\n\n        # Good fit = low relative wasted space.  Invert and scale.\n        # Add a small constant to the denominator to avoid division by zero and smooth the function.\n        priorities[available_bins] = 1.0 / (0.01 + relative_wasted_space)\n\n        # Further improve good fit by considering bin occupancy, penalize bins which are empty or almost full.\n        max_cap = np.max(bins_remain_cap)\n        occupancy = 1.0 - bins_remain_cap[available_bins] / max_cap if max_cap > 0 else 0.0 #handle edge case where max cap is zero\n        occupancy_penalty = np.abs(occupancy - 0.5) #Bins that are near half full are preferable.\n\n        priorities[available_bins] -= occupancy_penalty * 0.2\n\n        #Reward bins approaching a target fullness (e.g., 75%)\n        target_fullness = 0.75 * max_cap if max_cap > 0 else 0.0\n        target_range = 0.1 * max_cap if max_cap > 0 else 0.1 #Scale relative to maximum bin size.\n        \n        target_bonus = np.exp(-((bins_remain_cap[available_bins] - item - target_fullness)**2) / (2 * target_range**2))\n        priorities[available_bins] += target_bonus * 0.5\n\n        # Penalize bins with very high remaining capacity, discouraging fragmentation\n        high_capacity_threshold = 0.9 * max_cap if max_cap > 0 else 0.9\n        high_capacity = bins_remain_cap[available_bins] > high_capacity_threshold\n        priorities[available_bins][high_capacity] -= 0.1\n\n\n    # Rule 3: Prioritize almost full bins to complete them, but make it relative to bin size.\n    almost_full = (bins_remain_cap >= item) & (bins_remain_cap - item < 0.1 * max_cap if max_cap>0 else bins_remain_cap >=item )\n    priorities[almost_full] += 10  # Give a significant bonus to almost full bins\n\n    # Rule 4: Add some noise to break ties randomly.\n    available_bins = bins_remain_cap >= item\n    priorities[available_bins] += np.random.normal(0, 1e-6, size=np.sum(available_bins))\n\n    return priorities",
    "response_id": 5,
    "obj": 3.9688871160749857,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response6.txt_stdout.txt",
    "code_path": "problem_iter8_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    max_bin_cap = np.max(bins_remain_cap)\n\n    # Handle edge case where all bins are empty or max cap is zero\n    if max_bin_cap == 0:\n        max_bin_cap = 1.0  # Avoid division by zero\n\n    # Rule 1: Infeasible bins get a very negative priority.\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -1e9\n\n    # Rule 2: Quantify \"good fit\" using relative wasted space and bin capacity ratio.\n    available_bins = bins_remain_cap >= item\n    if np.any(available_bins):\n        wasted_space = bins_remain_cap[available_bins] - item\n        relative_wasted_space = wasted_space / (item + 1e-9)  # avoid division by zero if item is 0\n\n        # Bin capacity ratio (remaining capacity / total capacity)\n        bin_capacity_ratio = bins_remain_cap[available_bins] / max_bin_cap\n\n        # Good fit = low relative wasted space and moderate to high bin capacity ratio. Invert and scale.\n        priorities[available_bins] = (1.0 / (0.01 + relative_wasted_space)) + bin_capacity_ratio * 0.3\n\n        # Penalize bins which are almost full or empty, scaled by item size ratio and emphasizing almost full\n        occupancy = 1.0 - bin_capacity_ratio\n        occupancy_penalty = np.abs(occupancy - 0.5) * (item / max_bin_cap)\n        priorities[available_bins] -= occupancy_penalty * 0.4  # Increased penalty\n\n        # Reward bins approaching a target fullness (e.g., 75%), scaled by item size. Using a Gaussian distribution for smoother reward\n        target_fullness = 0.75 * max_bin_cap\n        target_range = 0.15 * max_bin_cap  # Increased range for more bins to be in target\n        target_bonus = np.exp(-((bins_remain_cap[available_bins] - item - target_fullness) ** 2) / (2 * target_range ** 2))\n        priorities[available_bins] += target_bonus * 0.7 * (item / max_bin_cap) #Increased bonus\n\n    # Rule 3: Prioritize almost full bins to complete them, scale based on remaining cap\n    almost_full = (bins_remain_cap >= item) & (bins_remain_cap - item < 0.1 * max_bin_cap)\n    if np.any(almost_full):\n        priorities[almost_full] += 12 * (1 - bins_remain_cap[almost_full] / max_bin_cap) #Increased base reward\n\n    # Rule 4: Add some noise to break ties randomly, scaled by item size. Reduce overall noise\n    available_bins = bins_remain_cap >= item\n    priorities[available_bins] += np.random.normal(0, 1e-7 * (item / max_bin_cap), size=np.sum(available_bins))\n\n    return priorities",
    "response_id": 6,
    "obj": 4.038691663342641,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response7.txt_stdout.txt",
    "code_path": "problem_iter8_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Rule 1: Infeasible bins get a large negative priority.\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -1e9\n\n    # Rule 2: Quantify \"good fit\" using relative wasted space.\n    # A good fit minimizes the *ratio* of wasted space to the item size.\n    available_bins = bins_remain_cap >= item\n    if np.any(available_bins):\n        wasted_space = bins_remain_cap[available_bins] - item\n        relative_wasted_space = wasted_space / (item + 0.001)  # Add small constant to avoid division by zero\n\n        # Good fit = low relative wasted space.  Invert and scale.\n        priorities[available_bins] = 1.0 / (0.01 + relative_wasted_space)\n\n        # Further improve good fit by considering bin occupancy, penalize extremes.\n        occupancy = 1.0 - bins_remain_cap[available_bins]  # Assuming bin size is 1\n        occupancy_penalty = np.abs(occupancy - 0.75)  # Bins that are near 75% full are preferable.\n        priorities[available_bins] -= occupancy_penalty * 0.5\n\n    # Rule 3: Prioritize almost full bins to complete them\n    almost_full = (bins_remain_cap >= item) & (bins_remain_cap - item < 0.1)\n    priorities[almost_full] += 10  # Give a significant bonus to almost full bins\n\n    # Rule 4: Add some noise to break ties randomly.\n    available_bins = bins_remain_cap >= item\n    priorities[available_bins] += np.random.normal(0, 1e-6, size=np.sum(available_bins))\n\n    return priorities",
    "response_id": 7,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response8.txt_stdout.txt",
    "code_path": "problem_iter8_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Rule 1: Infeasible bins get a very negative priority.\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -1e9\n\n    # Rule 2: Quantify \"good fit\" using relative wasted space.\n    # A good fit minimizes the *ratio* of wasted space to the item size.\n    available_bins = bins_remain_cap >= item\n    if np.any(available_bins):\n        wasted_space = bins_remain_cap[available_bins] - item\n        relative_wasted_space = wasted_space / (item + 1e-9)  # avoid division by zero if item is 0\n\n        # Good fit = low relative wasted space. Invert and scale.\n        priorities[available_bins] = 1.0 / (0.01 + relative_wasted_space)\n\n        # Reward bins approaching a target fullness (e.g., 75% of max cap)\n        max_cap = np.max(bins_remain_cap) if bins_remain_cap.size > 0 else 1.0  # handles empty bin case\n        target_fullness = 0.75 * max_cap\n        target_range = 0.15 * max_cap # Adjust range for sensitivity.\n\n        remaining_after_pack = bins_remain_cap[available_bins] - item\n\n        target_bonus = np.exp(-((remaining_after_pack - (max_cap - target_fullness)) ** 2) / (2 * target_range ** 2))\n        priorities[available_bins] += target_bonus * 0.5\n\n    # Rule 3: Prioritize almost full bins to complete them, relative to bin size.\n    # Prioritize if remaining cap is within 5% of the max cap.\n    almost_full = (bins_remain_cap >= item) & (bins_remain_cap - item < 0.05 * np.max(bins_remain_cap)) if np.max(bins_remain_cap)>0 else (bins_remain_cap >= item)\n    priorities[almost_full] += 10\n\n    # Rule 4: Add some noise to break ties randomly.\n    available_bins = bins_remain_cap >= item\n    priorities[available_bins] += np.random.normal(0, 1e-6, size=np.sum(available_bins))\n\n    return priorities",
    "response_id": 8,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response9.txt_stdout.txt",
    "code_path": "problem_iter8_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Rule 1: Infeasible bins get a very negative priority.\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -1e9\n\n    # Rule 2: Quantify \"good fit\" using relative wasted space.\n    available_bins = bins_remain_cap >= item\n    if np.any(available_bins):\n        wasted_space = bins_remain_cap[available_bins] - item\n        relative_wasted_space = wasted_space / (item + 1e-9)  # avoid division by zero\n\n        # Good fit = low relative wasted space. Invert.\n        priorities[available_bins] = 1.0 / (0.01 + relative_wasted_space)\n\n        max_cap = np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else 1.0 #Avoid division by zero, and handle empty input array\n\n        # Penalize large gaps, scaled relative to item size\n        large_gap_threshold = 0.5 * item\n        large_gap_penalty = (wasted_space > large_gap_threshold) * (wasted_space / max_cap)\n        priorities[available_bins] -= large_gap_penalty * 0.3\n\n        # Reward tight fits, especially for larger items.\n        tight_fit_threshold = 0.1 * item\n        tight_fit_bonus = (wasted_space <= tight_fit_threshold) * (item / max_cap)\n        priorities[available_bins] += tight_fit_bonus * 0.4\n\n    # Rule 3: Prioritize almost full bins.\n    almost_full = (bins_remain_cap >= item) & (bins_remain_cap - item < 0.1 * np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else bins_remain_cap >= item)\n    priorities[almost_full] += 5 #Significant bonus\n\n    # Rule 4: Add some noise to break ties randomly.\n    available_bins = bins_remain_cap >= item\n    priorities[available_bins] += np.random.normal(0, 1e-6, size=np.sum(available_bins))\n\n    return priorities",
    "response_id": 9,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response0.txt_stdout.txt",
    "code_path": "problem_iter9_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Rule 1: Infeasible bins get a very negative priority.\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -1e9\n\n    # Rule 2:  Prioritize bins based on relative waste, and target fullness.\n    available_bins = bins_remain_cap >= item\n    if np.any(available_bins):\n        wasted_space = bins_remain_cap[available_bins] - item\n        bin_capacity = np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else 1.0\n        relative_wasted_space = wasted_space / bin_capacity # Scale wasted space by bin size\n\n        priorities[available_bins] = -relative_wasted_space # Lower waste is better\n\n        # Bonus for bins close to target fullness (75% full)\n        target_fullness = 0.75 * bin_capacity\n        fullness_deviation = np.abs((bin_capacity - bins_remain_cap[available_bins]) - target_fullness)\n\n        # Apply a bonus that decays with the square of the deviation from target fullness\n        target_bonus = np.exp(-(fullness_deviation**2) / (2 * (0.1 * bin_capacity)**2)) # std dev = 10% of bin capacity.\n        priorities[available_bins] += target_bonus * 0.5\n\n    # Rule 3: Extra priority for almost-full bins.\n    almost_full_threshold = 0.1 * bin_capacity  # Considered almost full if within 10% of max capacity\n    almost_full = (bins_remain_cap >= item) & (bins_remain_cap - item <= almost_full_threshold)\n    priorities[almost_full] += 5  # Significant bonus for almost full.\n\n    # Rule 4: Add some noise to break ties randomly.\n    available_bins = bins_remain_cap >= item\n    priorities[available_bins] += np.random.normal(0, 1e-6, size=np.sum(available_bins))\n\n    return priorities",
    "response_id": 0,
    "obj": 6.172716394096539,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response1.txt_stdout.txt",
    "code_path": "problem_iter9_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Rule 1: Infeasible bins get a very negative priority.\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -1e9\n\n    # Rule 2: Quantify \"good fit\" using relative wasted space.\n    available_bins = bins_remain_cap >= item\n    if np.any(available_bins):\n        wasted_space = bins_remain_cap[available_bins] - item\n        relative_wasted_space = wasted_space / (bins_remain_cap[available_bins] + 1e-9)\n\n        priorities[available_bins] = 1.0 / (0.01 + relative_wasted_space)\n\n        # Reward bins approaching a target fullness (e.g., 75% of bin capacity)\n        max_cap = np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else 1.0\n        target_fullness = 0.75 * max_cap\n        target_range = 0.15 * max_cap # increased range\n\n        target_bonus = np.exp(-((bins_remain_cap[available_bins] - item - target_fullness)**2) / (2 * target_range**2))\n        priorities[available_bins] += target_bonus * 0.7 #Increased bonus\n\n    # Rule 3: Prioritize almost full bins to complete them\n    almost_full = (bins_remain_cap >= item) & (bins_remain_cap - item < 0.15 * np.max(bins_remain_cap) if np.max(bins_remain_cap)>0 else bins_remain_cap >=item ) #Adjusted threshold\n    priorities[almost_full] += 15  # Increased bonus\n\n    # Rule 4: Add small noise for tie-breaking.\n    available_bins = bins_remain_cap >= item\n    priorities[available_bins] += np.random.normal(0, 1e-6, size=np.sum(available_bins))\n\n    return priorities",
    "response_id": 1,
    "obj": 3.8093338651775075,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response2.txt_stdout.txt",
    "code_path": "problem_iter9_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Rule 1: Infeasible bins get a very negative priority.\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -1e9\n\n    # Rule 2: Quantify \"good fit\" using relative wasted space.\n    available_bins = bins_remain_cap >= item\n    if np.any(available_bins):\n        wasted_space = bins_remain_cap[available_bins] - item\n        relative_wasted_space = wasted_space / (bins_remain_cap[available_bins] + 1e-9)\n\n        # Good fit = low relative wasted space.\n        priorities[available_bins] = 1.0 / (0.01 + relative_wasted_space)\n\n        # Reward bins approaching a target fullness (e.g., 75%)\n        max_cap = np.max(bins_remain_cap)\n        target_fullness = 0.75 * max_cap if max_cap > 0 else 0.0\n        target_range = 0.2 * max_cap if max_cap > 0 else 0.1\n\n        target_bonus = np.exp(-((bins_remain_cap[available_bins] - item - target_fullness)**2) / (2 * target_range**2))\n        priorities[available_bins] += target_bonus * 0.5\n\n\n    # Rule 3: Prioritize almost full bins to complete them.\n    almost_full = (bins_remain_cap >= item) & (bins_remain_cap - item < 0.1 * np.max(bins_remain_cap) if np.max(bins_remain_cap)>0 else bins_remain_cap >=item )\n    priorities[almost_full] += 5\n\n    # Rule 4: Add some noise to break ties randomly.\n    available_bins = bins_remain_cap >= item\n    priorities[available_bins] += np.random.normal(0, 1e-6, size=np.sum(available_bins))\n\n    return priorities",
    "response_id": 2,
    "obj": 3.948942959712818,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response3.txt_stdout.txt",
    "code_path": "problem_iter9_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Rule 1: Infeasible bins get a very negative priority.\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -1e9\n\n    # Rule 2: Quantify \"good fit\" using relative wasted space.\n    available_bins = bins_remain_cap >= item\n    if np.any(available_bins):\n        wasted_space = bins_remain_cap[available_bins] - item\n        relative_wasted_space = wasted_space / (bins_remain_cap[available_bins] + 1e-9)\n\n        # Good fit = low relative wasted space.  Invert and scale.\n        priorities[available_bins] = 1.0 / (0.01 + relative_wasted_space)\n\n\n        #Reward bins approaching a target fullness (e.g., 75%)\n        max_cap = np.max(bins_remain_cap)\n        target_fullness = 0.75 * max_cap if max_cap > 0 else 0.0\n        target_range = 0.2 * max_cap if max_cap > 0 else 0.1 #Scale relative to maximum bin size. Increased range.\n\n        target_bonus = np.exp(-((bins_remain_cap[available_bins] - item - target_fullness)**2) / (2 * target_range**2))\n        priorities[available_bins] += target_bonus * 0.5\n\n\n    # Rule 3: Prioritize almost full bins to complete them, but make it relative to bin size.\n    almost_full = (bins_remain_cap >= item) & (bins_remain_cap - item < 0.1 * np.max(bins_remain_cap) if np.max(bins_remain_cap)>0 else bins_remain_cap >=item )\n    priorities[almost_full] += 10  # Give a significant bonus to almost full bins, relatively\n\n    # Rule 4: Add some noise to break ties randomly.\n    available_bins = bins_remain_cap >= item\n    priorities[available_bins] += np.random.normal(0, 1e-6, size=np.sum(available_bins))\n\n    return priorities",
    "response_id": 3,
    "obj": 3.948942959712818,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response4.txt_stdout.txt",
    "code_path": "problem_iter9_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Rule 1: Infeasible bins get a very negative priority.\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -1e9\n\n    # Rule 2: Prioritize bins that minimize relative wasted space.\n    available_bins = bins_remain_cap >= item\n    if np.any(available_bins):\n        wasted_space = bins_remain_cap[available_bins] - item\n        relative_wasted_space = wasted_space / (bins_remain_cap[available_bins] + 1e-9)  # Wasted space relative to *remaining* capacity\n\n        priorities[available_bins] = 1.0 / (0.01 + relative_wasted_space) # Invert for priority\n\n        # Rule 3: Bonus for bins nearing target fullness (75%) - relative to bin capacity\n        bin_capacities = bins_remain_cap + item  # Approximates the initial bin capacity\n        target_fullness = 0.75 * bin_capacities[available_bins]\n        target_range = 0.1 * bin_capacities[available_bins]\n\n        target_bonus = np.exp(-((bins_remain_cap[available_bins] - target_fullness)**2) / (2 * target_range**2))\n        priorities[available_bins] += target_bonus * 0.5\n\n    # Rule 4: Prioritize almost full bins to complete them.\n    almost_full_threshold = 0.1 * np.max(bin_capacities) if np.max(bin_capacities) > 0 else 0.1 #Threshold relative to inital bin size\n    almost_full = (bins_remain_cap >= item) & (bins_remain_cap - item < almost_full_threshold)\n    priorities[almost_full] += 10\n\n    # Rule 5: Small noise to break ties.\n    priorities[available_bins] += np.random.normal(0, 1e-6, size=np.sum(available_bins))\n\n    return priorities",
    "response_id": 4,
    "obj": 4.048663741523748,
    "exec_success": true
  }
]