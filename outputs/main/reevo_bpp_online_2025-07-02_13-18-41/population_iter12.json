[
  {
    "stdout_filepath": "problem_iter12_response0.txt_stdout.txt",
    "code_path": "problem_iter12_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Rule 1: Infeasible bins get a very negative priority.\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -1e9\n\n    # Rule 2: Quantify \"good fit\" using relative wasted space.\n    available_bins = bins_remain_cap >= item\n    if np.any(available_bins):\n        wasted_space = bins_remain_cap[available_bins] - item\n        relative_wasted_space = wasted_space / (bins_remain_cap[available_bins] + 1e-9)\n\n        # Good fit = low relative wasted space.  Invert and scale.\n        priorities[available_bins] = 1.0 / (0.01 + relative_wasted_space)\n\n        # Reward bins approaching a target fullness (e.g., 75%)\n        max_cap = np.max(bins_remain_cap)\n        target_fullness = 0.75 * max_cap if max_cap > 0 else 0.0\n        target_range = 0.2 * max_cap if max_cap > 0 else 0.1  # Scale relative to maximum bin size. Increased range.\n\n        if max_cap > 0:\n            target_bonus = np.exp(-((bins_remain_cap[available_bins] - item - (max_cap - target_fullness)) ** 2) / (2 * target_range ** 2))\n        else:\n            target_bonus = np.zeros_like(bins_remain_cap[available_bins])\n        priorities[available_bins] += target_bonus * 0.5\n\n\n    # Rule 3: Prioritize almost full bins to complete them, but make it relative to bin size.\n    max_cap = np.max(bins_remain_cap)\n    almost_full_threshold = 0.1 * max_cap if max_cap > 0 else 0.1\n    almost_full = (bins_remain_cap >= item) & (bins_remain_cap - item <= almost_full_threshold)\n    priorities[almost_full] += 20  # Give a significant bonus to almost full bins, relatively\n\n    # Rule 4: Add some noise to break ties randomly.\n    available_bins = bins_remain_cap >= item\n    priorities[available_bins] += np.random.normal(0, 1e-6, size=np.sum(available_bins))\n\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response1.txt_stdout.txt",
    "code_path": "problem_iter12_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Rule 1: Infeasible bins get a very negative priority.\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -1e9\n\n    # Rule 2: Quantify \"good fit\" using relative wasted space, scaled by remaining capacity.\n    available_bins = bins_remain_cap >= item\n    if np.any(available_bins):\n        wasted_space = bins_remain_cap[available_bins] - item\n        relative_wasted_space = wasted_space / (bins_remain_cap[available_bins] + 1e-9)\n\n        # Good fit = low relative wasted space.  Invert and scale.\n        priorities[available_bins] = 1.0 / (0.01 + relative_wasted_space)\n\n        # Reward bins approaching a target fullness (e.g., 75%)\n        max_cap = np.max(bins_remain_cap) if len(bins_remain_cap) > 0 else 1.0  # Avoid edge case where bins_remain_cap is empty\n        target_fullness = 0.75 * max_cap\n        target_range = 0.2 * max_cap  # Scale relative to maximum bin size. Increased range.\n\n        target_bonus = np.exp(-((bins_remain_cap[available_bins] - item - target_fullness) ** 2) / (2 * target_range ** 2))\n        priorities[available_bins] += target_bonus * 0.5\n\n    # Rule 3: Prioritize almost full bins to complete them, but make it relative to remaining capacity.\n    max_cap = np.max(bins_remain_cap) if len(bins_remain_cap) > 0 else 1.0  # Avoid edge case where bins_remain_cap is empty\n    almost_full_threshold = 0.1 * max_cap\n    almost_full = (bins_remain_cap >= item) & (bins_remain_cap - item < almost_full_threshold)\n    #Scale bonus by how close it is to being full\n    proximity_bonus = 1 - ((bins_remain_cap[almost_full] - item) / almost_full_threshold)\n    priorities[almost_full] += 10 * proximity_bonus  # Give a significant bonus to almost full bins, relatively\n\n    # Rule 4: Add some noise to break ties randomly.\n    available_bins = bins_remain_cap >= item\n    priorities[available_bins] += np.random.normal(0, 1e-6, size=np.sum(available_bins))\n\n    return priorities",
    "response_id": 1,
    "obj": 3.948942959712818,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response2.txt_stdout.txt",
    "code_path": "problem_iter12_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Rule 1: Infeasible bins get a very negative priority.\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -1e9\n\n    # Rule 2: Quantify \"good fit\" using relative wasted space.\n    available_bins = bins_remain_cap >= item\n    if np.any(available_bins):\n        wasted_space = bins_remain_cap[available_bins] - item\n        relative_wasted_space = wasted_space / (bins_remain_cap[available_bins] + 1e-9)\n\n        # Good fit = low relative wasted space.  Invert and scale.\n        priorities[available_bins] = 1.0 / (0.01 + relative_wasted_space)\n\n        # Reward bins approaching a target fullness (e.g., 75%)\n        max_cap = np.max(bins_remain_cap)\n        target_fullness = 0.75 * max_cap if max_cap > 0 else 0.0\n        target_range = 0.2 * max_cap if max_cap > 0 else 0.1  # Scale relative to maximum bin size. Increased range.\n\n        target_bonus = np.exp(-((bins_remain_cap[available_bins] - item - target_fullness) ** 2) / (2 * target_range ** 2))\n        priorities[available_bins] += target_bonus * 0.5\n\n    # Rule 3: Prioritize almost full bins to complete them, but make it relative to bin size.\n    max_cap = np.max(bins_remain_cap)\n    almost_full_threshold = 0.1 * max_cap if max_cap > 0 else 0.1\n    almost_full = (bins_remain_cap >= item) & (bins_remain_cap - item < almost_full_threshold)\n    priorities[almost_full] += 10  # Give a significant bonus to almost full bins, relatively\n\n    # Rule 4: Slightly prioritize bins with smaller remaining capacity (avoid spreading items too thin).\n    if np.any(available_bins):\n        priorities[available_bins] += (max_cap - bins_remain_cap[available_bins]) / (max_cap + 1e-9) * 0.1 if max_cap>0 else 0.0\n\n    # Rule 5: Add some noise to break ties randomly.\n    available_bins = bins_remain_cap >= item\n    priorities[available_bins] += np.random.normal(0, 1e-6, size=np.sum(available_bins))\n\n    return priorities",
    "response_id": 2,
    "obj": 3.9389708815317115,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response3.txt_stdout.txt",
    "code_path": "problem_iter12_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Rule 1: Infeasible bins get a very negative priority.\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -1e9\n\n    # Rule 2: Quantify \"good fit\" using relative wasted space.\n    available_bins = bins_remain_cap >= item\n    if np.any(available_bins):\n        wasted_space = bins_remain_cap[available_bins] - item\n        relative_wasted_space = wasted_space / (bins_remain_cap[available_bins] + 1e-9)\n\n        # Good fit = low relative wasted space. Invert and scale.\n        priorities[available_bins] = 1.0 / (0.01 + relative_wasted_space)\n\n        # Reward bins approaching a target fullness (e.g., 75%)\n        max_cap = np.max(bins_remain_cap) if len(bins_remain_cap) > 0 else 1.0  # Avoid edge case where bins_remain_cap is empty\n        target_fullness = 0.75 * max_cap\n        target_range = 0.2 * max_cap  # Scale relative to maximum bin size. Increased range.\n\n        target_bonus = np.exp(-((bins_remain_cap[available_bins] - item - target_fullness)**2) / (2 * target_range**2))\n        priorities[available_bins] += target_bonus * 0.5\n\n    # Rule 3: Prioritize almost full bins to complete them, but make it relative to remaining capacity.\n    max_cap = np.max(bins_remain_cap) if len(bins_remain_cap) > 0 else 1.0  # Avoid edge case where bins_remain_cap is empty\n    almost_full_threshold = 0.1 * max_cap\n    almost_full = (bins_remain_cap >= item) & (bins_remain_cap - item < almost_full_threshold)\n    priorities[almost_full] += 10  # Give a significant bonus to almost full bins, relatively\n\n    # Rule 4: Add some noise to break ties randomly, but reduce the noise\n    available_bins = bins_remain_cap >= item\n    priorities[available_bins] += np.random.normal(0, 1e-7, size=np.sum(available_bins))\n\n    #Rule 5: Prioritize bins with larger remaining capacity slightly more\n    priorities[available_bins] += bins_remain_cap[available_bins] / (max_cap + 1e-9) * 0.1\n\n    return priorities",
    "response_id": 3,
    "obj": 3.948942959712818,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response4.txt_stdout.txt",
    "code_path": "problem_iter12_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Rule 1: Infeasible bins get a very negative priority.\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -1e9\n\n    # Rule 2: Quantify \"good fit\" using relative wasted space.\n    available_bins = bins_remain_cap >= item\n    if np.any(available_bins):\n        wasted_space = bins_remain_cap[available_bins] - item\n        relative_wasted_space = wasted_space / (bins_remain_cap[available_bins] + 1e-9)\n\n        # Good fit = low relative wasted space.  Invert and scale.\n        priorities[available_bins] = 1.0 / (0.01 + relative_wasted_space)\n\n        # Reward bins approaching a target fullness (e.g., 75%)\n        target_fullness = 0.75\n        target_range = 0.2\n\n        remaining_capacity_ratio = bins_remain_cap[available_bins] / np.max(bins_remain_cap) if np.max(bins_remain_cap)>0 else 0.0\n        item_ratio = item / np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else 0.0\n        target_bonus = np.exp(-((remaining_capacity_ratio - item_ratio - (1 - target_fullness))**2) / (2 * target_range**2))\n        priorities[available_bins] += target_bonus * 0.5\n\n    # Rule 3: Prioritize almost full bins to complete them, but make it relative to bin size.\n    almost_full_threshold = 0.1\n    almost_full = (bins_remain_cap >= item) & ((bins_remain_cap - item) / (bins_remain_cap + 1e-9) < almost_full_threshold)\n    priorities[almost_full] += 10  # Give a significant bonus to almost full bins, relatively\n\n    # Rule 4: Add some noise to break ties randomly.\n    available_bins = bins_remain_cap >= item\n    priorities[available_bins] += np.random.normal(0, 1e-6, size=np.sum(available_bins))\n\n    return priorities",
    "response_id": 4,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response5.txt_stdout.txt",
    "code_path": "problem_iter12_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Rule 1: Infeasible bins get a very negative priority.\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -1e9\n\n    # Rule 2: Quantify \"good fit\" using relative wasted space.\n    available_bins = bins_remain_cap >= item\n    if np.any(available_bins):\n        wasted_space = bins_remain_cap[available_bins] - item\n        relative_wasted_space = wasted_space / (bins_remain_cap[available_bins] + 1e-9)\n\n        # Good fit = low relative wasted space. Invert and scale.\n        priorities[available_bins] = 1.0 / (0.01 + relative_wasted_space)\n\n        # Reward bins approaching a target fullness (e.g., 75%)\n        target_fullness = 0.75\n        target_range = 0.2\n\n        relative_remaining = bins_remain_cap[available_bins] / np.max(bins_remain_cap, initial=1) if len(bins_remain_cap) > 0 else 0\n        target_bonus = np.exp(-((relative_remaining - (item/ np.max(bins_remain_cap, initial=1)) - target_fullness)**2) / (2 * target_range**2))\n        priorities[available_bins] += target_bonus * 0.5\n\n    # Rule 3: Prioritize almost full bins to complete them, but make it relative.\n    almost_full_threshold = 0.1\n    relative_remaining = bins_remain_cap / np.max(bins_remain_cap, initial=1) if len(bins_remain_cap) > 0 else bins_remain_cap\n    almost_full = (bins_remain_cap >= item) & (relative_remaining - (item/ np.max(bins_remain_cap, initial=1)) < almost_full_threshold)\n    priorities[almost_full] += 10\n\n    # Rule 4: Add some noise to break ties randomly.\n    available_bins = bins_remain_cap >= item\n    priorities[available_bins] += np.random.normal(0, 1e-6, size=np.sum(available_bins))\n\n    return priorities",
    "response_id": 5,
    "obj": 3.948942959712818,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response6.txt_stdout.txt",
    "code_path": "problem_iter12_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Rule 1: Infeasible bins get a very negative priority.\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -1e9\n\n    # Rule 2: Quantify \"good fit\" using relative wasted space (local normalization).\n    available_bins = bins_remain_cap >= item\n    if np.any(available_bins):\n        wasted_space = bins_remain_cap[available_bins] - item\n        relative_wasted_space = wasted_space / (bins_remain_cap[available_bins] + 1e-9)\n\n        priorities[available_bins] = 1.0 / (0.01 + relative_wasted_space)\n\n        # Reward bins approaching a target fullness (e.g., 80% of bin capacity)\n        max_cap = np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else 1.0\n        target_fullness = 0.80 * max_cap\n        target_range = 0.15 * max_cap\n\n        target_bonus = np.exp(-((bins_remain_cap[available_bins] - item - target_fullness)**2) / (2 * target_range**2))\n        priorities[available_bins] += target_bonus * 0.7\n\n    # Rule 3: Prioritize almost full bins to complete them (adjusted threshold)\n    almost_full = (bins_remain_cap >= item) & (bins_remain_cap - item < 0.2 * np.max(bins_remain_cap) if np.max(bins_remain_cap)>0 else bins_remain_cap >=item )\n    priorities[almost_full] += 15\n\n    # Rule 4: Add small noise for tie-breaking.\n    available_bins = bins_remain_cap >= item\n    priorities[available_bins] += np.random.normal(0, 1e-6, size=np.sum(available_bins))\n\n    return priorities",
    "response_id": 6,
    "obj": 3.9090546469884373,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response7.txt_stdout.txt",
    "code_path": "problem_iter12_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Rule 1: Infeasible bins get a very negative priority.\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -1e9\n\n    # Rule 2: Quantify \"good fit\" using relative wasted space.\n    available_bins = bins_remain_cap >= item\n    if np.any(available_bins):\n        wasted_space = bins_remain_cap[available_bins] - item\n        relative_wasted_space = wasted_space / (bins_remain_cap[available_bins] + 1e-9)\n\n        # Good fit = low relative wasted space.  Invert and scale.\n        priorities[available_bins] = 1.0 / (0.01 + relative_wasted_space)\n\n        # Reward bins approaching a target fullness (e.g., 75%)\n        max_cap = np.max(bins_remain_cap)\n        target_fullness = 0.75 if max_cap > 0 else 0.0  # Use a ratio instead of scaled value\n        target_range = 0.2  #Keep target range relative, independent of max_cap\n\n        fullness_deviation = np.abs((bins_remain_cap[available_bins] - item) / (max_cap + 1e-9) - target_fullness) if max_cap > 0 else 0 #deviation from target ratio\n        target_bonus = np.exp(-(fullness_deviation**2) / (2 * target_range**2))\n        priorities[available_bins] += target_bonus * 0.5\n\n\n    # Rule 3: Prioritize almost full bins to complete them, but make it relative to bin size.\n    max_cap = np.max(bins_remain_cap)\n    almost_full_threshold = 0.1 #Relative almost full threshold.\n    almost_full = (bins_remain_cap >= item) & ((bins_remain_cap - item) / (max_cap + 1e-9) < almost_full_threshold) if max_cap > 0 else (bins_remain_cap >= item) & (bins_remain_cap - item < 0.1)\n    priorities[almost_full] += 20  # Give a significant bonus to almost full bins, relatively\n\n    # Rule 4: Add some noise to break ties randomly.\n    available_bins = bins_remain_cap >= item\n    priorities[available_bins] += np.random.normal(0, 1e-6, size=np.sum(available_bins))\n\n    return priorities",
    "response_id": 7,
    "obj": 3.948942959712818,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response8.txt_stdout.txt",
    "code_path": "problem_iter12_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Rule 1: Infeasible bins get a very negative priority.\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -1e9\n\n    # Rule 2: Quantify \"good fit\" using relative wasted space.\n    available_bins = bins_remain_cap >= item\n    if np.any(available_bins):\n        wasted_space = bins_remain_cap[available_bins] - item\n        relative_wasted_space = wasted_space / (bins_remain_cap[available_bins] + 1e-9)\n\n        priorities[available_bins] = 1.0 / (0.01 + relative_wasted_space)\n\n        # Reward bins approaching a target fullness (e.g., 75% of bin capacity)\n        max_cap = np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else 1.0\n        target_fullness = 0.75 * max_cap\n        target_range = 0.15 * max_cap\n\n        target_bonus = np.exp(-((bins_remain_cap[available_bins] - item - target_fullness)**2) / (2 * target_range**2))\n        priorities[available_bins] += target_bonus * 0.7\n\n    # Rule 3: Prioritize almost full bins to complete them\n    almost_full_threshold = 0.15 * np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else 0.15\n    almost_full = (bins_remain_cap >= item) & (bins_remain_cap - item < almost_full_threshold)\n    priorities[almost_full] += 15\n\n    # Rule 4: Add small noise for tie-breaking.\n    available_bins = bins_remain_cap >= item\n    priorities[available_bins] += np.random.normal(0, 1e-6, size=np.sum(available_bins))\n\n    # Rule 5: Favor bins with larger remaining capacity when the item is large\n    large_item_threshold = 0.5 * np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else 0.5\n    if item > large_item_threshold:\n        priorities[available_bins] += bins_remain_cap[available_bins] / (np.max(bins_remain_cap) + 1e-9) * 0.5\n\n    return priorities",
    "response_id": 8,
    "obj": 3.8093338651775075,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response9.txt_stdout.txt",
    "code_path": "problem_iter12_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Rule 1: Infeasible bins get a very negative priority.\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -1e9\n\n    # Rule 2: Quantify \"good fit\" using relative wasted space.\n    available_bins = bins_remain_cap >= item\n    if np.any(available_bins):\n        wasted_space = bins_remain_cap[available_bins] - item\n        relative_wasted_space = wasted_space / (item + 1e-9) # Using item size for relative calculation\n\n        # Good fit = low relative wasted space. Invert and scale. Using item size for normalization\n        priorities[available_bins] = 1.0 / (0.01 + relative_wasted_space)\n\n        # Reward bins approaching a target fullness (e.g., 75%)\n        max_cap = np.max(bins_remain_cap) if bins_remain_cap.size > 0 else 1.0\n        target_fullness = 0.75 * max_cap\n        target_range = 0.2 * max_cap\n\n        target_bonus = np.exp(-((bins_remain_cap[available_bins] - item - target_fullness)**2) / (2 * target_range**2))\n        priorities[available_bins] += target_bonus * 0.5\n\n        # Rule 3: Prioritize almost full bins to complete them, but make it relative to bin size.\n        almost_full_threshold = 0.1 * max_cap\n        almost_full = (bins_remain_cap[available_bins] - item < almost_full_threshold)\n        priorities[available_bins][almost_full] += 10  # Significant bonus to almost full bins\n\n    # Rule 4: Add some noise to break ties randomly, scaled by item size.\n    noise_std = 1e-6 * item\n    priorities[available_bins] += np.random.normal(0, noise_std, size=np.sum(available_bins))\n\n    return priorities",
    "response_id": 9,
    "obj": 3.9688871160749857,
    "exec_success": true
  }
]