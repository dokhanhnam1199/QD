```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:

    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Infeasible bins get a large negative priority
    infeasible_bins = bins_remain_cap < item
    priorities[infeasible_bins] = -1e9

    # Calculate wasted space if item is placed in each bin
    wasted_space = bins_remain_cap - item
    wasted_space[wasted_space < 0] = np.inf  # Mark infeasible bins

    # Capacity ratio based tight fit
    capacity_ratio = item / bins_remain_cap
    tight_fit_priority = np.exp(-10 * np.abs(capacity_ratio - 1)) # Peaks at capacity ratio = 1 (item == remaining capacity)

    priorities[~infeasible_bins] += tight_fit_priority[~infeasible_bins] * 10 # Scale tight fit priority

    # Large gap penalty
    gap_ratio = wasted_space / bins_remain_cap
    large_gap_penalty = (gap_ratio > 0.8) * (gap_ratio * 10)  # Penalize gaps exceeding 80% of bin size
    priorities[~infeasible_bins] -= large_gap_penalty[~infeasible_bins]

    # Near-full bin reward
    near_full_threshold = 0.95
    near_full_reward = ((bins_remain_cap - item) / bins_remain_cap > near_full_threshold) * 5
    priorities[~infeasible_bins] += near_full_reward[~infeasible_bins]

    # Adaptive penalty/bonus based on bin utilization
    bin_utilization = (bins_remain_cap - wasted_space) / bins_remain_cap  # Fraction of the bin that would be filled
    adaptive_factor = np.clip(bin_utilization, 0, 1)
    priorities[~infeasible_bins] += adaptive_factor[~infeasible_bins] * 3 # Reward higher utilization
    
    # Small item bonus: Preferentially use bins with higher remaining capacity if the item is small
    small_item_threshold = 0.1
    if item < small_item_threshold:
        priorities[~infeasible_bins] += bins_remain_cap[~infeasible_bins] * 0.1

    # Noise for tie-breaking
    priorities[~infeasible_bins] += np.random.normal(0, 1e-6, size=np.sum(~infeasible_bins))

    return priorities
```
