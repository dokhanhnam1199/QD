```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Mark infeasible bins with a very low priority
    infeasible_bins = bins_remain_cap < item
    priorities[infeasible_bins] = -1e9

    # Calculate wasted space after placing the item
    wasted_space = bins_remain_cap - item
    wasted_space[wasted_space < 0] = np.inf  # Ensure infeasible bins have infinite wasted space

    # Tight-Fit Reward: Favor bins with minimal wasted space relative to item size and bin capacity
    # A higher reward is given if the item fills a significant portion of the bin.
    tight_fit_score = (item / bins_remain_cap) * (1 - wasted_space / bins_remain_cap)
    priorities[~infeasible_bins] += tight_fit_score[~infeasible_bins] * 10

    # Large-Gap Penalty: Penalize bins where the wasted space is a significant fraction of the bin's capacity.
    large_gap_threshold = 0.6  # Tune this threshold to control how much wasted space is acceptable
    large_gap_penalty = -5  # Tune the penalty strength
    large_gap = wasted_space / bins_remain_cap > large_gap_threshold
    priorities[large_gap] += large_gap_penalty

    # Fill-Level Adaptation: Adjust the priority based on how full the bin will be after placing the item.
    # This encourages using partially filled bins while avoiding excessive fragmentation.
    fill_level = 1 - wasted_space / bins_remain_cap
    adaptive_factor = np.clip(fill_level * 3, -1, 1)  # Scale and clip the factor for stability
    priorities[~infeasible_bins] += adaptive_factor[~infeasible_bins]

    # Small remaining capacity reward
    small_remaining_capacity_threshold = 0.15
    small_remaining_capacity_reward = 2
    small_remaining = wasted_space / bins_remain_cap < small_remaining_capacity_threshold
    priorities[small_remaining] += small_remaining_capacity_reward
    

    # Tie-Breaking Noise: Add small random noise to break ties and explore different packing configurations.
    priorities[~infeasible_bins] += np.random.normal(0, 1e-6, size=np.sum(~infeasible_bins))

    return priorities
```
