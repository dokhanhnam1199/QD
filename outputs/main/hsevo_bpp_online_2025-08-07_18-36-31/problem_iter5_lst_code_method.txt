{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\n# Priority: minimize leftover space, large boost for exact fits\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Score bins: higher for smaller leftover after item, with big bonus for exact fits.\"\"\"\n    fit = bins_remain_cap >= item\n    leftover = bins_remain_cap - item\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    exact_bonus = 1e6\n    eps = 1e-9\n    priorities[fit] = -leftover[fit] + np.where(leftover[fit] <= eps, exact_bonus, 0.0)\n    return priorities\n\n[Heuristics 2nd]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, w: float = 0.7160738679422335, M: float = 8210866497.623484) -> np.ndarray:\n    \"\"\"Combines best-fit (-residual^2) and worst-fit (remaining capacity) using a weighted sum, plus an exact-fit bonus. Deterministic, vectorized, no randomness.\"\"\"\n    feasible = bins_remain_cap >= item\n    residual = bins_remain_cap - item\n    base = np.where(feasible, -residual**2 + w * bins_remain_cap, -np.inf)\n    exact = np.isclose(residual, 0.0)\n    priorities = base + np.where(exact, M, 0.0)\n    return priorities\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    leftover = bins_remain_cap - item\n    feas = leftover >= 0\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)\n    priorities[feas] = -leftover[feas]\n    return priorities\n\n[Heuristics 4th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Monotonic inverse-leftover score with exact\u2011fit boost.\n    \"\"\"\n    eps = 1e-9\n    fit_mask = bins_remain_cap >= item\n    base = np.where(fit_mask, 1.0 / (bins_remain_cap - item + eps), -np.inf)\n    exact_bonus = np.where(fit_mask & (bins_remain_cap == item), 1e7, 0.0)\n    return base + exact_bonus\n\n[Heuristics 5th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, w: float = 0.7160738679422335, M: float = 8210866497.623484) -> np.ndarray:\n    \"\"\"Combines best-fit (-residual^2) and worst-fit (remaining capacity) using a weighted sum, plus an exact-fit bonus. Deterministic, vectorized, no randomness.\"\"\"\n    feasible = bins_remain_cap >= item\n    residual = bins_remain_cap - item\n    base = np.where(feasible, -residual**2 + w * bins_remain_cap, -np.inf)\n    exact = np.isclose(residual, 0.0)\n    priorities = base + np.where(exact, M, 0.0)\n    return priorities\n\n[Heuristics 6th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit (-residual^2) and worst-fit (remaining capacity) using a weighted sum, plus an exact-fit bonus. Deterministic, vectorized, no randomness.\"\"\"\n    feasible = bins_remain_cap >= item\n    residual = bins_remain_cap - item\n    w = 0.5\n    base = np.where(feasible, -residual**2 + w * bins_remain_cap, -np.inf)\n    exact = np.isclose(residual, 0.0)\n    M = 1e9\n    priorities = base + np.where(exact, M, 0.0)\n    return priorities\n\n[Heuristics 7th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    leftover = bins_remain_cap - item\n    feas = leftover >= 0\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)\n    priorities[feas] = -leftover[feas]\n    return priorities\n\n[Heuristics 8th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Score bins: highest for smallest leftover, boost exact fits, deterministic tie\u2011break.\"\"\"\n    mask = bins_remain_cap >= item\n    residual = bins_remain_cap - item\n    priority = -residual\n    priority[np.isclose(bins_remain_cap, item)] += 1.0\n    priority += -np.arange(bins_remain_cap.shape[0], dtype=float) * 1e-12\n    priority = np.where(mask, priority, -np.inf)\n    return priority\n\n[Heuristics 9th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Compute negative leftover with exact\u2011fit bonus and tie\u2011break by index.\"\"\"\n    gap = bins_remain_cap - item\n    feasible = gap >= 0\n    idx = np.arange(len(bins_remain_cap))\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    bonus = np.where(gap == 0, 1e-6, 0.0)\n    priorities[feasible] = -gap[feasible] + bonus[feasible] - 1e-12 * idx[feasible]\n    return priorities\n\n[Heuristics 10th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Compute a deterministic, monotonic priority score for each bin based on the residual\n    capacity after placing an item. The priority is higher for bins that are closer to an\n    exact fit. An exact or near\u2011exact fit receives a small bonus so that it is always\n    preferred over a bin with a larger remaining capacity.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities for each bin.\n\n    Returns\n    -------\n    np.ndarray\n        1\u2011D array of priority scores; larger values indicate a more desirable bin.\n        Bins that cannot accommodate the item are given a priority of -inf.\n    \"\"\"\n    leftover = bins_remain_cap - item\n    feas = leftover >= 0\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)\n    epsilon = 1e-12\n    exact_fit = leftover <= epsilon\n    bonus = 1e-6\n    priorities[feas] = -leftover[feas] + bonus * exact_fit[feas]\n    return priorities\n\n[Heuristics 11th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines inverse residual scoring with exact-fit boost and mild remaining-capacity tie-breaker.\n    \"\"\"\n    leftover = bins_remain_cap - item\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    fit_mask = leftover >= 0\n    priorities[fit_mask] = 1.0 / (1.0 + leftover[fit_mask])\n    exact_mask = fit_mask & (leftover == 0)\n    priorities[exact_mask] += 10.0\n    priorities[fit_mask] += 0.01 * bins_remain_cap[fit_mask]\n    return priorities\n\n[Heuristics 12th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines inverse residual scoring with exact-fit boost and mild remaining-capacity tie-breaker.\n    \"\"\"\n    leftover = bins_remain_cap - item\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    fit_mask = leftover >= 0\n    priorities[fit_mask] = 1.0 / (1.0 + leftover[fit_mask])\n    exact_mask = fit_mask & (leftover == 0)\n    priorities[exact_mask] += 10.0\n    priorities[fit_mask] += 0.01 * bins_remain_cap[fit_mask]\n    return priorities\n\n[Heuristics 13th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines inverse residual scoring with exact-fit boost and mild remaining-capacity tie-breaker.\n    \"\"\"\n    leftover = bins_remain_cap - item\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    fit_mask = leftover >= 0\n    priorities[fit_mask] = 1.0 / (1.0 + leftover[fit_mask])\n    exact_mask = fit_mask & (leftover == 0)\n    priorities[exact_mask] += 10.0\n    priorities[fit_mask] += 0.01 * bins_remain_cap[fit_mask]\n    return priorities\n\n[Heuristics 14th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines inverse residual scoring with exact-fit boost and mild remaining-capacity tie-breaker.\n    \"\"\"\n    leftover = bins_remain_cap - item\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    fit_mask = leftover >= 0\n    priorities[fit_mask] = 1.0 / (1.0 + leftover[fit_mask])\n    exact_mask = fit_mask & (leftover == 0)\n    priorities[exact_mask] += 10.0\n    priorities[fit_mask] += 0.01 * bins_remain_cap[fit_mask]\n    return priorities\n\n[Heuristics 15th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines inverse residual scoring with exact-fit boost and mild remaining-capacity tie-breaker.\n    \"\"\"\n    leftover = bins_remain_cap - item\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    fit_mask = leftover >= 0\n    priorities[fit_mask] = 1.0 / (1.0 + leftover[fit_mask])\n    exact_mask = fit_mask & (leftover == 0)\n    priorities[exact_mask] += 10.0\n    priorities[fit_mask] += 0.01 * bins_remain_cap[fit_mask]\n    return priorities\n\n[Heuristics 16th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines inverse residual scoring with exact-fit boost and mild remaining-capacity tie-breaker.\n    \"\"\"\n    leftover = bins_remain_cap - item\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    fit_mask = leftover >= 0\n    priorities[fit_mask] = 1.0 / (1.0 + leftover[fit_mask])\n    exact_mask = fit_mask & (leftover == 0)\n    priorities[exact_mask] += 10.0\n    priorities[fit_mask] += 0.01 * bins_remain_cap[fit_mask]\n    return priorities\n\n[Heuristics 17th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines inverse residual scoring with exact-fit boost and mild remaining-capacity tie-breaker.\n    \"\"\"\n    leftover = bins_remain_cap - item\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    fit_mask = leftover >= 0\n    priorities[fit_mask] = 1.0 / (1.0 + leftover[fit_mask])\n    exact_mask = fit_mask & (leftover == 0)\n    priorities[exact_mask] += 10.0\n    priorities[fit_mask] += 0.01 * bins_remain_cap[fit_mask]\n    return priorities\n\n[Heuristics 18th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines inverse residual scoring with exact-fit boost and mild remaining-capacity tie-breaker.\n    \"\"\"\n    leftover = bins_remain_cap - item\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    fit_mask = leftover >= 0\n    priorities[fit_mask] = 1.0 / (1.0 + leftover[fit_mask])\n    exact_mask = fit_mask & (leftover == 0)\n    priorities[exact_mask] += 10.0\n    priorities[fit_mask] += 0.01 * bins_remain_cap[fit_mask]\n    return priorities\n\n[Heuristics 19th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines inverse residual scoring with exact-fit boost and mild remaining-capacity tie-breaker.\n    \"\"\"\n    leftover = bins_remain_cap - item\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    fit_mask = leftover >= 0\n    priorities[fit_mask] = 1.0 / (1.0 + leftover[fit_mask])\n    exact_mask = fit_mask & (leftover == 0)\n    priorities[exact_mask] += 10.0\n    priorities[fit_mask] += 0.01 * bins_remain_cap[fit_mask]\n    return priorities\n\n[Heuristics 20th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines inverse residual scoring with exact-fit boost and mild remaining-capacity tie-breaker.\n    \"\"\"\n    leftover = bins_remain_cap - item\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    fit_mask = leftover >= 0\n    priorities[fit_mask] = 1.0 / (1.0 + leftover[fit_mask])\n    exact_mask = fit_mask & (leftover == 0)\n    priorities[exact_mask] += 10.0\n    priorities[fit_mask] += 0.01 * bins_remain_cap[fit_mask]\n    return priorities\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}