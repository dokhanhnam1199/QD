[
  {
    "stdout_filepath": "problem_iter1_response0.txt_stdout.txt",
    "code_path": "problem_iter1_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using First Fit.\"\"\"\n    n = bins_remain_cap.shape[0]\n    priorities = -np.arange(n)\n    feasible = bins_remain_cap >= item\n    priorities = np.where(feasible, priorities, -np.inf)\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response1.txt_stdout.txt",
    "code_path": "problem_iter1_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    leftover = bins_remain_cap - item\n    feas = leftover >= 0\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)\n    priorities[feas] = -leftover[feas]\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response2.txt_stdout.txt",
    "code_path": "problem_iter1_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin using Worst Fit.\n    \"\"\"\n    can_fit = bins_remain_cap >= item\n    priorities = np.where(can_fit, bins_remain_cap - item, -np.inf)\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 149.30195452732352,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response3.txt_stdout.txt",
    "code_path": "problem_iter1_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    bins = bins_remain_cap.astype(float)\n    rem = bins - item\n    priorities = np.full_like(bins, -np.inf)\n    ok = rem >= 0\n    priorities[ok] = -rem[ok]\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response4.txt_stdout.txt",
    "code_path": "problem_iter1_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    fit = bins_remain_cap >= item\n    priorities = np.full(bins_remain_cap.shape, -np.inf, dtype=float)\n    priorities[fit] = -(bins_remain_cap[fit] - item)\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response5.txt_stdout.txt",
    "code_path": "problem_iter1_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    eps = 1e-12\n    diff = bins_remain_cap - item\n    return np.where(diff >= 0, 1.0 / (diff ** 2 + eps), 0.0)",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response6.txt_stdout.txt",
    "code_path": "problem_iter1_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Computes sigmoid fit score priorities for placing item in bins.\n\n    Args:\n        item: Size of the incoming item.\n        bins_remain_cap: Remaining capacities of bins.\n\n    Returns:\n        Priority scores for each bin; higher indicates better fit.\n    \"\"\"\n    residual = bins_remain_cap - item\n    mask = residual >= 0\n    priorities = np.full(bins_remain_cap.shape, -np.inf, dtype=float)\n    if not mask.any():\n        return priorities\n    k = 10.0\n    exp_neg = np.exp(-k * residual[mask])\n    sigmoid_score = 2 * exp_neg / (1 + exp_neg)\n    fill_factor = item / bins_remain_cap[mask]\n    priorities[mask] = fill_factor * sigmoid_score\n    return priorities",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response7.txt_stdout.txt",
    "code_path": "problem_iter1_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority scores for Random Fit bin selection.\"\"\"\n    scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    fit_mask = bins_remain_cap >= item\n    scores[fit_mask] = np.random.random(fit_mask.sum())\n    return scores",
    "response_id": 7,
    "tryHS": false,
    "obj": 73.54407658556043,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response8.txt_stdout.txt",
    "code_path": "problem_iter1_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.1) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for each bin using an epsilon\u2011greedy strategy.\n    \"\"\"\n    feasible = bins_remain_cap >= item\n    deterministic = item - bins_remain_cap\n    deterministic[~feasible] = -np.inf\n    random_scores = np.random.rand(bins_remain_cap.shape[0])\n    priorities = (1 - epsilon) * deterministic + epsilon * random_scores\n    priorities[~feasible] = -np.inf\n    return priorities",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response9.txt_stdout.txt",
    "code_path": "problem_iter1_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, temperature: float = 1.0) -> np.ndarray:\n    \"\"\"Returns priority scores for each bin using a softmax fit strategy.\"\"\"\n    caps = bins_remain_cap.astype(float)\n    mask = caps >= item\n    priorities = np.zeros_like(caps, dtype=float)\n    if not np.any(mask):\n        return priorities\n    residual = caps[mask] - item\n    exponent = np.exp(-residual / max(temperature, 1e-12))\n    total = exponent.sum()\n    if total > 0:\n        priorities[mask] = exponent / total\n    return priorities",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response10.txt_stdout.txt",
    "code_path": "problem_iter1_code10.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for each bin using the First Fit heuristic.\n    \"\"\"\n    mask = bins_remain_cap >= item\n    indices = np.arange(bins_remain_cap.shape[0], dtype=float)\n    priorities = np.where(mask, -indices, -np.inf)\n    return priorities",
    "response_id": 10,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response11.txt_stdout.txt",
    "code_path": "problem_iter1_code11.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    feasible = bins_remain_cap >= item\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    remaining = bins_remain_cap - item\n    priorities[feasible] = -remaining[feasible]\n    return priorities",
    "response_id": 11,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response12.txt_stdout.txt",
    "code_path": "problem_iter1_code12.py",
    "code": "import numpy as np\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority for worst-fit bin packing.\"\"\"\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    mask = bins_remain_cap >= item\n    priorities[mask] = bins_remain_cap[mask]\n    return priorities",
    "response_id": 12,
    "tryHS": false,
    "obj": 149.30195452732352,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response13.txt_stdout.txt",
    "code_path": "problem_iter1_code13.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    feasible = bins_remain_cap >= item\n    priority = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    priority[feasible] = -(bins_remain_cap[feasible] - item)\n    return priority",
    "response_id": 13,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response14.txt_stdout.txt",
    "code_path": "problem_iter1_code14.py",
    "code": "import numpy as np\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    M = 1e9\n    feasible = bins_remain_cap >= item\n    residual = bins_remain_cap - item\n    base = np.where(feasible, -residual, -np.inf)\n    exact = np.isclose(residual, 0.0)\n    priorities = base + np.where(exact, M, 0.0)\n    return priorities",
    "response_id": 14,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response15.txt_stdout.txt",
    "code_path": "problem_iter1_code15.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    epsilon = 1e-9\n    fit = bins_remain_cap >= item\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    priorities[fit] = 1.0 / (bins_remain_cap[fit] - item + epsilon)\n    return priorities",
    "response_id": 15,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response16.txt_stdout.txt",
    "code_path": "problem_iter1_code16.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Priority function using Sigmoid Fit Score strategy for online Bin Packing.\"\"\"\n    eps = 1e-9\n    k = 12.0\n    residual = bins_remain_cap - item\n    fit_mask = residual >= 0\n    priorities = np.where(fit_mask, 1 / (1 + np.exp(k * residual)), 0.0)\n    return priorities",
    "response_id": 16,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response17.txt_stdout.txt",
    "code_path": "problem_iter1_code17.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\"\"\"\n    priorities = np.random.rand(bins_remain_cap.shape[0])\n    return np.where(bins_remain_cap >= item, priorities, -np.inf)",
    "response_id": 17,
    "tryHS": false,
    "obj": 73.65376944555247,
    "SLOC": 3.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response18.txt_stdout.txt",
    "code_path": "problem_iter1_code18.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin using epsilon-greedy.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    epsilon = 0.1\n    mask = bins_remain_cap >= item\n    priorities = np.full(bins_remain_cap.shape, -np.inf)\n    if np.random.rand() < epsilon:\n        rand_prior = np.random.rand(bins_remain_cap.size)\n        priorities[mask] = rand_prior[mask]\n    else:\n        leftover = bins_remain_cap[mask] - item\n        priorities[mask] = -leftover\n    return priorities",
    "response_id": 18,
    "tryHS": false,
    "obj": 4.148384523334677,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response19.txt_stdout.txt",
    "code_path": "problem_iter1_code19.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    gaps = bins_remain_cap - item\n    fit = gaps >= 0\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    if np.any(fit):\n        scores = -gaps[fit]\n        max_score = scores.max()\n        exp_scores = np.exp(scores - max_score)\n        probs = exp_scores / exp_scores.sum()\n        priorities[fit] = probs\n    return priorities",
    "response_id": 19,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response20.txt_stdout.txt",
    "code_path": "problem_iter1_code20.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    fit = bins_remain_cap >= item\n    n = bins_remain_cap.size\n    priorities = np.full(n, -np.inf, dtype=float)\n    priorities[fit] = -(bins_remain_cap[fit] - item) + 1e-6 * (n - np.arange(n)[fit])\n    return priorities",
    "response_id": 20,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response21.txt_stdout.txt",
    "code_path": "problem_iter1_code21.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority for best fit placement of an item into bins.\n\n    Args:\n        item: Size of the item to be added to a bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of the same shape as bins_remain_cap with priority scores.\n    \"\"\"\n    priorities = np.full(bins_remain_cap.shape, -np.inf, dtype=float)\n    fit = bins_remain_cap >= item\n    priorities[fit] = item - bins_remain_cap[fit]\n    return priorities",
    "response_id": 21,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response22.txt_stdout.txt",
    "code_path": "problem_iter1_code22.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = bins_remain_cap - item\n    return np.where(bins_remain_cap >= item, priorities, -np.inf)",
    "response_id": 22,
    "tryHS": false,
    "obj": 149.30195452732352,
    "SLOC": 3.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response23.txt_stdout.txt",
    "code_path": "problem_iter1_code23.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    leftover = bins_remain_cap - item\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    fit_mask = leftover >= 0\n    priorities[fit_mask] = 1.0 / (1.0 + leftover[fit_mask])\n    return priorities",
    "response_id": 23,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response24.txt_stdout.txt",
    "code_path": "problem_iter1_code24.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    gap = bins_remain_cap - item\n    feasible = gap >= 0\n    idx = np.arange(bins_remain_cap.shape[0], dtype=float)\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    priorities[feasible] = -gap[feasible] - 1e-12 * idx[feasible]\n    return priorities",
    "response_id": 24,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response25.txt_stdout.txt",
    "code_path": "problem_iter1_code25.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    eps = 1e-9\n    leftover = bins_remain_cap - item\n    priorities = np.where(leftover >= 0, 1.0 / (leftover + eps), -np.inf)\n    return priorities",
    "response_id": 25,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response26.txt_stdout.txt",
    "code_path": "problem_iter1_code26.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using sigmoid fit score.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    residual = bins_remain_cap - item\n    feasible = residual >= 0\n    k = 10.0\n    eps = 1e-12\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    priorities[feasible] = 2.0 / (1.0 + np.exp(k * (residual[feasible] / (bins_remain_cap[feasible] + eps))))\n    return priorities",
    "response_id": 26,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response27.txt_stdout.txt",
    "code_path": "problem_iter1_code27.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    feasible = bins_remain_cap >= item\n    if np.random.rand() < 0:\n        pass\n    priorities[feasible] = np.random.random(np.count_nonzero(feasible))\n    return priorities",
    "response_id": 27,
    "tryHS": false,
    "obj": 72.80614280015956,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response28.txt_stdout.txt",
    "code_path": "problem_iter1_code28.py",
    "code": "import numpy as np\n\n_v2_call_count = 0\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using an epsilon\u2011greedy strategy.\n\n    Args:\n        item: Size of the item to be placed.\n        bins_remain_cap: Remaining capacities of the bins.\n\n    Returns:\n        An array of priority scores for each bin.\n    \"\"\"\n    global _v2_call_count\n    _v2_call_count += 1\n    epsilon = 0.5 / np.sqrt(_v2_call_count)\n    epsilon = min(epsilon, 0.3)\n    feasible = bins_remain_cap >= item\n    leftover = bins_remain_cap - item\n    exploit = -leftover\n    exploit[~feasible] = -np.inf\n    noise = np.random.rand(bins_remain_cap.size)\n    priorities = (1 - epsilon) * exploit + epsilon * noise\n    return priorities",
    "response_id": 28,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response29.txt_stdout.txt",
    "code_path": "problem_iter1_code29.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Softmax-Based Fit priority function.\"\"\"\n    feasible = bins_remain_cap >= item\n    slack = bins_remain_cap - item\n    alpha = 5.0\n    log_scores = np.where(feasible, -alpha * slack, -np.inf)\n    if not np.isfinite(log_scores).any():\n        return np.zeros_like(bins_remain_cap, dtype=float)\n    max_log = np.max(log_scores[np.isfinite(log_scores)])\n    exp_scores = np.exp(log_scores - max_log)\n    sum_exp = exp_scores.sum()\n    if sum_exp == 0:\n        return np.zeros_like(bins_remain_cap, dtype=float)\n    priorities = exp_scores / sum_exp\n    return priorities",
    "response_id": 29,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 14.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  }
]