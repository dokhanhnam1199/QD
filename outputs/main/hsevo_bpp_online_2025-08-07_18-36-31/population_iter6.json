[
  {
    "stdout_filepath": "problem_iter5_response0.txt_stdout.txt",
    "code_path": "problem_iter5_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines negative leftover with large exact\u2011fit bonus and index tie\u2011break to favor exact fits while reducing fragmentation.\"\"\"\n    fit = bins_remain_cap >= item\n    leftover = bins_remain_cap - item\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    exact_bonus = 1e7\n    eps = 1e-9\n    priorities[fit] = -leftover[fit] + np.where(leftover[fit] <= eps, exact_bonus, 0.0)\n    priorities += np.arange(bins_remain_cap.size) * 1e-5\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response1.txt_stdout.txt",
    "code_path": "problem_iter5_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit squared penalty, worst-fit capacity weight, inverse residual tie-breaker, and large exact-fit bonus for deterministic online BPP priority.\"\"\"\n    feasible = bins_remain_cap >= item\n    residual = bins_remain_cap - item\n    base = np.where(feasible, -residual**2 + 0.1 * bins_remain_cap, -np.inf)\n    tie = np.where(feasible, 1.0/(1.0+residual), 0.0)\n    exact = np.isclose(residual, 0.0)\n    priorities = base + tie + np.where(exact, 1e6, 0.0)\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response2.txt_stdout.txt",
    "code_path": "problem_iter5_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit and inverse residual scoring with a large exact-fit bonus and tiny capacity tie\u2011breaker.\"\"\"\n    leftover = bins_remain_cap - item\n    feasible = leftover >= 0\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    if np.any(feasible):\n        priorities[feasible] = -leftover[feasible]\n        priorities[feasible] += 1.0 / (1.0 + leftover[feasible])\n        priorities[feasible & (leftover == 0)] += 1e6\n        priorities[feasible] += 1e-6 * bins_remain_cap[feasible]\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response3.txt_stdout.txt",
    "code_path": "problem_iter5_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combine inverse leftover, exact\u2011fit boost, capacity tie\u2011breaker, and fragmentation penalty.\"\"\"\n    eps = 1e-9\n    leftover = bins_remain_cap - item\n    fit_mask = leftover >= 0\n    # Base: inverse leftover (tighter fit \u2192 higher score)\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    priorities[fit_mask] = 1.0 / (leftover[fit_mask] + eps)\n    # Tie\u2011breaker: favor bins with larger remaining capacity\n    priorities[fit_mask] += 0.01 * bins_remain_cap[fit_mask]\n    # Penalize large slack to reduce fragmentation\n    priorities[fit_mask] -= 0.001 * (leftover[fit_mask] ** 2)\n    # Exact\u2011fit bonus: huge boost ensures selection when possible\n    exact_mask = fit_mask & np.isclose(leftover, 0, atol=eps)\n    priorities[exact_mask] += 1e7\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response4.txt_stdout.txt",
    "code_path": "problem_iter5_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    w = 0.1\n    gamma = 0.5\n    M = 1e6\n    feasible = bins_remain_cap >= item\n    residual = bins_remain_cap - item\n    base = np.where(feasible, -residual**2 + w * bins_remain_cap + gamma / (1.0 + residual), -np.inf)\n    exact = np.isclose(residual, 0.0)\n    return base + np.where(exact, M, 0.0)",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response5.txt_stdout.txt",
    "code_path": "problem_iter5_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    feasible = bins_remain_cap >= item\n    residual = bins_remain_cap - item\n    w_cap = 0.1\n    w_inv = 0.5\n    M = 1e9\n    base = -residual**2\n    cap_score = w_cap * bins_remain_cap\n    inv_score = 1.0 / (1.0 + residual)\n    exact_bonus = np.where(np.isclose(residual, 0.0), M, 0.0)\n    tie = np.arange(bins_remain_cap.shape[0]) * 1e-6\n    scores = base + cap_score + w_inv * inv_score + exact_bonus + tie\n    scores = np.where(feasible, scores, -np.inf)\n    return scores",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 14.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response6.txt_stdout.txt",
    "code_path": "problem_iter5_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Exact\u2011fit boost, quadratic residual penalty, capacity tie\u2011breaker, small random diversification.\"\"\"\n    leftover = bins_remain_cap - item\n    feasible = leftover >= 0\n    scores = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)\n    if not np.any(feasible):\n        return scores\n    alpha = 0.2\n    base = -leftover[feasible] - alpha * (leftover[feasible] ** 2)\n    base += 1e-3 * bins_remain_cap[feasible]  # typo corrected: bins_remain_cap\n    base += np.random.rand(base.shape[0]) * 1e-6\n    scores[feasible] = base\n    exact = (leftover == 0) & feasible\n    scores[exact] += 1e6\n    return scores",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 14.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response7.txt_stdout.txt",
    "code_path": "problem_iter5_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Best-fit with strong exact-fit boost and inverse-residual tweak.\n    \"\"\"\n    mask = bins_remain_cap >= item\n    residual = bins_remain_cap - item\n    # combine best-fit, exact-fit, inverse residual, deterministic tie-break\n    priority = -residual\n    priority[np.isclose(bins_remain_cap, item)] += 1e6\n    priority += 1.0 / (1.0 + residual) * 1e-3\n    priority -= np.arange(bins_remain_cap.size) * 1e-12\n    priority = np.where(mask, priority, -np.inf)\n    return priority",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response8.txt_stdout.txt",
    "code_path": "problem_iter5_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Best\u2011fit with large exact\u2011fit bonus, inverse\u2011residual term, and index tie\u2011breaker.\n    \"\"\"\n    gap = bins_remain_cap - item\n    feasible = gap >= 0\n    idx = np.arange(len(bins_remain_cap))\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    priorities[feasible] = -gap[feasible]\n    exact = feasible & (gap == 0)\n    priorities[exact] += 1e6\n    priorities[feasible] += 1.0 / (1.0 + gap[feasible])\n    priorities[feasible] -= 1e-12 * idx[feasible]\n    return priorities",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response9.txt_stdout.txt",
    "code_path": "problem_iter5_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Hybrid scoring: negative leftover + inverse term, huge exact\u2011fit boost, tiny capacity tie\u2011breaker.\"\"\"\n    leftover = bins_remain_cap - item\n    feasible = leftover >= 0\n    scores = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)\n    # parameters: inverse weight, capacity tie\u2011breaker, exact\u2011fit bonus\n    alpha = 1.0\n    beta = 1e-3\n    epsilon = 1e-12\n    exact_bonus = 1e6\n    # base score: penalize leftover, add inverse term, slight capacity tie\u2011breaker\n    inv_term = alpha / (1.0 + leftover[feasible])\n    base = -leftover[feasible] + inv_term + beta * bins_remain_cap[feasible]\n    # huge boost for exact fits\n    exact_mask = leftover[feasible] <= epsilon\n    base[exact_mask] += exact_bonus\n    scores[feasible] = base\n    return scores",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 14.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response0.txt_stdout.txt",
    "code_path": "problem_iter6_code0.py",
    "code": "import numpy as np\n\n_initial_total_capacity = None\n_bin_capacity = None\n_avg_item_size = None\n_placement_counter = 0\n_alpha_avg = 0.1\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    global _initial_total_capacity, _bin_capacity, _avg_item_size, _placement_counter, _alpha_avg\n    if _initial_total_capacity is None:\n        _initial_total_capacity = float(np.sum(bins_remain_cap))\n        _bin_capacity = float(np.max(bins_remain_cap))\n        _avg_item_size = item\n    else:\n        _avg_item_size = (1 - _alpha_avg) * _avg_item_size + _alpha_avg * item\n    _placement_counter += 1\n    leftover = bins_remain_cap - item\n    feas = leftover >= 0\n    scores = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)\n    if np.any(feas):\n        load_factor = (_initial_total_capacity - np.sum(bins_remain_cap)) / _initial_total_capacity\n        weight_frag = load_factor\n        weight_pot = 1.0 - load_factor\n        bf = -leftover[feas]\n        frag = -weight_frag * (leftover[feas] / _bin_capacity) ** 2\n        pot = weight_pot * (leftover[feas] / (_avg_item_size + 1e-12))\n        base = bf + frag + pot\n        noise = np.random.normal(scale=0.001, size=base.shape)\n        scores[feas] = base + noise\n    return scores",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 23.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  }
]