[
  {
    "stdout_filepath": "problem_iter2_response0.txt_stdout.txt",
    "code_path": "problem_iter2_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Score bins: higher for tighter fit, exact fits get a large bonus, deterministic tie\u2011break.\"\"\"\n    leftover = bins_remain_cap - item\n    feasible = leftover >= 0\n    scores = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)\n    # Base score prefers smaller leftover (tighter fit)\n    base = -leftover[feasible]\n    # Bonus for exact fits (leftover \u2248 0)\n    exact_bonus = np.where(np.isclose(leftover[feasible], 0.0, atol=1e-12), 10.0, 0.0)\n    # Deterministic tie\u2011breaker: favor lower\u2011index bins\n    tie_break = -np.arange(bins_remain_cap.shape[feasible]) * 1e-9  # noqa: E501\n    scores[feasible] = base + exact_bonus + tie_break\n    return scores",
    "response_id": 0,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 13, in priority_v2\nTypeError: only integer scalar arrays can be converted to a scalar index\n9\n1\n"
  },
  {
    "stdout_filepath": "problem_iter2_response1.txt_stdout.txt",
    "code_path": "problem_iter2_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit (-residual^2) and worst-fit (remaining capacity) using a weighted sum, plus an exact-fit bonus. Deterministic, vectorized, no randomness.\"\"\"\n    feasible = bins_remain_cap >= item\n    residual = bins_remain_cap - item\n    w = 0.5\n    base = np.where(feasible, -residual**2 + w * bins_remain_cap, -np.inf)\n    exact = np.isclose(residual, 0.0)\n    M = 1e9\n    priorities = base + np.where(exact, M, 0.0)\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response2.txt_stdout.txt",
    "code_path": "problem_iter2_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Monotonic inverse-leftover score with exact\u2011fit boost.\n    \"\"\"\n    eps = 1e-9\n    fit_mask = bins_remain_cap >= item\n    base = np.where(fit_mask, 1.0 / (bins_remain_cap - item + eps), -np.inf)\n    exact_bonus = np.where(fit_mask & (bins_remain_cap == item), 1e7, 0.0)\n    return base + exact_bonus",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response3.txt_stdout.txt",
    "code_path": "problem_iter2_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    eps = 1e-9\n    k = 12.0\n    residual = bins_remain_cap - item\n    fit = residual >= 0\n    base = np.where(fit, 1.0 / (1.0 + np.exp(k * residual)), -np.inf)\n    exact = np.abs(residual) < eps\n    return base + exact.astype(float)",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response4.txt_stdout.txt",
    "code_path": "problem_iter2_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Score bins: highest for smallest leftover, boost exact fits, deterministic tie\u2011break.\"\"\"\n    mask = bins_remain_cap >= item\n    residual = bins_remain_cap - item\n    priority = -residual\n    priority[np.isclose(bins_remain_cap, item)] += 1.0\n    priority += -np.arange(bins_remain_cap.shape[0], dtype=float) * 1e-12\n    priority = np.where(mask, priority, -np.inf)\n    return priority",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response5.txt_stdout.txt",
    "code_path": "problem_iter2_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Deterministic priority based on negative leftover, with a tiny exact\u2011fit bonus.\n    \"\"\"\n    # Feasible bins: remaining capacity >= item size\n    feasible = bins_remain_cap >= item\n\n    # Initialize all priorities to -\u221e (infeasible)\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Negative leftover: larger for tighter fits (item - remaining_cap)\n    priorities[feasible] = item - bins_remain_cap[feasible]\n\n    # Small exact\u2011fit bonus to break ties for perfect fits\n    exact_fit = feasible & (bins_remain_cap == item)\n    priorities[exact_fit] += 1e-6\n\n    return priorities",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response6.txt_stdout.txt",
    "code_path": "problem_iter2_code6.py",
    "code": "import numpy as np\n\n# Priority: minimize leftover space, large boost for exact fits\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Score bins: higher for smaller leftover after item, with big bonus for exact fits.\"\"\"\n    fit = bins_remain_cap >= item\n    leftover = bins_remain_cap - item\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    exact_bonus = 1e6\n    eps = 1e-9\n    priorities[fit] = -leftover[fit] + np.where(leftover[fit] <= eps, exact_bonus, 0.0)\n    return priorities",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response7.txt_stdout.txt",
    "code_path": "problem_iter2_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Compute negative leftover with exact\u2011fit bonus and tie\u2011break by index.\"\"\"\n    gap = bins_remain_cap - item\n    feasible = gap >= 0\n    idx = np.arange(len(bins_remain_cap))\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    bonus = np.where(gap == 0, 1e-6, 0.0)\n    priorities[feasible] = -gap[feasible] + bonus[feasible] - 1e-12 * idx[feasible]\n    return priorities",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response8.txt_stdout.txt",
    "code_path": "problem_iter2_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines inverse residual scoring with exact-fit boost and mild remaining-capacity tie-breaker.\n    \"\"\"\n    leftover = bins_remain_cap - item\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    fit_mask = leftover >= 0\n    priorities[fit_mask] = 1.0 / (1.0 + leftover[fit_mask])\n    exact_mask = fit_mask & (leftover == 0)\n    priorities[exact_mask] += 10.0\n    priorities[fit_mask] += 0.01 * bins_remain_cap[fit_mask]\n    return priorities",
    "response_id": 8,
    "tryHS": false,
    "obj": 86.27842042281613,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response9.txt_stdout.txt",
    "code_path": "problem_iter2_code9.py",
    "code": "import numpy as np\n\n# Choose bin with smallest leftover, give a boost to exact fits.\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Score bins: high for minimal waste, extra bonus for exact fits.\"\"\"\n    leftover = bins_remain_cap - item\n    feasible = leftover >= 0\n    scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    scores[feasible] = -leftover[feasible]                 # less waste \u2192 higher score\n    exact_fit = leftover == 0\n    if np.any(exact_fit):\n        bonus = bins_remain_cap.max() + 1.0                # dominates other scores\n        scores[exact_fit] += bonus\n    return scores",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  }
]