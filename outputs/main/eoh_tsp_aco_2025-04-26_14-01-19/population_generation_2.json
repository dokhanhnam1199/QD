[
     {
          "algorithm": "This algorithm uses a greedy approach combined with random restarts, path smoothing, and weighted edge updates based on tour length to create a heuristic matrix reflecting edge usage in good-quality tours.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm uses a greedy approach combined with random restarts, path smoothing, and weighted edge updates based on tour length to create a heuristic matrix reflecting edge usage in good-quality tours.}\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros((n, n))\n    num_restarts = 50\n    smoothing_iterations = 5\n\n    for restart in range(num_restarts):\n        # Greedy tour construction with random start\n        start_node = np.random.randint(n)\n        tour = [start_node]\n        unvisited = set(range(n))\n        unvisited.remove(start_node)\n        current_node = start_node\n\n        while unvisited:\n            nearest_neighbor = min(unvisited, key=lambda x: distance_matrix[current_node, x])\n            tour.append(nearest_neighbor)\n            unvisited.remove(nearest_neighbor)\n            current_node = nearest_neighbor\n        tour.append(start_node)\n\n        # Path smoothing (2-opt swaps)\n        for _ in range(smoothing_iterations):\n            improved = False\n            for i in range(1, n):\n                for j in range(i + 1, n + 1):\n                    if j - i == 1:\n                        continue\n\n                    current_cost = distance_matrix[tour[i - 1], tour[i]] + distance_matrix[tour[j - 1], tour[j % n]]\n                    new_cost = distance_matrix[tour[i - 1], tour[j - 1]] + distance_matrix[tour[i], tour[j % n]]\n\n                    if new_cost < current_cost:\n                        tour[i:j] = reversed(tour[i:j])\n                        improved = True\n            if not improved:\n                break\n\n        # Calculate tour length\n        tour_length = 0\n        for i in range(n):\n            tour_length += distance_matrix[tour[i], tour[(i + 1) % n]]\n\n        # Update heuristic matrix with weighting based on tour length\n        weight = 1.0 / (tour_length + 1e-9)  # Add a small constant to avoid division by zero\n        for i in range(n):\n            node1 = tour[i]\n            node2 = tour[(i + 1) % n]\n            heuristics_matrix[node1, node2] += weight\n            heuristics_matrix[node2, node1] += weight\n\n    heuristics_matrix /= num_restarts\n    return heuristics_matrix",
          "objective": 5.72519,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm uses a greedy approach combined with random restarts and path smoothing to create a heuristic matrix reflecting edge usage in good-quality tours.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm uses a greedy approach combined with random restarts and path smoothing to create a heuristic matrix reflecting edge usage in good-quality tours.}\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros((n, n))\n    num_restarts = 50\n    smoothing_iterations = 5\n\n    for restart in range(num_restarts):\n        # Greedy tour construction with random start\n        start_node = np.random.randint(n)\n        tour = [start_node]\n        unvisited = set(range(n))\n        unvisited.remove(start_node)\n        current_node = start_node\n\n        while unvisited:\n            nearest_neighbor = min(unvisited, key=lambda x: distance_matrix[current_node, x])\n            tour.append(nearest_neighbor)\n            unvisited.remove(nearest_neighbor)\n            current_node = nearest_neighbor\n        tour.append(start_node)\n\n        # Path smoothing (2-opt swaps)\n        for _ in range(smoothing_iterations):\n            improved = False\n            for i in range(1, n):\n                for j in range(i + 1, n + 1):\n                    if j - i == 1:\n                        continue\n\n                    current_cost = distance_matrix[tour[i - 1], tour[i]] + distance_matrix[tour[j - 1], tour[j % n]]\n                    new_cost = distance_matrix[tour[i - 1], tour[j - 1]] + distance_matrix[tour[i], tour[j % n]]\n\n                    if new_cost < current_cost:\n                        tour[i:j] = reversed(tour[i:j])\n                        improved = True\n            if not improved:\n                break\n\n        # Update heuristic matrix\n        for i in range(n):\n            node1 = tour[i]\n            node2 = tour[(i + 1) % n]\n            heuristics_matrix[node1, node2] += 1\n            heuristics_matrix[node2, node1] += 1\n\n    heuristics_matrix /= num_restarts\n    return heuristics_matrix",
          "objective": 5.72904,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm uses a greedy approach with random restarts and path smoothing to build a heuristic matrix based on the frequency of edge usage in good solutions.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm uses a greedy approach with random restarts and path smoothing to build a heuristic matrix based on the frequency of edge usage in good solutions.}\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros((n, n))\n    num_restarts = 50\n    path_smoothing_iterations = 5\n\n    for _ in range(num_restarts):\n        # Greedy construction with random start\n        start_node = np.random.randint(n)\n        unvisited = list(range(n))\n        path = [start_node]\n        unvisited.remove(start_node)\n\n        while unvisited:\n            current_node = path[-1]\n            nearest_neighbor = min(unvisited, key=lambda x: distance_matrix[current_node, x])\n            path.append(nearest_neighbor)\n            unvisited.remove(nearest_neighbor)\n\n        path.append(start_node)  # Complete the cycle\n\n        # Path smoothing (2-opt)\n        for _ in range(path_smoothing_iterations):\n            improved = False\n            for i in range(1, n):\n                for j in range(i + 2, n + 1):\n                    old_distance = distance_matrix[path[i - 1], path[i]] + distance_matrix[path[j - 1], path[j % n]]\n                    new_distance = distance_matrix[path[i - 1], path[j - 1]] + distance_matrix[path[i], path[j % n]]\n                    if new_distance < old_distance:\n                        path[i:j] = reversed(path[i:j])\n                        improved = True\n            if not improved:\n                break\n\n        # Update heuristics matrix based on path\n        path_length = 0\n        for i in range(n):\n            path_length += distance_matrix[path[i], path[(i + 1) % n]]\n        \n        for i in range(n):\n            heuristics_matrix[path[i], path[(i + 1) % n]] += 1.0 / path_length\n            heuristics_matrix[path[(i + 1) % n], path[i]] += 1.0 / path_length\n\n    return heuristics_matrix",
          "objective": 5.73667,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm builds a heuristic matrix by averaging edge frequencies across multiple greedy randomized construction and local search improvement iterations.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm builds a heuristic matrix by averaging edge frequencies across multiple greedy randomized construction and local search improvement iterations.}\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros((n, n))\n    num_samples = 50\n    local_search_iterations = 5\n\n    for _ in range(num_samples):\n        # Greedy randomized construction\n        unvisited = list(range(n))\n        start_node = np.random.choice(unvisited)\n        path = [start_node]\n        unvisited.remove(start_node)\n\n        while unvisited:\n            current_node = path[-1]\n            distances = [distance_matrix[current_node, node] for node in unvisited]\n            min_dist = min(distances)\n            candidates = [unvisited[i] for i, dist in enumerate(distances) if dist <= min_dist * 1.2] # Randomized: Allow some sub-optimal choices\n            next_node = np.random.choice(candidates)\n            path.append(next_node)\n            unvisited.remove(next_node)\n\n        path.append(path[0])\n\n        # Local search (2-opt)\n        for _ in range(local_search_iterations):\n            improved = False\n            for i in range(1, n):\n                for j in range(i + 2, n + 1):\n                    old_distance = distance_matrix[path[i - 1], path[i]] + distance_matrix[path[j - 1], path[j % n]]\n                    new_distance = distance_matrix[path[i - 1], path[j - 1]] + distance_matrix[path[i], path[j % n]]\n                    if new_distance < old_distance:\n                        path[i:j] = reversed(path[i:j])\n                        improved = True\n            if not improved:\n                break\n\n        # Update heuristics matrix based on edge frequency\n        for i in range(n):\n            heuristics_matrix[path[i], path[(i + 1) % n]] += 1\n            heuristics_matrix[path[(i + 1) % n], path[i]] += 1\n\n    return heuristics_matrix",
          "objective": 5.74591,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm combines ant colony optimization with a more aggressive pheromone update strategy and a simplified acceptance criterion in local search, emphasizing exploration.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm combines ant colony optimization with a more aggressive pheromone update strategy and a simplified acceptance criterion in local search, emphasizing exploration.}\"\"\"\n    n = distance_matrix.shape[0]\n    pheromone = np.ones((n, n))  # Initialize pheromone trails\n    heuristics_matrix = np.zeros((n, n))\n    temperature = 0.75  # Initial temperature (reduced)\n    cooling_rate = 0.97 # slower cooling\n    alpha = 0.7  # Pheromone influence\n    beta = 3.0  # Distance influence\n    evaporation_rate = 0.3 # higher evaporation\n    local_search_iterations = 3 # fewer iterations\n\n    for iteration in range(60):  # Reduced number of iterations\n        paths = []\n        path_lengths = []\n        for ant in range(n):  # Number of ants equals number of nodes\n            current_node = ant\n            visited = [False] * n\n            visited[current_node] = True\n            path = [current_node]\n            path_length = 0\n\n            while len(path) < n:\n                probabilities = np.zeros(n)\n                for i in range(n):\n                    if not visited[i]:\n                        probabilities[i] = (pheromone[current_node, i]**alpha) / (distance_matrix[current_node, i]**beta)\n\n                if np.sum(probabilities) == 0:\n                    unvisited_nodes = [i for i in range(n) if not visited[i]]\n                    next_node = np.random.choice(unvisited_nodes)\n                else:\n                    probabilities /= np.sum(probabilities)\n                    next_node = np.random.choice(n, p=probabilities)\n\n                path.append(next_node)\n                path_length += distance_matrix[current_node, next_node]\n                visited[next_node] = True\n                current_node = next_node\n\n            path_length += distance_matrix[path[-1], path[0]]  # Return to starting node\n            paths.append(path)\n            path_lengths.append(path_length)\n\n        # Local search (2-opt swap) with simplified acceptance\n        for ant in range(n):\n            path = paths[ant]\n            path_length = path_lengths[ant]\n\n            for _ in range(local_search_iterations):\n                i, j = np.random.choice(n, 2, replace=False)\n                if i > j:\n                    i, j = j, i\n\n                new_path = path[:i] + path[i:j+1][::-1] + path[j+1:]\n                new_path_length = 0\n                for k in range(n - 1):\n                    new_path_length += distance_matrix[new_path[k], new_path[k+1]]\n                new_path_length += distance_matrix[new_path[-1], new_path[0]]\n\n                if new_path_length < path_length or np.random.rand() < 0.1: #always accept slightly worse solutions\n                    paths[ant] = new_path\n                    path_lengths[ant] = new_path_length\n                    path = new_path\n                    path_length = new_path_length\n\n\n        # Update pheromone trails - more aggressive update\n        pheromone *= (1 - evaporation_rate)  # Evaporation\n\n        best_path_index = np.argmin(path_lengths)\n        best_path = paths[best_path_index]\n        best_path_length = path_lengths[best_path_index]\n\n        for i in range(n):\n            pheromone[best_path[i], best_path[(i + 1) % n]] += 3.0 / best_path_length # increased intensity\n            pheromone[best_path[(i + 1) % n], best_path[i]] += 3.0 / best_path_length\n\n        # Update heuristics matrix\n        for i in range(n):\n            for j in range(n):\n                heuristics_matrix[i, j] += pheromone[i, j] / distance_matrix[i, j]  # Combine pheromone and distance\n\n        temperature *= cooling_rate  # Cool the temperature\n\n    return heuristics_matrix",
          "objective": 5.74884,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm iteratively samples candidate TSP solutions by stochastically selecting edges based on a combination of distance, pheromone (representing prior success), and a temperature parameter that controls exploration vs. exploitation, then updates pheromone trails based on solution quality.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm iteratively samples candidate TSP solutions by stochastically selecting edges based on a combination of distance, pheromone (representing prior success), and a temperature parameter that controls exploration vs. exploitation, then updates pheromone trails based on solution quality.}\"\"\"\n    \n    n = distance_matrix.shape[0]\n    pheromone = np.ones((n, n))  # Initialize pheromone trails\n    heuristics_matrix = np.zeros((n, n))\n    temperature = 1.0  # Initial temperature\n    cooling_rate = 0.95\n    alpha = 1.0  # Pheromone influence\n    beta = 2.0  # Distance influence\n    evaporation_rate = 0.1\n\n    for iteration in range(100):  # Number of iterations\n        paths = []\n        path_lengths = []\n        for ant in range(n):  # Number of ants equals number of nodes\n            current_node = ant\n            visited = [False] * n\n            visited[current_node] = True\n            path = [current_node]\n            path_length = 0\n\n            while len(path) < n:\n                probabilities = np.zeros(n)\n                for i in range(n):\n                    if not visited[i]:\n                        probabilities[i] = (pheromone[current_node, i]**alpha) / (distance_matrix[current_node, i]**beta)\n                \n                if np.sum(probabilities) == 0:\n                    # Handle the case where all probabilities are zero (e.g., all nodes visited or infinite distance)\n                    # This could happen if the distance matrix has np.inf values.\n                    # A simple workaround is to randomly choose an unvisited node.\n                    unvisited_nodes = [i for i in range(n) if not visited[i]]\n                    next_node = np.random.choice(unvisited_nodes)\n                else:\n                    probabilities /= np.sum(probabilities)\n                    next_node = np.random.choice(n, p=probabilities)\n                \n                path.append(next_node)\n                path_length += distance_matrix[current_node, next_node]\n                visited[next_node] = True\n                current_node = next_node\n\n            path_length += distance_matrix[path[-1], path[0]]  # Return to starting node\n            paths.append(path)\n            path_lengths.append(path_length)\n\n        # Update pheromone trails\n        pheromone *= (1 - evaporation_rate)  # Evaporation\n\n        best_path_index = np.argmin(path_lengths)\n        best_path = paths[best_path_index]\n        best_path_length = path_lengths[best_path_index]\n\n        for i in range(n):\n            pheromone[best_path[i], best_path[(i + 1) % n]] += 1.0 / best_path_length\n            pheromone[best_path[(i + 1) % n], best_path[i]] += 1.0 / best_path_length\n        \n        # Update heuristics matrix\n        for i in range(n):\n            for j in range(n):\n                heuristics_matrix[i, j] += pheromone[i, j] / distance_matrix[i, j]  # Combine pheromone and distance\n        \n        temperature *= cooling_rate  # Cool the temperature\n\n    return heuristics_matrix",
          "objective": 5.74993,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm uses a greedy approach combined with random restarts, path smoothing, and weighted heuristic updates based on tour length to create a heuristic matrix reflecting edge usage in good-quality tours.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm uses a greedy approach combined with random restarts, path smoothing, and weighted heuristic updates based on tour length to create a heuristic matrix reflecting edge usage in good-quality tours.}\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros((n, n))\n    num_restarts = 50\n    smoothing_iterations = 5\n\n    for restart in range(num_restarts):\n        # Greedy tour construction with random start\n        start_node = np.random.randint(n)\n        tour = [start_node]\n        unvisited = set(range(n))\n        unvisited.remove(start_node)\n        current_node = start_node\n\n        while unvisited:\n            nearest_neighbor = min(unvisited, key=lambda x: distance_matrix[current_node, x])\n            tour.append(nearest_neighbor)\n            unvisited.remove(nearest_neighbor)\n            current_node = nearest_neighbor\n        tour.append(start_node)\n\n        # Path smoothing (2-opt swaps)\n        for _ in range(smoothing_iterations):\n            improved = False\n            for i in range(1, n):\n                for j in range(i + 1, n + 1):\n                    if j - i == 1:\n                        continue\n\n                    current_cost = distance_matrix[tour[i - 1], tour[i]] + distance_matrix[tour[j - 1], tour[j % n]]\n                    new_cost = distance_matrix[tour[i - 1], tour[j - 1]] + distance_matrix[tour[i], tour[j % n]]\n\n                    if new_cost < current_cost:\n                        tour[i:j] = reversed(tour[i:j])\n                        improved = True\n            if not improved:\n                break\n\n        # Calculate tour length\n        tour_length = 0\n        for i in range(n):\n            tour_length += distance_matrix[tour[i], tour[(i + 1) % n]]\n\n        # Update heuristic matrix with weight based on tour length (shorter tours have higher weight)\n        weight = 1.0 / (tour_length + 1e-6)  # Add a small constant to avoid division by zero\n        for i in range(n):\n            node1 = tour[i]\n            node2 = tour[(i + 1) % n]\n            heuristics_matrix[node1, node2] += weight\n            heuristics_matrix[node2, node1] += weight\n\n    heuristics_matrix /= num_restarts\n    return heuristics_matrix",
          "objective": 5.75917,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm combines ant colony optimization with a simulated annealing-inspired acceptance criterion for local search, enhancing pheromone trails based on path improvements.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm combines ant colony optimization with a simulated annealing-inspired acceptance criterion for local search, enhancing pheromone trails based on path improvements.}\"\"\"\n    n = distance_matrix.shape[0]\n    pheromone = np.ones((n, n))  # Initialize pheromone trails\n    heuristics_matrix = np.zeros((n, n))\n    temperature = 1.0  # Initial temperature\n    cooling_rate = 0.95\n    alpha = 0.8  # Pheromone influence\n    beta = 2.5  # Distance influence\n    evaporation_rate = 0.2\n    local_search_iterations = 5\n\n    for iteration in range(80):  # Number of iterations\n        paths = []\n        path_lengths = []\n        for ant in range(n):  # Number of ants equals number of nodes\n            current_node = ant\n            visited = [False] * n\n            visited[current_node] = True\n            path = [current_node]\n            path_length = 0\n\n            while len(path) < n:\n                probabilities = np.zeros(n)\n                for i in range(n):\n                    if not visited[i]:\n                        probabilities[i] = (pheromone[current_node, i]**alpha) / (distance_matrix[current_node, i]**beta)\n\n                if np.sum(probabilities) == 0:\n                    unvisited_nodes = [i for i in range(n) if not visited[i]]\n                    next_node = np.random.choice(unvisited_nodes)\n                else:\n                    probabilities /= np.sum(probabilities)\n                    next_node = np.random.choice(n, p=probabilities)\n\n                path.append(next_node)\n                path_length += distance_matrix[current_node, next_node]\n                visited[next_node] = True\n                current_node = next_node\n\n            path_length += distance_matrix[path[-1], path[0]]  # Return to starting node\n            paths.append(path)\n            path_lengths.append(path_length)\n\n        # Local search (2-opt swap) with simulated annealing acceptance\n        for ant in range(n):\n            path = paths[ant]\n            path_length = path_lengths[ant]\n\n            for _ in range(local_search_iterations):\n                i, j = np.random.choice(n, 2, replace=False)\n                if i > j:\n                    i, j = j, i\n\n                new_path = path[:i] + path[i:j+1][::-1] + path[j+1:]\n                new_path_length = 0\n                for k in range(n - 1):\n                    new_path_length += distance_matrix[new_path[k], new_path[k+1]]\n                new_path_length += distance_matrix[new_path[-1], new_path[0]]\n\n                if new_path_length < path_length:\n                    paths[ant] = new_path\n                    path_lengths[ant] = new_path_length\n                    path = new_path\n                    path_length = new_path_length\n                else:\n                    # Simulated annealing acceptance criterion\n                    delta = new_path_length - path_length\n                    acceptance_probability = np.exp(-delta / temperature)\n                    if np.random.rand() < acceptance_probability:\n                        paths[ant] = new_path\n                        path_lengths[ant] = new_path_length\n                        path = new_path\n                        path_length = new_path_length\n\n        # Update pheromone trails\n        pheromone *= (1 - evaporation_rate)  # Evaporation\n\n        best_path_index = np.argmin(path_lengths)\n        best_path = paths[best_path_index]\n        best_path_length = path_lengths[best_path_index]\n\n        for i in range(n):\n            pheromone[best_path[i], best_path[(i + 1) % n]] += 1.0 / best_path_length\n            pheromone[best_path[(i + 1) % n], best_path[i]] += 1.0 / best_path_length\n\n        # Update heuristics matrix\n        for i in range(n):\n            for j in range(n):\n                heuristics_matrix[i, j] += pheromone[i, j] / distance_matrix[i, j]  # Combine pheromone and distance\n\n        temperature *= cooling_rate  # Cool the temperature\n\n    return heuristics_matrix",
          "objective": 5.76316,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm uses a nearest neighbor approach with probabilistic edge selection and path smoothing with adaptive temperature to generate a heuristic matrix.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm uses a nearest neighbor approach with probabilistic edge selection and path smoothing with adaptive temperature to generate a heuristic matrix.}\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros((n, n))\n    num_iterations = 50\n    smoothing_iterations = 5\n    initial_temperature = 10\n    cooling_rate = 0.95\n\n    for iteration in range(num_iterations):\n        temperature = initial_temperature\n        # Nearest neighbor tour construction with probabilistic edge selection\n        start_node = np.random.randint(n)\n        tour = [start_node]\n        unvisited = set(range(n))\n        unvisited.remove(start_node)\n        current_node = start_node\n\n        while unvisited:\n            probabilities = np.array([np.exp(-distance_matrix[current_node, neighbor] / temperature) for neighbor in unvisited])\n            probabilities /= np.sum(probabilities)\n            nearest_neighbor = np.random.choice(list(unvisited), p=probabilities)\n            tour.append(nearest_neighbor)\n            unvisited.remove(nearest_neighbor)\n            current_node = nearest_neighbor\n        tour.append(start_node)\n\n        # Path smoothing (2-opt swaps)\n        for _ in range(smoothing_iterations):\n            improved = False\n            for i in range(1, n):\n                for j in range(i + 1, n + 1):\n                    if j - i == 1:\n                        continue\n\n                    current_cost = distance_matrix[tour[i - 1], tour[i]] + distance_matrix[tour[j - 1], tour[j % n]]\n                    new_cost = distance_matrix[tour[i - 1], tour[j - 1]] + distance_matrix[tour[i], tour[j % n]]\n\n                    if new_cost < current_cost:\n                        tour[i:j] = reversed(tour[i:j])\n                        improved = True\n            if not improved:\n                break\n            temperature *= cooling_rate\n\n\n        # Update heuristic matrix\n        for i in range(n):\n            node1 = tour[i]\n            node2 = tour[(i + 1) % n]\n            heuristics_matrix[node1, node2] += 1\n            heuristics_matrix[node2, node1] += 1\n\n    heuristics_matrix /= num_iterations\n    return heuristics_matrix",
          "objective": 5.77289,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm uses a greedy approach with random restarts and path smoothing, updating the heuristic matrix with a score function based on edge rank within the tour.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm uses a greedy approach with random restarts and path smoothing, updating the heuristic matrix with a score function based on edge rank within the tour.}\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros((n, n))\n    num_restarts = 50\n    path_smoothing_iterations = 5\n\n    for _ in range(num_restarts):\n        # Greedy construction with random start\n        start_node = np.random.randint(n)\n        unvisited = list(range(n))\n        path = [start_node]\n        unvisited.remove(start_node)\n\n        while unvisited:\n            current_node = path[-1]\n            nearest_neighbor = min(unvisited, key=lambda x: distance_matrix[current_node, x])\n            path.append(nearest_neighbor)\n            unvisited.remove(nearest_neighbor)\n\n        path.append(start_node)  # Complete the cycle\n\n        # Path smoothing (2-opt)\n        for _ in range(path_smoothing_iterations):\n            improved = False\n            for i in range(1, n):\n                for j in range(i + 2, n + 1):\n                    old_distance = distance_matrix[path[i - 1], path[i]] + distance_matrix[path[j - 1], path[j % n]]\n                    new_distance = distance_matrix[path[i - 1], path[j - 1]] + distance_matrix[path[i], path[j % n]]\n                    if new_distance < old_distance:\n                        path[i:j] = reversed(path[i:j])\n                        improved = True\n            if not improved:\n                break\n\n        # Update heuristics matrix based on path and edge rank\n        tour_length = len(path)\n        for i in range(n):\n            u = path[i]\n            v = path[(i + 1) % n]\n\n            # Calculate a score based on the edge's 'rank' in the tour.\n            rank_score = 1.0 / (i + 1)  # Edges appearing earlier get higher scores\n\n            heuristics_matrix[u, v] += rank_score\n            heuristics_matrix[v, u] += rank_score\n\n    return heuristics_matrix",
          "objective": 5.77668,
          "other_inf": null
     }
]