[
     {
          "algorithm": "This algorithm iteratively samples candidate TSP solutions by stochastically selecting edges based on a combination of distance, pheromone (representing prior success), and a temperature parameter that controls exploration vs. exploitation, then updates pheromone trails based on solution quality.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm iteratively samples candidate TSP solutions by stochastically selecting edges based on a combination of distance, pheromone (representing prior success), and a temperature parameter that controls exploration vs. exploitation, then updates pheromone trails based on solution quality.}\"\"\"\n    \n    n = distance_matrix.shape[0]\n    pheromone = np.ones((n, n))  # Initialize pheromone trails\n    heuristics_matrix = np.zeros((n, n))\n    temperature = 1.0  # Initial temperature\n    cooling_rate = 0.95\n    alpha = 1.0  # Pheromone influence\n    beta = 2.0  # Distance influence\n    evaporation_rate = 0.1\n\n    for iteration in range(100):  # Number of iterations\n        paths = []\n        path_lengths = []\n        for ant in range(n):  # Number of ants equals number of nodes\n            current_node = ant\n            visited = [False] * n\n            visited[current_node] = True\n            path = [current_node]\n            path_length = 0\n\n            while len(path) < n:\n                probabilities = np.zeros(n)\n                for i in range(n):\n                    if not visited[i]:\n                        probabilities[i] = (pheromone[current_node, i]**alpha) / (distance_matrix[current_node, i]**beta)\n                \n                if np.sum(probabilities) == 0:\n                    # Handle the case where all probabilities are zero (e.g., all nodes visited or infinite distance)\n                    # This could happen if the distance matrix has np.inf values.\n                    # A simple workaround is to randomly choose an unvisited node.\n                    unvisited_nodes = [i for i in range(n) if not visited[i]]\n                    next_node = np.random.choice(unvisited_nodes)\n                else:\n                    probabilities /= np.sum(probabilities)\n                    next_node = np.random.choice(n, p=probabilities)\n                \n                path.append(next_node)\n                path_length += distance_matrix[current_node, next_node]\n                visited[next_node] = True\n                current_node = next_node\n\n            path_length += distance_matrix[path[-1], path[0]]  # Return to starting node\n            paths.append(path)\n            path_lengths.append(path_length)\n\n        # Update pheromone trails\n        pheromone *= (1 - evaporation_rate)  # Evaporation\n\n        best_path_index = np.argmin(path_lengths)\n        best_path = paths[best_path_index]\n        best_path_length = path_lengths[best_path_index]\n\n        for i in range(n):\n            pheromone[best_path[i], best_path[(i + 1) % n]] += 1.0 / best_path_length\n            pheromone[best_path[(i + 1) % n], best_path[i]] += 1.0 / best_path_length\n        \n        # Update heuristics matrix\n        for i in range(n):\n            for j in range(n):\n                heuristics_matrix[i, j] += pheromone[i, j] / distance_matrix[i, j]  # Combine pheromone and distance\n        \n        temperature *= cooling_rate  # Cool the temperature\n\n    return heuristics_matrix",
          "objective": 5.74993,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm combines ant colony optimization with a simulated annealing-inspired acceptance criterion for local search, enhancing pheromone trails based on path improvements.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm combines ant colony optimization with a simulated annealing-inspired acceptance criterion for local search, enhancing pheromone trails based on path improvements.}\"\"\"\n    n = distance_matrix.shape[0]\n    pheromone = np.ones((n, n))  # Initialize pheromone trails\n    heuristics_matrix = np.zeros((n, n))\n    temperature = 1.0  # Initial temperature\n    cooling_rate = 0.95\n    alpha = 0.8  # Pheromone influence\n    beta = 2.5  # Distance influence\n    evaporation_rate = 0.2\n    local_search_iterations = 5\n\n    for iteration in range(80):  # Number of iterations\n        paths = []\n        path_lengths = []\n        for ant in range(n):  # Number of ants equals number of nodes\n            current_node = ant\n            visited = [False] * n\n            visited[current_node] = True\n            path = [current_node]\n            path_length = 0\n\n            while len(path) < n:\n                probabilities = np.zeros(n)\n                for i in range(n):\n                    if not visited[i]:\n                        probabilities[i] = (pheromone[current_node, i]**alpha) / (distance_matrix[current_node, i]**beta)\n\n                if np.sum(probabilities) == 0:\n                    unvisited_nodes = [i for i in range(n) if not visited[i]]\n                    next_node = np.random.choice(unvisited_nodes)\n                else:\n                    probabilities /= np.sum(probabilities)\n                    next_node = np.random.choice(n, p=probabilities)\n\n                path.append(next_node)\n                path_length += distance_matrix[current_node, next_node]\n                visited[next_node] = True\n                current_node = next_node\n\n            path_length += distance_matrix[path[-1], path[0]]  # Return to starting node\n            paths.append(path)\n            path_lengths.append(path_length)\n\n        # Local search (2-opt swap) with simulated annealing acceptance\n        for ant in range(n):\n            path = paths[ant]\n            path_length = path_lengths[ant]\n\n            for _ in range(local_search_iterations):\n                i, j = np.random.choice(n, 2, replace=False)\n                if i > j:\n                    i, j = j, i\n\n                new_path = path[:i] + path[i:j+1][::-1] + path[j+1:]\n                new_path_length = 0\n                for k in range(n - 1):\n                    new_path_length += distance_matrix[new_path[k], new_path[k+1]]\n                new_path_length += distance_matrix[new_path[-1], new_path[0]]\n\n                if new_path_length < path_length:\n                    paths[ant] = new_path\n                    path_lengths[ant] = new_path_length\n                    path = new_path\n                    path_length = new_path_length\n                else:\n                    # Simulated annealing acceptance criterion\n                    delta = new_path_length - path_length\n                    acceptance_probability = np.exp(-delta / temperature)\n                    if np.random.rand() < acceptance_probability:\n                        paths[ant] = new_path\n                        path_lengths[ant] = new_path_length\n                        path = new_path\n                        path_length = new_path_length\n\n        # Update pheromone trails\n        pheromone *= (1 - evaporation_rate)  # Evaporation\n\n        best_path_index = np.argmin(path_lengths)\n        best_path = paths[best_path_index]\n        best_path_length = path_lengths[best_path_index]\n\n        for i in range(n):\n            pheromone[best_path[i], best_path[(i + 1) % n]] += 1.0 / best_path_length\n            pheromone[best_path[(i + 1) % n], best_path[i]] += 1.0 / best_path_length\n\n        # Update heuristics matrix\n        for i in range(n):\n            for j in range(n):\n                heuristics_matrix[i, j] += pheromone[i, j] / distance_matrix[i, j]  # Combine pheromone and distance\n\n        temperature *= cooling_rate  # Cool the temperature\n\n    return heuristics_matrix",
          "objective": 5.76316,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm employs a simplified ant colony optimization approach with a fixed pheromone update and aggressive exploration to identify promising edges for the TSP solution.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm employs a simplified ant colony optimization approach with a fixed pheromone update and aggressive exploration to identify promising edges for the TSP solution.}\"\"\"\n    \n    n = distance_matrix.shape[0]\n    pheromone = np.ones((n, n)) * 0.1  # Initialize pheromone trails\n    heuristics_matrix = np.zeros((n, n))\n    alpha = 0.5  # Pheromone influence\n    beta = 3.0  # Distance influence\n    evaporation_rate = 0.2\n    num_ants = n // 2  # Reduced number of ants\n\n    for iteration in range(50):  # Fewer iterations\n        paths = []\n        path_lengths = []\n        for ant in range(num_ants):\n            current_node = np.random.randint(n)\n            visited = [False] * n\n            visited[current_node] = True\n            path = [current_node]\n            path_length = 0\n\n            while len(path) < n:\n                probabilities = np.zeros(n)\n                for i in range(n):\n                    if not visited[i]:\n                        probabilities[i] = (pheromone[current_node, i]**alpha) / (distance_matrix[current_node, i]**beta)\n                \n                if np.sum(probabilities) == 0:\n                    unvisited_nodes = [i for i in range(n) if not visited[i]]\n                    next_node = np.random.choice(unvisited_nodes)\n                else:\n                    probabilities /= np.sum(probabilities)\n                    next_node = np.random.choice(n, p=probabilities)\n                \n                path.append(next_node)\n                path_length += distance_matrix[current_node, next_node]\n                visited[next_node] = True\n                current_node = next_node\n\n            path_length += distance_matrix[path[-1], path[0]]\n            paths.append(path)\n            path_lengths.append(path_length)\n\n        # Update pheromone trails - simplified update\n        pheromone *= (1 - evaporation_rate)\n\n        best_path_index = np.argmin(path_lengths)\n        best_path = paths[best_path_index]\n        best_path_length = path_lengths[best_path_index]\n\n        # Aggressive pheromone update for the best path\n        for i in range(n):\n            pheromone[best_path[i], best_path[(i + 1) % n]] += 2.0 / best_path_length\n            pheromone[best_path[(i + 1) % n], best_path[i]] += 2.0 / best_path_length\n\n        # Update heuristics matrix\n        for i in range(n):\n            for j in range(n):\n                heuristics_matrix[i, j] += pheromone[i, j] / distance_matrix[i, j]\n\n    return heuristics_matrix",
          "objective": 5.79493,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm employs a combination of ant colony optimization and local search to iteratively refine TSP solutions, enhancing pheromone trails based on improved path lengths found through edge swapping.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm employs a combination of ant colony optimization and local search to iteratively refine TSP solutions, enhancing pheromone trails based on improved path lengths found through edge swapping.}\"\"\"\n    \n    n = distance_matrix.shape[0]\n    pheromone = np.ones((n, n))  # Initialize pheromone trails\n    heuristics_matrix = np.zeros((n, n))\n    temperature = 1.0  # Initial temperature\n    cooling_rate = 0.95\n    alpha = 1.0  # Pheromone influence\n    beta = 2.0  # Distance influence\n    evaporation_rate = 0.1\n    local_search_iterations = 10\n\n    for iteration in range(100):  # Number of iterations\n        paths = []\n        path_lengths = []\n        for ant in range(n):  # Number of ants equals number of nodes\n            current_node = ant\n            visited = [False] * n\n            visited[current_node] = True\n            path = [current_node]\n            path_length = 0\n\n            while len(path) < n:\n                probabilities = np.zeros(n)\n                for i in range(n):\n                    if not visited[i]:\n                        probabilities[i] = (pheromone[current_node, i]**alpha) / (distance_matrix[current_node, i]**beta)\n                \n                if np.sum(probabilities) == 0:\n                    # Handle the case where all probabilities are zero (e.g., all nodes visited or infinite distance)\n                    # This could happen if the distance matrix has np.inf values.\n                    # A simple workaround is to randomly choose an unvisited node.\n                    unvisited_nodes = [i for i in range(n) if not visited[i]]\n                    next_node = np.random.choice(unvisited_nodes)\n                else:\n                    probabilities /= np.sum(probabilities)\n                    next_node = np.random.choice(n, p=probabilities)\n                \n                path.append(next_node)\n                path_length += distance_matrix[current_node, next_node]\n                visited[next_node] = True\n                current_node = next_node\n\n            path_length += distance_matrix[path[-1], path[0]]  # Return to starting node\n            paths.append(path)\n            path_lengths.append(path_length)\n\n        # Local search (2-opt swap)\n        for ant in range(n):\n            path = paths[ant]\n            path_length = path_lengths[ant]\n\n            for _ in range(local_search_iterations):\n                i, j = np.random.choice(n, 2, replace=False)\n                if i > j:\n                    i, j = j, i\n\n                new_path = path[:i] + path[i:j+1][::-1] + path[j+1:]\n                new_path_length = 0\n                for k in range(n - 1):\n                    new_path_length += distance_matrix[new_path[k], new_path[k+1]]\n                new_path_length += distance_matrix[new_path[-1], new_path[0]]\n\n                if new_path_length < path_length:\n                    paths[ant] = new_path\n                    path_lengths[ant] = new_path_length\n\n        # Update pheromone trails\n        pheromone *= (1 - evaporation_rate)  # Evaporation\n\n        best_path_index = np.argmin(path_lengths)\n        best_path = paths[best_path_index]\n        best_path_length = path_lengths[best_path_index]\n\n        for i in range(n):\n            pheromone[best_path[i], best_path[(i + 1) % n]] += 1.0 / best_path_length\n            pheromone[best_path[(i + 1) % n], best_path[i]] += 1.0 / best_path_length\n        \n        # Update heuristics matrix\n        for i in range(n):\n            for j in range(n):\n                heuristics_matrix[i, j] += pheromone[i, j] / distance_matrix[i, j]  # Combine pheromone and distance\n        \n        temperature *= cooling_rate  # Cool the temperature\n\n    return heuristics_matrix",
          "objective": 5.80284,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm generates multiple tours by iteratively adding the edge with the highest pheromone level (initialized inversely proportional to distance) while avoiding cycles, and then updates pheromone levels based on a modified score function incorporating distance and pheromone with adjusted parameters, and averages edge occurrences across generated tours.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"\n    {This algorithm generates multiple tours by iteratively adding the edge with the highest pheromone level (initialized inversely proportional to distance) while avoiding cycles, and then updates pheromone levels based on a modified score function incorporating distance and pheromone with adjusted parameters, and averages edge occurrences across generated tours.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    pheromone_matrix = 1 / (distance_matrix + np.eye(n))  # Avoid division by zero\n    alpha = 0.5  # Reduced influence of pheromones\n    beta = 3     # Increased influence of distance\n    num_ants = 15  # Increased number of ants\n    num_iterations = 75 # Increased number of iterations\n    evaporation_rate = 0.3 # Reduced evaporation rate\n\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    for iteration in range(num_iterations):\n        ant_tours = []\n        for ant in range(num_ants):\n            start_node = np.random.randint(n)\n            tour = [start_node]\n            unvisited = set(range(n))\n            unvisited.remove(start_node)\n\n            current_node = start_node\n            while unvisited:\n                probabilities = np.zeros(n)\n                for i in unvisited:\n                    probabilities[i] = (pheromone_matrix[current_node, i]**alpha) * ((1/(distance_matrix[current_node, i]+1e-9))**beta) # adding 1e-9 to avoid division by zero\n                probabilities /= np.sum(probabilities)\n\n                next_node = np.random.choice(list(range(n)), p=probabilities)\n\n                if next_node not in unvisited:\n                  continue\n\n                tour.append(next_node)\n                unvisited.remove(next_node)\n                current_node = next_node\n\n            tour.append(start_node)\n            ant_tours.append(tour)\n\n        # Update pheromones\n        pheromone_matrix *= (1 - evaporation_rate)\n\n        for tour in ant_tours:\n            tour_length = 0\n            for i in range(n):\n                tour_length += distance_matrix[tour[i], tour[i+1]]\n\n            if tour_length > 0:  # Avoid division by zero if tour_length is zero\n                pheromone_deposit = 1 / tour_length\n            else:\n                pheromone_deposit = 0\n\n            for i in range(n):\n                node1 = tour[i]\n                node2 = tour[i+1]\n                pheromone_matrix[node1, node2] += pheromone_deposit\n                pheromone_matrix[node2, node1] += pheromone_deposit\n\n        # Aggregate edge frequencies for heuristic matrix\n        for tour in ant_tours:\n            for i in range(n):\n                node1 = tour[i]\n                node2 = tour[i+1]\n                heuristics_matrix[node1, node2] += 1\n                heuristics_matrix[node2, node1] += 1\n\n    heuristics_matrix /= (num_ants * num_iterations)\n    return heuristics_matrix",
          "objective": 5.97479,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm generates multiple tours by iteratively adding the edge with the highest pheromone level (initialized inversely proportional to distance) while avoiding cycles, and then updates pheromone levels based on tour quality.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"\n    {This algorithm generates multiple tours by iteratively adding the edge with the highest pheromone level (initialized inversely proportional to distance) while avoiding cycles, and then updates pheromone levels based on tour quality.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    pheromone_matrix = 1 / (distance_matrix + np.eye(n))  # Avoid division by zero\n    alpha = 1\n    beta = 2\n    num_ants = 10\n    num_iterations = 50\n    evaporation_rate = 0.5\n\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    for iteration in range(num_iterations):\n        ant_tours = []\n        for ant in range(num_ants):\n            start_node = np.random.randint(n)\n            tour = [start_node]\n            unvisited = set(range(n))\n            unvisited.remove(start_node)\n\n            current_node = start_node\n            while unvisited:\n                probabilities = np.zeros(n)\n                for i in unvisited:\n                    probabilities[i] = (pheromone_matrix[current_node, i]**alpha) * ((1/(distance_matrix[current_node, i]+1e-9))**beta) # adding 1e-9 to avoid division by zero\n                probabilities /= np.sum(probabilities)\n\n                next_node = np.random.choice(list(range(n)), p=probabilities)\n\n                if next_node not in unvisited:\n                  continue\n\n                tour.append(next_node)\n                unvisited.remove(next_node)\n                current_node = next_node\n\n            tour.append(start_node)\n            ant_tours.append(tour)\n\n        # Update pheromones\n        pheromone_matrix *= (1 - evaporation_rate)\n\n        for tour in ant_tours:\n            tour_length = 0\n            for i in range(n):\n                tour_length += distance_matrix[tour[i], tour[i+1]]\n\n            if tour_length > 0:  # Avoid division by zero if tour_length is zero\n                pheromone_deposit = 1 / tour_length\n            else:\n                pheromone_deposit = 0\n\n            for i in range(n):\n                node1 = tour[i]\n                node2 = tour[i+1]\n                pheromone_matrix[node1, node2] += pheromone_deposit\n                pheromone_matrix[node2, node1] += pheromone_deposit\n\n        # Aggregate edge frequencies for heuristic matrix\n        for tour in ant_tours:\n            for i in range(n):\n                node1 = tour[i]\n                node2 = tour[i+1]\n                heuristics_matrix[node1, node2] += 1\n                heuristics_matrix[node2, node1] += 1\n\n    heuristics_matrix /= (num_ants * num_iterations)\n    return heuristics_matrix",
          "objective": 6.0111,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm constructs tours by iteratively selecting the nearest unvisited neighbor with a probability biased by pheromone levels, updating pheromones based on tour length, and returns a matrix representing edge frequencies across multiple tours.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"\n    {This algorithm constructs tours by iteratively selecting the nearest unvisited neighbor with a probability biased by pheromone levels, updating pheromones based on tour length, and returns a matrix representing edge frequencies across multiple tours.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    pheromone_matrix = 1 / (distance_matrix + np.eye(n))  # Avoid division by zero\n    alpha = 1\n    beta = 2\n    num_ants = 10\n    num_iterations = 50\n    evaporation_rate = 0.5\n\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    for iteration in range(num_iterations):\n        ant_tours = []\n        for ant in range(num_ants):\n            start_node = np.random.randint(n)\n            tour = [start_node]\n            unvisited = set(range(n))\n            unvisited.remove(start_node)\n\n            current_node = start_node\n            while unvisited:\n                probabilities = np.zeros(n)\n                for i in unvisited:\n                    probabilities[i] = (pheromone_matrix[current_node, i]**alpha) * ((1/(distance_matrix[current_node, i]+1e-9))**beta) # adding 1e-9 to avoid division by zero\n                probabilities /= np.sum(probabilities)\n\n                next_node = np.random.choice(list(range(n)), p=probabilities)\n\n                if next_node not in unvisited:\n                  continue\n\n                tour.append(next_node)\n                unvisited.remove(next_node)\n                current_node = next_node\n\n            tour.append(start_node)\n            ant_tours.append(tour)\n\n        # Update pheromones\n        pheromone_matrix *= (1 - evaporation_rate)\n\n        for tour in ant_tours:\n            tour_length = 0\n            for i in range(n):\n                tour_length += distance_matrix[tour[i], tour[i+1]]\n\n            if tour_length > 0:  # Avoid division by zero if tour_length is zero\n                pheromone_deposit = 1 / tour_length\n            else:\n                pheromone_deposit = 0\n\n            for i in range(n):\n                node1 = tour[i]\n                node2 = tour[i+1]\n                pheromone_matrix[node1, node2] += pheromone_deposit\n                pheromone_matrix[node2, node1] += pheromone_deposit\n\n        # Aggregate edge frequencies for heuristic matrix\n        for tour in ant_tours:\n            for i in range(n):\n                node1 = tour[i]\n                node2 = tour[i+1]\n                heuristics_matrix[node1, node2] += 1\n                heuristics_matrix[node2, node1] += 1\n\n    heuristics_matrix /= (num_ants * num_iterations)\n    return heuristics_matrix",
          "objective": 6.08154,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm constructs a heuristic matrix by iteratively generating tours using a greedy approach with random restarts and incorporates both edge distances and node degrees to guide tour construction.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm constructs a heuristic matrix by iteratively generating tours using a greedy approach with random restarts and incorporates both edge distances and node degrees to guide tour construction.}\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    num_samples = 100\n\n    for _ in range(num_samples):\n        start_node = np.random.randint(n)\n        current_node = start_node\n        unvisited_nodes = set(range(n))\n        unvisited_nodes.remove(current_node)\n        tour = [current_node]\n        node_degrees = np.zeros(n)\n\n        while unvisited_nodes:\n            # Incorporate node degrees into distance calculation\n            weighted_distances = distance_matrix[current_node, :] + node_degrees * 0.1  # Adjust factor as needed\n            weighted_distances = np.where(np.isin(range(n), list(unvisited_nodes)), weighted_distances, np.inf)\n            \n            nearest_node = np.argmin(weighted_distances)\n            \n            if nearest_node not in unvisited_nodes:\n                available_nodes = list(unvisited_nodes)\n                if available_nodes:\n                    nearest_node = min(available_nodes, key=lambda x: distance_matrix[current_node, x])\n                else:\n                    break\n\n            tour.append(nearest_node)\n            unvisited_nodes.remove(nearest_node)\n\n            heuristics_matrix[current_node, nearest_node] += 1\n            heuristics_matrix[nearest_node, current_node] += 1\n\n            node_degrees[current_node] += 1\n            node_degrees[nearest_node] += 1\n\n            current_node = nearest_node\n        \n        tour.append(start_node)\n\n        heuristics_matrix[current_node, start_node] += 1\n        heuristics_matrix[start_node, current_node] += 1\n\n    return heuristics_matrix",
          "objective": 6.11481,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm constructs tours by iteratively selecting the nearest unvisited neighbor with a probability biased by pheromone levels and a fixed desirability, updating pheromones based on tour length and edge usage, and returns a matrix representing edge frequencies across multiple tours.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"\n    {This algorithm constructs tours by iteratively selecting the nearest unvisited neighbor with a probability biased by pheromone levels and a fixed desirability, updating pheromones based on tour length and edge usage, and returns a matrix representing edge frequencies across multiple tours.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    pheromone_matrix = np.ones_like(distance_matrix)\n    alpha = 0.5\n    beta = 1.5\n    desirability = 0.1\n    num_ants = 15\n    num_iterations = 40\n    evaporation_rate = 0.3\n    Q = 10\n\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    for iteration in range(num_iterations):\n        ant_tours = []\n        for ant in range(num_ants):\n            start_node = np.random.randint(n)\n            tour = [start_node]\n            unvisited = set(range(n))\n            unvisited.remove(start_node)\n\n            current_node = start_node\n            while unvisited:\n                probabilities = np.zeros(n)\n                for i in unvisited:\n                    probabilities[i] = (pheromone_matrix[current_node, i]**alpha) * ((1/(distance_matrix[current_node, i]+1e-9))**beta) + desirability # adding 1e-9 to avoid division by zero\n                probabilities /= np.sum(probabilities)\n\n                next_node = np.random.choice(list(range(n)), p=probabilities)\n                if next_node not in unvisited:\n                  continue\n\n                tour.append(next_node)\n                unvisited.remove(next_node)\n                current_node = next_node\n\n            tour.append(start_node)\n            ant_tours.append(tour)\n\n        # Update pheromones\n        pheromone_matrix *= (1 - evaporation_rate)\n\n        for tour in ant_tours:\n            tour_length = 0\n            for i in range(n):\n                tour_length += distance_matrix[tour[i], tour[i+1]]\n\n            for i in range(n):\n                node1 = tour[i]\n                node2 = tour[i+1]\n                pheromone_matrix[node1, node2] += Q / (tour_length + 1e-9)\n                pheromone_matrix[node2, node1] += Q / (tour_length + 1e-9)\n\n        # Aggregate edge frequencies for heuristic matrix\n        for tour in ant_tours:\n            for i in range(n):\n                node1 = tour[i]\n                node2 = tour[i+1]\n                heuristics_matrix[node1, node2] += 1\n                heuristics_matrix[node2, node1] += 1\n\n    heuristics_matrix /= (num_ants * num_iterations)\n    return heuristics_matrix",
          "objective": 6.13183,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm constructs multiple tours using a nearest neighbor approach from random starting nodes, then averages the edge occurrences across these tours to estimate edge importance.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm constructs multiple tours using a nearest neighbor approach from random starting nodes, then averages the edge occurrences across these tours to estimate edge importance.}\"\"\"\n    n = distance_matrix.shape[0]\n    num_samples = 100\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    for _ in range(num_samples):\n        # Choose a random starting node\n        nodes = list(range(n))\n        start_node = np.random.choice(nodes)\n        tour = [start_node]\n        nodes_left = [node for node in nodes if node != start_node]\n\n        # Build the tour using nearest neighbor\n        while nodes_left:\n            last_node = tour[-1]\n            nearest_node = None\n            min_distance = float('inf')\n\n            for node in nodes_left:\n                distance = distance_matrix[last_node, node]\n                if distance < min_distance:\n                    min_distance = distance\n                    nearest_node = node\n\n            tour.append(nearest_node)\n            nodes_left.remove(nearest_node)\n        \n        tour.append(tour[0])\n\n        # Update heuristics matrix\n        for i in range(n):\n            node1 = tour[i]\n            node2 = tour[i+1]\n            heuristics_matrix[node1, node2] += 1\n            heuristics_matrix[node2, node1] += 1\n\n    heuristics_matrix /= num_samples\n    return heuristics_matrix",
          "objective": 6.14834,
          "other_inf": null
     }
]