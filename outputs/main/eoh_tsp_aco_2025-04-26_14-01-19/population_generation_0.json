[
     {
          "algorithm": "This algorithm iteratively samples candidate TSP solutions by stochastically selecting edges based on a combination of distance, pheromone (representing prior success), and a temperature parameter that controls exploration vs. exploitation, then updates pheromone trails based on solution quality.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm iteratively samples candidate TSP solutions by stochastically selecting edges based on a combination of distance, pheromone (representing prior success), and a temperature parameter that controls exploration vs. exploitation, then updates pheromone trails based on solution quality.}\"\"\"\n    \n    n = distance_matrix.shape[0]\n    pheromone = np.ones((n, n))  # Initialize pheromone trails\n    heuristics_matrix = np.zeros((n, n))\n    temperature = 1.0  # Initial temperature\n    cooling_rate = 0.95\n    alpha = 1.0  # Pheromone influence\n    beta = 2.0  # Distance influence\n    evaporation_rate = 0.1\n\n    for iteration in range(100):  # Number of iterations\n        paths = []\n        path_lengths = []\n        for ant in range(n):  # Number of ants equals number of nodes\n            current_node = ant\n            visited = [False] * n\n            visited[current_node] = True\n            path = [current_node]\n            path_length = 0\n\n            while len(path) < n:\n                probabilities = np.zeros(n)\n                for i in range(n):\n                    if not visited[i]:\n                        probabilities[i] = (pheromone[current_node, i]**alpha) / (distance_matrix[current_node, i]**beta)\n                \n                if np.sum(probabilities) == 0:\n                    # Handle the case where all probabilities are zero (e.g., all nodes visited or infinite distance)\n                    # This could happen if the distance matrix has np.inf values.\n                    # A simple workaround is to randomly choose an unvisited node.\n                    unvisited_nodes = [i for i in range(n) if not visited[i]]\n                    next_node = np.random.choice(unvisited_nodes)\n                else:\n                    probabilities /= np.sum(probabilities)\n                    next_node = np.random.choice(n, p=probabilities)\n                \n                path.append(next_node)\n                path_length += distance_matrix[current_node, next_node]\n                visited[next_node] = True\n                current_node = next_node\n\n            path_length += distance_matrix[path[-1], path[0]]  # Return to starting node\n            paths.append(path)\n            path_lengths.append(path_length)\n\n        # Update pheromone trails\n        pheromone *= (1 - evaporation_rate)  # Evaporation\n\n        best_path_index = np.argmin(path_lengths)\n        best_path = paths[best_path_index]\n        best_path_length = path_lengths[best_path_index]\n\n        for i in range(n):\n            pheromone[best_path[i], best_path[(i + 1) % n]] += 1.0 / best_path_length\n            pheromone[best_path[(i + 1) % n], best_path[i]] += 1.0 / best_path_length\n        \n        # Update heuristics matrix\n        for i in range(n):\n            for j in range(n):\n                heuristics_matrix[i, j] += pheromone[i, j] / distance_matrix[i, j]  # Combine pheromone and distance\n        \n        temperature *= cooling_rate  # Cool the temperature\n\n    return heuristics_matrix",
          "objective": 5.74993,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm samples multiple random TSP solutions using a nearest neighbor heuristic, then aggregates the edge frequencies across these solutions to generate a heuristic matrix indicating the likelihood of each edge being part of a good TSP tour.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm samples multiple random TSP solutions using a nearest neighbor heuristic, then aggregates the edge frequencies across these solutions to generate a heuristic matrix indicating the likelihood of each edge being part of a good TSP tour.}\"\"\"\n    n = distance_matrix.shape[0]\n    num_samples = 100\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    for _ in range(num_samples):\n        start_node = np.random.randint(n)\n        current_node = start_node\n        unvisited_nodes = set(range(n))\n        unvisited_nodes.remove(current_node)\n        tour = [current_node]\n\n        while unvisited_nodes:\n            nearest_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node, node])\n            heuristics_matrix[current_node, nearest_node] += 1\n            heuristics_matrix[nearest_node, current_node] += 1\n            current_node = nearest_node\n            tour.append(current_node)\n            unvisited_nodes.remove(current_node)\n\n        heuristics_matrix[current_node, start_node] += 1\n        heuristics_matrix[start_node, current_node] += 1\n\n    return heuristics_matrix",
          "objective": 6.17309,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm samples multiple greedy solutions by starting from different random nodes, and averages the frequency each edge appears in these solutions to generate a heuristic matrix.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm samples multiple greedy solutions by starting from different random nodes, and averages the frequency each edge appears in these solutions to generate a heuristic matrix.}\"\"\"\n    num_nodes = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    num_samples = num_nodes * 5  # Sample multiple greedy solutions\n\n    for _ in range(num_samples):\n        start_node = np.random.randint(num_nodes)\n        current_node = start_node\n        unvisited_nodes = set(range(num_nodes))\n        unvisited_nodes.remove(start_node)\n        path = [start_node]\n\n        while unvisited_nodes:\n            nearest_node = -1\n            min_distance = np.inf\n            for neighbor in unvisited_nodes:\n                distance = distance_matrix[current_node, neighbor]\n                if distance < min_distance:\n                    min_distance = distance\n                    nearest_node = neighbor\n\n            path.append(nearest_node)\n            unvisited_nodes.remove(nearest_node)\n            current_node = nearest_node\n\n        path.append(start_node)  # Return to the start node\n\n        # Update heuristics matrix based on the path\n        for i in range(len(path) - 1):\n            node1 = path[i]\n            node2 = path[i+1]\n            heuristics_matrix[node1, node2] += 1\n            heuristics_matrix[node2, node1] += 1\n\n    # Normalize the heuristics matrix\n    heuristics_matrix /= num_samples\n    return heuristics_matrix",
          "objective": 6.24894,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm samples multiple TSP solutions using a nearest neighbor heuristic with randomized starting nodes, and then averages the edge occurrences across these solutions to estimate edge importance.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm samples multiple TSP solutions using a nearest neighbor heuristic with randomized starting nodes, and then averages the edge occurrences across these solutions to estimate edge importance.}\"\"\"\n    n = distance_matrix.shape[0]\n    num_samples = 100\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    for _ in range(num_samples):\n        start_node = np.random.randint(n)\n        unvisited_nodes = set(range(n))\n        current_node = start_node\n        unvisited_nodes.remove(current_node)\n        path = [current_node]\n\n        while unvisited_nodes:\n            nearest_neighbor = None\n            min_distance = float('inf')\n\n            for neighbor in unvisited_nodes:\n                distance = distance_matrix[current_node, neighbor]\n                if distance < min_distance:\n                    min_distance = distance\n                    nearest_neighbor = neighbor\n\n            path.append(nearest_neighbor)\n            current_node = nearest_neighbor\n            unvisited_nodes.remove(current_node)\n\n        path.append(start_node)\n\n        for i in range(n):\n            node1 = path[i]\n            node2 = path[i+1]\n            heuristics_matrix[node1, node2] += 1\n            heuristics_matrix[node2, node1] += 1\n\n    heuristics_matrix /= num_samples\n    return heuristics_matrix",
          "objective": 6.26726,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm estimates edge importance by sampling random paths, penalizing edges used in long paths and rewarding edges used in short paths, then normalizes the edge weights to generate the heuristics matrix.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm estimates edge importance by sampling random paths, penalizing edges used in long paths and rewarding edges used in short paths, then normalizes the edge weights to generate the heuristics matrix.}\"\"\"\n    num_nodes = distance_matrix.shape[0]\n    num_samples = 1000\n    edge_counts = np.zeros_like(distance_matrix, dtype=float)\n    path_lengths = np.zeros(num_samples)\n\n    for i in range(num_samples):\n        path = np.random.permutation(num_nodes)\n        path_length = 0\n        for j in range(num_nodes - 1):\n            path_length += distance_matrix[path[j], path[j+1]]\n            edge_counts[path[j], path[j+1]] += 1\n            edge_counts[path[j+1], path[j]] += 1\n        path_length += distance_matrix[path[-1], path[0]]\n        edge_counts[path[-1], path[0]] += 1\n        edge_counts[path[0], path[-1]] += 1\n        path_lengths[i] = path_length\n\n    average_path_length = np.mean(path_lengths)\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    for i in range(num_nodes):\n        for j in range(num_nodes):\n            if i != j:\n                if edge_counts[i, j] > 0:\n                  heuristics_matrix[i, j] = edge_counts[i, j] / distance_matrix[i, j]\n                else:\n                  heuristics_matrix[i, j] = 0\n            else:\n              heuristics_matrix[i, j] = 0\n\n    # Normalize the matrix\n    max_val = np.max(heuristics_matrix)\n    if max_val > 0:\n      heuristics_matrix = heuristics_matrix / max_val\n\n    return heuristics_matrix",
          "objective": 6.71911,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm generates multiple random tours using a nearest neighbor heuristic with stochasticity, and then averages the frequency each edge appears across these tours to create a heuristic matrix.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"\n    {This algorithm generates multiple random tours using a nearest neighbor heuristic with stochasticity, and then averages the frequency each edge appears across these tours to create a heuristic matrix.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    num_samples = 100\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    for _ in range(num_samples):\n        start_node = np.random.randint(n)\n        tour = [start_node]\n        unvisited = set(range(n))\n        unvisited.remove(start_node)\n\n        current_node = start_node\n        while unvisited:\n            distances = distance_matrix[current_node, :]\n            \n            # Stochastic nearest neighbor: adds some randomness to the selection.\n            probabilities = np.zeros(n)\n            for i in unvisited:\n                probabilities[i] = np.exp(-distances[i] / np.std(distances))\n            probabilities /= np.sum(probabilities)\n            \n            next_node = np.random.choice(n, p=probabilities)\n\n            if next_node not in unvisited:\n                unvisited_probs = [probabilities[i] for i in unvisited]\n                unvisited_probs /= np.sum(unvisited_probs)\n                next_node = np.random.choice(list(unvisited), p=unvisited_probs)\n\n            tour.append(next_node)\n            unvisited.remove(next_node)\n            current_node = next_node\n\n        tour.append(start_node)  # Return to the starting node\n\n        for i in range(n):\n            node1 = tour[i]\n            node2 = tour[i+1]\n            heuristics_matrix[node1, node2] += 1\n            heuristics_matrix[node2, node1] += 1\n\n    heuristics_matrix /= num_samples\n    return heuristics_matrix",
          "objective": 8.04654,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm uses stochastic sampling of near-optimal tours by iteratively building tours using a nearest neighbor approach with probabilistic edge selection based on edge cost and a temperature parameter, and then aggregates edge usage frequencies to produce a heuristic matrix.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm uses stochastic sampling of near-optimal tours by iteratively building tours using a nearest neighbor approach with probabilistic edge selection based on edge cost and a temperature parameter, and then aggregates edge usage frequencies to produce a heuristic matrix.}\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    num_samples = 100\n\n    for _ in range(num_samples):\n        start_node = np.random.randint(n)\n        current_node = start_node\n        unvisited_nodes = set(range(n))\n        unvisited_nodes.remove(current_node)\n        tour = [current_node]\n\n        while unvisited_nodes:\n            distances = np.array([distance_matrix[current_node, i] if i in unvisited_nodes else np.inf for i in range(n)])\n            \n            # Use softmax to convert distances to probabilities\n            temperature = 1.0  # Adjust for exploration vs. exploitation\n            probabilities = np.exp(-distances / temperature)\n            probabilities[np.isinf(probabilities)] = 0 # remove infinities generated during softmax operation\n            probabilities = probabilities / np.sum(probabilities)\n\n            next_node = np.random.choice(n, p=probabilities)\n            \n            if next_node not in unvisited_nodes:\n                available_nodes = list(unvisited_nodes)\n                if available_nodes:\n                    next_node = min(available_nodes, key=lambda x: distance_matrix[current_node, x])\n                else:\n                    break \n                \n            tour.append(next_node)\n            unvisited_nodes.remove(next_node)\n            current_node = next_node\n        \n        tour.append(start_node)\n        \n        for i in range(len(tour) - 1):\n            node1 = tour[i]\n            node2 = tour[i+1]\n            heuristics_matrix[node1, node2] += 1\n            heuristics_matrix[node2, node1] += 1\n\n    heuristics_matrix = heuristics_matrix / num_samples\n    return heuristics_matrix",
          "objective": 14.96462,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm samples random tours and updates a heuristic matrix based on the frequency of edges appearing in short tours.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm samples random tours and updates a heuristic matrix based on the frequency of edges appearing in short tours.}\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    num_samples = 1000\n    best_tour_length = float('inf')\n\n    for _ in range(num_samples):\n        # Generate a random tour\n        tour = np.random.permutation(n)\n        \n        # Calculate the tour length\n        tour_length = 0\n        for i in range(n - 1):\n            tour_length += distance_matrix[tour[i], tour[i+1]]\n        tour_length += distance_matrix[tour[n-1], tour[0]]\n        \n        # Update heuristics based on tour quality\n        if tour_length < best_tour_length:\n            for i in range(n - 1):\n                heuristics_matrix[tour[i], tour[i+1]] += 1/tour_length\n                heuristics_matrix[tour[i+1], tour[i]] += 1/tour_length\n            heuristics_matrix[tour[n-1], tour[0]] += 1/tour_length\n            heuristics_matrix[tour[0], tour[n-1]] += 1/tour_length\n            best_tour_length = tour_length\n            \n    return heuristics_matrix",
          "objective": 17.68925,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm generates multiple random tours, selects the best few, and then averages the edge occurrences across those best tours to produce a heuristic matrix.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm generates multiple random tours, selects the best few, and then averages the edge occurrences across those best tours to produce a heuristic matrix.}\"\"\"\n    n = distance_matrix.shape[0]\n    num_tours = 100\n    num_best = 10\n    tours = []\n    tour_lengths = []\n\n    for _ in range(num_tours):\n        tour = np.random.permutation(n)\n        tour_length = 0\n        for i in range(n - 1):\n            tour_length += distance_matrix[tour[i], tour[i+1]]\n        tour_length += distance_matrix[tour[-1], tour[0]]\n        tours.append(tour)\n        tour_lengths.append(tour_length)\n\n    # Sort tours by length\n    sorted_indices = np.argsort(tour_lengths)\n    best_tours = [tours[i] for i in sorted_indices[:num_best]]\n\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    for tour in best_tours:\n        for i in range(n - 1):\n            heuristics_matrix[tour[i], tour[i+1]] += 1\n            heuristics_matrix[tour[i+1], tour[i]] += 1\n        heuristics_matrix[tour[-1], tour[0]] += 1\n        heuristics_matrix[tour[0], tour[-1]] += 1\n\n    heuristics_matrix = heuristics_matrix / num_best  # Average the edge counts\n\n    return heuristics_matrix",
          "objective": 17.87252,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm generates multiple random tours, scores each edge based on how often it appears in good tours, and returns a matrix of these scores.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"\n    {This algorithm generates multiple random tours, scores each edge based on how often it appears in good tours, and returns a matrix of these scores.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    num_samples = 1000\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    for _ in range(num_samples):\n        # Generate a random tour\n        tour = np.random.permutation(n)\n\n        # Calculate tour length\n        tour_length = 0\n        for i in range(n - 1):\n            tour_length += distance_matrix[tour[i], tour[i+1]]\n        tour_length += distance_matrix[tour[-1], tour[0]]\n\n        # Normalize tour length (lower is better)\n        normalized_length = 1 / (tour_length + 1e-6)  # Add a small constant to avoid division by zero\n\n        # Update edge scores based on normalized tour length\n        for i in range(n - 1):\n            heuristics_matrix[tour[i], tour[i+1]] += normalized_length\n            heuristics_matrix[tour[i+1], tour[i]] += normalized_length  # Symmetric\n        heuristics_matrix[tour[-1], tour[0]] += normalized_length\n        heuristics_matrix[tour[0], tour[-1]] += normalized_length\n\n    # Normalize the heuristics matrix\n    heuristics_matrix = heuristics_matrix / num_samples\n\n    return heuristics_matrix",
          "objective": 20.04918,
          "other_inf": null
     }
]