{
     "algorithm": "This algorithm iteratively samples candidate TSP solutions by stochastically selecting edges based on a combination of distance, pheromone (representing prior success), and a temperature parameter that controls exploration vs. exploitation, then updates pheromone trails based on solution quality.",
     "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm iteratively samples candidate TSP solutions by stochastically selecting edges based on a combination of distance, pheromone (representing prior success), and a temperature parameter that controls exploration vs. exploitation, then updates pheromone trails based on solution quality.}\"\"\"\n    \n    n = distance_matrix.shape[0]\n    pheromone = np.ones((n, n))  # Initialize pheromone trails\n    heuristics_matrix = np.zeros((n, n))\n    temperature = 1.0  # Initial temperature\n    cooling_rate = 0.95\n    alpha = 1.0  # Pheromone influence\n    beta = 2.0  # Distance influence\n    evaporation_rate = 0.1\n\n    for iteration in range(100):  # Number of iterations\n        paths = []\n        path_lengths = []\n        for ant in range(n):  # Number of ants equals number of nodes\n            current_node = ant\n            visited = [False] * n\n            visited[current_node] = True\n            path = [current_node]\n            path_length = 0\n\n            while len(path) < n:\n                probabilities = np.zeros(n)\n                for i in range(n):\n                    if not visited[i]:\n                        probabilities[i] = (pheromone[current_node, i]**alpha) / (distance_matrix[current_node, i]**beta)\n                \n                if np.sum(probabilities) == 0:\n                    # Handle the case where all probabilities are zero (e.g., all nodes visited or infinite distance)\n                    # This could happen if the distance matrix has np.inf values.\n                    # A simple workaround is to randomly choose an unvisited node.\n                    unvisited_nodes = [i for i in range(n) if not visited[i]]\n                    next_node = np.random.choice(unvisited_nodes)\n                else:\n                    probabilities /= np.sum(probabilities)\n                    next_node = np.random.choice(n, p=probabilities)\n                \n                path.append(next_node)\n                path_length += distance_matrix[current_node, next_node]\n                visited[next_node] = True\n                current_node = next_node\n\n            path_length += distance_matrix[path[-1], path[0]]  # Return to starting node\n            paths.append(path)\n            path_lengths.append(path_length)\n\n        # Update pheromone trails\n        pheromone *= (1 - evaporation_rate)  # Evaporation\n\n        best_path_index = np.argmin(path_lengths)\n        best_path = paths[best_path_index]\n        best_path_length = path_lengths[best_path_index]\n\n        for i in range(n):\n            pheromone[best_path[i], best_path[(i + 1) % n]] += 1.0 / best_path_length\n            pheromone[best_path[(i + 1) % n], best_path[i]] += 1.0 / best_path_length\n        \n        # Update heuristics matrix\n        for i in range(n):\n            for j in range(n):\n                heuristics_matrix[i, j] += pheromone[i, j] / distance_matrix[i, j]  # Combine pheromone and distance\n        \n        temperature *= cooling_rate  # Cool the temperature\n\n    return heuristics_matrix",
     "objective": 5.74993,
     "other_inf": null
}