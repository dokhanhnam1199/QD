import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm uses a Genetic Algorithm (GA) to evolve a population of TSP tours and averages edge occurrences across the best performing individuals (elites) in the final generation to form the heuristic matrix.}"""
    n = distance_matrix.shape[0]
    num_samples = 100
    population_size = 50
    num_generations = 30
    mutation_rate = 0.01
    elite_size = 10

    def calculate_fitness(tour):
        total_distance = 0
        for i in range(len(tour) - 1):
            total_distance += distance_matrix[tour[i], tour[i+1]]
        return total_distance

    def create_initial_population(population_size, n):
        population = []
        for _ in range(population_size):
            tour = np.random.permutation(n).tolist()
            tour.append(tour[0])
            population.append(tour)
        return population

    def selection(population, fitness_scores, elite_size):
        elite_indices = np.argsort(fitness_scores)[:elite_size]
        elites = [population[i] for i in elite_indices]
        return elites

    def crossover(parent1, parent2):
        start_gene = np.random.randint(1, len(parent1) - 1)
        end_gene = np.random.randint(start_gene + 1, len(parent1))
        
        child = [-1] * len(parent1)
        for i in range(start_gene, end_gene):
            child[i] = parent1[i]
        
        index2 = 1
        for i in range(1, len(parent1)):
            if child[i] == -1:
                while parent2[index2] in child:
                    index2 += 1
                child[i] = parent2[index2]
                index2 += 1
        return child

    def mutate(tour, mutation_rate):
        for i in range(1, len(tour) - 1):
            if np.random.rand() < mutation_rate:
                j = np.random.randint(1, len(tour) - 1)
                tour[i], tour[j] = tour[j], tour[i]
        return tour

    population = create_initial_population(population_size, n)
    
    for _ in range(num_generations):
        fitness_scores = [calculate_fitness(tour) for tour in population]
        elites = selection(population, fitness_scores, elite_size)

        new_population = elites.copy()
        while len(new_population) < population_size:
            parent1 = np.random.choice(elites)
            parent2 = np.random.choice(elites)
            child = crossover(parent1, parent2)
            child = mutate(child, mutation_rate)
            new_population.append(child)
        population = new_population

    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    fitness_scores = [calculate_fitness(tour) for tour in population]
    elite_indices = np.argsort(fitness_scores)[:elite_size]
    elites = [population[i] for i in elite_indices]

    for tour in elites:
        for i in range(n):
            node1 = tour[i]
            node2 = tour[i+1]
            heuristics_matrix[node1, node2] += 1
            heuristics_matrix[node2, node1] += 1

    heuristics_matrix /= (elite_size)
    return heuristics_matrix
