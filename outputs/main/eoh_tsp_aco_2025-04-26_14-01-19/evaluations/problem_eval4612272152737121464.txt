import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm iteratively refines a heuristic matrix by probabilistically constructing tours based on current heuristics, evaluating tour quality, and reinforcing edges present in good tours while penalizing those in poor tours.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.ones((n, n))  # Initialize heuristic matrix
    alpha = 1.0  # Influence of heuristic information
    beta = 2.0  # Influence of distance
    learning_rate = 0.1
    num_iterations = 100
    num_tours = 2 * n

    for iteration in range(num_iterations):
        tours = []
        tour_lengths = []
        for _ in range(num_tours):
            start_node = np.random.randint(n)
            tour = [start_node]
            unvisited = set(range(n))
            unvisited.remove(start_node)
            current_node = start_node

            while unvisited:
                probabilities = np.zeros(n)
                for neighbor in range(n):
                    if neighbor in unvisited:
                        probabilities[neighbor] = (heuristics_matrix[current_node, neighbor]**alpha) / (distance_matrix[current_node, neighbor]**beta)

                if np.sum(probabilities) > 0:
                    probabilities /= np.sum(probabilities)
                    next_node = np.random.choice(n, p=probabilities)
                else:
                    next_node = np.random.choice(list(unvisited))

                tour.append(next_node)
                unvisited.remove(next_node)
                current_node = next_node
            
            tour.append(start_node)
            tour_length = 0
            for i in range(n):
                tour_length += distance_matrix[tour[i], tour[i+1]]
            
            tours.append(tour)
            tour_lengths.append(tour_length)
        
        best_tour_length = min(tour_lengths)
        worst_tour_length = max(tour_lengths)

        for i in range(num_tours):
            tour = tours[i]
            tour_length = tour_lengths[i]
            
            reward = (worst_tour_length - tour_length) / (worst_tour_length - best_tour_length)
            
            for j in range(n):
                node1 = tour[j]
                node2 = tour[j+1]
                
                if reward > 0.5:
                    heuristics_matrix[node1, node2] *= (1 + learning_rate * reward)
                    heuristics_matrix[node2, node1] *= (1 + learning_rate * reward)
                else:
                    heuristics_matrix[node1, node2] *= (1 - learning_rate * (1 - reward))
                    heuristics_matrix[node2, node1] *= (1 - learning_rate * (1 - reward))

    return heuristics_matrix
