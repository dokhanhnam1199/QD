import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm uses simulated annealing to iteratively refine a set of random tours, favoring shorter tours and updating a heuristics matrix based on edge frequencies in accepted solutions.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros((n, n))
    num_iterations = 1000
    initial_temperature = 100
    cooling_rate = 0.95
    num_tours = 10

    tours = [np.random.permutation(n) for _ in range(num_tours)]
    tour_lengths = [calculate_tour_length(tour, distance_matrix) for tour in tours]

    temperature = initial_temperature
    for iteration in range(num_iterations):
        for i in range(num_tours):
            tour = tours[i]
            tour_length = tour_lengths[i]

            # Generate a neighbor tour by swapping two random cities
            neighbor_tour = tour.copy()
            idx1, idx2 = np.random.choice(n, 2, replace=False)
            neighbor_tour[idx1], neighbor_tour[idx2] = neighbor_tour[idx2], neighbor_tour[idx1]
            neighbor_tour_length = calculate_tour_length(neighbor_tour, distance_matrix)

            # Accept the neighbor tour based on the Metropolis criterion
            delta = neighbor_tour_length - tour_length
            if delta < 0 or np.random.rand() < np.exp(-delta / temperature):
                tours[i] = neighbor_tour
                tour_lengths[i] = neighbor_tour_length

        # Update temperature
        temperature *= cooling_rate

    # Update heuristics matrix based on edge frequencies in accepted tours
    for tour in tours:
        for i in range(n):
            city1 = tour[i]
            city2 = tour[(i + 1) % n]
            heuristics_matrix[city1, city2] += 1
            heuristics_matrix[city2, city1] += 1

    heuristics_matrix /= num_tours
    return heuristics_matrix

def calculate_tour_length(tour, distance_matrix):
    length = 0
    for i in range(len(tour) - 1):
        length += distance_matrix[tour[i], tour[i + 1]]
    length += distance_matrix[tour[-1], tour[0]]
    return heuristics_matrix
