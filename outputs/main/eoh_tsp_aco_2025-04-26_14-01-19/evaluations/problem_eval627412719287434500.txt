import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm builds a heuristic matrix by averaging edge frequencies across multiple greedy randomized construction and local search improvement iterations.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros((n, n))
    num_samples = 50
    local_search_iterations = 5

    for _ in range(num_samples):
        # Greedy randomized construction
        unvisited = list(range(n))
        start_node = np.random.choice(unvisited)
        path = [start_node]
        unvisited.remove(start_node)

        while unvisited:
            current_node = path[-1]
            distances = [distance_matrix[current_node, node] for node in unvisited]
            min_dist = min(distances)
            candidates = [unvisited[i] for i, dist in enumerate(distances) if dist <= min_dist * 1.2] # Randomized: Allow some sub-optimal choices
            next_node = np.random.choice(candidates)
            path.append(next_node)
            unvisited.remove(next_node)

        path.append(path[0])

        # Local search (2-opt)
        for _ in range(local_search_iterations):
            improved = False
            for i in range(1, n):
                for j in range(i + 2, n + 1):
                    old_distance = distance_matrix[path[i - 1], path[i]] + distance_matrix[path[j - 1], path[j % n]]
                    new_distance = distance_matrix[path[i - 1], path[j - 1]] + distance_matrix[path[i], path[j % n]]
                    if new_distance < old_distance:
                        path[i:j] = reversed(path[i:j])
                        improved = True
            if not improved:
                break

        # Update heuristics matrix based on edge frequency
        for i in range(n):
            heuristics_matrix[path[i], path[(i + 1) % n]] += 1
            heuristics_matrix[path[(i + 1) % n], path[i]] += 1

    return heuristics_matrix
