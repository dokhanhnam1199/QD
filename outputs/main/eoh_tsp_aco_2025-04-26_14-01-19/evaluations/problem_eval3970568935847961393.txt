import numpy as np

def heuristics_v2(distance_matrix):
    """
    {This algorithm constructs tours using a combination of pheromone levels and distance, periodically updating pheromones based on tour quality and using an elite ant strategy to reinforce the best tour found so far, and aggregates edge frequencies for the heuristic matrix.}
    """
    n = distance_matrix.shape[0]
    pheromone_matrix = 1 / (distance_matrix + np.eye(n))  # Avoid division by zero
    alpha = 1
    beta = 2
    num_ants = 10
    num_iterations = 50
    evaporation_rate = 0.5
    elite_weight = 2 

    best_tour = None
    best_tour_length = float('inf')

    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

    for iteration in range(num_iterations):
        ant_tours = []
        ant_tour_lengths = []
        for ant in range(num_ants):
            start_node = np.random.randint(n)
            tour = [start_node]
            unvisited = set(range(n))
            unvisited.remove(start_node)

            current_node = start_node
            while unvisited:
                probabilities = np.zeros(n)
                for i in unvisited:
                    probabilities[i] = (pheromone_matrix[current_node, i]**alpha) * ((1/(distance_matrix[current_node, i]+1e-9))**beta) # adding 1e-9 to avoid division by zero
                probabilities /= np.sum(probabilities)

                next_node = np.random.choice(list(range(n)), p=probabilities)

                if next_node not in unvisited:
                  continue

                tour.append(next_node)
                unvisited.remove(next_node)
                current_node = next_node

            tour.append(start_node)
            ant_tours.append(tour)

            tour_length = 0
            for i in range(n):
                tour_length += distance_matrix[tour[i], tour[i+1]]
            ant_tour_lengths.append(tour_length)

            if tour_length < best_tour_length:
                best_tour_length = tour_length
                best_tour = tour

        # Update pheromones
        pheromone_matrix *= (1 - evaporation_rate)

        for tour, tour_length in zip(ant_tours, ant_tour_lengths):
            if tour_length > 0:  # Avoid division by zero if tour_length is zero
                pheromone_deposit = 1 / tour_length
            else:
                pheromone_deposit = 0

            for i in range(n):
                node1 = tour[i]
                node2 = tour[i+1]
                pheromone_matrix[node1, node2] += pheromone_deposit
                pheromone_matrix[node2, node1] += pheromone_deposit

        # Elite ant strategy
        if best_tour:
            best_tour_length = 0
            for i in range(n):
                best_tour_length += distance_matrix[best_tour[i], best_tour[i+1]]
            
            if best_tour_length > 0:
                elite_pheromone_deposit = elite_weight / best_tour_length
            else:
                elite_pheromone_deposit = 0

            for i in range(n):
                node1 = best_tour[i]
                node2 = best_tour[i+1]
                pheromone_matrix[node1, node2] += elite_pheromone_deposit
                pheromone_matrix[node2, node1] += elite_pheromone_deposit


        # Aggregate edge frequencies for heuristic matrix
        for tour in ant_tours:
            for i in range(n):
                node1 = tour[i]
                node2 = tour[i+1]
                heuristics_matrix[node1, node2] += 1
                heuristics_matrix[node2, node1] += 1

    heuristics_matrix /= (num_ants * num_iterations)
    return heuristics_matrix
