import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm uses a Monte Carlo tree search approach to explore the solution space, iteratively building partial tours and evaluating their potential based on estimated remaining cost, then updating a heuristic matrix based on the frequency of edge usage in promising tours.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros((n, n))
    num_iterations = 100
    num_simulations = 10

    def calculate_remaining_cost_estimate(partial_tour, unvisited_nodes, distance_matrix):
        if not unvisited_nodes:
            return 0.0
        
        current_node = partial_tour[-1]
        remaining_cost = 0.0
        
        # Estimate remaining cost as sum of shortest edges from current node to unvisited nodes and back
        distances_to_unvisited = [distance_matrix[current_node, node] for node in unvisited_nodes]
        remaining_cost += sum(sorted(distances_to_unvisited)[:min(len(distances_to_unvisited),2)]) # Sum of two shortest dists

        if len(partial_tour) == n-1:
            remaining_cost += min([distance_matrix[node,partial_tour[0]] for node in unvisited_nodes])
        else:
            #Estimate the distance between the unvisited nodes
            subset_dist_matrix = distance_matrix[np.ix_(list(unvisited_nodes),list(unvisited_nodes))]
            if(subset_dist_matrix.shape[0] > 1):
                 remaining_cost += np.mean(subset_dist_matrix) /2
        return remaining_cost
    
    def simulate_tour(start_node, distance_matrix, heuristics_matrix):
        current_node = start_node
        unvisited_nodes = set(range(n))
        unvisited_nodes.remove(current_node)
        tour = [current_node]
        tour_length = 0.0

        while unvisited_nodes:
            best_next_node = None
            best_tour_length = float('inf')
            
            for next_node in unvisited_nodes:
                temp_tour = tour + [next_node]
                temp_unvisited = unvisited_nodes.copy()
                temp_unvisited.remove(next_node)
                
                estimated_length = tour_length + distance_matrix[current_node, next_node] + calculate_remaining_cost_estimate(temp_tour, temp_unvisited, distance_matrix)
                
                if estimated_length < best_tour_length:
                    best_tour_length = estimated_length
                    best_next_node = next_node

            if best_next_node is None:
                break

            tour_length += distance_matrix[current_node, best_next_node]
            tour.append(best_next_node)
            unvisited_nodes.remove(best_next_node)
            current_node = best_next_node

        tour_length += distance_matrix[tour[-1], tour[0]]  # Return to start
        return tour, tour_length

    for _ in range(num_iterations):
        for start_node in range(n):
            best_tour = None
            best_tour_length = float('inf')

            for _ in range(num_simulations):
                tour, tour_length = simulate_tour(start_node, distance_matrix, heuristics_matrix)
                
                if tour_length < best_tour_length:
                    best_tour_length = tour_length
                    best_tour = tour

            if best_tour:
                for i in range(len(best_tour)):
                    node1 = best_tour[i]
                    node2 = best_tour[(i + 1) % len(best_tour)]
                    heuristics_matrix[node1, node2] += 1
                    heuristics_matrix[node2, node1] += 1

    return heuristics_matrix
