import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm constructs tours using a randomized nearest neighbor approach, biased by a pheromone matrix which is updated based on tour quality and edge usage, mimicking ant colony optimization principles.}"""
    n = distance_matrix.shape[0]
    pheromone_matrix = np.ones((n, n))  # Initialize pheromone matrix
    heuristics_matrix = np.zeros((n, n))
    num_ants = 50
    evaporation_rate = 0.1
    q = 100  # Pheromone deposit constant

    for ant in range(num_ants):
        start_node = np.random.randint(n)
        tour = [start_node]
        unvisited = set(range(n))
        unvisited.remove(start_node)
        current_node = start_node
        tour_length = 0.0

        while unvisited:
            probabilities = np.array([pheromone_matrix[current_node, neighbor] / distance_matrix[current_node, neighbor] if distance_matrix[current_node, neighbor] > 0 else 0 for neighbor in range(n)])
            probabilities[list(range(n))] = 0 # Exclude already visited nodes
            probabilities[current_node] = 0 # Exclude current node
            probabilities = probabilities/ np.sum(probabilities) if np.sum(probabilities) > 0 else np.ones(n)/n # Normalize probabilities to sum to 1

            next_node = np.random.choice(n, p=probabilities)
            while next_node not in unvisited:
                probabilities = np.array([pheromone_matrix[current_node, neighbor] / distance_matrix[current_node, neighbor] if distance_matrix[current_node, neighbor] > 0 else 0 for neighbor in range(n)])
                probabilities[list(range(n))] = 0 # Exclude already visited nodes
                probabilities[current_node] = 0 # Exclude current node
                probabilities = probabilities/ np.sum(probabilities) if np.sum(probabilities) > 0 else np.ones(n)/n # Normalize probabilities to sum to 1
                next_node = np.random.choice(n, p=probabilities)
            
            tour.append(next_node)
            tour_length += distance_matrix[current_node, next_node]
            unvisited.remove(next_node)
            current_node = next_node
        
        tour.append(start_node)  # Complete the cycle
        tour_length += distance_matrix[current_node, start_node]
        
        # Pheromone update
        for i in range(n):
            node1 = tour[i]
            node2 = tour[(i + 1) % n]
            pheromone_matrix[node1, node2] += q / tour_length
            pheromone_matrix[node2, node1] += q / tour_length
        
        pheromone_matrix *= (1 - evaporation_rate)  # Evaporation

    # Aggregate pheromone information into the heuristics matrix
    for i in range(n):
        for j in range(n):
            if i != j:
                heuristics_matrix[i, j] = pheromone_matrix[i, j]
    return heuristics_matrix
