import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm combines edge-usage statistics from multiple local search procedures with a weighted random sampling approach to build a heuristic matrix.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros((n, n))
    num_samples = 50
    local_search_iterations = 5

    for _ in range(num_samples):
        # Randomly initialize a solution
        nodes = list(range(n))
        np.random.shuffle(nodes)
        path = nodes + [nodes[0]]

        # Local search (2-opt)
        for _ in range(local_search_iterations):
            improved = False
            for i in range(1, n):
                for j in range(i + 2, n + 1):
                    old_distance = distance_matrix[path[i - 1], path[i]] + distance_matrix[path[j - 1], path[j % n]]
                    new_distance = distance_matrix[path[i - 1], path[j - 1]] + distance_matrix[path[i], path[j % n]]
                    if new_distance < old_distance:
                        path[i:j] = reversed(path[i:j])
                        improved = True
            if not improved:
                break

        # Update heuristics matrix based on path and path length
        path_length = 0
        for i in range(n):
            path_length += distance_matrix[path[i], path[(i + 1) % n]]

        # Weighted contribution to heuristic matrix
        weight = np.exp(-path_length / 100)  # Example weighting
        for i in range(n):
            heuristics_matrix[path[i], path[(i + 1) % n]] += weight
            heuristics_matrix[path[(i + 1) % n], path[i]] += weight

    return heuristics_matrix
