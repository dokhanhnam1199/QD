import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm uses a greedy approach with random restarts and path smoothing, but biases the path smoothing towards more significant improvements and penalizes longer edges in the heuristic update.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros((n, n))
    num_restarts = 50
    path_smoothing_iterations = 5

    for _ in range(num_restarts):
        # Greedy construction with random start
        start_node = np.random.randint(n)
        unvisited = list(range(n))
        path = [start_node]
        unvisited.remove(start_node)

        while unvisited:
            current_node = path[-1]
            nearest_neighbor = min(unvisited, key=lambda x: distance_matrix[current_node, x])
            path.append(nearest_neighbor)
            unvisited.remove(nearest_neighbor)

        path.append(start_node)  # Complete the cycle

        # Path smoothing (2-opt) - Bias towards larger improvements
        for _ in range(path_smoothing_iterations):
            improved = False
            for i in range(1, n):
                for j in range(i + 2, n + 1):
                    old_distance = distance_matrix[path[i - 1], path[i]] + distance_matrix[path[j - 1], path[j % n]]
                    new_distance = distance_matrix[path[i - 1], path[j - 1]] + distance_matrix[path[i], path[j % n]]
                    improvement = old_distance - new_distance
                    if improvement > 0.1 * (old_distance + new_distance): # Only accept improvements greater than 10%
                        path[i:j] = reversed(path[i:j])
                        improved = True
            if not improved:
                break

        # Update heuristics matrix based on path - Penalize longer edges
        path_length = 0
        for i in range(n):
            path_length += distance_matrix[path[i], path[(i + 1) % n]]
        
        for i in range(n):
            edge_length = distance_matrix[path[i], path[(i + 1) % n]]
            heuristic_update = max(0.0, (1.0 / path_length) * (1 - (edge_length / np.mean(distance_matrix)))) # Penalize longer edges
            heuristics_matrix[path[i], path[(i + 1) % n]] += heuristic_update
            heuristics_matrix[path[(i + 1) % n], path[i]] += heuristic_update

    return heuristics_matrix
