import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm estimates edge importance by sampling random paths, weighting edges by the inverse of the path length they appear in, and then normalizes the edge weights to generate the heuristics matrix.}"""
    num_nodes = distance_matrix.shape[0]
    num_samples = 1000
    edge_weights = np.zeros_like(distance_matrix, dtype=float)

    for i in range(num_samples):
        path = np.random.permutation(num_nodes)
        path_length = 0
        for j in range(num_nodes - 1):
            path_length += distance_matrix[path[j], path[j+1]]
        path_length += distance_matrix[path[-1], path[0]]

        for j in range(num_nodes - 1):
            edge_weights[path[j], path[j+1]] += 1.0 / path_length
            edge_weights[path[j+1], path[j]] += 1.0 / path_length
        edge_weights[path[-1], path[0]] += 1.0 / path_length
        edge_weights[path[0], path[-1]] += 1.0 / path_length
    
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    for i in range(num_nodes):
        for j in range(num_nodes):
            if i != j:
                heuristics_matrix[i, j] = edge_weights[i, j] / distance_matrix[i, j]
            else:
                heuristics_matrix[i, j] = 0

    # Normalize the matrix
    max_val = np.max(heuristics_matrix)
    if max_val > 0:
        heuristics_matrix = heuristics_matrix / max_val

    return heuristics_matrix
