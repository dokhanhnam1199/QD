import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm combines shortest path computations with perturbation and iterative refinement to estimate edge importance.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    num_iterations = 50

    for _ in range(num_iterations):
        start_node = np.random.randint(n)
        
        # Compute shortest paths from start_node
        distances = dijkstra(distance_matrix, start_node)
        
        # Perturb distances slightly (exploration)
        perturbed_distances = distances + np.random.normal(0, np.mean(distances)/10, size=n)
        perturbed_distances = np.maximum(perturbed_distances, 0) #Ensure no negative distances

        # Build a path from start to every other node using perturbed distances
        paths = {}
        for end_node in range(n):
            if end_node != start_node:
                path = find_path(distance_matrix, start_node, end_node, perturbed_distances)
                paths[end_node] = path

        #Refine and score the paths
        for end_node, path in paths.items():
            if path:
                for i in range(len(path) - 1):
                    node1 = path[i]
                    node2 = path[i+1]
                    heuristics_matrix[node1, node2] += 1
                    heuristics_matrix[node2, node1] += 1

    heuristics_matrix = heuristics_matrix / num_iterations
    return heuristics_matrix

def dijkstra(distance_matrix, start_node):
    n = distance_matrix.shape[0]
    distances = np.full(n, np.inf)
    distances[start_node] = 0
    visited = np.zeros(n, dtype=bool)

    for _ in range(n):
        # Find the unvisited node with the smallest distance
        min_distance = np.inf
        min_node = -1
        for node in range(n):
            if not visited[node] and distances[node] < min_distance:
                min_distance = distances[node]
                min_node = node

        if min_node == -1:
            break

        visited[min_node] = True

        # Update distances to neighbors
        for neighbor in range(n):
            if distance_matrix[min_node, neighbor] > 0: # Assuming 0 means no direct edge
                new_distance = distances[min_node] + distance_matrix[min_node, neighbor]
                if new_distance < distances[neighbor]:
                    distances[neighbor] = new_distance

    return distances

def find_path(distance_matrix, start_node, end_node, distances):
    n = distance_matrix.shape[0]
    predecessors = {}
    visited = {start_node}
    queue = [start_node]
    
    while queue:
        current_node = queue.pop(0)
        
        if current_node == end_node:
            break
            
        for neighbor in range(n):
            if distance_matrix[current_node, neighbor] > 0 :
                if neighbor not in visited:
                    if distances[current_node] + distance_matrix[current_node, neighbor] <= distances[neighbor]+1e-6: #Allow small difference due to perturbation
                        predecessors[neighbor] = current_node
                        visited.add(neighbor)
                        queue.append(neighbor)

    # Reconstruct path
    path = []
    current = end_node
    while current != start_node:
        if current not in predecessors:
            return None  # No path found
        path.append(current)
        current = predecessors[current]
    path.append(start_node)
    path.reverse()

    return heuristics_matrix
