import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm uses a greedy approach with random restarts and path smoothing, updating the heuristic matrix with a score function based on edge rank within the tour.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros((n, n))
    num_restarts = 50
    path_smoothing_iterations = 5

    for _ in range(num_restarts):
        # Greedy construction with random start
        start_node = np.random.randint(n)
        unvisited = list(range(n))
        path = [start_node]
        unvisited.remove(start_node)

        while unvisited:
            current_node = path[-1]
            nearest_neighbor = min(unvisited, key=lambda x: distance_matrix[current_node, x])
            path.append(nearest_neighbor)
            unvisited.remove(nearest_neighbor)

        path.append(start_node)  # Complete the cycle

        # Path smoothing (2-opt)
        for _ in range(path_smoothing_iterations):
            improved = False
            for i in range(1, n):
                for j in range(i + 2, n + 1):
                    old_distance = distance_matrix[path[i - 1], path[i]] + distance_matrix[path[j - 1], path[j % n]]
                    new_distance = distance_matrix[path[i - 1], path[j - 1]] + distance_matrix[path[i], path[j % n]]
                    if new_distance < old_distance:
                        path[i:j] = reversed(path[i:j])
                        improved = True
            if not improved:
                break

        # Update heuristics matrix based on path and edge rank
        tour_length = len(path)
        for i in range(n):
            u = path[i]
            v = path[(i + 1) % n]

            # Calculate a score based on the edge's 'rank' in the tour.
            rank_score = 1.0 / (i + 1)  # Edges appearing earlier get higher scores

            heuristics_matrix[u, v] += rank_score
            heuristics_matrix[v, u] += rank_score

    return heuristics_matrix
