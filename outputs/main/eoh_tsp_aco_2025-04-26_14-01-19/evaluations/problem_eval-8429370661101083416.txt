import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm uses a genetic algorithm with a pheromone-guided mutation operator to evolve a population of TSP solutions, updating a heuristic matrix based on the frequency of edges in the best solutions.}"""
    n = distance_matrix.shape[0]
    population_size = 50
    num_generations = 100
    mutation_rate = 0.1
    pheromone_influence = 0.5
    evaporation_rate = 0.1
    
    # Initialize pheromone matrix
    pheromone_matrix = np.ones((n, n))

    # Initialize population
    population = []
    for _ in range(population_size):
        population.append(np.random.permutation(n))
    
    heuristics_matrix = np.zeros((n, n))

    for generation in range(num_generations):
        # Evaluate fitness of each individual (path length)
        fitness = np.zeros(population_size)
        for i in range(population_size):
            path = population[i]
            for j in range(n - 1):
                fitness[i] += distance_matrix[path[j], path[j+1]]
            fitness[i] += distance_matrix[path[-1], path[0]]

        # Selection (tournament selection)
        selected_indices = np.random.choice(population_size, size=population_size, replace=True)
        new_population = []
        for i in range(0, population_size, 2):
            if i + 1 >= population_size:
                parent1_idx = selected_indices[i]
                parent2_idx = selected_indices[i]
            else:
                parent1_idx = selected_indices[i]
                parent2_idx = selected_indices[i+1]
            
            if fitness[parent1_idx] < fitness[parent2_idx]:
                parent = population[parent1_idx]
            else:
                parent = population[parent2_idx]
            new_population.append(parent)
            
        population = new_population

        # Crossover (order crossover) - only one parent is used for simplicity based on pheromone guided mutation
        
        # Mutation (pheromone-guided swap)
        for i in range(population_size):
            if np.random.rand() < mutation_rate:
                node1 = np.random.randint(n)
                # Pheromone-guided selection of node2
                probabilities = pheromone_matrix[population[i][node1], :]
                probabilities /= np.sum(probabilities)
                node2 = np.random.choice(n, p=probabilities)
                
                # Find index of node2 in the path
                idx2 = np.where(population[i] == node2)[0][0]

                # Swap nodes
                population[i][node1], population[i][idx2] = population[i][idx2], population[i][node1]

        # Update pheromone matrix
        pheromone_matrix *= (1 - evaporation_rate)
        best_index = np.argmin(fitness)
        best_path = population[best_index]
        best_path_length = fitness[best_index]

        for i in range(n):
            pheromone_matrix[best_path[i], best_path[(i + 1) % n]] += 1.0 / best_path_length
            pheromone_matrix[best_path[(i + 1) % n], best_path[i]] += 1.0 / best_path_length

        # Update heuristic matrix
        for path in population:
            for i in range(n):
                node1 = path[i]
                node2 = path[(i + 1) % n]
                heuristics_matrix[node1, node2] += 1
                heuristics_matrix[node2, node1] += 1
                
    heuristics_matrix /= (population_size * num_generations)
    return heuristics_matrix
