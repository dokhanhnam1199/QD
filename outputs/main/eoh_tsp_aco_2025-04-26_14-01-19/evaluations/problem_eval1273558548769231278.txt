import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm constructs a heuristic matrix by iteratively generating tours using a greedy approach with random restarts and incorporates both edge distances and node degrees to guide tour construction.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    num_samples = 100

    for _ in range(num_samples):
        start_node = np.random.randint(n)
        current_node = start_node
        unvisited_nodes = set(range(n))
        unvisited_nodes.remove(current_node)
        tour = [current_node]
        node_degrees = np.zeros(n)

        while unvisited_nodes:
            # Incorporate node degrees into distance calculation
            weighted_distances = distance_matrix[current_node, :] + node_degrees * 0.1  # Adjust factor as needed
            weighted_distances = np.where(np.isin(range(n), list(unvisited_nodes)), weighted_distances, np.inf)
            
            nearest_node = np.argmin(weighted_distances)
            
            if nearest_node not in unvisited_nodes:
                available_nodes = list(unvisited_nodes)
                if available_nodes:
                    nearest_node = min(available_nodes, key=lambda x: distance_matrix[current_node, x])
                else:
                    break

            tour.append(nearest_node)
            unvisited_nodes.remove(nearest_node)

            heuristics_matrix[current_node, nearest_node] += 1
            heuristics_matrix[nearest_node, current_node] += 1

            node_degrees[current_node] += 1
            node_degrees[nearest_node] += 1

            current_node = nearest_node
        
        tour.append(start_node)

        heuristics_matrix[current_node, start_node] += 1
        heuristics_matrix[start_node, current_node] += 1

    return heuristics_matrix
