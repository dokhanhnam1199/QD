import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm iteratively refines a probability distribution over edges by sampling candidate solutions, evaluating their quality using a combination of distance and edge frequency, and updating the distribution to favor edges present in better solutions.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros((n, n))
    edge_probabilities = np.ones((n, n)) / (n * n)  # Initialize uniform probabilities

    num_iterations = 100
    num_samples = 50
    alpha = 0.7  # Influence of distance
    beta = 1.3 # Influence of frequency

    for _ in range(num_iterations):
        candidate_solutions = []
        solution_lengths = []

        for _ in range(num_samples):
            # Sample a path based on edge probabilities
            current_node = np.random.randint(n)
            unvisited = set(range(n))
            unvisited.remove(current_node)
            path = [current_node]

            while unvisited:
                probabilities = edge_probabilities[current_node, :].copy()
                
                #Zero out the probabilities to already visited nodes
                for node in range(n):
                  if node not in unvisited:
                    probabilities[node] = 0
                    
                if np.sum(probabilities) == 0:
                  next_node = np.random.choice(list(unvisited))
                else:
                  probabilities /= np.sum(probabilities)
                  next_node = np.random.choice(n, p=probabilities)
                  while next_node not in unvisited:
                    probabilities[next_node] = 0
                    if np.sum(probabilities) == 0:
                      next_node = np.random.choice(list(unvisited))
                      break
                    probabilities /= np.sum(probabilities)
                    next_node = np.random.choice(n, p=probabilities)
                    
                path.append(next_node)
                unvisited.remove(next_node)
                current_node = next_node

            path.append(path[0]) # Complete the cycle
            
            # Calculate the length of the path
            path_length = 0
            for i in range(n):
                path_length += distance_matrix[path[i], path[(i + 1) % n]]

            candidate_solutions.append(path)
            solution_lengths.append(path_length)

        # Evaluate solutions and update edge probabilities
        for i in range(num_samples):
            path = candidate_solutions[i]
            path_length = solution_lengths[i]

            # Calculate a score based on distance and frequency
            score = np.exp(-alpha * path_length) # Lower path lengths = higher score
            
            # Update edge probabilities based on score
            for j in range(n):
                u = path[j]
                v = path[(j + 1) % n]
                edge_probabilities[u, v] = (1 - beta) * edge_probabilities[u, v] + beta * score
                edge_probabilities[v, u] = (1 - beta) * edge_probabilities[v, u] + beta * score
                
        # Normalize edge probabilities
        for row in range(n):
          if np.sum(edge_probabilities[row,:]) > 0:
            edge_probabilities[row,:] /= np.sum(edge_probabilities[row,:])
          else:
            edge_probabilities[row,:] = np.ones(n) / n

    heuristics_matrix = edge_probabilities
    return heuristics_matrix
