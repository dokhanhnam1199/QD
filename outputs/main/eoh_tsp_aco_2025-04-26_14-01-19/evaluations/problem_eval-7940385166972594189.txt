import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm estimates edge importance by sampling random paths, penalizing edges used in long paths and rewarding edges used in short paths, then normalizes the edge weights to generate the heuristics matrix.}"""
    num_nodes = distance_matrix.shape[0]
    num_samples = 1000
    edge_counts = np.zeros_like(distance_matrix, dtype=float)
    path_lengths = np.zeros(num_samples)

    for i in range(num_samples):
        path = np.random.permutation(num_nodes)
        path_length = 0
        for j in range(num_nodes - 1):
            path_length += distance_matrix[path[j], path[j+1]]
            edge_counts[path[j], path[j+1]] += 1
            edge_counts[path[j+1], path[j]] += 1
        path_length += distance_matrix[path[-1], path[0]]
        edge_counts[path[-1], path[0]] += 1
        edge_counts[path[0], path[-1]] += 1
        path_lengths[i] = path_length

    average_path_length = np.mean(path_lengths)
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

    for i in range(num_nodes):
        for j in range(num_nodes):
            if i != j:
                if edge_counts[i, j] > 0:
                  heuristics_matrix[i, j] = edge_counts[i, j] / distance_matrix[i, j]
                else:
                  heuristics_matrix[i, j] = 0
            else:
              heuristics_matrix[i, j] = 0

    # Normalize the matrix
    max_val = np.max(heuristics_matrix)
    if max_val > 0:
      heuristics_matrix = heuristics_matrix / max_val

    return heuristics_matrix
