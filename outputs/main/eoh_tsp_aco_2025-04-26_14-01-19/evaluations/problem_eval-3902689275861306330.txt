import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm uses a greedy randomized construction of multiple tours, followed by local search and averaging edge frequencies to create a heuristic matrix.}"""
    n = distance_matrix.shape[0]
    num_tours = 50
    local_search_iterations = 10
    randomness_factor = 0.3
    heuristics_matrix = np.zeros((n, n))

    def construct_tour():
        start_node = np.random.randint(n)
        tour = [start_node]
        unvisited = list(range(n))
        unvisited.remove(start_node)

        while unvisited:
            current_node = tour[-1]
            distances = [distance_matrix[current_node, node] for node in unvisited]
            min_distance = min(distances)
            
            # Randomized selection based on distance
            eligible_nodes = [unvisited[i] for i, dist in enumerate(distances) if dist <= min_distance * (1 + randomness_factor)]
            next_node = np.random.choice(eligible_nodes)
            
            tour.append(next_node)
            unvisited.remove(next_node)
        
        tour.append(start_node)
        return tour

    def tour_length(tour):
        length = 0
        for i in range(len(tour) - 1):
            length += distance_matrix[tour[i], tour[i+1]]
        return length
    
    def two_opt_swap(tour):
        best_tour = tour[:]
        best_length = tour_length(tour)
        
        for _ in range(local_search_iterations):
            i, j = np.random.choice(len(tour)-1, 2, replace=False)
            if i > j:
                i, j = j, i

            new_tour = tour[:i+1] + tour[i+1:j+1][::-1] + tour[j+1:]
            new_length = tour_length(new_tour)

            if new_length < best_length:
                best_tour = new_tour[:]
                best_length = new_length
        return best_tour
    
    for _ in range(num_tours):
        tour = construct_tour()
        tour = two_opt_swap(tour) # Apply local search
        
        for i in range(n):
            node1 = tour[i]
            node2 = tour[i+1]
            heuristics_matrix[node1, node2] += 1
            heuristics_matrix[node2, node1] += 1
    
    heuristics_matrix /= (num_tours)  # Normalize
    return heuristics_matrix
