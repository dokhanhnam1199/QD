import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm uses a genetic algorithm approach, evolving a population of tours and using edge frequencies from the best individuals to build the heuristic matrix.}"""
    n = distance_matrix.shape[0]
    population_size = 50
    num_generations = 20
    mutation_rate = 0.05

    # Initialize population
    population = [np.random.permutation(n) for _ in range(population_size)]

    for _ in range(num_generations):
        # Evaluate fitness (tour length)
        fitness = np.array([calculate_tour_length(tour, distance_matrix) for tour in population])

        # Selection (tournament selection)
        selected_indices = np.random.choice(population_size, size=population_size, replace=True, p=softmax(-fitness))  #Probabilistically choose tours based on fitness, favoring shorter tours.

        selected_population = [population[i] for i in selected_indices]

        # Crossover (order crossover)
        new_population = []
        for i in range(0, population_size, 2):
            parent1 = selected_population[i]
            parent2 = selected_population[(i + 1) % population_size]
            child1, child2 = order_crossover(parent1, parent2)
            new_population.append(child1)
            new_population.append(child2)
        population = new_population

        # Mutation (swap mutation)
        for i in range(population_size):
            if np.random.rand() < mutation_rate:
                population[i] = swap_mutation(population[i])

    # After evolution, take the best tour(s) and create the heuristics matrix
    fitness = np.array([calculate_tour_length(tour, distance_matrix) for tour in population])
    best_tour_index = np.argmin(fitness)
    best_tour = population[best_tour_index]

    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    for i in range(n - 1):
        heuristics_matrix[best_tour[i], best_tour[i+1]] = 1.0
        heuristics_matrix[best_tour[i+1], best_tour[i]] = 1.0
    heuristics_matrix[best_tour[-1], best_tour[0]] = 1.0
    heuristics_matrix[best_tour[0], best_tour[-1]] = 1.0

    return heuristics_matrix

def calculate_tour_length(tour, distance_matrix):
    tour_length = 0
    for i in range(len(tour) - 1):
        tour_length += distance_matrix[tour[i], tour[i+1]]
    tour_length += distance_matrix[tour[-1], tour[0]]
    return tour_length

def order_crossover(parent1, parent2):
    n = len(parent1)
    start = np.random.randint(n)
    length = np.random.randint(1, n - 1)
    end = (start + length) % n

    child1 = -np.ones(n, dtype=int)
    child2 = -np.ones(n, dtype=int)

    if start < end:
        child1[start:end] = parent1[start:end]
        child2[start:end] = parent2[start:end]
    else:
        child1[start:] = parent1[start:]
        child1[:end] = parent1[:end]
        child2[start:] = parent2[start:]
        child2[:end] = parent2[:end]

    # Fill in remaining positions
    current1 = end
    current2 = end
    parent2_index = end
    parent1_index = end

    while -1 in child1:
        if parent2[parent2_index] not in child1:
            child1[current1] = parent2[parent2_index]
            current1 = (current1 + 1) % n
        parent2_index = (parent2_index + 1) % n

    while -1 in child2:
        if parent1[parent1_index] not in child2:
            child2[current2] = parent1[parent1_index]
            current2 = (current2 + 1) % n
        parent1_index = (parent1_index + 1) % n
    return child1, child2

def swap_mutation(tour):
    n = len(tour)
    i, j = np.random.choice(n, 2, replace=False)
    tour[i], tour[j] = tour[j], tour[i]
    return tour

def softmax(x):
    e_x = np.exp(x - np.max(x))
    return heuristics_matrix
