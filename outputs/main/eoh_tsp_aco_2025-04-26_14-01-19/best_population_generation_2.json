{
     "algorithm": "This algorithm uses a greedy approach combined with random restarts, path smoothing, and weighted edge updates based on tour length to create a heuristic matrix reflecting edge usage in good-quality tours.",
     "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm uses a greedy approach combined with random restarts, path smoothing, and weighted edge updates based on tour length to create a heuristic matrix reflecting edge usage in good-quality tours.}\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros((n, n))\n    num_restarts = 50\n    smoothing_iterations = 5\n\n    for restart in range(num_restarts):\n        # Greedy tour construction with random start\n        start_node = np.random.randint(n)\n        tour = [start_node]\n        unvisited = set(range(n))\n        unvisited.remove(start_node)\n        current_node = start_node\n\n        while unvisited:\n            nearest_neighbor = min(unvisited, key=lambda x: distance_matrix[current_node, x])\n            tour.append(nearest_neighbor)\n            unvisited.remove(nearest_neighbor)\n            current_node = nearest_neighbor\n        tour.append(start_node)\n\n        # Path smoothing (2-opt swaps)\n        for _ in range(smoothing_iterations):\n            improved = False\n            for i in range(1, n):\n                for j in range(i + 1, n + 1):\n                    if j - i == 1:\n                        continue\n\n                    current_cost = distance_matrix[tour[i - 1], tour[i]] + distance_matrix[tour[j - 1], tour[j % n]]\n                    new_cost = distance_matrix[tour[i - 1], tour[j - 1]] + distance_matrix[tour[i], tour[j % n]]\n\n                    if new_cost < current_cost:\n                        tour[i:j] = reversed(tour[i:j])\n                        improved = True\n            if not improved:\n                break\n\n        # Calculate tour length\n        tour_length = 0\n        for i in range(n):\n            tour_length += distance_matrix[tour[i], tour[(i + 1) % n]]\n\n        # Update heuristic matrix with weighting based on tour length\n        weight = 1.0 / (tour_length + 1e-9)  # Add a small constant to avoid division by zero\n        for i in range(n):\n            node1 = tour[i]\n            node2 = tour[(i + 1) % n]\n            heuristics_matrix[node1, node2] += weight\n            heuristics_matrix[node2, node1] += weight\n\n    heuristics_matrix /= num_restarts\n    return heuristics_matrix",
     "objective": 5.72519,
     "other_inf": null
}