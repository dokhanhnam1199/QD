```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority scores dynamically blending best-fit and worst-fit heuristics.
    
    Large items (close to bin capacity) favor smallest residual (best-fit).
    Small items favor largest remaining capacity (worst-fit space preservation).
    Combines both strategies via continuous weights proportional to item size.
    
    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.
    
    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    can_fit = bins_remain_cap >= item
    if not np.any(can_fit):
        return np.full_like(bins_remain_cap, -np.inf)
    
    C = bins_remain_cap.max()
    s = float(item)
    
    if s > C:
        return np.full_like(bins_remain_cap, -np.inf)
    
    s_ratio = s / C
    best_score = -(bins_remain_cap - s)  # Best fit prioritization
    worst_score = bins_remain_cap       # Worst fit prioritization
    
    # Blend with size-dependent weights:
    # Linear progression between BF (-residual) and WF (remaining)
    priority = s_ratio * best_score + (1 - s_ratio) * worst_score
    priority = np.where(can_fit, priority, -np.inf)
    
    return priority
```
