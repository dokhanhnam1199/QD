```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority scores for bins by dynamically blending Best Fit and Worst Fit,
    with increased sensitivity to item size and bin utilization patterns.
    
    For small items, encourages utilizing bins close to full to preserve large spaces for future items.
    For medium-sized items, uses a smooth blend of Best/Worst Fit. For large items, Best Fit is enforced.
    """
    can_fit = bins_remain_cap >= item
    if not np.any(can_fit):
        return np.full_like(bins_remain_cap, -np.inf)
    
    threshold = 0.5
    residual = bins_remain_cap - item
    
    # Blend factor dynamically balances Best Fit (large item) and Worst Fit (small item)
    blend_factor = np.where(item > threshold, 1.0, item / threshold)
    coefficient = (1 - 2 * blend_factor)  # Positive=Worst Fit, Negative=Best Fit
    priority = coefficient * residual
    
    # Encourage small items to fill bins nearing capacity through utilization bonus
    bin_fill_benefit = 1.0 - bins_remain_cap  # Higher fill means more benefit for small items
    utilization_bonus = np.where(
        item <= threshold * 0.5,  # Only for small items (<= 0.25)
        0.3 * bin_fill_benefit,   # Add proportional bonus to prioritize fuller bins
        0.0
    )
    priority += utilization_bonus
    
    # Penalize bins that would leave very small gaps harder for mid-sized items
    mid_size_mask = (blend_factor > 0.3) & (blend_factor < 0.7)  # Approximately 0.15 < item < 0.35
    tight_penalty = np.where(
        mid_size_mask & (residual < 0.05),  # Leave ~5% buffer below threshold
        -0.2 / (residual + 1e-6),  # Strong penalty for tiny residuals
        0.0
    )
    priority += tight_penalty
    
    # Enforce packing feasibility
    final_priority = np.where(can_fit, priority, -np.inf)
    return final_priority
```
