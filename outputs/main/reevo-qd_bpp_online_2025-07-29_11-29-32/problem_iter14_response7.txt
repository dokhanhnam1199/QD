```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority scores for bins balancing best-fit (large items) and worst-fit (small items).
    
    Calculates adaptive weights based on item size relative to inferred bin capacity.
    Prioritizes bins with smallest residual for large items (best-fit) and largest residual for small items (worst-fit).
    
    Args:
        item: Size of the item to pack.
        bins_remain_cap: Array of remaining capacities for each bin.
    
    Returns:
        Array of priority scores for each bin. Infeasible bins receive -inf.
    """
    if bins_remain_cap.size == 0:
        return np.array([])
    
    EPSILON = 1e-9
    
    # Infer bin capacity from maximum remaining capacity (assumes at least one empty bin exists)
    C = np.max(bins_remain_cap)
    if C < EPSILON and item < EPSILON:
        return np.zeros_like(bins_remain_cap, dtype=np.float64)
    if C < EPSILON:
        return np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)
    
    # Normalize item size
    normalized_item = item / (C + EPSILON)
    
    # Feasibility check
    can_fit = bins_remain_cap >= item
    
    # Calculate weight and residual-based score
    weight = 1 - 2 * normalized_item  # Blend factor: [-1, 1]
    residual = bins_remain_cap - item
    
    # Dynamic priority score with adaptive strategy
    priority = np.where(can_fit, residual * weight, -np.inf)
    
    return priority
```
