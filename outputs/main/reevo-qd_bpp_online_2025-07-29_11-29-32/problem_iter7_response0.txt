```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority scores blending best-fit and worst-fit heuristics adaptively.
    
    For large items, prioritizes minimal slack (best-fit). For small items, preserves 
    larger spaces (worst-fit). Weights dynamically depend on item size relative to 
    estimated bin capacity. Infeasible bins receive -inf priority.
    
    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.
    
    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    can_fit = bins_remain_cap >= item
    if not np.any(can_fit):
        return np.full_like(bins_remain_cap, -np.inf)
    
    # Estimate bin capacity as max remaining capacity (threshold-free adaptation)
    C_estimate = np.max(bins_remain_cap) + 1e-9  # Avoid division by zero
    
    # Size-dependent weights: continuous transition between heuristics
    normalized_size = item / C_estimate
    best_weight = normalized_size  # Best-fit emphasis increases with item size
    worst_weight = 1.0 - normalized_size  # Worst-fit emphasis for small items
    
    # Component scores
    best_score = -(bins_remain_cap - item)  # Best-fit: minimize slack
    worst_score = bins_remain_cap  # Worst-fit: preserve large spaces
    
    # Hybrid priority score
    combined_score = best_weight * best_score + worst_weight * worst_score
    
    # Penalize infeasible bins
    return np.where(can_fit, combined_score, -np.inf)
```
