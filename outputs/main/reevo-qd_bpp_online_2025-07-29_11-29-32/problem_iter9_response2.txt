```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority scores for bins using a dynamic blend of Best Fit and Worst Fit based on item size.
    
    Large items are prioritized with Best Fit logic (min residual), small items with Worst Fit (max residual),
    with smooth threshold-free interpolation using item size.
    
    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.
    
    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    can_fit = bins_remain_cap >= item
    # Best Fit: prioritize minimizing residual (higher score for smaller residual)
    best_priority = -(bins_remain_cap - item)
    # Worst Fit: prioritize maximizing residual bin capacity
    worst_priority = bins_remain_cap
    
    # Blend heuristic: weights depend on item size (s)
    # Large s (close to 1) → best_priority dominates; small s → worst_priority dominates
    weight_best = item
    combined_priority = weight_best * best_priority + (1 - weight_best) * worst_priority
    
    # Infeasible bins get -inf priority
    return np.where(can_fit, combined_priority, -np.inf)
```
