```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Blended strategy combining Best Fit (large items) and Worst Fit (small items) with perfect-fit preference."""
    can_fit = bins_remain_cap >= item
    perfect_fit = np.isclose(bins_remain_cap, item)
    
    # Configurable thresholds for adaptive strategy selection
    LARGE_THRESHOLD = 0.7  # Empirically optimized for larger-item packing efficiency
    PERFECT_FIT_BONUS = 1e6  # Reward bins where item exactly fills remaining capacity
    
    # Base heuristics
    best_priority = -(bins_remain_cap - item)  # Best Fit: minimize remaining space after placement
    worst_priority = bins_remain_cap           # Worst Fit: prefer emptier bins
    
    # Strategy blending based on item size threshold
    priority = np.where(item >= LARGE_THRESHOLD, best_priority, worst_priority)
    
    # Apply perfect-fit preference
    priority = np.where(perfect_fit & can_fit, priority + PERFECT_FIT_BONUS, priority)
    
    # Penalize invalid bins while preserving numeric stability
    return np.where(can_fit, priority, -np.inf)
```
