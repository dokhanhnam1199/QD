[
  {
    "stdout_filepath": "problem_iter0_stdout0.txt",
    "code_path": "problem_iter0_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    return np.zeros_like(bins_remain_cap)",
    "response_id": 0,
    "obj": 4.487435181491823,
    "SLOC": 2.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response0.txt_stdout.txt",
    "code_path": "problem_iter1_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority scores for bins based on Best Fit heuristic.\n\n    Bins that can fit the item are prioritized by smallest remaining capacity after placement.\n    Infeasible bins receive -inf priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    can_fit = bins_remain_cap >= item\n    priority = np.where(can_fit, -(bins_remain_cap - item), -np.inf)\n    return priority",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response0.txt_stdout.txt",
    "code_path": "problem_iter2_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority scores for bins based on minimal leftover space.\n\n    Args:\n        item: Size of the item to be packed.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Returns:\n        Array of priority scores for each bin. Higher values indicate better fit.\n    \"\"\"\n    # Prioritize bins that can fit the item with the least leftover space.\n    # Priority is (item - remaining_capacity), which is negative for valid bins,\n    # with higher (less negative) values indicating better fits.\n    return np.where(bins_remain_cap >= item, item - bins_remain_cap, -np.inf)",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response2.txt_stdout.txt",
    "code_path": "problem_iter3_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority scores combining Best Fit for large and Worst Fit for small items.\n    \n    Uses a dynamic formula based on item size to balance slack minimization and space preservation.\n    \"\"\"\n    can_fit = bins_remain_cap >= item\n    priority = np.where(\n        can_fit,\n        bins_remain_cap * (1 - 2 * item) + (item ** 2),\n        -np.inf\n    )\n    return priority",
    "response_id": 2,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response0.txt_stdout.txt",
    "code_path": "problem_iter4_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on item size using Best Fit for large items and Worst Fit for small ones.\"\"\"\n    can_fit = bins_remain_cap >= item\n    slack = bins_remain_cap - item\n    if item >= 0.5:\n        # Best Fit: prioritize bins with minimal slack (least remaining space after placement)\n        priority = -slack\n    else:\n        # Worst Fit: prioritize bins with maximum remaining capacity\n        priority = bins_remain_cap\n    return np.where(can_fit, priority, -np.inf)",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response1.txt_stdout.txt",
    "code_path": "problem_iter5_code1.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority scores for bins balancing best-fit and worst-fit heuristics.\n    \n    Dynamically scores bins based on item size: minimizes residual capacity for large items\n    and preserves space (maximizes residual) for small items. Penalizes infeasible bins (-\u221e).\n    \n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n    \n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    can_fit = bins_remain_cap >= item\n    residual = bins_remain_cap - item\n    weight = 1 - 2 * item  # Blends best-fit (negative weight) & worst-fit (positive weight)\n    priority = np.where(can_fit, residual * weight, -np.inf)\n    return priority",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 14.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response0.txt_stdout.txt",
    "code_path": "problem_iter6_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority scores blending best-fit and worst-fit with item-size-dependent weights and threshold adjustment.\n    \n    Blends best-fit (residual * negative weight) and worst-fit (residual * positive weight) heuristics with smooth transition at \n    item_size = 0.5, adjusted by epsilon to prioritize best-fit for perfect 0.5-sized items. Additive numerical stability ensures \n    no zero-weight edge cases. Preserves space efficiency for small items and gap avoidance for large items.\n    \n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n    \n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    can_fit = bins_remain_cap >= item\n    residual = bins_remain_cap - item\n    \n    # Dynamic weight with smooth transition and edge-case handling\n    weight_bias = 1e-6\n    weight = (1 - 2 * item) - weight_bias  # Best-fit default at item_size threshold\n    \n    priority = np.where(can_fit, residual * weight, -np.inf)\n    return priority",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response0.txt_stdout.txt",
    "code_path": "problem_iter8_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins using adaptive threshold between best-fit and worst-fit heuristics.\n    \n    For items >= 0.5: Best-fit (min residual) to avoid fragmentation.\n    For items < 0.5: Worst-fit (max residual) to preserve larger spaces.\n    Uses numpy's efficient masking for performance.\n    \n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n    \n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    can_fit = bins_remain_cap >= item\n    residual = bins_remain_cap - item\n    \n    if item >= 0.5:\n        # Best-fit: Score = -residual for smallest residual space\n        priority = np.where(can_fit, -residual, -np.inf)\n    else:\n        # Worst-fit: Score = residual for largest residual space\n        priority = np.where(can_fit, residual, -np.inf)\n    \n    return priority",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response1.txt_stdout.txt",
    "code_path": "problem_iter9_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority scores blending Best Fit and Worst Fit heuristics adaptively.\n    \n    For large items, prioritizes tight fits (Best Fit); for small items, prefers spacious bins (Worst Fit).\n    Invalid bins receive -inf. Combines residual space and item size via dynamic weights.\n    \n    Args:\n        item: Size of item to be added.\n        bins_remain_cap: Array of remaining capacities for each bin.\n    \n    Returns:\n        Array of priority scores for each bin.\n    \"\"\"\n    can_fit = bins_remain_cap >= item\n    residual = bins_remain_cap - item\n    \n    # Adaptive weight based on item size: blends Best Fit (-residual) and Worst Fit (residual)\n    # Weight = item_size \u2192 prioritizes Best Fit more for larger items\n    priority = np.where(can_fit, residual * (1 - 2 * item), -np.inf)\n    return priority",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response0.txt_stdout.txt",
    "code_path": "problem_iter10_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority scores blending Best Fit and Worst Fit with adaptive weights and tie-breaking.\n    \n    Adaptive blending is achieved via item-size-dependent weights. A small epsilon term breaks ties\n    in favor of tighter fits for edge cases (e.g., item=0.5).\n    \n    Args:\n        item: Size of item to be added.\n        bins_remain_cap: Array of remaining capacities for each bin.\n    \n    Returns:\n        Array of priority scores for each bin.\n    \"\"\"\n    can_fit = bins_remain_cap >= item\n    residual = bins_remain_cap - item\n    \n    # Main adaptive priority blending Best/Worst Fit (proportional to residual)\n    adaptive_weight = 1.0 - 2.0 * item\n    adaptive_priority = adaptive_weight * residual\n    \n    # Epsilon term biasing toward smaller residuals in tie-breaker cases\n    epsilon_priority = -residual * 1e-6  # Small negative to prefer least residual\n    \n    # Combine priorities while masking invalid bins\n    priority = np.where(can_fit, adaptive_priority + epsilon_priority, -np.inf)\n    return priority",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  }
]