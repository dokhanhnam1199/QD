```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority scores blending squared-error best fit and worst fit with dynamic weights.
    
    Scores prioritize minimizing leftover space quadratically for large items and preserving large
    spaces for small items. Dynamic epsilon scales with item size relative to estimated bin capacity.
    Infeasible bins receive -inf priority.
    """
    can_fit = bins_remain_cap >= item
    leftover = bins_remain_cap - item
    
    # Best fit term: minimize squared leftover space
    best_fit_term = -(leftover ** 2)
    
    # Estimate bin capacity from current max remaining capacity
    bin_capacity = np.max(bins_remain_cap) if bins_remain_cap.size > 0 else 1.0
    bin_capacity = max(bin_capacity, 1e-9)  # Avoid division by zero
    
    # Dynamic epsilon: larger for small items to prioritize space preservation
    relative_size = item / bin_capacity
    epsilon = (1.0 - np.clip(relative_size, 0.0, 1.0)) * 1e-6
    
    # Worst fit term: prefer bins with larger remaining capacity (space preservation)
    worst_fit_term = bins_remain_cap
    
    # Combined score with adaptive weights
    score = best_fit_term + epsilon * worst_fit_term
    
    # Penalize invalid bins and return
    return np.where(can_fit, score, -np.inf)
```
