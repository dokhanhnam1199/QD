```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority scores blending normalized Best/Worst Fit with adaptive weights and tie-breaking.
    
    Adaptive priorities are calculated using item-size-dependent weights and residuals normalized
    relative to the current distribution of feasible bin capacities. A small epsilon term ensures
    stable tie-breaking in favor of tighter fits.
    
    Args:
        item: Size of item to be added.
        bins_remain_cap: Array of remaining capacities for each bin.
    
    Returns:
        Array of priority scores for each bin.
    """
    can_fit = bins_remain_cap >= item
    residual = bins_remain_cap - item
    
    # Handle edge case where no bins can fit the item
    if not np.any(can_fit):
        return np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)
    
    # Calculate statistics of feasible residuals for normalization
    feasible_residuals = residual[can_fit]
    mean_feasible_residual = np.mean(feasible_residuals)
    
    # Compute adjusted residuals relative to feasible mean
    adjusted_residual = np.where(can_fit, residual - mean_feasible_residual, 0)
    
    # Adaptive blending proportional to item size (1.0 - 2*item means Worst Fit for small items, Best Fit for large)
    adaptive_weight = 1.0 - 2.0 * item
    adaptive_priority = adaptive_weight * adjusted_residual
    
    # Small epsilon term for tie-breaking in favor of tighter fits
    epsilon_priority = -residual * 1e-6
    
    # Combine priorities with infinity masking for invalid bins
    priority = np.where(can_fit, adaptive_priority + epsilon_priority, -np.inf)
    return priority
```
