```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns adaptive priority scores blending Best Fit and Worst Fit heuristics.

    Bins that can fit the item are scored using a combination of Best Fit (minimizing residual slack) and Worst Fit
    (maintaining larger capacities), with weights determined by the item's size relative to the median remaining capacity.
    Squared residual slack penalizes inefficient placements more severely. Infeasible bins receive -inf priority.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    can_fit = bins_remain_cap >= item
    if not np.any(can_fit):
        return np.full_like(bins_remain_cap, -np.inf)

    # Best Fit component: minimize squared residual slack
    residual = bins_remain_cap - item
    best_scores = -(residual ** 2)

    # Worst Fit component: prioritize bins with large remaining capacity
    worst_scores = bins_remain_cap

    # Compute median remaining capacity for threshold adaptation
    med_remaining = np.median(bins_remain_cap[can_fit])

    # Adaptive weight via sigmoid centered at item/med_remaining = 1
    x = item / (med_remaining + 1e-9)  # Avoid division by zero
    k = 4  # Empirically tuned steepness parameter
    weight_best = 1 / (1 + np.exp(-k * (x - 1.25)))  # Right-shifted threshold

    # Blend components with dynamic weights
    scores = weight_best * best_scores + (1 - weight_best) * worst_scores
    scores[~can_fit] = -np.inf  # Penalize invalid bins

    return scores
```
