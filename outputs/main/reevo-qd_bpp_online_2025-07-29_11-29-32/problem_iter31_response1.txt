```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority scores for bins blending best-fit for large items and worst-fit for small items.
    
    Uses adaptive thresholds with smooth transitions for item-bin synergy and edge robustness.
    
    Args:
        item: Size of the item to be packed.
        bins_remain_cap: Array of remaining capacities for each bin.
        
    Returns:
        Array of same size as bins_remain_cap with priority scores.
    """
    can_fit = bins_remain_cap >= item
    slack = bins_remain_cap - item

    # Threshold (tau) and smoothing window (delta) tuned empirically
    tau = 0.5  # Intermediate-threshold item size split (normalized bin capacity)
    delta = 0.1  # Smooth transition window width
    weight = np.clip((item - (tau - delta)) / (2 * delta), 0.0, 1.0)

    # Hybrid priority: best-fit (min-slack) and worst-fit (max-slack)
    best_prio = -slack  # Best-fit prioritizes smallest slack
    worst_prio = slack  # Worst-fit prioritizes largest slack
    hybrid = best_prio * weight + worst_prio * (1 - weight)

    # Invalid bins receive -inf
    return np.where(can_fit, hybrid, -np.inf)
```
