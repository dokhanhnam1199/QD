```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority scores for bins, combining Best Fit and Worst Fit dynamically.
    
    For large items (relative to remaining capacity), prioritizes minimal slack (Best Fit).
    For small items, prioritizes largest remaining capacity (Worst Fit) to reduce fragmentation.
    Combines both behaviors via a continuous metric without hard thresholds.
    
    Args:
        item: Size of the item to pack (must be <= bin capacity).
        bins_remain_cap: Array of remaining capacities for each bin.
    
    Returns:
        Array of priority scores for each bin (higher = better fit).
    """
    can_fit = bins_remain_cap >= item
    # Calculate adaptive priority: itemÂ² + rem_cap * (1 - 2*item)
    # This creates a continuous balance between BF (min slack) and WF (max slack)
    priority = np.where(
        can_fit,
        item**2 + bins_remain_cap * (1 - 2 * item),
        -np.inf
    )
    return priority
```
