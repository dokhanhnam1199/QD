```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Ranked via size threshold ð›•: large items (ð•© > 0.5) â†’ BF; small items (ð•© â‰¤ 0.5) â†’ 1.5Ã— slack preservation.
    Tie-breaker (ðœ€Â·i) ensures determinism.
    
    Args:
        item: Normalized size (â‰¤1) of the incoming item.
        bins_remain_cap: List of normalized remaining capacities (â‰¤1).
    
    Returns:
        Priorities where higher = better fit. Infeasible bins get -âˆž.
    """
    # Constants
    THRESHOLD = 0.5
    WF_WEIGHT = 1.5  # Increased slack preservation for small items
    EPSILON = 1e-8   # Tie-breaker to ensure deterministic selection

    # Feasibility mask
    can_fit = bins_remain_cap >= item
    
    # Best Fit for large items: minimize slack
    bf_slack = bins_remain_cap - item
    bf_priority = -bf_slack  # Higher = closer to zero slack
    
    # Worst Fit variant for small items: maximize slack weighted by positional tie-breaker
    wf_slack = bins_remain_cap  
    wf_priority = (wf_slack * WF_WEIGHT) + (EPSILON * np.arange(len(wf_slack)))  # Slack prioritization

    # Select strategy based on item size
    priority = np.where(
        can_fit,
        np.where(
            item > THRESHOLD,
            bf_priority,   # High-priority for tight fits (large items)
            wf_priority    # High-priority for slack preservation (small items)
        ),
        -np.inf  # Infeasible bins
    )

    return priority
```
