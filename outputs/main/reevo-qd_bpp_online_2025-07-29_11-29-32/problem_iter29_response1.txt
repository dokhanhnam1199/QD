```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Ranked via size threshold 𝛕: large items (𝕩 > 0.5) → BF; small items (𝕩 ≤ 0.5) → 1.5× slack preservation.
    Tie-breaker (𝜀·i) ensures determinism.
    
    Args:
        item: Normalized size (≤1) of the incoming item.
        bins_remain_cap: List of normalized remaining capacities (≤1).
    
    Returns:
        Priorities where higher = better fit. Infeasible bins get -∞.
    """
    # Constants
    THRESHOLD = 0.5
    WF_WEIGHT = 1.5  # Increased slack preservation for small items
    EPSILON = 1e-8   # Tie-breaker to ensure deterministic selection

    # Feasibility mask
    can_fit = bins_remain_cap >= item
    
    # Best Fit for large items: minimize slack
    bf_slack = bins_remain_cap - item
    bf_priority = -bf_slack  # Higher = closer to zero slack
    
    # Worst Fit variant for small items: maximize slack weighted by positional tie-breaker
    wf_slack = bins_remain_cap  
    wf_priority = (wf_slack * WF_WEIGHT) + (EPSILON * np.arange(len(wf_slack)))  # Slack prioritization

    # Select strategy based on item size
    priority = np.where(
        can_fit,
        np.where(
            item > THRESHOLD,
            bf_priority,   # High-priority for tight fits (large items)
            wf_priority    # High-priority for slack preservation (small items)
        ),
        -np.inf  # Infeasible bins
    )

    return priority
```
