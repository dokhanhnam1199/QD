```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Mutated priority function blending Best/Worst Fit via adaptive thresholds.
    Uses squared-error scoring weighted by item size to balance slack minimization
    and space preservation. Ties broken via epsilon-biased residual ranking."""
    R = bins_remain_cap - item
    can_fit = bins_remain_cap >= item
    
    # Dynamic weight based on item size relative to bin capacity (assumed normalized to 1.0)
    weight = 1.0 - 2.0 * item  # Threshold at 0.5 for adaptive switching
    
    # Squared-error scoring of residual space
    R_squared = R * R
    
    # Epsilon-bias for deterministic tie-breaking using residual capacity
    epsilon = 1e-7
    tie_breaker = -epsilon * R  # Prioritize smaller residual when tied
    
    # Blend slack minimization (Best Fit) and space preservation (Worst Fit) using dynamic weight
    # Positive weight favors larger R (space preservation), negative favors smaller R (slack minimization)
    priority = np.where(can_fit, weight * R_squared + tie_breaker, -np.inf)
    
    return priority
```
