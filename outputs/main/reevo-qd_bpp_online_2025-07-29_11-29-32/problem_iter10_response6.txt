```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority scores combining Best Fit/Worst Fit with tie-breaking by bin utilization.
    
    Uses adaptive weights for Best/Worst Fit blending based on item size. For tie-breaking,
    bins with higher current utilization (filled space) are prioritized. Invalid bins are penalized.
    
    Args:
        item: Size of item to be packed (0 < item <= 1).
        bins_remain_cap: Array of remaining capacities for each bin (0 <= capacity <= 1).
    
    Returns:
        Array of priority scores for each bin.
    """
    can_fit = bins_remain_cap >= item
    residual = bins_remain_cap - item
    filled = 1.0 - bins_remain_cap  # Current utilization of each bin
    
    # Blend Best Fit (-residual) and Worst Fit (residual) based on item size
    weight = 1.0 - 2.0 * item  # Dynamic weight: favors Best Fit for item > 0.5, Worst Fit for item < 0.5
    priority = residual * weight
    
    # Tie-breaker: prioritize bins with higher utilization using a small epsilon
    TIE_BREAKER = 1e-8  # Minimal adjustment to avoid altering main priority logic
    priority += TIE_BREAKER * filled
    
    # Mask invalid bins (those without sufficient capacity)
    return np.where(can_fit, priority, -np.inf)
```
