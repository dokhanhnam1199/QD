```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Improved priority function combining best-fit/worst-fit balance with perfect-fit preference.
    
    Features:
    - Dynamic weight adjustment like v1 (best-fit for large items, worst-fit for small items)
    - Major priority bonus for perfect fits (zero residual after placement)
    - Tie-breaker for floating point precision issues
    - Maintains constraint-aware scoring via -âˆž penalties for invalid bins
    
    Args:
        item: Size of item to be added to the bin (0 < item <= 1).
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Ensure compatibility with item sizes
    can_fit = bins_remain_cap >= item
    
    # Calculate residuals and dynamic weight
    residual = bins_remain_cap - item
    weight = 1 - 2 * item
    
    # Base priority is weight-adjusted residual (best-fit/worst-fit hybrid)
    base_priority = np.where(can_fit, weight * residual, -np.inf)
    
    # Perfect-fit bonus (+1e6) to prioritize bins with zero residual
    perfect_fit = np.isclose(residual, 0.0) & can_fit
    bonus_priority = np.where(perfect_fit, base_priority + 1e6, base_priority)
    
    # Optional tie-breaker for floating-point precision (1e-8 favors bins with lower remaining capacity)
    tie_breaker = 1e-8 * (2 * float(weight < 0) - 1) * bins_remain_cap
    
    # Final priority with tie-breaker applied
    final_priority = np.where(can_fit, bonus_priority + tie_breaker, -np.inf)
    
    return final_priority
```
