```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority scores blending Best Fit and Worst Fit heuristics with dynamic weights.
    
    Combines BF (prioritizes tight fits for large items) and WF (preserves larger gaps for small items)
        based on item size relative to bin capacity. Weights are dynamic and epsilon tie-breaking
        ensures deterministic tie resolution.
    
    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.
    
    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    n = len(bins_remain_cap)
    if n == 0:
        return np.array([])  # Handle empty bin list

    C = bins_remain_cap.max()  # Full bin capacity inferred
    can_fit = bins_remain_cap >= item

    # Dynamic weight based on item size relative to bin capacity
    alpha = item / C  
    delta = bins_remain_cap - item  # Slack if placed

    # Epsilon tie-breaking term
    indices = np.arange(n)
    epsilon = 1e-6
    
    priority = np.where(
        can_fit,
        alpha * (-delta) + (1 - alpha) * bins_remain_cap - epsilon * indices,  # BF-WF blend
        -np.inf
    )
    return priority
```
