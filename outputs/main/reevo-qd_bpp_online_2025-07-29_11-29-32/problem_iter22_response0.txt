```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Improved priority function using threshold-based blending of BF/WF strategies with capacity normalization."""
    if bins_remain_cap.size == 0:
        return np.array([])  # Handle empty bins case gracefully
    
    C = np.max(bins_remain_cap)  # Infer bin capacity from remaining capacities
    THRESHOLD = 0.5 * C
    DELTA = 0.1 * C
    
    can_fit = bins_remain_cap >= item
    slack = bins_remain_cap - item
    
    # Determine weights based on item size relative to bin capacity
    if item <= THRESHOLD - DELTA:
        w_bf, w_wf = 0.0, 1.0  # WF dominant for small items
    elif item >= THRESHOLD + DELTA:
        w_bf, w_wf = 1.0, 0.0  # BF dominant for large items
    else:
        # Linear blend in transition zone
        t = (item - (THRESHOLD - DELTA)) / (2 * DELTA)
        w_bf, w_wf = t, 1 - t
    
    # Component scores
    bf_component = -slack  # Minimize slack (Best Fit)
    wf_component = bins_remain_cap  # Maximize remaining capacity (Worst Fit)
    
    # Composite priority blend
    composite = w_bf * bf_component + w_wf * wf_component
    
    # Mask infeasible bins and return
    return np.where(can_fit, composite, -np.inf)
```
