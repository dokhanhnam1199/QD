```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority scores for bins based on adaptive blend of Best/Worst Fit.

    Bins that can fit the item are prioritized by dynamically balancing slack minimization
    (larger items) and space preservation (smaller items), resolved with residual-tied Îµ-bias.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Returns:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    can_fit = bins_remain_cap >= item
    residual = bins_remain_cap - item

    # Dynamic weight: stronger Best-Fit emphasis as item size approaches bin capacity
    alpha = item  # Assuming fixed bin capacity of 1.0

    # Main priority: blend BF (negative residual) and WF (preserve space)
    main_priority = np.where(
        can_fit,
        alpha * (-residual) + (1 - alpha) * bins_remain_cap,
        -np.inf
    )

    # Tie-breaker: penalize larger residuals with eps precision
    epsilon = 1e-8
    tie_breaker = -epsilon * residual
    priority = main_priority + tie_breaker

    return priority
```
