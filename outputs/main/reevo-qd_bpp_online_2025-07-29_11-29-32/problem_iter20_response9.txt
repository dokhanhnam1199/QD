```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Adaptive priority combining Best/Worst Fit using item size, with tie-breaking noise.
    
    Args:
        item: Size of the item to pack
        bins_remain_cap: Array of remaining capacities for each bin
    
    Returns:
        Array of priority scores where higher = better. -inf for infeasible bins.
    """
    EPSILON = 1e-9
    
    if bins_remain_cap.size == 0:
        # Handle empty bins gracefully to trigger new bin creation
        return np.array([])
    
    # Feasibility mask and residual space calculation
    can_fit = bins_remain_cap >= item
    residual = bins_remain_cap - item
    
    # Linear blend of Best Fit (-residual) and Worst Fit (residual) using item size
    priority = np.where(can_fit, residual * (1 - 2 * item), -np.inf)
    
    # Add infinitesimal noise for fair tie-breaking (especially for edge cases)
    priority += EPSILON * np.random.randn(*priority.shape)
    
    return priority
```
