```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns blended Best/Worst Fit priority scores with smooth transitions and tie-breaking.
    
    Large items (relative to bin capacity) use Best Fit minimization of residual space,
    small items use Worst Fit maximization of residual space. Blend factor interpolates
    between strategies based on normalized item size.
    
    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.
    
    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Avoid division by zero in C estimation using small epsilon
    C = bins_remain_cap.max() if bins_remain_cap.size > 0 else item
    epsilon = 1e-6  # For numerical stability and tie-breaking
    
    # Blend factor: item size normalized to bin capacity
    blend_factor = item / (C + 1e-9)
    
    # Compute residual capacity and feasibility mask
    residual = bins_remain_cap - item
    can_fit = residual >= 0
    
    # Blended priority with tie-breaking epsilon
    priority = (1 - 2 * blend_factor - epsilon) * residual
    
    return np.where(can_fit, priority, -np.inf)
```
