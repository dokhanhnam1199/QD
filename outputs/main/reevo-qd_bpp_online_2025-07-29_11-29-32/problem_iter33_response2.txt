```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns adaptive priority scores for bins using blended heuristics with squared error weighting.
    
    Adapts blending between Best Fit (slack minimization) and Worst Fit (flexibility) based on item size.
    Valid bins receive priority scores; infeasible bins receive -inf. Dynamic thresholds balance synergy.
    
    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of current remaining capacities for each bin.
    
    Return:
        Array of priority scores where higher values indicate better bin choices.
    """
    # Blend control parameters
    SMALL_ITEM_THRESHOLD = 0.25  # Below this, pure worst fit
    LARGE_ITEM_THRESHOLD = 0.5   # Above this, pure best fit
    # Linear blend region between thresholds
    weight = np.clip((item - SMALL_ITEM_THRESHOLD) / (LARGE_ITEM_THRESHOLD - SMALL_ITEM_THRESHOLD), 0, 1)
    
    can_fit = bins_remain_cap >= item
    residual = bins_remain_cap - item
    
    # Best Fit: Minimize residual (slack) using squared error weighting
    best_fit_score = -(residual ** 2)  # Higher = smaller residual
    # Worst Fit: Maximize residual using squared error weighting
    worst_fit_score = (residual ** 2)  # Higher = larger residual
    
    # Adaptive blend of heuristics based on item size
    blended_score = weight * best_fit_score + (1 - weight) * worst_fit_score
    
    # Enforce feasibility constraints
    priority = np.where(can_fit, blended_score, -np.inf)
    return priority
```
