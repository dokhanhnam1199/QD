```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority scores using adaptive strategy based on item size relative to median remaining capacity.
    
    Switches between Best Fit (minimize slack) and Worst Fit (preserve largest spaces) dynamically,
    using the median remaining capacity of feasible bins as a context-aware threshold.
    """
    can_fit = bins_remain_cap >= item
    feasible_bins = bins_remain_cap[can_fit]
    
    if not feasible_bins.size:
        return np.full_like(bins_remain_cap, -np.inf)
    
    # Use median of feasible bins as adaptive threshold
    threshold = np.median(feasible_bins)
    
    if item > threshold:
        # Prioritize Best Fit: minimize remaining capacity after placement
        priority = - (bins_remain_cap - item)
    else:
        # Prioritize Worst Fit: preserve largest remaining capacities
        priority = bins_remain_cap.copy()
    
    return np.where(can_fit, priority, -np.inf)
```
