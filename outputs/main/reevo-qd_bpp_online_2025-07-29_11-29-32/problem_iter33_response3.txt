```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns adaptive priority scores combining Best/Worst Fit with dynamic weighting.
    
    Handles large items by minimizing slack with squared penalty (best fit).
    Scales flexibility for small items via remaining capacity maximization (worst fit).
    Weights adapt to item size relative to bin capacity ('C' normalized to 1.0).
    Invalid bins receive -inf priority.
    
    Args:
        item: Size of item to be packed.
        bins_remain_cap: Remaining capacities of bins.
    
    Returns:
        Priority scores per bin.
    """
    can_fit = bins_remain_cap >= item
    C = 1.0  # Assuming bins have normalized capacity [0,1]
    
    # Adaptive weight from item size (larger=best, smaller=worst)
    alpha = item / C  # Dynamic scaling factor
    
    # Best Fit component (squared slack penalty)
    best_component = -(bins_remain_cap - item) ** 2
    
    # Worst Fit component (remaining capacity exploitation)
    worst_component = bins_remain_cap
    
    # Adaptive convex combination
    priority = alpha * best_component + (1 - alpha) * worst_component
    
    # Mask infeasible bins
    priority = np.where(can_fit, priority, -np.inf)
    
    return priority
```
