```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority scores for bins by blending Best/Worst Fit heuristics based on item size.
    
    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.
    
    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    can_fit = bins_remain_cap >= item
    threshold = 0.5
    residual = bins_remain_cap - item
    
    # Calculate blending factor for Best/Worst Fit contribution
    blend_factor = np.where(item > threshold, 1.0, item / threshold)
    
    # Dynamic priority combining Best Fit (minimize residual) and Worst Fit (preserve capacity)
    # Coefficient (1-2*blend_factor) ensures smooth transition:
    # - Positive for small items (Worst Fit), increasing residual prioritization
    # - Negative for large items (Best Fit), minimizing residual
    priority = (1 - 2 * blend_factor) * residual
    
    # Apply -inf to bins that cannot fit the item
    final_priority = np.where(can_fit, priority, -np.inf)
    return final_priority
```
