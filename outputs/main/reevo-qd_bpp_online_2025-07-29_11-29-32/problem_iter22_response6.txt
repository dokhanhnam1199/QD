```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority scores blending normalized BF and WF strategies with adaptive weights."""
    THRESHOLD = 0.5
    DELTA = 0.1
    epsilon = 1e-9

    can_fit = bins_remain_cap >= item
    slack = bins_remain_cap - item

    # BF component: -slack (higher is better)
    # WF component: remain_cap (higher is better)
    bf_component = -slack
    wf_component = bins_remain_cap

    # Compute min and max for BF and WF components among feasible bins
    masked_bf = np.where(can_fit, bf_component, np.inf)
    masked_wf = np.where(can_fit, wf_component, -np.inf)
    bf_min = np.min(masked_bf)
    bf_max = np.max(masked_bf)
    wf_min = np.min(masked_wf)
    wf_max = np.max(masked_wf)

    # Handle division by zero and ranges
    bf_range = bf_max - bf_min + epsilon
    wf_range = wf_max - wf_min + epsilon

    # Normalize components to [0,1] based on feasible bins' statistics
    normalized_bf = (bf_component - bf_min) / bf_range
    normalized_wf = (wf_component - wf_min) / wf_range

    # Blend weights based on item size
    if item <= THRESHOLD - DELTA:
        w_bf, w_wf = 0.0, 1.0
    elif item >= THRESHOLD + DELTA:
        w_bf, w_wf = 1.0, 0.0
    else:
        t = (item - (THRESHOLD - DELTA)) / (2 * DELTA)
        w_bf, w_wf = t, 1 - t

    # Composite priority blend
    composite = w_bf * normalized_bf + w_wf * normalized_wf

    # Mask infeasible bins
    priority = np.where(can_fit, composite, -np.inf)
    return priority
```
