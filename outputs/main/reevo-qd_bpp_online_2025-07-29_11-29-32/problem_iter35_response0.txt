```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Priority combining slack minimization (Best Fit) and space preservation (Worst Fit) with dynamic weights."""
    can_fit = bins_remain_cap >= item
    # Estimate bin capacity as max remaining capacity seen (assumes at least one bin is empty or conservative)
    C = np.max(bins_remain_cap) if len(bins_remain_cap) > 0 else item
    alpha = item / C  # Dynamic weight based on item size relative to bin capacity
    coeff = 1.0 - 2 * alpha  # Adaptive threshold: balances Best/Worst Fit
    epsilon = 1e-6  # Deterministic tie-breaker favoring larger residual capacity
    # Combine components: coeff controls direction; epsilon ensures tie-breaker
    priority = coeff * bins_remain_cap + epsilon * bins_remain_cap
    # Mask infeasible bins and return
    return np.where(can_fit, priority, -np.inf)
```
