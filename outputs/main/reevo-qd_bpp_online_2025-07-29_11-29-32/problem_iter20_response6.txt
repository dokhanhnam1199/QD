```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Hybrid priority combining size-weighted Best Fit and Worst Fit with dynamic interpolation.
    
    For each bin, balance between minimizing slack (Best Fit) and maximizing remaining capacity (Worst Fit)
    based on item size. Larger items prioritize slack minimization through higher weight on Best Fit,
    while smaller items prioritize filling bins with more free space to preserve room for larger items.
    """
    can_fit = bins_remain_cap >= item
    slack = bins_remain_cap - item
    
    # Dynamic weight factors
    w_best = item   # Weight for slack minimization (Best Fit)
    w_worst = 1.0 - item  # Weight for remaining capacity prioritization (Worst Fit)
    
    # Component priority scores
    best_fit_score = -slack  # We minimize slack (maximize negative slack)
    worst_fit_score = bins_remain_cap  # We maximize remaining capacity
    
    # Combined priority with size-weighted interpolation
    priority = w_best * best_fit_score + w_worst * worst_fit_score
    
    # Filter infeasible bins and return
    return np.where(can_fit, priority, -np.inf)
```
