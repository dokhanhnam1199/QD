```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority scores blending BF/WF heuristics with adaptive thresholds.
    
    Prioritizes bins with smooth transitions between BF (for large item fractions) 
    and WF (for small item fractions), with tie-breaking epsilon.
    
    Args:
        item: Size of item to be added.
        bins_remain_cap: Array of capacities remaining for each bin.
        
    Returns:
        Array of priority scores for each bin.
    """
    # Check which bins can fit the item
    can_fit = bins_remain_cap >= item
    
    # Compute leftover capacity and item ratio for eligible bins
    leftover = bins_remain_cap - item
    with np.errstate(divide='ignore', invalid='ignore'):
        ratio = np.where(can_fit, item / bins_remain_cap, 0.0)
    
    # Hybrid BF/WF priority with smooth transition at 50% ratio
    raw_priority = (1.0 - 2.0 * ratio) * leftover
    
    # Tie-breaking: subtle penalty by bin index (lower indices preferred)
    indices = np.arange(len(bins_remain_cap))
    adjusted_priority = raw_priority - indices * 1e-9
    
    # Mask infeasible bins and return
    return np.where(can_fit, adjusted_priority, -np.inf)
```
