```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Improved priority function blending Best Fit (BF) and Worst Fit (WF) with normalized components.
    
    For each item, prioritizes bins based on:
    - BF heuristic for large items (tight packing)
    - WF heuristic for small items (space preservation)
    - Smooth linear interpolation in transition zone using normalized component scores
    """
    THRESHOLD = 0.5
    DELTA = 0.1  # Transition zone width

    can_fit = bins_remain_cap >= item
    feasible_mask = can_fit & (bins_remain_cap > 0)  # Avoid divide-by-zero in BF component

    # Blend weights: linearly interpolate between BF and WF around threshold
    if item <= THRESHOLD - DELTA:
        w_bf, w_wf = 0.0, 1.0  # WF dominant for small items
    elif item >= THRESHOLD + DELTA:
        w_bf, w_wf = 1.0, 0.0  # BF dominant for large items
    else:
        # Linear blend between BF and WF in threshold region
        t = (item - (THRESHOLD - DELTA)) / (2 * DELTA)
        w_bf, w_wf = t, 1 - t

    # Normalized Best Fit component: item / bins_remain_cap (higher means tighter fit)
    with np.errstate(divide='ignore', invalid='ignore'):
        bf_component = np.where(feasible_mask, item / bins_remain_cap, -np.inf)

    # Worst Fit component: bins_remain_cap (larger values preferred)
    wf_component = bins_remain_cap

    # Composite score: weighted blend of normalized components
    composite = w_bf * bf_component + w_wf * wf_component

    # Mask infeasible bins and return
    priority = np.where(can_fit, composite, -np.inf)
    return priority
```
