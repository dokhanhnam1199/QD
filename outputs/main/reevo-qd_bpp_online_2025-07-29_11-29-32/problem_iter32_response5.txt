```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Returns priority with which we want to pack the item into each bin.
    
    For large items (> 0.5): Best Fit + deterministic tie-breaker (prioritize lower index).
    For small items (≤ 0.5): Slack preservation × 1.5 + deterministic tie-breaker.
    
    Args:
        item: Normalized size (≤ 1) of the incoming item.
        bins_remain_cap: Array of normalized remaining capacities (≤ 1).
    
    Returns:
        Array of same size as bins_remain_cap with priority score of each bin.
        Feasible bins have finite scores, infeasible bins get -∞.
    """
    THRESHOLD = 0.5
    WF_WEIGHT = 1.5  # Slack preservation weight for small items
    EPSILON = 1e-8   # Tie-breaker for deterministic selection

    # Feasibility mask
    can_fit = bins_remain_cap >= item

    # Best Fit for large items: minimize slack with deterministic tie-breaker
    bf_slack = bins_remain_cap - item
    bf_penalty = EPSILON * np.arange(len(bf_slack))  # Tie-breaker: lower index = better
    bf_priority = -bf_slack - bf_penalty  # -slack ensures lower slack => higher priority

    # Slack preservation for small items with deterministic tie-breaker
    wf_priority = bins_remain_cap * WF_WEIGHT + EPSILON * np.arange(len(bins_remain_cap))

    # Combine strategies using item size threshold
    priority = np.where(
        can_fit,
        np.where(
            item > THRESHOLD,
            bf_priority,   # Large items - prioritize tight fits (BF)
            wf_priority    # Small items - prioritize slack preservation
        ),
        -np.inf  # Infeasible bins (discard them)
    )

    return priority
```
