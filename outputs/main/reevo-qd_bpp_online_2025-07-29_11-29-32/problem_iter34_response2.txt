```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which to select a bin for packing the item.

    Implements threshold adjustment (item >= 0.5 → Best Fit) and adaptive slack preservation,
    with tie-breakers for determinism.
    
    Args:
        item: Normalized size (≤1) of the incoming item.
        bins_remain_cap: List of normalized remaining capacities (≤1).
    
    Returns:
        Priorities where higher = better fit. Infeasible bins get -∞.
    """
    # Constants
    THRESHOLD = 0.5        # Dynamic threshold adjustment (item >= THRESHOLD uses Best Fit)
    EPSILON = 1e-8         # Tie-breaker to ensure deterministic selection

    # Feasibility mask
    can_fit = bins_remain_cap >= item
    
    # Best Fit (minimize slack) for large items (>=0.5)
    bf_slack = bins_remain_cap - item
    bf_priority = -bf_slack  # Higher = closer to zero slack
    
    # Improved slack preservation with item-size-dependent weight
    weight = 2.0 - item  # Weight decreases with increasing item size
    wf_priority = (bins_remain_cap * weight) + (EPSILON * np.arange(len(bins_remain_cap)))

    # Select strategy based on item size (adjusted threshold)
    priority = np.where(
        can_fit,
        np.where(
            item >= THRESHOLD,
            bf_priority,   # Best Fit for large items
            wf_priority    # Adaptive slack preservation for small items
        ),
        -np.inf  # Infeasible bins
    )
    
    return priority
```
