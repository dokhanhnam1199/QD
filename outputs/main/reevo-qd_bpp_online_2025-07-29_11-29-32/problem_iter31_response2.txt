```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority scores blending best-fit (for large items) and worst-fit (for small items) heuristics."""
    can_fit = bins_remain_cap >= item
    if not bins_remain_cap.size:
        return np.full_like(can_fit, -np.inf, dtype=np.float64)
    
    # Adaptive threshold: mean of current bin capacities (balances tight-fit vs slack preservation)
    theta = np.mean(bins_remain_cap)
    
    # Best-fit priority: minimize slack after placement (-slack, higher is better)
    best_priority = -(bins_remain_cap - item)
    # Worst-fit priority: preserve slack (higher remaining capacity is better)
    worst_priority = bins_remain_cap
    
    # Blend strategies using vectorized thresholding (item size vs theta)
    priority = np.where(
        item > theta,
        # Prioritize best-fit for large items
        np.where(can_fit, best_priority, -np.inf),
        # Prioritize worst-fit for small items
        np.where(can_fit, worst_priority, -np.inf)
    )
    
    return priority
```
