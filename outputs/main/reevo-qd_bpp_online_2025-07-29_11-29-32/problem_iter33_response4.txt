```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority scores for bins that blend Best/Worst Fit heuristics with adaptive thresholds.
    
    For large items, prioritizes bins with minimal residual space after placement using squared error
    weighting (Best Fit). For small items, prioritizes bins with maximal residual space using squared 
    error weighting (Worst Fit). Smoothly interpolates between regimes using item size normalization.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Compute feasibility mask
    can_fit = bins_remain_cap >= item
    
    # Compute residuals for bins that can fit the item
    feasible_resid = bins_remain_cap - item
    
    # Blending weight based on item size normalization (assuming bin capacity ~ 1.0)
    weight = 1.0 - 2.0 * item  # Positive for small items (prioritize residual), negative for large
    
    # Prioritize residual space exploitation with squared error weighting
    priority = weight * (feasible_resid ** 2)
    
    # Apply mask: infeasible bins have -inf, can_fit bins have computed priority
    masked_priority = np.where(can_fit, priority, -np.inf)
    
    return masked_priority
```
