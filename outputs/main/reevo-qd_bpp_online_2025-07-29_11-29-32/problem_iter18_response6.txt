```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    EPSILON = 1e-9
    weight_bias = 1e-6
    
    if bins_remain_cap.size == 0:
        return np.array([])
    
    # Infer bin capacity from maximum remaining capacity (handles scaling)
    C = np.max(bins_remain_cap)
    
    # Handle fully packed bins edge case
    if C < EPSILON:
        return np.zeros_like(bins_remain_cap, dtype=np.float64) if item < EPSILON else np.full_like(bins_remain_cap, -np.inf)

    # Normalize all calculations to [0,1] range for capacity-invariant behavior
    scaled_item = item / C
    can_fit = bins_remain_cap >= item - EPSILON
    
    # Dynamic weight blending best-fit (negative) and worst-fit (positive) based on normalized item size
    weight = (1.0 - 2.0 * scaled_item) - weight_bias
    
    # Calculate residual space and prioritize perfect fits
    residual = bins_remain_cap - item
    priority = residual * weight
    
    # Optional bonus for perfect fits (implicitly preferred via weight inversion logic)
    priority += -EPSILON * np.where(np.abs(residual) < EPSILON, 1.0, 0.0)
    
    return np.where(can_fit, priority, -np.inf)
```
