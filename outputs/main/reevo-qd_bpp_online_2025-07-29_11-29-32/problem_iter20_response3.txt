```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Improved priority function blending Best Fit (BF) and Worst Fit (WF) strategies with adaptive weights.
    
    For items larger than THRESHOLD + DELTA, prioritize BF (minimize slack). For items smaller than 
    THRESHOLD - DELTA, prioritize WF (maximize remaining capacity). Blend linearly in the transition zone.
    """
    THRESHOLD = 0.5
    DELTA = 0.1
    
    # Check if any bins are available
    if bins_remain_cap.size == 0:
        return np.array([])
    
    # Determine feasibility and slack
    can_fit = bins_remain_cap >= item
    slack = bins_remain_cap - item
    
    # Calculate blending weights based on item size
    if item <= THRESHOLD - DELTA:
        w_bf, w_wf = 0.0, 1.0  # Pure WF for small items
    elif item >= THRESHOLD + DELTA:
        w_bf, w_wf = 1.0, 0.0  # Pure BF for large items
    else:
        # Linear blend in transition region
        t = (item - (THRESHOLD - DELTA)) / (2 * DELTA)
        w_bf, w_wf = t, 1 - t
    
    # Simple component calculations
    bf_component = -slack       # BF component: minimize slack
    wf_component = bins_remain_cap  # WF component: maximize remaining capacity
    
    # Composite priority blending
    composite = w_bf * bf_component + w_wf * wf_component
    
    # Masks to ensure only valid bins are considered
    priority = np.where(can_fit, composite, -np.inf)
    
    # Tie-breaking random perturbation
    priority += np.random.rand(*priority.shape) * 1e-9
    
    return priority
```
