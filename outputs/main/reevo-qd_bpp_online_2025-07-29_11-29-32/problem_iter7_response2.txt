```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority scores blending best-fit/worst-fit heuristics using adaptive item-size-aware weighting.
    
    For each bin:
    - Small items (low item/rc ratio): prioritize worst-fit (max residual space)
    - Large items (high item/rc ratio): prioritize best-fit (min slack)
    - Dynamic transition via continuous ratio-based weighting (no fixed thresholds)
    
    Args:
        item: Size of item to be packed
        bins_remain_cap: Array of current remaining capacities for each bin
    
    Returns:
        Array of priority scores for each bin
    """
    can_fit = bins_remain_cap >= item
    
    # Avoid division by zero in non-feasible bins (safe due to can_fit mask)
    with np.errstate(divide='ignore', invalid='ignore'):
        w = np.where(can_fit, item / bins_remain_cap, 0)
    
    # Adaptive priority combining best-fit/worst-fit via continuous weighting
    slack = bins_remain_cap - item
    priority = (1 - 2 * w) * slack
    
    # Penalize infeasible bins with -inf
    return np.where(can_fit, priority, -np.inf)
```
