```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority scores blending best-fit/worst-fit with item-size-dependent weight via smooth transition.
    
    Smoothly interpolates between best-fit and worst-fit strategies using a hyperbolic tangent function centered at item_size=0.5. 
    The smoothness factor 'k' ensures gradual strategy shifts to avoid abrupt decisions near critical threshold while preserving 
    numerical stability through epsilon bias. Weight remains adaptive to both small and large items while balancing capacity use.
    
    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.
    
    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    can_fit = bins_remain_cap >= item
    residual = bins_remain_cap - item

    # Smooth transition weight using tanh centered at 0.5, k controls smoothness
    k = 10.0  
    weight = np.tanh((0.5 - item) * k) - 1e-6  # Bias ensures best-fit for 0.5-sized items

    priority = np.where(can_fit, residual * weight, -np.inf)
    return priority
```
