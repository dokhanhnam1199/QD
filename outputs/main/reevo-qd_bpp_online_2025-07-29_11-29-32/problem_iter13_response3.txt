```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Priority function v2 implementing adaptive bin selection with quadratic penalties."""
    EPSILON = 1e-9
    if bins_remain_cap.size == 0:
        return np.array([])  # Handle empty bins case gracefully

    # Infer bin capacity from max remaining capacity
    C = np.max(bins_remain_cap)
    
    # Handle edge cases where all bins are full but item is zero
    if C < EPSILON and item < EPSILON:
        return np.zeros_like(bins_remain_cap, dtype=np.float64)
    if C < EPSILON:
        C = 1.0  # Fallback normalization value
    
    # Adaptive blending weights based on item-capacity ratio
    item_ratio = item / C
    weight = item_ratio ** 1.5  # Polynomial expression for adaptive strategy
    
    # Feasibility filter and residual computation
    can_fit = bins_remain_cap >= item
    residual = bins_remain_cap - item
    
    # Best Fit component: quadratic penalty for residual space
    bf_component = -(residual ** 2)  # Stronger penalty for leftover space
    
    # Worst Fit component: slack normalization with epsilon-stabilized weights
    normalized_slack = residual / (bins_remain_cap + EPSILON)
    wf_component = normalized_slack * item_ratio  # Size-adjusted slack valuation
    
    # Non-linear residual tuning with deviation minimization
    ideal_residual = C * np.sqrt(item_ratio)  # Math-guided target
    deviation = residual - ideal_residual
    deviation_penalty = (deviation ** 2) / (item + EPSILON)
    
    # Final priority calculation with adaptive blending and math-optimized terms
    priority = (weight * bf_component) + ((1 - weight) * wf_component) - deviation_penalty
    
    # Epsilon stabilization for smooth transitions
    priority += EPSILON * np.random.rand(*priority.shape)
    
    # Mask infeasible bins and return
    return np.where(can_fit, priority, -np.inf)
```
