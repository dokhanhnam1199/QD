```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Adaptive priority combining best-fit and worst-fit based on item size and dynamic thresholds.
    
    Uses best-fit for:
    - Large items (>= 0.5)       : Minimize fragmentation.
    - Items > avg_remaining     : Pack "heavy" items tightly.
    Uses worst-fit for small  items: Preserve larger spaces.
    """
    can_fit = bins_remain_cap >= item
    residual = bins_remain_cap - item

    if not np.any(can_fit):
        return np.full_like(bins_remain_cap, -np.inf)

    # Dynamic threshold based on average remaining capacity
    avg_remaining = np.mean(bins_remain_cap) if len(bins_remain_cap) > 0 else 0.5

    if item >= 0.5:
        priority = -residual  # Best-fit: minimize residual
    elif item > avg_remaining:
        priority = -residual  # Best-fit for items larger than avg_remaining
    else:
        priority = residual   # Worst-fit: maximize residual

    return np.where(can_fit, priority, -np.inf)
```
