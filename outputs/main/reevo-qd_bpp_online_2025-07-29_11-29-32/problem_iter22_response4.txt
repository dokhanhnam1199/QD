```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Priority function blending Best Fit and Worst Fit heuristics with item-size thresholds.
    
    Uses Best Fit for items larger than 1/3 (minimizing residual space) and Worst Fit for
    items smaller than or equal to 1/3 (maximizing residual space to preserve larger gaps).
    Tie-breaking prefers tighter fits via epsilon regularization.
    
    Args:
        item: Size of item to be added.
        bins_remain_cap: Array of remaining capacities for each bin.
    
    Returns:
        Array of priority scores for each bin.
    """
    can_fit = bins_remain_cap >= item
    residual = bins_remain_cap - item
    
    # Epsilon term to bias toward smaller residuals in tie-breaking
    epsilon_term = -residual * 1e-6
    
    # Main priority based on item size thresholds
    if item > 0.5:
        priority = -residual  # Best Fit for large items
    elif item > 1.0 / 3.0:
        priority = -residual  # Best Fit for medium items
    else:
        priority = residual   # Worst Fit for small items
    
    # Apply tie-breaking and mask invalid bins
    total_priority = priority + epsilon_term
    return np.where(can_fit, total_priority, -np.inf)
```
