```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority scores for bins blending Best Fit and Worst Fit heuristics.
    
    For large items, prioritizes minimizing residual space (Best Fit).
    For small items, prioritizes preserving capacity for future items (Worst Fit).
    Computed via linear blending based on item size, with tie-breaking epsilon.
    
    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.
    
    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    can_fit = bins_remain_cap >= item
    # Epsilon tie-breaker leans toward Best Fit's residual minimization
    alpha = item  # Blending factor: increases with item size
    best_component = item - bins_remain_cap  # -(residual space) equivalent
    blended = alpha * best_component + (1 - alpha) * bins_remain_cap
    blended += 1e-6 * best_component  # Tie-breaking epsilon as small adjustment
    return np.where(can_fit, blended, -np.inf)
```
