```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Adaptive priority blending Best Fit and Worst Fit based on item size relative to current mean capacity."""
    can_fit = bins_remain_cap >= item
    
    if not np.any(can_fit):
        return np.full_like(bins_remain_cap, -np.inf)
    
    # Adaptive threshold: mean of available bin capacities
    applicable_caps = bins_remain_cap[can_fit]
    threshold = applicable_caps.mean() if applicable_caps.size > 0 else 0.5  # Fallback if empty
    
    # Best Fit and Worst Fit priorities
    best_priority = -(bins_remain_cap - item)  # Minimize remaining space
    worst_priority = bins_remain_cap          # Maximize remaining space before placement
    
    # Smooth sigmoid blending weight based on item size vs threshold
    weight = 1.0 / (1.0 + np.exp(-(item - threshold)))
    
    # Combine strategies with item-size-weighted adaptive blend
    blended_priority = weight * best_priority + (1 - weight) * worst_priority
    
    return np.where(can_fit, blended_priority, -np.inf)
```
