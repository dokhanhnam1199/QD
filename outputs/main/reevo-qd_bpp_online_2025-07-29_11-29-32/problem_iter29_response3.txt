```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Blends Best Fit and Worst Fit heuristics with adaptive thresholds for robust packing.
    
    Criteria:
    - Large items (>50% of peak rem. cap) prioritize BF to minimize slack.
    - Small items use Worst Fit to preserve larger gaps for future items.
    - Handles edge cases (e.g., max rem. cap = 0) and includes tie-breaking.
    
    Args:
        item: Float item size in (0, 1].
        bins_remain_cap: Array of current bin capacities.
    
    Returns:
        Array of logit scores for bin selection.
    """
    if not len(bins_remain_cap):
        return np.array([])
        
    can_fit = bins_remain_cap >= item
    C = np.max(bins_remain_cap) if len(bins_remain_cap) else 0.0
    threshold = 0.5 * max(C, item)  # Prevents unbounded scaling
    is_large = item > threshold
    
    # Primary heuristic logic
    if is_large:
        score = -(bins_remain_cap - item)
    else:
        score = bins_remain_cap * (1 + 1e-5)  # Tie-breaker bias
    
    # Tie-breaking by bin index for stability
    tiebreaker = np.random.uniform(1e-9, 1e-8, len(bins_remain_cap))
    score += tiebreaker
    
    # Mask invalid options
    return np.where(can_fit, score, -np.inf)
```
