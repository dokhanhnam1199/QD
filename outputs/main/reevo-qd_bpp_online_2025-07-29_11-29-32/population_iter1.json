[
  {
    "stdout_filepath": "problem_iter0_stdout0.txt",
    "code_path": "problem_iter0_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    return np.zeros_like(bins_remain_cap)",
    "response_id": 0,
    "obj": 4.487435181491823,
    "SLOC": 2.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response0.txt_stdout.txt",
    "code_path": "problem_iter1_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority scores for bins based on Best Fit heuristic.\n\n    Bins that can fit the item are prioritized by smallest remaining capacity after placement.\n    Infeasible bins receive -inf priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    can_fit = bins_remain_cap >= item\n    priority = np.where(can_fit, -(bins_remain_cap - item), -np.inf)\n    return priority",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response1.txt_stdout.txt",
    "code_path": "problem_iter1_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Priority function that uses Best Fit for large items (> 0.5) and Worst Fit for small items (<= 0.5).\"\"\"\n    mask = bins_remain_cap >= item\n    priority = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)\n    \n    if item > 0.5:\n        # Best Fit: prioritize bins where item fits tightly (item - remaining_cap)\n        priority[mask] = item - bins_remain_cap[mask]\n    else:\n        # Worst Fit: prioritize bins with largest remaining capacity\n        priority[mask] = bins_remain_cap[mask]\n    \n    return priority",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response2.txt_stdout.txt",
    "code_path": "problem_iter1_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority scores for bins using a Best Fit heuristic.\n    \n    The priority for each bin is the negative of its remaining capacity after placing\n    the item, if it fits. This encourages selecting bins that minimize leftover space.\n    Bins that cannot fit the item are assigned a very low priority.\n    \"\"\"\n    can_fit = bins_remain_cap >= item\n    return np.where(\n        can_fit,\n        item - bins_remain_cap,  # Equivalent to -(remaining_cap - item)\n        -np.inf\n    )",
    "response_id": 2,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response3.txt_stdout.txt",
    "code_path": "problem_iter1_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate priority as negative of leftover space for bins that can fit the item\n    # and -infinity for bins that cannot fit. This prioritizes bins with smallest\n    # leftover space (Best Fit heuristic).\n    can_fit = bins_remain_cap >= item\n    leftover = bins_remain_cap - item\n    priority = np.where(can_fit, -leftover, -np.inf)\n    return priority",
    "response_id": 3,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response4.txt_stdout.txt",
    "code_path": "problem_iter1_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority scores based on item-to-bin remaining capacity ratio and fit feasibility.\n    \n    Bins that can fit the item are prioritized by how much of the bin's remaining space they fill,\n    encouraging tight packing. Bins that cannot fit the item receive a priority of -inf.\n    \"\"\"\n    # Mask bins that can fit the item and have non-zero remaining capacity to avoid division by zero\n    valid_bins = (bins_remain_cap >= item) & (bins_remain_cap > 0)\n    # Initialize priority array with -inf for all bins\n    priority = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)\n    # Calculate ratio of item size to bin's remaining capacity for valid bins\n    priority[valid_bins] = item / bins_remain_cap[valid_bins]\n    return priority",
    "response_id": 4,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response5.txt_stdout.txt",
    "code_path": "problem_iter1_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins that can fit the item with minimal leftover space (Best Fit heuristic).\n    \n    Bins that cannot fit the item are assigned -infinity. The bin with the smallest\n    remaining capacity >= item (i.e., minimal leftover) receives the highest priority.\n    \"\"\"\n    # Calculate the leftover space if item is placed in each bin\n    leftover = bins_remain_cap - item\n    \n    # Prioritize bins with minimal non-negative leftover (Best Fit)\n    # Scores for valid bins are negative of leftover to favor smaller leftover\n    return np.where(leftover >= 0, -leftover, -np.inf)",
    "response_id": 5,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response6.txt_stdout.txt",
    "code_path": "problem_iter1_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Priority function that prioritizes bins fitting the item exactly first, \n    followed by bins with minimal leftover space (Best Fit with exact match bonus).\"\"\"\n    mask = bins_remain_cap >= item\n    space_left = bins_remain_cap - item\n    exact_fill = np.isclose(bins_remain_cap, item)  # Handle floating-point precision\n    # Assign high priority to exact fits; otherwise use negative space_left for Best Fit\n    priorities = np.where(mask, 1e6 * exact_fill - space_left, -np.inf)\n    return priorities",
    "response_id": 6,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response7.txt_stdout.txt",
    "code_path": "problem_iter1_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority scores based on minimizing leftover space after placement.\n    \n    Bins that can fit the item are prioritized by how tightly they pack it (less leftover).\n    Bins that cannot fit the item receive a very low priority.\n    \"\"\"\n    can_fit = bins_remain_cap >= item\n    leftover = bins_remain_cap - item\n    # Use negative leftover as priority (smaller leftover = higher priority)\n    # Add a small epsilon to avoid division by zero in cases of perfect fit (leftover=0)\n    priority = np.where(can_fit, -leftover + 1e-9, -np.inf)\n    return priority",
    "response_id": 7,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response8.txt_stdout.txt",
    "code_path": "problem_iter1_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Priority function combining Worst Fit and Best Fit heuristics based on item size relative to estimated bin capacity.\"\"\"\n    if len(bins_remain_cap) == 0:\n        return np.array([])\n    \n    # Estimate bin capacity as the maximum remaining capacity among current bins\n    C = np.max(bins_remain_cap)\n    relative_size = item / C if C > 0 else 0.0\n    \n    valid_mask = bins_remain_cap >= item\n    \n    if relative_size > 0.5:\n        # Prioritize bins with largest remaining capacity for large items (Worst Fit)\n        return np.where(valid_mask, bins_remain_cap, -np.inf)\n    else:\n        # Prioritize bins with smallest remaining capacity for small items (Best Fit)\n        return np.where(valid_mask, -bins_remain_cap, -np.inf)",
    "response_id": 8,
    "obj": 4.13841244515357,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response9.txt_stdout.txt",
    "code_path": "problem_iter1_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority scores based on the Best Fit heuristic.\n\n    The priority for each bin is the negative of its remaining capacity if the item\n    can fit, otherwise negative infinity. This encourages placing items in bins\n    with the smallest remaining capacity that can still accommodate the item.\n\n    Args:\n        item: Size of the item to be packed.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Returns:\n        Array of priority scores for each bin.\n    \"\"\"\n    priority = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)\n    can_fit = bins_remain_cap >= item\n    priority[can_fit] = -bins_remain_cap[can_fit]\n    return priority",
    "response_id": 9,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response10.txt_stdout.txt",
    "code_path": "problem_iter1_code10.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority scores based on the ratio of item size to bin's remaining capacity.\n    \n    Bins that can fit the item are prioritized by how large a fraction of their space the item occupies.\n    This encourages placing items in bins where they fill a higher proportion of the remaining space,\n    which aligns with minimizing leftover space and thus approximates the Best Fit heuristic.\n    \"\"\"\n    can_fit = bins_remain_cap >= item\n    # Add epsilon to denominator to prevent division by zero, ensuring numerical stability\n    epsilon = 1e-9\n    denominator = bins_remain_cap + epsilon\n    ratio = item / denominator\n    # Assign -inf to bins that can't fit the item, ensuring they are not selected\n    return np.where(can_fit, ratio, -np.inf)",
    "response_id": 10,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response11.txt_stdout.txt",
    "code_path": "problem_iter1_code11.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Prioritize bins that can fit the item with minimal remaining capacity.\n    # Priority is (item - bin_remaining_cap), which is negative for valid bins,\n    # with higher values (closer to 0) indicating better fits.\n    return np.where(bins_remain_cap >= item, item - bins_remain_cap, -np.inf)",
    "response_id": 11,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response12.txt_stdout.txt",
    "code_path": "problem_iter1_code12.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    can_fit = bins_remain_cap >= item\n    # Prioritize bins that can fit the item with smallest remaining capacity\n    # by using negative remaining capacity as priority. Infeasible bins get -inf.\n    return np.where(can_fit, -bins_remain_cap, -np.inf)",
    "response_id": 12,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response13.txt_stdout.txt",
    "code_path": "problem_iter1_code13.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Priority function combining Best Fit and Worst Fit heuristics based on item size.\"\"\"\n    slack = bins_remain_cap - item\n    mask = slack >= 0\n    priority = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)\n    \n    # Threshold for large items (assuming bin capacity is normalized to 1.0)\n    LARGE_ITEM_THRESHOLD = 0.5\n    \n    if item > LARGE_ITEM_THRESHOLD:\n        # Prioritize bins with largest remaining capacity (Worst Fit for large items)\n        priority[mask] = bins_remain_cap[mask]\n    else:\n        # Prioritize bins with smallest slack (Best Fit for small items)\n        priority[mask] = -slack[mask]\n    \n    return priority",
    "response_id": 13,
    "obj": 149.30195452732352,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response14.txt_stdout.txt",
    "code_path": "problem_iter1_code14.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority scores using a Best Fit heuristic with slack minimization.\n    \n    Bins that can fit the item are prioritized by how closely they match the item size,\n    preferring bins with the smallest remaining capacity after placement. Bins that\n    cannot fit the item are assigned a priority of negative infinity.\n    \"\"\"\n    slack = bins_remain_cap - item\n    valid = slack >= 0\n    # Prioritize bins with smallest slack (remaining capacity after placement)\n    # by assigning higher priority to smaller slack values.\n    priorities = np.where(\n        valid,\n        -slack,  # Equivalent to (item - bins_remain_cap), higher is better\n        -np.inf\n    )\n    return priorities",
    "response_id": 14,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response15.txt_stdout.txt",
    "code_path": "problem_iter1_code15.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Priority function using a hybrid strategy: Best Fit for large items (>=0.5), Worst Fit for small items.\"\"\"\n    valid_mask = bins_remain_cap >= item\n    priority = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)\n    \n    if not np.any(valid_mask):\n        return priority  # No valid bins to place the item\n    \n    if item >= 0.5:\n        # Best Fit: prioritize bins with smallest remaining capacity\n        priority[valid_mask] = -bins_remain_cap[valid_mask]\n    else:\n        # Worst Fit: prioritize bins with largest remaining capacity\n        priority[valid_mask] = bins_remain_cap[valid_mask]\n    \n    return priority",
    "response_id": 15,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response16.txt_stdout.txt",
    "code_path": "problem_iter1_code16.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority scores for bins using a combination of best-fit and bin utilization.\n\n    Args:\n        item: Size of the item to be packed.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Returns:\n        Array of priority scores for each bin.\n    \"\"\"\n    # Mask bins that can fit the item\n    valid = bins_remain_cap >= item\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n    \n    if not np.any(valid):\n        return priorities  # No valid bins, return all -inf\n    \n    # Calculate ratio-based priority (higher = better fit)\n    ratio_priority = item / bins_remain_cap[valid]\n    \n    # Calculate utilization-based priority (higher = more utilized bin)\n    bin_utilization = 1.0 - bins_remain_cap[valid]\n    utilization_priority = bin_utilization / (1.0 - item + 1e-9)  # Normalize by item size\n    \n    # Combine priorities with weighted sum (tuned for balanced bin utilization)\n    combined_priority = 0.7 * ratio_priority + 0.3 * utilization_priority\n    \n    priorities[valid] = combined_priority\n    return priorities",
    "response_id": 16,
    "obj": 4.0885520542481055,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response17.txt_stdout.txt",
    "code_path": "problem_iter1_code17.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Priority based on negative of leftover space (Best Fit heuristic).\"\"\"\n    leftover = bins_remain_cap - item\n    valid = leftover >= 0\n    # Assign negative leftover as priority (smallest leftover has highest priority)\n    # Invalid bins receive a very low priority to avoid selection\n    return np.where(valid, -leftover, -1e10)",
    "response_id": 17,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response18.txt_stdout.txt",
    "code_path": "problem_iter1_code18.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Best Fit strategy.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    valid_mask = bins_remain_cap >= item\n    priority = np.zeros_like(bins_remain_cap)\n    # Prioritize bins that fit the item with higher item/remaining_cap ratio\n    priority[valid_mask] = item / bins_remain_cap[valid_mask]\n    return priority",
    "response_id": 18,
    "obj": 4.198244914240141,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response19.txt_stdout.txt",
    "code_path": "problem_iter1_code19.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority scores based on minimizing leftover space with bias towards tighter fits.\n    \n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    \n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate valid bins and their leftover space\n    leftover = bins_remain_cap - item\n    can_fit = leftover >= 0\n    \n    # Priority formula: \n    # - For valid bins: higher priority for smaller leftover (using -leftover)\n    # - For invalid bins: very low priority (-inf)\n    priority = np.where(can_fit, -leftover, -np.inf)\n    \n    return priority",
    "response_id": 19,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response20.txt_stdout.txt",
    "code_path": "problem_iter1_code20.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Priority function using a ratio-based Best Fit heuristic.\n\n    Bins that can fit the item are prioritized by the ratio of the item size to\n    the bin's remaining capacity. This rewards tighter fits (ratio closer to 1.0).\n    Bins that cannot fit the item receive a priority of 0.\n\n    Args:\n        item: Size of the item to be packed.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Returns:\n        Array of priority scores for each bin.\n    \"\"\"\n    fit_mask = bins_remain_cap >= item\n    priorities = np.zeros_like(bins_remain_cap, dtype=np.float64)\n    # Add a tiny epsilon to avoid division by zero in edge cases\n    epsilon = 1e-9\n    priorities[fit_mask] = item / (bins_remain_cap[fit_mask] + epsilon)\n    return priorities",
    "response_id": 20,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response21.txt_stdout.txt",
    "code_path": "problem_iter1_code21.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority scores based on minimizing leftover space in bins that can fit the item.\n    \n    Args:\n        item: Size of the item to be packed.\n        bins_remain_cap: Array of remaining capacities for each bin.\n    \n    Returns:\n        Array of priority scores for each bin. Higher scores indicate better fit.\n    \"\"\"\n    leftover = bins_remain_cap - item\n    valid_mask = leftover >= 0\n    # Prioritize bins with smallest non-negative leftover (Best Fit)\n    priority = np.where(valid_mask, -leftover, -np.inf)\n    return priority",
    "response_id": 21,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response22.txt_stdout.txt",
    "code_path": "problem_iter1_code22.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority scores for bins using a Best Fit strategy.\n\n    The priority is highest for the bin with the smallest remaining capacity that can fit the item.\n    Bins that cannot accommodate the item are assigned -infinity.\n\n    Args:\n        item: Size of the item to be packed.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Returns:\n        Array of priority scores for each bin.\n    \"\"\"\n    eligible = bins_remain_cap >= item\n    return np.where(eligible, item - bins_remain_cap, -np.inf)",
    "response_id": 22,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response23.txt_stdout.txt",
    "code_path": "problem_iter1_code23.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority scores for each bin based on a hybrid heuristic.\n    \n    Prioritizes bins that can fit the item with the following criteria:\n    1. Bins with remaining capacity closest to the item size (Best Fit)\n    2. Bins with higher current utilization (lower remaining capacity)\n    3. Tie-breaker for earlier bins using a small epsilon decay\n    \n    Args:\n        item: Size of the item to pack.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        \n    Returns:\n        Array of priority scores for each bin.\n    \"\"\"\n    # Base priority: -remaining_cap for valid bins (Best Fit)\n    base_priority = np.where(bins_remain_cap >= item, -bins_remain_cap, -np.inf)\n    \n    # Tie-breaker: small epsilon decay based on bin index\n    epsilon = 1e-6\n    index_tiebreaker = epsilon * np.arange(len(bins_remain_cap))\n    \n    # Combined priority: base priority with tie-breaker\n    return base_priority - index_tiebreaker",
    "response_id": 23,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response24.txt_stdout.txt",
    "code_path": "problem_iter1_code24.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority scores based on minimizing leftover space after placement.\n    \n    Bins that can fit the item are prioritized by the inverse of resulting leftover space.\n    Bins that cannot fit the item are assigned a very low priority.\n    \"\"\"\n    can_fit = bins_remain_cap >= item\n    leftover = bins_remain_cap - item\n    # Use negative leftover as priority (smaller leftover = higher priority)\n    # Add a small epsilon to avoid division by zero in edge cases\n    priority = np.where(can_fit, -leftover + 1e-9, -np.inf)\n    return priority",
    "response_id": 24,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response25.txt_stdout.txt",
    "code_path": "problem_iter1_code25.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Priority function combining Best Fit for large items and Worst Fit for small items.\"\"\"\n    can_fit = bins_remain_cap >= item\n    large_item_threshold = 0.5\n    \n    if item >= large_item_threshold:\n        # Best Fit: prioritize bins with remaining capacity closest to item size\n        fit_scores = item - bins_remain_cap\n    else:\n        # Worst Fit: prioritize bins with largest remaining capacity\n        fit_scores = bins_remain_cap\n    \n    # Assign -inf to bins that can't fit the item\n    priorities = np.where(can_fit, fit_scores, -np.inf)\n    return priorities",
    "response_id": 25,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response26.txt_stdout.txt",
    "code_path": "problem_iter1_code26.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority scores using a Best Fit strategy with tightness scoring.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize with negative infinity for invalid bins\n    priority = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)\n    \n    # Mask bins that can fit the item\n    valid_mask = bins_remain_cap >= item\n    \n    # Calculate tightness score: prioritize bins with smallest leftover space\n    tightness_score = -(bins_remain_cap[valid_mask] - item)\n    \n    # Assign scores to valid bins\n    priority[valid_mask] = tightness_score\n    \n    return priority",
    "response_id": 26,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response27.txt_stdout.txt",
    "code_path": "problem_iter1_code27.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority scores for bins using a combination of best-fit and bin utilization.\n\n    Args:\n        item: Size of the item to pack.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Returns:\n        Array of priority scores for each bin.\n    \"\"\"\n    # Mask bins that can fit the item\n    mask = bins_remain_cap >= item\n    \n    # Calculate best-fit score (prioritize smallest leftover space)\n    best_fit_score = np.where(mask, -(bins_remain_cap - item), -np.inf)\n    \n    # Calculate utilization score (higher utilization after placement is better)\n    utilization_score = (1 - (bins_remain_cap - item) / np.max(bins_remain_cap)) if np.any(mask) else np.zeros_like(bins_remain_cap)\n    utilization_score = np.where(mask, utilization_score, -np.inf)\n    \n    # Combine scores with weighted sum (best-fit dominates, utilization breaks ties)\n    combined_score = best_fit_score + 0.1 * utilization_score\n    \n    return combined_score",
    "response_id": 27,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response28.txt_stdout.txt",
    "code_path": "problem_iter1_code28.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority scores for bins based on Best Fit heuristic.\n\n    Args:\n        item: Size of the item to be packed.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Returns:\n        Array of priority scores where higher values indicate better fit.\n    \"\"\"\n    # Calculate remaining capacity after placing the item\n    remaining = bins_remain_cap - item\n    # Identify valid bins (can fit the item)\n    valid = remaining >= 0\n    # Priority is negative of remaining space (prioritizes smallest leftover)\n    priority = np.where(valid, -remaining, -np.inf)\n    return priority",
    "response_id": 28,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response29.txt_stdout.txt",
    "code_path": "problem_iter1_code29.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority scores using Best Fit heuristic: prioritize bins that leave the least remaining space after placing the item.\n    \n    Args:\n        item: Size of the item to pack.\n        bins_remain_cap: Array of remaining capacities for each bin.\n    \n    Returns:\n        Priorities where higher values indicate better fit (least leftover space).\n    \"\"\"\n    mask = bins_remain_cap >= item\n    # Calculate priority as negative of leftover space (higher priority = smaller leftover)\n    priorities = np.where(mask, item - bins_remain_cap, -np.inf)\n    return priorities",
    "response_id": 29,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  }
]