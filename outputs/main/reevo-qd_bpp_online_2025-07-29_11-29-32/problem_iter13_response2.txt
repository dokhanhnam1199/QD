```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    eps = 1e-9  # Epsilon for numerical stability
    can_fit = bins_remain_cap >= item
    
    # Normalize item size relative to global bin capacity (assumed to be max available)
    bin_capacity = bins_remain_cap.max() if bins_remain_cap.size > 0 else item
    normalized_item = item / (bin_capacity + eps)
    
    # Dynamic target residual calculation
    target_residual_ratio = (1 - normalized_item**0.5)  # Adjust sensitivity
    target_residual = bin_capacity * target_residual_ratio
    
    # Core components
    residual = bins_remain_cap - item
    slack_ratio = bins_remain_cap / (bin_capacity + eps)
    
    # Blending weights using polynomial expression
    size_factor = normalized_item**1.5
    blend_weight = (size_factor + eps) / (size_factor + slack_ratio + eps)
    
    # Non-linear residual deviation penalty
    deviation = residual - target_residual
    deviation_penalty = (deviation**2) * (1 - blend_weight)
    
    # Feasibility-first quadratic scoring
    score = -blend_weight * residual - deviation_penalty
    
    return np.where(can_fit, score, -np.inf)
```
