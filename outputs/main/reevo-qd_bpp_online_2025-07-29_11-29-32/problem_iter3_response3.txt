```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority scores combining Best Fit and Worst Fit using dynamic ratio-based metrics.
    
    Bins that can fit the item are scored by normalized remaining capacity/item ratios:
    - Large items (relative to bin slack) use Best Fit (min slack scaled by item size)
    - Small items use Worst Fit (max remaining capacity scaled by item size)
    Infeasible bins receive -inf priority.
    
    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    can_fit = bins_remain_cap >= item
    feasible_caps = bins_remain_cap[can_fit]
    
    if not np.any(can_fit):
        return np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)
    
    # Calculate slack and normalized slack ratio
    slack = bins_remain_cap - item
    ratio = bins_remain_cap / item  # Remaining capacity/item ratio (>=1 for feasible)
    
    # Dynamic scoring based on normalized slack ratio
    # For large items (ratio close to 1): prioritize minimal slack (Best Fit)
    # For small items (ratio large): prioritize maximal remaining capacity (Worst Fit)
    # Combined via inverse slack normalization
    priority = np.where(can_fit, -(slack / item) + (bins_remain_cap / np.max(feasible_caps)), -np.inf)
    
    return priority
```
