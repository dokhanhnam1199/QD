[
  {
    "stdout_filepath": "problem_iter0_stdout0.txt",
    "code_path": "problem_iter0_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    ratios = item / bins_remain_cap\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities",
    "response_id": 0,
    "obj": 149.30195452732352,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 11.60964047443681,
    "mi": 94.04446327225541,
    "token_count": 47.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response0.txt_stdout.txt",
    "code_path": "problem_iter1_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            # Prioritize bins that can fit the item\n            remaining_after_fit = cap - item\n            \n            #First-Fit Decreasing-esque : Try to fill each bin optimally.\n            #Prioritize almost full bin. But penalize very tight fill to allow flexibility\n            if remaining_after_fit > 0:\n                priorities[i] = (item / cap) - 0.05*(remaining_after_fit/cap)\n            else: #Exactly full\n                priorities[i] = 1 #Very high priority to indicate a full bin\n\n            #Additional heuristic to promote more balanced loading between bins\n            #and reduce fragmentation: Use sqrt to emphasize closer fills rather than faraway ones\n            priorities[i] = np.sqrt(priorities[i])\n\n        else:\n            # Set priority to a very low value (or negative) for bins that can't fit\n            priorities[i] = -1e9 \n\n    return priorities",
    "response_id": 0,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.99996724999983 seconds"
  },
  {
    "stdout_filepath": "problem_iter1_response1.txt_stdout.txt",
    "code_path": "problem_iter1_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # 1. Feasibility: Can the item fit?\n    feasible_bins = bins_remain_cap >= item\n    \n    if not np.any(feasible_bins):\n        # If no bin can fit the item, assign minimal priority to all bins\n        return priorities - np.inf\n    \n    # 2. Remaining Capacity: Prefer bins with less remaining capacity *after* placing the item.  This encourages filling bins.\n\n    remaining_after_fit = bins_remain_cap - item\n    remaining_after_fit[~feasible_bins] = np.inf # penalize infeasible bins severely\n\n    priorities = -remaining_after_fit\n\n    # 3. Avoidance of fragmentation: prioritize bins whose utilization after insertion is high, but doesn't result in too much waste\n    utilization = (bins_remain_cap - remaining_after_fit) / np.max(bins_remain_cap) #Utilization of bin\n    fragmentation_penalty = np.abs(remaining_after_fit - item) #Smaller remainder, bigger penalty\n\n    priorities[feasible_bins] += 0.1 * utilization[feasible_bins] - 0.05 * fragmentation_penalty[feasible_bins] # Adjust scaling factor based on experiments\n\n    \n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 50.18947501009619,
    "mi": 83.59973324786895,
    "token_count": 114.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response2.txt_stdout.txt",
    "code_path": "problem_iter1_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Feasibility check: Assign very low priority if item doesn't fit\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] = -np.inf  # Significantly penalize infeasible bins\n\n    # Encourage filling bins more completely\n    fill_ratios = item / bins_remain_cap\n    fill_score = np.where(~infeasible_mask, np.clip(fill_ratios, 0, 1), 0) # Avoid modifying the already assigned -inf\n\n    # Bonus for bins that are already relatively full, avoiding fragmentation\n    occupation_ratios = (1 - bins_remain_cap / np.max(bins_remain_cap))\n    occupation_bonus = np.where(~infeasible_mask, occupation_ratios * fill_score, 0)\n\n    # Prioritize bins where the item represents a significant proportion of remaining space, and account for occupation.\n    priorities = np.where(~infeasible_mask, fill_score + occupation_bonus, priorities)\n\n    # Small random component to break ties and explore slightly\n    priorities += np.random.rand(len(bins_remain_cap)) * 0.0001\n    \n    return priorities",
    "response_id": 2,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 17, in priority_v2\n    priorities[can_fit] += 1  # Give these bins a base priority\nOverflowError: cannot convert float infinity to integer\n9\n3\n50.18947501009619\n83.59973324786895\n114\n"
  },
  {
    "stdout_filepath": "problem_iter1_response3.txt_stdout.txt",
    "code_path": "problem_iter1_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Prioritize bins that can fit the item\n    can_fit = bins_remain_cap >= item\n    priorities[can_fit] += 1  # Give these bins a base priority\n\n    # Further prioritize bins with the least remaining capacity after placing item\n    remaining_after_fit = bins_remain_cap[can_fit] - item\n    if len(remaining_after_fit) > 0:  # Check if any bins can fit the item before proceeding\n        priorities[can_fit] += np.max(remaining_after_fit) - remaining_after_fit  # Smaller remainder has higher priority\n    else:\n        #If no bin can fit the item, assign a low priority to bins which have the highest remaining cap.\n        priorities += bins_remain_cap / np.max(bins_remain_cap) * 0.01 # Small Value to make it the smallest among others that can fit\n\n    # Penalize bins that cannot fit the item (make them lower priority, close to 0 or negative)\n    priorities[~can_fit] -= 0.0001*(item-bins_remain_cap[~can_fit])   #Very small penalize\n\n    return priorities",
    "response_id": 3,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 50.18947501009619,
    "mi": 83.59973324786895,
    "token_count": 114.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response4.txt_stdout.txt",
    "code_path": "problem_iter1_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # 1. Feasibility: Assign very low priority if the item doesn't fit.\n    infeasible_mask = item > bins_remain_cap\n    priorities[infeasible_mask] = -np.inf\n    \n    # 2. Maximize remaining capacity after packing (minimize waste). Prefer bins that will have more space left.\n    feasible_mask = ~infeasible_mask\n    remaining_space = bins_remain_cap[feasible_mask] - item\n    \n    # Give priority to bins with more remaining capacity. Add small constant to avoid zero division.\n    priorities[feasible_mask] = remaining_space / (bins_remain_cap[feasible_mask] + 1e-6) \n    \n    # 3. Prioritize bins with closer capacity to item size\n    # Prioritize bins that fit the item snugly, reducing fragmentation.\n    snugness = bins_remain_cap[feasible_mask] - item\n    snugness_priority = np.exp(-np.abs(snugness) / (item + 1e-6)) # Gaussian-like, peaks when snugness is small. Adding a small constant for numerical stability\n    priorities[feasible_mask] += snugness_priority\n    \n    # Add a bonus to bins that are nearly full. Helps avoid a lot of nearly empty bins at the end.\n    nearly_full_bonus = (bins_remain_cap[feasible_mask] / np.max(bins_remain_cap + 1e-6))**2\n    priorities[feasible_mask] += nearly_full_bonus\n\n    return priorities",
    "response_id": 4,
    "obj": 149.30195452732352,
    "SLOC": 9.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 50.18947501009619,
    "mi": 83.59973324786895,
    "token_count": 114.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response5.txt_stdout.txt",
    "code_path": "problem_iter1_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Calculate remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n\n    # Give high priority to bins that can fit the item\n    fit_mask = remaining_capacities >= 0\n    priorities[fit_mask] = bins_remain_cap[fit_mask] - item  # Favor bins with tighter fit.\n\n    # Give negative priority to bins that cannot fit the item, with a larger magnitude\n    # if the item would exceed the capacity significantly\n    no_fit_mask = remaining_capacities < 0\n    priorities[no_fit_mask] = remaining_capacities[no_fit_mask] * 2  # Heavily penalize bins that can't fit.\n\n    # Boost bins that are nearly full but can still fit the item (encourages finishing bins).  Avoid divide by zero.\n    nearly_full_mask = (bins_remain_cap > 0) & fit_mask\n    priorities[nearly_full_mask] += 0.1*(1 - remaining_capacities[nearly_full_mask]/bins_remain_cap[nearly_full_mask])\n\n    return priorities",
    "response_id": 5,
    "obj": 149.30195452732352,
    "SLOC": 9.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 50.18947501009619,
    "mi": 83.59973324786895,
    "token_count": 114.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response6.txt_stdout.txt",
    "code_path": "problem_iter1_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # First-Fit-Decreasing Inspired: Favor bins that can fit the item with minimal waste.\n    # Avoid bins that are too small (negative residual)\n    residual_space = bins_remain_cap - item\n    \n    # Bins that can accommodate the item get a base priority based on how full they become after placement.\n    # Fuller bins (smaller waste) get higher priority. Using a non-linear function (e.g., square) to amplify this.\n    valid_bins = residual_space >= 0\n    if np.any(valid_bins):\n      priorities[valid_bins] = (item / bins_remain_cap[valid_bins])**2 # Fullness of bin if the item is added.\n    \n    #Add a bonus to almost full bin: The bins with remaining capacity between item and item + a tolerance\n    almost_full_tolerance = 0.1\n    almost_full = (bins_remain_cap >= item) & (bins_remain_cap <= item + almost_full_tolerance)\n    priorities[almost_full] += 1.0 #Adding a significant bonus\n    \n    # Give a large penalty if placing would cause an exceedance of bin capacity\n    priorities[residual_space < 0] = -1e9 \n\n    return priorities",
    "response_id": 6,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 50.18947501009619,
    "mi": 83.59973324786895,
    "token_count": 114.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response7.txt_stdout.txt",
    "code_path": "problem_iter1_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # 1. Feasibility check: only consider bins that can fit the item\n    feasible_bins = bins_remain_cap >= item\n    \n    # 2. Calculate remaining capacity after placing the item (for feasible bins)\n    remaining_capacities = bins_remain_cap - item\n    remaining_capacities[~feasible_bins] = -1  # Mark infeasible bins\n    \n    # 3. Prioritize bins with smaller remaining capacity (First-Fit Decreasing style)\n    # But only if they're feasible\n    priorities[feasible_bins] = bins_remain_cap[feasible_bins] - item\n    \n    # 4. Give a boost to almost full bins to avoid fragmentation. A bin is considered almost full if remaining capacity is less than a threshold (e.g., 10% of bin size). In cases we do not know the original size we will consider that this is a value between 0 and item\n    almost_full_threshold = min(item * 0.1, 0.1) #Threshold is 10% of item size, but cannot be bigger than 0.1\n    almost_full = (remaining_capacities > 0) & (remaining_capacities <= almost_full_threshold)\n    priorities[almost_full] += 1  # Boost for almost full bins\n    \n    # 5. Infeasible bins get the lowest priority (or 0, they don't matter anyway)\n    priorities[~feasible_bins] = -1e9 #Large negative number\n\n    return priorities",
    "response_id": 7,
    "obj": 149.30195452732352,
    "SLOC": 9.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 50.18947501009619,
    "mi": 83.59973324786895,
    "token_count": 114.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response8.txt_stdout.txt",
    "code_path": "problem_iter1_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # First-Fit-Decreasing inspired heuristic: Prefer bins that can fit the item well\n    fit_mask = bins_remain_cap >= item\n    priorities[fit_mask] = bins_remain_cap[fit_mask] - item  # Smaller difference = better fit\n    priorities[~fit_mask] = -1e9  # Very low priority for bins that can't fit the item\n\n    # Add a small bias to favor bins with more remaining capacity to avoid fragmentation if similar good fits are available\n    priorities += bins_remain_cap * 0.001\n\n    return priorities",
    "response_id": 8,
    "obj": 149.30195452732352,
    "SLOC": 9.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 50.18947501009619,
    "mi": 83.59973324786895,
    "token_count": 114.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response9.txt_stdout.txt",
    "code_path": "problem_iter1_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Calculate waste if item is placed in each bin\n    waste = bins_remain_cap - item\n    \n    # Assign high priority if item fits and low otherwise\n    fits = waste >= 0\n    priorities[fits] = 1.0\n    \n    # Among bins where the item fits, prioritize bins with least waste\n    priorities[fits] = 1.0 / (waste[fits] + 1e-6) # adding small number to prevent division by zero\n    \n    #For bins that don't fit the item: zero or very negative values. This discourages from placing to those bins, although impossible\n    priorities[~fits] = -1000\n    \n    return priorities",
    "response_id": 9,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 50.18947501009619,
    "mi": 83.59973324786895,
    "token_count": 114.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response10.txt_stdout.txt",
    "code_path": "problem_iter1_code10.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Rule 1: Bins that can fit the item get higher priority\n    can_fit = bins_remain_cap >= item\n    priorities[can_fit] += 1\n\n    # Rule 2: Give higher priority to bins with remaining capacity close to item size\n    # (First Fit Decreasing principle). Avoid very small remaining capacity\n    remaining_space = bins_remain_cap - item\n    close_fit = can_fit & (remaining_space <= np.mean(bins_remain_cap)) # Adjust threshold (np.mean(bins_remain_cap))\n    priorities[close_fit] += 2\n\n    # Rule 3: Penalize bins that will become almost full, but only if the item fits.\n    almost_full = can_fit & (remaining_space / bins_remain_cap < 0.1) # Adjust threshold (0.1)\n    priorities[almost_full] -= 0.5\n\n    # Rule 4: If the item doesn't fit any bin, prioritize bins with larger remaining capacity\n    if not np.any(can_fit):\n        priorities = bins_remain_cap / np.sum(bins_remain_cap)\n\n    return priorities",
    "response_id": 10,
    "obj": 8.526126844834463,
    "SLOC": 9.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 50.18947501009619,
    "mi": 83.59973324786895,
    "token_count": 114.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response11.txt_stdout.txt",
    "code_path": "problem_iter1_code11.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Heuristic 1: Prefer bins where the item fits.\n    fits = bins_remain_cap >= item\n    priorities[fits] += 1.0\n\n    # Heuristic 2: Smaller remaining capacity after placing the item results in a higher score (First-Fit Decreasing variant). Avoid large fragmentation.\n    remaining_after_placement = bins_remain_cap - item\n    valid_placements = remaining_after_placement >= 0\n    priorities[valid_placements] += 1.0 / (remaining_after_placement[valid_placements] + 1e-9)  # Avoid division by zero and prefer small remaining space\n\n    # Heuristic 3: Give slight bonus for almost full bins.\n    almost_full = (bins_remain_cap > item) & (bins_remain_cap < 2 * item)\n    priorities[almost_full] += 0.5\n\n    # Heuristic 4: Penalize bins if the item will overfill the bin.\n    overfill = bins_remain_cap < item\n    priorities[overfill] -= 0.0\n\n    return priorities",
    "response_id": 11,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 50.18947501009619,
    "mi": 83.59973324786895,
    "token_count": 114.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response12.txt_stdout.txt",
    "code_path": "problem_iter1_code12.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Calculate waste if item is placed in each bin\n    waste = bins_remain_cap - item\n\n    # Give high priority to bins where the item fits\n    fit_mask = waste >= 0\n    priorities[fit_mask] = 1\n\n    # Prioritize bins with less waste\n    priorities[fit_mask] += 1 / (waste[fit_mask] + 0.0001)  # Avoid division by zero\n\n    # Penalize bins where the item doesn't fit (make them less desirable)\n    no_fit_mask = ~fit_mask\n    priorities[no_fit_mask] = - (item - bins_remain_cap[no_fit_mask])  # penalize by amount of overflow\n\n    # Slightly prioritize bins that are closer to half full.  This aims to prevent\n    # bins from being either completely full or almost empty and promotes balanced loading.\n    half_full_distance = np.abs(bins_remain_cap - np.mean(bins_remain_cap))\n    priorities -= half_full_distance / (np.max(bins_remain_cap) + 0.0001)  # Normalize the distance\n\n    return priorities",
    "response_id": 12,
    "obj": 39.53928998803351,
    "SLOC": 9.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 50.18947501009619,
    "mi": 83.59973324786895,
    "token_count": 114.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response13.txt_stdout.txt",
    "code_path": "problem_iter1_code13.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Heuristic 1:  Favor bins that can fit the item\n    can_fit = bins_remain_cap >= item\n    priorities[can_fit] += 1\n\n    # Heuristic 2:  Prioritize bins with smallest remaining capacity after adding the item (First-Fit Decreasing variation)\n    remaining_after_fit = bins_remain_cap - item\n    remaining_after_fit[~can_fit] = np.inf  # Penalize bins that can't fit\n    priorities -= remaining_after_fit / np.max(bins_remain_cap) # Normalizing.\n\n    # Heuristic 3: Add a small random number for tie-breaking\n    priorities += np.random.rand(len(bins_remain_cap)) * 0.001\n\n    return priorities",
    "response_id": 13,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 50.18947501009619,
    "mi": 83.59973324786895,
    "token_count": 114.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response14.txt_stdout.txt",
    "code_path": "problem_iter1_code14.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # First-Fit Decreasing inspired heuristic\n    # Give high priority to bins where the item fits, and the remaining space after placing\n    # the item is minimized (close to zero, but positive).\n\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            remaining_space = cap - item\n            #Prioritize bins with least remaining space, but prevent overflow.\n            #Prioritize using an exponential function, small difference in space is preferred\n            priorities[i] = np.exp(-remaining_space)\n        else:\n            priorities[i] = -1  # negative priority to indicate invalid bins\n\n    return priorities",
    "response_id": 14,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.99997676999965 seconds"
  },
  {
    "stdout_filepath": "problem_iter1_response15.txt_stdout.txt",
    "code_path": "problem_iter1_code15.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # First-Fit Decreasing heuristic-inspired priority: prioritize bins that can fit the item well\n    fit_mask = bins_remain_cap >= item\n    priorities[fit_mask] = bins_remain_cap[fit_mask] - item  # Smaller waste is better\n\n    # Prioritize bins with close to exact fit\n    exact_fit_threshold = 0.05  # Define a threshold for \"close to exact fit\"\n    close_fit_mask = (bins_remain_cap >= item) & (bins_remain_cap - item <= exact_fit_threshold)\n    priorities[close_fit_mask] += 10  # Boost priority for bins with almost exact fit\n\n    # Penalize bins that would be filled over a certain threshold even after packing the item\n    overfill_threshold = 0.95  # Define a threshold for the bin filling level\n    filled_level = (bins_remain_cap - item)  # Remaining capacity after packing\n\n    very_small_remaining = filled_level <=0\n    priorities[very_small_remaining] = -np.inf # Do not want to pack there\n    \n    return priorities",
    "response_id": 15,
    "obj": 149.30195452732352,
    "SLOC": 9.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 50.18947501009619,
    "mi": 83.59973324786895,
    "token_count": 114.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response16.txt_stdout.txt",
    "code_path": "problem_iter1_code16.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Very high priority for bins where the item fits almost perfectly\n    almost_full = (bins_remain_cap >= item) & (bins_remain_cap <= item * 1.1)  # Tolerate 10% overfill\n    priorities[almost_full] += 100\n\n    # High priority for bins that can accommodate the item\n    can_accommodate = bins_remain_cap >= item\n    priorities[can_accommodate] += (bins_remain_cap[can_accommodate] - item) / np.max(bins_remain_cap) # Smaller waste = high priority\n\n    # Slightly penalize bins with very high remaining capacity. Encourage filling up the bins.\n    large_capacity = bins_remain_cap > item * 2 # Twice item size\n    priorities[large_capacity] -= bins_remain_cap[large_capacity] / np.max(bins_remain_cap) * 0.1 # Slightly reduce priority of large capacity bins\n\n    # Assign very low priority to bins where the item cannot fit\n    cannot_accommodate = bins_remain_cap < item\n    priorities[cannot_accommodate] = -1000  # Or a very low negative value\n    \n    # Add small random noise to break ties (optional, but can help with exploration)\n    priorities += np.random.rand(len(bins_remain_cap)) * 0.01\n    \n    return priorities",
    "response_id": 16,
    "obj": 73.07538891104906,
    "SLOC": 9.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 50.18947501009619,
    "mi": 83.59973324786895,
    "token_count": 114.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response17.txt_stdout.txt",
    "code_path": "problem_iter1_code17.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Rule 1: Highest priority to bins where the item fits best (smallest waste)\n    waste = bins_remain_cap - item\n    \n    # Give a very low priority if it doesn't fit\n    priorities[waste < 0] = -np.inf\n    \n    # Prioritize bins where the waste is minimized\n    priorities[waste >= 0] = 1 / (waste[waste >= 0] + 1e-9)  # Avoid division by zero and make waste inversely proportional to priority. Adding small const\n    \n    # Rule 2: slightly prioritize bins with more remaining capacity to reduce fragmentation if many bins fit. \n    # Only applicable for the fitting bins.\n    \n    fitting_bins = waste >=0\n    if np.any(fitting_bins):\n        max_remaining_cap = np.max(bins_remain_cap[fitting_bins])\n        priorities[fitting_bins] += 0.1 * (bins_remain_cap[fitting_bins] / max_remaining_cap)  #Adding a fraction of remaining capacity as a bonus\n\n    return priorities",
    "response_id": 17,
    "obj": 35.63023534104507,
    "SLOC": 9.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 50.18947501009619,
    "mi": 83.59973324786895,
    "token_count": 114.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response18.txt_stdout.txt",
    "code_path": "problem_iter1_code18.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Calculate wasted space if item is placed in each bin.\n    wasted_space = bins_remain_cap - item\n\n    # Give high priority to bins where the item fits and wasted space is minimized.\n    for i in range(len(bins_remain_cap)):\n        if wasted_space[i] >= 0:\n            #Prioritize smaller waste, prefer bins where item fits tightly\n            priorities[i] = 1.0 / (wasted_space[i] + 0.0001) # Adding a small value to avoid division by zero.\n\n            #Consider item size relative to remaining capacity. Filling the bin near capacity is good\n            priorities[i] += 1 / (1+abs(bins_remain_cap[i]-item)) #Prioritise small difference in value\n\n        else:\n            # Give very low priority to bins where the item doesn't fit.\n            priorities[i] = -1000.0  # or some other very negative value\n\n    return priorities",
    "response_id": 18,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 50.18947501009619,
    "mi": 83.59973324786895,
    "token_count": 114.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response19.txt_stdout.txt",
    "code_path": "problem_iter1_code19.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Feasibility check: only consider bins that can fit the item\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        return priorities  # No bin can fit, all priorities remain zero\n\n    # Priority 1: Bins that fit the item best (smallest remaining capacity after placing the item).\n    remaining_after_fit = bins_remain_cap - item\n    remaining_after_fit[remaining_after_fit < 0] = np.inf # Mark infeasible bins with infinite remaining. Important when all bins are already in use\n\n    # Assign high priority to bins with the *smallest positive* remaining capacity\n    priorities[feasible_bins] = 1 / (remaining_after_fit[feasible_bins] + 1e-9) # Adding a small constant to avoid division by zero and to act as a tie-breaker.\n\n    #Priority 2: Avoid bins that are getting too full if they fit well.\n\n    return priorities",
    "response_id": 19,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 50.18947501009619,
    "mi": 83.59973324786895,
    "token_count": 114.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response20.txt_stdout.txt",
    "code_path": "problem_iter1_code20.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Calculate remaining capacity after placing the item\n    remaining_after_placement = bins_remain_cap - item\n\n    # Give a high priority to bins that can accommodate the item\n    can_accommodate = remaining_after_placement >= 0\n    priorities[can_accommodate] = 1\n\n    # For bins that can accommodate, prioritize those with less remaining space.\n    # Aim to fill bins as much as possible. This promotes bin utilization.\n    priorities[can_accommodate] += 1 / (1 + remaining_after_placement[can_accommodate])\n\n    # Slightly penalize bins that would be nearly full (but not perfectly)\n    nearly_full = (remaining_after_placement > 0) & (remaining_after_placement < 0.1) #threshold can be tuned.\n    priorities[nearly_full] -= 0.05 #Penalty can be tuned\n\n    #For bins that CANNOT accommodate, assign a very low (negative) priority so that they are not chosen, but still have their relative priorities calculated\n    cannot_accommodate = remaining_after_placement < 0\n    priorities[cannot_accommodate] = -100 #Arbitrary negative value can be tuned, or set equal to a constant * the worst allowable bin packing score in your particular setup to normalize results\n\n    return priorities",
    "response_id": 20,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 50.18947501009619,
    "mi": 83.59973324786895,
    "token_count": 114.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response21.txt_stdout.txt",
    "code_path": "problem_iter1_code21.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            # First-Fit Decreasing-inspired heuristic\n            # Prioritize bins with smaller remaining capacity that can still fit the item\n            priorities[i] = (cap - item) / cap # Remaining waste percentage\n            priorities[i] = 1 - priorities[i] # Prefer less waste\n            # Prefer bins that will have lower remaining capacities after packing.\n            # Adding a small constant to avoid division by zero issues.\n            # Normalize: Higher = better\n        else:\n            # Very low priority for bins that cannot fit the item.\n            priorities[i] = -1e9\n    return priorities",
    "response_id": 21,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 50.18947501009619,
    "mi": 83.59973324786895,
    "token_count": 114.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response22.txt_stdout.txt",
    "code_path": "problem_iter1_code22.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if item <= cap:\n            # Encourage filling bins that are close to being full after adding the item\n            remaining_after_add = cap - item\n            if remaining_after_add == 0:\n                priorities[i] = 100  # High priority for perfect fit\n            else:\n                priorities[i] = 1 / (remaining_after_add + 0.00001)  # Smaller remaining cap gets higher priority\n        else:\n            priorities[i] = -1000  # Very low priority if item doesn't fit\n    return priorities",
    "response_id": 22,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 50.18947501009619,
    "mi": 83.59973324786895,
    "token_count": 114.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response23.txt_stdout.txt",
    "code_path": "problem_iter1_code23.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            # First Fit Decreasing logic inspired: Prioritize bins that can fit the item snugly\n            priority = 1 / (cap - item + 1e-9)  # Avoid division by zero\n            # Slightly filled bins get higher priority than emptier ones, but only if item fits.\n            priority += (1 - (cap / np.max(bins_remain_cap))) * 0.5\n            priorities[i] = priority\n        else:\n            # Item does not fit. Penalize heavily.\n            priorities[i] = -1e9  # Very low priority\n\n    return priorities",
    "response_id": 23,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.99997852999968 seconds"
  },
  {
    "stdout_filepath": "problem_iter1_response24.txt_stdout.txt",
    "code_path": "problem_iter1_code24.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Give high priority to bins that can fit the item perfectly or almost perfectly.\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    priorities[perfect_fit] = 1000  # Very high priority for perfect fit\n\n    # Give high priority to bins that have enough space, but not too much.\n    # Prefer bins that have space for the item + a small buffer (e.g., 10% of the item size)\n    almost_fit = (bins_remain_cap >= item) & (bins_remain_cap <= item * 1.1)\n    priorities[almost_fit] = 500\n\n    # Otherwise, prioritize bins with smaller remaining capacity but still enough for the item\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):\n        priorities[valid_bins] = 1.0 / bins_remain_cap[valid_bins]\n\n    # If no bin can fit the item, assign a small negative priority.  This effectively\n    # means such a bin will only be chosen if we're forced to (e.g., a new bin needs to be started).\n    priorities[bins_remain_cap < item] = -1\n\n    return priorities",
    "response_id": 24,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 50.18947501009619,
    "mi": 83.59973324786895,
    "token_count": 114.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response25.txt_stdout.txt",
    "code_path": "problem_iter1_code25.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # First, filter out bins that cannot fit the item\n    valid_bins = bins_remain_cap >= item\n\n    if not np.any(valid_bins):\n        # If no bin can fit the item, return low priority for all (effectively opening a new bin).\n        return priorities\n\n    # Calculate the waste if the item is placed in each valid bin\n    waste = bins_remain_cap[valid_bins] - item\n\n    # Assign higher priority to bins with less waste, but give some additional\n    # boost to almost-full bins.\n    priorities[valid_bins] = (1 / (waste + 0.00001)) + (bins_remain_cap[valid_bins] / np.max(bins_remain_cap))\n\n    # Optional: Add a small random component to break ties\n    priorities[valid_bins] += np.random.rand(np.sum(valid_bins)) * 0.0001\n\n    return priorities",
    "response_id": 25,
    "obj": 84.7726366174711,
    "SLOC": 9.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 50.18947501009619,
    "mi": 83.59973324786895,
    "token_count": 114.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response26.txt_stdout.txt",
    "code_path": "problem_iter1_code26.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Feasibility: Bin must be able to fit the item\n    feasible_bins = bins_remain_cap >= item\n    priorities[~feasible_bins] = -np.inf  # Disqualify infeasible bins\n\n    # Encourage filling bins:\n    fill_ratio = item / bins_remain_cap\n    priorities[feasible_bins] = 1 - fill_ratio[feasible_bins] # Higher priority for smaller waste (larger fill ratio)\n\n    # Bonus for bins that are already somewhat full. This helps complete bins\n    # Avoid dividing by zero, add small epsilon.\n    epsilon = 1e-9\n    utilization_ratio = (1 - bins_remain_cap / (1 + epsilon))\n    priorities[feasible_bins] += 0.5 * utilization_ratio[feasible_bins] #Added 0.5 factor as heuristic\n\n    # Larger bins have slight advantage in case of ties\n    priorities[feasible_bins] += 0.01 * bins_remain_cap[feasible_bins]  #added 0.01 factor as heuristic\n    return priorities",
    "response_id": 26,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 17, in priority_v2\n    priorities[fit_mask] = 1.0\nOverflowError: cannot convert float infinity to integer\n9\n3\n50.18947501009619\n83.59973324786895\n114\n"
  },
  {
    "stdout_filepath": "problem_iter1_response27.txt_stdout.txt",
    "code_path": "problem_iter1_code27.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Assign a high priority to bins that can fit the item.\n    fit_mask = bins_remain_cap >= item\n    priorities[fit_mask] = 1.0\n\n    # Adjust priority based on how well the item fits.\n    # Higher priority for bins where the remaining space after\n    # packing the item is minimized (First-Fit Decreasing principle).\n    remaining_space = bins_remain_cap - item\n    remaining_space[~fit_mask] = np.inf  # Assign infinite remaining space to bins that don't fit\n\n    # Normalize the remaining space to have higher priority for smaller remaining space\n    priorities[fit_mask] += 1.0 / (1.0 + remaining_space[fit_mask])\n\n    # Add a tie-breaking factor to prefer bins with more free space overall if there's still a tie after considering above criteria.\n    # Add to avoid ties and to potentially promote packing smaller items into emptier bins (reduces fragmentation).\n    priorities += bins_remain_cap / np.sum(bins_remain_cap) * 0.1  # small additive bonus\n\n    return priorities",
    "response_id": 27,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 50.18947501009619,
    "mi": 83.59973324786895,
    "token_count": 114.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response28.txt_stdout.txt",
    "code_path": "problem_iter1_code28.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Feasibility check: Can the item fit?\n    feasible_bins = bins_remain_cap >= item\n\n    # If no bin can fit the item, return an array of -inf (effectively reject all)\n    if not np.any(feasible_bins):\n        return np.full_like(bins_remain_cap, -np.inf)\n\n    # Prioritize bins based on remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    remaining_capacities[~feasible_bins] = -np.inf  # Disqualify infeasible bins\n\n    # Score is higher when remaining_capacities is close to 0, \n    # but also penalize bins that are filled too much (avoid creating very full bins immediately).\n    # Here is the formula used:\n    # -abs(remaining_capacities) + K*(bins_remain_cap)\n    # Note: K can be any values (such as 0 or 0.5 etc.).\n    # If K is smaller, the main importance is to choose a near-full bin.\n    # Otherwise, bins are less filled at start, which might be good at later iteration\n    K = 0.5\n    priorities[feasible_bins] = -np.abs(remaining_capacities[feasible_bins]) + K*bins_remain_cap[feasible_bins]\n\n\n    #Add a small random component to break ties and explore different options\n    priorities[feasible_bins] += np.random.rand(np.sum(feasible_bins)) * 0.001\n\n    return priorities",
    "response_id": 28,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 50.18947501009619,
    "mi": 83.59973324786895,
    "token_count": 114.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response29.txt_stdout.txt",
    "code_path": "problem_iter1_code29.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # First Fit Decreasing heuristic inspired\n    # Prioritize bins where the item fits. If it doesn't fit give the bin a very low score\n\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            #Prioritize bins with smaller remaining capacity but enough for the item to fit.\n            priorities[i] = (cap - item) # try to use close to full bins first (smallest diff)\n            priorities[i] = 1 / (priorities[i] + 0.00001) # if exactly full use bin with cap==item first.\n            \n        else:\n            priorities[i] = -1000 # very low score\n\n    return priorities",
    "response_id": 29,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 50.18947501009619,
    "mi": 83.59973324786895,
    "token_count": 114.0,
    "exec_success": true
  }
]