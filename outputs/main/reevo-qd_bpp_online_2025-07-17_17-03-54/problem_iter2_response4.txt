```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    # Rule 1: Highest priority to bins where the item fits best (smallest waste)
    waste = bins_remain_cap - item
    
    # Give a very low priority if it doesn't fit
    priorities[waste < 0] = -np.inf
    
    # Prioritize bins where the waste is minimized
    waste_positive = waste[waste >= 0]
    if waste_positive.size > 0:
        min_waste = np.min(waste_positive)
        priorities[waste >= 0] = 1 / (waste[waste >= 0] - min_waste + 0.1)  # Prioritize closer to min waste. Avoid division by zero.
        # Scale the priorities so that best fit has a score of ~1

    # Rule 2: slightly prioritize bins with more remaining capacity to reduce fragmentation if many bins fit. 
    # Only applicable for the fitting bins.
    
    fitting_bins = waste >=0
    if np.any(fitting_bins):
        max_remaining_cap = np.max(bins_remain_cap[fitting_bins])
        priorities[fitting_bins] += 0.1 * (bins_remain_cap[fitting_bins] / max_remaining_cap)  #Adding a fraction of remaining capacity as a bonus

    return priorities
```
