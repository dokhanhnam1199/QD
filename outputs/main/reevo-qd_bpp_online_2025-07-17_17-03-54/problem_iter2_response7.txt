```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:

    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Heuristic 1: Feasibility - can the item fit?  Major factor.
    fits = bins_remain_cap >= item
    priorities[fits] += 10.0

    # Heuristic 2: Minimize wasted space (FFD inspired).  More important than before.
    remaining_after_placement = bins_remain_cap - item
    valid_placements = remaining_after_placement >= 0
    priorities[valid_placements] += 5.0 / (remaining_after_placement[valid_placements] + 1e-9)  # Stronger preference for tighter fits

    # Heuristic 3: Reward bins that are becoming full, but not excessively.  Discourage extreme fragmentation.
    almost_full = (bins_remain_cap > item) & (bins_remain_cap <= 1.5 * item) #Tuned the almost full condition
    priorities[almost_full] += 2.0

    # Heuristic 4: Penalize bins that can't fit.  (Already handled by the 0 case, but make it explicit). Less important than fitting.
    overfill = bins_remain_cap < item
    priorities[overfill] -= 1.0 #Reduced penalty

    #Heuristic 5: Bins that have been used less get a tiny bonus to spread items across bins initially.
    priorities += (bins_remain_cap > 0) * 0.1 #Slightly favor non-empty bins
    return priorities
```
