```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:

    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    # Identify bins where the item fits
    fit_mask = bins_remain_cap >= item
    
    # If no bin fits, assign a very low priority to all bins
    if not np.any(fit_mask):
        return -np.ones_like(bins_remain_cap)  # Return an array of -1 priorities

    # Calculate remaining capacity after adding the item, only for bins where it fits
    remaining_cap_after_add = bins_remain_cap[fit_mask] - item
    
    # Prioritize bins based on the inverse of remaining capacity. Add small epsilon to avoid division by zero.
    priorities[fit_mask] = 1 / (remaining_cap_after_add + 1e-9)

    # Give higher priority to bins that will be completely full after adding the item
    full_mask = remaining_cap_after_add <= 1e-9 #Using epsilon for comparison
    priorities[fit_mask][full_mask] = np.max(priorities[fit_mask]) + 10 #Set to a very high value

    return priorities
```
