```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    # High priority to bins where item fits with least remaining space
    # and that aren't too full already
    
    valid_bins = bins_remain_cap >= item
    
    if np.any(valid_bins):
      remaining_after_fit = bins_remain_cap[valid_bins] - item
      
      # Normalize remaining capacity after placing the item
      normalized_remaining = remaining_after_fit / bins_remain_cap[valid_bins]
      
      # Calculate priorities - bins with the least normalized space after fit gets highest priority
      priorities[valid_bins] = 1 - normalized_remaining
      
      # Bonus if remaining_after_fit is close to zero but still bigger than zero (fit almost perfectly)
      perfect_fit_bonus = np.exp(-10*remaining_after_fit)
      priorities[valid_bins] += perfect_fit_bonus
      
      # Avoid very full bins: discount priority if initial bin utilization is very high
      utilization = 1 - bins_remain_cap[valid_bins]
      overfull_penalty = np.where(utilization > 0.95, -100, 0) # drastically penalize almost-full bins
      priorities[valid_bins] += overfull_penalty

    # If no bins fit, penalize very full bins the least and prefer empty ones.
    else:
      priorities = - (1 - bins_remain_cap) # empty bins get the least negative penalty
    
    return priorities
```
