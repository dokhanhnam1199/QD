[
  {
    "stdout_filepath": "problem_iter0_stdout0.txt",
    "code_path": "problem_iter0_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    ratios = item / bins_remain_cap\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities",
    "response_id": 0,
    "obj": 149.30195452732352,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 11.60964047443681,
    "mi": 94.04446327225541,
    "token_count": 47.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response0.txt_stdout.txt",
    "code_path": "problem_iter1_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Calculate remaining capacity after adding the item\n    remaining_after_add = bins_remain_cap - item\n\n    # Give very low priority to bins that cannot accommodate the item\n    priorities[remaining_after_add < 0] = -np.inf\n\n    # Calculate the fill ratio (item size / bin capacity)\n    fill_ratio = item / bins_remain_cap\n    \n    # Bins with remaining capacity close to item size are prioritized higher.\n    # Try to fill bins tightly without wasting too much space.\n    \n    priorities[remaining_after_add >= 0] = (bins_remain_cap[remaining_after_add >= 0] / (abs(remaining_after_add[remaining_after_add >= 0] - item) + 0.00001))\n    \n    \n    # Scale by remaining capacity, which helps prefer bins that were already filled partially,\n    # without focusing solely on almost-full bins if others are more appropriate.\n    priorities[remaining_after_add >= 0] *= bins_remain_cap[remaining_after_add >= 0]\n    \n\n    return priorities",
    "response_id": 0,
    "obj": 50.1695253290786,
    "SLOC": 15.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 396.4588483417382,
    "mi": 77.7879013914236,
    "token_count": 195.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response1.txt_stdout.txt",
    "code_path": "problem_iter1_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if item <= cap:\n            # First Fit Decreasing-like: Prefer bins with tighter fit. Reward small waste.\n            waste = cap - item\n            priorities[i] = 1 / (waste + 0.0001)  # Avoid division by zero\n\n            #Consider relative fullness to avoid filling a near-empty bin if a tighter fit is available elsewhere.\n            fullness = item / cap\n            priorities[i] *= (1 + fullness)  #Boost priority the closer the fit\n            \n            # Penalize bins nearing fullness if the current item causes them to overflow when combined with some small items that appear later.\n            if cap < 2 * item:\n                 priorities[i] *= 1.1 # increase it slightly\n\n        else:\n            priorities[i] = -1  # Bin is not feasible\n\n    return priorities",
    "response_id": 1,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.99997471000097 seconds"
  },
  {
    "stdout_filepath": "problem_iter1_response2.txt_stdout.txt",
    "code_path": "problem_iter1_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # First-Fit Decreasing (FFD) Inspired: Prefer bins with just enough space\n    residual_space = bins_remain_cap - item\n    fit_scores = np.where(residual_space >= 0, np.exp(-np.abs(residual_space)), -np.inf)\n\n    # Give penalty to bins that are already too full\n    priorities = fit_scores\n\n    # Smallest-Fit Inspired: Fill up bins that have less capacity\n    priorities += -0.01 * bins_remain_cap # Adding a small factor since we prefer 'exact' fit\n\n    # Large item penalty: If item size is above the threshold, penalize bins.\n    large_item_threshold = 0.7\n    if item > large_item_threshold:\n      priorities -= (item - large_item_threshold)\n\n    # Avoid creating too many near-empty bins. Reward larger utilization of current bins\n    priorities += bins_remain_cap / np.sum(bins_remain_cap) if np.sum(bins_remain_cap) > 0 else 0.0\n\n    return priorities",
    "response_id": 2,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 396.4588483417382,
    "mi": 77.7879013914236,
    "token_count": 195.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response3.txt_stdout.txt",
    "code_path": "problem_iter1_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: Only consider bins that can fit the item\n    feasible_bins = bins_remain_cap >= item\n    priorities[~feasible_bins] = -np.inf  # Assign lowest priority to infeasible bins\n\n    # 2. Remaining Capacity: Prefer bins with less remaining capacity after adding the item,\n    #    but avoid bins that will become too full (e.g., remaining capacity < item/2, can be tuned)\n    remaining_after_fit = bins_remain_cap - item\n    too_full = remaining_after_fit < 0.1 * np.max(bins_remain_cap) # or < item/2 if you have a known reasonable upper bound of item size, avoids creating many near-full bins. Original paper use 0.\n    priorities[too_full & feasible_bins] = -np.inf\n\n    # 3. Fill Ratio: Calculate the fill ratio if the item is added\n    fill_ratio = item / bins_remain_cap[feasible_bins & ~too_full]\n\n    # 4. Score based on fill_ratio and remaining after fit. The idea is to prioritize to fully use the bin without making it over-full.\n    priorities[feasible_bins & ~too_full] = fill_ratio + 0.01 * remaining_after_fit[feasible_bins & ~too_full]/np.max(bins_remain_cap)\n    return priorities",
    "response_id": 3,
    "obj": 15.167530913442375,
    "SLOC": 15.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 396.4588483417382,
    "mi": 77.7879013914236,
    "token_count": 195.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response4.txt_stdout.txt",
    "code_path": "problem_iter1_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # First Fit Decreasing heuristic adaptation: prioritize bins that can fit the item\n    # and have the least remaining capacity after placing the item.  If no bin can fit the item, then return 0\n    \n    # Assign a base priority if the bin can fit the item\n    can_fit = bins_remain_cap >= item\n    \n    if np.any(can_fit):  # at least one bin can fit\n        priorities[can_fit] = 1.0  # Base priority\n\n        # Prioritize bins with smaller remaining capacity after placement\n        remaining_after_placement = bins_remain_cap[can_fit] - item\n        priorities[can_fit] += 1.0 / (remaining_after_placement + 1e-9)  # Avoid division by zero\n\n        # Bonus for near-perfect fit (reduces fragmentation)\n        near_perfect_fit = (remaining_after_placement >= 0) & (remaining_after_placement <= 0.1 * np.max(bins_remain_cap))\n        priorities[can_fit][near_perfect_fit] += 2.0\n        \n    else:\n        # if no bins can fit return a small value that makes it be last\n        priorities[:] = -1.0\n\n    return priorities",
    "response_id": 4,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 396.4588483417382,
    "mi": 77.7879013914236,
    "token_count": 195.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response5.txt_stdout.txt",
    "code_path": "problem_iter1_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # First-Fit Decreasing heuristic inspired priority\n    # Give high priority to bins that can fit the item and have the least remaining space after fitting.\n    # If bin cannot fit the item, give it a very low priority (negative value).\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            priorities[i] = 1 / (cap - item + 1e-9)  # Avoid division by zero.  Smaller remaining space -> Higher priority\n        else:\n            priorities[i] = -1e9  # Very low priority if item doesn't fit\n\n    return priorities",
    "response_id": 5,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 396.4588483417382,
    "mi": 77.7879013914236,
    "token_count": 195.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response6.txt_stdout.txt",
    "code_path": "problem_iter1_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Calculate remaining capacity after adding the item\n    remaining_after_add = bins_remain_cap - item\n    \n    # Give high priority to bins where the item fits and the remaining capacity is minimized, but not zero or negative.\n    fit_mask = remaining_after_add >= 0\n    \n    if np.any(fit_mask):\n        priorities[fit_mask] = 1 / (remaining_after_add[fit_mask] + 1e-9) # Adding a small constant to prevent division by zero\n        \n        # If some bins have exactly the item size, give them highest priority\n        exact_fit_mask = (bins_remain_cap - item) == 0\n        if np.any(exact_fit_mask):\n             priorities[exact_fit_mask] = np.max(priorities) + 1\n    else:\n         priorities = np.zeros_like(bins_remain_cap) # if item doesn't fit anywhere, assign lowest priority to all bins\n         \n    return priorities",
    "response_id": 6,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 396.4588483417382,
    "mi": 77.7879013914236,
    "token_count": 195.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response7.txt_stdout.txt",
    "code_path": "problem_iter1_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Give high priority to bins where the item fits with minimal waste.\n    # Avoids fragmentation by preferring bins that will be filled more completely.\n    fit_mask = bins_remain_cap >= item\n    waste = bins_remain_cap - item\n    priorities[fit_mask] = 1 / (waste[fit_mask] + 1e-9)  # Smaller waste, higher priority\n\n    # If no bins can fit, assign a very negative priority\n    if not np.any(fit_mask):\n        priorities[:] = -np.inf # Prevents selection\n\n    return priorities",
    "response_id": 7,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 396.4588483417382,
    "mi": 77.7879013914236,
    "token_count": 195.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response8.txt_stdout.txt",
    "code_path": "problem_iter1_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # First Fit Decreasing Heuristic-inspired: Prefer bins that can accommodate the item.\n    # and prefer the fuller ones\n\n    eligible_bins = bins_remain_cap >= item\n    \n    if np.any(eligible_bins):\n        priorities[eligible_bins] = bins_remain_cap[eligible_bins] - item # Remaining capacity after inserting\n        priorities[eligible_bins] = 1 / (priorities[eligible_bins] + 1e-9) # To favor bins with smallest remaining capacity\n        \n    else:\n        #If no bin can fit, then assign low score for all bins, so that we can create new one if possible.\n        priorities[:] = -1 \n            \n    return priorities",
    "response_id": 8,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 396.4588483417382,
    "mi": 77.7879013914236,
    "token_count": 195.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response9.txt_stdout.txt",
    "code_path": "problem_iter1_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Feasibility: can the item fit?  Infeasible bins get -inf priority.\n    feasible = bins_remain_cap >= item\n    priorities[~feasible] = -np.inf\n\n    # For feasible bins:\n    # 1. Maximize space utilization: fill the bin as much as possible.\n    # 2. Minimize wasted space: penalize bins with too much remaining capacity after adding the item.\n    # 3. Small bins get priority (First Fit Decreasing style influence)\n    # Normalized remaining capacity after adding the item.\n    remaining_capacity_after = bins_remain_cap[feasible] - item\n    normalized_remaining = remaining_capacity_after / np.max(bins_remain_cap) # normalize with respect to largest bin. avoids scale issues\n    \n    # Score is composed of utilization and waste factors\n    utilization_score =  1- normalized_remaining\n    waste_penalty = - (normalized_remaining)**2 # Quadratic penalty for wasted space\n    \n    # Combine scores\n    priorities[feasible] = utilization_score + waste_penalty \n   \n\n    return priorities",
    "response_id": 9,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 396.4588483417382,
    "mi": 77.7879013914236,
    "token_count": 195.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response10.txt_stdout.txt",
    "code_path": "problem_iter1_code10.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Give high priority to bins that can fit the item snugly\n    fit_mask = bins_remain_cap >= item\n    priorities[fit_mask] = (bins_remain_cap[fit_mask] - item) / bins_remain_cap[fit_mask]\n    priorities[fit_mask] = 1 - priorities[fit_mask] # higher values for smaller remaining space after placement\n    \n    # Penalize bins that are too full or won't fit the item at all\n    not_fit_mask = bins_remain_cap < item\n    priorities[not_fit_mask] = -np.inf # ensure that bins too small are not considered\n    \n    # Add a small bonus for bins that are not completely empty (to favor using partially filled bins first)\n    non_empty_mask = bins_remain_cap < 1.0\n    priorities[non_empty_mask] += 0.001\n    \n    return priorities",
    "response_id": 10,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 396.4588483417382,
    "mi": 77.7879013914236,
    "token_count": 195.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response11.txt_stdout.txt",
    "code_path": "problem_iter1_code11.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Huge penalty if the item doesn't fit\n    priorities[bins_remain_cap < item] = -np.inf\n    \n    # If item fits, prioritize bins with tighter fit (minimize wasted space), but not too tight\n    \n    # Option 1: Linear Reward, penalized by waste\n    waste = bins_remain_cap - item\n    \n    # Penalize bins nearing completion. High priority for bins that are just large enough\n    # but also incentivize filling already decently filled bins\n\n    # Attempt a non-linear scaling\n    priorities[bins_remain_cap >= item] = np.exp(-waste[bins_remain_cap >= item]) * (bins_remain_cap[bins_remain_cap >= item]/ bins_remain_cap.max()) \n    \n    return priorities",
    "response_id": 11,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 396.4588483417382,
    "mi": 77.7879013914236,
    "token_count": 195.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response12.txt_stdout.txt",
    "code_path": "problem_iter1_code12.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            # First Fit Decreasing inspired: prioritize bins where the item fits well.\n            # Give preference to bins with smallest remaining capacity greater or equal to the item size.\n            priorities[i] = 1 / (cap + 1e-9)  # Avoid division by zero\n        else:\n            # Negative priority if item doesn't fit\n            priorities[i] = -1e9 # Large negative value to discourage placement\n\n    return priorities",
    "response_id": 12,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.99997006999911 seconds"
  },
  {
    "stdout_filepath": "problem_iter1_response13.txt_stdout.txt",
    "code_path": "problem_iter1_code13.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Prioritize bins where the item fits\n    fit_mask = bins_remain_cap >= item\n    \n    # If no bin fits, assign a low priority to all bins\n    if not np.any(fit_mask):\n        return priorities\n\n    # Calculate fill ratio for bins where the item fits\n    fill_ratio = item / bins_remain_cap\n    fill_ratio[~fit_mask] = 0  # Set to 0 for bins where it doesn't fit\n\n    # Prioritize bins with a fill ratio close to 1 (but not exceeding 1)\n    priorities[fit_mask] = 1 - np.abs(1 - fill_ratio[fit_mask])\n    \n    # Add a small bonus for bins that are nearly full before adding the item\n    nearly_full_bonus_mask = (bins_remain_cap > item) & (bins_remain_cap < item * 1.2) # Slightly more than needed\n    priorities[nearly_full_bonus_mask] += 0.1 # Add some bonus. It will never dominate completely full bins.\n    \n    # Slightly penalize bins with significantly larger capacity than item size\n    large_capacity_penalty_mask = (bins_remain_cap > item * 3) & fit_mask\n    priorities[large_capacity_penalty_mask] -= 0.05 # Small penalty if the space left over will be excessive. \n\n    return priorities",
    "response_id": 13,
    "obj": 4.4674910251296325,
    "SLOC": 15.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 396.4588483417382,
    "mi": 77.7879013914236,
    "token_count": 195.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response14.txt_stdout.txt",
    "code_path": "problem_iter1_code14.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if item <= cap:\n            # Encourage filling bins as much as possible, but prioritize bins that are close to full after adding the item\n            fill_ratio = item / cap\n            remaining_cap_after_add = cap - item\n            #Prioritize bins that will be almost full\n            if remaining_cap_after_add > 0:\n              priorities[i] = 1/(remaining_cap_after_add + 1e-9) # add small epsilon to avoid division by zero\n            else:\n              priorities[i] = 100 # high priority if item fits exactly\n        else:\n            priorities[i] = -1  # Cannot fit, assign very low priority\n    return priorities",
    "response_id": 14,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 396.4588483417382,
    "mi": 77.7879013914236,
    "token_count": 195.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response15.txt_stdout.txt",
    "code_path": "problem_iter1_code15.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # High priority if the item fits well (small waste)\n    fit_mask = bins_remain_cap >= item\n    waste = bins_remain_cap - item\n    priorities[fit_mask] = 1.0 / (waste[fit_mask] + 0.0001)  # Avoid division by zero\n    # Small amount of waste implies large value, large waste implies small value.\n\n    # Negative priority if it doesn't fit\n    non_fit_mask = bins_remain_cap < item\n    priorities[non_fit_mask] = -item/(bins_remain_cap[non_fit_mask]+0.0001) #Prioritize small remaining cap when the item cannot fit.\n\n    #Boost priority of bins that are nearly full when they fit the item\n    nearly_full_mask = (bins_remain_cap > item) & (bins_remain_cap <= 2*item)\n\n    priorities[nearly_full_mask] = priorities[nearly_full_mask] + 2 # Try to fill partially full bins\n\n    return priorities",
    "response_id": 15,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 396.4588483417382,
    "mi": 77.7879013914236,
    "token_count": 195.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response16.txt_stdout.txt",
    "code_path": "problem_iter1_code16.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # First-Fit Decreasing inspired heuristic: prioritize bins that can fit the item,\n    # but among those, prefer bins with less remaining capacity. This tries to\n    # fill bins before opening new ones.\n\n    # Very large number so it goes to the end if it can't fit\n    penalty = 1e9\n\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            # Give a priority based on how well the item fits (lower remaining capacity after insertion is better).\n            # Add a small constant to ensure positive values and avoid division by zero.\n            priorities[i] = 1.0 / (cap - item + 0.0001)  # Higher priority for smaller remaining space\n        else:\n            priorities[i] = -penalty # Very Low Priority\n    return priorities",
    "response_id": 16,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 396.4588483417382,
    "mi": 77.7879013914236,
    "token_count": 195.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response17.txt_stdout.txt",
    "code_path": "problem_iter1_code17.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Large enough bins that can accommodate the item get a baseline priority.\n    eligible_bins = bins_remain_cap >= item\n    priorities[eligible_bins] = 1.0\n\n    # Favor bins where the item fills a large portion of the remaining capacity,\n    # but not too large, so as to avoid leaving too little space.\n    fill_ratios = item / bins_remain_cap\n    good_fill = (fill_ratios >= 0.5) & (fill_ratios <= 0.95) & eligible_bins  # Target fill range\n    priorities[good_fill] += 2.0 # Give high priority if fill is good.\n\n    # Add a small bonus for bins that are nearly full after packing. This\n    # encourages the algorithm to close out bins.\n    remaining_after_pack = bins_remain_cap - item\n    almost_full = (remaining_after_pack > 0) & (remaining_after_pack <= 0.1) & eligible_bins\n    priorities[almost_full] += 1.5\n\n    # Slightly discourage using empty bins if other partially filled bins are viable.\n    empty_bins = bins_remain_cap == np.max(bins_remain_cap)  # Assuming 'max' is initial capacity.\n    priorities[empty_bins & eligible_bins] -= 0.5 * np.mean(eligible_bins)\n\n    # Add a random component to break ties and explore the solution space\n    priorities[eligible_bins] += np.random.rand(np.sum(eligible_bins)) * 0.1\n\n    return priorities",
    "response_id": 17,
    "obj": 6.950538492221783,
    "SLOC": 15.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 396.4588483417382,
    "mi": 77.7879013914236,
    "token_count": 195.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response18.txt_stdout.txt",
    "code_path": "problem_iter1_code18.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Assign high priority to bins that can fit the item with minimal waste\n    fit_mask = bins_remain_cap >= item\n    \n    if np.any(fit_mask):  # Check if any bin can fit the item\n        waste = bins_remain_cap[fit_mask] - item\n        priorities[fit_mask] = 1 / (waste + 0.00001) # high priority when waste is low (avoid zero division)\n\n        # Prioritize bins closer to item size (First-Fit Decreasing inspired)\n        priorities[fit_mask] += (bins_remain_cap[fit_mask] - item) / np.max(bins_remain_cap) \n\n    # Give bins close to full a negative priority if item doesn't fit (try to fill new bins)\n    almost_full = (bins_remain_cap > 0) & (bins_remain_cap < item)\n    priorities[almost_full] = -1 * (item - bins_remain_cap[almost_full])  # Give negative priority if bin is not useful\n\n    # Very low priority for empty/zero bins (to avoid useless computation if no bins work)\n    empty_bins = bins_remain_cap == 0\n    priorities[empty_bins] = -1000 #very small number\n\n    return priorities",
    "response_id": 18,
    "obj": 84.7726366174711,
    "SLOC": 15.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 396.4588483417382,
    "mi": 77.7879013914236,
    "token_count": 195.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response19.txt_stdout.txt",
    "code_path": "problem_iter1_code19.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    # First-Fit Decreasing inspired: Prefer bins that can accommodate the item\n    can_fit = bins_remain_cap >= item\n    priorities[can_fit] += 1\n\n    # Fill the almost full bins first, but only if it fits\n    almost_full = (bins_remain_cap >= item) & (bins_remain_cap < 2 * item)  #Try to fill bins nearing capacity, but that can still fit the item.\n    priorities[almost_full] += 2 # Give them higher priority than just bins that can fit.\n\n    # Avoid bins with very little remaining capacity after placing the item, unless its the ONLY bin that can fit\n    too_small = (bins_remain_cap - item) < 0.1 #if only 10% left.\n    only_option = (can_fit.sum() ==1) & can_fit  # make it so its okay to have only 10% remain, but only if only ONE can fit\n    too_small = too_small & (~only_option) # avoid almost full bins ONLY if not the ONLY option\n\n    priorities[too_small] -= 10  # Very negative to really discourage using them, as long as not the ONLY one that will work.\n    \n\n    # Prefer to use bins with largest capacity\n    priorities += bins_remain_cap / bins_remain_cap.max() #normalizes to value between 0-1. Helps diversify bins used\n\n    #Normalize so priorities cant be negative.\n    min_prio = priorities.min()\n    priorities -= min_prio\n\n    return priorities",
    "response_id": 19,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 32, in priority_v2\n    # This encourages filling bins up before opening new ones.\nnumpy._core._exceptions._UFuncOutputCastingError: Cannot cast ufunc 'add' output from dtype('float64') to dtype('int64') with casting rule 'same_kind'\n15\n1\n396.4588483417382\n77.7879013914236\n195\n"
  },
  {
    "stdout_filepath": "problem_iter1_response20.txt_stdout.txt",
    "code_path": "problem_iter1_code20.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Calculate remaining capacity after adding the item\n    remaining_after_add = bins_remain_cap - item\n\n    # Assign high priority to bins that can fit the item snugly\n    fit_threshold = 0.1  # Adjust this threshold as needed\n    snug_fit = np.where((remaining_after_add >= 0) & (remaining_after_add <= fit_threshold))[0]\n    priorities[snug_fit] += 10  # Give snug fits a significant boost\n\n    # Assign medium priority to bins that can fit the item\n    can_fit = np.where(remaining_after_add >= 0)[0]\n    priorities[can_fit] += 5\n\n    # Penalize bins that cannot fit the item (make them less desirable)\n    cannot_fit = np.where(remaining_after_add < 0)[0]\n    priorities[cannot_fit] -= 1\n\n    # Give higher priority to bins with less remaining capacity if they can fit.\n    # This encourages filling bins up before opening new ones.\n    priorities[can_fit] += 1 / (bins_remain_cap[can_fit] + 0.0001)  # Avoid division by zero\n\n    # Refine priority based on the percentage of the bin that the item would fill\n    fill_percentage = item / bins_remain_cap\n    fill_percentage[remaining_after_add < 0] = 0  # Only consider bins where it fits.\n    priorities += fill_percentage  # the bigger the percentage the higher priority\n\n    return priorities",
    "response_id": 20,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 396.4588483417382,
    "mi": 77.7879013914236,
    "token_count": 195.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response21.txt_stdout.txt",
    "code_path": "problem_iter1_code21.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # First, disqualify bins that cannot fit the item\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -np.inf\n    \n    # Calculate the waste if the item is placed in the bin\n    waste = bins_remain_cap - item\n    \n    # Prioritize bins with smaller waste, but only if they are feasible\n    feasible_bins = ~infeasible_bins\n    if np.any(feasible_bins): #check if any feasible bin exists\n        priorities[feasible_bins] = -waste[feasible_bins]\n\n        #Boost score for almost full bin to pack items as densely as possible.\n        almost_full_threshold = 0.1 * np.max(bins_remain_cap) #within 10% of fullest bin\n        almost_full_bins = (waste >= 0) & (waste <= almost_full_threshold) & feasible_bins\n        priorities[almost_full_bins] += 10  # Boost priority if it almost fills the bin. The boosting value is chosen emperically.\n\n        # A further enhancement is to consider that it may be useful to open up new bins.\n        # Add a small bias to each eligible bin to promote the \"new bin\" option.\n        priorities[feasible_bins] += 0.001 # Bias to not use existing bins.\n\n    return priorities",
    "response_id": 21,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 396.4588483417382,
    "mi": 77.7879013914236,
    "token_count": 195.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response22.txt_stdout.txt",
    "code_path": "problem_iter1_code22.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # High priority to bins where item fits with least remaining space\n    # and that aren't too full already\n    \n    valid_bins = bins_remain_cap >= item\n    \n    if np.any(valid_bins):\n      remaining_after_fit = bins_remain_cap[valid_bins] - item\n      \n      # Normalize remaining capacity after placing the item\n      normalized_remaining = remaining_after_fit / bins_remain_cap[valid_bins]\n      \n      # Calculate priorities - bins with the least normalized space after fit gets highest priority\n      priorities[valid_bins] = 1 - normalized_remaining\n      \n      # Bonus if remaining_after_fit is close to zero but still bigger than zero (fit almost perfectly)\n      perfect_fit_bonus = np.exp(-10*remaining_after_fit)\n      priorities[valid_bins] += perfect_fit_bonus\n      \n      # Avoid very full bins: discount priority if initial bin utilization is very high\n      utilization = 1 - bins_remain_cap[valid_bins]\n      overfull_penalty = np.where(utilization > 0.95, -100, 0) # drastically penalize almost-full bins\n      priorities[valid_bins] += overfull_penalty\n\n    # If no bins fit, penalize very full bins the least and prefer empty ones.\n    else:\n      priorities = - (1 - bins_remain_cap) # empty bins get the least negative penalty\n    \n    return priorities",
    "response_id": 22,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 396.4588483417382,
    "mi": 77.7879013914236,
    "token_count": 195.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response23.txt_stdout.txt",
    "code_path": "problem_iter1_code23.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if item <= cap:\n            # If the item fits, prioritize bins with less remaining capacity, but not too close to full\n            # Use a combination of remaining capacity and waste after packing.\n            waste = cap - item\n            priorities[i] = (1 / (waste + 1e-6)) * (1 - (waste / cap)) # Avoid division by zero and prioritize less waste\n            #priorities[i] = 1 / (cap + 1e-6)\n        else:\n            # If the item doesn't fit, assign a very low priority.\n            priorities[i] = -1e9 # Very low priority\n    return priorities",
    "response_id": 23,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 396.4588483417382,
    "mi": 77.7879013914236,
    "token_count": 195.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response24.txt_stdout.txt",
    "code_path": "problem_iter1_code24.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # 1. Feasibility: Prioritize bins that can actually fit the item.\n    feasible_bins = bins_remain_cap >= item\n    priorities[feasible_bins] += 1  # Give feasible bins a base priority\n\n    # 2. Remaining Capacity: Prioritize bins with less remaining capacity\n    #    after placing the item (First Fit Decreasing principle).\n    remaining_capacity_after_fit = bins_remain_cap - item\n    remaining_capacity_after_fit[remaining_capacity_after_fit < 0] = np.inf # Penalize infeasible bins. Set remaining capacity to infinity\n\n    # Convert remaining capacity to priority: the lower the capacity, the better. Subtract from max capacity\n    max_cap = np.max(bins_remain_cap) # Normalize so bins with high capacity aren't penalized as much.\n    capacity_priority = max_cap - remaining_capacity_after_fit \n    capacity_priority[~feasible_bins] = -np.inf # Give very low priority if item doesn't fit\n\n    priorities += capacity_priority\n\n    # 3. Bonus for being nearly full: A bin that has just enough space.\n    nearly_full_threshold = item * 1.1 # Bins that only have ~10% more than the item should be selected\n    nearly_full = (bins_remain_cap >= item) & (bins_remain_cap <= nearly_full_threshold)\n    priorities[nearly_full] += 2 # Significant bonus for being near-full\n\n    return priorities",
    "response_id": 24,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 396.4588483417382,
    "mi": 77.7879013914236,
    "token_count": 195.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response25.txt_stdout.txt",
    "code_path": "problem_iter1_code25.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # First-Fit-Decreasing-like heuristic: Prefer bins that can fit the item closely\n    fit_mask = bins_remain_cap >= item\n    if np.any(fit_mask):\n      priorities[fit_mask] = bins_remain_cap[fit_mask] - item  # Remaining capacity after fit\n      priorities[fit_mask] = 1 / (1e-9 + priorities[fit_mask]) # Avoid division by zero, invert for closer fits\n\n    # If no bin can fit, consider overflow (less preferred, avoid only if possible)\n    else:\n      priorities = -1 * (item - bins_remain_cap) # penalty for overflow, bigger penalty if overflow is bigger.\n      \n\n    # Bonus for bins that are already somewhat full, but still have some space\n    # This tries to consolidate existing partially filled bins.\n    partial_full_mask = (bins_remain_cap > 0) & (bins_remain_cap < np.max(bins_remain_cap)) # Avoid empty or max capacity bins\n    if np.any(partial_full_mask):\n      priorities[partial_full_mask] += 0.1 * (1 - bins_remain_cap[partial_full_mask]/np.max(bins_remain_cap)) #higher when less remains\n\n    return priorities",
    "response_id": 25,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 30, in priority_v2\nnumpy._core._exceptions._UFuncOutputCastingError: Cannot cast ufunc 'add' output from dtype('float64') to dtype('int64') with casting rule 'same_kind'\n15\n1\n396.4588483417382\n77.7879013914236\n195\n"
  },
  {
    "stdout_filepath": "problem_iter1_response26.txt_stdout.txt",
    "code_path": "problem_iter1_code26.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            # Prioritize bins that can fit the item\n            space_waste = cap - item\n            # Prioritize bins with less space waste (First-Fit Decreasing inspired)\n            priorities[i] = 1 / (space_waste + 1e-6)  # Adding a small constant to avoid division by zero\n            # Prioritize bins that are fuller (Almost-Full strategy)\n            priorities[i] += (1 - cap / np.max(bins_remain_cap))  # Bias towards fuller bins relative to fullest bin\n        else:\n            # Very negative priority if item doesn't fit.\n            priorities[i] = -1e9  # Very low priority for bins that can't fit\n    return priorities",
    "response_id": 26,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.99997762000203 seconds"
  },
  {
    "stdout_filepath": "problem_iter1_response27.txt_stdout.txt",
    "code_path": "problem_iter1_code27.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # 1. Feasibility: Can the item fit in the bin?\n    feasible = bins_remain_cap >= item\n    priorities[~feasible] = -np.inf  # Make infeasible bins have very low priority\n\n    # 2. Remaining Capacity: Prioritize bins with less remaining capacity after placing the item, \n    #    but only for feasible bins\n    remaining_capacity = bins_remain_cap - item\n    priorities[feasible] = -remaining_capacity[feasible]  # Minimize remaining capacity\n\n    # 3. Fill percentage: Give a boost to bins that will be filled nicely.\n    fill_percentage = (bins_remain_cap - remaining_capacity) / 1.0  # Assuming bin capacity is 1\n    \n    # 4. Bonus for bins close to full.\n    close_to_full = (fill_percentage > 0.75) & feasible  \n    priorities[close_to_full] += 10  \n\n    # 5. If no bin has space give a slight preference to bins that were most full\n    if np.all(priorities == -np.inf):\n        priorities = bins_remain_cap\n        priorities = -priorities\n    \n    return priorities",
    "response_id": 27,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 396.4588483417382,
    "mi": 77.7879013914236,
    "token_count": 195.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response28.txt_stdout.txt",
    "code_path": "problem_iter1_code28.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            # First Fit Decreasing-esque: Prefer bins that can fit the item well.\n            # Avoid fragmentation.\n            priorities[i] = (cap - item) / cap\n\n            #Improvement: Prioritize bins close to full AFTER placing the item, reducing external fragmentation\n            priorities[i] += 1 - (cap-item)/np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else 1.0 # Avoid division by zero\n\n            # Slight encouragement to use less full bins first, when all other things are equal\n            # A smaller bonus\n            priorities[i] += 0.1 * (1 - cap/np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else 0.0)\n\n\n        else:\n            priorities[i] = -1e9  # Very low priority if it doesn't fit\n    return priorities",
    "response_id": 28,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.999975869999616 seconds"
  },
  {
    "stdout_filepath": "problem_iter1_response29.txt_stdout.txt",
    "code_path": "problem_iter1_code29.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Give a high priority to bins that can fit the item snugly\n    fit_snugly = (bins_remain_cap >= item) & (bins_remain_cap <= 1.2 * item)\n    priorities[fit_snugly] += 10  # Significant boost for snug fits\n    \n    # Prioritize bins that have enough space to avoid fragmentation\n    enough_space = (bins_remain_cap >= item) & (bins_remain_cap >= 0.5)  # Avoid small fragments\n    priorities[enough_space] += 5  # Moderate boost for enough space\n\n    # Penalize bins where the item barely fits\n    barely_fits = (bins_remain_cap >= item) & (bins_remain_cap < 1.01 * item)\n    priorities[barely_fits] -= 2  # Slight penalty\n\n    # Penalize bins which are already quite full\n    full_bins = bins_remain_cap < 0.95\n    priorities[full_bins] -= (1 - bins_remain_cap[full_bins]) * 10 #More penalty on the bins more closer to the full\n\n    # Avoid bins that are too empty if we can avoid it\n    empty_ish = (bins_remain_cap >= item) & (bins_remain_cap >= 0.8)\n    priorities[empty_ish] += bins_remain_cap[empty_ish] * 0.1\n\n    # Disqualify bins that cannot fit the item\n    cannot_fit = bins_remain_cap < item\n    priorities[cannot_fit] = -np.inf\n\n    return priorities",
    "response_id": 29,
    "obj": 56.12285600319107,
    "SLOC": 15.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 396.4588483417382,
    "mi": 77.7879013914236,
    "token_count": 195.0,
    "exec_success": true
  }
]