[
  {
    "stdout_filepath": "problem_iter0_stdout0.txt",
    "code_path": "problem_iter0_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    ratios = item / bins_remain_cap\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities",
    "response_id": 0,
    "obj": 149.30195452732352,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 11.60964047443681,
    "mi": 94.04446327225541,
    "token_count": 47.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response2.txt_stdout.txt",
    "code_path": "problem_iter1_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # First-Fit Decreasing (FFD) Inspired: Prefer bins with just enough space\n    residual_space = bins_remain_cap - item\n    fit_scores = np.where(residual_space >= 0, np.exp(-np.abs(residual_space)), -np.inf)\n\n    # Give penalty to bins that are already too full\n    priorities = fit_scores\n\n    # Smallest-Fit Inspired: Fill up bins that have less capacity\n    priorities += -0.01 * bins_remain_cap # Adding a small factor since we prefer 'exact' fit\n\n    # Large item penalty: If item size is above the threshold, penalize bins.\n    large_item_threshold = 0.7\n    if item > large_item_threshold:\n      priorities -= (item - large_item_threshold)\n\n    # Avoid creating too many near-empty bins. Reward larger utilization of current bins\n    priorities += bins_remain_cap / np.sum(bins_remain_cap) if np.sum(bins_remain_cap) > 0 else 0.0\n\n    return priorities",
    "response_id": 2,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 396.4588483417382,
    "mi": 77.7879013914236,
    "token_count": 195.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response7.txt_stdout.txt",
    "code_path": "problem_iter2_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Identify bins that can fit the item\n    can_fit = bins_remain_cap >= item\n\n    if np.any(can_fit):\n        # Base priority for bins that can fit\n        priorities[can_fit] = 1.0\n\n        # Calculate remaining capacity after placing the item\n        remaining_after_placement = bins_remain_cap[can_fit] - item\n\n        # Prioritize tighter fits using a score based on the inverse of remaining space.  Add small constant to prevent divide by zero\n        priorities[can_fit] += 2.0 / (remaining_after_placement + 0.01*np.mean(bins_remain_cap))\n\n        # Bonus for bins that become nearly full after placing the item (reduces fragmentation). More generous window than before.\n        nearly_full = (remaining_after_placement >= 0) & (remaining_after_placement <= 0.2 * np.max(bins_remain_cap))\n        priorities[can_fit][nearly_full] += 3.0\n\n        # Discourage using empty bins unless the item is very large relative to bin size.\n        # If item is more than half full the empty bins can be useful.\n        empty_bin_indices = np.where(bins_remain_cap == np.max(bins_remain_cap))[0]  # Assuming initial capacity is max.\n        empty_and_fits = np.intersect1d(np.where(can_fit)[0], empty_bin_indices)\n\n        if item <= 0.5 * np.max(bins_remain_cap):\n            priorities[empty_and_fits] -= 1.0 # Slightly discourage\n\n        # Add small random value to break ties\n        priorities[can_fit] += np.random.rand(np.sum(can_fit)) * 0.1\n\n    else:\n        # No bin can fit the item. Assign very low priority.\n        priorities[:] = -10.0  # Significantly lower than before.\n\n    return priorities",
    "response_id": 7,
    "obj": 4.028719585161557,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 41.20902501875006,
    "mi": 84.34368649899291,
    "token_count": 92.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response2.txt_stdout.txt",
    "code_path": "problem_iter3_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Identify bins that can fit the item\n    can_fit = bins_remain_cap >= item\n\n    if np.any(can_fit):\n        # Base priority for bins that can fit\n        priorities[can_fit] = 1.0\n\n        # Calculate remaining capacity after placing the item\n        remaining_after_placement = bins_remain_cap[can_fit] - item\n\n        # Prioritize tighter fits using a score based on the inverse of remaining space.  Add small constant to prevent divide by zero\n        priorities[can_fit] += 2.0 / (remaining_after_placement + 0.01*np.mean(bins_remain_cap))\n\n        # Bonus for bins that become nearly full after placing the item (reduces fragmentation). More generous window than before.\n        nearly_full = (remaining_after_placement >= 0) & (remaining_after_placement <= 0.2 * np.max(bins_remain_cap))\n        priorities[can_fit][nearly_full] += 3.0\n\n        # Discourage using empty bins unless the item is very large relative to bin size.\n        # If item is more than half full the empty bins can be useful.\n        empty_bin_indices = np.where(bins_remain_cap == np.max(bins_remain_cap))[0]  # Assuming initial capacity is max.\n        empty_and_fits = np.intersect1d(np.where(can_fit)[0], empty_bin_indices)\n\n        if item <= 0.5 * np.max(bins_remain_cap):\n            priorities[empty_and_fits] -= 1.0 # Slightly discourage\n\n        # Add small random value to break ties\n        priorities[can_fit] += np.random.rand(np.sum(can_fit)) * 0.1\n\n    else:\n        # No bin can fit the item. Assign very low priority.\n        priorities[:] = -10.0  # Significantly lower than before.\n\n    return priorities",
    "response_id": 2,
    "obj": 4.01874750698045,
    "SLOC": 17.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 278.14015821251,
    "mi": 81.78862012507061,
    "token_count": 245.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response8.txt_stdout.txt",
    "code_path": "problem_iter4_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Identify bins that can fit the item\n    can_fit = bins_remain_cap >= item\n\n    if np.any(can_fit):\n        # Base priority for bins that can fit\n        priorities[can_fit] = 1.0\n\n        # Calculate remaining capacity after placing the item\n        remaining_after_placement = bins_remain_cap[can_fit] - item\n\n        # Prioritize tighter fits using a score based on the inverse of remaining space.  Add small constant to prevent divide by zero\n        priorities[can_fit] += 2.0 / (remaining_after_placement + 0.01*np.mean(bins_remain_cap))\n\n        # Bonus for bins that become nearly full after placing the item (reduces fragmentation). More generous window than before.\n        nearly_full = (remaining_after_placement >= 0) & (remaining_after_placement <= 0.2 * np.max(bins_remain_cap))\n        priorities[can_fit][nearly_full] += 3.0\n\n        # Discourage using empty bins unless the item is very large relative to bin size.\n        # If item is more than half full the empty bins can be useful.\n        empty_bin_indices = np.where(bins_remain_cap == np.max(bins_remain_cap))[0]  # Assuming initial capacity is max.\n        empty_and_fits = np.intersect1d(np.where(can_fit)[0], empty_bin_indices)\n\n        if item <= 0.5 * np.max(bins_remain_cap):\n            priorities[empty_and_fits] -= 1.0 # Slightly discourage\n        elif len(empty_and_fits) > 0:\n            priorities[empty_and_fits] += 0.5 # Slightly encourage if item is large and fits in an empty bin\n\n        # Add small random value to break ties\n        priorities[can_fit] += np.random.rand(np.sum(can_fit)) * 0.1\n\n    else:\n        # No bin can fit the item. Assign very low priority.\n        priorities[:] = -10.0  # Significantly lower than before.\n\n    # Prioritize bins with less remaining capacity to encourage filling them up\n    priorities -= 0.001 * bins_remain_cap # Add a small negative value proportional to the remaining capacity\n\n    return priorities",
    "response_id": 8,
    "obj": 3.9289988033506273,
    "SLOC": 20.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 304.37979577972794,
    "mi": 80.62868102243245,
    "token_count": 252.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response4.txt_stdout.txt",
    "code_path": "problem_iter5_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Identify bins that can fit the item\n    can_fit = bins_remain_cap >= item\n\n    if np.any(can_fit):\n        # Base priority for bins that can fit\n        priorities[can_fit] = 1.0\n\n        # Calculate remaining capacity after placing the item\n        remaining_after_placement = bins_remain_cap[can_fit] - item\n\n        # Prioritize tighter fits, stronger reward\n        priorities[can_fit] += 5.0 / (remaining_after_placement + 0.01*np.mean(bins_remain_cap))\n\n        # Bonus for bins that become nearly full after placing the item (reduces fragmentation), stronger reward. Window adjusted.\n        nearly_full = (remaining_after_placement >= 0) & (remaining_after_placement <= 0.1 * np.max(bins_remain_cap))\n        priorities[can_fit][nearly_full] += 10.0\n\n        # Discourage using empty bins unless the item is very large relative to bin size. Stronger penalty. Adaptive threshold.\n        empty_bin_indices = np.where(bins_remain_cap == np.max(bins_remain_cap))[0]  # Assuming initial capacity is max.\n        empty_and_fits = np.intersect1d(np.where(can_fit)[0], empty_bin_indices)\n\n        if item <= 0.4 * np.max(bins_remain_cap):\n            priorities[empty_and_fits] -= 5.0  # Stronger discouragement\n        elif len(empty_and_fits) > 0:\n            priorities[empty_and_fits] += 1.0 # encourage if item is large and fits in an empty bin\n\n        # Add small random value to break ties, only when needed.\n        if np.sum(can_fit) > 1:\n             priorities[can_fit] += np.random.rand(np.sum(can_fit)) * 0.01 # Smaller randomness\n\n    else:\n        # No bin can fit the item. Assign very low priority.\n        priorities[:] = -10.0\n\n    #Penalize bins with larger remaining capacity, but less strongly than rewards.\n    priorities -= 0.0005 * bins_remain_cap\n\n    return priorities",
    "response_id": 4,
    "obj": 2.921818907060227,
    "SLOC": 21.0,
    "cyclomatic_complexity": 5.0,
    "halstead": 371.2413500673362,
    "mi": 77.9417636464267,
    "token_count": 288.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response0.txt_stdout.txt",
    "code_path": "problem_iter6_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Identify bins that can fit the item\n    can_fit = bins_remain_cap >= item\n\n    if np.any(can_fit):\n        # Base priority for bins that can fit\n        priorities[can_fit] = 1.0\n\n        # Calculate remaining capacity after placing the item\n        remaining_after_placement = bins_remain_cap[can_fit] - item\n\n        # Prioritize tighter fits using a score based on the inverse of remaining space.  Add small constant to prevent divide by zero\n        priorities[can_fit] += 2.0 / (remaining_after_placement + 0.01*np.mean(bins_remain_cap))\n\n        # Bonus for bins that become nearly full after placing the item (reduces fragmentation). More generous window than before.\n        nearly_full = (remaining_after_placement >= 0) & (remaining_after_placement <= 0.2 * np.max(bins_remain_cap))\n        priorities[can_fit][nearly_full] += 3.0\n\n        # Discourage using empty bins unless the item is very large relative to bin size.\n        # If item is more than half full the empty bins can be useful.\n        empty_bin_indices = np.where(bins_remain_cap == np.max(bins_remain_cap))[0]  # Assuming initial capacity is max.\n        empty_and_fits = np.intersect1d(np.where(can_fit)[0], empty_bin_indices)\n\n        if item <= 0.5 * np.max(bins_remain_cap):\n            priorities[empty_and_fits] -= 1.0 # Slightly discourage\n        elif len(empty_and_fits) > 0: # If the item is large, prefer to put in empty bin to avoid fragmentation.\n             priorities[empty_and_fits] += 0.5\n\n        # Add small random value to break ties\n        priorities[can_fit] += np.random.rand(np.sum(can_fit)) * 0.1\n\n    else:\n        # No bin can fit the item. Assign very low priority.\n        priorities[:] = -10.0  # Significantly lower than before.\n\n    # If no bin fits, slightly prefer bins with higher remaining capacity in the hopes of fitting future smaller items.\n    if not np.any(can_fit):\n        priorities += bins_remain_cap / np.max(bins_remain_cap) * 0.1\n\n\n    return priorities",
    "response_id": 0,
    "obj": 3.8691663342640563,
    "SLOC": 21.0,
    "cyclomatic_complexity": 6.0,
    "halstead": 519.1272112606621,
    "mi": 76.78764541830671,
    "token_count": 316.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter7_response0.txt_stdout.txt",
    "code_path": "problem_iter7_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Identify bins that can fit the item\n    can_fit = bins_remain_cap >= item\n\n    if np.any(can_fit):\n        # Base priority for bins that can fit\n        priorities[can_fit] = 1.0\n\n        # Calculate remaining capacity after placing the item\n        remaining_after_placement = bins_remain_cap[can_fit] - item\n\n        # Prioritize tighter fits, stronger reward\n        priorities[can_fit] += 5.0 / (remaining_after_placement + 0.01*np.mean(bins_remain_cap))\n\n        # Bonus for bins that become nearly full after placing the item (reduces fragmentation), stronger reward. Window adjusted.\n        nearly_full = (remaining_after_placement >= 0) & (remaining_after_placement <= 0.1 * np.max(bins_remain_cap))\n        priorities[can_fit][nearly_full] += 10.0\n\n        # Discourage using empty bins unless the item is very large relative to bin size. Stronger penalty. Adaptive threshold.\n        empty_bin_indices = np.where(bins_remain_cap == np.max(bins_remain_cap))[0]  # Assuming initial capacity is max.\n        empty_and_fits = np.intersect1d(np.where(can_fit)[0], empty_bin_indices)\n\n        if item <= 0.4 * np.max(bins_remain_cap):\n            priorities[empty_and_fits] -= 5.0  # Stronger discouragement\n        elif len(empty_and_fits) > 0:\n            priorities[empty_and_fits] += 1.0 # encourage if item is large and fits in an empty bin\n\n        # Add small value to break ties, only when needed. Smaller randomness\n        \n        max_priority = np.max(priorities[can_fit])\n        close_to_max = np.isclose(priorities[can_fit], max_priority)\n        if np.sum(close_to_max) > 1:\n\n            priorities[can_fit][close_to_max] += np.random.rand(np.sum(close_to_max)) * 0.001 # Smaller randomness\n\n    else:\n        # No bin can fit the item. Assign very low priority.\n        priorities[:] = -10.0\n\n    # Adaptive penalty for larger remaining capacities, focusing on variance reduction.  Stronger at lower capacities.\n    mean_cap = np.mean(bins_remain_cap)\n    penalty_strength = 0.001 * (1 + mean_cap / (bins_remain_cap + 1e-9)) # Increased sensitivity at lower remaining capacity.\n    priorities -= penalty_strength * bins_remain_cap\n\n\n    return priorities",
    "response_id": 0,
    "obj": 2.951735141603524,
    "SLOC": 22.0,
    "cyclomatic_complexity": 5.0,
    "halstead": 458.233636365056,
    "mi": 74.82738639122894,
    "token_count": 310.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response0.txt_stdout.txt",
    "code_path": "problem_iter8_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Identify bins that can fit the item\n    can_fit = bins_remain_cap >= item\n\n    if np.any(can_fit):\n        # Base priority for bins that can fit\n        priorities[can_fit] = 1.0\n\n        # Calculate remaining capacity after placing the item\n        remaining_after_placement = bins_remain_cap[can_fit] - item\n\n        # Prioritize tighter fits, stronger reward\n        priorities[can_fit] += 5.0 / (remaining_after_placement + 0.01*np.mean(bins_remain_cap))\n\n        # Bonus for bins that become nearly full after placing the item (reduces fragmentation), stronger reward. Window adjusted.\n        nearly_full = (remaining_after_placement >= 0) & (remaining_after_placement <= 0.1 * np.max(bins_remain_cap))\n        priorities[can_fit][nearly_full] += 10.0\n\n        # Discourage using empty bins unless the item is very large relative to bin size. Stronger penalty. Adaptive threshold.\n        empty_bin_indices = np.where(bins_remain_cap == np.max(bins_remain_cap))[0]  # Assuming initial capacity is max.\n        empty_and_fits = np.intersect1d(np.where(can_fit)[0], empty_bin_indices)\n\n        if item <= 0.4 * np.max(bins_remain_cap):\n            priorities[empty_and_fits] -= 5.0  # Stronger discouragement\n        elif len(empty_and_fits) > 0:\n            priorities[empty_and_fits] += 1.0 # encourage if item is large and fits in an empty bin\n\n        # Add small random value to break ties, only when needed.\n        if np.sum(can_fit) > 1:\n             priorities[can_fit] += np.random.rand(np.sum(can_fit)) * 0.001 # Smaller randomness\n\n    else:\n        # No bin can fit the item. Assign very low priority.\n        priorities[:] = -10.0\n\n    # Adaptive penalty for larger remaining capacities, focusing on variance reduction. Stronger at lower capacities.\n    mean_cap = np.mean(bins_remain_cap)\n    penalty_strength = 0.0005 * (1 + mean_cap / (bins_remain_cap + 1e-9)) # Increased sensitivity at lower remaining capacity.\n    priorities -= penalty_strength * bins_remain_cap\n\n\n    return priorities",
    "response_id": 0,
    "obj": 2.951735141603524,
    "SLOC": 20.0,
    "cyclomatic_complexity": 4.0,
    "halstead": 417.6453580433296,
    "mi": 76.71755947543558,
    "token_count": 298.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response2.txt_stdout.txt",
    "code_path": "problem_iter9_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Identify bins that can fit the item\n    can_fit = bins_remain_cap >= item\n\n    if np.any(can_fit):\n        # Base priority for bins that can fit\n        priorities[can_fit] = 1.0\n\n        # Calculate remaining capacity after placing the item\n        remaining_after_placement = bins_remain_cap[can_fit] - item\n\n        # Prioritize tighter fits, stronger reward, scale based on item size\n        priorities[can_fit] += (5.0 + 2*item/np.max(bins_remain_cap)) / (remaining_after_placement + 0.01*np.mean(bins_remain_cap))\n\n        # Bonus for bins that become nearly full after placing the item (reduces fragmentation), stronger reward. Window adjusted adaptively\n        nearly_full = (remaining_after_placement >= 0) & (remaining_after_placement <= 0.1 * np.max(bins_remain_cap))\n        priorities[can_fit][nearly_full] += 10.0 + 5*item/np.max(bins_remain_cap)\n\n        # Discourage using empty bins unless the item is very large relative to bin size. Stronger penalty. Adaptive threshold.\n        empty_bin_indices = np.where(bins_remain_cap == np.max(bins_remain_cap))[0]  # Assuming initial capacity is max.\n        empty_and_fits = np.intersect1d(np.where(can_fit)[0], empty_bin_indices)\n\n        empty_bin_threshold = 0.3 + 0.2*np.std(bins_remain_cap)/np.max(bins_remain_cap) #Adaptive threshold\n        if item <= empty_bin_threshold * np.max(bins_remain_cap):\n            priorities[empty_and_fits] -= 5.0 - item/(empty_bin_threshold * np.max(bins_remain_cap)) # Stronger discouragement, but relax if item close to threshold.\n        elif len(empty_and_fits) > 0:\n            priorities[empty_and_fits] += 1.0 # encourage if item is large and fits in an empty bin\n\n        # Add small random value to break ties, only when needed.\n        feasible_bins = np.where(can_fit)[0]\n        if len(feasible_bins) > 1:\n             priorities[feasible_bins] += np.random.rand(len(feasible_bins)) * 0.01 # Smaller randomness\n\n    else:\n        # No bin can fit the item. Assign very low priority.\n        priorities[:] = -10.0\n\n    #Penalize bins with larger remaining capacity, but less strongly than rewards. Adaptive\n    priorities -= 0.0005 * bins_remain_cap*(1 + item/np.max(bins_remain_cap))\n\n    return priorities",
    "response_id": 2,
    "obj": 19.63502193857201,
    "SLOC": 22.0,
    "cyclomatic_complexity": 5.0,
    "halstead": 375.60221301187687,
    "mi": 76.15171959643696,
    "token_count": 301.0,
    "exec_success": true
  }
]