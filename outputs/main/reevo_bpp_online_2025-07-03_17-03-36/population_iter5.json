[
  {
    "stdout_filepath": "problem_iter4_response0.txt_stdout.txt",
    "code_path": "problem_iter4_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: Assign a large negative priority to bins that can't fit the item\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -1e9  # Large negative number\n\n    # 2. Best Fit: Prioritize bins where the remaining capacity *after* adding the item is smallest.\n    # But only for feasible bins.\n    feasible_bins = ~infeasible_bins\n    remaining_after_fit = bins_remain_cap[feasible_bins] - item\n    priorities[feasible_bins] = -remaining_after_fit  # Smaller remaining capacity gives higher priority\n\n    # 3. Relative Item Size: Penalize bins where the item occupies a small proportion of the bin's capacity.\n    # This encourages filling bins more fully and avoids placing tiny items in large bins.\n    bin_size = np.max(bins_remain_cap)  # assume all bins are same size.\n    relative_item_size = item / bin_size  # item size with respect to bin size.\n    priorities[feasible_bins] -= relative_item_size * 10  # Scale the penalty.\n\n    # 4. Moderate Fill Level: Avoid bins that are *almost* full after adding the item.\n    # This can lead to fragmentation, as it becomes difficult to place larger items in nearly full bins.\n    almost_full = (bins_remain_cap[feasible_bins] - item) < (bin_size * 0.1)\n    priorities[feasible_bins][almost_full] -= 5  # Slight penalty for almost full bins.\n\n    #5. Prefer bins with higher fill ratio before adding the item, but only if item fits\n    fill_ratio_before = (bin_size - bins_remain_cap[feasible_bins]) / bin_size\n    priorities[feasible_bins] += fill_ratio_before * 2\n\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response1.txt_stdout.txt",
    "code_path": "problem_iter4_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_size = np.max(bins_remain_cap) # assume all bins are same size.\n\n    # 1. Feasibility: Assign a large negative priority to bins that can't fit the item\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -1e9  # Large negative number\n\n    # 2. Best Fit: Prioritize bins where the remaining capacity *after* adding the item is smallest.\n    feasible_bins = ~infeasible_bins\n    remaining_after_fit = bins_remain_cap[feasible_bins] - item\n    priorities[feasible_bins] = -remaining_after_fit # Smaller remaining capacity gives higher priority\n\n    #3. Relative Item Size: Penalize bins where the item occupies a small proportion of the bin's capacity.\n    relative_item_size = item / bin_size #item size with respect to bin size.\n    priorities[feasible_bins] -= relative_item_size * 10 #Scale the penalty.\n\n    #4. Moderate Fill Level: Avoid bins that are *almost* full after adding the item.\n    almost_full = (bins_remain_cap[feasible_bins] - item) < (bin_size * 0.1)\n    priorities[feasible_bins][almost_full] -= 5 #Slight penalty for almost full bins.\n    \n    #5. Encourage usage of emptier bins initially\n    empty_bins = bins_remain_cap == bin_size\n    priorities[empty_bins] += 2 #Slight bonus for empty bins\n\n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response2.txt_stdout.txt",
    "code_path": "problem_iter4_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Calculate wasted space if item is placed in each bin\n    wasted_space = bins_remain_cap - item\n\n    # Assign high priority to bins where item fits and wasted space is minimized\n    fit_mask = wasted_space >= 0\n    if np.any(fit_mask):\n        # Prioritize tight fits proportionally\n        priorities[fit_mask] = 1 / (wasted_space[fit_mask] + 1e-6)  # Avoid division by zero and prioritize smaller wasted space\n    else:\n        # If no bin can fit the item, penalize overfilled bins linearly\n        overfill_amount = item - bins_remain_cap\n        priorities = -overfill_amount  # Linear penalty for overfill\n        \n    return priorities",
    "response_id": 2,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response3.txt_stdout.txt",
    "code_path": "problem_iter4_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: Assign a large negative priority to bins that can't fit the item\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -1e9  # Large negative number\n\n    # 2. Best Fit: Prioritize bins where the remaining capacity *after* adding the item is smallest.\n    # But only for feasible bins.\n    feasible_bins = ~infeasible_bins\n    remaining_after_fit = bins_remain_cap[feasible_bins] - item\n    priorities[feasible_bins] = -remaining_after_fit # Smaller remaining capacity gives higher priority\n\n    #3. Relative Item Size: Penalize bins where the item occupies a small proportion of the bin's capacity.\n    #This encourages filling bins more fully and avoids placing tiny items in large bins.\n    bin_size = np.max(bins_remain_cap) # assume all bins are same size.\n    relative_item_size = item / bin_size #item size with respect to bin size.\n    priorities[feasible_bins] -= relative_item_size * 10 #Scale the penalty.\n\n    #4. Moderate Fill Level: Avoid bins that are *almost* full after adding the item.\n    # This can lead to fragmentation, as it becomes difficult to place larger items in nearly full bins.\n    almost_full = (bins_remain_cap[feasible_bins] - item) < (bin_size * 0.1)\n    priorities[feasible_bins][almost_full] -= 5 #Slight penalty for almost full bins.\n\n    #5. Encourage filling bins that are already somewhat full.\n    #Give a bonus inversely proportional to the remaining capacity *before* adding the item.\n    already_full = bins_remain_cap[feasible_bins] < (bin_size * 0.9) # Define what constitutes 'somewhat full'. This is tunable\n    priorities[feasible_bins][already_full] += (bin_size - bins_remain_cap[feasible_bins][already_full]) / bin_size * 2  # Give bonus. Scale to [0, 2].\n\n    return priorities",
    "response_id": 3,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response4.txt_stdout.txt",
    "code_path": "problem_iter4_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Rule 1: Perfect Fit - Highest Priority\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    priorities[perfect_fit] = np.inf\n\n    # Rule 2: Prioritize bins that can fit the item, minimizing wasted space.\n    fitting_bins = bins_remain_cap >= item\n    if np.any(fitting_bins):\n        space_waste = bins_remain_cap[fitting_bins] - item\n        # Prioritize smaller waste, but also consider the remaining capacity\n        priorities[fitting_bins] = 1 / (space_waste + 1e-9) # Adding a small value to avoid division by zero\n        # Scale priority by how full the bin would be\n        fill_ratio = item / bins_remain_cap[fitting_bins]\n        priorities[fitting_bins] *= (1 - np.abs(fill_ratio - 0.75)) # Prefer bins closer to 75% full after packing.\n        \n        # Heavily penalize almost full bins\n        almost_full = (fill_ratio > 0.95) & fitting_bins\n        priorities[almost_full] *= 0.01 # Reduce the priority significantly if almost full\n\n    # Rule 3: Assign a very low priority if the item doesn't fit\n    not_fitting = bins_remain_cap < item\n    priorities[not_fitting] = -np.inf\n\n    return priorities",
    "response_id": 4,
    "obj": 4.547267650578394,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response5.txt_stdout.txt",
    "code_path": "problem_iter4_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: Assign a large negative priority to bins that can't fit the item\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -1e9  # Large penalty for infeasibility\n\n    # 2. Best Fit: Prioritize bins with the smallest remaining capacity *after* adding the item\n    feasible_bins = ~infeasible_bins\n    remaining_after_fit = bins_remain_cap[feasible_bins] - item\n\n    # Prioritize smaller waste, but avoid bins that are too full (waste close to zero)\n    # Aim for moderate fill levels to accommodate future items\n\n    priorities[feasible_bins] = -remaining_after_fit  # Primary Best Fit scoring\n\n    # Scale the remaining cap and subtract it - encourages moderate fill\n    if np.max(bins_remain_cap) != 0:\n        priorities[feasible_bins] -= (bins_remain_cap[feasible_bins] / np.max(bins_remain_cap)) * 0.001\n\n    # Add a bonus for bins that are reasonably full but not too full\n    # This helps to consolidate items into fewer bins and avoids excessive fragmentation.\n    reasonable_fill = (bins_remain_cap[feasible_bins] > item) & (remaining_after_fit > 0.1 * np.max(bins_remain_cap)) # tuning 0.1\n    priorities[feasible_bins][reasonable_fill] += 0.0005\n    \n    return priorities",
    "response_id": 5,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response6.txt_stdout.txt",
    "code_path": "problem_iter4_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: Assign a large negative priority to bins that can't fit the item\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -1e9  # Large negative number\n\n    # 2. Best Fit: Prioritize bins where the remaining capacity *after* adding the item is smallest.\n    # But only for feasible bins.\n    feasible_bins = ~infeasible_bins\n    remaining_after_fit = bins_remain_cap[feasible_bins] - item\n    priorities[feasible_bins] = -remaining_after_fit  # Smaller remaining capacity gives higher priority\n\n    # 3. Relative Item Size: Penalize bins where the item occupies a small proportion of the bin's capacity.\n    # This encourages filling bins more fully and avoids placing tiny items in large bins.\n    bin_size = np.max(bins_remain_cap)  # assume all bins are same size.\n    relative_item_size = item / bin_size  # item size with respect to bin size.\n    priorities[feasible_bins] -= relative_item_size * 10  # Scale the penalty.\n\n    # 4. Moderate Fill Level: Avoid bins that are *almost* full after adding the item, but also penalize very empty bins.\n    # This can lead to fragmentation, as it becomes difficult to place larger items in nearly full bins.\n    almost_full = (bins_remain_cap[feasible_bins] - item) < (bin_size * 0.1)\n    priorities[feasible_bins][almost_full] -= 5  # Slight penalty for almost full bins.\n\n    # Penalize bins that would be very empty after placing the item\n    very_empty = (bins_remain_cap[feasible_bins] - item) > (bin_size * 0.9)\n    priorities[feasible_bins][very_empty] -= 3 # Small penalty for almost empty bins\n    \n    # 5. Reward fill ratio closer to optimal fill\n    optimal_fill = 0.75\n    fill_ratio = item / bin_size\n    priorities[feasible_bins] -= abs(fill_ratio - optimal_fill) * 5 # penalize deviation from optimal\n\n    return priorities",
    "response_id": 6,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response7.txt_stdout.txt",
    "code_path": "problem_iter4_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: Assign a large negative priority to bins that can't fit the item\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -1e9  # Large penalty for infeasibility\n\n    # 2. Best Fit: Prioritize bins with the smallest remaining capacity *after* adding the item\n    feasible_bins = ~infeasible_bins\n    remaining_after_fit = bins_remain_cap[feasible_bins] - item\n\n    # Prioritize smaller waste, but avoid bins that are too full (waste close to zero)\n    # Aim for moderate fill levels to accommodate future items\n\n    priorities[feasible_bins] = -remaining_after_fit  # Primary Best Fit scoring\n\n    # Scale the remaining capacity and subtract it (normalize to 0-1)\n    if np.any(feasible_bins):  # only perform normalization if there are feasible bins\n        max_cap = np.max(bins_remain_cap[feasible_bins])\n        if max_cap > 0:\n            priorities[feasible_bins] -= (bins_remain_cap[feasible_bins] / max_cap) * 0.001\n        \n    return priorities",
    "response_id": 7,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response8.txt_stdout.txt",
    "code_path": "problem_iter4_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    fit_mask = bins_remain_cap >= item\n    \n    if np.any(fit_mask):\n        # Prioritize bins with smallest remaining capacity after placing the item (Best-Fit)\n        priorities[fit_mask] = 1.0 / (bins_remain_cap[fit_mask] - item + 1e-9)\n    \n    # Assign very low priority to bins that cannot fit the item\n    priorities[~fit_mask] = -1e9\n    \n    return priorities",
    "response_id": 8,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response9.txt_stdout.txt",
    "code_path": "problem_iter4_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # 1. Feasibility: Infeasible bins get a large negative priority.\n    feasible_bins = bins_remain_cap >= item\n    priorities[~feasible_bins] = -1e9\n\n    # 2. Remaining Capacity: Prefer bins with less remaining capacity *after* placing the item.\n    remaining_after_fit = bins_remain_cap - item\n    \n    # Only consider remaining capacity for feasible bins, set infeasible remaining to large number\n    remaining_after_fit_adj = np.copy(remaining_after_fit)\n    remaining_after_fit_adj[~feasible_bins] = np.max(bins_remain_cap) + item # some large value\n\n    # Normalize remaining capacity (smaller is better)\n    max_remaining = np.max(remaining_after_fit_adj)\n    normalized_remaining = 1 - (remaining_after_fit_adj / max_remaining)\n    priorities += normalized_remaining\n\n    # 3. Fragmentation Penalty: Penalize bins that will leave a small unusable fragment.\n    fragment_threshold = 0.2  # Define a threshold for small fragments relative to bin size\n    fragment_penalty = 0.7\n\n    fragment_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit <= fragment_threshold * np.max(bins_remain_cap))\n    priorities[fragment_mask] -= fragment_penalty\n\n    # 4. Reward Near-Perfect Fit: Encourage using bins that almost perfectly fit the item.\n    near_perfect_fit_threshold = 0.1\n    near_perfect_fit_bonus = 0.5\n    near_perfect_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit <= near_perfect_fit_threshold * np.max(bins_remain_cap))\n    priorities[near_perfect_mask] += near_perfect_fit_bonus\n\n    # 5. Encourage usage of emptier bins when possible, to reduce # of bins used\n    # Only apply if some bins are quite empty\n    empty_bin_threshold = 0.9\n    if np.any(bins_remain_cap >= empty_bin_threshold * np.max(bins_remain_cap)):\n        empty_bin_bonus = 0.2\n        empty_bin_mask = feasible_bins & (bins_remain_cap >= empty_bin_threshold * np.max(bins_remain_cap))\n        priorities[empty_bin_mask] += empty_bin_bonus\n\n    return priorities",
    "response_id": 9,
    "obj": 3.9888312724371757,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response0.txt_stdout.txt",
    "code_path": "problem_iter5_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: Infeasible bins get a large negative priority.\n    feasible_bins = bins_remain_cap >= item\n    priorities[~feasible_bins] = -1e9\n\n    # 2. Best Fit: Prioritize bins where the remaining capacity after adding the item is minimized.\n    remaining_after_fit = bins_remain_cap - item\n    \n    # Handle infeasible bins to avoid errors during normalization.\n    remaining_after_fit_adj = np.copy(remaining_after_fit)\n    remaining_after_fit_adj[~feasible_bins] = np.max(bins_remain_cap) + item\n\n    # Normalize remaining capacity (smaller is better) - Best Fit principle\n    max_remaining = np.max(remaining_after_fit_adj)\n    normalized_remaining = 1 - (remaining_after_fit_adj / max_remaining)\n    priorities += normalized_remaining\n\n    # 3. Penalize Small Relative Item Sizes:\n    # If the item is small relative to the bin capacity, slightly penalize its usage.\n    item_size_threshold = 0.1 # item must be at least 10% of largest bin\n    if item <= item_size_threshold * np.max(bins_remain_cap):\n      priorities[feasible_bins] -= 0.1  # Small penalty\n\n    # 4. Penalize Near-Full Bins:\n    # Avoid filling bins that are already almost full. This encourages using emptier bins first.\n    near_full_threshold = 0.9\n    near_full_penalty = 0.2\n    near_full_bins = feasible_bins & (bins_remain_cap <= near_full_threshold * np.max(bins_remain_cap)) & (bins_remain_cap > item) # already quite full\n    priorities[near_full_bins] -= near_full_penalty\n\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response1.txt_stdout.txt",
    "code_path": "problem_iter5_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: Infeasible bins get a very low priority.\n    feasible_bins = bins_remain_cap >= item\n    priorities[~feasible_bins] = -1e9\n\n    # 2. Best Fit: Prioritize bins with the least remaining capacity *after* placing the item.\n    remaining_after_fit = bins_remain_cap - item\n\n    # Only consider remaining capacity for feasible bins, set infeasible remaining to large number\n    remaining_after_fit_adj = np.copy(remaining_after_fit)\n    remaining_after_fit_adj[~feasible_bins] = np.max(bins_remain_cap) + item # some large value\n\n    # Normalize remaining capacity (smaller is better) within the feasible bins\n    min_remaining = np.min(remaining_after_fit_adj[feasible_bins]) if np.any(feasible_bins) else 0\n    max_remaining = np.max(remaining_after_fit_adj) if np.any(feasible_bins) else 1\n\n    if max_remaining > min_remaining:\n        normalized_remaining = 1 - ((remaining_after_fit_adj - min_remaining) / (max_remaining - min_remaining))\n    else:\n        normalized_remaining = np.ones_like(remaining_after_fit_adj) #All are the same.\n\n\n    priorities += normalized_remaining\n\n    # 3. Penalize Small Relative Item Sizes: If the item is very small compared to bin size, deprioritize\n    relative_size = item / np.max(bins_remain_cap)\n    small_item_threshold = 0.1 #tune\n    small_item_penalty = 0.3 #tune\n\n    if relative_size < small_item_threshold:\n       priorities[feasible_bins] -= small_item_penalty\n\n    # 4. Penalize Near-Full Bins: Deprioritize bins that are nearly full *before* placing the item to avoid creating almost-full bins.\n    near_full_threshold = 0.9 #tune\n    near_full_penalty = 0.5 #tune\n\n    near_full_bins = bins_remain_cap >=0 #temp\n    near_full_bins[feasible_bins] = bins_remain_cap[feasible_bins] >= (near_full_threshold * np.max(bins_remain_cap))\n    priorities[near_full_bins] -= near_full_penalty\n\n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response2.txt_stdout.txt",
    "code_path": "problem_iter5_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap) # Assume all bins have same capacity.\n\n    # 1. Feasibility: Infeasible bins get the lowest priority.\n    feasible_bins = bins_remain_cap >= item\n    priorities[~feasible_bins] = -np.inf\n\n    # 2. Best Fit: Prioritize bins that result in the least remaining capacity after placement.\n    remaining_after_fit = bins_remain_cap - item\n    remaining_after_fit[~feasible_bins] = bin_capacity  # Assign large values to infeasible bins\n\n    # Normalize remaining capacity to a range [0, 1], lower is better\n    normalized_remaining = remaining_after_fit / bin_capacity\n    priorities[feasible_bins] -= normalized_remaining[feasible_bins] # Lower remaining is better, so we subtract\n\n    # 3. Fragmentation Penalty: Penalize bins if the remaining capacity is too small relative to the bin size.\n    fragment_threshold = 0.15  # Threshold for small fragments (relative to bin capacity)\n    fragment_penalty = 0.5\n\n    fragment_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit <= fragment_threshold * bin_capacity)\n    priorities[fragment_mask] -= fragment_penalty\n\n    # 4. Near-Full Penalty: Discourage filling bins too close to their capacity to avoid future issues\n    near_full_threshold = 0.95\n    near_full_penalty = 0.3\n\n    near_full_mask = feasible_bins & (bins_remain_cap <= bin_capacity) & ((bins_remain_cap - item) <= (1 - near_full_threshold) * bin_capacity) & (bins_remain_cap - item > 0) # Added some more conditions for stability\n    priorities[near_full_mask] -= near_full_penalty\n\n    return priorities",
    "response_id": 2,
    "obj": 6.252493019545279,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response3.txt_stdout.txt",
    "code_path": "problem_iter5_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: Infeasible bins get the lowest priority.\n    feasible_bins = bins_remain_cap >= item\n    priorities[~feasible_bins] = -np.inf\n\n    # 2. Best Fit: Maximize remaining capacity after placing the item.\n    remaining_after_fit = bins_remain_cap - item\n    priorities[feasible_bins] = -remaining_after_fit[feasible_bins]  # Smaller remaining capacity is better\n    \n    # 3. Fragmentation Penalty: Penalize creating small fragments.\n    fragment_threshold = 0.15\n    fragment_penalty = 0.5\n    fragment_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit <= fragment_threshold * np.max(bins_remain_cap))\n    priorities[fragment_mask] -= fragment_penalty\n\n    # 4. Near-full penalty. Penalize bins that are almost full after adding an item.\n    near_full_threshold = 0.95\n    near_full_penalty = 0.3\n    near_full_mask = feasible_bins & ((bins_remain_cap - item) <= (1-near_full_threshold) * np.max(bins_remain_cap)) & ((bins_remain_cap - item) >= 0)\n    priorities[near_full_mask] -= near_full_penalty\n    \n    return priorities",
    "response_id": 3,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response4.txt_stdout.txt",
    "code_path": "problem_iter5_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: Infeasible bins get a very low priority.\n    feasible_bins = bins_remain_cap >= item\n    priorities[~feasible_bins] = -1e9\n\n    # 2. Best Fit: Prioritize bins that result in the least remaining capacity.\n    remaining_after_fit = bins_remain_cap - item\n    \n    # Only consider remaining capacity for feasible bins, set infeasible remaining to large number\n    remaining_after_fit_adj = np.copy(remaining_after_fit)\n    remaining_after_fit_adj[~feasible_bins] = np.max(bins_remain_cap) + item # some large value\n\n    # Normalize remaining capacity (smaller is better)\n    max_remaining = np.max(remaining_after_fit_adj)\n    normalized_remaining = 1 - (remaining_after_fit_adj / max_remaining)\n    priorities += normalized_remaining\n\n    # 3. Penalize small relative item sizes\n    relative_item_size = item / np.max(bins_remain_cap)\n    if relative_item_size < 0.1:\n        priorities -= 0.1  # Small penalty for very small items\n\n    # 4. Penalize near-full bins (risk of creating unusable fragments)\n    near_full_threshold = 0.9\n    near_full_bins = bins_remain_cap / np.max(bins_remain_cap) > near_full_threshold\n    priorities[near_full_bins & feasible_bins] -= 0.2 # Moderate penalty for near-full bins\n\n    return priorities",
    "response_id": 4,
    "obj": 4.048663741523748,
    "exec_success": true
  }
]