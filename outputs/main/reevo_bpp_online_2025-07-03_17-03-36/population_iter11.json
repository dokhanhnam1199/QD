[
  {
    "stdout_filepath": "problem_iter10_response0.txt_stdout.txt",
    "code_path": "problem_iter10_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    max_bin_cap = np.max(bins_remain_cap)\n\n    # 1. Feasibility: Infeasible bins get a large negative priority.\n    feasible_bins = bins_remain_cap >= item\n    priorities[~feasible_bins] = -1e9\n\n    # 2. Best Fit (Normalized): Prefer bins where the remaining capacity after placement is minimal\n    remaining_after_fit = bins_remain_cap - item\n    remaining_after_fit_adj = np.where(feasible_bins, remaining_after_fit, max_bin_cap * 2)  # Large value for infeasible\n    normalized_remaining = 1 - (remaining_after_fit_adj / (max_bin_cap + 1e-6))  # Normalize to [0, 1], adding small value to prevent divide by zero\n    priorities += normalized_remaining\n\n    # 3. Fragmentation Penalty: Penalize bins that will leave a small unusable fragment.\n    fragment_threshold = 0.12\n    fragment_penalty = 0.5\n    fragment_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit <= fragment_threshold * max_bin_cap)\n    priorities[fragment_mask] -= fragment_penalty\n\n    # 4. Reward Near-Perfect Fit: Encourage using bins that almost perfectly fit the item.\n    near_perfect_fit_threshold = 0.06\n    near_perfect_fit_bonus = 0.65\n    near_perfect_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit <= near_perfect_fit_threshold * max_bin_cap)\n    priorities[near_perfect_mask] += near_perfect_fit_bonus\n\n    # 5. Encourage usage of emptier bins when possible, to reduce # of bins used, but only if item isn't too big\n    empty_bin_threshold = 0.85\n    empty_bin_bonus = 0.35\n    item_size_threshold = 0.6\n    empty_bin_mask = feasible_bins & (bins_remain_cap >= empty_bin_threshold * max_bin_cap) & (item <= item_size_threshold * max_bin_cap)\n    priorities[empty_bin_mask] += empty_bin_bonus\n\n    # 6. Penalize filling near-full bins, especially if larger bins are available. Stronger penalty\n    near_full_threshold = 0.15\n    near_full_penalty = 0.5\n    if np.any(bins_remain_cap >= empty_bin_threshold * max_bin_cap):\n        near_full_mask = feasible_bins & (bins_remain_cap <= near_full_threshold * max_bin_cap)\n        priorities[near_full_mask] -= near_full_penalty\n\n    # 7. Add a slight penalty for using bins which were completely empty before - reduced penalty\n    previously_empty_penalty = 0.15\n    previously_empty_mask = (bins_remain_cap == max_bin_cap) & feasible_bins\n    priorities[previously_empty_mask] -= previously_empty_penalty\n\n    # 8. Prioritize bins with capacities closest to item size if there are multiple feasible bins\n    if np.sum(feasible_bins) > 1:\n        size_diff = np.abs(bins_remain_cap[feasible_bins] - item)\n        normalized_size_diff = 1 - (size_diff / (max_bin_cap + 1e-6))\n        priorities[feasible_bins] += normalized_size_diff * 0.2  # Add a fraction of this score\n\n    return priorities",
    "response_id": 0,
    "obj": 4.637016354208217,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response1.txt_stdout.txt",
    "code_path": "problem_iter10_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)\n\n    # Normalize item size and remaining capacities\n    normalized_item = item / bin_capacity\n    normalized_bins_remain_cap = bins_remain_cap / bin_capacity\n\n    # 1. Feasibility: Infeasible bins get a very large negative priority.\n    feasible_bins = normalized_bins_remain_cap >= normalized_item\n    priorities[~feasible_bins] = -1e9\n\n    # 2. Best Fit: Prefer bins where the remaining capacity after placement is minimal\n    remaining_after_fit = normalized_bins_remain_cap - normalized_item\n    remaining_after_fit[~feasible_bins] = 2  # Set to large value for infeasible bins\n    best_fit_priority = -remaining_after_fit  # Smaller remaining is better\n    priorities += best_fit_priority\n\n    # 3. Moderate Fill: Penalize bins that are nearly full or nearly empty *before* item placement.\n    nearly_full_threshold = 0.9\n    nearly_empty_threshold = 0.1\n    moderate_fill_penalty = 0.3\n\n    nearly_full_bins = normalized_bins_remain_cap > nearly_full_threshold\n    nearly_empty_bins = normalized_bins_remain_cap < nearly_empty_threshold\n\n    priorities[feasible_bins & nearly_full_bins] -= moderate_fill_penalty\n    priorities[feasible_bins & nearly_empty_bins] -= moderate_fill_penalty\n\n    # 4. Fragmentation Penalty: Heavily penalize bins that will create a very small fragment.\n    fragment_threshold = 0.15\n    fragment_penalty = 0.8\n    fragment_mask = feasible_bins & (remaining_after_fit >= 0) & (remaining_after_fit <= fragment_threshold)\n    priorities[fragment_mask] -= fragment_penalty\n\n    # 5. Reward Near-Perfect Fit: Significant bonus for near perfect fits\n    near_perfect_fit_threshold = 0.05\n    near_perfect_fit_bonus = 0.7\n    near_perfect_mask = feasible_bins & (remaining_after_fit >= 0) & (remaining_after_fit <= near_perfect_fit_threshold)\n    priorities[near_perfect_mask] += near_perfect_fit_bonus\n\n    # 6. Small Item Penalty: Slightly discourage placing very small items into partially filled bins.\n    small_item_threshold = 0.1\n    small_item_penalty = 0.1\n    small_item = normalized_item < small_item_threshold\n    if small_item:\n        partially_filled_bins = feasible_bins & (normalized_bins_remain_cap < 1)\n        priorities[partially_filled_bins] -= small_item_penalty\n\n    # 7. Edge Case Handling: Give empty bins a slight preference if no good fit exists.\n    empty_bin_bonus = 0.05\n    empty_bins = normalized_bins_remain_cap == 1\n    if not np.any(near_perfect_mask) and np.any(feasible_bins & empty_bins):\n        priorities[feasible_bins & empty_bins] += empty_bin_bonus\n\n    # 8. Normalize Priorities: Scale priorities to a reasonable range\n    max_priority = np.max(priorities[feasible_bins]) if np.any(feasible_bins) else 0\n    min_priority = np.min(priorities[feasible_bins]) if np.any(feasible_bins) else 0\n\n    if max_priority > min_priority:\n        priorities[feasible_bins] = (priorities[feasible_bins] - min_priority) / (max_priority - min_priority)\n    elif np.any(feasible_bins):\n        priorities[feasible_bins] = 0.5  # Give all feasible bins a neutral priority if they are all the same.\n\n    return priorities",
    "response_id": 1,
    "obj": 2.7822098125249393,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response2.txt_stdout.txt",
    "code_path": "problem_iter10_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)\n\n    # 1. Feasibility: Infeasible bins get a very large negative priority.\n    feasible_bins = bins_remain_cap >= item\n    priorities[~feasible_bins] = -1e9\n\n    # 2. Best Fit: Prefer bins where the remaining capacity after placement is minimal\n    remaining_after_fit = bins_remain_cap - item\n    remaining_after_fit[~feasible_bins] = bin_capacity * 2  # Set to large value for infeasible bins\n    best_fit_priority = -remaining_after_fit / bin_capacity  # Normalize & invert: smaller remaining is better\n    priorities += best_fit_priority\n\n    # 3. Moderate Fill: Penalize bins that are nearly full or nearly empty *before* item placement.\n    nearly_full_threshold = 0.9\n    nearly_empty_threshold = 0.1\n    moderate_fill_penalty = 0.3\n\n    nearly_full_bins = (bins_remain_cap / bin_capacity) > nearly_full_threshold\n    nearly_empty_bins = (bins_remain_cap / bin_capacity) < nearly_empty_threshold\n\n    priorities[feasible_bins & nearly_full_bins] -= moderate_fill_penalty\n    priorities[feasible_bins & nearly_empty_bins] -= moderate_fill_penalty\n\n    # 4. Fragmentation Penalty: Heavily penalize bins that will create a very small fragment.\n    fragment_threshold = 0.15\n    fragment_penalty = 0.8\n    fragment_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit / bin_capacity <= fragment_threshold)\n    priorities[fragment_mask] -= fragment_penalty\n\n    # 5. Reward Near-Perfect Fit: Significant bonus for near perfect fits\n    near_perfect_fit_threshold = 0.05\n    near_perfect_fit_bonus = 0.7\n    near_perfect_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit / bin_capacity <= near_perfect_fit_threshold)\n    priorities[near_perfect_mask] += near_perfect_fit_bonus\n\n    # 6. Small Item Penalty: Slightly discourage placing very small items into partially filled bins.  Also, give a slight preference to placing small items in empty bins.\n    small_item_threshold = 0.1\n    small_item_penalty = 0.1\n    small_item = item / bin_capacity < small_item_threshold\n    if small_item:\n        partially_filled_bins = feasible_bins & (bins_remain_cap < bin_capacity) & (bins_remain_cap > 0)\n        empty_bins = bins_remain_cap == bin_capacity\n        priorities[partially_filled_bins] -= small_item_penalty\n        priorities[empty_bins] += small_item_penalty / 2  # Slight preference for empty bins\n\n    # 7. Bin balancing: Try to balance the fill levels of the bins\n    bin_fill_levels = (bin_capacity - bins_remain_cap) / bin_capacity\n    mean_fill_level = np.mean(bin_fill_levels)\n    bin_balancing_penalty = 0.05 * np.abs(bin_fill_levels - mean_fill_level)\n    priorities -= bin_balancing_penalty\n\n    # Simplified rule: Slightly prefer bins with capacity closest to item size\n    priority_item_fit = -np.abs(bins_remain_cap - item) / bin_capacity\n    priorities += 0.02*priority_item_fit #Scale to keep it subtle\n\n    # 8. Encourage using bins that are already somewhat filled, but not too full.\n    # This can help consolidate items and leave more empty bins for later, larger items.\n    medium_filled_threshold_lower = 0.3\n    medium_filled_threshold_upper = 0.7\n    medium_filled_bonus = 0.08\n\n    medium_filled_bins = feasible_bins & \\\n                         (bins_remain_cap / bin_capacity < 1 - medium_filled_threshold_lower) & \\\n                         (bins_remain_cap / bin_capacity > 1 - medium_filled_threshold_upper)\n\n    priorities[medium_filled_bins] += medium_filled_bonus\n\n    return priorities",
    "response_id": 2,
    "obj": 3.2708416433984797,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response3.txt_stdout.txt",
    "code_path": "problem_iter10_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)\n\n    # 1. Feasibility: Infeasible bins get a very large negative priority.\n    feasible_bins = bins_remain_cap >= item\n    priorities[~feasible_bins] = -1e9\n\n    # 2. Best Fit: Prefer bins where the remaining capacity after placement is minimal\n    remaining_after_fit = bins_remain_cap - item\n    remaining_after_fit[~feasible_bins] = bin_capacity * 2  # Set to large value for infeasible bins\n    best_fit_priority = -remaining_after_fit / bin_capacity  # Normalize & invert: smaller remaining is better\n    priorities += best_fit_priority\n\n    # 3. Moderate Fill Avoidance (Before Placement): Penalize bins close to full or empty.\n    nearly_full_threshold = 0.85\n    nearly_empty_threshold = 0.15\n    moderate_fill_penalty = 0.25\n\n    nearly_full_bins = (bins_remain_cap / bin_capacity) > nearly_full_threshold\n    nearly_empty_bins = (bins_remain_cap / bin_capacity) < nearly_empty_threshold\n\n    priorities[feasible_bins & nearly_full_bins] -= moderate_fill_penalty\n    priorities[feasible_bins & nearly_empty_bins] -= moderate_fill_penalty\n\n    # 4. Fragmentation Penalty: Heavily penalize bins that will create a very small fragment.\n    fragment_threshold = 0.1\n    fragment_penalty = 0.7\n    fragment_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit / bin_capacity <= fragment_threshold)\n    priorities[fragment_mask] -= fragment_penalty\n\n    # 5. Reward Near-Perfect Fit: Significant bonus for near perfect fits\n    near_perfect_fit_threshold = 0.05\n    near_perfect_fit_bonus = 0.65\n    near_perfect_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit / bin_capacity <= near_perfect_fit_threshold)\n    priorities[near_perfect_mask] += near_perfect_fit_bonus\n\n    # 6. Small Item Penalty: Slightly discourage placing very small items into partially filled bins. Increased penalty. More empty = More penalty\n    small_item_threshold = 0.1\n    if item / bin_capacity < small_item_threshold:\n        small_item_penalty = 0.2 * (1 - bins_remain_cap / bin_capacity) # Normalize remaining cap, invert, scale by penalty\n        small_item_penalty[~feasible_bins] = 0\n        priorities -= small_item_penalty\n\n    # 7. Large Item Bonus: Encourage placing large items into emptier bins.\n    large_item_threshold = 0.7\n    if item / bin_capacity > large_item_threshold:\n        large_item_bonus = 0.2 * (bins_remain_cap / bin_capacity)\n        large_item_bonus[~feasible_bins] = 0\n        priorities += large_item_bonus\n\n    return priorities",
    "response_id": 3,
    "obj": 4.726765057838063,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response4.txt_stdout.txt",
    "code_path": "problem_iter10_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)\n\n    # 1. Feasibility: Infeasible bins get a very large negative priority.\n    feasible_bins = bins_remain_cap >= item\n    priorities[~feasible_bins] = -1e9\n\n    # 2. Best Fit: Prefer bins where the remaining capacity after placement is minimal\n    remaining_after_fit = bins_remain_cap - item\n    remaining_after_fit[~feasible_bins] = bin_capacity * 2  # Set to large value for infeasible bins\n    best_fit_priority = -remaining_after_fit / bin_capacity  # Normalize & invert: smaller remaining is better\n    priorities += best_fit_priority\n\n    # 3. Moderate Fill: Penalize bins that are nearly full or nearly empty *before* item placement.\n    nearly_full_threshold = 0.9\n    nearly_empty_threshold = 0.1\n    moderate_fill_penalty = 0.3\n\n    nearly_full_bins = (bins_remain_cap / bin_capacity) > nearly_full_threshold\n    nearly_empty_bins = (bins_remain_cap / bin_capacity) < nearly_empty_threshold\n\n    priorities[feasible_bins & nearly_full_bins] -= moderate_fill_penalty\n    priorities[feasible_bins & nearly_empty_bins] -= moderate_fill_penalty\n\n    # 4. Fragmentation Penalty: Heavily penalize bins that will create a very small fragment.\n    fragment_threshold = 0.15\n    fragment_penalty = 0.8\n    fragment_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit / bin_capacity <= fragment_threshold)\n    priorities[fragment_mask] -= fragment_penalty\n\n    # 5. Reward Near-Perfect Fit: Significant bonus for near perfect fits\n    near_perfect_fit_threshold = 0.05\n    near_perfect_fit_bonus = 0.7\n    near_perfect_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit / bin_capacity <= near_perfect_fit_threshold)\n    priorities[near_perfect_mask] += near_perfect_fit_bonus\n\n    # 6. Small Item Penalty: Slightly discourage placing very small items into partially filled bins.  Also, give a slight preference to placing small items in empty bins.\n    small_item_threshold = 0.1\n    small_item_penalty = 0.1\n    small_item = item / bin_capacity < small_item_threshold\n    if small_item:\n        partially_filled_bins = feasible_bins & (bins_remain_cap < bin_capacity) & (bins_remain_cap > 0)\n        empty_bins = bins_remain_cap == bin_capacity\n        priorities[partially_filled_bins] -= small_item_penalty\n        priorities[empty_bins] += small_item_penalty / 2  # Slight preference for empty bins\n\n    # 7. Bin balancing: Try to balance the fill levels of the bins\n    bin_fill_levels = (bin_capacity - bins_remain_cap) / bin_capacity\n    mean_fill_level = np.mean(bin_fill_levels)\n    bin_balancing_penalty = 0.05 * np.abs(bin_fill_levels - mean_fill_level)\n    priorities -= bin_balancing_penalty\n\n    return priorities",
    "response_id": 4,
    "obj": 2.6525727961707357,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response5.txt_stdout.txt",
    "code_path": "problem_iter10_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)\n\n    # 1. Feasibility: Infeasible bins get a very large negative priority.\n    feasible_bins = bins_remain_cap >= item\n    priorities[~feasible_bins] = -1e9\n\n    # 2. Best Fit: Prefer bins where the remaining capacity after placement is minimal\n    remaining_after_fit = bins_remain_cap - item\n    remaining_after_fit[~feasible_bins] = bin_capacity * 2  # Set to large value for infeasible bins\n    best_fit_priority = -remaining_after_fit / bin_capacity  # Normalize & invert: smaller remaining is better\n    priorities += best_fit_priority\n\n    # 3. Moderate Fill: Penalize bins that are nearly full or nearly empty *before* item placement.\n    nearly_full_threshold = 0.9\n    nearly_empty_threshold = 0.1\n    moderate_fill_penalty = 0.3\n\n    nearly_full_bins = (bins_remain_cap / bin_capacity) > nearly_full_threshold\n    nearly_empty_bins = (bins_remain_cap / bin_capacity) < nearly_empty_threshold\n\n    priorities[feasible_bins & nearly_full_bins] -= moderate_fill_penalty\n    priorities[feasible_bins & nearly_empty_bins] -= moderate_fill_penalty\n\n    # 4. Fragmentation Penalty: Heavily penalize bins that will create a very small fragment.\n    fragment_threshold = 0.15\n    fragment_penalty = 0.8\n    fragment_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit / bin_capacity <= fragment_threshold)\n    priorities[fragment_mask] -= fragment_penalty\n\n    # 5. Reward Near-Perfect Fit: Significant bonus for near perfect fits\n    near_perfect_fit_threshold = 0.05\n    near_perfect_fit_bonus = 0.7\n    near_perfect_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit / bin_capacity <= near_perfect_fit_threshold)\n    priorities[near_perfect_mask] += near_perfect_fit_bonus\n\n    # 6. Small Item Penalty: Slightly discourage placing very small items into partially filled bins.  Also, give a slight preference to placing small items in empty bins.\n    small_item_threshold = 0.1\n    small_item_penalty = 0.1\n    small_item = item / bin_capacity < small_item_threshold\n    if small_item:\n        partially_filled_bins = feasible_bins & (bins_remain_cap < bin_capacity) & (bins_remain_cap > 0)\n        empty_bins = bins_remain_cap == bin_capacity\n        priorities[partially_filled_bins] -= small_item_penalty\n        priorities[empty_bins] += small_item_penalty / 2  # Slight preference for empty bins\n\n    # 7. Bin balancing: Try to balance the fill levels of the bins\n    bin_fill_levels = (bin_capacity - bins_remain_cap) / bin_capacity\n    mean_fill_level = np.mean(bin_fill_levels)\n    bin_balancing_penalty = 0.05 * np.abs(bin_fill_levels - mean_fill_level)\n    priorities -= bin_balancing_penalty\n\n    return priorities",
    "response_id": 5,
    "obj": 2.6525727961707357,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response6.txt_stdout.txt",
    "code_path": "problem_iter10_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)\n\n    # 1. Feasibility: Infeasible bins get a very large negative priority.\n    feasible_bins = bins_remain_cap >= item\n    priorities[~feasible_bins] = -1e9\n\n    # 2. Best Fit: Prefer bins where the remaining capacity after placement is minimal\n    remaining_after_fit = bins_remain_cap - item\n    remaining_after_fit[~feasible_bins] = bin_capacity * 2  # Set to large value for infeasible bins\n    best_fit_priority = -remaining_after_fit / bin_capacity # Normalize & invert: smaller remaining is better\n    priorities += best_fit_priority\n\n    # 3. Moderate Fill: Penalize bins that are nearly full or nearly empty *before* item placement.\n    nearly_full_threshold = 0.9\n    nearly_empty_threshold = 0.1\n    moderate_fill_penalty = 0.3\n\n    nearly_full_bins = (bins_remain_cap / bin_capacity) > nearly_full_threshold\n    nearly_empty_bins = (bins_remain_cap / bin_capacity) < nearly_empty_threshold\n\n    priorities[feasible_bins & nearly_full_bins] -= moderate_fill_penalty\n    priorities[feasible_bins & nearly_empty_bins] -= moderate_fill_penalty\n\n    # 4. Fragmentation Penalty: Heavily penalize bins that will create a very small fragment.\n    fragment_threshold = 0.15\n    fragment_penalty = 0.8\n    fragment_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit / bin_capacity <= fragment_threshold)\n    priorities[fragment_mask] -= fragment_penalty\n\n    # 5. Reward Near-Perfect Fit: Significant bonus for near perfect fits\n    near_perfect_fit_threshold = 0.05\n    near_perfect_fit_bonus = 0.7\n    near_perfect_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit / bin_capacity <= near_perfect_fit_threshold)\n    priorities[near_perfect_mask] += near_perfect_fit_bonus\n\n    # 6. Small Item Penalty: Slightly discourage placing very small items into partially filled bins.  Also, give a slight preference to placing small items in empty bins.\n    small_item_threshold = 0.1\n    small_item_penalty = 0.1\n    small_item = item / bin_capacity < small_item_threshold\n    if small_item:\n      partially_filled_bins = feasible_bins & (bins_remain_cap < bin_capacity) & (bins_remain_cap > 0)\n      empty_bins = bins_remain_cap == bin_capacity\n      priorities[partially_filled_bins] -= small_item_penalty\n      priorities[empty_bins] += small_item_penalty/2 #Slight preference for empty bins\n\n    #7. Bin balancing: Try to balance the fill levels of the bins\n    bin_fill_levels = (bin_capacity - bins_remain_cap) / bin_capacity\n    mean_fill_level = np.mean(bin_fill_levels)\n    bin_balancing_penalty = 0.05 * np.abs(bin_fill_levels - mean_fill_level)\n    priorities -= bin_balancing_penalty\n\n\n    return priorities",
    "response_id": 6,
    "obj": 2.6525727961707357,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response7.txt_stdout.txt",
    "code_path": "problem_iter10_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)\n\n    # 1. Feasibility: Infeasible bins get a very large negative priority.\n    feasible_bins = bins_remain_cap >= item\n    priorities[~feasible_bins] = -1e9\n\n    # 2. Best Fit: Prefer bins where the remaining capacity after placement is minimal\n    remaining_after_fit = bins_remain_cap - item\n    remaining_after_fit[~feasible_bins] = bin_capacity * 2  # Set to large value for infeasible bins\n    best_fit_priority = -remaining_after_fit / bin_capacity  # Normalize & invert: smaller remaining is better\n    priorities += best_fit_priority\n\n    # 3. Moderate Fill: Penalize bins that are nearly full or nearly empty *before* item placement.\n    nearly_full_threshold = 0.9\n    nearly_empty_threshold = 0.1\n    moderate_fill_penalty = 0.3\n\n    nearly_full_bins = (bins_remain_cap / bin_capacity) > nearly_full_threshold\n    nearly_empty_bins = (bins_remain_cap / bin_capacity) < nearly_empty_threshold\n\n    priorities[feasible_bins & nearly_full_bins] -= moderate_fill_penalty\n    priorities[feasible_bins & nearly_empty_bins] -= moderate_fill_penalty\n\n    # 4. Fragmentation Penalty: Heavily penalize bins that will create a very small fragment.\n    fragment_threshold = 0.15\n    fragment_penalty = 0.8\n    fragment_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit / bin_capacity <= fragment_threshold)\n    priorities[fragment_mask] -= fragment_penalty\n\n    # 5. Reward Near-Perfect Fit: Significant bonus for near perfect fits\n    near_perfect_fit_threshold = 0.05\n    near_perfect_fit_bonus = 0.7\n    near_perfect_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit / bin_capacity <= near_perfect_fit_threshold)\n    priorities[near_perfect_mask] += near_perfect_fit_bonus\n\n    # 6. Small Item Penalty: Slightly discourage placing very small items into partially filled bins.  Also, give a slight preference to placing small items in empty bins.\n    small_item_threshold = 0.1\n    small_item_penalty = 0.1\n    small_item = item / bin_capacity < small_item_threshold\n    if small_item:\n        partially_filled_bins = feasible_bins & (bins_remain_cap < bin_capacity) & (bins_remain_cap > 0)\n        empty_bins = bins_remain_cap == bin_capacity\n        priorities[partially_filled_bins] -= small_item_penalty\n        priorities[empty_bins] += small_item_penalty / 2  # Slight preference for empty bins\n\n    # 7. Bin balancing: Try to balance the fill levels of the bins\n    bin_fill_levels = (bin_capacity - bins_remain_cap) / bin_capacity\n    mean_fill_level = np.mean(bin_fill_levels)\n    bin_balancing_penalty = 0.05 * np.abs(bin_fill_levels - mean_fill_level)\n    priorities -= bin_balancing_penalty\n\n    # Simplified rule: Slightly prefer bins with capacity closest to item size\n    priority_item_fit = -np.abs(bins_remain_cap - item) / bin_capacity\n    priorities += 0.02*priority_item_fit #Scale to keep it subtle\n\n    # 8. Avoid overfilling bins that are close to full, even if technically feasible now.\n    almost_full_threshold = 0.95\n    almost_full_penalty = 0.5\n    almost_full_bins = (bins_remain_cap / bin_capacity) > (almost_full_threshold - (item/bin_capacity)) #Check before placement\n    priorities[feasible_bins & almost_full_bins] -= almost_full_penalty\n\n    return priorities",
    "response_id": 7,
    "obj": 2.8021539688871298,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response8.txt_stdout.txt",
    "code_path": "problem_iter10_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)\n\n    # 1. Feasibility: Infeasible bins get a very large negative priority.\n    feasible_bins = bins_remain_cap >= item\n    priorities[~feasible_bins] = -1e9\n\n    # 2. Best Fit: Prefer bins where the remaining capacity after placement is minimal (normalized)\n    remaining_after_fit = bins_remain_cap - item\n    remaining_after_fit[~feasible_bins] = bin_capacity * 2  # Set to large value for infeasible bins\n    best_fit_priority = -remaining_after_fit / bin_capacity  # Normalize & invert: smaller remaining is better\n    priorities += best_fit_priority\n\n    # 3. Moderate Fill: Penalize bins that are nearly full or nearly empty *before* item placement.\n    nearly_full_threshold = 0.9\n    nearly_empty_threshold = 0.1\n    moderate_fill_penalty = 0.3\n\n    nearly_full_bins = (bins_remain_cap / bin_capacity) > nearly_full_threshold\n    nearly_empty_bins = (bins_remain_cap / bin_capacity) < nearly_empty_threshold\n\n    priorities[feasible_bins & nearly_full_bins] -= moderate_fill_penalty\n    priorities[feasible_bins & nearly_empty_bins] -= moderate_fill_penalty\n\n    # 4. Fragmentation Penalty: Heavily penalize bins that will create a very small fragment. (normalized)\n    fragment_threshold = 0.15\n    fragment_penalty = 0.8\n    fragment_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit / bin_capacity <= fragment_threshold)\n    priorities[fragment_mask] -= fragment_penalty\n\n    # 5. Reward Near-Perfect Fit: Significant bonus for near perfect fits (normalized)\n    near_perfect_fit_threshold = 0.05\n    near_perfect_fit_bonus = 0.7\n    near_perfect_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit / bin_capacity <= near_perfect_fit_threshold)\n    priorities[near_perfect_mask] += near_perfect_fit_bonus\n\n    # 6. Small Item Penalty: Slightly discourage placing very small items into partially filled bins. (normalized)\n    small_item_threshold = 0.1\n    small_item_penalty = 0.1\n    if item / bin_capacity < small_item_threshold:\n        partially_filled_bins = feasible_bins & (bins_remain_cap < bin_capacity)\n        priorities[partially_filled_bins] -= small_item_penalty\n\n    # 7. Large Item Bonus: Encourage placing large items into emptier bins. (normalized)\n    large_item_threshold = 0.7\n    large_item_bonus = 0.2\n    if item / bin_capacity > large_item_threshold:\n        relatively_empty_bins = feasible_bins & ((bins_remain_cap / bin_capacity) > 0.5)  # Bins more than half empty\n        priorities[relatively_empty_bins] += large_item_bonus\n        \n    # 8. Item Fragmentation Avoidance: Discourage splitting items across bins if a suitable bin exists.\n    #   Prioritize using existing bins over opening new ones.\n    new_bin_penalty = 0.05  # Slightly penalize using a completely empty bin\n    empty_bins = bins_remain_cap == bin_capacity\n    priorities[feasible_bins & empty_bins] -= new_bin_penalty\n    \n\n    return priorities",
    "response_id": 8,
    "obj": 2.8520143597925944,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response9.txt_stdout.txt",
    "code_path": "problem_iter10_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)\n\n    # 1. Feasibility: Infeasible bins get a very large negative priority.\n    feasible_bins = bins_remain_cap >= item\n    priorities[~feasible_bins] = -1e9\n\n    # 2. Best Fit: Prefer bins where the remaining capacity after placement is minimal\n    remaining_after_fit = bins_remain_cap - item\n    remaining_after_fit[~feasible_bins] = bin_capacity * 2  # Set to large value for infeasible bins\n    best_fit_priority = -remaining_after_fit / bin_capacity  # Normalize & invert: smaller remaining is better\n    priorities += best_fit_priority\n\n    # 3. Moderate Fill: Penalize bins that are nearly full or nearly empty *before* item placement.\n    nearly_full_threshold = 0.9\n    nearly_empty_threshold = 0.1\n    moderate_fill_penalty = 0.2  # Reduced penalty\n\n    nearly_full_bins = (bins_remain_cap / bin_capacity) > nearly_full_threshold\n    nearly_empty_bins = (bins_remain_cap / bin_capacity) < nearly_empty_threshold\n\n    priorities[feasible_bins & nearly_full_bins] -= moderate_fill_penalty\n    priorities[feasible_bins & nearly_empty_bins] -= moderate_fill_penalty\n\n    # 4. Fragmentation Penalty: Heavily penalize bins that will create a very small fragment.\n    fragment_threshold = 0.15\n    fragment_penalty = 0.7  # Reduced penalty\n    fragment_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit / bin_capacity <= fragment_threshold)\n    priorities[fragment_mask] -= fragment_penalty\n\n    # 5. Reward Near-Perfect Fit: Significant bonus for near perfect fits\n    near_perfect_fit_threshold = 0.05\n    near_perfect_fit_bonus = 0.6 # Reduced bonus\n    near_perfect_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit / bin_capacity <= near_perfect_fit_threshold)\n    priorities[near_perfect_mask] += near_perfect_fit_bonus\n\n    # 6. Small Item Handling: Adjust penalty/reward for small items based on fill level.\n    small_item_threshold = 0.1\n    small_item_penalty = 0.08 # Reduced penalty\n    small_item_bonus = 0.04 # Reduced bonus\n    small_item = item / bin_capacity < small_item_threshold\n\n    if small_item:\n        partially_filled_bins = feasible_bins & (bins_remain_cap < bin_capacity) & (bins_remain_cap > 0)\n        empty_bins = bins_remain_cap == bin_capacity\n        priorities[partially_filled_bins] -= small_item_penalty\n        priorities[empty_bins] += small_item_bonus  # Reduced bonus for empty bins\n\n    # 7. Bin balancing: Try to balance the fill levels of the bins. Increased balancing influence.\n    bin_fill_levels = (bin_capacity - bins_remain_cap) / bin_capacity\n    mean_fill_level = np.mean(bin_fill_levels)\n    bin_balancing_penalty = 0.07 * np.abs(bin_fill_levels - mean_fill_level) # Increased factor\n    priorities -= bin_balancing_penalty\n\n    # 8. Item fit preference. Increase influence\n    priority_item_fit = -np.abs(bins_remain_cap - item) / bin_capacity\n    priorities += 0.03 * priority_item_fit  # Increased scale\n\n    # 9. Empty bin usage. Encourage the use of empty bins early on.\n    is_empty = bins_remain_cap == bin_capacity\n    priorities[feasible_bins & is_empty] += 0.05 # A slight initial preference for empty bins\n\n    return priorities",
    "response_id": 9,
    "obj": 2.572796170721974,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response0.txt_stdout.txt",
    "code_path": "problem_iter11_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)\n    normalized_item = item / bin_capacity\n\n    # 1. Feasibility: Infeasible bins get a very large negative priority.\n    feasible_bins = bins_remain_cap >= item\n    priorities[~feasible_bins] = -1e9\n\n    # 2. Best Fit: Prefer bins where the remaining capacity after placement is minimal\n    remaining_after_fit = bins_remain_cap - item\n    remaining_after_fit[~feasible_bins] = bin_capacity * 2  # Set to large value for infeasible bins\n    best_fit_priority = -remaining_after_fit / bin_capacity  # Normalize & invert: smaller remaining is better\n    priorities += best_fit_priority\n\n    # 3. Fragmentation Penalty: Heavily penalize bins that will create a very small fragment.\n    fragment_threshold = 0.12\n    fragment_penalty = 0.6\n    fragment_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit / bin_capacity <= fragment_threshold)\n    priorities[fragment_mask] -= fragment_penalty\n\n    # 4. Reward Near-Perfect Fit: Significant bonus for near perfect fits\n    near_perfect_fit_threshold = 0.07\n    near_perfect_fit_bonus = 0.5\n    near_perfect_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit / bin_capacity <= near_perfect_fit_threshold)\n    priorities[near_perfect_mask] += near_perfect_fit_bonus\n\n    # 5. Small Item Preference & Avoidance:\n    small_item_threshold = 0.1\n    small_item_bonus = 0.1\n    small_item_penalty = 0.05\n    if normalized_item < small_item_threshold:\n        # Prefer bins with remaining capacity exceeding a threshold or near empty\n        preferred_threshold = 0.5\n        preferred_bins = feasible_bins & ((bins_remain_cap / bin_capacity) > preferred_threshold)\n        priorities[preferred_bins] += small_item_bonus\n        # Avoid adding to bins with some capacity to avoid many small fragments\n        avoid_bins = feasible_bins & (bins_remain_cap < bin_capacity) & (bins_remain_cap > item)\n        priorities[avoid_bins] -= small_item_penalty\n\n    # 6. Bin balancing (moderate): Try to balance fill levels, with a dampening factor for small items.\n    bin_fill_levels = (bin_capacity - bins_remain_cap) / bin_capacity\n    mean_fill_level = np.mean(bin_fill_levels)\n    balancing_factor = 0.02 * (1 - min(1, 5 * normalized_item))  # Dampen balancing for smaller items.\n    bin_balancing_penalty = balancing_factor * np.abs(bin_fill_levels - mean_fill_level)\n    priorities -= bin_balancing_penalty\n\n    # 7. Large item incentive to fill more\n    large_item_threshold = 0.7\n    large_item_bonus = 0.1\n\n    if normalized_item > large_item_threshold:\n      nearly_full_bins = feasible_bins & ((bins_remain_cap / bin_capacity) < 0.3) & ((bins_remain_cap / bin_capacity) > (normalized_item -0.01) )\n\n      priorities[nearly_full_bins] += large_item_bonus\n    return priorities",
    "response_id": 0,
    "obj": 3.540087754287994,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response1.txt_stdout.txt",
    "code_path": "problem_iter11_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)\n    normalized_item = item / bin_capacity\n\n    # 1. Feasibility: Infeasible bins get a very large negative priority.\n    feasible_bins = bins_remain_cap >= item\n    priorities[~feasible_bins] = -1e9\n\n    # 2. Best Fit (Normalized): Prioritize bins with minimal remaining capacity after placement.\n    remaining_after_fit = bins_remain_cap - item\n    remaining_after_fit[~feasible_bins] = bin_capacity * 2  # Set to large value for infeasible bins\n    best_fit_priority = -remaining_after_fit / bin_capacity\n    priorities += best_fit_priority\n\n    # 3. Moderate Fill Avoidance: Discourage fills close to full without being overly aggressive.\n    fill_threshold = 0.95\n    fill_avoidance_penalty = 0.2\n    high_fill_bins = feasible_bins & ((bins_remain_cap - item) / bin_capacity <= (1 - fill_threshold)) & (bins_remain_cap -item > 0)\n    priorities[high_fill_bins] -= fill_avoidance_penalty\n\n    # 4. Bin Balancing: Encourage packing into bins with lower fill levels.\n    bin_fill_levels = (bin_capacity - bins_remain_cap) / bin_capacity\n    mean_fill_level = np.mean(bin_fill_levels)\n    bin_balancing_bonus = -0.05 * (bin_fill_levels - mean_fill_level) # Scale down balancing\n    priorities += bin_balancing_bonus\n\n    # 5. Fragmentation Penalty (Stricter):  Penalize small fragments more strongly.\n    fragment_threshold = 0.1\n    fragment_penalty = 0.5\n    fragment_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit / bin_capacity <= fragment_threshold)\n    priorities[fragment_mask] -= fragment_penalty\n\n    # 6. Near-Perfect Fit Reward:  Significant bonus for fits close to perfect, tuned down\n    near_perfect_fit_threshold = 0.04\n    near_perfect_fit_bonus = 0.4\n    near_perfect_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit / bin_capacity <= near_perfect_fit_threshold)\n    priorities[near_perfect_mask] += near_perfect_fit_bonus\n\n    # 7. Item-Size Dependent Bonus:  Slight reward for placing larger items (exploration).\n    item_size_bonus = 0.05 * normalized_item\n    priorities[feasible_bins] += item_size_bonus  # Apply only to feasible bins\n\n    # 8. Small Item preference for relatively empty bins\n    small_item_threshold = 0.2\n    small_item_bonus = 0.1\n    small_item = item / bin_capacity < small_item_threshold\n\n    if small_item:\n        relatively_empty_bins = feasible_bins & (bins_remain_cap > 0.7* bin_capacity) & (bins_remain_cap < bin_capacity)\n        priorities[relatively_empty_bins]+= small_item_bonus/2\n        completely_empty_bins = feasible_bins & (bins_remain_cap == bin_capacity)\n        priorities[completely_empty_bins] += small_item_bonus\n\n    return priorities",
    "response_id": 1,
    "obj": 4.587155963302752,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response2.txt_stdout.txt",
    "code_path": "problem_iter11_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)\n    normalized_item = item / bin_capacity\n\n    # 1. Feasibility: Infeasible bins get a very large negative priority.\n    feasible_bins = bins_remain_cap >= item\n    priorities[~feasible_bins] = -1e9\n\n    # 2. Normalized Remaining Capacity (Best Fit, but scaled):\n    remaining_after_fit = bins_remain_cap - item\n    remaining_after_fit[~feasible_bins] = bin_capacity * 2\n    normalized_remaining = remaining_after_fit / bin_capacity\n    best_fit_priority = -normalized_remaining  # Smaller remaining is better.\n    priorities += best_fit_priority\n\n    # 3. Moderate Fill Avoidance: Encourage filling bins somewhat, but not completely.\n    fill_threshold_low = 0.1\n    fill_threshold_high = 0.95\n    fill_avoidance_penalty = 0.05\n    fill_avoidance_mask = feasible_bins & (normalized_remaining > fill_threshold_low) & (normalized_remaining < fill_threshold_high)\n    priorities[fill_avoidance_mask] -= fill_avoidance_penalty * normalized_item # Penalize more for larger items\n\n\n    # 4. Bin Balancing: Encourage bins with fill levels closest to the mean.\n    bin_fill_levels = (bin_capacity - bins_remain_cap) / bin_capacity\n    mean_fill_level = np.mean(bin_fill_levels)\n    bin_balancing_bonus = -np.abs(bin_fill_levels - mean_fill_level) * 0.02 # Small bonus, normalized\n    priorities += bin_balancing_bonus\n\n    # 5. Fragmentation Penalty: Discourage creating small fragments, scaled to item size.\n    fragment_threshold = 0.1\n    fragment_penalty = 0.4\n    fragment_mask = feasible_bins & (normalized_remaining > 0) & (normalized_remaining <= fragment_threshold)\n    priorities[fragment_mask] -= fragment_penalty * normalized_item # Penalize more if item is large\n\n    # 6. Near-Perfect Fit Reward: Strong reward for near-perfect fits.\n    near_perfect_threshold = 0.05\n    near_perfect_bonus = 0.5\n    near_perfect_mask = feasible_bins & (normalized_remaining > 0) & (normalized_remaining <= near_perfect_threshold)\n    priorities[near_perfect_mask] += near_perfect_bonus\n\n    # 7. Item-Size Dependent Bonus: Slightly prefer bins closer in size to the item.\n    size_difference = np.abs(bins_remain_cap - item) / bin_capacity\n    size_similarity_bonus = -size_difference * 0.03\n    priorities += size_similarity_bonus\n\n    # 8. Exploration Bonus : Encourage exploration of empty or nearly empty bins.\n    exploration_threshold = 0.95\n    exploration_bonus = 0.01\n    exploration_mask = feasible_bins & (bins_remain_cap / bin_capacity > exploration_threshold)\n    priorities[exploration_mask] += exploration_bonus\n\n    return priorities",
    "response_id": 2,
    "obj": 4.796569605105718,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response3.txt_stdout.txt",
    "code_path": "problem_iter11_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)\n    normalized_item = item / bin_capacity\n\n    # 1. Feasibility: Infeasible bins get a very large negative priority.\n    feasible_bins = bins_remain_cap >= item\n    priorities[~feasible_bins] = -1e9\n\n    # 2. Best Fit: Prefer bins where the remaining capacity after placement is minimal\n    remaining_after_fit = bins_remain_cap - item\n    remaining_after_fit[~feasible_bins] = bin_capacity * 2  # Set to large value for infeasible bins\n    best_fit_priority = -remaining_after_fit / bin_capacity  # Normalize & invert: smaller remaining is better\n    priorities += best_fit_priority\n\n    # 3. Fragmentation Penalty: Heavily penalize bins that will create a very small fragment.\n    fragment_threshold = 0.12  # Slightly tighter threshold\n    fragment_penalty = 0.8  # Increased penalty\n    fragment_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit / bin_capacity <= fragment_threshold)\n    priorities[fragment_mask] -= fragment_penalty\n\n    # 4. Reward Near-Perfect Fit: Significant bonus for near perfect fits\n    near_perfect_fit_threshold = 0.08  # Increased threshold for near-perfect\n    near_perfect_fit_bonus = 0.7  # Increased bonus\n    near_perfect_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit / bin_capacity <= near_perfect_fit_threshold)\n    priorities[near_perfect_mask] += near_perfect_fit_bonus\n\n    # 5. Small Item Handling: Discourage small items in partially filled bins, prefer empty. Item-size-dependent bonus.\n    small_item_threshold = 0.1\n    small_item_penalty = 0.1\n    small_item = normalized_item < small_item_threshold\n    if small_item:\n        partially_filled_bins = feasible_bins & (bins_remain_cap < bin_capacity) & (bins_remain_cap > item)\n        empty_bins = bins_remain_cap == bin_capacity\n        priorities[partially_filled_bins] -= small_item_penalty * normalized_item # Scale penalty by item size\n        priorities[empty_bins] += small_item_penalty * normalized_item / 2  # Smaller bonus for empty\n\n    # 6. Bin balancing: Try to balance the fill levels of the bins - only if not a near perfect fit. More aggressive balancing.\n    bin_fill_levels = (bin_capacity - bins_remain_cap) / bin_capacity\n    mean_fill_level = np.mean(bin_fill_levels)\n    bin_balancing_penalty = 0.05 * np.abs(bin_fill_levels - mean_fill_level) # Increased balancing penalty\n    priorities[~near_perfect_mask] -= bin_balancing_penalty[~near_perfect_mask]  # Apply only if not near perfect\n\n    # 7. Moderate Fill Avoidance: Discourage bins that are already moderately full.\n    moderate_fill_threshold_low = 0.4\n    moderate_fill_threshold_high = 0.7\n    moderate_fill_penalty = 0.2\n\n    moderately_filled_bins = feasible_bins & (bin_fill_levels >= moderate_fill_threshold_low) & (bin_fill_levels <= moderate_fill_threshold_high)\n    priorities[moderately_filled_bins] -= moderate_fill_penalty\n\n    return priorities",
    "response_id": 3,
    "obj": 3.4004786597527064,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response4.txt_stdout.txt",
    "code_path": "problem_iter11_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)\n    normalized_item = item / bin_capacity\n\n    # 1. Feasibility: Infeasible bins get a very large negative priority.\n    feasible_bins = bins_remain_cap >= item\n    priorities[~feasible_bins] = -1e9\n\n    # 2. Best Fit (Normalized): Prefer bins where the remaining capacity after placement is minimal, normalized.\n    remaining_after_fit = bins_remain_cap - item\n    remaining_after_fit[~feasible_bins] = bin_capacity * 2  # Set to large value for infeasible bins\n    best_fit_priority = -remaining_after_fit / bin_capacity  # Normalize & invert: smaller remaining is better\n    priorities += best_fit_priority\n\n    # 3. Moderate Fill Avoidance: Slightly discourage bins that are already very full (but not infeasible).\n    full_threshold = 0.8\n    full_avoidance_penalty = 0.1\n    full_bins = feasible_bins & ((bin_capacity - bins_remain_cap) / bin_capacity > full_threshold)\n    priorities[full_bins] -= full_avoidance_penalty\n\n    # 4. Fragmentation Penalty: Heavily penalize bins that will create a very small fragment. Tuned threshold.\n    fragment_threshold = 0.12\n    fragment_penalty = 0.6  # Slightly reduced penalty\n    fragment_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit / bin_capacity <= fragment_threshold)\n    priorities[fragment_mask] -= fragment_penalty\n\n    # 5. Reward Near-Perfect Fit: Significant bonus for near perfect fits. Tuned threshold and bonus.\n    near_perfect_fit_threshold = 0.04\n    near_perfect_fit_bonus = 0.7\n    near_perfect_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit / bin_capacity <= near_perfect_fit_threshold)\n    priorities[near_perfect_mask] += near_perfect_fit_bonus\n\n    # 6. Item-Size Dependent Bonus: Give a slight bonus based on item size (encourages filling larger gaps)\n    item_size_bonus_factor = 0.15\n    item_size_bonus = normalized_item * item_size_bonus_factor\n    priorities[feasible_bins] += item_size_bonus\n\n    # 7. Bin balancing: Try to balance the fill levels of the bins - only if not a near perfect fit. Tuned penalty\n    bin_fill_levels = (bin_capacity - bins_remain_cap) / bin_capacity\n    mean_fill_level = np.mean(bin_fill_levels)\n    bin_balancing_penalty = 0.04 * np.abs(bin_fill_levels - mean_fill_level)  # Slightly increased penalty\n    priorities[~near_perfect_mask] -= bin_balancing_penalty[~near_perfect_mask]  # Apply bin balancing only if not near perfect\n\n    # 8. Exploration Bonus (Low Probability): Introduce some randomness for exploration. Reduced probability.\n    exploration_probability = 0.01\n    random_bonus = np.random.uniform(0, 0.05, size=bins_remain_cap.shape)  # Small random bonus\n    explore_mask = np.random.rand(len(bins_remain_cap)) < exploration_probability\n    priorities[feasible_bins & explore_mask] += random_bonus[feasible_bins & explore_mask]\n\n    return priorities",
    "response_id": 4,
    "obj": 4.557239728759479,
    "exec_success": true
  }
]