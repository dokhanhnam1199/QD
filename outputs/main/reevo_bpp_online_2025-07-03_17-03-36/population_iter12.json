[
  {
    "stdout_filepath": "problem_iter12_response0.txt_stdout.txt",
    "code_path": "problem_iter12_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)\n    normalized_item = item / bin_capacity\n\n    # 1. Feasibility: Infeasible bins get a very large negative priority.\n    feasible_bins = bins_remain_cap >= item\n    priorities[~feasible_bins] = -1e9\n\n    # 2. Best Fit: Prefer bins where the remaining capacity after placement is minimal\n    remaining_after_fit = bins_remain_cap - item\n    remaining_after_fit[~feasible_bins] = bin_capacity * 2  # Set to large value for infeasible bins\n    best_fit_priority = -remaining_after_fit / bin_capacity  # Normalize & invert: smaller remaining is better\n    priorities += best_fit_priority\n\n    # 3. Fragmentation Penalty: Heavily penalize bins that will create a very small fragment. Adjusted threshold\n    fragment_threshold = 0.10\n    fragment_penalty = 0.5\n    fragment_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit / bin_capacity <= fragment_threshold)\n    priorities[fragment_mask] -= fragment_penalty\n\n    # 4. Reward Near-Perfect Fit: Significant bonus for near perfect fits.  Adjusted threshold\n    near_perfect_fit_threshold = 0.06\n    near_perfect_fit_bonus = 0.4\n    near_perfect_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit / bin_capacity <= near_perfect_fit_threshold)\n    priorities[near_perfect_mask] += near_perfect_fit_bonus\n\n    # 5. Small Item Preference & Avoidance:\n    small_item_threshold = 0.12\n    small_item_bonus = 0.08\n    small_item_penalty = 0.03\n    if normalized_item < small_item_threshold:\n        # Prefer bins with remaining capacity exceeding a threshold or near empty\n        preferred_threshold = 0.6\n        preferred_bins = feasible_bins & ((bins_remain_cap / bin_capacity) > preferred_threshold)\n        priorities[preferred_bins] += small_item_bonus\n        # Avoid adding to bins with some capacity to avoid many small fragments\n        avoid_bins = feasible_bins & (bins_remain_cap < bin_capacity) & (bins_remain_cap > item)\n        priorities[avoid_bins] -= small_item_penalty\n\n    # 6. Bin balancing (moderate): Try to balance fill levels, with a dampening factor for small items.\n    bin_fill_levels = (bin_capacity - bins_remain_cap) / bin_capacity\n    mean_fill_level = np.mean(bin_fill_levels)\n    balancing_factor = 0.03 * (1 - min(1, 5 * normalized_item))  # Dampen balancing for smaller items.  Slightly increased\n    bin_balancing_penalty = balancing_factor * np.abs(bin_fill_levels - mean_fill_level)\n    priorities -= bin_balancing_penalty\n\n    # 7. Large item incentive to fill more\n    large_item_threshold = 0.7\n    large_item_bonus = 0.15 #Increased\n\n    if normalized_item > large_item_threshold:\n      nearly_full_bins = feasible_bins & ((bins_remain_cap / bin_capacity) < 0.3) & ((bins_remain_cap / bin_capacity) > (normalized_item -0.02) ) #Adjusted tolerance\n\n      priorities[nearly_full_bins] += large_item_bonus\n\n    # 8. Empty bin bonus - encourage use of empty bins\n    empty_bin_bonus = 0.05\n    empty_bins = bins_remain_cap == bin_capacity\n    priorities[feasible_bins & empty_bins] += empty_bin_bonus\n\n    return priorities",
    "response_id": 0,
    "obj": 4.13841244515357,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response1.txt_stdout.txt",
    "code_path": "problem_iter12_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)\n\n    # 1. Feasibility: Infeasible bins get a very large negative priority.\n    feasible_bins = bins_remain_cap >= item\n    priorities[~feasible_bins] = -1e9\n\n    # 2. Best Fit: Prefer bins where the remaining capacity after placement is minimal\n    remaining_after_fit = bins_remain_cap - item\n    remaining_after_fit[~feasible_bins] = bin_capacity * 2  # Set to large value for infeasible bins\n    best_fit_priority = -remaining_after_fit / bin_capacity  # Normalize & invert: smaller remaining is better\n    priorities += best_fit_priority\n\n    # 3. Moderate Fill: Penalize bins that are nearly full or nearly empty *before* item placement.\n    nearly_full_threshold = 0.9\n    nearly_empty_threshold = 0.1\n    moderate_fill_penalty = 0.3\n\n    nearly_full_bins = (bins_remain_cap / bin_capacity) > nearly_full_threshold\n    nearly_empty_bins = (bins_remain_cap / bin_capacity) < nearly_empty_threshold\n\n    priorities[feasible_bins & nearly_full_bins] -= moderate_fill_penalty\n    priorities[feasible_bins & nearly_empty_bins] -= moderate_fill_penalty\n\n    # 4. Fragmentation Penalty: Heavily penalize bins that will create a very small fragment.\n    fragment_threshold = 0.15\n    fragment_penalty = 0.8\n    fragment_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit / bin_capacity <= fragment_threshold)\n    priorities[fragment_mask] -= fragment_penalty\n\n    # 5. Reward Near-Perfect Fit: Significant bonus for near perfect fits\n    near_perfect_fit_threshold = 0.05\n    near_perfect_fit_bonus = 0.7\n    near_perfect_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit / bin_capacity <= near_perfect_fit_threshold)\n    priorities[near_perfect_mask] += near_perfect_fit_bonus\n\n    # 6. Small Item Penalty: Slightly discourage placing very small items into partially filled bins.  Also, give a slight preference to placing small items in empty bins.\n    small_item_threshold = 0.1\n    small_item_penalty = 0.1\n    small_item = item / bin_capacity < small_item_threshold\n    if small_item:\n        partially_filled_bins = feasible_bins & (bins_remain_cap < bin_capacity) & (bins_remain_cap > 0)\n        empty_bins = bins_remain_cap == bin_capacity\n        priorities[partially_filled_bins] -= small_item_penalty\n        priorities[empty_bins] += small_item_penalty / 2  # Slight preference for empty bins\n\n    # 7. Bin balancing: Try to balance the fill levels of the bins\n    bin_fill_levels = (bin_capacity - bins_remain_cap) / bin_capacity\n    mean_fill_level = np.mean(bin_fill_levels)\n    bin_balancing_penalty = 0.05 * np.abs(bin_fill_levels - mean_fill_level)\n    priorities -= bin_balancing_penalty\n\n    return priorities",
    "response_id": 1,
    "obj": 2.6525727961707357,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response2.txt_stdout.txt",
    "code_path": "problem_iter12_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)\n\n    # 1. Feasibility: Infeasible bins get a very large negative priority.\n    feasible_bins = bins_remain_cap >= item\n    priorities[~feasible_bins] = -1e9\n\n    # 2. Best Fit: Prefer bins where the remaining capacity after placement is minimal\n    remaining_after_fit = bins_remain_cap - item\n    remaining_after_fit[~feasible_bins] = bin_capacity * 2  # Set to large value for infeasible bins\n    best_fit_priority = -remaining_after_fit / bin_capacity  # Normalize & invert: smaller remaining is better\n    priorities += best_fit_priority\n\n    # 3. Moderate Fill: Penalize bins that are nearly full or nearly empty *before* item placement.\n    nearly_full_threshold = 0.85\n    nearly_empty_threshold = 0.15\n    moderate_fill_penalty = 0.4\n\n    nearly_full_bins = (bins_remain_cap / bin_capacity) > nearly_full_threshold\n    nearly_empty_bins = (bins_remain_cap / bin_capacity) < nearly_empty_threshold\n\n    priorities[feasible_bins & nearly_full_bins] -= moderate_fill_penalty\n    priorities[feasible_bins & nearly_empty_bins] -= moderate_fill_penalty\n\n    # 4. Fragmentation Penalty: Heavily penalize bins that will create a very small fragment.\n    fragment_threshold = 0.15\n    fragment_penalty = 0.8\n    fragment_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit / bin_capacity <= fragment_threshold)\n    priorities[fragment_mask] -= fragment_penalty\n\n    # 5. Reward Near-Perfect Fit: Significant bonus for near perfect fits\n    near_perfect_fit_threshold = 0.04\n    near_perfect_fit_bonus = 0.8\n    near_perfect_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit / bin_capacity <= near_perfect_fit_threshold)\n    priorities[near_perfect_mask] += near_perfect_fit_bonus\n\n    # 6. Small Item Penalty: Slightly discourage placing very small items into partially filled bins.  Also, give a slight preference to placing small items in empty bins.\n    small_item_threshold = 0.1\n    small_item_penalty = 0.1\n    small_item = item / bin_capacity < small_item_threshold\n    if small_item:\n        partially_filled_bins = feasible_bins & (bins_remain_cap < bin_capacity) & (bins_remain_cap > 0)\n        empty_bins = bins_remain_cap == bin_capacity\n        priorities[partially_filled_bins] -= small_item_penalty\n        priorities[empty_bins] += small_item_penalty / 2  # Slight preference for empty bins\n\n    # 7. Bin balancing: Try to balance the fill levels of the bins\n    bin_fill_levels = (bin_capacity - bins_remain_cap) / bin_capacity\n    mean_fill_level = np.mean(bin_fill_levels)\n    bin_balancing_penalty = 0.05 * np.abs(bin_fill_levels - mean_fill_level)\n    priorities -= bin_balancing_penalty\n\n    # Simplified rule: Slightly prefer bins with capacity closest to item size\n    priority_item_fit = -np.abs(bins_remain_cap - item) / bin_capacity\n    priorities += 0.02 * priority_item_fit  # Scale to keep it subtle\n\n    # 8. Avoid overfilling bins that are close to full, even if technically feasible now.\n    almost_full_threshold = 0.93\n    almost_full_penalty = 0.6\n    almost_full_bins = (bins_remain_cap / bin_capacity) > (almost_full_threshold - (item / bin_capacity))  # Check before placement\n    priorities[feasible_bins & almost_full_bins] -= almost_full_penalty\n\n    return priorities",
    "response_id": 2,
    "obj": 3.7893897088153174,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response3.txt_stdout.txt",
    "code_path": "problem_iter12_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)\n    normalized_item = item / bin_capacity\n\n    # 1. Feasibility: Infeasible bins get a very large negative priority.\n    feasible_bins = bins_remain_cap >= item\n    priorities[~feasible_bins] = -1e9\n\n    # 2. Best Fit: Prefer bins where the remaining capacity after placement is minimal\n    remaining_after_fit = bins_remain_cap - item\n    remaining_after_fit[~feasible_bins] = bin_capacity * 2  # Set to large value for infeasible bins\n    best_fit_priority = -remaining_after_fit / bin_capacity  # Normalize & invert: smaller remaining is better\n    priorities += best_fit_priority\n\n    # 3. Moderate Fill: Penalize bins that are nearly full or nearly empty *before* item placement.\n    nearly_full_threshold = 0.9\n    nearly_empty_threshold = 0.1\n    moderate_fill_penalty = 0.3\n\n    nearly_full_bins = (bins_remain_cap / bin_capacity) > nearly_full_threshold\n    nearly_empty_bins = (bins_remain_cap / bin_capacity) < nearly_empty_threshold\n\n    priorities[feasible_bins & nearly_full_bins] -= moderate_fill_penalty\n    priorities[feasible_bins & nearly_empty_bins] -= moderate_fill_penalty\n\n    # 4. Fragmentation Penalty: Heavily penalize bins that will create a very small fragment.\n    fragment_threshold = 0.12\n    fragment_penalty = 0.7\n    fragment_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit / bin_capacity <= fragment_threshold)\n    priorities[fragment_mask] -= fragment_penalty\n\n    # 5. Reward Near-Perfect Fit: Significant bonus for near perfect fits\n    near_perfect_fit_threshold = 0.08\n    near_perfect_fit_bonus = 0.6\n    near_perfect_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit / bin_capacity <= near_perfect_fit_threshold)\n    priorities[near_perfect_mask] += near_perfect_fit_bonus\n\n    # 6. Small Item handling: Slightly discourage placing very small items into partially filled bins\n    small_item_threshold = 0.1\n    small_item_penalty = 0.08\n    if normalized_item < small_item_threshold:\n        partially_filled_bins = feasible_bins & (bins_remain_cap < bin_capacity) & (bins_remain_cap > item)\n        priorities[partially_filled_bins] -= small_item_penalty\n\n    # 7. Bin balancing: Try to balance the fill levels of the bins\n    bin_fill_levels = (bin_capacity - bins_remain_cap) / bin_capacity\n    mean_fill_level = np.mean(bin_fill_levels)\n    bin_balancing_penalty = 0.04 * np.abs(bin_fill_levels - mean_fill_level)\n    priorities -= bin_balancing_penalty\n\n    return priorities",
    "response_id": 3,
    "obj": 4.13841244515357,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response4.txt_stdout.txt",
    "code_path": "problem_iter12_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)\n\n    # 1. Feasibility: Infeasible bins get a very large negative priority.\n    feasible_bins = bins_remain_cap >= item\n    priorities[~feasible_bins] = -1e9\n\n    # 2. Best Fit (Raw Capacity): Prefer bins where the remaining capacity after placement is minimal\n    remaining_after_fit = bins_remain_cap - item\n    remaining_after_fit[~feasible_bins] = bin_capacity * 2  # Set to large value for infeasible bins\n    best_fit_priority = -remaining_after_fit  # Smaller remaining is better\n    priorities += best_fit_priority\n\n    # 3. Moderate Fill: Penalize bins that are nearly full or nearly empty *before* item placement.\n    nearly_full_threshold = 0.9\n    nearly_empty_threshold = 0.1\n    moderate_fill_penalty = 0.2\n\n    nearly_full_bins = (bins_remain_cap / bin_capacity) > nearly_full_threshold\n    nearly_empty_bins = (bins_remain_cap / bin_capacity) < nearly_empty_threshold\n\n    priorities[feasible_bins & nearly_full_bins] -= moderate_fill_penalty\n    priorities[feasible_bins & nearly_empty_bins] -= moderate_fill_penalty\n\n    # 4. Fragmentation Penalty: Heavily penalize bins that will create a very small fragment.\n    fragment_threshold = 0.15\n    fragment_penalty = 0.7\n    fragment_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit / bin_capacity <= fragment_threshold)\n    priorities[fragment_mask] -= fragment_penalty\n\n    # 5. Reward Near-Perfect Fit: Significant bonus for near perfect fits\n    near_perfect_fit_threshold = 0.05\n    near_perfect_fit_bonus = 0.6\n    near_perfect_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit / bin_capacity <= near_perfect_fit_threshold)\n    priorities[near_perfect_mask] += near_perfect_fit_bonus\n\n    # 6. Small Item Handling: Adjust penalty/reward for small items based on fill level.\n    small_item_threshold = 0.1\n    small_item_penalty = 0.08\n    small_item_bonus = 0.04\n    small_item = item / bin_capacity < small_item_threshold\n\n    if small_item:\n        partially_filled_bins = feasible_bins & (bins_remain_cap < bin_capacity) & (bins_remain_cap > 0)\n        empty_bins = bins_remain_cap == bin_capacity\n        priorities[partially_filled_bins] -= small_item_penalty\n        priorities[empty_bins] += small_item_bonus\n\n    # 7. Bin balancing: Try to balance the fill levels of the bins.\n    bin_fill_levels = (bin_capacity - bins_remain_cap) / bin_capacity\n    mean_fill_level = np.mean(bin_fill_levels)\n    bin_balancing_penalty = 0.1 * np.abs(bin_fill_levels - mean_fill_level)  # Increased factor\n    priorities -= bin_balancing_penalty\n\n    # 8. Item fit preference.\n    priority_item_fit = -np.abs(bins_remain_cap - item)\n    priorities += 0.05 * priority_item_fit  # Increased scale\n\n    # 9. Empty bin usage. Encourage the use of empty bins early on.\n    is_empty = bins_remain_cap == bin_capacity\n    priorities[feasible_bins & is_empty] += 0.07  # A slight initial preference for empty bins\n\n    # 10. Prioritize bins with higher remaining capacity when item is large\n    large_item_threshold = 0.7\n    if item / bin_capacity > large_item_threshold:\n        priorities[feasible_bins] += 0.03 * bins_remain_cap[feasible_bins]\n\n    return priorities",
    "response_id": 4,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response5.txt_stdout.txt",
    "code_path": "problem_iter12_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)\n    normalized_item = item / bin_capacity\n\n    # 1. Feasibility: Infeasible bins get a very large negative priority.\n    feasible_bins = bins_remain_cap >= item\n    priorities[~feasible_bins] = -1e9\n\n    # 2. Best Fit: Prefer bins where the remaining capacity after placement is minimal.\n    remaining_after_fit = bins_remain_cap - item\n    remaining_after_fit[~feasible_bins] = bin_capacity * 2  # Large value for infeasible bins\n    best_fit_priority = -remaining_after_fit / bin_capacity  # Normalize & invert\n    priorities += best_fit_priority\n\n    # 3. Moderate Fill Penalty (Before Placement): Discourage near-full and near-empty bins. Stronger penalty than v1.\n    nearly_full_threshold = 0.9\n    nearly_empty_threshold = 0.1\n    moderate_fill_penalty = 0.5\n\n    nearly_full_bins = (bins_remain_cap / bin_capacity) > nearly_full_threshold\n    nearly_empty_bins = (bins_remain_cap / bin_capacity) < nearly_empty_threshold\n\n    priorities[feasible_bins & nearly_full_bins] -= moderate_fill_penalty\n    priorities[feasible_bins & nearly_empty_bins] -= moderate_fill_penalty\n\n    # 4. Fragmentation Penalty: Heavily penalize creating small fragments, scale to item size.\n    fragment_threshold = 0.15\n    fragment_penalty = 1.0  # Stronger penalty\n    fragment_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit / bin_capacity <= fragment_threshold)\n    priorities[fragment_mask] -= fragment_penalty * normalized_item # Scale by item size\n\n    # 5. Reward Near-Perfect Fit: Significant bonus for near perfect fits.\n    near_perfect_fit_threshold = 0.05\n    near_perfect_fit_bonus = 0.8  # Stronger bonus\n    near_perfect_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit / bin_capacity <= near_perfect_fit_threshold)\n    priorities[near_perfect_mask] += near_perfect_fit_bonus\n\n    # 6. Small Item Handling: Discourage placing very small items into partially filled bins; prefer empty bins.\n    small_item_threshold = 0.1\n    small_item_penalty = 0.3  # Increased penalty\n    small_item = normalized_item < small_item_threshold\n    if small_item:\n        partially_filled_bins = feasible_bins & (bins_remain_cap < bin_capacity) & (bins_remain_cap > 0)\n        empty_bins = bins_remain_cap == bin_capacity\n        priorities[partially_filled_bins] -= small_item_penalty\n        priorities[empty_bins] += small_item_penalty / 2  # Prefer empty bins, but less strongly\n\n    # 7. Bin balancing: Try to balance the fill levels of the bins. Less important than other factors.\n    bin_fill_levels = (bin_capacity - bins_remain_cap) / bin_capacity\n    mean_fill_level = np.mean(bin_fill_levels)\n    bin_balancing_penalty = 0.03 * np.abs(bin_fill_levels - mean_fill_level)  # Reduce penalty\n    priorities -= bin_balancing_penalty\n\n    return priorities",
    "response_id": 5,
    "obj": 4.2181890706023095,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response6.txt_stdout.txt",
    "code_path": "problem_iter12_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)\n    normalized_item = item / bin_capacity\n\n    # 1. Feasibility: Infeasible bins get a very large negative priority.\n    feasible_bins = bins_remain_cap >= item\n    priorities[~feasible_bins] = -1e9\n\n    # 2. Best Fit: Prefer bins where the remaining capacity after placement is minimal\n    remaining_after_fit = bins_remain_cap - item\n    remaining_after_fit[~feasible_bins] = bin_capacity * 2  # Set to large value for infeasible bins\n    best_fit_priority = -remaining_after_fit / bin_capacity  # Normalize & invert: smaller remaining is better\n    priorities += best_fit_priority\n\n    # 3. Fragmentation Penalty: Heavily penalize bins that will create a very small fragment.\n    fragment_threshold = 0.12\n    fragment_penalty = 0.8\n    fragment_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit / bin_capacity <= fragment_threshold)\n    priorities[fragment_mask] -= fragment_penalty\n\n    # 4. Reward Near-Perfect Fit: Significant bonus for near perfect fits\n    near_perfect_fit_threshold = 0.04\n    near_perfect_fit_bonus = 0.7\n    near_perfect_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit / bin_capacity <= near_perfect_fit_threshold)\n    priorities[near_perfect_mask] += near_perfect_fit_bonus\n\n    # 5. Small Item Handling: Slightly discourage placing very small items into partially filled bins, strongly prefer empty bins.\n    small_item_threshold = 0.1\n    small_item_penalty = 0.2\n    small_item = item / bin_capacity < small_item_threshold\n    if small_item:\n        partially_filled_bins = feasible_bins & (bins_remain_cap < bin_capacity) & (bins_remain_cap > item)\n        empty_bins = bins_remain_cap == bin_capacity\n        priorities[partially_filled_bins] -= small_item_penalty\n        priorities[empty_bins] += small_item_penalty\n\n    # 6. Bin balancing: Try to balance the fill levels of the bins - only if not a near perfect fit.\n    bin_fill_levels = (bin_capacity - bins_remain_cap) / bin_capacity\n    mean_fill_level = np.mean(bin_fill_levels)\n    bin_balancing_penalty = 0.04 * np.abs(bin_fill_levels - mean_fill_level)\n    priorities[~near_perfect_mask] -= bin_balancing_penalty[~near_perfect_mask]  # Apply bin balancing only if not near perfect\n\n    # 7. Large item encouragement for nearly full bins:\n    large_item_threshold = 0.7\n    nearly_full_threshold = 0.9\n    large_item_bonus = 0.3\n    large_item = item / bin_capacity > large_item_threshold\n    nearly_full_bins = feasible_bins & (bins_remain_cap / bin_capacity <= 1 - nearly_full_threshold)\n    if large_item:\n        priorities[nearly_full_bins] += large_item_bonus\n    return priorities",
    "response_id": 6,
    "obj": 3.3905065815716,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response7.txt_stdout.txt",
    "code_path": "problem_iter12_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)\n    normalized_item = item / bin_capacity\n\n    # 1. Feasibility: Infeasible bins get a very large negative priority.\n    feasible_bins = bins_remain_cap >= item\n    priorities[~feasible_bins] = -1e9\n\n    # 2. Best Fit: Prefer bins where the remaining capacity after placement is minimal\n    remaining_after_fit = bins_remain_cap - item\n    remaining_after_fit[~feasible_bins] = bin_capacity * 2  # Set to large value for infeasible bins\n    best_fit_priority = -remaining_after_fit / bin_capacity  # Normalize & invert: smaller remaining is better\n    priorities += best_fit_priority\n\n    # 3. Moderate Fill: Penalize bins that are nearly full or nearly empty *before* item placement.\n    nearly_full_threshold = 0.9\n    nearly_empty_threshold = 0.1\n    moderate_fill_penalty = 0.3\n\n    nearly_full_bins = (bins_remain_cap / bin_capacity) > nearly_full_threshold\n    nearly_empty_bins = (bins_remain_cap / bin_capacity) < nearly_empty_threshold\n\n    priorities[feasible_bins & nearly_full_bins] -= moderate_fill_penalty\n    priorities[feasible_bins & nearly_empty_bins] -= moderate_fill_penalty\n\n    # 4. Fragmentation Penalty: Heavily penalize bins that will create a very small fragment.\n    fragment_threshold = 0.15\n    fragment_penalty = 0.8\n    fragment_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit / bin_capacity <= fragment_threshold)\n    priorities[fragment_mask] -= fragment_penalty\n\n    # 5. Reward Near-Perfect Fit: Significant bonus for near perfect fits\n    near_perfect_fit_threshold = 0.05\n    near_perfect_fit_bonus = 0.7\n    near_perfect_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit / bin_capacity <= near_perfect_fit_threshold)\n    priorities[near_perfect_mask] += near_perfect_fit_bonus\n\n    # 6. Small Item Penalty: Slightly discourage placing very small items into partially filled bins.  Also, give a slight preference to placing small items in empty bins.\n    small_item_threshold = 0.1\n    small_item_penalty = 0.1\n    small_item = normalized_item < small_item_threshold\n    if small_item:\n        partially_filled_bins = feasible_bins & (bins_remain_cap < bin_capacity) & (bins_remain_cap > 0)\n        empty_bins = bins_remain_cap == bin_capacity\n        priorities[partially_filled_bins] -= small_item_penalty * normalized_item # Scale by item size\n        priorities[empty_bins] += small_item_penalty / 2 * normalized_item # Scale by item size\n\n\n    # 7. Bin balancing: Try to balance the fill levels of the bins\n    bin_fill_levels = (bin_capacity - bins_remain_cap) / bin_capacity\n    mean_fill_level = np.mean(bin_fill_levels)\n    bin_balancing_penalty = 0.05 * np.abs(bin_fill_levels - mean_fill_level)\n    priorities -= bin_balancing_penalty\n\n    # 8. Encourage using bins that are already somewhat filled, but not too full.\n    medium_filled_threshold_lower = 0.3\n    medium_filled_threshold_upper = 0.7\n    medium_filled_bonus = 0.1 #Increased bonus\n\n    medium_filled_bins = feasible_bins & \\\n                         (bins_remain_cap / bin_capacity < 1 - medium_filled_threshold_lower) & \\\n                         (bins_remain_cap / bin_capacity > 1 - medium_filled_threshold_upper)\n\n    priorities[medium_filled_bins] += medium_filled_bonus\n\n    return priorities",
    "response_id": 7,
    "obj": 3.280813721579586,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response8.txt_stdout.txt",
    "code_path": "problem_iter12_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)\n    normalized_item = item / bin_capacity\n\n    # 1. Feasibility: Infeasible bins get a very large negative priority.\n    feasible_bins = bins_remain_cap >= item\n    priorities[~feasible_bins] = -1e9\n\n    # 2. Best Fit: Prefer bins where the remaining capacity after placement is minimal\n    remaining_after_fit = bins_remain_cap - item\n    remaining_after_fit[~feasible_bins] = bin_capacity * 2  # Set to large value for infeasible bins\n    best_fit_priority = -remaining_after_fit / bin_capacity  # Normalize & invert: smaller remaining is better\n    priorities += best_fit_priority\n\n    # 3. Moderate Fill: Penalize bins that are nearly full or nearly empty *before* item placement.\n    nearly_full_threshold = 0.85\n    nearly_empty_threshold = 0.15\n    moderate_fill_penalty = 0.3\n\n    nearly_full_bins = (bins_remain_cap / bin_capacity) > nearly_full_threshold\n    nearly_empty_bins = (bins_remain_cap / bin_capacity) < nearly_empty_threshold\n\n    priorities[feasible_bins & nearly_full_bins] -= moderate_fill_penalty\n    priorities[feasible_bins & nearly_empty_bins] -= moderate_fill_penalty\n\n    # 4. Fragmentation Penalty: Heavily penalize bins that will create a very small fragment.\n    fragment_threshold = 0.1\n    fragment_penalty = 0.7\n    fragment_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit / bin_capacity <= fragment_threshold)\n    priorities[fragment_mask] -= fragment_penalty\n\n    # 5. Reward Near-Perfect Fit: Significant bonus for near perfect fits\n    near_perfect_fit_threshold = 0.06\n    near_perfect_fit_bonus = 0.6\n    near_perfect_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit / bin_capacity <= near_perfect_fit_threshold)\n    priorities[near_perfect_mask] += near_perfect_fit_bonus\n\n    # 6. Small Item Handling: Prefer near-empty, avoid partially filled.\n    small_item_threshold = 0.1\n    if normalized_item < small_item_threshold:\n        partially_filled_bins = feasible_bins & (bins_remain_cap < bin_capacity) & (bins_remain_cap > item)\n        near_empty_bins = feasible_bins & (bins_remain_cap > 0.9 * bin_capacity)\n        priorities[partially_filled_bins] -= 0.15\n        priorities[near_empty_bins] += 0.1\n\n    # 7. Bin balancing: Try to balance the fill levels of the bins\n    bin_fill_levels = (bin_capacity - bins_remain_cap) / bin_capacity\n    mean_fill_level = np.mean(bin_fill_levels)\n    bin_balancing_penalty = 0.04 * np.abs(bin_fill_levels - mean_fill_level)\n    priorities -= bin_balancing_penalty\n\n    return priorities",
    "response_id": 8,
    "obj": 5.265257279617068,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response9.txt_stdout.txt",
    "code_path": "problem_iter12_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)\n    normalized_item = item / bin_capacity\n\n    # 1. Feasibility: Infeasible bins get a very large negative priority.\n    feasible_bins = bins_remain_cap >= item\n    priorities[~feasible_bins] = -1e9\n\n    # 2. Best Fit: Prefer bins where the remaining capacity after placement is minimal\n    remaining_after_fit = bins_remain_cap - item\n    remaining_after_fit[~feasible_bins] = bin_capacity * 2  # Set to large value for infeasible bins\n    best_fit_priority = -remaining_after_fit / bin_capacity  # Normalize & invert: smaller remaining is better\n    priorities += best_fit_priority\n\n    # 3. Moderate Fill: Penalize bins that are nearly full or nearly empty *before* item placement.\n    nearly_full_threshold = 0.9\n    nearly_empty_threshold = 0.1\n    moderate_fill_penalty = 0.3\n\n    nearly_full_bins = (bins_remain_cap / bin_capacity) > nearly_full_threshold\n    nearly_empty_bins = (bins_remain_cap / bin_capacity) < nearly_empty_threshold\n\n    priorities[feasible_bins & nearly_full_bins] -= moderate_fill_penalty\n    priorities[feasible_bins & nearly_empty_bins] -= moderate_fill_penalty\n\n    # 4. Fragmentation Penalty: Heavily penalize bins that will create a very small fragment.\n    fragment_threshold = 0.15\n    fragment_penalty = 0.8\n    fragment_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit / bin_capacity <= fragment_threshold)\n    priorities[fragment_mask] -= fragment_penalty\n\n    # 5. Reward Near-Perfect Fit: Significant bonus for near perfect fits\n    near_perfect_fit_threshold = 0.05\n    near_perfect_fit_bonus = 0.7\n    near_perfect_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit / bin_capacity <= near_perfect_fit_threshold)\n    priorities[near_perfect_mask] += near_perfect_fit_bonus\n\n    # 6. Small Item Handling: Discourage placing very small items into partially filled bins.\n    small_item_threshold = 0.1\n    small_item_penalty = 0.1\n    if normalized_item < small_item_threshold:\n        partially_filled_bins = feasible_bins & (bins_remain_cap < bin_capacity) & (bins_remain_cap > item)\n        priorities[partially_filled_bins] -= small_item_penalty\n\n    # 7. Bin balancing: Try to balance the fill levels of the bins\n    bin_fill_levels = (bin_capacity - bins_remain_cap) / bin_capacity\n    mean_fill_level = np.mean(bin_fill_levels)\n    bin_balancing_penalty = 0.05 * np.abs(bin_fill_levels - mean_fill_level)\n    priorities -= bin_balancing_penalty\n\n    # 8. Encourage using bins that are already somewhat filled, but not too full.\n    medium_filled_threshold_lower = 0.3\n    medium_filled_threshold_upper = 0.7\n    medium_filled_bonus = 0.08\n\n    medium_filled_bins = feasible_bins & \\\n                         (bins_remain_cap / bin_capacity < 1 - medium_filled_threshold_lower) & \\\n                         (bins_remain_cap / bin_capacity > 1 - medium_filled_threshold_upper)\n\n    priorities[medium_filled_bins] += medium_filled_bonus\n\n    return priorities",
    "response_id": 9,
    "obj": 3.230953330674122,
    "exec_success": true
  }
]