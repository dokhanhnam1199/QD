[
  {
    "stdout_filepath": "problem_iter1_response0.txt_stdout.txt",
    "code_path": "problem_iter1_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Rule 1: Prefer bins that can fit the item.\n    can_fit = bins_remain_cap >= item\n    priorities[can_fit] += 1.0\n\n    # Rule 2: Give higher priority to bins with less remaining capacity after packing. The smaller the remaining cap, the better fit and fewer fragmentation\n    remaining_after_fit = bins_remain_cap[can_fit] - item\n    priorities[can_fit] += np.exp(-remaining_after_fit) # Exponentiated to give more weight to smaller values\n    \n    # Rule 3: Penalize bins that waste a lot of space if item cannot fit. This is a desperation strategy\n    cannot_fit = ~can_fit #np.logical_not(can_fit) #bins_remain_cap < item\n    waste = item - bins_remain_cap[cannot_fit]\n    priorities[cannot_fit] -= waste*0.0001 # Penalize very small amount for bins that cannot fit it, preventing infinite penalty\n\n    # Rule 4: Add a small random number for tie-breaking.\n    priorities += np.random.rand(len(bins_remain_cap)) * 0.000001 #small noise for tie breaking\n    \n    return priorities",
    "response_id": 0,
    "obj": 24.481451934583166,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response1.txt_stdout.txt",
    "code_path": "problem_iter1_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # 1. Feasibility: Assign 0 priority to bins that can't fit the item\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -np.inf\n\n    # 2. Best Fit: Prioritize bins with the smallest remaining capacity *after* adding the item\n    #    This encourages filling bins tightly.  But, only consider bins that *can* fit the item\n    \n    feasible_bins = ~infeasible_bins\n    remaining_after_fit = bins_remain_cap[feasible_bins] - item\n    priorities[feasible_bins] = -remaining_after_fit\n\n    # 3. Tie-breaker: Slightly prioritize bins with higher initial capacity.\n    #    This can help avoid fragmenting bins too much, as larger bins may be better for future items.\n    #    The effect should be small relative to best-fit. We do this by subtracting from -remaining_after_fit a scaled value.\n    \n    priorities[feasible_bins] -= bins_remain_cap[feasible_bins] / np.max(bins_remain_cap) / 1000.0\n\n    # 4.  Use the capacity to get a proportion.\n\n    #Return final priorities array\n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response2.txt_stdout.txt",
    "code_path": "problem_iter1_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Calculate wasted space if the item is placed in each bin\n    wasted_space = bins_remain_cap - item\n\n    # Assign high priority to bins where the item fits and leaves minimal wasted space\n    fit_indices = wasted_space >= 0\n    if np.any(fit_indices):\n        priorities[fit_indices] = 1 / (wasted_space[fit_indices] + 1e-6)  # Avoid division by zero\n\n        # Further prioritize bins with larger remaining capacity after placing the item (to handle similar wasted space values)\n        priorities[fit_indices] += bins_remain_cap[fit_indices] / np.max(bins_remain_cap[fit_indices])\n    else:\n        # If item doesn't fit in any bin, try to fit in the bin with largest capacity\n        priorities = bins_remain_cap / np.max(bins_remain_cap)\n        priorities = priorities * 0.1 # very low probability of adding to the bin if wasted space is not availabe\n\n    return priorities",
    "response_id": 2,
    "obj": 84.7726366174711,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response3.txt_stdout.txt",
    "code_path": "problem_iter1_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # 1. Feasibility: High priority for bins that can fit the item.\n    feasible_bins = bins_remain_cap >= item\n    priorities[feasible_bins] += 1\n\n    # 2. Remaining Capacity: Prefer bins with less remaining capacity after placing the item\n    #    (but only among feasible bins).  This encourages filling bins completely.\n    remaining_after_fit = bins_remain_cap - item\n    remaining_after_fit[remaining_after_fit < 0] = np.inf # Penalize infeasible bins\n\n    # Normalize the remaining capacity scores\n    normalized_remaining = np.where(feasible_bins, 1 - (remaining_after_fit / np.max(bins_remain_cap)), 0)\n\n    priorities += normalized_remaining\n\n    # 3. Avoidance of Fragmentation: Penalize bins that will leave a small unusable fragment.\n    fragment_threshold = 0.1  # Define a threshold for small fragments relative to bin size\n\n    for i in range(len(bins_remain_cap)):\n        if feasible_bins[i]:\n          fragment = bins_remain_cap[i] - item\n          if 0 < fragment <= fragment_threshold:\n              priorities[i] -= 0.5\n\n    return priorities",
    "response_id": 3,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response4.txt_stdout.txt",
    "code_path": "problem_iter1_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: High priority if the item fits.\n    feasible = bins_remain_cap >= item\n    priorities[feasible] += 1  # Give a base priority for fitting\n\n    # 2. Remaining Capacity: Higher priority for bins with tighter fit.\n    remaining_space = bins_remain_cap - item\n    remaining_space[~feasible] = np.inf  # Ignore infeasible bins\n\n    # Give higher priority to bins where space is tight\n    priorities[feasible] += 1.0 / (remaining_space[feasible] + 0.0001) # avoid division by zero\n\n    # 3. Avoidance of Fragmentation: Penalize bins with too much space *after* packing\n    # Give a negative priority for bins that would result in excessive wasted space\n    large_remaining_space = remaining_space > 0.5\n    priorities[feasible & large_remaining_space] -= 0.5 * remaining_space[feasible & large_remaining_space]\n\n\n    # 4. Give a slight boost to bins that are relatively empty in general (First-Fit-like behavior).\n    priorities += 0.1 * bins_remain_cap  # Encourage using emptier bins earlier.\n\n    return priorities",
    "response_id": 4,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response5.txt_stdout.txt",
    "code_path": "problem_iter1_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Give a high priority to bins that can accommodate the item\n    can_accommodate = bins_remain_cap >= item\n    priorities[can_accommodate] += 1  # Base priority for being able to fit\n\n    # Prioritize bins where the remaining capacity after adding the item is small but non-negative.\n    remaining_after_fit = bins_remain_cap - item\n    \n    valid_remaining = remaining_after_fit[can_accommodate]\n\n    if valid_remaining.size > 0:\n      normalized_remaining = 1 / (valid_remaining + 1e-6)  # Adding small epsilon to avoid division by zero. Higher priority if remaining is small.\n      priorities[can_accommodate] += normalized_remaining\n    \n    # Give a lower priority to almost full bins to avoid creating bins with tiny wasted space if possible.\n    almost_full = (bins_remain_cap < item + 0.1) & (bins_remain_cap >= item) # small value to consider the precision\n    priorities[almost_full] -= 0.5 # discourage if almost full, yet accommodates.\n    \n    return priorities",
    "response_id": 5,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response6.txt_stdout.txt",
    "code_path": "problem_iter1_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # First priority: Can the item fit?\n    can_fit = bins_remain_cap >= item\n    priorities[can_fit] += 1\n\n    # Second priority: How much space is left after packing? Smaller is better (First Fit Decreasing inspiration).\n    remaining_space = bins_remain_cap - item\n    remaining_space[~can_fit] = np.inf  # Ignore bins where it doesn't fit\n\n    # Invert remaining space, so smaller values have higher priority\n    priorities[can_fit] += np.max(remaining_space[can_fit]) - remaining_space[can_fit] if np.any(can_fit) else 0\n    # Third priority: Favour bins which are almost full. Try to fill them up as best as we can to avoid having bins with small items.\n    almost_full = np.logical_and(bins_remain_cap > 0, bins_remain_cap < 2 * item)\n    priorities[almost_full] += 0.5\n    \n    # Fourth priority: If no bin can fit, severely penalize adding it to any bin, by adding very small negative value.\n    if not np.any(can_fit):\n        priorities -= 0.01\n\n    return priorities",
    "response_id": 6,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 24, in priority_v2\n    \nnumpy._core._exceptions._UFuncOutputCastingError: Cannot cast ufunc 'add' output from dtype('float64') to dtype('int64') with casting rule 'same_kind'\n"
  },
  {
    "stdout_filepath": "problem_iter1_response7.txt_stdout.txt",
    "code_path": "problem_iter1_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Calculate wasted space if item is placed in the bin.\n    wasted_space = bins_remain_cap - item\n    \n    # Give very low priority (negative) to bins that cannot fit the item.\n    priorities[wasted_space < 0] = -np.inf\n    \n    # Higher priority to bins where wasted space is small, but not too small.\n    # The goal is to avoid filling bins too tightly and instead aim for bins \n    # that allow for future items to be packed as well. Avoid bins that are over 95% full.\n    \n    # Find bins that can fit the item.\n    fit_bins = wasted_space >= 0\n    \n    # Calculate fill ratios for bins that can fit.\n    fill_ratios = np.zeros_like(bins_remain_cap, dtype=float)\n    fill_ratios[fit_bins] = item / bins_remain_cap[fit_bins]\n\n    # Give preference to bins that are filled reasonably well.\n    priorities[fit_bins] = np.exp(-np.abs(fill_ratios[fit_bins] - 0.75)) # Prefer bins filled around 75%\n\n    # Reduce the priority if the bin is almost full. A filled ratio > 0.95 incurs a heavy penalty.\n    almost_full = fit_bins & (fill_ratios > 0.95)\n    priorities[almost_full] *= 0.1\n    \n    # Give small bonus for almost-full bins to reduce fragmentation if there's no other option, but ensure it is worse than good fit if possible.\n    # Note: this is usually a bad idea to prioritize since the problem is more about item size variance.\n    return priorities",
    "response_id": 7,
    "obj": 9.064619066613492,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response8.txt_stdout.txt",
    "code_path": "problem_iter1_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Give a high priority to bins where the item fits snugly, but not too snugly.\n    fit_mask = bins_remain_cap >= item\n    space_left = bins_remain_cap - item\n    priorities[fit_mask] = (item / bins_remain_cap[fit_mask])  # Ratio of item size to bin capacity (higher is better fit)\n\n    # Penalize bins with very little space remaining after the item is placed\n    small_space_mask = (space_left[fit_mask] < 0.1) & fit_mask  # Example: Penalize if space left is less than 0.1\n    priorities[small_space_mask] = priorities[small_space_mask] * 0.5  # Reduce priority\n\n    # Penalize bins with significant space remaining after the item is placed\n    large_space_mask = (space_left[fit_mask] > 0.5) & fit_mask #Example: if there's half the bin left\n    priorities[large_space_mask] = priorities[large_space_mask] * 0.8\n    \n    # Give bins with space available a base priority, so all will be compared.\n    priorities[fit_mask] = priorities[fit_mask] + 0.1\n\n    return priorities",
    "response_id": 8,
    "obj": 4.9760670123653865,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response9.txt_stdout.txt",
    "code_path": "problem_iter1_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # 1. Feasibility check:\n    feasible_bins = bins_remain_cap >= item\n    \n    # If no bin is feasible, return low priority for all bins\n    if not np.any(feasible_bins):\n      return priorities\n\n    # 2. Prioritize bins that can fit the item, but are close to being full after packing.\n    fill_levels = (bins_remain_cap[feasible_bins] - item) / np.max(bins_remain_cap) # Normalized\n    priorities[feasible_bins] = 1 - fill_levels # Higher priority for bins close to being full\n    \n    # 3. Add a bonus for bins that have been used a lot already to consolidate items\n    used_bins = bins_remain_cap < np.max(bins_remain_cap)\n    priorities[used_bins] += 0.2 # Add a bonus to already used bins.  Slightly more aggressive than v1. This constant can be tuned.\n\n    # 4. Introduce small random noise to break ties and explore different solutions\n    priorities += np.random.rand(len(bins_remain_cap)) * 0.01\n\n    return priorities",
    "response_id": 9,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response10.txt_stdout.txt",
    "code_path": "problem_iter1_code10.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # First, give a large negative priority to bins that cannot fit the item\n    priorities[bins_remain_cap < item] = -np.inf\n\n    # For bins that can fit, calculate a score based on remaining capacity after packing\n    remaining_capacity_after_pack = bins_remain_cap - item\n    \n    # Prioritize bins where the item fits best (least remaining space), but avoid nearly full bins.\n    # We can balance these two factors.\n    \n    # Option 1: Linear combination of remaining capacity and inverse of remaining capacity.\n    # This prioritizes bins with smallest remaining capacity.\n    priorities[bins_remain_cap >= item] = (1 / (remaining_capacity_after_pack[bins_remain_cap >= item] + 1e-6)) + bins_remain_cap[bins_remain_cap >= item] # adding small epsilon value to avoid division by zero\n\n    \n    # Option 2: Use a function that decreases sharply when the remaining capacity is small.\n    # This might involve an exponential function.\n\n    # Option 3: Reward bins that result in some remaining capacity relative to item size\n    #priorities[bins_remain_cap >= item] = np.exp(-remaining_capacity_after_pack[bins_remain_cap >= item] / item)\n\n    #Option 4: give very large reward if the remaining capacity is close to some target capacity.\n    #target_capacity = 0.5 #try to get half of the capacity\n    #distance = np.abs(remaining_capacity_after_pack - target_capacity)\n    #priorities[bins_remain_cap >= item] = -distance[bins_remain_cap >= item]\n        \n    return priorities",
    "response_id": 10,
    "obj": 86.58755484643,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response11.txt_stdout.txt",
    "code_path": "problem_iter1_code11.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: Prioritize bins that can actually fit the item.\n    feasible_bins = bins_remain_cap >= item\n    priorities[feasible_bins] += 1.0\n\n    # 2. Remaining capacity: Prioritize bins with less remaining capacity after placing the item.\n    remaining_after_fit = bins_remain_cap - item\n    remaining_after_fit[~feasible_bins] = np.inf  # Penalize infeasible bins.\n\n    # Use inverse of remaining capacity to prioritize bins which are almost full\n    priorities[feasible_bins] += 1.0 / (1e-9 + remaining_after_fit[feasible_bins])\n\n    # 3. Fill Ratio: Consider the fill ratio of the bin after adding the item. Avoid very sparse bins.\n    fill_ratio = item / bins_remain_cap\n\n    priorities[feasible_bins] += np.clip(fill_ratio[feasible_bins], 0, 1)\n\n    # 4. Avoid creating very small fragments: Penalize bins where the remaining space after insertion would be very small\n    very_small_fragment = remaining_after_fit < 0.1  # if remaining is < 0.1, strongly penalize. Scale as needed\n    priorities[feasible_bins & very_small_fragment] -= 0.5 #Subtract small constant if creates a small fragment\n\n    #5. Items that perfectly fit: Highest Priority\n    perfect_fit = bins_remain_cap == item\n    priorities[perfect_fit] += 5\n\n    return priorities",
    "response_id": 11,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response12.txt_stdout.txt",
    "code_path": "problem_iter1_code12.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Give high priority to bins where item fits reasonably well.\n    fit_mask = bins_remain_cap >= item\n    priorities[fit_mask] = (bins_remain_cap[fit_mask] - item) / bins_remain_cap[fit_mask] # remaining space ratio. Higher is better\n    \n    # Prioritize bins where the item fits best (smallest remaining space).\n    if np.any(fit_mask):\n        min_waste = np.min(bins_remain_cap[fit_mask] - item)\n        best_fit_mask = (bins_remain_cap - item) == min_waste\n        priorities[best_fit_mask] += 1.0  # Adding a constant boost\n\n    # Penalize bins that are too small (item does not fit), but not too heavily.\n    # This allows smaller bins to be considered later if no better options exist.\n    no_fit_mask = bins_remain_cap < item\n    priorities[no_fit_mask] = - (item - bins_remain_cap[no_fit_mask]) / np.max(bins_remain_cap) # negative, close to 0, larger item smaller bin means larger penality.\n\n    return priorities",
    "response_id": 12,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response13.txt_stdout.txt",
    "code_path": "problem_iter1_code13.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            # Prioritize bins that can fit the item\n            space_waste = cap - item\n            # Minimize space waste (First Fit Decreasing heuristic inspired)\n            priorities[i] = 1 / (space_waste + 0.0001)  # Adding a small value to avoid division by zero\n        else:\n            # Assign a very low priority if the item doesn't fit\n            priorities[i] = -1e9\n\n    return priorities",
    "response_id": 13,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response14.txt_stdout.txt",
    "code_path": "problem_iter1_code14.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if item <= cap:\n            # Basic score based on remaining capacity. Larger remaining capacity, better fit.\n            priority = cap - item\n\n            # Prefer bins where the item fits best (smallest wasted space)\n            priority += 1.0 / (item + 0.0001)  # Add a small constant to prevent division by zero\n\n            # Reward bins that are almost full *after* placing the item.\n            remaining_after = cap - item\n            if remaining_after > 0:\n                priority += np.exp(-10 * remaining_after / np.max(bins_remain_cap)) # Exponential decay\n            else:\n                priority = -np.inf  # Never choose a bin with negative remaining capacity (should be redundant).\n            \n            priorities[i] = priority\n        else:\n            priorities[i] = -np.inf # Item does not fit\n\n    return priorities",
    "response_id": 14,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.999956718995236 seconds"
  },
  {
    "stdout_filepath": "problem_iter1_response15.txt_stdout.txt",
    "code_path": "problem_iter1_code15.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Calculate waste if item is placed in each bin\n    waste = bins_remain_cap - item\n    \n    # Prioritize bins where item fits\n    fit_mask = waste >= 0\n    \n    # If item fits, prioritize based on how much space is left after packing\n    # Smaller waste is better.\n    priorities[fit_mask] = 1 / (waste[fit_mask] + 0.0000001) # Avoid division by zero\n    \n    # Bonus for near-full bins:\n    near_full_threshold = 0.2 #percentage of the bin size considered nearly full\n    near_full_mask = (bins_remain_cap > 0) & (bins_remain_cap <= (item + (np.max(bins_remain_cap) * near_full_threshold))) & fit_mask #Ensure that this applies to a fitting bin\n    \n    priorities[near_full_mask] += 2 #increase the priority to pack those\n\n    \n    # Penalize bins where item doesn't fit, unless none fit.\n    no_fit_mask = waste < 0\n    if np.any(fit_mask):\n        priorities[no_fit_mask] = -np.inf\n    else:\n        #If nothing fits try packing in the bigger bins\n        priorities = bins_remain_cap #just take the remaining cap, bigger is better.\n        #priorities[no_fit_mask] = bins_remain_cap[no_fit_mask]/np.max(bins_remain_cap)\n        #priorities[fit_mask] = np.zeros_like(priorities[fit_mask]) # set to zero because we only pack to those where no_fit_mask is True\n    return priorities",
    "response_id": 15,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response16.txt_stdout.txt",
    "code_path": "problem_iter1_code16.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # First-Fit Decreasing (FFD) inspired priority: Prioritize bins that can fit the item snugly.\n    # A bin is a good fit if the remaining capacity after adding the item is small.\n    \n    fit_check = bins_remain_cap - item\n    \n    # Bins that cannot fit the item get a very low priority\n    priorities[fit_check < 0] = -np.inf \n    \n    # Prioritize bins with smallest remaining capacity *after* placing item,\n    # but give preference to bins which are not too full already.\n    \n    priorities[fit_check >= 0] = 1.0 / (fit_check[fit_check >= 0] + 0.00001) # Avoid division by zero\n    \n    #Adjust priority based on how full the bin already is. Favor almost-full bins, \n    #but less aggressively than those where this new item will make it very full.\n    \n    fullness = 1.0 - bins_remain_cap[fit_check >= 0] / np.max(bins_remain_cap)\n    priorities[fit_check >= 0] += 0.5 * fullness\n    \n    return priorities",
    "response_id": 16,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response17.txt_stdout.txt",
    "code_path": "problem_iter1_code17.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Calculate wasted space if item is placed in each bin\n    wasted_space = bins_remain_cap - item\n\n    # Assign high priority to bins where item fits and wasted space is minimized\n    fit_mask = wasted_space >= 0\n    if np.any(fit_mask):\n        priorities[fit_mask] = 1 / (wasted_space[fit_mask] + 1e-6)  # Avoid division by zero\n    else:\n        #If no bin can fit the item, use worst fit approach (least empty bin)\n        priorities = bins_remain_cap - item\n        priorities = -np.abs(priorities) #prioritze least overfilled\n    return priorities",
    "response_id": 17,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response18.txt_stdout.txt",
    "code_path": "problem_iter1_code18.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Give high priority to bins that can fit the item snugly\n    fit_mask = bins_remain_cap >= item\n    priorities[fit_mask] = (bins_remain_cap[fit_mask] - item) / bins_remain_cap[fit_mask]\n\n    # Give a penalty to bins that cannot fit (but not a total zero). This makes the bins that can fit to stand out.\n    no_fit_mask = bins_remain_cap < item\n    priorities[no_fit_mask] = -item / bins_remain_cap[no_fit_mask]\n    # Add a small constant to bins that can fit to encourage their use\n    priorities[fit_mask] += 0.1\n    \n    return priorities",
    "response_id": 18,
    "obj": 149.30195452732352,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response19.txt_stdout.txt",
    "code_path": "problem_iter1_code19.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            # Best Fit logic: prioritize bins with smallest remaining capacity after adding the item.\n            priorities[i] = 1 / (cap - item + 1e-9)  # Adding a small constant to avoid division by zero.\n        else:\n            priorities[i] = -1e9  # Very low priority if the item doesn't fit.\n\n    return priorities",
    "response_id": 19,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response20.txt_stdout.txt",
    "code_path": "problem_iter1_code20.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Large enough but with smallest waste\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):\n        waste = bins_remain_cap[valid_bins] - item\n        min_waste = np.min(waste)\n        priorities[valid_bins] = 1.0 / (waste + 1e-6)  # Prioritize less waste\n        priorities[valid_bins & (waste == min_waste)] = 10.0 # boost for absolute best fit\n\n    \n    # Incentivize filling up bins even when waste is larger.\n    # This is helpful when items are small compare to bins.\n\n    ratios = item / bins_remain_cap\n\n    priorities += (1-np.clip(ratios, 0.0, 1.0)) * 0.1\n\n    return priorities",
    "response_id": 20,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response21.txt_stdout.txt",
    "code_path": "problem_iter1_code21.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Heuristic 1: Prefer bins where the item fits and leaves minimal waste\n    fit_mask = bins_remain_cap >= item\n    waste = bins_remain_cap - item\n    \n    priorities[fit_mask] = 1 / (waste[fit_mask] + 1e-6)  # Avoid division by zero\n\n    # Heuristic 2: Give a bonus to bins that are nearly full *before* adding the item\n    # (encourage filling bins that are already substantially utilized)\n    # The \"+ item\" check helps to prefer bins where we actually CAN add the item\n    nearly_full_threshold = 0.8\n    nearly_full_mask = (bins_remain_cap / bins_remain_cap.max() >= nearly_full_threshold) & fit_mask\n    priorities[nearly_full_mask] += 2\n\n    # Heuristic 3: Avoid bins that are too empty after placing the item.\n    # Only consider it when the item actually fits. This aims at balancing utilization\n    too_empty_threshold = 0.2 * bins_remain_cap.max()\n    too_empty_mask = (waste < too_empty_threshold) & fit_mask\n    priorities[too_empty_mask] += 1\n    \n\n    # Heuristic 4: If no bin can fit the item, choose the one with max capacity\n    if not np.any(fit_mask):\n        priorities = bins_remain_cap / bins_remain_cap.max()\n\n    return priorities",
    "response_id": 21,
    "obj": 57.4890307140008,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response22.txt_stdout.txt",
    "code_path": "problem_iter1_code22.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    # First Fit Decreasing heuristic: Give preference to bins that can accommodate the item\n    # with minimal wasted space\n    \n    # Give very low priority to bins that cannot fit the item\n    priorities[bins_remain_cap < item] = -np.inf\n    \n    # Prioritize bins that fit the item, with preference for bins with less remaining space\n    # after the item is added (i.e. a \"more full\" bin is better)\n    \n    remaining_space = bins_remain_cap - item\n    \n    # Prioritize by inverse of remaining space, so smaller remaining space = higher priority\n    priorities[bins_remain_cap >= item] = 1.0 / (remaining_space[bins_remain_cap >= item] + 0.00001) # add small number to avoid division by zero errors\n    \n    #Bonus: Give a tiny additional boost to bins that are currently empty (to encourage opening new bins less)\n    priorities[bins_remain_cap == 1.0] += 0.0001\n\n    return priorities",
    "response_id": 22,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 19, in priority_v2\n    priorities[wasted_space < 0] = -np.inf\nOverflowError: cannot convert float infinity to integer\n"
  },
  {
    "stdout_filepath": "problem_iter1_response23.txt_stdout.txt",
    "code_path": "problem_iter1_code23.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Calculate wasted space if item is placed in each bin\n    wasted_space = bins_remain_cap - item\n\n    # Give very low priority to bins that cannot fit the item\n    priorities[wasted_space < 0] = -np.inf\n\n    # Give higher priority to bins where wasted space is minimized but not too tight (to allow future items)\n    # The ideal wasted space is somewhere around item_size / 2 (can be adjusted)\n    ideal_wasted_space = item / 2.0\n\n    # A bin with a capacity which fits the item the best to ideal waste is preferred\n    distance_from_ideal = np.abs(wasted_space - ideal_wasted_space)\n    priorities[wasted_space >= 0] = -distance_from_ideal[wasted_space >= 0]\n\n    # Adjust for bin usage: slightly prefer partially full bins to encourage balanced packing.\n    # This adds a small bonus for using bins that aren't nearly full or nearly empty after placement.\n    usage_bonus = np.where(wasted_space >= 0, np.clip(bins_remain_cap[wasted_space >= 0] * item / np.power(np.mean(bins_remain_cap), 2.0),0,1), 0)\n    priorities[wasted_space >= 0] += usage_bonus\n\n    # Even out probabilities when all possible moves are very bad\n    if np.all(priorities == -np.inf):\n        priorities = np.ones_like(bins_remain_cap) / len(bins_remain_cap)\n\n\n    return priorities",
    "response_id": 23,
    "obj": 9.493418428400483,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response24.txt_stdout.txt",
    "code_path": "problem_iter1_code24.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Calculate remaining capacity after adding the item\n    remaining_after_add = bins_remain_cap - item\n\n    # Give high priority to bins that can fit the item perfectly or near perfectly\n    perfect_fit_bonus = np.exp(-np.abs(remaining_after_add) / (item + 1e-6)) # Avoid division by zero\n    priorities += perfect_fit_bonus\n\n    # Give some priority to bins that can fit the item, but less than perfect fit\n    can_fit = remaining_after_add >= 0\n    priorities[can_fit] += 0.5 * (bins_remain_cap[can_fit] / np.sum(bins_remain_cap[can_fit] + 1e-6))\n\n    # Penalize bins that cannot fit the item (make it a lower priority). Avoid infinite penalty\n    cannot_fit = remaining_after_add < 0\n    priorities[cannot_fit] -= np.abs(remaining_after_add[cannot_fit]) / (np.max(bins_remain_cap) + 1e-6)\n\n    #Prioritize bins that are relatively full to avoid creating bins with just a small items\n    relative_fullness = (np.max(bins_remain_cap)-bins_remain_cap) / (np.max(bins_remain_cap) + 1e-6)\n    priorities += 0.2 * relative_fullness\n    return priorities",
    "response_id": 24,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response25.txt_stdout.txt",
    "code_path": "problem_iter1_code25.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # First, find bins that can actually fit the item\n    feasible_bins = bins_remain_cap >= item\n\n    # If no bin can fit the item, assign a low priority to all bins (to signal a new bin is needed). A negative value\n    # should be enough.\n    if not np.any(feasible_bins):\n      return np.full_like(bins_remain_cap, -1.0)\n\n    # For feasible bins, calculate a score based on remaining capacity\n    for i in range(len(bins_remain_cap)):\n        if feasible_bins[i]:\n            remaining_after_fit = bins_remain_cap[i] - item\n            \n            # A: Prioritize bins that result in a good fill ratio\n            fill_ratio = item / bins_remain_cap[i]\n            priorities[i] = fill_ratio\n\n            # B: Add bonus for near-full bins after placement. Prevents fragmentation.\n            if remaining_after_fit > 0:\n              near_full_bonus = np.exp(-10*remaining_after_fit / bins_remain_cap[i]) #Sharp decrease.  Higher = nearer to full\n              priorities[i] += near_full_bonus\n            \n            # C: Slight penalty for excessive waste.  Encourages closer fits\n            if remaining_after_fit > item/2:\n              waste_penalty = 0.1 * remaining_after_fit/bins_remain_cap[i]\n              priorities[i] -= waste_penalty\n        else:\n            # Assign very low priority to infeasible bins\n            priorities[i] = -1e9 # Arbitrarily low number\n\n    return priorities",
    "response_id": 25,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.999991339980625 seconds"
  },
  {
    "stdout_filepath": "problem_iter1_response26.txt_stdout.txt",
    "code_path": "problem_iter1_code26.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Calculate remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n\n    # Prioritize bins that can accommodate the item\n    eligible_bins = remaining_capacities >= 0\n    priorities[eligible_bins] = bins_remain_cap[eligible_bins] - item  # Favor bins with smaller resulting waste\n    # Penalize bins that cannot accommodate the item heavily\n    priorities[~eligible_bins] = -1e9 # A very low value\n\n    # Further refine prioritization among eligible bins\n    # Give higher priority to bins with smaller remaining capacity *after* packing the item\n    priorities[eligible_bins] = 1.0 / (1e-6 + remaining_capacities[eligible_bins]) #avoid division by zero. Smaller cap -> High priority\n\n    # Boost bins that are nearly full after placing the item\n    nearly_full = (remaining_capacities >= 0) & (remaining_capacities <= 0.1) #thresholds can be adjusted\n    priorities[nearly_full] += 10 # Increased boost can prevent unnecessary new bins\n\n\n    return priorities",
    "response_id": 26,
    "obj": 4.198244914240141,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response27.txt_stdout.txt",
    "code_path": "problem_iter1_code27.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Rule 1: If the item fits perfectly, give it the highest priority.\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    priorities[perfect_fit] = np.inf\n\n    # Rule 2: Prioritize bins where the remaining capacity is greater than the item size.\n    # This is essential, as it avoids any exceptions later if a bin is selected when it doesnt even fit\n    does_not_fit = bins_remain_cap < item\n    priorities[does_not_fit] = -np.inf\n    \n    # Rule 3: Next-fit modification: Give some priority to bins with small space.\n\n    small_space = (bins_remain_cap > item) & (bins_remain_cap <= 2 * item) # space between item and 2* item\n    priorities[small_space] = 2 / (bins_remain_cap[small_space] - item + 0.000001) # small differences means the bin is better.  Plus a small constant.\n\n    # Rule 4: Prioritize bins with remaining capacity close to the item size.\n    # This attempts to pack bins as tightly as possible, reducing wasted space.\n\n    remaining_space = bins_remain_cap - item\n    #remaining_space[remaining_space < 0 ] = np.inf  # make it very low priority to use bins that cant fit\n\n    fitting_bins = bins_remain_cap > item\n    if np.any(fitting_bins):\n\n        priorities[fitting_bins] =  (bins_remain_cap[fitting_bins] - item) / np.max(bins_remain_cap) * -1 # prioritize by the smalles remaining space.\n        priorities[fitting_bins] = 1 / (1 + np.exp(priorities[fitting_bins] * 10)) # turn it into sigmoid, higher values\n\n    \n    return priorities",
    "response_id": 27,
    "obj": 86.58755484643,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response28.txt_stdout.txt",
    "code_path": "problem_iter1_code28.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Large item goes into larger bins. Try to fill bins as full as possible\n    \n    fit_mask = bins_remain_cap >= item\n    \n    # If the item doesn't fit into any bin\n    if not np.any(fit_mask):\n        return np.full_like(bins_remain_cap, -np.inf)\n    \n    # Prioritize bins that the item can fit into\n    \n    available_bins = bins_remain_cap[fit_mask]\n    \n    # 1. Prioritize almost full bins after placing items\n    post_fill = available_bins - item\n    priorities[fit_mask] = 1/(post_fill + 1e-9)  # Avoid division by zero and prioritize smaller remaining space\n\n    # 2. Reduce waste when the item is relatively small:\n    item_relative_size = item / np.max(bins_remain_cap) if np.max(bins_remain_cap)>0 else 0.0\n    if item_relative_size < 0.2:\n        priorities[fit_mask] += (available_bins / np.max(bins_remain_cap))  # Place in relatively large bins when the item is small\n\n    \n    return priorities",
    "response_id": 28,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response29.txt_stdout.txt",
    "code_path": "problem_iter1_code29.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # First Fit Decreasing heuristic inspired priority\n    # Give high priority to bins that can fit the item reasonably well\n\n    fit_mask = bins_remain_cap >= item\n    \n    priorities[fit_mask] = (bins_remain_cap[fit_mask] - item) / bins_remain_cap[fit_mask]\n\n    # Give a small bonus to bins that are almost full to pack them\n    almost_full = (bins_remain_cap > 0) & (bins_remain_cap < item)\n    priorities[almost_full] = -1.0  # Negative priority means don't put the item if it doesn't fit.\n\n    return priorities",
    "response_id": 29,
    "obj": 149.30195452732352,
    "exec_success": true
  }
]