[
  {
    "stdout_filepath": "problem_iter2_response0.txt_stdout.txt",
    "code_path": "problem_iter2_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # 1. Feasibility: High priority for bins that can fit the item.\n    feasible_bins = bins_remain_cap >= item\n    priorities[feasible_bins] += 1\n\n    # 2. Remaining Capacity: Prefer bins with less remaining capacity after placing the item\n    remaining_after_fit = bins_remain_cap - item\n    remaining_after_fit[remaining_after_fit < 0] = np.inf  # Penalize infeasible bins\n\n    # Normalize the remaining capacity scores for feasible bins only\n    max_cap = np.max(bins_remain_cap)\n    normalized_remaining = np.zeros_like(bins_remain_cap, dtype=float)\n    normalized_remaining[feasible_bins] = 1 - (remaining_after_fit[feasible_bins] / max_cap)\n    priorities += normalized_remaining\n\n    # 3. Avoidance of Fragmentation: Penalize bins that will leave a small unusable fragment.\n    fragment_threshold = 0.1  # Define a threshold for small fragments relative to bin size\n    fragment_penalty = 0.5\n\n    fragment_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit <= fragment_threshold * max_cap)\n    priorities[fragment_mask] -= fragment_penalty\n\n\n    # 4. Bonus for near perfect fit\n    near_perfect_fit_threshold = 0.05\n    near_perfect_fit_bonus = 0.3\n    near_perfect_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit <= near_perfect_fit_threshold * max_cap)\n    priorities[near_perfect_mask] += near_perfect_fit_bonus\n\n    return priorities",
    "response_id": 0,
    "obj": 4.686876745113682,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response1.txt_stdout.txt",
    "code_path": "problem_iter2_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Prioritize minimal waste for bins that can fit the item\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):\n        waste = bins_remain_cap[valid_bins] - item\n        min_waste = np.min(waste)\n        priorities[valid_bins] = 1.0 / (waste + 1e-6)  # Prioritize less waste; add a small constant to avoid division by zero\n        priorities[valid_bins & (waste == min_waste)] += 10.0  # Boost for absolute best fit (smallest waste)\n\n        # Further incentivize the absolute best fit by considering the ratio of item to bin capacity.\n        best_fit_indices = valid_bins & (waste == min_waste)\n        if np.any(best_fit_indices):\n            ratios = item / bins_remain_cap[best_fit_indices]\n            priorities[best_fit_indices] += ratios * 5 # Increase boost if the item almost fills the bin\n    \n    # Incentivize filling up bins, especially when items are small relative to bin size,\n    # but less aggressively than prioritizing minimal waste.\n    ratios = item / bins_remain_cap\n    priorities += (np.clip(ratios, 0.0, 1.0)) * 0.1 #Prioritize higher ratios\n\n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response2.txt_stdout.txt",
    "code_path": "problem_iter2_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Calculate wasted space if item is placed in each bin\n    wasted_space = bins_remain_cap - item\n\n    # Rule 1: Infeasible bins get negative infinity priority\n    priorities[wasted_space < 0] = -np.inf\n\n    # Rule 2: Prioritize bins that can fit the item, with a preference for less wasted space.\n    # We use an exponential function to give a strong preference to bins with small wasted space.\n    # An ideal wasted space exists to avoid bins getting too full too fast.\n    ideal_wasted_space = item / 2.0\n    distance_from_ideal = np.abs(wasted_space - ideal_wasted_space)\n    \n    # Apply a score based on the distance from the ideal wasted space. Smaller distance is better.\n    priorities[wasted_space >= 0] = -distance_from_ideal[wasted_space >= 0]\n\n    # Rule 3: Encourage balanced bin usage\n    # Give a bonus to bins that are neither too full nor too empty after placing the item.\n    # The bonus is proportional to the product of the remaining capacity and the item size.\n    # Normalize by the mean of bin capacities to scale appropriately\n    usage_bonus = np.where(wasted_space >= 0, np.clip(bins_remain_cap[wasted_space >= 0] * item / np.power(np.mean(bins_remain_cap), 2.0), 0, 1), 0) # Ensure result is within reasonable bounds [0,1]\n    priorities[wasted_space >= 0] += usage_bonus\n\n    # Rule 4: Even out probabilities when all possible moves are very bad.\n    # If no bin can fit the item (all priorities are -inf), distribute probabilities evenly.\n    if np.all(priorities == -np.inf):\n        priorities = np.ones_like(bins_remain_cap) / len(bins_remain_cap)\n\n    return priorities",
    "response_id": 2,
    "obj": 9.493418428400483,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response3.txt_stdout.txt",
    "code_path": "problem_iter2_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Rule 1: Prefer bins that can fit the item.\n    can_fit = bins_remain_cap >= item\n    priorities[can_fit] += 1.0\n\n    # Rule 2: Give higher priority to bins with less remaining capacity after packing. The smaller the remaining cap, the better fit and fewer fragmentation\n    if np.any(can_fit):\n        remaining_after_fit = bins_remain_cap[can_fit] - item\n        priorities[can_fit] += np.exp(-remaining_after_fit*10) # Exponentiated to give more weight to smaller values\n    \n    # Rule 3: Penalize bins that waste a lot of space if item cannot fit. This is a desperation strategy\n    cannot_fit = ~can_fit\n    if np.any(cannot_fit):\n        waste = item - bins_remain_cap[cannot_fit]\n        priorities[cannot_fit] -= waste*0.0001 # Penalize very small amount for bins that cannot fit it, preventing infinite penalty\n\n    # Rule 4: Add a small random number for tie-breaking.\n    priorities += np.random.rand(len(bins_remain_cap)) * 0.000001 #small noise for tie breaking\n    \n    return priorities",
    "response_id": 3,
    "obj": 36.11886717191864,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response4.txt_stdout.txt",
    "code_path": "problem_iter2_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: High priority if the item fits.\n    feasible = bins_remain_cap >= item\n    priorities[feasible] += 1  # Give a base priority for fitting\n\n    # 2. Tighter Fit: Higher priority for bins with tighter fit.\n    remaining_space = bins_remain_cap - item\n    remaining_space[~feasible] = np.inf  # Ignore infeasible bins\n\n    # Give higher priority to bins where space is tight (use inverse of remaining space)\n    priorities[feasible] += 1.0 / (remaining_space[feasible] + 0.0001) # avoid division by zero\n\n    # 3. Fragmentation Avoidance: Penalize bins with excessive wasted space *after* packing.  Stronger penalty than v1.\n    # Give a negative priority for bins that would result in excessive wasted space\n    large_remaining_space = remaining_space > 0.5\n    priorities[feasible & large_remaining_space] -= 1.0 * remaining_space[feasible & large_remaining_space]\n\n\n    # 4. First-Fit Tendency: Slight boost to bins that are relatively empty in general.  Increased weight compared to v1.\n    priorities += 0.2 * bins_remain_cap  # Encourage using emptier bins earlier, more aggressively.\n\n    # 5. Best Fit Modification: Give a bonus to bins whose remaining capacity is closest to the item size.\n    # This encourages a \"best fit\" approach.\n    fit_score = np.zeros_like(bins_remain_cap, dtype=float)\n    fit_score[feasible] = item / bins_remain_cap[feasible]\n    priorities[feasible] += fit_score[feasible]\n\n\n    return priorities",
    "response_id": 4,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response5.txt_stdout.txt",
    "code_path": "problem_iter2_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: Prioritize bins that can actually fit the item.\n    feasible_bins = bins_remain_cap >= item\n    priorities[feasible_bins] += 1.0\n\n    # 2. Remaining capacity: Prioritize bins with less remaining capacity after placing the item.\n    remaining_after_fit = bins_remain_cap - item\n    remaining_after_fit[~feasible_bins] = np.inf  # Penalize infeasible bins.\n\n    # Use inverse of remaining capacity to prioritize bins which are almost full\n    priorities[feasible_bins] += 1.0 / (1e-9 + remaining_after_fit[feasible_bins])\n\n    # 3. Fill Ratio: Consider the fill ratio of the bin after adding the item. Avoid very sparse bins.\n    fill_ratio = item / bins_remain_cap\n\n    priorities[feasible_bins] += np.clip(fill_ratio[feasible_bins], 0, 1)\n\n    # 4. Avoid creating very small fragments: Penalize bins where the remaining space after insertion would be very small\n    very_small_fragment = (remaining_after_fit > 0) & (remaining_after_fit < 0.1)  # if remaining is < 0.1, strongly penalize. Scale as needed\n    priorities[feasible_bins & very_small_fragment] -= 0.5 #Subtract small constant if creates a small fragment\n\n    #5. Items that perfectly fit: Highest Priority\n    perfect_fit = bins_remain_cap == item\n    priorities[perfect_fit] += 5\n\n    # 6. Bonus for almost full bins: Encourage filling bins close to capacity\n    almost_full = (remaining_after_fit > 0) & (remaining_after_fit <= 0.2)\n    priorities[feasible_bins & almost_full] += 2\n\n    return priorities",
    "response_id": 5,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response6.txt_stdout.txt",
    "code_path": "problem_iter2_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Calculate wasted space if item is placed in the bin.\n    wasted_space = bins_remain_cap - item\n    \n    # Give very low priority (negative infinity) to bins that cannot fit the item.\n    priorities[wasted_space < 0] = -np.inf\n    \n    # Find bins that can fit the item.\n    can_fit = wasted_space >= 0\n    \n    # Calculate fill ratios for bins that can fit.\n    fill_ratios = np.zeros_like(bins_remain_cap, dtype=float)\n    fill_ratios[can_fit] = item / bins_remain_cap[can_fit]\n\n    # Give preference to bins that are filled reasonably well (around 75%).\n    priorities[can_fit] = np.exp(-np.abs(fill_ratios[can_fit] - 0.75))\n\n    # Heavily reduce the priority if the bin is almost full (filled ratio > 0.95).\n    almost_full = can_fit & (fill_ratios > 0.95)\n    priorities[almost_full] *= 0.01 # Even stronger penalty than before\n    \n    return priorities",
    "response_id": 6,
    "obj": 9.064619066613492,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response7.txt_stdout.txt",
    "code_path": "problem_iter2_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Rule 1: Perfect Fit\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    priorities[perfect_fit] = np.inf\n\n    # Rule 2: Prioritize bins that can fit the item, minimizing wasted space.\n    fitting_bins = bins_remain_cap >= item\n    if np.any(fitting_bins):\n        space_waste = bins_remain_cap[fitting_bins] - item\n        priorities[fitting_bins] = 1 / (space_waste + 1e-9)  # Adding a small value to avoid division by zero\n\n    # Rule 3: Assign a very low priority if the item doesn't fit\n    not_fitting = bins_remain_cap < item\n    priorities[not_fitting] = -np.inf\n\n    return priorities",
    "response_id": 7,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response8.txt_stdout.txt",
    "code_path": "problem_iter2_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    fit_mask = bins_remain_cap >= item\n    \n    if np.any(fit_mask):\n        priorities[fit_mask] = 1 / (bins_remain_cap[fit_mask] - item + 1e-9)\n    \n    priorities[~fit_mask] = -1e9\n    \n\n    return priorities",
    "response_id": 8,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response9.txt_stdout.txt",
    "code_path": "problem_iter2_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Calculate wasted space if item is placed in each bin\n    wasted_space = bins_remain_cap - item\n\n    # Assign high priority to bins where item fits and wasted space is minimized\n    fit_mask = wasted_space >= 0\n    if np.any(fit_mask):\n        priorities[fit_mask] = 1 / (wasted_space[fit_mask] + 1e-6)  # Avoid division by zero\n        # Further prioritize bins that are closer to being full after adding the item\n        remaining_space_ratio = (bins_remain_cap[fit_mask] - item) / bins_remain_cap[fit_mask]\n        priorities[fit_mask] *= (1 - remaining_space_ratio) + 0.1 #a little boost even when perfectly fit\n    else:\n        # If no bin can fit the item, use worst fit approach (least overfilled bin)\n        overfill_amount = item - bins_remain_cap\n        priorities = -overfill_amount\n    return priorities",
    "response_id": 9,
    "obj": 4.048663741523748,
    "exec_success": true
  }
]