[
  {
    "stdout_filepath": "problem_iter6_response0.txt_stdout.txt",
    "code_path": "problem_iter6_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_size = np.max(bins_remain_cap)\n\n    # 1. Feasibility: Eliminate infeasible bins immediately.\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -np.inf\n\n    # Consider only feasible bins from this point onward.\n    feasible_bins = ~infeasible_bins\n\n    # 2. Best Fit: Primary criterion is minimizing remaining space.\n    remaining_space = bins_remain_cap[feasible_bins] - item\n    priorities[feasible_bins] = -remaining_space\n\n    # 3. Moderate Fill Level: Discourage bins that become almost full.\n    almost_full = remaining_space < (0.1 * bin_size)\n    priorities[feasible_bins][almost_full] -= 5\n\n    # 4. Relative Item Size: Discourage placing small items in large bins.\n    relative_item_size = item / bin_size\n    priorities[feasible_bins] -= relative_item_size * 10\n\n    # 5. Encourage fuller bins: Give a slight bonus to bins that are already somewhat full.\n    already_full = bins_remain_cap[feasible_bins] > (0.1 * bin_size) #Only give the bonus if it's not almost empty.\n    already_full = already_full & (bins_remain_cap[feasible_bins] < (0.9 * bin_size))\n    fill_level = (bin_size - bins_remain_cap[feasible_bins][already_full]) / bin_size\n    priorities[feasible_bins][already_full] += fill_level * 2 # Scale to [0, 2]\n\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response1.txt_stdout.txt",
    "code_path": "problem_iter6_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: Infeasible bins get a large negative priority.\n    feasible_bins = bins_remain_cap >= item\n    priorities[~feasible_bins] = -1e9\n\n    # 2. Remaining Capacity: Prefer bins with less remaining capacity *after* placing the item.\n    remaining_after_fit = bins_remain_cap - item\n\n    # Only consider remaining capacity for feasible bins, set infeasible remaining to large number\n    remaining_after_fit_adj = np.copy(remaining_after_fit)\n    remaining_after_fit_adj[~feasible_bins] = np.max(bins_remain_cap) + item  # some large value\n\n    # Normalize remaining capacity (smaller is better)\n    max_remaining = np.max(remaining_after_fit_adj)\n    normalized_remaining = 1 - (remaining_after_fit_adj / max_remaining)\n    priorities += normalized_remaining\n\n    # 3. Fragmentation Penalty: Penalize bins that will leave a small unusable fragment.\n    fragment_threshold = 0.2  # Define a threshold for small fragments relative to bin size\n    fragment_penalty = 0.7\n\n    max_bin_cap = np.max(bins_remain_cap)\n    fragment_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit <= fragment_threshold * max_bin_cap)\n    priorities[fragment_mask] -= fragment_penalty\n\n    # 4. Reward Near-Perfect Fit: Encourage using bins that almost perfectly fit the item.\n    near_perfect_fit_threshold = 0.1\n    near_perfect_fit_bonus = 0.5\n    near_perfect_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit <= near_perfect_fit_threshold * max_bin_cap)\n    priorities[near_perfect_mask] += near_perfect_fit_bonus\n\n    # 5. Encourage usage of emptier bins when possible, to reduce # of bins used\n    # Only apply if some bins are quite empty\n    empty_bin_threshold = 0.9\n    if np.any(bins_remain_cap >= empty_bin_threshold * max_bin_cap):\n        empty_bin_bonus = 0.2\n        empty_bin_mask = feasible_bins & (bins_remain_cap >= empty_bin_threshold * max_bin_cap)\n        priorities[empty_bin_mask] += empty_bin_bonus\n    \n    # 6. Prioritize bins with larger remaining capacity if near-full bins are available\n    near_full_threshold = 0.15\n    if np.any(bins_remain_cap <= near_full_threshold * max_bin_cap) and np.any(bins_remain_cap >= empty_bin_threshold * max_bin_cap):\n            larger_bin_bonus = 0.1 # Slightly less than empty bin bonus to avoid over-prioritization\n            larger_bin_mask = feasible_bins & (bins_remain_cap >= empty_bin_threshold * max_bin_cap)\n            priorities[larger_bin_mask] += larger_bin_bonus\n\n    return priorities",
    "response_id": 1,
    "obj": 3.9888312724371757,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response2.txt_stdout.txt",
    "code_path": "problem_iter6_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: Assign a large negative priority to bins that can't fit the item\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -1e9  # Large penalty for infeasibility\n\n    # 2. Best Fit: Prioritize bins with the smallest remaining capacity *after* adding the item, but only for feasible bins\n    feasible_bins = ~infeasible_bins\n    remaining_after_fit = bins_remain_cap[feasible_bins] - item\n\n    # Primary Best Fit scoring (smaller waste is better)\n    priorities[feasible_bins] = -remaining_after_fit\n\n    # Encourage moderate fill levels (avoid bins that are too full or too empty after placement)\n    bin_capacity = np.max(bins_remain_cap)\n    if bin_capacity > 0:\n        # Scale the remaining capacity and subtract a small amount. Encourages filling bins without overfilling.\n        priorities[feasible_bins] -= (bins_remain_cap[feasible_bins] / bin_capacity) * 0.001\n\n        # Bonus for bins that are reasonably full *after* placing the item, but not excessively full.\n        # This encourages consolidating items into fewer bins while preventing extreme fragmentation.\n        reasonable_fill = (remaining_after_fit > 0.1 * bin_capacity) & (remaining_after_fit < 0.8 * bin_capacity) # play with these parameters\n        priorities[feasible_bins][reasonable_fill] += 0.0005 # tiny bonus\n\n    return priorities",
    "response_id": 2,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response3.txt_stdout.txt",
    "code_path": "problem_iter6_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: Infeasible bins get a large negative priority.\n    feasible_bins = bins_remain_cap >= item\n    priorities[~feasible_bins] = -1e9\n\n    # 2. Best Fit: Prioritize bins where the remaining capacity after adding the item is minimized.\n    remaining_after_fit = bins_remain_cap - item\n\n    # Handle infeasible bins to avoid errors during normalization.\n    remaining_after_fit_adj = np.copy(remaining_after_fit)\n    remaining_after_fit_adj[~feasible_bins] = np.max(bins_remain_cap) + item\n\n    # Normalize remaining capacity (smaller is better) - Best Fit principle\n    max_remaining = np.max(remaining_after_fit_adj)\n    normalized_remaining = 1 - (remaining_after_fit_adj / max_remaining)\n    priorities += normalized_remaining\n\n    # 3. Fragmentation Penalty: Penalize bins that will leave a small unusable fragment.\n    fragment_threshold = 0.2  # Define a threshold for small fragments relative to bin size\n    fragment_penalty = 0.6\n    fragment_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit <= fragment_threshold * np.max(bins_remain_cap))\n    priorities[fragment_mask] -= fragment_penalty\n\n    # 4. Reward Near-Perfect Fit: Encourage using bins that almost perfectly fit the item.\n    near_perfect_fit_threshold = 0.1\n    near_perfect_fit_bonus = 0.4\n    near_perfect_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit <= near_perfect_fit_threshold * np.max(bins_remain_cap))\n    priorities[near_perfect_mask] += near_perfect_fit_bonus\n\n    # 5. Encourage usage of emptier bins when possible, to reduce # of bins used\n    empty_bin_threshold = 0.8\n    if np.any(bins_remain_cap >= empty_bin_threshold * np.max(bins_remain_cap)):\n        empty_bin_bonus = 0.3\n        empty_bin_mask = feasible_bins & (bins_remain_cap >= empty_bin_threshold * np.max(bins_remain_cap))\n        priorities[empty_bin_mask] += empty_bin_bonus\n\n    return priorities",
    "response_id": 3,
    "obj": 4.008775428799367,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response4.txt_stdout.txt",
    "code_path": "problem_iter6_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_size = np.max(bins_remain_cap)  # assume all bins are same size.\n\n    # 1. Feasibility: Assign a large negative priority to bins that can't fit the item\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -1e9  # Large negative number\n\n    # 2. Best Fit: Prioritize bins where the remaining capacity *after* adding the item is smallest.\n    feasible_bins = ~infeasible_bins\n    remaining_after_fit = bins_remain_cap[feasible_bins] - item\n    priorities[feasible_bins] = -remaining_after_fit  # Smaller remaining capacity gives higher priority\n\n    # 3. Relative Item Size: Penalize bins where the item occupies a small proportion of the bin's capacity.\n    relative_item_size = item / bin_size  # item size with respect to bin size.\n    priorities[feasible_bins] -= relative_item_size * 10  # Scale the penalty.\n\n    # 4. Moderate Fill Level: Avoid bins that are *almost* full after adding the item.\n    almost_full = (bins_remain_cap[feasible_bins] - item) < (bin_size * 0.1)\n    priorities[feasible_bins][almost_full] -= 5  # Slight penalty for almost full bins.\n    \n    #5. Prefer bins with higher fill ratio before adding the item, but only if item fits\n    fill_ratio_before = (bin_size - bins_remain_cap[feasible_bins]) / bin_size\n    priorities[feasible_bins] += fill_ratio_before * 2\n\n    #6. Perfect Fit Bonus: Give a significant bonus to bins where the item fits perfectly\n    perfect_fit = np.isclose(bins_remain_cap[feasible_bins], item)\n    priorities[feasible_bins][perfect_fit] += 10\n\n    return priorities",
    "response_id": 4,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response5.txt_stdout.txt",
    "code_path": "problem_iter6_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_size = np.max(bins_remain_cap)\n\n    # 1. Feasibility: Assign a large negative priority to bins that can't fit the item\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -1e9\n\n    # 2. Best Fit: Prioritize bins where the remaining capacity *after* adding the item is smallest.\n    feasible_bins = ~infeasible_bins\n    remaining_after_fit = bins_remain_cap[feasible_bins] - item\n    priorities[feasible_bins] = -remaining_after_fit\n\n    # 3. Relative Item Size: Penalize bins where the item occupies a small proportion of the bin's capacity.\n    relative_item_size = item / bin_size\n    priorities[feasible_bins] -= relative_item_size * 10\n\n    # 4. Moderate Fill Level: Avoid bins that are *almost* full after adding the item.\n    almost_full = (bins_remain_cap[feasible_bins] - item) < (bin_size * 0.1)\n    priorities[feasible_bins][almost_full] -= 5\n\n    # 5. Encourage filling bins that are already somewhat full. More aggressively than before.\n    already_full = bins_remain_cap[feasible_bins] < (bin_size * 0.9)\n    priorities[feasible_bins][already_full] += (bin_size - bins_remain_cap[feasible_bins][already_full]) / bin_size * 5  # Increased bonus\n\n    # 6. Perfect Fit Bonus\n    perfect_fit = np.isclose(remaining_after_fit, 0)\n    priorities[feasible_bins][perfect_fit] += 10 # Significant bonus for perfect fit.\n\n\n    return priorities",
    "response_id": 5,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response6.txt_stdout.txt",
    "code_path": "problem_iter6_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_size = np.max(bins_remain_cap)  # Assume all bins have same capacity.\n\n    # 1. Feasibility: Assign a large negative priority to bins that can't fit the item\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -1e9  # Large negative number\n\n    # Proceed only for feasible bins\n    feasible_bins = ~infeasible_bins\n\n    if not np.any(feasible_bins):\n        return priorities # No feasible bins, return lowest priority possible\n\n    # 2. Best Fit (among feasible bins)\n    remaining_after_fit = bins_remain_cap[feasible_bins] - item\n    priorities[feasible_bins] = -remaining_after_fit  # Smaller remaining capacity gets higher priority\n\n    # 3. Target Fill Level: Reward bins that, after adding the item, get close to an ideal fill ratio.\n    optimal_fill = 0.75\n    current_fill_ratio = (bin_size - bins_remain_cap[feasible_bins]) / bin_size  # Current fill ratio BEFORE adding the item\n    new_fill_ratio = (bin_size - remaining_after_fit) / bin_size # Expected fill ratio AFTER adding the item\n    \n    #Penalize deviation from target ratio\n    priorities[feasible_bins] -= abs(new_fill_ratio - optimal_fill) * 10\n    \n    # 4. Relative Item Size: Reward placing larger items\n    relative_item_size = item / bin_size\n    priorities[feasible_bins] += relative_item_size * 3\n\n    # 5. Avoid extremely empty bins after placing item\n    very_empty = (remaining_after_fit / bin_size) > 0.9\n    priorities[feasible_bins][very_empty] -= 2\n\n    #6. Avoid almost full\n    almost_full = (remaining_after_fit / bin_size) < 0.1\n    priorities[feasible_bins][almost_full] -= 4\n    \n    return priorities",
    "response_id": 6,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response7.txt_stdout.txt",
    "code_path": "problem_iter6_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # 1. Feasibility: Mark infeasible bins.\n    feasible_bins = bins_remain_cap >= item\n    priorities[~feasible_bins] = -np.inf  # Assign lowest priority to infeasible bins\n\n    # 2. Best Fit: Prioritize feasible bins based on remaining capacity after placement.\n    if np.any(feasible_bins):\n        remaining_capacity = bins_remain_cap[feasible_bins] - item\n        priorities[feasible_bins] = -remaining_capacity  # Smaller remaining capacity gets higher priority\n\n    return priorities",
    "response_id": 7,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response8.txt_stdout.txt",
    "code_path": "problem_iter6_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: Infeasible bins get the lowest priority.\n    feasible_bins = bins_remain_cap >= item\n    priorities[~feasible_bins] = -np.inf\n\n    # 2. Best Fit: Maximize remaining capacity after placing the item (minimize negative remaining capacity).\n    remaining_after_fit = bins_remain_cap - item\n    priorities[feasible_bins] = -remaining_after_fit[feasible_bins]  # Smaller remaining capacity is better\n\n    # 3. Fragmentation Penalty: Penalize creating small fragments.\n    fragment_threshold = 0.15 * np.max(bins_remain_cap)\n    fragment_penalty = 0.5\n    fragment_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit <= fragment_threshold)\n    priorities[fragment_mask] -= fragment_penalty\n\n    # 4. Near-full penalty. Penalize bins that are almost full after adding an item.\n    near_full_threshold = 0.95 * np.max(bins_remain_cap)\n    near_full_penalty = 0.3\n    near_full_mask = feasible_bins & (remaining_after_fit >= 0) & (remaining_after_fit <= (np.max(bins_remain_cap) - near_full_threshold))\n    priorities[near_full_mask] -= near_full_penalty\n    \n    return priorities",
    "response_id": 8,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response9.txt_stdout.txt",
    "code_path": "problem_iter6_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: Infeasible bins get a large negative priority.\n    feasible_bins = bins_remain_cap >= item\n    priorities[~feasible_bins] = -1e9\n\n    # 2. Best Fit: Prioritize bins where the remaining capacity after adding the item is minimized.\n    remaining_after_fit = bins_remain_cap - item\n\n    # Handle infeasible bins to avoid errors during normalization.\n    remaining_after_fit_adj = np.copy(remaining_after_fit)\n    remaining_after_fit_adj[~feasible_bins] = np.max(bins_remain_cap) + item\n\n    # Normalize remaining capacity (smaller is better) - Best Fit principle\n    max_remaining = np.max(remaining_after_fit_adj)\n    normalized_remaining = 1 - (remaining_after_fit_adj / max_remaining)\n    priorities += normalized_remaining\n\n    # 3. Fragmentation Penalty: Penalize bins that will leave a small unusable fragment.\n    fragment_threshold = 0.2  # Define a threshold for small fragments relative to bin size\n    fragment_penalty = 0.6\n\n    fragment_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit <= fragment_threshold * np.max(bins_remain_cap))\n    priorities[fragment_mask] -= fragment_penalty\n\n    # 4. Reward Near-Perfect Fit: Encourage using bins that almost perfectly fit the item.\n    near_perfect_fit_threshold = 0.1\n    near_perfect_fit_bonus = 0.7\n    near_perfect_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit <= near_perfect_fit_threshold * np.max(bins_remain_cap))\n    priorities[near_perfect_mask] += near_perfect_fit_bonus\n\n    # 5. Encourage usage of emptier bins when possible, to reduce # of bins used\n    empty_bin_threshold = 0.8\n    empty_bin_bonus = 0.3\n    empty_bin_mask = feasible_bins & (bins_remain_cap >= empty_bin_threshold * np.max(bins_remain_cap))\n    priorities[empty_bin_mask] += empty_bin_bonus\n\n    # 6. Moderate Item size handling, instead of hard threshold\n    item_ratio = item / np.max(bins_remain_cap)\n    moderate_item_penalty = 0.1 * item_ratio  # Scale penalty with item size\n    priorities[feasible_bins] -= moderate_item_penalty\n    \n    return priorities",
    "response_id": 9,
    "obj": 4.27802153968888,
    "exec_success": true
  }
]