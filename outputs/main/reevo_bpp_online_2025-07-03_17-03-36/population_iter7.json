[
  {
    "stdout_filepath": "problem_iter6_response0.txt_stdout.txt",
    "code_path": "problem_iter6_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_size = np.max(bins_remain_cap)\n\n    # 1. Feasibility: Eliminate infeasible bins immediately.\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -np.inf\n\n    # Consider only feasible bins from this point onward.\n    feasible_bins = ~infeasible_bins\n\n    # 2. Best Fit: Primary criterion is minimizing remaining space.\n    remaining_space = bins_remain_cap[feasible_bins] - item\n    priorities[feasible_bins] = -remaining_space\n\n    # 3. Moderate Fill Level: Discourage bins that become almost full.\n    almost_full = remaining_space < (0.1 * bin_size)\n    priorities[feasible_bins][almost_full] -= 5\n\n    # 4. Relative Item Size: Discourage placing small items in large bins.\n    relative_item_size = item / bin_size\n    priorities[feasible_bins] -= relative_item_size * 10\n\n    # 5. Encourage fuller bins: Give a slight bonus to bins that are already somewhat full.\n    already_full = bins_remain_cap[feasible_bins] > (0.1 * bin_size) #Only give the bonus if it's not almost empty.\n    already_full = already_full & (bins_remain_cap[feasible_bins] < (0.9 * bin_size))\n    fill_level = (bin_size - bins_remain_cap[feasible_bins][already_full]) / bin_size\n    priorities[feasible_bins][already_full] += fill_level * 2 # Scale to [0, 2]\n\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response1.txt_stdout.txt",
    "code_path": "problem_iter6_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: Infeasible bins get a large negative priority.\n    feasible_bins = bins_remain_cap >= item\n    priorities[~feasible_bins] = -1e9\n\n    # 2. Remaining Capacity: Prefer bins with less remaining capacity *after* placing the item.\n    remaining_after_fit = bins_remain_cap - item\n\n    # Only consider remaining capacity for feasible bins, set infeasible remaining to large number\n    remaining_after_fit_adj = np.copy(remaining_after_fit)\n    remaining_after_fit_adj[~feasible_bins] = np.max(bins_remain_cap) + item  # some large value\n\n    # Normalize remaining capacity (smaller is better)\n    max_remaining = np.max(remaining_after_fit_adj)\n    normalized_remaining = 1 - (remaining_after_fit_adj / max_remaining)\n    priorities += normalized_remaining\n\n    # 3. Fragmentation Penalty: Penalize bins that will leave a small unusable fragment.\n    fragment_threshold = 0.2  # Define a threshold for small fragments relative to bin size\n    fragment_penalty = 0.7\n\n    max_bin_cap = np.max(bins_remain_cap)\n    fragment_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit <= fragment_threshold * max_bin_cap)\n    priorities[fragment_mask] -= fragment_penalty\n\n    # 4. Reward Near-Perfect Fit: Encourage using bins that almost perfectly fit the item.\n    near_perfect_fit_threshold = 0.1\n    near_perfect_fit_bonus = 0.5\n    near_perfect_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit <= near_perfect_fit_threshold * max_bin_cap)\n    priorities[near_perfect_mask] += near_perfect_fit_bonus\n\n    # 5. Encourage usage of emptier bins when possible, to reduce # of bins used\n    # Only apply if some bins are quite empty\n    empty_bin_threshold = 0.9\n    if np.any(bins_remain_cap >= empty_bin_threshold * max_bin_cap):\n        empty_bin_bonus = 0.2\n        empty_bin_mask = feasible_bins & (bins_remain_cap >= empty_bin_threshold * max_bin_cap)\n        priorities[empty_bin_mask] += empty_bin_bonus\n    \n    # 6. Prioritize bins with larger remaining capacity if near-full bins are available\n    near_full_threshold = 0.15\n    if np.any(bins_remain_cap <= near_full_threshold * max_bin_cap) and np.any(bins_remain_cap >= empty_bin_threshold * max_bin_cap):\n            larger_bin_bonus = 0.1 # Slightly less than empty bin bonus to avoid over-prioritization\n            larger_bin_mask = feasible_bins & (bins_remain_cap >= empty_bin_threshold * max_bin_cap)\n            priorities[larger_bin_mask] += larger_bin_bonus\n\n    return priorities",
    "response_id": 1,
    "obj": 3.9888312724371757,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response2.txt_stdout.txt",
    "code_path": "problem_iter6_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: Assign a large negative priority to bins that can't fit the item\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -1e9  # Large penalty for infeasibility\n\n    # 2. Best Fit: Prioritize bins with the smallest remaining capacity *after* adding the item, but only for feasible bins\n    feasible_bins = ~infeasible_bins\n    remaining_after_fit = bins_remain_cap[feasible_bins] - item\n\n    # Primary Best Fit scoring (smaller waste is better)\n    priorities[feasible_bins] = -remaining_after_fit\n\n    # Encourage moderate fill levels (avoid bins that are too full or too empty after placement)\n    bin_capacity = np.max(bins_remain_cap)\n    if bin_capacity > 0:\n        # Scale the remaining capacity and subtract a small amount. Encourages filling bins without overfilling.\n        priorities[feasible_bins] -= (bins_remain_cap[feasible_bins] / bin_capacity) * 0.001\n\n        # Bonus for bins that are reasonably full *after* placing the item, but not excessively full.\n        # This encourages consolidating items into fewer bins while preventing extreme fragmentation.\n        reasonable_fill = (remaining_after_fit > 0.1 * bin_capacity) & (remaining_after_fit < 0.8 * bin_capacity) # play with these parameters\n        priorities[feasible_bins][reasonable_fill] += 0.0005 # tiny bonus\n\n    return priorities",
    "response_id": 2,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response3.txt_stdout.txt",
    "code_path": "problem_iter6_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: Infeasible bins get a large negative priority.\n    feasible_bins = bins_remain_cap >= item\n    priorities[~feasible_bins] = -1e9\n\n    # 2. Best Fit: Prioritize bins where the remaining capacity after adding the item is minimized.\n    remaining_after_fit = bins_remain_cap - item\n\n    # Handle infeasible bins to avoid errors during normalization.\n    remaining_after_fit_adj = np.copy(remaining_after_fit)\n    remaining_after_fit_adj[~feasible_bins] = np.max(bins_remain_cap) + item\n\n    # Normalize remaining capacity (smaller is better) - Best Fit principle\n    max_remaining = np.max(remaining_after_fit_adj)\n    normalized_remaining = 1 - (remaining_after_fit_adj / max_remaining)\n    priorities += normalized_remaining\n\n    # 3. Fragmentation Penalty: Penalize bins that will leave a small unusable fragment.\n    fragment_threshold = 0.2  # Define a threshold for small fragments relative to bin size\n    fragment_penalty = 0.6\n    fragment_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit <= fragment_threshold * np.max(bins_remain_cap))\n    priorities[fragment_mask] -= fragment_penalty\n\n    # 4. Reward Near-Perfect Fit: Encourage using bins that almost perfectly fit the item.\n    near_perfect_fit_threshold = 0.1\n    near_perfect_fit_bonus = 0.4\n    near_perfect_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit <= near_perfect_fit_threshold * np.max(bins_remain_cap))\n    priorities[near_perfect_mask] += near_perfect_fit_bonus\n\n    # 5. Encourage usage of emptier bins when possible, to reduce # of bins used\n    empty_bin_threshold = 0.8\n    if np.any(bins_remain_cap >= empty_bin_threshold * np.max(bins_remain_cap)):\n        empty_bin_bonus = 0.3\n        empty_bin_mask = feasible_bins & (bins_remain_cap >= empty_bin_threshold * np.max(bins_remain_cap))\n        priorities[empty_bin_mask] += empty_bin_bonus\n\n    return priorities",
    "response_id": 3,
    "obj": 4.008775428799367,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response4.txt_stdout.txt",
    "code_path": "problem_iter6_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_size = np.max(bins_remain_cap)  # assume all bins are same size.\n\n    # 1. Feasibility: Assign a large negative priority to bins that can't fit the item\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -1e9  # Large negative number\n\n    # 2. Best Fit: Prioritize bins where the remaining capacity *after* adding the item is smallest.\n    feasible_bins = ~infeasible_bins\n    remaining_after_fit = bins_remain_cap[feasible_bins] - item\n    priorities[feasible_bins] = -remaining_after_fit  # Smaller remaining capacity gives higher priority\n\n    # 3. Relative Item Size: Penalize bins where the item occupies a small proportion of the bin's capacity.\n    relative_item_size = item / bin_size  # item size with respect to bin size.\n    priorities[feasible_bins] -= relative_item_size * 10  # Scale the penalty.\n\n    # 4. Moderate Fill Level: Avoid bins that are *almost* full after adding the item.\n    almost_full = (bins_remain_cap[feasible_bins] - item) < (bin_size * 0.1)\n    priorities[feasible_bins][almost_full] -= 5  # Slight penalty for almost full bins.\n    \n    #5. Prefer bins with higher fill ratio before adding the item, but only if item fits\n    fill_ratio_before = (bin_size - bins_remain_cap[feasible_bins]) / bin_size\n    priorities[feasible_bins] += fill_ratio_before * 2\n\n    #6. Perfect Fit Bonus: Give a significant bonus to bins where the item fits perfectly\n    perfect_fit = np.isclose(bins_remain_cap[feasible_bins], item)\n    priorities[feasible_bins][perfect_fit] += 10\n\n    return priorities",
    "response_id": 4,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response5.txt_stdout.txt",
    "code_path": "problem_iter6_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_size = np.max(bins_remain_cap)\n\n    # 1. Feasibility: Assign a large negative priority to bins that can't fit the item\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -1e9\n\n    # 2. Best Fit: Prioritize bins where the remaining capacity *after* adding the item is smallest.\n    feasible_bins = ~infeasible_bins\n    remaining_after_fit = bins_remain_cap[feasible_bins] - item\n    priorities[feasible_bins] = -remaining_after_fit\n\n    # 3. Relative Item Size: Penalize bins where the item occupies a small proportion of the bin's capacity.\n    relative_item_size = item / bin_size\n    priorities[feasible_bins] -= relative_item_size * 10\n\n    # 4. Moderate Fill Level: Avoid bins that are *almost* full after adding the item.\n    almost_full = (bins_remain_cap[feasible_bins] - item) < (bin_size * 0.1)\n    priorities[feasible_bins][almost_full] -= 5\n\n    # 5. Encourage filling bins that are already somewhat full. More aggressively than before.\n    already_full = bins_remain_cap[feasible_bins] < (bin_size * 0.9)\n    priorities[feasible_bins][already_full] += (bin_size - bins_remain_cap[feasible_bins][already_full]) / bin_size * 5  # Increased bonus\n\n    # 6. Perfect Fit Bonus\n    perfect_fit = np.isclose(remaining_after_fit, 0)\n    priorities[feasible_bins][perfect_fit] += 10 # Significant bonus for perfect fit.\n\n\n    return priorities",
    "response_id": 5,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response6.txt_stdout.txt",
    "code_path": "problem_iter6_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_size = np.max(bins_remain_cap)  # Assume all bins have same capacity.\n\n    # 1. Feasibility: Assign a large negative priority to bins that can't fit the item\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -1e9  # Large negative number\n\n    # Proceed only for feasible bins\n    feasible_bins = ~infeasible_bins\n\n    if not np.any(feasible_bins):\n        return priorities # No feasible bins, return lowest priority possible\n\n    # 2. Best Fit (among feasible bins)\n    remaining_after_fit = bins_remain_cap[feasible_bins] - item\n    priorities[feasible_bins] = -remaining_after_fit  # Smaller remaining capacity gets higher priority\n\n    # 3. Target Fill Level: Reward bins that, after adding the item, get close to an ideal fill ratio.\n    optimal_fill = 0.75\n    current_fill_ratio = (bin_size - bins_remain_cap[feasible_bins]) / bin_size  # Current fill ratio BEFORE adding the item\n    new_fill_ratio = (bin_size - remaining_after_fit) / bin_size # Expected fill ratio AFTER adding the item\n    \n    #Penalize deviation from target ratio\n    priorities[feasible_bins] -= abs(new_fill_ratio - optimal_fill) * 10\n    \n    # 4. Relative Item Size: Reward placing larger items\n    relative_item_size = item / bin_size\n    priorities[feasible_bins] += relative_item_size * 3\n\n    # 5. Avoid extremely empty bins after placing item\n    very_empty = (remaining_after_fit / bin_size) > 0.9\n    priorities[feasible_bins][very_empty] -= 2\n\n    #6. Avoid almost full\n    almost_full = (remaining_after_fit / bin_size) < 0.1\n    priorities[feasible_bins][almost_full] -= 4\n    \n    return priorities",
    "response_id": 6,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response7.txt_stdout.txt",
    "code_path": "problem_iter6_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # 1. Feasibility: Mark infeasible bins.\n    feasible_bins = bins_remain_cap >= item\n    priorities[~feasible_bins] = -np.inf  # Assign lowest priority to infeasible bins\n\n    # 2. Best Fit: Prioritize feasible bins based on remaining capacity after placement.\n    if np.any(feasible_bins):\n        remaining_capacity = bins_remain_cap[feasible_bins] - item\n        priorities[feasible_bins] = -remaining_capacity  # Smaller remaining capacity gets higher priority\n\n    return priorities",
    "response_id": 7,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response8.txt_stdout.txt",
    "code_path": "problem_iter6_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: Infeasible bins get the lowest priority.\n    feasible_bins = bins_remain_cap >= item\n    priorities[~feasible_bins] = -np.inf\n\n    # 2. Best Fit: Maximize remaining capacity after placing the item (minimize negative remaining capacity).\n    remaining_after_fit = bins_remain_cap - item\n    priorities[feasible_bins] = -remaining_after_fit[feasible_bins]  # Smaller remaining capacity is better\n\n    # 3. Fragmentation Penalty: Penalize creating small fragments.\n    fragment_threshold = 0.15 * np.max(bins_remain_cap)\n    fragment_penalty = 0.5\n    fragment_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit <= fragment_threshold)\n    priorities[fragment_mask] -= fragment_penalty\n\n    # 4. Near-full penalty. Penalize bins that are almost full after adding an item.\n    near_full_threshold = 0.95 * np.max(bins_remain_cap)\n    near_full_penalty = 0.3\n    near_full_mask = feasible_bins & (remaining_after_fit >= 0) & (remaining_after_fit <= (np.max(bins_remain_cap) - near_full_threshold))\n    priorities[near_full_mask] -= near_full_penalty\n    \n    return priorities",
    "response_id": 8,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response9.txt_stdout.txt",
    "code_path": "problem_iter6_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: Infeasible bins get a large negative priority.\n    feasible_bins = bins_remain_cap >= item\n    priorities[~feasible_bins] = -1e9\n\n    # 2. Best Fit: Prioritize bins where the remaining capacity after adding the item is minimized.\n    remaining_after_fit = bins_remain_cap - item\n\n    # Handle infeasible bins to avoid errors during normalization.\n    remaining_after_fit_adj = np.copy(remaining_after_fit)\n    remaining_after_fit_adj[~feasible_bins] = np.max(bins_remain_cap) + item\n\n    # Normalize remaining capacity (smaller is better) - Best Fit principle\n    max_remaining = np.max(remaining_after_fit_adj)\n    normalized_remaining = 1 - (remaining_after_fit_adj / max_remaining)\n    priorities += normalized_remaining\n\n    # 3. Fragmentation Penalty: Penalize bins that will leave a small unusable fragment.\n    fragment_threshold = 0.2  # Define a threshold for small fragments relative to bin size\n    fragment_penalty = 0.6\n\n    fragment_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit <= fragment_threshold * np.max(bins_remain_cap))\n    priorities[fragment_mask] -= fragment_penalty\n\n    # 4. Reward Near-Perfect Fit: Encourage using bins that almost perfectly fit the item.\n    near_perfect_fit_threshold = 0.1\n    near_perfect_fit_bonus = 0.7\n    near_perfect_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit <= near_perfect_fit_threshold * np.max(bins_remain_cap))\n    priorities[near_perfect_mask] += near_perfect_fit_bonus\n\n    # 5. Encourage usage of emptier bins when possible, to reduce # of bins used\n    empty_bin_threshold = 0.8\n    empty_bin_bonus = 0.3\n    empty_bin_mask = feasible_bins & (bins_remain_cap >= empty_bin_threshold * np.max(bins_remain_cap))\n    priorities[empty_bin_mask] += empty_bin_bonus\n\n    # 6. Moderate Item size handling, instead of hard threshold\n    item_ratio = item / np.max(bins_remain_cap)\n    moderate_item_penalty = 0.1 * item_ratio  # Scale penalty with item size\n    priorities[feasible_bins] -= moderate_item_penalty\n    \n    return priorities",
    "response_id": 9,
    "obj": 4.27802153968888,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter7_response0.txt_stdout.txt",
    "code_path": "problem_iter7_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)\n    # 1. Feasibility: Infeasible bins get a very large negative priority.\n    feasible_bins = bins_remain_cap >= item\n    priorities[~feasible_bins] = -1e9\n\n    # 2. Best Fit: Prefer bins where the remaining capacity after placement is minimal\n    remaining_after_fit = bins_remain_cap - item\n    remaining_after_fit[~feasible_bins] = bin_capacity * 2  # Set to large value for infeasible bins\n    best_fit_priority = -remaining_after_fit / bin_capacity # Normalize & invert: smaller remaining is better\n    priorities += best_fit_priority\n\n    # 3. Moderate Fill: Penalize bins that are nearly full or nearly empty *before* item placement.\n    nearly_full_threshold = 0.9\n    nearly_empty_threshold = 0.1\n    moderate_fill_penalty = 0.3\n\n    nearly_full_bins = (bins_remain_cap / bin_capacity) > nearly_full_threshold\n    nearly_empty_bins = (bins_remain_cap / bin_capacity) < nearly_empty_threshold\n\n    priorities[feasible_bins & nearly_full_bins] -= moderate_fill_penalty\n    priorities[feasible_bins & nearly_empty_bins] -= moderate_fill_penalty\n\n    # 4. Fragmentation Penalty: Heavily penalize bins that will create a very small fragment.\n    fragment_threshold = 0.15\n    fragment_penalty = 0.8\n    fragment_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit / bin_capacity <= fragment_threshold)\n    priorities[fragment_mask] -= fragment_penalty\n\n    # 5. Reward Near-Perfect Fit: Significant bonus for near perfect fits\n    near_perfect_fit_threshold = 0.05\n    near_perfect_fit_bonus = 0.7\n    near_perfect_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit / bin_capacity <= near_perfect_fit_threshold)\n    priorities[near_perfect_mask] += near_perfect_fit_bonus\n\n    # 6. Small Item Penalty: Slightly discourage placing very small items into partially filled bins.\n    small_item_threshold = 0.1\n    small_item_penalty = 0.1\n    small_item = item / bin_capacity < small_item_threshold\n    if small_item:\n      partially_filled_bins = feasible_bins & (bins_remain_cap < bin_capacity)\n      priorities[partially_filled_bins] -= small_item_penalty\n      \n    return priorities",
    "response_id": 0,
    "obj": 2.6725169525329036,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter7_response1.txt_stdout.txt",
    "code_path": "problem_iter7_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)\n\n    # 1. Feasibility: Infeasible bins get a very large negative priority.\n    feasible_bins = bins_remain_cap >= item\n    priorities[~feasible_bins] = -1e9\n\n    # 2. Best Fit: Prioritize bins where the item fits best (smallest remaining space).\n    remaining_after_fit = bins_remain_cap - item\n    \n    #Only consider remaining capacity for feasible bins\n    remaining_after_fit_adj = np.copy(remaining_after_fit)\n    remaining_after_fit_adj[~feasible_bins] = bin_capacity + item\n\n    # Normalize remaining capacity (smaller is better)\n    normalized_remaining = 1 - (remaining_after_fit_adj / bin_capacity)\n    priorities += normalized_remaining\n\n    # 3. Moderate Fill: Penalize bins that are almost full or almost empty *after* placing the item.\n    almost_full_threshold = 0.1 * bin_capacity # consider as a percentage\n    almost_empty_threshold = 0.9 * bin_capacity\n\n    almost_full_mask = feasible_bins & (remaining_after_fit <= almost_full_threshold) & (remaining_after_fit >= 0)\n    almost_empty_mask = feasible_bins & (remaining_after_fit >= almost_empty_threshold)\n    \n    # Penalize almost full slightly more than almost empty\n    priorities[almost_full_mask] -= 0.6\n    priorities[almost_empty_mask] -= 0.3\n    \n\n    # 4. Small Item Penalty: Reduce the priority of placing small items if a near-perfect fit isn't possible.\n    small_item_threshold = 0.2 * bin_capacity\n    if item <= small_item_threshold:\n        near_perfect_fit_threshold = 0.1 * bin_capacity\n        near_perfect_mask = feasible_bins & (remaining_after_fit >= 0) & (remaining_after_fit <= near_perfect_fit_threshold)\n        \n        # Only apply penalty if no near perfect fit.\n        if not np.any(near_perfect_mask):\n            priorities[feasible_bins] -= 0.2 # Slightly penalize\n\n    # 5. Reward Near-Perfect Fit: Significant bonus for bins that have a near-perfect fit\n    near_perfect_fit_threshold = 0.1 * bin_capacity\n    near_perfect_fit_bonus = 0.7\n    near_perfect_mask = feasible_bins & (remaining_after_fit >= 0) & (remaining_after_fit <= near_perfect_fit_threshold)\n    priorities[near_perfect_mask] += near_perfect_fit_bonus\n    \n\n    # 6. Fragmentation Penalty: Penalize creating very small fragments.\n    fragment_threshold = 0.15 * bin_capacity\n    fragment_penalty = 0.5\n    fragment_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit <= fragment_threshold)\n    priorities[fragment_mask] -= fragment_penalty\n\n\n    return priorities",
    "response_id": 1,
    "obj": 3.669724770642197,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter7_response2.txt_stdout.txt",
    "code_path": "problem_iter7_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)\n\n    # 1. Feasibility: Infeasible bins get a large negative priority.\n    feasible_bins = bins_remain_cap >= item\n    priorities[~feasible_bins] = -1e9\n\n    # 2. Best Fit Preference: Prioritize bins where the remaining space after placing the item is minimized.\n    remaining_after_fit = bins_remain_cap - item\n    remaining_after_fit[~feasible_bins] = bin_capacity # some large value for infeasible bins\n\n    # Normalize remaining capacity (smaller is better, but penalize almost full)\n    normalized_remaining = (bin_capacity - remaining_after_fit) / bin_capacity  # Higher means better fill\n\n    # 3. Penalize Near-Full Bins: Avoid bins that are almost full after placing the item.\n    near_full_threshold = 0.95\n    near_full_penalty = 0.6\n    near_full_mask = feasible_bins & ((bins_remain_cap - item) / bin_capacity >= near_full_threshold)\n    priorities[near_full_mask] -= near_full_penalty\n\n    # 4. Penalize Small Items: Avoid placing small items in almost empty bins to prevent fragmentation.\n    small_item_threshold = 0.2\n    empty_bin_threshold = 0.9\n    small_item_penalty = 0.4\n    small_item_mask = (item / bin_capacity <= small_item_threshold) & feasible_bins & (bins_remain_cap / bin_capacity >= empty_bin_threshold)\n    priorities[small_item_mask] -= small_item_penalty\n\n    # 5. Reward Near-Perfect Fit: Encourage using bins that almost perfectly fit the item.\n    near_perfect_fit_threshold = 0.1\n    near_perfect_fit_bonus = 0.8\n    near_perfect_mask = feasible_bins & (remaining_after_fit >= 0) & (remaining_after_fit <= near_perfect_fit_threshold * bin_capacity)\n    priorities[near_perfect_mask] += near_perfect_fit_bonus\n    \n    # 6. Fragmentation penalty, higher than before, if fragmentation occurs, penalize more\n    fragment_threshold = 0.2\n    fragment_penalty = 0.9\n    fragment_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit <= fragment_threshold * bin_capacity)\n    priorities[fragment_mask] -= fragment_penalty\n\n    # 7. Moderate Fill Preference: Encourage bins to be moderately filled.\n    moderate_fill_lower = 0.3\n    moderate_fill_upper = 0.7\n    moderate_fill_bonus = 0.5\n    moderate_fill_mask = feasible_bins & (remaining_after_fit / bin_capacity >= (1 - moderate_fill_upper)) & (remaining_after_fit / bin_capacity <= (1 - moderate_fill_lower))\n    priorities[moderate_fill_mask] += moderate_fill_bonus\n    \n    priorities += normalized_remaining # Base fill level\n\n    return priorities",
    "response_id": 2,
    "obj": 8.137215795771853,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter7_response3.txt_stdout.txt",
    "code_path": "problem_iter7_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)\n    # 1. Feasibility: Infeasible bins get a very negative priority.\n    feasible_bins = bins_remain_cap >= item\n    priorities[~feasible_bins] = -1e9\n\n    # 2. Best Fit: Prioritize bins with the least remaining capacity after adding the item.\n    remaining_after_fit = bins_remain_cap - item\n    remaining_after_fit[~feasible_bins] = bin_capacity * 2 # set to high value if infeasible\n\n    # Normalize remaining capacity, smaller is better.\n    normalized_remaining = 1 - (remaining_after_fit / bin_capacity)\n    priorities += normalized_remaining\n\n    # 3. Moderate Fill Level: Penalize near-empty and near-full bins.\n    fill_level_after = (bin_capacity - remaining_after_fit) / bin_capacity\n    near_empty_penalty = np.exp(-((fill_level_after - 0.1) ** 2) / 0.02) # Penalize fill near 0.1\n    near_full_penalty = np.exp(-((fill_level_after - 0.9) ** 2) / 0.02) # Penalize fill near 0.9\n\n    priorities -= (near_empty_penalty + near_full_penalty) * 0.3\n\n    # 4. Fragmentation penalty: Penalize leaving small fragments, but less severely.\n    fragment_threshold = 0.15 # Slightly increased threshold\n    fragment_penalty = 0.2\n    fragment_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit <= fragment_threshold * bin_capacity)\n    priorities[fragment_mask] -= fragment_penalty\n\n    # 5. Near perfect fit bonus: Increase the bonus for a near-perfect fit.\n    near_perfect_fit_threshold = 0.05\n    near_perfect_fit_bonus = 0.7\n    near_perfect_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit <= near_perfect_fit_threshold * bin_capacity)\n    priorities[near_perfect_mask] += near_perfect_fit_bonus\n\n    # 6. Penalize Small Items (discourage putting small items in almost empty bins)\n    small_item_threshold = 0.1\n    small_item_penalty = 0.1\n    small_item_mask = (item <= small_item_threshold * bin_capacity) & (bins_remain_cap >= 0.9 * bin_capacity) & feasible_bins\n    priorities[small_item_mask] -= small_item_penalty\n\n    return priorities",
    "response_id": 3,
    "obj": 2.921818907060227,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter7_response4.txt_stdout.txt",
    "code_path": "problem_iter7_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)\n\n    # 1. Feasibility: Infeasible bins get a large negative priority.\n    feasible_bins = bins_remain_cap >= item\n    priorities[~feasible_bins] = -1e9\n\n    # 2. Best Fit Preference\n    remaining_after_fit = bins_remain_cap - item\n    best_fit_delta = np.abs(remaining_after_fit)\n    # Adjust the best fit delta for infeasible bins\n    best_fit_delta_adj = np.copy(best_fit_delta)\n    best_fit_delta_adj[~feasible_bins] = bin_capacity * 2 # assign large penalty\n    # Normalize best fit delta and create priority (lower delta = higher priority)\n    normalized_best_fit = 1 - (best_fit_delta_adj / np.max(best_fit_delta_adj))\n    priorities += normalized_best_fit\n\n    # 3. Moderate Fill Preference (avoid near-empty and near-full bins)\n    fill_level = (bin_capacity - bins_remain_cap + item)/ bin_capacity\n    moderate_fill_bonus = np.exp(-((fill_level - 0.6)**2) / (2 * 0.2**2))  # Gaussian centered at 0.6\n    priorities += moderate_fill_bonus * feasible_bins  # only add bonus to feasible bins.\n    \n\n    # 4. Penalize Small Items (when other choices exist)\n    small_item_threshold = 0.1 * bin_capacity\n    small_item_penalty = 0.3\n    if item < small_item_threshold:\n        priorities[feasible_bins] -= small_item_penalty # Apply to all feasible bins\n\n    # 5. Fragment Penalty\n    fragment_threshold = 0.15 * bin_capacity\n    fragment_penalty = 0.5\n    fragment_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit <= fragment_threshold)\n    priorities[fragment_mask] -= fragment_penalty\n\n    # 6. Near-Perfect Fit Reward\n    near_perfect_fit_threshold = 0.05 * bin_capacity\n    near_perfect_fit_bonus = 0.7\n    near_perfect_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit <= near_perfect_fit_threshold)\n    priorities[near_perfect_mask] += near_perfect_fit_bonus\n\n    return priorities",
    "response_id": 4,
    "obj": 8.984842441164753,
    "exec_success": true
  }
]