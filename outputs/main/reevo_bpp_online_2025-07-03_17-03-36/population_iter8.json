[
  {
    "stdout_filepath": "problem_iter8_response0.txt_stdout.txt",
    "code_path": "problem_iter8_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: Infeasible bins get the lowest priority.\n    feasible_bins = bins_remain_cap >= item\n    priorities[~feasible_bins] = -np.inf\n\n    # 2. Best Fit: Maximize remaining capacity after placing the item (minimize negative remaining capacity).\n    remaining_after_fit = bins_remain_cap - item\n    priorities[feasible_bins] = -remaining_after_fit[feasible_bins]  # Smaller remaining capacity is better\n\n    # 3. Fragmentation Penalty: Penalize creating small fragments.\n    fragment_threshold = 0.15 * np.max(bins_remain_cap)\n    fragment_penalty = 0.5\n    fragment_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit <= fragment_threshold)\n    priorities[fragment_mask] -= fragment_penalty\n\n    # 4. Near-full penalty. Penalize bins that are almost full after adding an item.\n    near_full_threshold = 0.95 * np.max(bins_remain_cap)\n    near_full_penalty = 0.3\n    near_full_mask = feasible_bins & (remaining_after_fit >= 0) & (remaining_after_fit <= (np.max(bins_remain_cap) - near_full_threshold))\n    priorities[near_full_mask] -= near_full_penalty\n\n    # 5. Encourage using empty bins if possible.\n    empty_bin_threshold = 0.99 * np.max(bins_remain_cap)\n    empty_bin_bonus = 0.2\n    empty_bin_mask = feasible_bins & (bins_remain_cap >= empty_bin_threshold)\n    priorities[empty_bin_mask] += empty_bin_bonus\n\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response1.txt_stdout.txt",
    "code_path": "problem_iter8_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)\n\n    # 1. Feasibility: Infeasible bins get a very large negative priority.\n    feasible_bins = bins_remain_cap >= item\n    priorities[~feasible_bins] = -1e9\n\n    # 2. Best Fit: Prefer bins where the remaining capacity after placement is minimal\n    remaining_after_fit = bins_remain_cap - item\n    remaining_after_fit[~feasible_bins] = bin_capacity * 2  # Set to large value for infeasible bins\n    best_fit_priority = -remaining_after_fit / bin_capacity  # Normalize & invert: smaller remaining is better\n    priorities += best_fit_priority\n\n    # 3. Moderate Fill: Penalize bins that are nearly full or nearly empty *before* item placement.\n    nearly_full_threshold = 0.9\n    nearly_empty_threshold = 0.1\n    moderate_fill_penalty = 0.3\n\n    nearly_full_bins = (bins_remain_cap / bin_capacity) > nearly_full_threshold\n    nearly_empty_bins = (bins_remain_cap / bin_capacity) < nearly_empty_threshold\n\n    priorities[feasible_bins & nearly_full_bins] -= moderate_fill_penalty\n    priorities[feasible_bins & nearly_empty_bins] -= moderate_fill_penalty\n\n    # 4. Fragmentation Penalty: Heavily penalize bins that will create a very small fragment.\n    fragment_threshold = 0.15\n    fragment_penalty = 0.8\n    fragment_mask = feasible_bins & (remaining_after_fit >= 0) & (remaining_after_fit / bin_capacity <= fragment_threshold)\n    priorities[fragment_mask] -= fragment_penalty\n\n    # 5. Reward Near-Perfect Fit: Significant bonus for near perfect fits\n    near_perfect_fit_threshold = 0.05\n    near_perfect_fit_bonus = 0.7\n    near_perfect_mask = feasible_bins & (remaining_after_fit >= 0) & (remaining_after_fit / bin_capacity <= near_perfect_fit_threshold)\n    priorities[near_perfect_mask] += near_perfect_fit_bonus\n\n    # 6. Small Item Penalty: Slightly discourage placing very small items into partially filled bins.\n    small_item_threshold = 0.1\n    small_item_penalty = 0.1\n    small_item = item / bin_capacity < small_item_threshold\n    if small_item:\n        partially_filled_bins = feasible_bins & (bins_remain_cap < bin_capacity)\n        priorities[partially_filled_bins] -= small_item_penalty\n\n    # 7. Normalize Priorities: Scale priorities to a reasonable range\n    max_priority = np.max(priorities[feasible_bins]) if np.any(feasible_bins) else 0\n    min_priority = np.min(priorities[feasible_bins]) if np.any(feasible_bins) else 0\n\n    if max_priority > min_priority:\n      priorities[feasible_bins] = (priorities[feasible_bins] - min_priority) / (max_priority - min_priority)\n    elif np.any(feasible_bins):\n        priorities[feasible_bins] = 0.5  # Give all feasible bins a neutral priority if they are all the same.\n\n    return priorities",
    "response_id": 1,
    "obj": 2.68248903071401,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response2.txt_stdout.txt",
    "code_path": "problem_iter8_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    max_bin_cap = np.max(bins_remain_cap)\n\n    # 1. Feasibility: Infeasible bins get a large negative priority.\n    feasible_bins = bins_remain_cap >= item\n    priorities[~feasible_bins] = -1e9\n\n    # 2. Remaining Capacity: Prefer bins with less remaining capacity *after* placing the item.\n    remaining_after_fit = bins_remain_cap - item\n\n    # Normalize remaining capacity (smaller is better), consider only feasible bins.\n    remaining_after_fit_adj = np.where(feasible_bins, remaining_after_fit, max_bin_cap * 2)  # Large value for infeasible\n    normalized_remaining = 1 - (remaining_after_fit_adj / (max_bin_cap * 2))  # Normalize to [0, 1]\n    priorities += normalized_remaining\n\n    # 3. Fragmentation Penalty: Penalize bins that will leave a small unusable fragment.\n    fragment_threshold = 0.15\n    fragment_penalty = 0.6\n    fragment_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit <= fragment_threshold * max_bin_cap)\n    priorities[fragment_mask] -= fragment_penalty\n\n    # 4. Reward Near-Perfect Fit: Encourage using bins that almost perfectly fit the item.\n    near_perfect_fit_threshold = 0.075\n    near_perfect_fit_bonus = 0.7\n    near_perfect_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit <= near_perfect_fit_threshold * max_bin_cap)\n    priorities[near_perfect_mask] += near_perfect_fit_bonus\n\n    # 5. Encourage usage of emptier bins when possible, to reduce # of bins used\n    empty_bin_threshold = 0.9\n    empty_bin_bonus = 0.3\n    empty_bin_mask = feasible_bins & (bins_remain_cap >= empty_bin_threshold * max_bin_cap)\n    priorities[empty_bin_mask] += empty_bin_bonus\n\n    # 6. Penalize filling near-full bins, especially if larger bins are available.\n    near_full_threshold = 0.1\n    near_full_penalty = 0.4\n\n    if np.any(bins_remain_cap >= empty_bin_threshold * max_bin_cap):\n        near_full_mask = feasible_bins & (bins_remain_cap <= near_full_threshold * max_bin_cap)\n        priorities[near_full_mask] -= near_full_penalty\n\n    # 7. Add a slight penalty for using bins which were completely empty before\n    previously_empty_penalty = 0.2\n    previously_empty_mask = (bins_remain_cap == max_bin_cap) & feasible_bins\n    priorities[previously_empty_mask] -= previously_empty_penalty\n    return priorities",
    "response_id": 2,
    "obj": 3.280813721579586,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response3.txt_stdout.txt",
    "code_path": "problem_iter8_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: Infeasible bins get the lowest priority.\n    feasible_bins = bins_remain_cap >= item\n    priorities[~feasible_bins] = -np.inf\n\n    # 2. Best Fit: Maximize remaining capacity after placing the item (minimize negative remaining capacity).\n    remaining_after_fit = bins_remain_cap - item\n    priorities[feasible_bins] = -remaining_after_fit[feasible_bins]  # Smaller remaining capacity is better\n\n    # 3. Fragmentation Penalty: Penalize creating small fragments.\n    fragment_threshold = 0.2 * np.max(bins_remain_cap)\n    fragment_penalty = 0.7\n    fragment_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit <= fragment_threshold)\n    priorities[fragment_mask] -= fragment_penalty\n\n    return priorities",
    "response_id": 3,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response4.txt_stdout.txt",
    "code_path": "problem_iter8_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)\n\n    # 1. Feasibility: Infeasible bins get a very large negative priority.\n    feasible_bins = bins_remain_cap >= item\n    priorities[~feasible_bins] = -1e9\n\n    # 2. Best Fit: Prefer bins where the remaining capacity after placement is minimal\n    remaining_after_fit = bins_remain_cap - item\n    remaining_after_fit[~feasible_bins] = bin_capacity * 2  # Set to large value for infeasible bins\n    best_fit_priority = -remaining_after_fit / bin_capacity # Normalize & invert: smaller remaining is better\n    priorities += best_fit_priority\n\n    # 3. Moderate Fill: Penalize bins that are nearly full or nearly empty *before* item placement.\n    nearly_full_threshold = 0.9\n    nearly_empty_threshold = 0.1\n    moderate_fill_penalty = 0.3\n\n    nearly_full_bins = (bins_remain_cap / bin_capacity) > nearly_full_threshold\n    nearly_empty_bins = (bins_remain_cap / bin_capacity) < nearly_empty_threshold\n\n    priorities[feasible_bins & nearly_full_bins] -= moderate_fill_penalty\n    priorities[feasible_bins & nearly_empty_bins] -= moderate_fill_penalty\n\n    # 4. Fragmentation Penalty: Heavily penalize bins that will create a very small fragment.\n    fragment_threshold = 0.15\n    fragment_penalty = 0.8\n    fragment_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit / bin_capacity <= fragment_threshold)\n    priorities[fragment_mask] -= fragment_penalty\n\n    # 5. Reward Near-Perfect Fit: Significant bonus for near perfect fits\n    near_perfect_fit_threshold = 0.05\n    near_perfect_fit_bonus = 0.7\n    near_perfect_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit / bin_capacity <= near_perfect_fit_threshold)\n    priorities[near_perfect_mask] += near_perfect_fit_bonus\n\n    # 6. Small Item Penalty: Slightly discourage placing very small items into partially filled bins.  Also, give a slight preference to placing small items in empty bins.\n    small_item_threshold = 0.1\n    small_item_penalty = 0.1\n    small_item = item / bin_capacity < small_item_threshold\n    if small_item:\n      partially_filled_bins = feasible_bins & (bins_remain_cap < bin_capacity) & (bins_remain_cap > 0)\n      empty_bins = bins_remain_cap == bin_capacity\n      priorities[partially_filled_bins] -= small_item_penalty\n      priorities[empty_bins] += small_item_penalty/2 #Slight preference for empty bins\n\n    #7. Bin balancing: Try to balance the fill levels of the bins\n    bin_fill_levels = (bin_capacity - bins_remain_cap) / bin_capacity\n    mean_fill_level = np.mean(bin_fill_levels)\n    bin_balancing_penalty = 0.05 * np.abs(bin_fill_levels - mean_fill_level)\n    priorities -= bin_balancing_penalty\n\n\n    return priorities",
    "response_id": 4,
    "obj": 2.6525727961707357,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response5.txt_stdout.txt",
    "code_path": "problem_iter8_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)\n\n    # 1. Feasibility: Infeasible bins get a very large negative priority.\n    feasible_bins = bins_remain_cap >= item\n    priorities[~feasible_bins] = -1e9\n\n    # 2. Best Fit: Prioritize bins where the item fits best (smallest remaining space).\n    remaining_after_fit = bins_remain_cap - item\n    remaining_after_fit_adj = np.copy(remaining_after_fit)\n    remaining_after_fit_adj[~feasible_bins] = bin_capacity + item\n\n    # Normalize remaining capacity (smaller is better)\n    normalized_remaining = 1 - (remaining_after_fit_adj / bin_capacity)\n    priorities += normalized_remaining\n\n    # 3. Moderate Fill: Penalize bins that are almost full or almost empty *after* placing the item.\n    almost_full_threshold = 0.1 * bin_capacity\n    almost_empty_threshold = 0.9 * bin_capacity\n\n    almost_full_mask = feasible_bins & (remaining_after_fit <= almost_full_threshold) & (remaining_after_fit >= 0)\n    almost_empty_mask = feasible_bins & (remaining_after_fit >= almost_empty_threshold)\n\n    # Penalize almost full slightly more than almost empty\n    priorities[almost_full_mask] -= 0.6\n    priorities[almost_empty_mask] -= 0.3\n\n    # 4. Adaptive Item Size Penalty: Penalize placing items based on their relative size\n    item_ratio = item / bin_capacity\n    if item_ratio > 0.5:\n        priorities[feasible_bins] -= 0.4 * item_ratio  # Larger items get a higher penalty\n    elif item_ratio > 0.2:\n        priorities[feasible_bins] -= 0.2 * item_ratio # Moderate penalty\n\n    # 5. Reward Near-Perfect Fit: Significant bonus for bins that have a near-perfect fit\n    near_perfect_fit_threshold = 0.1 * bin_capacity\n    near_perfect_fit_bonus = 0.7\n    near_perfect_mask = feasible_bins & (remaining_after_fit >= 0) & (remaining_after_fit <= near_perfect_fit_threshold)\n    priorities[near_perfect_mask] += near_perfect_fit_bonus\n\n    # 6. Fragmentation Penalty: Penalize creating very small fragments.\n    fragment_threshold = 0.15 * bin_capacity\n    fragment_penalty = 0.5\n    fragment_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit <= fragment_threshold)\n    priorities[fragment_mask] -= fragment_penalty\n\n    return priorities",
    "response_id": 5,
    "obj": 3.64978061428003,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response6.txt_stdout.txt",
    "code_path": "problem_iter8_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)\n\n    # 1. Feasibility: Infeasible bins get a large negative priority.\n    feasible_bins = bins_remain_cap >= item\n    priorities[~feasible_bins] = -1e9\n\n    # 2. Best Fit: Prioritize bins where the remaining capacity after adding the item is minimized.\n    remaining_after_fit = bins_remain_cap - item\n\n    # Handle infeasible bins to avoid errors during normalization.\n    remaining_after_fit_adj = np.copy(remaining_after_fit)\n    remaining_after_fit_adj[~feasible_bins] = bin_capacity + item  # Set to a value larger than any feasible remaining capacity\n\n    # Normalize remaining capacity (smaller is better) - Best Fit principle\n    min_remaining = np.min(remaining_after_fit_adj) # use minimum for normalization\n    normalized_remaining = 1 - (remaining_after_fit_adj - min_remaining) / (bin_capacity - min_remaining)\n    priorities += normalized_remaining\n\n    # 3. Fragmentation Penalty: Penalize bins that will leave a small unusable fragment.\n    fragment_threshold = 0.2  # Define a threshold for small fragments relative to bin size\n    fragment_penalty = 0.6\n    fragment_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit <= fragment_threshold * bin_capacity)\n    priorities[fragment_mask] -= fragment_penalty\n\n    # 4. Reward Near-Perfect Fit: Encourage using bins that almost perfectly fit the item.\n    near_perfect_fit_threshold = 0.1\n    near_perfect_fit_bonus = 0.4\n    near_perfect_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit <= near_perfect_fit_threshold * bin_capacity)\n    priorities[near_perfect_mask] += near_perfect_fit_bonus\n\n    # 5. Encourage usage of emptier bins when possible, to reduce # of bins used\n    empty_bin_threshold = 0.8\n    if np.any(bins_remain_cap >= empty_bin_threshold * bin_capacity):\n        empty_bin_bonus = 0.3\n        empty_bin_mask = feasible_bins & (bins_remain_cap >= empty_bin_threshold * bin_capacity)\n        priorities[empty_bin_mask] += empty_bin_bonus\n\n    #6. Moderate Fill Preference: slightly encourage bins to be moderately filled to avoid extremes.\n    moderate_fill_lower = 0.3\n    moderate_fill_upper = 0.7\n    moderate_fill_bonus = 0.1 # keep the bonus moderate to not over-influence the decision\n    moderate_fill_mask = feasible_bins & (remaining_after_fit / bin_capacity >= (1 - moderate_fill_upper)) & (remaining_after_fit / bin_capacity <= (1 - moderate_fill_lower))\n    priorities[moderate_fill_mask] += moderate_fill_bonus\n\n    return priorities",
    "response_id": 6,
    "obj": 4.517351416035098,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response7.txt_stdout.txt",
    "code_path": "problem_iter8_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)\n\n    # 1. Feasibility: Infeasible bins get a very large negative priority.\n    feasible_bins = bins_remain_cap >= item\n    priorities[~feasible_bins] = -1e9\n\n    # 2. Best Fit: Prefer bins where the remaining capacity after placement is minimal\n    remaining_after_fit = bins_remain_cap - item\n    remaining_after_fit[~feasible_bins] = bin_capacity * 2  # Set to large value for infeasible bins\n    best_fit_priority = -remaining_after_fit / bin_capacity # Normalize & invert: smaller remaining is better\n    priorities += best_fit_priority\n\n    # 3. Moderate Fill: Penalize bins that are nearly full or nearly empty *before* item placement.\n    nearly_full_threshold = 0.9\n    nearly_empty_threshold = 0.1\n    moderate_fill_penalty = 0.3\n\n    nearly_full_bins = (bins_remain_cap / bin_capacity) > nearly_full_threshold\n    nearly_empty_bins = (bins_remain_cap / bin_capacity) < nearly_empty_threshold\n\n    priorities[feasible_bins & nearly_full_bins] -= moderate_fill_penalty\n    priorities[feasible_bins & nearly_empty_bins] -= moderate_fill_penalty\n\n    # 4. Fragmentation Penalty: Heavily penalize bins that will create a very small fragment.\n    fragment_threshold = 0.15\n    fragment_penalty = 0.8\n    fragment_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit / bin_capacity <= fragment_threshold)\n    priorities[fragment_mask] -= fragment_penalty\n\n    # 5. Reward Near-Perfect Fit: Significant bonus for near perfect fits\n    near_perfect_fit_threshold = 0.05\n    near_perfect_fit_bonus = 0.7\n    near_perfect_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit / bin_capacity <= near_perfect_fit_threshold)\n    priorities[near_perfect_mask] += near_perfect_fit_bonus\n\n    # 6. Small Item Penalty: Slightly discourage placing very small items into partially filled bins.\n    small_item_threshold = 0.1\n    small_item_penalty = 0.1\n    if item / bin_capacity < small_item_threshold:\n        partially_filled_bins = feasible_bins & (bins_remain_cap < bin_capacity)\n        priorities[partially_filled_bins] -= small_item_penalty\n\n    # 7. Large Item Bonus: Encourage placing large items into emptier bins.\n    large_item_threshold = 0.7\n    large_item_bonus = 0.2\n    if item / bin_capacity > large_item_threshold:\n        relatively_empty_bins = feasible_bins & ((bins_remain_cap / bin_capacity) > 0.5)  # Bins more than half empty\n        priorities[relatively_empty_bins] += large_item_bonus\n\n    return priorities",
    "response_id": 7,
    "obj": 2.6725169525329036,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response8.txt_stdout.txt",
    "code_path": "problem_iter8_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: Assign a large negative priority to bins that can't fit the item\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -1e9  # Large penalty for infeasibility\n\n    # 2. Best Fit: Prioritize bins with the smallest remaining capacity *after* adding the item, but only for feasible bins\n    feasible_bins = ~infeasible_bins\n    remaining_after_fit = bins_remain_cap[feasible_bins] - item\n\n    # Primary Best Fit scoring (smaller waste is better)\n    priorities[feasible_bins] = -remaining_after_fit\n\n    # Encourage moderate fill levels (avoid bins that are too full or too empty after placement)\n    bin_capacity = np.max(bins_remain_cap)\n    if bin_capacity > 0:\n        # Scale the remaining capacity and subtract a small amount. Encourages filling bins without overfilling.\n        priorities[feasible_bins] -= (bins_remain_cap[feasible_bins] / bin_capacity) * 0.001\n\n        # Bonus for bins that are reasonably full *after* placing the item, but not excessively full.\n        # This encourages consolidating items into fewer bins while preventing extreme fragmentation.\n        reasonable_fill = (remaining_after_fit > 0.1 * bin_capacity) & (remaining_after_fit < 0.8 * bin_capacity) # play with these parameters\n        priorities[feasible_bins][reasonable_fill] += 0.0005 # tiny bonus\n\n    # Slight penalty for bins that become almost full after placing the item\n    almost_full = (remaining_after_fit > 0) & (remaining_after_fit <= 0.05 * bin_capacity)\n    priorities[feasible_bins][almost_full] -= 0.0002\n    \n\n    return priorities",
    "response_id": 8,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response9.txt_stdout.txt",
    "code_path": "problem_iter8_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    max_bin_cap = np.max(bins_remain_cap)\n\n    # 1. Feasibility: Infeasible bins get a large negative priority.\n    feasible_bins = bins_remain_cap >= item\n    priorities[~feasible_bins] = -1e9\n\n    # 2. Normalized Remaining Capacity: Prioritize based on remaining capacity *after* placing the item.\n    remaining_after_fit = bins_remain_cap - item\n    remaining_after_fit_adj = np.copy(remaining_after_fit)\n    remaining_after_fit_adj[~feasible_bins] = max_bin_cap + item  # Large value for infeasible bins\n\n    normalized_remaining = 1 - (remaining_after_fit_adj / max_bin_cap)\n    priorities += normalized_remaining\n\n    # 3. Fragmentation Penalty: Discourage bins that will result in small, unusable fragments.\n    fragment_threshold = 0.2\n    fragment_penalty = 0.8\n    fragment_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit <= fragment_threshold * max_bin_cap)\n    priorities[fragment_mask] -= fragment_penalty\n\n    # 4. Reward Near-Perfect Fit: Encourage bins that provide a near-perfect fit for the item.\n    near_perfect_fit_threshold = 0.1\n    near_perfect_fit_bonus = 0.6\n    near_perfect_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit <= near_perfect_fit_threshold * max_bin_cap)\n    priorities[near_perfect_mask] += near_perfect_fit_bonus\n\n    # 5. Encourage usage of emptier bins when possible, but only if some bins are actually empty\n    empty_bin_threshold = 0.9\n    if np.any(bins_remain_cap >= empty_bin_threshold * max_bin_cap):\n        empty_bin_bonus = 0.3\n        empty_bin_mask = feasible_bins & (bins_remain_cap >= empty_bin_threshold * max_bin_cap)\n        priorities[empty_bin_mask] += empty_bin_bonus\n\n    # 6. Prioritize bins with larger remaining capacity if near-full bins exist and some bins have substantial space\n    near_full_threshold = 0.2 # Increased threshold\n    if np.any(bins_remain_cap <= near_full_threshold * max_bin_cap) and np.any(bins_remain_cap >= empty_bin_threshold * max_bin_cap):\n        larger_bin_bonus = 0.15  # Slightly increased bonus\n        larger_bin_mask = feasible_bins & (bins_remain_cap >= empty_bin_threshold * max_bin_cap)\n        priorities[larger_bin_mask] += larger_bin_bonus\n    \n    # 7. Moderate Fill Preference Adjustment: Slightly prioritize moderate fill to further balance bin usage\n    moderate_fill_lower = 0.3\n    moderate_fill_upper = 0.7\n    moderate_fill_bonus = 0.2 # Reduced compared to v0\n    moderate_fill_mask = feasible_bins & (remaining_after_fit / max_bin_cap >= (1 - moderate_fill_upper)) & (remaining_after_fit / max_bin_cap <= (1 - moderate_fill_lower))\n    priorities[moderate_fill_mask] += moderate_fill_bonus\n\n    return priorities",
    "response_id": 9,
    "obj": 16.174710809732755,
    "exec_success": true
  }
]