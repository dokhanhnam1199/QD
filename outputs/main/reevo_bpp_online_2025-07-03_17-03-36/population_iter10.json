[
  {
    "stdout_filepath": "problem_iter10_response0.txt_stdout.txt",
    "code_path": "problem_iter10_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    max_bin_cap = np.max(bins_remain_cap)\n\n    # 1. Feasibility: Infeasible bins get a large negative priority.\n    feasible_bins = bins_remain_cap >= item\n    priorities[~feasible_bins] = -1e9\n\n    # 2. Best Fit (Normalized): Prefer bins where the remaining capacity after placement is minimal\n    remaining_after_fit = bins_remain_cap - item\n    remaining_after_fit_adj = np.where(feasible_bins, remaining_after_fit, max_bin_cap * 2)  # Large value for infeasible\n    normalized_remaining = 1 - (remaining_after_fit_adj / (max_bin_cap + 1e-6))  # Normalize to [0, 1], adding small value to prevent divide by zero\n    priorities += normalized_remaining\n\n    # 3. Fragmentation Penalty: Penalize bins that will leave a small unusable fragment.\n    fragment_threshold = 0.12\n    fragment_penalty = 0.5\n    fragment_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit <= fragment_threshold * max_bin_cap)\n    priorities[fragment_mask] -= fragment_penalty\n\n    # 4. Reward Near-Perfect Fit: Encourage using bins that almost perfectly fit the item.\n    near_perfect_fit_threshold = 0.06\n    near_perfect_fit_bonus = 0.65\n    near_perfect_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit <= near_perfect_fit_threshold * max_bin_cap)\n    priorities[near_perfect_mask] += near_perfect_fit_bonus\n\n    # 5. Encourage usage of emptier bins when possible, to reduce # of bins used, but only if item isn't too big\n    empty_bin_threshold = 0.85\n    empty_bin_bonus = 0.35\n    item_size_threshold = 0.6\n    empty_bin_mask = feasible_bins & (bins_remain_cap >= empty_bin_threshold * max_bin_cap) & (item <= item_size_threshold * max_bin_cap)\n    priorities[empty_bin_mask] += empty_bin_bonus\n\n    # 6. Penalize filling near-full bins, especially if larger bins are available. Stronger penalty\n    near_full_threshold = 0.15\n    near_full_penalty = 0.5\n    if np.any(bins_remain_cap >= empty_bin_threshold * max_bin_cap):\n        near_full_mask = feasible_bins & (bins_remain_cap <= near_full_threshold * max_bin_cap)\n        priorities[near_full_mask] -= near_full_penalty\n\n    # 7. Add a slight penalty for using bins which were completely empty before - reduced penalty\n    previously_empty_penalty = 0.15\n    previously_empty_mask = (bins_remain_cap == max_bin_cap) & feasible_bins\n    priorities[previously_empty_mask] -= previously_empty_penalty\n\n    # 8. Prioritize bins with capacities closest to item size if there are multiple feasible bins\n    if np.sum(feasible_bins) > 1:\n        size_diff = np.abs(bins_remain_cap[feasible_bins] - item)\n        normalized_size_diff = 1 - (size_diff / (max_bin_cap + 1e-6))\n        priorities[feasible_bins] += normalized_size_diff * 0.2  # Add a fraction of this score\n\n    return priorities",
    "response_id": 0,
    "obj": 4.637016354208217,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response1.txt_stdout.txt",
    "code_path": "problem_iter10_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)\n\n    # Normalize item size and remaining capacities\n    normalized_item = item / bin_capacity\n    normalized_bins_remain_cap = bins_remain_cap / bin_capacity\n\n    # 1. Feasibility: Infeasible bins get a very large negative priority.\n    feasible_bins = normalized_bins_remain_cap >= normalized_item\n    priorities[~feasible_bins] = -1e9\n\n    # 2. Best Fit: Prefer bins where the remaining capacity after placement is minimal\n    remaining_after_fit = normalized_bins_remain_cap - normalized_item\n    remaining_after_fit[~feasible_bins] = 2  # Set to large value for infeasible bins\n    best_fit_priority = -remaining_after_fit  # Smaller remaining is better\n    priorities += best_fit_priority\n\n    # 3. Moderate Fill: Penalize bins that are nearly full or nearly empty *before* item placement.\n    nearly_full_threshold = 0.9\n    nearly_empty_threshold = 0.1\n    moderate_fill_penalty = 0.3\n\n    nearly_full_bins = normalized_bins_remain_cap > nearly_full_threshold\n    nearly_empty_bins = normalized_bins_remain_cap < nearly_empty_threshold\n\n    priorities[feasible_bins & nearly_full_bins] -= moderate_fill_penalty\n    priorities[feasible_bins & nearly_empty_bins] -= moderate_fill_penalty\n\n    # 4. Fragmentation Penalty: Heavily penalize bins that will create a very small fragment.\n    fragment_threshold = 0.15\n    fragment_penalty = 0.8\n    fragment_mask = feasible_bins & (remaining_after_fit >= 0) & (remaining_after_fit <= fragment_threshold)\n    priorities[fragment_mask] -= fragment_penalty\n\n    # 5. Reward Near-Perfect Fit: Significant bonus for near perfect fits\n    near_perfect_fit_threshold = 0.05\n    near_perfect_fit_bonus = 0.7\n    near_perfect_mask = feasible_bins & (remaining_after_fit >= 0) & (remaining_after_fit <= near_perfect_fit_threshold)\n    priorities[near_perfect_mask] += near_perfect_fit_bonus\n\n    # 6. Small Item Penalty: Slightly discourage placing very small items into partially filled bins.\n    small_item_threshold = 0.1\n    small_item_penalty = 0.1\n    small_item = normalized_item < small_item_threshold\n    if small_item:\n        partially_filled_bins = feasible_bins & (normalized_bins_remain_cap < 1)\n        priorities[partially_filled_bins] -= small_item_penalty\n\n    # 7. Edge Case Handling: Give empty bins a slight preference if no good fit exists.\n    empty_bin_bonus = 0.05\n    empty_bins = normalized_bins_remain_cap == 1\n    if not np.any(near_perfect_mask) and np.any(feasible_bins & empty_bins):\n        priorities[feasible_bins & empty_bins] += empty_bin_bonus\n\n    # 8. Normalize Priorities: Scale priorities to a reasonable range\n    max_priority = np.max(priorities[feasible_bins]) if np.any(feasible_bins) else 0\n    min_priority = np.min(priorities[feasible_bins]) if np.any(feasible_bins) else 0\n\n    if max_priority > min_priority:\n        priorities[feasible_bins] = (priorities[feasible_bins] - min_priority) / (max_priority - min_priority)\n    elif np.any(feasible_bins):\n        priorities[feasible_bins] = 0.5  # Give all feasible bins a neutral priority if they are all the same.\n\n    return priorities",
    "response_id": 1,
    "obj": 2.7822098125249393,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response2.txt_stdout.txt",
    "code_path": "problem_iter10_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)\n\n    # 1. Feasibility: Infeasible bins get a very large negative priority.\n    feasible_bins = bins_remain_cap >= item\n    priorities[~feasible_bins] = -1e9\n\n    # 2. Best Fit: Prefer bins where the remaining capacity after placement is minimal\n    remaining_after_fit = bins_remain_cap - item\n    remaining_after_fit[~feasible_bins] = bin_capacity * 2  # Set to large value for infeasible bins\n    best_fit_priority = -remaining_after_fit / bin_capacity  # Normalize & invert: smaller remaining is better\n    priorities += best_fit_priority\n\n    # 3. Moderate Fill: Penalize bins that are nearly full or nearly empty *before* item placement.\n    nearly_full_threshold = 0.9\n    nearly_empty_threshold = 0.1\n    moderate_fill_penalty = 0.3\n\n    nearly_full_bins = (bins_remain_cap / bin_capacity) > nearly_full_threshold\n    nearly_empty_bins = (bins_remain_cap / bin_capacity) < nearly_empty_threshold\n\n    priorities[feasible_bins & nearly_full_bins] -= moderate_fill_penalty\n    priorities[feasible_bins & nearly_empty_bins] -= moderate_fill_penalty\n\n    # 4. Fragmentation Penalty: Heavily penalize bins that will create a very small fragment.\n    fragment_threshold = 0.15\n    fragment_penalty = 0.8\n    fragment_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit / bin_capacity <= fragment_threshold)\n    priorities[fragment_mask] -= fragment_penalty\n\n    # 5. Reward Near-Perfect Fit: Significant bonus for near perfect fits\n    near_perfect_fit_threshold = 0.05\n    near_perfect_fit_bonus = 0.7\n    near_perfect_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit / bin_capacity <= near_perfect_fit_threshold)\n    priorities[near_perfect_mask] += near_perfect_fit_bonus\n\n    # 6. Small Item Penalty: Slightly discourage placing very small items into partially filled bins.  Also, give a slight preference to placing small items in empty bins.\n    small_item_threshold = 0.1\n    small_item_penalty = 0.1\n    small_item = item / bin_capacity < small_item_threshold\n    if small_item:\n        partially_filled_bins = feasible_bins & (bins_remain_cap < bin_capacity) & (bins_remain_cap > 0)\n        empty_bins = bins_remain_cap == bin_capacity\n        priorities[partially_filled_bins] -= small_item_penalty\n        priorities[empty_bins] += small_item_penalty / 2  # Slight preference for empty bins\n\n    # 7. Bin balancing: Try to balance the fill levels of the bins\n    bin_fill_levels = (bin_capacity - bins_remain_cap) / bin_capacity\n    mean_fill_level = np.mean(bin_fill_levels)\n    bin_balancing_penalty = 0.05 * np.abs(bin_fill_levels - mean_fill_level)\n    priorities -= bin_balancing_penalty\n\n    # Simplified rule: Slightly prefer bins with capacity closest to item size\n    priority_item_fit = -np.abs(bins_remain_cap - item) / bin_capacity\n    priorities += 0.02*priority_item_fit #Scale to keep it subtle\n\n    # 8. Encourage using bins that are already somewhat filled, but not too full.\n    # This can help consolidate items and leave more empty bins for later, larger items.\n    medium_filled_threshold_lower = 0.3\n    medium_filled_threshold_upper = 0.7\n    medium_filled_bonus = 0.08\n\n    medium_filled_bins = feasible_bins & \\\n                         (bins_remain_cap / bin_capacity < 1 - medium_filled_threshold_lower) & \\\n                         (bins_remain_cap / bin_capacity > 1 - medium_filled_threshold_upper)\n\n    priorities[medium_filled_bins] += medium_filled_bonus\n\n    return priorities",
    "response_id": 2,
    "obj": 3.2708416433984797,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response3.txt_stdout.txt",
    "code_path": "problem_iter10_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)\n\n    # 1. Feasibility: Infeasible bins get a very large negative priority.\n    feasible_bins = bins_remain_cap >= item\n    priorities[~feasible_bins] = -1e9\n\n    # 2. Best Fit: Prefer bins where the remaining capacity after placement is minimal\n    remaining_after_fit = bins_remain_cap - item\n    remaining_after_fit[~feasible_bins] = bin_capacity * 2  # Set to large value for infeasible bins\n    best_fit_priority = -remaining_after_fit / bin_capacity  # Normalize & invert: smaller remaining is better\n    priorities += best_fit_priority\n\n    # 3. Moderate Fill Avoidance (Before Placement): Penalize bins close to full or empty.\n    nearly_full_threshold = 0.85\n    nearly_empty_threshold = 0.15\n    moderate_fill_penalty = 0.25\n\n    nearly_full_bins = (bins_remain_cap / bin_capacity) > nearly_full_threshold\n    nearly_empty_bins = (bins_remain_cap / bin_capacity) < nearly_empty_threshold\n\n    priorities[feasible_bins & nearly_full_bins] -= moderate_fill_penalty\n    priorities[feasible_bins & nearly_empty_bins] -= moderate_fill_penalty\n\n    # 4. Fragmentation Penalty: Heavily penalize bins that will create a very small fragment.\n    fragment_threshold = 0.1\n    fragment_penalty = 0.7\n    fragment_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit / bin_capacity <= fragment_threshold)\n    priorities[fragment_mask] -= fragment_penalty\n\n    # 5. Reward Near-Perfect Fit: Significant bonus for near perfect fits\n    near_perfect_fit_threshold = 0.05\n    near_perfect_fit_bonus = 0.65\n    near_perfect_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit / bin_capacity <= near_perfect_fit_threshold)\n    priorities[near_perfect_mask] += near_perfect_fit_bonus\n\n    # 6. Small Item Penalty: Slightly discourage placing very small items into partially filled bins. Increased penalty. More empty = More penalty\n    small_item_threshold = 0.1\n    if item / bin_capacity < small_item_threshold:\n        small_item_penalty = 0.2 * (1 - bins_remain_cap / bin_capacity) # Normalize remaining cap, invert, scale by penalty\n        small_item_penalty[~feasible_bins] = 0\n        priorities -= small_item_penalty\n\n    # 7. Large Item Bonus: Encourage placing large items into emptier bins.\n    large_item_threshold = 0.7\n    if item / bin_capacity > large_item_threshold:\n        large_item_bonus = 0.2 * (bins_remain_cap / bin_capacity)\n        large_item_bonus[~feasible_bins] = 0\n        priorities += large_item_bonus\n\n    return priorities",
    "response_id": 3,
    "obj": 4.726765057838063,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response4.txt_stdout.txt",
    "code_path": "problem_iter10_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)\n\n    # 1. Feasibility: Infeasible bins get a very large negative priority.\n    feasible_bins = bins_remain_cap >= item\n    priorities[~feasible_bins] = -1e9\n\n    # 2. Best Fit: Prefer bins where the remaining capacity after placement is minimal\n    remaining_after_fit = bins_remain_cap - item\n    remaining_after_fit[~feasible_bins] = bin_capacity * 2  # Set to large value for infeasible bins\n    best_fit_priority = -remaining_after_fit / bin_capacity  # Normalize & invert: smaller remaining is better\n    priorities += best_fit_priority\n\n    # 3. Moderate Fill: Penalize bins that are nearly full or nearly empty *before* item placement.\n    nearly_full_threshold = 0.9\n    nearly_empty_threshold = 0.1\n    moderate_fill_penalty = 0.3\n\n    nearly_full_bins = (bins_remain_cap / bin_capacity) > nearly_full_threshold\n    nearly_empty_bins = (bins_remain_cap / bin_capacity) < nearly_empty_threshold\n\n    priorities[feasible_bins & nearly_full_bins] -= moderate_fill_penalty\n    priorities[feasible_bins & nearly_empty_bins] -= moderate_fill_penalty\n\n    # 4. Fragmentation Penalty: Heavily penalize bins that will create a very small fragment.\n    fragment_threshold = 0.15\n    fragment_penalty = 0.8\n    fragment_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit / bin_capacity <= fragment_threshold)\n    priorities[fragment_mask] -= fragment_penalty\n\n    # 5. Reward Near-Perfect Fit: Significant bonus for near perfect fits\n    near_perfect_fit_threshold = 0.05\n    near_perfect_fit_bonus = 0.7\n    near_perfect_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit / bin_capacity <= near_perfect_fit_threshold)\n    priorities[near_perfect_mask] += near_perfect_fit_bonus\n\n    # 6. Small Item Penalty: Slightly discourage placing very small items into partially filled bins.  Also, give a slight preference to placing small items in empty bins.\n    small_item_threshold = 0.1\n    small_item_penalty = 0.1\n    small_item = item / bin_capacity < small_item_threshold\n    if small_item:\n        partially_filled_bins = feasible_bins & (bins_remain_cap < bin_capacity) & (bins_remain_cap > 0)\n        empty_bins = bins_remain_cap == bin_capacity\n        priorities[partially_filled_bins] -= small_item_penalty\n        priorities[empty_bins] += small_item_penalty / 2  # Slight preference for empty bins\n\n    # 7. Bin balancing: Try to balance the fill levels of the bins\n    bin_fill_levels = (bin_capacity - bins_remain_cap) / bin_capacity\n    mean_fill_level = np.mean(bin_fill_levels)\n    bin_balancing_penalty = 0.05 * np.abs(bin_fill_levels - mean_fill_level)\n    priorities -= bin_balancing_penalty\n\n    return priorities",
    "response_id": 4,
    "obj": 2.6525727961707357,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response5.txt_stdout.txt",
    "code_path": "problem_iter10_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)\n\n    # 1. Feasibility: Infeasible bins get a very large negative priority.\n    feasible_bins = bins_remain_cap >= item\n    priorities[~feasible_bins] = -1e9\n\n    # 2. Best Fit: Prefer bins where the remaining capacity after placement is minimal\n    remaining_after_fit = bins_remain_cap - item\n    remaining_after_fit[~feasible_bins] = bin_capacity * 2  # Set to large value for infeasible bins\n    best_fit_priority = -remaining_after_fit / bin_capacity  # Normalize & invert: smaller remaining is better\n    priorities += best_fit_priority\n\n    # 3. Moderate Fill: Penalize bins that are nearly full or nearly empty *before* item placement.\n    nearly_full_threshold = 0.9\n    nearly_empty_threshold = 0.1\n    moderate_fill_penalty = 0.3\n\n    nearly_full_bins = (bins_remain_cap / bin_capacity) > nearly_full_threshold\n    nearly_empty_bins = (bins_remain_cap / bin_capacity) < nearly_empty_threshold\n\n    priorities[feasible_bins & nearly_full_bins] -= moderate_fill_penalty\n    priorities[feasible_bins & nearly_empty_bins] -= moderate_fill_penalty\n\n    # 4. Fragmentation Penalty: Heavily penalize bins that will create a very small fragment.\n    fragment_threshold = 0.15\n    fragment_penalty = 0.8\n    fragment_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit / bin_capacity <= fragment_threshold)\n    priorities[fragment_mask] -= fragment_penalty\n\n    # 5. Reward Near-Perfect Fit: Significant bonus for near perfect fits\n    near_perfect_fit_threshold = 0.05\n    near_perfect_fit_bonus = 0.7\n    near_perfect_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit / bin_capacity <= near_perfect_fit_threshold)\n    priorities[near_perfect_mask] += near_perfect_fit_bonus\n\n    # 6. Small Item Penalty: Slightly discourage placing very small items into partially filled bins.  Also, give a slight preference to placing small items in empty bins.\n    small_item_threshold = 0.1\n    small_item_penalty = 0.1\n    small_item = item / bin_capacity < small_item_threshold\n    if small_item:\n        partially_filled_bins = feasible_bins & (bins_remain_cap < bin_capacity) & (bins_remain_cap > 0)\n        empty_bins = bins_remain_cap == bin_capacity\n        priorities[partially_filled_bins] -= small_item_penalty\n        priorities[empty_bins] += small_item_penalty / 2  # Slight preference for empty bins\n\n    # 7. Bin balancing: Try to balance the fill levels of the bins\n    bin_fill_levels = (bin_capacity - bins_remain_cap) / bin_capacity\n    mean_fill_level = np.mean(bin_fill_levels)\n    bin_balancing_penalty = 0.05 * np.abs(bin_fill_levels - mean_fill_level)\n    priorities -= bin_balancing_penalty\n\n    return priorities",
    "response_id": 5,
    "obj": 2.6525727961707357,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response6.txt_stdout.txt",
    "code_path": "problem_iter10_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)\n\n    # 1. Feasibility: Infeasible bins get a very large negative priority.\n    feasible_bins = bins_remain_cap >= item\n    priorities[~feasible_bins] = -1e9\n\n    # 2. Best Fit: Prefer bins where the remaining capacity after placement is minimal\n    remaining_after_fit = bins_remain_cap - item\n    remaining_after_fit[~feasible_bins] = bin_capacity * 2  # Set to large value for infeasible bins\n    best_fit_priority = -remaining_after_fit / bin_capacity # Normalize & invert: smaller remaining is better\n    priorities += best_fit_priority\n\n    # 3. Moderate Fill: Penalize bins that are nearly full or nearly empty *before* item placement.\n    nearly_full_threshold = 0.9\n    nearly_empty_threshold = 0.1\n    moderate_fill_penalty = 0.3\n\n    nearly_full_bins = (bins_remain_cap / bin_capacity) > nearly_full_threshold\n    nearly_empty_bins = (bins_remain_cap / bin_capacity) < nearly_empty_threshold\n\n    priorities[feasible_bins & nearly_full_bins] -= moderate_fill_penalty\n    priorities[feasible_bins & nearly_empty_bins] -= moderate_fill_penalty\n\n    # 4. Fragmentation Penalty: Heavily penalize bins that will create a very small fragment.\n    fragment_threshold = 0.15\n    fragment_penalty = 0.8\n    fragment_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit / bin_capacity <= fragment_threshold)\n    priorities[fragment_mask] -= fragment_penalty\n\n    # 5. Reward Near-Perfect Fit: Significant bonus for near perfect fits\n    near_perfect_fit_threshold = 0.05\n    near_perfect_fit_bonus = 0.7\n    near_perfect_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit / bin_capacity <= near_perfect_fit_threshold)\n    priorities[near_perfect_mask] += near_perfect_fit_bonus\n\n    # 6. Small Item Penalty: Slightly discourage placing very small items into partially filled bins.  Also, give a slight preference to placing small items in empty bins.\n    small_item_threshold = 0.1\n    small_item_penalty = 0.1\n    small_item = item / bin_capacity < small_item_threshold\n    if small_item:\n      partially_filled_bins = feasible_bins & (bins_remain_cap < bin_capacity) & (bins_remain_cap > 0)\n      empty_bins = bins_remain_cap == bin_capacity\n      priorities[partially_filled_bins] -= small_item_penalty\n      priorities[empty_bins] += small_item_penalty/2 #Slight preference for empty bins\n\n    #7. Bin balancing: Try to balance the fill levels of the bins\n    bin_fill_levels = (bin_capacity - bins_remain_cap) / bin_capacity\n    mean_fill_level = np.mean(bin_fill_levels)\n    bin_balancing_penalty = 0.05 * np.abs(bin_fill_levels - mean_fill_level)\n    priorities -= bin_balancing_penalty\n\n\n    return priorities",
    "response_id": 6,
    "obj": 2.6525727961707357,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response7.txt_stdout.txt",
    "code_path": "problem_iter10_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)\n\n    # 1. Feasibility: Infeasible bins get a very large negative priority.\n    feasible_bins = bins_remain_cap >= item\n    priorities[~feasible_bins] = -1e9\n\n    # 2. Best Fit: Prefer bins where the remaining capacity after placement is minimal\n    remaining_after_fit = bins_remain_cap - item\n    remaining_after_fit[~feasible_bins] = bin_capacity * 2  # Set to large value for infeasible bins\n    best_fit_priority = -remaining_after_fit / bin_capacity  # Normalize & invert: smaller remaining is better\n    priorities += best_fit_priority\n\n    # 3. Moderate Fill: Penalize bins that are nearly full or nearly empty *before* item placement.\n    nearly_full_threshold = 0.9\n    nearly_empty_threshold = 0.1\n    moderate_fill_penalty = 0.3\n\n    nearly_full_bins = (bins_remain_cap / bin_capacity) > nearly_full_threshold\n    nearly_empty_bins = (bins_remain_cap / bin_capacity) < nearly_empty_threshold\n\n    priorities[feasible_bins & nearly_full_bins] -= moderate_fill_penalty\n    priorities[feasible_bins & nearly_empty_bins] -= moderate_fill_penalty\n\n    # 4. Fragmentation Penalty: Heavily penalize bins that will create a very small fragment.\n    fragment_threshold = 0.15\n    fragment_penalty = 0.8\n    fragment_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit / bin_capacity <= fragment_threshold)\n    priorities[fragment_mask] -= fragment_penalty\n\n    # 5. Reward Near-Perfect Fit: Significant bonus for near perfect fits\n    near_perfect_fit_threshold = 0.05\n    near_perfect_fit_bonus = 0.7\n    near_perfect_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit / bin_capacity <= near_perfect_fit_threshold)\n    priorities[near_perfect_mask] += near_perfect_fit_bonus\n\n    # 6. Small Item Penalty: Slightly discourage placing very small items into partially filled bins.  Also, give a slight preference to placing small items in empty bins.\n    small_item_threshold = 0.1\n    small_item_penalty = 0.1\n    small_item = item / bin_capacity < small_item_threshold\n    if small_item:\n        partially_filled_bins = feasible_bins & (bins_remain_cap < bin_capacity) & (bins_remain_cap > 0)\n        empty_bins = bins_remain_cap == bin_capacity\n        priorities[partially_filled_bins] -= small_item_penalty\n        priorities[empty_bins] += small_item_penalty / 2  # Slight preference for empty bins\n\n    # 7. Bin balancing: Try to balance the fill levels of the bins\n    bin_fill_levels = (bin_capacity - bins_remain_cap) / bin_capacity\n    mean_fill_level = np.mean(bin_fill_levels)\n    bin_balancing_penalty = 0.05 * np.abs(bin_fill_levels - mean_fill_level)\n    priorities -= bin_balancing_penalty\n\n    # Simplified rule: Slightly prefer bins with capacity closest to item size\n    priority_item_fit = -np.abs(bins_remain_cap - item) / bin_capacity\n    priorities += 0.02*priority_item_fit #Scale to keep it subtle\n\n    # 8. Avoid overfilling bins that are close to full, even if technically feasible now.\n    almost_full_threshold = 0.95\n    almost_full_penalty = 0.5\n    almost_full_bins = (bins_remain_cap / bin_capacity) > (almost_full_threshold - (item/bin_capacity)) #Check before placement\n    priorities[feasible_bins & almost_full_bins] -= almost_full_penalty\n\n    return priorities",
    "response_id": 7,
    "obj": 2.8021539688871298,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response8.txt_stdout.txt",
    "code_path": "problem_iter10_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)\n\n    # 1. Feasibility: Infeasible bins get a very large negative priority.\n    feasible_bins = bins_remain_cap >= item\n    priorities[~feasible_bins] = -1e9\n\n    # 2. Best Fit: Prefer bins where the remaining capacity after placement is minimal (normalized)\n    remaining_after_fit = bins_remain_cap - item\n    remaining_after_fit[~feasible_bins] = bin_capacity * 2  # Set to large value for infeasible bins\n    best_fit_priority = -remaining_after_fit / bin_capacity  # Normalize & invert: smaller remaining is better\n    priorities += best_fit_priority\n\n    # 3. Moderate Fill: Penalize bins that are nearly full or nearly empty *before* item placement.\n    nearly_full_threshold = 0.9\n    nearly_empty_threshold = 0.1\n    moderate_fill_penalty = 0.3\n\n    nearly_full_bins = (bins_remain_cap / bin_capacity) > nearly_full_threshold\n    nearly_empty_bins = (bins_remain_cap / bin_capacity) < nearly_empty_threshold\n\n    priorities[feasible_bins & nearly_full_bins] -= moderate_fill_penalty\n    priorities[feasible_bins & nearly_empty_bins] -= moderate_fill_penalty\n\n    # 4. Fragmentation Penalty: Heavily penalize bins that will create a very small fragment. (normalized)\n    fragment_threshold = 0.15\n    fragment_penalty = 0.8\n    fragment_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit / bin_capacity <= fragment_threshold)\n    priorities[fragment_mask] -= fragment_penalty\n\n    # 5. Reward Near-Perfect Fit: Significant bonus for near perfect fits (normalized)\n    near_perfect_fit_threshold = 0.05\n    near_perfect_fit_bonus = 0.7\n    near_perfect_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit / bin_capacity <= near_perfect_fit_threshold)\n    priorities[near_perfect_mask] += near_perfect_fit_bonus\n\n    # 6. Small Item Penalty: Slightly discourage placing very small items into partially filled bins. (normalized)\n    small_item_threshold = 0.1\n    small_item_penalty = 0.1\n    if item / bin_capacity < small_item_threshold:\n        partially_filled_bins = feasible_bins & (bins_remain_cap < bin_capacity)\n        priorities[partially_filled_bins] -= small_item_penalty\n\n    # 7. Large Item Bonus: Encourage placing large items into emptier bins. (normalized)\n    large_item_threshold = 0.7\n    large_item_bonus = 0.2\n    if item / bin_capacity > large_item_threshold:\n        relatively_empty_bins = feasible_bins & ((bins_remain_cap / bin_capacity) > 0.5)  # Bins more than half empty\n        priorities[relatively_empty_bins] += large_item_bonus\n        \n    # 8. Item Fragmentation Avoidance: Discourage splitting items across bins if a suitable bin exists.\n    #   Prioritize using existing bins over opening new ones.\n    new_bin_penalty = 0.05  # Slightly penalize using a completely empty bin\n    empty_bins = bins_remain_cap == bin_capacity\n    priorities[feasible_bins & empty_bins] -= new_bin_penalty\n    \n\n    return priorities",
    "response_id": 8,
    "obj": 2.8520143597925944,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response9.txt_stdout.txt",
    "code_path": "problem_iter10_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)\n\n    # 1. Feasibility: Infeasible bins get a very large negative priority.\n    feasible_bins = bins_remain_cap >= item\n    priorities[~feasible_bins] = -1e9\n\n    # 2. Best Fit: Prefer bins where the remaining capacity after placement is minimal\n    remaining_after_fit = bins_remain_cap - item\n    remaining_after_fit[~feasible_bins] = bin_capacity * 2  # Set to large value for infeasible bins\n    best_fit_priority = -remaining_after_fit / bin_capacity  # Normalize & invert: smaller remaining is better\n    priorities += best_fit_priority\n\n    # 3. Moderate Fill: Penalize bins that are nearly full or nearly empty *before* item placement.\n    nearly_full_threshold = 0.9\n    nearly_empty_threshold = 0.1\n    moderate_fill_penalty = 0.2  # Reduced penalty\n\n    nearly_full_bins = (bins_remain_cap / bin_capacity) > nearly_full_threshold\n    nearly_empty_bins = (bins_remain_cap / bin_capacity) < nearly_empty_threshold\n\n    priorities[feasible_bins & nearly_full_bins] -= moderate_fill_penalty\n    priorities[feasible_bins & nearly_empty_bins] -= moderate_fill_penalty\n\n    # 4. Fragmentation Penalty: Heavily penalize bins that will create a very small fragment.\n    fragment_threshold = 0.15\n    fragment_penalty = 0.7  # Reduced penalty\n    fragment_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit / bin_capacity <= fragment_threshold)\n    priorities[fragment_mask] -= fragment_penalty\n\n    # 5. Reward Near-Perfect Fit: Significant bonus for near perfect fits\n    near_perfect_fit_threshold = 0.05\n    near_perfect_fit_bonus = 0.6 # Reduced bonus\n    near_perfect_mask = feasible_bins & (remaining_after_fit > 0) & (remaining_after_fit / bin_capacity <= near_perfect_fit_threshold)\n    priorities[near_perfect_mask] += near_perfect_fit_bonus\n\n    # 6. Small Item Handling: Adjust penalty/reward for small items based on fill level.\n    small_item_threshold = 0.1\n    small_item_penalty = 0.08 # Reduced penalty\n    small_item_bonus = 0.04 # Reduced bonus\n    small_item = item / bin_capacity < small_item_threshold\n\n    if small_item:\n        partially_filled_bins = feasible_bins & (bins_remain_cap < bin_capacity) & (bins_remain_cap > 0)\n        empty_bins = bins_remain_cap == bin_capacity\n        priorities[partially_filled_bins] -= small_item_penalty\n        priorities[empty_bins] += small_item_bonus  # Reduced bonus for empty bins\n\n    # 7. Bin balancing: Try to balance the fill levels of the bins. Increased balancing influence.\n    bin_fill_levels = (bin_capacity - bins_remain_cap) / bin_capacity\n    mean_fill_level = np.mean(bin_fill_levels)\n    bin_balancing_penalty = 0.07 * np.abs(bin_fill_levels - mean_fill_level) # Increased factor\n    priorities -= bin_balancing_penalty\n\n    # 8. Item fit preference. Increase influence\n    priority_item_fit = -np.abs(bins_remain_cap - item) / bin_capacity\n    priorities += 0.03 * priority_item_fit  # Increased scale\n\n    # 9. Empty bin usage. Encourage the use of empty bins early on.\n    is_empty = bins_remain_cap == bin_capacity\n    priorities[feasible_bins & is_empty] += 0.05 # A slight initial preference for empty bins\n\n    return priorities",
    "response_id": 9,
    "obj": 2.572796170721974,
    "exec_success": true
  }
]