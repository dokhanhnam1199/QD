```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic function for the Traveling Salesman Problem (TSP).

    This function calculates a heuristic matrix indicating the desirability of including each edge
    in the TSP tour. It combines several factors:

    1. Inverse Distance: Shorter edges are preferred.
    2. Nearest Neighbor Density: Edges connected to nodes with fewer nearby neighbors are preferred.
       This encourages exploring nodes in sparse regions of the graph.
    3. Global Distance Normalization: Edges are normalized by the average distance to make the heuristics
       less sensitive to the overall scale of distances.

    The heuristic matrix is sparsified by setting values below a threshold to zero, focusing the search
    on the most promising edges.

    Args:
        distance_matrix (np.ndarray): A square matrix where distance_matrix[i][j] is the distance
                                       between node i and node j.

    Returns:
        np.ndarray: A heuristic matrix of the same shape as the distance_matrix, indicating the
                    desirability of including each edge in the TSP tour. Higher values indicate
                    more promising edges.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # Calculate inverse distances
    inverse_distance = 1 / (distance_matrix + 1e-9)  # Add a small constant to avoid division by zero

    # Calculate nearest neighbor density
    neighbor_density = np.zeros((n, n), dtype=float)
    for i in range(n):
        distances = distance_matrix[i, :]
        sorted_indices = np.argsort(distances)
        nearest_neighbors = sorted_indices[1: min(4, n)]  # Exclude self, take at most 3 neighbors
        for j in range(n):
            if j in nearest_neighbors:
                neighbor_density[i, j] = 1

    # Combine factors
    heuristic_matrix = inverse_distance + neighbor_density

    # Normalize by global average distance
    average_distance = np.mean(distance_matrix)
    heuristic_matrix = heuristic_matrix / (average_distance + 1e-9)

    #Sparsify Matrix
    threshold = np.percentile(heuristic_matrix[heuristic_matrix > 0], 40) # Keep top 60% edges

    heuristic_matrix[heuristic_matrix < threshold] = 0

    return heuristic_matrix
```
