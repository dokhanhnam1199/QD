```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic function for TSP using stochastic solution sampling principles.
    Combines distance, node degree potential, and sparsification for better guidance.

    Args:
        distance_matrix (np.ndarray): Distance matrix representing TSP instance.

    Returns:
        np.ndarray: Heuristic matrix indicating the promise of each edge.
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # Inverse distance as a base heuristic
    inverse_distance = 1 / (distance_matrix + 1e-9)  # Adding a small value to avoid division by zero

    # Node degree potential: Encouraging connections to nodes with fewer connections so far
    degree_potential = np.ones_like(distance_matrix, dtype=float)

    # Combine distance and degree potential
    heuristic_matrix = inverse_distance * degree_potential

    # Sparsification: Zero out edges that are likely bad based on a simple criteria
    #   - Edges longer than the average distance are penalized.
    avg_distance = np.mean(distance_matrix[distance_matrix != 0])  # Avoid include 0's in the mean, if any
    sparsification_threshold = 1.5 * avg_distance # Increase the threshold dynamically for adaptive sparsification
    heuristic_matrix[distance_matrix > sparsification_threshold] = 0
  
    # Further penalize connections to nodes if both nodes are far away
    for i in range(n):
        for j in range(n):
            if i != j:
                avg_distance_to_node_i = np.mean(distance_matrix[i, :][distance_matrix[i, :] > 0])
                avg_distance_to_node_j = np.mean(distance_matrix[j, :][distance_matrix[j, :] > 0])
                if distance_matrix[i, j] > 0.8 * (avg_distance_to_node_i + avg_distance_to_node_j) / 2:
                    heuristic_matrix[i, j] = 0
    
    # Enhance edges that are relatively shorter among all edges from its two vertices
    for i in range(n):
        for j in range(n):
            if i != j and heuristic_matrix[i, j] > 0:
                min_dist_i = np.min(distance_matrix[i, :][distance_matrix[i, :] > 0])
                min_dist_j = np.min(distance_matrix[j, :][distance_matrix[j, :] > 0])
                if distance_matrix[i, j] < (min_dist_i + min_dist_j) / 2:
                    heuristic_matrix[i, j] *= 1.2 # Increase heuristic by 20%
    
    return heuristic_matrix
```
