```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic function for TSP using a combination of factors and sparsification.

    Args:
        distance_matrix: A numpy array representing the distance matrix.

    Returns:
        A numpy array representing the heuristic values for each edge.
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # 1. Inverse Distance: Shorter distances are more promising.
    inverse_distance = 1 / (distance_matrix + 1e-9)  # Adding a small value to avoid division by zero.

    # 2. Node Degree Penalty: Penalize high-degree nodes (more connected)
    # to encourage a more even distribution of edges in the solution.
    degree = np.sum(inverse_distance, axis=0)
    degree_penalty = np.outer(degree, degree)  # Outer product to create a matrix
    degree_penalty = degree_penalty / np.max(degree_penalty) #Normalize to [0, 1]

    # 3. Average Distance to Neighbors: Edges connecting nodes with shorter
    # average distances to their neighbors are more likely to be in a good tour.
    avg_neighbor_distance = np.zeros(n)
    for i in range(n):
        neighbors = np.where(distance_matrix[i, :] > 0)[0]
        avg_neighbor_distance[i] = np.mean(distance_matrix[i, neighbors]) if len(neighbors) > 0 else 0

    neighbor_distance_score = np.outer(avg_neighbor_distance, avg_neighbor_distance)
    neighbor_distance_score = 1/(neighbor_distance_score + 1e-9) # Prefer small average distances.
    neighbor_distance_score = neighbor_distance_score/np.max(neighbor_distance_score)
    
    # Combine the factors:  Inverse distance is most important
    heuristic_matrix = inverse_distance * (0.7 + 0.3 * neighbor_distance_score) / (1 + 0.5*degree_penalty)

    # Sparsification: Keep only the top k edges for each node to reduce search space
    k = int(np.ceil(n * 0.3))  # Keep top 30% edges. Adjust as needed.

    for i in range(n):
        row = heuristic_matrix[i, :]
        indices = np.argsort(row)[-k:]  # Indices of top k values
        mask = np.ones(n, dtype=bool)
        mask[indices] = False
        heuristic_matrix[i, mask] = 0
        
    #Ensure symmetry if initial distance matrix is symmetric (e.g. Euclidean)
    heuristic_matrix = (heuristic_matrix + heuristic_matrix.T) / 2

    return heuristic_matrix
```
