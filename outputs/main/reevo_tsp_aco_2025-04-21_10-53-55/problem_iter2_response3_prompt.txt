{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a heuristics function for Solving Traveling Salesman Problem (TSP) via stochastic solution sampling following \"heuristics\". TSP requires finding the shortest path that visits all given nodes and returns to the starting node.\nThe `heuristics` function takes as input a distance matrix, and returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the input.\n\n\n[Worse code]\ndef heuristics_v0(distance_matrix: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Heuristic function for the Traveling Salesman Problem (TSP).\n    Employs a combination of factors and sparsification to guide\n    stochastic solution sampling.\n\n    Args:\n        distance_matrix (np.ndarray): A 2D numpy array representing the\n            distance matrix between nodes.\n\n    Returns:\n        np.ndarray: A 2D numpy array of the same shape as distance_matrix,\n            containing prior indicators of how promising it is to include\n            each edge in a solution.\n    \"\"\"\n\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    # Calculate node-level information (nearest neighbor, average distance)\n    nearest_neighbors = np.argsort(distance_matrix, axis=1)[:, 1:4]  # Indices of 3 nearest neighbors for each node\n    avg_distances = np.mean(distance_matrix, axis=1, keepdims=True)\n\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                # Factor 1: Inverse distance (favors shorter edges)\n                inverse_distance = 1 / distance_matrix[i, j]\n\n                # Factor 2: Nearest neighbor bonus (edges connecting to nearby nodes are favored)\n                nearest_neighbor_bonus = 0.0\n                if j in nearest_neighbors[i]:\n                    nearest_neighbor_bonus = 0.5 # Adjust weight as needed\n\n                # Factor 3: Avoid connections to far-away nodes relative to average distance\n                avg_distance_penalty = max(0.0, 1 - (avg_distances[i] / distance_matrix[i, j]))\n\n                # Factor 4:  Sparsity inducing factor. We penalize connecting to node\n                #           which is connected to all other nodes. This prevents hub nodes\n                connectedness = np.sum(distance_matrix[j,:] > 0)/(n-1)\n                sparsify_penalty = 1 - connectedness # 0 if it is connected to everyone\n                # Combine factors\n                heuristic_matrix[i, j] = inverse_distance + nearest_neighbor_bonus + avg_distance_penalty + sparsify_penalty\n            else:\n                heuristic_matrix[i, j] = 0  # No self-loops\n\n    # Sparsify the matrix: set low-probability edges to zero\n    threshold = np.percentile(heuristic_matrix[heuristic_matrix > 0], 20) # Dynamic Threshold\n    heuristic_matrix[heuristic_matrix < threshold] = 0\n\n    return heuristic_matrix\n\n[Better code]\ndef heuristics_v1(distance_matrix: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Heuristic function for the Traveling Salesman Problem (TSP) based on stochastic\n    solution sampling principles. It combines multiple factors to estimate the\n    promise of including an edge in the optimal TSP tour.\n\n    Args:\n        distance_matrix (np.ndarray): A square matrix representing the distances\n            between cities. distance_matrix[i][j] gives the distance from city i to city j.\n\n    Returns:\n        np.ndarray: A matrix of the same shape as the input, where each element\n            indicates the \"promise\" of including the corresponding edge in a solution.\n            Higher values indicate a more promising edge.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    # Heuristic 1: Inverse distance (already implemented in v1, but kept here for clarity)\n    heuristic_matrix = 1 / (distance_matrix + 1e-9)  # Add a small constant to avoid division by zero\n\n    # Heuristic 2: Nearest neighbor heuristic\n    nearest_neighbors = np.argsort(distance_matrix, axis=1)[:, 1:4] # Find 3 nearest neighbors\n    for i in range(n):\n        for j in nearest_neighbors[i]:\n            heuristic_matrix[i, j] += 0.5 # Boost edges to nearest neighbors\n            heuristic_matrix[j, i] += 0.5 # Make it symmetric\n    \n    # Heuristic 3: Minimum spanning tree approximation\n    # Idea: Edges likely in a good tour are also likely in the MST\n    mst_weights = distance_matrix.copy()\n    mst_weights[mst_weights == 0] = np.inf # avoid self loops and 0 distances\n    np.fill_diagonal(mst_weights, np.inf)  # avoid self loops\n    \n    edges = []\n    for i in range(n):\n        for j in range(i + 1, n):\n             edges.append((mst_weights[i, j], i, j)) # edge value, source, target\n    \n    edges.sort() # increasing value\n    \n    parent = list(range(n))\n    \n    def find(i):\n        if parent[i] == i:\n            return i\n        parent[i] = find(parent[i])\n        return parent[i]\n    \n    def union(i, j):\n        root_i = find(i)\n        root_j = find(j)\n        if root_i != root_j:\n            parent[root_i] = root_j\n            return True # indicate that a union occurred\n\n    mst_edge_count = 0\n    for weight, u, v in edges:\n      if union(u, v):\n        heuristic_matrix[u,v] += 0.3 # Give bonus for edges in the MST approximation.\n        heuristic_matrix[v,u] += 0.3\n        mst_edge_count += 1\n      if mst_edge_count == n-1:\n        break\n            \n\n    # Sparsification: Zero out less promising edges\n    threshold = np.quantile(heuristic_matrix[heuristic_matrix > 0], 0.25) # keep top 75% edges\n    heuristic_matrix[heuristic_matrix < threshold] = 0\n\n    # Ensure symmetry in the heuristic matrix\n    heuristic_matrix = (heuristic_matrix + heuristic_matrix.T) / 2\n\n    return heuristic_matrix\n\n[Reflection]\nPrioritize inverse distance, nearest neighbors, MST approximation, and enforce symmetry. Avoid unnecessary penalties.\n\n\n[Improved code]\nPlease write an improved function `heuristics_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}