```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic function for TSP using a combination of factors and sparsification.

    Args:
        distance_matrix (np.ndarray): A square matrix where distance_matrix[i, j]
            represents the distance between node i and node j.

    Returns:
        np.ndarray: A matrix of the same shape as distance_matrix, representing
            the "promise" of each edge. Higher values indicate a more promising edge.
    """
    n = distance_matrix.shape[0]
    promise_matrix = np.zeros((n, n))

    # 1. Inverse Distance: Shorter edges are generally more promising.
    inverse_distance = 1 / (distance_matrix + 1e-9)  # Adding a small constant to avoid division by zero

    # 2. Node Degree Preference:  Prefer nodes with low degree early on. We estimate degree by simply
    # inverting the sum of inverse distances from the point
    node_degree_preference = np.zeros((n, n))
    for i in range(n):
        node_degree = np.sum(inverse_distance[i,:]) + np.sum(inverse_distance[:,i]) - inverse_distance[i,i] #avoid double count
        node_degree_preference[i, :] = 1 / (node_degree + 1e-9)


    # 3. Combination: Combine the factors, weighting them appropriately.
    promise_matrix = 0.7 * inverse_distance + 0.3 * node_degree_preference

    # 4. Sparsification: Set unpromising edges to zero to encourage exploration
    # and potentially reduce search space. The threshold is adaptively determined.
    threshold = np.mean(promise_matrix[promise_matrix > 0]) * 0.25  #Dynamic threshold, consider only positive values to calculate mean
    promise_matrix[promise_matrix < threshold] = 0

    # Ensure that diagonal elements are zero (no self-loops).
    np.fill_diagonal(promise_matrix, 0)


    return promise_matrix
```
