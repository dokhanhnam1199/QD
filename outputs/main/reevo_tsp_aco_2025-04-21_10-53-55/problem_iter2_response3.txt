```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic function for the Traveling Salesman Problem (TSP) based on stochastic
    solution sampling principles. It combines inverse distance, nearest neighbors,
    and MST approximation to estimate the promise of including an edge in the
    optimal TSP tour. Enforces symmetry.

    Args:
        distance_matrix (np.ndarray): A square matrix representing the distances
            between cities. distance_matrix[i][j] gives the distance from city i to city j.

    Returns:
        np.ndarray: A matrix of the same shape as the input, where each element
            indicates the "promise" of including the corresponding edge in a solution.
            Higher values indicate a more promising edge.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # Heuristic 1: Inverse distance
    heuristic_matrix = 1 / (distance_matrix + 1e-9)  # Add a small constant to avoid division by zero

    # Heuristic 2: Nearest neighbor heuristic
    nearest_neighbors = np.argsort(distance_matrix, axis=1)[:, 1:4]  # Find 3 nearest neighbors
    for i in range(n):
        for j in nearest_neighbors[i]:
            heuristic_matrix[i, j] += 0.5  # Boost edges to nearest neighbors

    # Heuristic 3: Minimum spanning tree approximation
    mst_weights = distance_matrix.copy()
    mst_weights[mst_weights == 0] = np.inf  # avoid self loops and 0 distances
    np.fill_diagonal(mst_weights, np.inf)  # avoid self loops

    edges = []
    for i in range(n):
        for j in range(i + 1, n):
            edges.append((mst_weights[i, j], i, j))  # edge value, source, target

    edges.sort()  # increasing value

    parent = list(range(n))

    def find(i):
        if parent[i] == i:
            return i
        parent[i] = find(parent[i])
        return parent[i]

    def union(i, j):
        root_i = find(i)
        root_j = find(j)
        if root_i != root_j:
            parent[root_i] = root_j
            return True  # indicate that a union occurred

    mst_edge_count = 0
    for weight, u, v in edges:
        if union(u, v):
            heuristic_matrix[u, v] += 0.3  # Give bonus for edges in the MST approximation.
            mst_edge_count += 1
        if mst_edge_count == n - 1:
            break

    # Sparsification: Zero out less promising edges
    threshold = np.quantile(heuristic_matrix[heuristic_matrix > 0], 0.25)  # keep top 75% edges
    heuristic_matrix[heuristic_matrix < threshold] = 0

    # Ensure symmetry in the heuristic matrix
    heuristic_matrix = (heuristic_matrix + heuristic_matrix.T) / 2

    return heuristic_matrix
```
