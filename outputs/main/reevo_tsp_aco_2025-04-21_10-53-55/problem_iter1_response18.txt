```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic function for the Traveling Salesman Problem (TSP).

    This version combines several factors to estimate the likelihood of an edge being in the optimal tour.
    It also sparsifies the matrix by setting unpromising edges to zero.

    Args:
        distance_matrix (np.ndarray): A square matrix where element (i, j) represents
                                       the distance between node i and node j.

    Returns:
        np.ndarray: A matrix of the same shape as distance_matrix, where each element
                    represents a prior indicator of how promising it is to include
                    the corresponding edge in a solution.  Higher values indicate
                    more promising edges.
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # 1. Inverse Distance: Shorter edges are generally better.
    inverse_distance = 1 / (distance_matrix + 1e-6)  # Add a small value to avoid division by zero

    # 2. Node Degree Centrality: Penalize high-degree nodes (encourage even distribution of edges).
    #    Idea: A node that's very close to many other nodes will likely have several less optimal paths going through it.
    node_degree = np.sum(inverse_distance, axis=0) #Sum of attractiveness to each other node
    degree_factor = np.outer(node_degree, node_degree) #outer product gives nxn.
    degree_factor = 1 / (degree_factor + 1e-6)

    # 3.  Nearest Neighbor Influence:  Favor edges that connect each node to its nearest neighbors.
    nearest_neighbors = np.zeros((n, n))
    for i in range(n):
      sorted_indices = np.argsort(distance_matrix[i, :])
      # Consider only the 'k' nearest neighbors to node i. Experiment with k.
      k = min(5, n-1) #Consider 5 nearest neighbors or all, whichever is smaller
      for j in sorted_indices[1:k+1]: #Skip the node itself (index 0)
          nearest_neighbors[i, j] = 1
          nearest_neighbors[j, i] = 1 #symmetric matrix

    #4. Combination and Sparsification
    heuristic_matrix = inverse_distance * degree_factor * (nearest_neighbors + 0.1) #Adding a small value encourages exploration even if not a NN
    heuristic_matrix = heuristic_matrix * (1 - np.eye(n)) # Remove self-loops

    # Sparsify: Set values below a threshold to zero
    threshold = np.quantile(heuristic_matrix[heuristic_matrix > 0], 0.2) #keep the top 80% non zero numbers, sparsifying the matrix.
    heuristic_matrix[heuristic_matrix < threshold] = 0
    return heuristic_matrix
```
