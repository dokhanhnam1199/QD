{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a heuristics function for Solving Traveling Salesman Problem (TSP) via stochastic solution sampling following \"heuristics\". TSP requires finding the shortest path that visits all given nodes and returns to the starting node.\nThe `heuristics` function takes as input a distance matrix, and returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the input.\n\n\n[Worse code]\ndef heuristics_v0(distance_matrix: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Heuristic function for the Traveling Salesman Problem (TSP) using stochastic solution sampling.\n\n    This version combines several factors to estimate the desirability of including each edge in a solution.\n    It also sparsifies the matrix by setting unpromising elements to zero.\n\n    Args:\n        distance_matrix (np.ndarray): A square matrix representing the distances between cities.\n                                         distance_matrix[i][j] is the distance from city i to city j.\n\n    Returns:\n        np.ndarray: A matrix of the same shape as distance_matrix, containing heuristic values\n                     indicating the desirability of including each edge in a TSP solution.\n                     Higher values indicate more promising edges.\n    \"\"\"\n\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    # 1. Inverse distance: Shorter distances are generally more desirable.\n    inverse_distance = 1.0 / (distance_matrix + 1e-9)  # Add a small constant to avoid division by zero\n\n    # 2. Nearest neighbor heuristic: Edges connecting a city to its nearest neighbors are often good.\n    nearest_neighbors = np.argsort(distance_matrix, axis=1)\n    nearest_neighbor_mask = np.zeros_like(distance_matrix, dtype=bool)\n    for i in range(n):\n        # Consider the k nearest neighbors (excluding itself).  k can be tuned.\n        k = min(5, n - 1)  # Consider at most 5 nearest neighbors or n-1 if n < 6\n        nearest_neighbor_mask[i, nearest_neighbors[i, 1:k + 1]] = True  # index 0 is self\n\n    # 3. Sparsification: Remove edges that are too long or unlikely to be in a good solution.\n    #    - Calculate a distance threshold (e.g., based on the average distance).\n    average_distance = np.mean(distance_matrix)\n    distance_threshold = 2 * average_distance # Tune the scaling factor as needed.\n\n    #    - Set heuristic values to 0 for edges exceeding the threshold.\n    sparsification_mask = distance_matrix <= distance_threshold\n\n\n    # 4. Combine heuristics:  Combine the factors to get a final heuristic score.\n    heuristic_matrix = inverse_distance * nearest_neighbor_mask * sparsification_mask\n    # Alternative Combination: Weigh nearest neighbors higher, remove longer edges\n    # heuristic_matrix = (inverse_distance + 2.0*nearest_neighbor_mask) * sparsification_mask\n\n    # Optional: Normalize the heuristic matrix (not strictly necessary, but can improve exploration).\n    # If all elements are 0, then just return heuristic_matrix as is\n    if np.any(heuristic_matrix):\n        heuristic_matrix = heuristic_matrix / np.max(heuristic_matrix)\n\n\n    return heuristic_matrix\n\n[Better code]\ndef heuristics_v1(distance_matrix: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Heuristic function for the Traveling Salesman Problem (TSP) using a combination of factors\n    and stochastic solution sampling principles.\n\n    Args:\n        distance_matrix (np.ndarray): A 2D numpy array representing the distance matrix\n                                       where distance_matrix[i][j] is the distance between node i and node j.\n\n    Returns:\n        np.ndarray: A 2D numpy array of the same shape as distance_matrix,\n                    representing the prior indicators of how promising it is to include each edge in a solution.\n                    Higher values indicate more promising edges.\n    \"\"\"\n\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    # Heuristic 1: Inverse distance (as in v1, but we might modify it)\n    inverse_distance = 1 / (distance_matrix + 1e-9)  # Adding a small constant to avoid division by zero\n\n    # Heuristic 2: Savings heuristic (related to minimum spanning tree concept, favoring shorter edges)\n    savings = np.zeros_like(distance_matrix, dtype=float)\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                min_dist_i = np.min(distance_matrix[i, :][distance_matrix[i, :] > 0]) # min dist to i\n                min_dist_j = np.min(distance_matrix[j, :][distance_matrix[j, :] > 0]) # min dist to j\n                savings[i, j] = min_dist_i + min_dist_j - distance_matrix[i, j]\n\n    # Heuristic 3: Node degree desirability. Favor edges that connect to nodes with low degree.\n    #   The rationale is, the higher the degree of a node, the less incentive to visit/leave this node later\n    degree_heuristic = np.zeros_like(distance_matrix, dtype=float)\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n               degree_heuristic[i,j] = 1.0 # initialize to 1.\n\n    # Combine the heuristics (weighted sum)\n    heuristic_matrix = 0.6 * inverse_distance + 0.3 * savings + 0.1 * degree_heuristic\n\n    # Sparsify the matrix:  Keep only a fraction of the most promising edges for each node\n    sparsity_factor = 0.3 # hyperparameter\n    for i in range(n):\n        row = heuristic_matrix[i, :]\n        threshold = np.quantile(row, 1 - sparsity_factor)\n        heuristic_matrix[i, row < threshold] = 0\n\n    return heuristic_matrix\n\n[Reflection]\nSavings heuristic, node degree desirability, and weighted combinations improved the solution. Sparsification via quantile helps too.\n\n\n[Improved code]\nPlease write an improved function `heuristics_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}