```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic function for TSP using a combination of factors and sparsification.

    Args:
        distance_matrix (np.ndarray): A distance matrix representing the distances between cities.

    Returns:
        np.ndarray: A heuristic matrix indicating the desirability of including each edge in a tour.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # 1. Inverse distance: Shorter edges are generally better.
    inverse_distance = 1 / (distance_matrix + 1e-9)  # Adding a small value to avoid division by zero.

    # 2. Node degree desirability: Penalize connecting to nodes that already have many close neighbors. This encourages exploration.
    node_degree_desirability = np.zeros_like(distance_matrix, dtype=float)
    for i in range(n):
        distances_to_i = distance_matrix[i, :]
        sorted_indices = np.argsort(distances_to_i)
        closest_neighbors = sorted_indices[1:min(4, n)]  # Consider top 3 closest neighbors (excluding itself)
        for j in range(n):
            if i != j:
                neighbor_count = 0
                for neighbor in closest_neighbors:
                    if j != i and np.any(np.argsort(distance_matrix[j, :])[1:min(4, n)] == i):
                        neighbor_count += 1
                node_degree_desirability[i, j] = 1 / (neighbor_count + 1)  # avoid div by zero.

    # 3. Global Average Distance: Favor edges shorter than average distance
    avg_dist = np.mean(distance_matrix[distance_matrix > 0])

    # Combine the factors:
    heuristic_matrix = inverse_distance * node_degree_desirability

    # Adjust based on average distance
    heuristic_matrix[distance_matrix > avg_dist] *= 0.2  # heavily penalize long edges

    # 4. Sparsification: Keep only the top K promising edges for each node to reduce complexity
    K = min(5, n - 1)  # Keep at most 5 edges per node
    for i in range(n):
        row = heuristic_matrix[i, :]
        indices = np.argsort(row)[::-1]  # Sort in descending order of heuristic value
        keep_indices = indices[:K]

        # Zero out all but the top K edges:
        zero_indices = np.setdiff1d(np.arange(n), keep_indices)
        heuristic_matrix[i, zero_indices] = 0
        heuristic_matrix[i, i] = 0  # zero out self loop

    heuristic_matrix = np.maximum(heuristic_matrix, heuristic_matrix.T)

    return heuristic_matrix
```
