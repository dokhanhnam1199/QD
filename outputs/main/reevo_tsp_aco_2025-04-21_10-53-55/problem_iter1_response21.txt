```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic function for the Traveling Salesman Problem (TSP) using stochastic solution sampling.

    This version combines several factors to estimate the desirability of including each edge in a solution.
    It also sparsifies the matrix by setting unpromising elements to zero.

    Args:
        distance_matrix (np.ndarray): A square matrix representing the distances between cities.
                                         distance_matrix[i][j] is the distance from city i to city j.

    Returns:
        np.ndarray: A matrix of the same shape as distance_matrix, containing heuristic values
                     indicating the desirability of including each edge in a TSP solution.
                     Higher values indicate more promising edges.
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # 1. Inverse distance: Shorter distances are generally more desirable.
    inverse_distance = 1.0 / (distance_matrix + 1e-9)  # Add a small constant to avoid division by zero

    # 2. Nearest neighbor heuristic: Edges connecting a city to its nearest neighbors are often good.
    nearest_neighbors = np.argsort(distance_matrix, axis=1)
    nearest_neighbor_mask = np.zeros_like(distance_matrix, dtype=bool)
    for i in range(n):
        # Consider the k nearest neighbors (excluding itself).  k can be tuned.
        k = min(5, n - 1)  # Consider at most 5 nearest neighbors or n-1 if n < 6
        nearest_neighbor_mask[i, nearest_neighbors[i, 1:k + 1]] = True  # index 0 is self

    # 3. Sparsification: Remove edges that are too long or unlikely to be in a good solution.
    #    - Calculate a distance threshold (e.g., based on the average distance).
    average_distance = np.mean(distance_matrix)
    distance_threshold = 2 * average_distance # Tune the scaling factor as needed.

    #    - Set heuristic values to 0 for edges exceeding the threshold.
    sparsification_mask = distance_matrix <= distance_threshold


    # 4. Combine heuristics:  Combine the factors to get a final heuristic score.
    heuristic_matrix = inverse_distance * nearest_neighbor_mask * sparsification_mask
    # Alternative Combination: Weigh nearest neighbors higher, remove longer edges
    # heuristic_matrix = (inverse_distance + 2.0*nearest_neighbor_mask) * sparsification_mask

    # Optional: Normalize the heuristic matrix (not strictly necessary, but can improve exploration).
    # If all elements are 0, then just return heuristic_matrix as is
    if np.any(heuristic_matrix):
        heuristic_matrix = heuristic_matrix / np.max(heuristic_matrix)


    return heuristic_matrix
```
