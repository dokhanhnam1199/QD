```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristics for the Traveling Salesman Problem (TSP) using a combination of factors.

    This version considers:
        1. Inverse distance: Shorter distances are generally more promising.
        2. Node degree: Penalizes edges connected to nodes with too many near neighbors (encourages more evenly distributed path).
        3. Sparsity: Sets values below a dynamic threshold (based on distances) to zero to encourage focusing on potentially good edges.
    Args:
        distance_matrix (np.ndarray): A 2D numpy array representing the distance matrix between cities.

    Returns:
        np.ndarray: A 2D numpy array of the same shape as distance_matrix,
                    representing the heuristic values for each edge.
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # 1. Inverse distance (base heuristic)
    heuristic_matrix = 1 / (distance_matrix + 1e-9)  # Adding a small constant to avoid division by zero

    # 2. Node degree penalty
    for i in range(n):
        # Find indices of the closest neighbors for each node. We consider all other nodes.
        neighbor_indices = np.argsort(distance_matrix[i, :])
        
        # Penalize edges connected to nodes that are already very well connected to other nearby nodes.
        # For example, if the ith node is close to many other nodes, reduce the edge weight to them to avoid getting trapped in one area.
        degree_penalty = 0.0
        num_close_neighbors = min(5, n - 1)  # Limit to at most 5 neighbors. Tune as needed.

        #neighbor_distances = distance_matrix[i, neighbor_indices[1:num_close_neighbors+1]]
        degree_penalty = 0 #1.0 / (np.sum(distance_matrix[i, neighbor_indices[1:num_close_neighbors+1]])+ 1e-9) if num_close_neighbors > 0 else 0.0  # Penalize by inverse of sum of closest neighbors.
        
        for j in range(n):
            #Penalize nodes nearby ith node
            if i!= j and j in neighbor_indices[1:num_close_neighbors+1]:

                heuristic_matrix[i, j] -= degree_penalty
    #3. Sparsify (set low values to zero to encourage a focused search).
    threshold = np.mean(distance_matrix)  # Dynamic threshold based on average distance. Can also try other stats.

    heuristic_matrix[distance_matrix > threshold] = 0
    heuristic_matrix[np.isinf(heuristic_matrix)] = 0 #Remove infinite entries (happens when distance == 0)

    # Make matrix symmetrical (sometimes useful)
    heuristic_matrix = (heuristic_matrix + heuristic_matrix.T) / 2.0

    return heuristic_matrix
```
