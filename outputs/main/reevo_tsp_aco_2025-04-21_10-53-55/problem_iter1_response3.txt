```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristics function for solving Traveling Salesman Problem (TSP) via stochastic solution sampling.

    This version combines several factors to determine how promising it is to select an edge.
    It also sparsifies the matrix by setting unpromising elements to zero.

    Args:
        distance_matrix (np.ndarray): A distance matrix representing the distances between nodes.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution.
                    The return is of the same shape as the input.
    """

    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

    # Calculate average distance from each node
    avg_distances = np.mean(distance_matrix, axis=1, keepdims=True)

    # Calculate inverse distance
    inverse_distance = 1 / (distance_matrix + 1e-9)  # Adding a small constant to avoid division by zero

    # Combine factors: inverse distance, node importance, and local density
    for i in range(n):
        for j in range(n):
            if i != j:
                # Heuristic considers:
                # 1. Shorter distances are preferred (inverse_distance)
                # 2. Nodes with smaller average distances to other nodes are more central and important (scaled inverse of avg_distances)
                # 3. Combination effect
                heuristics_matrix[i, j] = inverse_distance[i, j] / (avg_distances[i] * avg_distances[j]) # Scale by product of avg distance
                #heuristics_matrix[i, j] = inverse_distance[i, j] - (avg_distances[i] + avg_distances[j]) # Scale by sum of avg distance


    # Sparsify the matrix: keep only top k edges for each node
    k = int(np.sqrt(n))  # Adjust k as needed; using sqrt(n)
    for i in range(n):
        row = heuristics_matrix[i, :].copy()  # Work on a copy to avoid modifying while iterating
        indices_to_keep = np.argsort(row)[-k:]  # Get indices of top k values
        heuristics_matrix[i, :] = 0  # Reset row
        heuristics_matrix[i, indices_to_keep] = row[indices_to_keep] # Restore top k elements
        heuristics_matrix[i,i] = 0

    #Ensure Symmetry after row wise operation.
    heuristics_matrix = (heuristics_matrix + heuristics_matrix.T)/2
    return heuristics_matrix
```
