{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a heuristics function for Solving Traveling Salesman Problem (TSP) via stochastic solution sampling following \"heuristics\". TSP requires finding the shortest path that visits all given nodes and returns to the starting node.\nThe `heuristics` function takes as input a distance matrix, and returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the input.\n\n\n[Worse code]\ndef heuristics_v0(distance_matrix: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Heuristic function for the Traveling Salesman Problem (TSP).\n    Employs a combination of factors and sparsification to guide\n    stochastic solution sampling.\n\n    Args:\n        distance_matrix (np.ndarray): A 2D numpy array representing the\n            distance matrix between nodes.\n\n    Returns:\n        np.ndarray: A 2D numpy array of the same shape as distance_matrix,\n            containing prior indicators of how promising it is to include\n            each edge in a solution.\n    \"\"\"\n\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    # Calculate node-level information (nearest neighbor, average distance)\n    nearest_neighbors = np.argsort(distance_matrix, axis=1)[:, 1:4]  # Indices of 3 nearest neighbors for each node\n    avg_distances = np.mean(distance_matrix, axis=1, keepdims=True)\n\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                # Factor 1: Inverse distance (favors shorter edges)\n                inverse_distance = 1 / distance_matrix[i, j]\n\n                # Factor 2: Nearest neighbor bonus (edges connecting to nearby nodes are favored)\n                nearest_neighbor_bonus = 0.0\n                if j in nearest_neighbors[i]:\n                    nearest_neighbor_bonus = 0.5 # Adjust weight as needed\n\n                # Factor 3: Avoid connections to far-away nodes relative to average distance\n                avg_distance_penalty = max(0.0, 1 - (avg_distances[i] / distance_matrix[i, j]))\n\n                # Factor 4:  Sparsity inducing factor. We penalize connecting to node\n                #           which is connected to all other nodes. This prevents hub nodes\n                connectedness = np.sum(distance_matrix[j,:] > 0)/(n-1)\n                sparsify_penalty = 1 - connectedness # 0 if it is connected to everyone\n                # Combine factors\n                heuristic_matrix[i, j] = inverse_distance + nearest_neighbor_bonus + avg_distance_penalty + sparsify_penalty\n            else:\n                heuristic_matrix[i, j] = 0  # No self-loops\n\n    # Sparsify the matrix: set low-probability edges to zero\n    threshold = np.percentile(heuristic_matrix[heuristic_matrix > 0], 20) # Dynamic Threshold\n    heuristic_matrix[heuristic_matrix < threshold] = 0\n\n    return heuristic_matrix\n\n[Better code]\ndef heuristics_v1(distance_matrix: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Heuristic function for the Traveling Salesman Problem (TSP) that combines\n    multiple factors to estimate the \"promise\" of including each edge in a solution.\n    This version attempts to be more sophisticated than a simple inverse distance.\n\n    Args:\n        distance_matrix (np.ndarray): A square matrix where element (i, j) represents\n                                      the distance between city i and city j.  It is\n                                      assumed that the diagonal elements are zero or very large\n                                      to discourage self-loops.\n\n    Returns:\n        np.ndarray: A matrix of the same shape as distance_matrix, where each element\n                      (i, j) indicates the desirability of including the edge (i, j) in\n                      the TSP tour. Higher values indicate more promising edges.\n    \"\"\"\n\n    n = distance_matrix.shape[0]\n\n    # 1. Inverse distance: Shorter distances are generally more desirable.\n    inverse_distance = 1.0 / (distance_matrix + 1e-9)  # Add a small constant to avoid division by zero\n\n    # 2. Nearest neighbor influence:  Edges connecting to cities with few nearby neighbors are more crucial.\n    #    For each city, find the distance to its k-th nearest neighbor. A smaller k-th nearest\n    #    neighbor distance indicates a denser local neighborhood. Edges connected to less dense\n    #    areas might be more important to ensure connectivity.\n\n    k = min(5, n - 1)  # Consider up to the 5th nearest neighbor, or fewer if n is small\n    nearest_neighbor_distances = np.zeros(n)\n    for i in range(n):\n        distances = distance_matrix[i, :]\n        nearest_neighbor_distances[i] = np.partition(distances, k + 1)[k + 1]\n\n    neighbor_influence = np.zeros_like(distance_matrix)\n    for i in range(n):\n        for j in range(n):\n            neighbor_influence[i, j] = nearest_neighbor_distances[i] + nearest_neighbor_distances[j]\n\n    # 3. Combination and scaling: Combine the factors.  Experiment with different weights.\n    heuristic_matrix = inverse_distance * (1 + neighbor_influence)\n\n    # 4. Sparsification: Zero out edges that are very unlikely to be in the optimal tour\n    #    based on a threshold derived from the mean of the heuristic matrix. This promotes\n    #    exploration of more focused search spaces.\n\n    threshold = np.mean(heuristic_matrix) * 0.2  # Tune this threshold multiplier\n    heuristic_matrix[heuristic_matrix < threshold] = 0\n\n    # Normalize the matrix to have values between 0 and 1. This isn't strictly necessary\n    # but might be helpful for some algorithms that use it.  Be aware this can also zero-out\n    # very small heuristic values due to floating-point issues, so exercise caution if your\n    # algorithm relies on edges with very weak probability remaining non-zero.\n    max_val = np.max(heuristic_matrix)\n    if max_val > 0: #Avoid division by zero.\n        heuristic_matrix = heuristic_matrix / max_val\n\n    return heuristic_matrix\n\n[Reflection]\nConsider neighborhood density, avoid hub nodes implicitly, and normalize heuristics for robust sampling.\n\n\n[Improved code]\nPlease write an improved function `heuristics_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}