{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a heuristics function for Solving Traveling Salesman Problem (TSP) via stochastic solution sampling following \"heuristics\". TSP requires finding the shortest path that visits all given nodes and returns to the starting node.\nThe `heuristics` function takes as input a distance matrix, and returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the input.\n\n\n[Worse code]\ndef heuristics_v0(distance_matrix: np.ndarray) -> np.ndarray:\n\n\n    \"\"\"\n    Heuristic function for TSP using nearest neighbors, local density,\n    geometric means, adaptive sparsification, and row-wise normalization.\n    This version improves upon v1 with enhanced local density estimation\n    and more robust handling of edge cases.\n\n    Args:\n        distance_matrix (np.ndarray): A 2D numpy array representing the distance matrix.\n\n    Returns:\n        np.ndarray: A 2D numpy array of the same shape as distance_matrix,\n                     representing the heuristic values (prior indicators).\n    \"\"\"\n\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    # Calculate nearest neighbors for each node.\n    nearest_neighbors = []\n    for i in range(n):\n        distances = distance_matrix[i].copy()\n        distances[i] = np.inf  # Exclude self-loop\n        nearest_neighbors.append(np.argsort(distances))\n\n    # Calculate a centrality measure (degree of connectivity).\n    degree_centrality = np.sum(1 / (distance_matrix + 1e-9), axis=0)\n    degree_centrality = degree_centrality / np.max(degree_centrality)  # Normalize\n\n    # Inverse distance factor\n    inverse_distance = 1 / (distance_matrix + 1e-9)\n    inverse_distance = inverse_distance / np.max(inverse_distance)  # Normalize\n\n    # Local Density Estimation: Improved version\n    local_density = np.zeros(n)\n    for i in range(n):\n        # Count neighbors within a dynamically adjusted radius.\n        # This radius is a fraction of the maximum distance from node i.\n        radius = 0.25 * np.max(distance_matrix[i]) # dynamic radius\n        neighbor_count = np.sum(distance_matrix[i] < radius)\n        local_density[i] = neighbor_count / (n - 1) # normalize\n\n    # Combine factors: inverse distance, nearest neighbor rank, and centrality.\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                # Rank of j in i's nearest neighbors and vice versa\n                rank_i = np.where(nearest_neighbors[i] == j)[0][0]\n                rank_j = np.where(nearest_neighbors[j] == i)[0][0]\n                rank_factor = 1 / (rank_i + rank_j + 1)\n\n                centrality_factor = (degree_centrality[i] + degree_centrality[j])\n\n                # Adjust centrality factor based on local density\n                adjusted_centrality = centrality_factor * (1 + local_density[i] + local_density[j]) / 2\n\n                # Geometric Mean for combining factors\n                heuristic_matrix[i, j] = (inverse_distance[i, j] * rank_factor * adjusted_centrality)**(1/3)\n\n    # Adaptive Sparsification\n    quantile_level = 0.75  # Adjust as needed\n    flat_heuristic = heuristic_matrix[heuristic_matrix > 0]\n\n    if len(flat_heuristic) > 0:  # avoid potential error\n        threshold = np.quantile(flat_heuristic, quantile_level)  # only consider elements > 0\n        heuristic_matrix[heuristic_matrix < threshold] = 0  # sparsify\n\n    # Row-wise normalization to avoid zero rows after sparsification\n    for i in range(n):\n        row_sum = np.sum(heuristic_matrix[i])\n        if row_sum > 0:\n            heuristic_matrix[i] = heuristic_matrix[i] / row_sum\n        else:\n            # Handle the case where a row is all zeros after sparsification.\n            # Distribute the probability evenly among the non-diagonal elements.\n            valid_indices = np.where(np.arange(n) != i)[0]\n            if len(valid_indices) > 0:  # safety check\n                heuristic_matrix[i, valid_indices] = 1 / len(valid_indices)\n\n\n    return heuristic_matrix\n\n[Better code]\ndef heuristics_v1(distance_matrix: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Heuristic function for TSP using normalized inverse distance,\n    geometric mean centrality, rank-based information, adaptive sparsification,\n    and degree centrality refinement with row-wise processing.\n\n    Args:\n        distance_matrix (np.ndarray): A 2D numpy array representing the distance matrix.\n\n    Returns:\n        np.ndarray: A 2D numpy array of the same shape as distance_matrix,\n                     representing the heuristic values (prior indicators).\n    \"\"\"\n\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    # 1. Row and Column Normalization\n    row_normalized = distance_matrix / (np.min(distance_matrix, axis=1, keepdims=True) + 1e-9)\n    col_normalized = distance_matrix / (np.min(distance_matrix, axis=0, keepdims=True) + 1e-9)\n    normalized_distance = (row_normalized + col_normalized) / 2\n    normalized_distance = 1 / (normalized_distance + 1e-9)\n    normalized_distance = normalized_distance / np.max(normalized_distance)\n\n    # 2. Geometric Mean Centrality\n    centrality = np.zeros(n)\n    for i in range(n):\n        centrality[i] = np.exp(np.mean(np.log(distance_matrix[i, distance_matrix[i] > 0] + 1e-9)))\n    centrality = 1 / (centrality / np.max(centrality) + 1e-9) # Invert & normalize\n\n    # 3. Rank-Based Information\n    nearest_neighbors = []\n    for i in range(n):\n        distances = distance_matrix[i].copy()\n        distances[i] = np.inf  # Exclude self-loop\n        nearest_neighbors.append(np.argsort(distances))\n\n    # 4. Combine Factors\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                rank_i = np.where(nearest_neighbors[i] == j)[0][0]\n                rank_j = np.where(nearest_neighbors[j] == i)[0][0]\n                rank_factor = 1 / (rank_i + rank_j + 1)\n\n                centrality_factor = np.sqrt(centrality[i] * centrality[j])\n\n                heuristic_matrix[i, j] = normalized_distance[i, j] * rank_factor * centrality_factor\n\n    # 5. Adaptive Sparsification\n    quantile_level = 0.75  # Adjust sparsity level (reduced compared to v1)\n    threshold = np.quantile(heuristic_matrix[heuristic_matrix > 0], quantile_level)\n    heuristic_matrix[heuristic_matrix < threshold] = 0\n\n    # 6. Degree Centrality Refinement & Row-wise Processing\n    degree_centrality = np.sum(1 / (distance_matrix + 1e-9), axis=0)\n    degree_centrality = degree_centrality / np.max(degree_centrality)\n\n    for i in range(n):\n        heuristic_matrix[i] = heuristic_matrix[i] * degree_centrality[i] # Scale row using node i's centrality\n        row_sum = np.sum(heuristic_matrix[i])\n        if row_sum > 0:\n            heuristic_matrix[i] = heuristic_matrix[i] / row_sum\n\n    return heuristic_matrix\n\n[Reflection]\nNormalization, geometric mean centrality, and degree centrality refinement improve heuristic quality in TSP solvers.\n\n\n[Improved code]\nPlease write an improved function `heuristics_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}