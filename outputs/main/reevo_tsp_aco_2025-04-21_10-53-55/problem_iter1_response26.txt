```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic function for the Traveling Salesman Problem (TSP).
    Employs a combination of factors and sparsification to guide
    stochastic solution sampling.

    Args:
        distance_matrix (np.ndarray): A 2D numpy array representing the
            distance matrix between nodes.

    Returns:
        np.ndarray: A 2D numpy array of the same shape as distance_matrix,
            containing prior indicators of how promising it is to include
            each edge in a solution.
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # Calculate node-level information (nearest neighbor, average distance)
    nearest_neighbors = np.argsort(distance_matrix, axis=1)[:, 1:4]  # Indices of 3 nearest neighbors for each node
    avg_distances = np.mean(distance_matrix, axis=1, keepdims=True)

    for i in range(n):
        for j in range(n):
            if i != j:
                # Factor 1: Inverse distance (favors shorter edges)
                inverse_distance = 1 / distance_matrix[i, j]

                # Factor 2: Nearest neighbor bonus (edges connecting to nearby nodes are favored)
                nearest_neighbor_bonus = 0.0
                if j in nearest_neighbors[i]:
                    nearest_neighbor_bonus = 0.5 # Adjust weight as needed

                # Factor 3: Avoid connections to far-away nodes relative to average distance
                avg_distance_penalty = max(0.0, 1 - (avg_distances[i] / distance_matrix[i, j]))

                # Factor 4:  Sparsity inducing factor. We penalize connecting to node
                #           which is connected to all other nodes. This prevents hub nodes
                connectedness = np.sum(distance_matrix[j,:] > 0)/(n-1)
                sparsify_penalty = 1 - connectedness # 0 if it is connected to everyone
                # Combine factors
                heuristic_matrix[i, j] = inverse_distance + nearest_neighbor_bonus + avg_distance_penalty + sparsify_penalty
            else:
                heuristic_matrix[i, j] = 0  # No self-loops

    # Sparsify the matrix: set low-probability edges to zero
    threshold = np.percentile(heuristic_matrix[heuristic_matrix > 0], 20) # Dynamic Threshold
    heuristic_matrix[heuristic_matrix < threshold] = 0

    return heuristic_matrix
```
