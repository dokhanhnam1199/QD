```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic function for the Traveling Salesman Problem (TSP).

    This function combines several factors to estimate the 'promisingness' of
    including each edge in the final solution.  It aims to balance
    edge length with node connectivity (avoiding node isolation), while
    also incorporating a degree of randomness through sampling potentially
    good subtours.  The final heuristic values are sparsified, only preserving
    edges deemed sufficiently promising based on a dynamically calculated threshold.

    Args:
        distance_matrix (np.ndarray): A square, symmetric NumPy array representing the
            pairwise distances between cities.

    Returns:
        np.ndarray: A NumPy array of the same shape as distance_matrix, where each
            element represents the heuristic value (higher is better) for including
            the corresponding edge in the TSP solution.  Unpromising edges are set to zero.
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # Inverse distance (shorter edges are preferred)
    inverse_distance = 1.0 / (distance_matrix + 1e-9)  # Add small value to avoid division by zero
    heuristic_matrix += inverse_distance

    # Node degree centrality (penalize edges that might isolate nodes)
    degree_centrality = np.sum(inverse_distance, axis=0)  # Higher is better, more connected
    for i in range(n):
        for j in range(n):
            if i != j:
                heuristic_matrix[i, j] += degree_centrality[i] + degree_centrality[j]

    # Nearest Neighbor Bonus
    nearest_neighbors = np.argsort(distance_matrix, axis=1)[:, 1:4]  # indices of 3 nearest neighbors
    for i in range(n):
        for neighbor in nearest_neighbors[i]:
             heuristic_matrix[i, neighbor] += inverse_distance.max() #significant bonus

    # Edge Distribution Uniformity - Helps to create spanning tour structure.

    edge_sum = np.sum(distance_matrix)
    expected_edge_value = edge_sum / (n * (n-1))
    edge_deviation = np.abs(distance_matrix - expected_edge_value)
    heuristic_matrix -= edge_deviation


    # Sparsify the matrix (keep only the most promising edges)
    threshold = np.percentile(heuristic_matrix[np.triu_indices_from(heuristic_matrix, k=1)], 75) # Adjust percentile
    heuristic_matrix[heuristic_matrix < threshold] = 0

    # Make symmetrical again in case operations skewed it.
    heuristic_matrix = np.maximum(heuristic_matrix, heuristic_matrix.T)

    return heuristic_matrix
```
