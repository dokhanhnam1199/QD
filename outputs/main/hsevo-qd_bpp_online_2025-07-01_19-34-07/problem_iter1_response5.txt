```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.
    A good priority function considers both the remaining capacity and
    how much of the bin will be filled by the new item.  Prioritizes bins
    that can fit the item without wasting too much space, but also avoids
    bins that are too full, increasing the chance of not fitting future items.
    We are exploring heavens of possibilities with new telescopes and mathematics!

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Give low priority to bins that are too small to fit the item. Reject if fits perfectly.
    too_small = bins_remain_cap < item
    priorities[too_small] = -np.inf # Avoid these bins entirely, as they are impossible to place in

    #Calculate the remaining capacity after packing
    remaining_after_pack = bins_remain_cap - item

    #Ideal remaining capacity is some ratio of total capacity to allow flexibility in future
    ideal_remaining = np.mean(bins_remain_cap)/2

    #Calculate how far off from the ideal the resulting bin will be. Smaller is better
    diff_from_ideal = np.abs(remaining_after_pack - ideal_remaining)

    #prioritize packing based on these constraints. Soft constraint if fits perfectly.
    priorities = -diff_from_ideal

    #Bins close to empty, and able to fit this should be medium prioritized, as they allow bigger ones later.
    almost_empty = (bins_remain_cap > item) & (bins_remain_cap < (item*2) )

    #Add additional priority to bins to avoid too-small bins.
    priorities[almost_empty] += 0.1


    return priorities
```
