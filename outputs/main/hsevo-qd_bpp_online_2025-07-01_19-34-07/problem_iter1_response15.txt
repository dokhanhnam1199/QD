```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version prioritizes bins where the item fills a significant
    portion of the remaining capacity but also considers absolute remaining capacity,
    giving some preference to bins with more space. This approach seeks
    to avoid fragmenting bins too much while still utilizing them effectively.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Avoid division by zero or negative capacity.  Assign a very low priority
    # to these bins to effectively disqualify them.
    valid_bins = bins_remain_cap > 0
    priorities = np.full(bins_remain_cap.shape, -np.inf)  # Default very low priority

    # Calculate ratio and modified priority for valid bins
    ratios = item / bins_remain_cap[valid_bins]
    # Apply penalty if item will exceed capacity after placement (ratios > 1)
    ratios = np.clip(ratios, 0, 1) # Ensure ration is valid. Should be done anyway

    # Use the logistic sigmoid to map the ratio to a value between 0 and 1.  
    # This provides a smoother weighting and emphasizes bins that are a good "fit".
    sigmoid_ratios = 1 / (1 + np.exp(-10 * (ratios - 0.5)))  # sharper curve near 0.5

    # Give some weight to the remaining capacity to prioritize bins with more space
    capacity_factor = bins_remain_cap[valid_bins] / np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else 0 #Avoid zero division
    
    # Combine ratio and capacity for final score
    priorities[valid_bins] = sigmoid_ratios + 0.1 * capacity_factor # weight capacity less

    return priorities
```
