```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Combines gravitational effect, fill ratio, and waste minimization."""
    # Avoid division by zero
    min_capacity = 1e-9
    bins_remain_cap = np.where(bins_remain_cap <= 0, min_capacity, bins_remain_cap)

    # Gravitational effect
    gravity_power = 2
    gravitational_effect = item / (bins_remain_cap**gravity_power)

    # Fill ratio
    fill_ratio = item / bins_remain_cap
    fill_ratio = np.where(bins_remain_cap < item, -np.inf, fill_ratio)

    # Waste minimization: Favor bins where the remaining capacity after adding the item is small
    potential_waste = bins_remain_cap - item
    waste_penalty = np.where(potential_waste > 0, np.exp(-potential_waste), -np.inf)  # Penalize large waste
    waste_penalty = np.where(potential_waste < 0, -np.inf, waste_penalty) # Make bin infeasible if item doesn't fit.

    # Combine the factors with weights. Weights can be tuned.
    priorities = gravitational_effect + fill_ratio + waste_penalty
    return priorities
```
