```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version incorporates a 'tight fit' bonus and a penalty for bins that are too full after packing.
    It also discourages leaving very small unused space.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    for i, cap in enumerate(bins_remain_cap):
        if item <= cap:
            # Calculate remaining capacity after packing
            remaining_cap = cap - item

            # Base priority: inverse of the remaining capacity (favors filling up bins)
            priorities[i] = 1.0 / (remaining_cap + 1e-9)  # Add small epsilon to prevent division by zero

            # Tight fit bonus: Higher priority for bins where the item fits snugly.
            #  This is a Gaussian-like bonus centered around a 'good fit'.
            fit_diff = np.abs(remaining_cap - item/2)  # target remaining is roughly half the item size for future
            tight_fit_bonus = np.exp(-(fit_diff**2) / (2 * (item/5)**2)) # Gaussian centered at item/2, std dev item/5
            priorities[i] += tight_fit_bonus


            # Penalty for creating nearly full bins after packing. We discourage overfilling bins
            if remaining_cap < 0.1: # If small space left
                 priorities[i] -= 10  # Heavy penalty

            #Discourage tiny leftovers, this is to reduce fragmentation
            if 0.1 < remaining_cap < 0.2:
                priorities[i] -= 5 #Moderate penalty for small left overs.


        else:
            priorities[i] = -np.inf  # Cannot fit the item

    return priorities
```
