```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.
    This version combines multiple factors for a more robust and adaptive heuristic.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Ensure no division by zero
    bins_remain_cap = np.where(bins_remain_cap <= 0, 1e-9, bins_remain_cap)

    # 1. Feasibility: Check if the item fits. Infeasible bins get a very low priority.
    feasibility = (bins_remain_cap >= item).astype(float)
    feasibility = np.where(feasibility == 0, -np.inf, feasibility)

    # 2. Remaining Capacity Ratio: Prefer bins where the item doesn't overfill significantly
    remaining_ratio = (bins_remain_cap - item) / bins_remain_cap
    remaining_ratio = np.clip(remaining_ratio, 0, 1)  # Clip to [0, 1]
    remaining_ratio = np.where(bins_remain_cap < item, 0, remaining_ratio) # zero if it doesnt fit

    # 3. Bin Utilization: Favor bins that are already somewhat full (but can still fit the item).
    utilization = 1 - bins_remain_cap  # Assume bin size is 1.
    utilization = np.clip(utilization, 0, 1)
    
    # 4. Item Size Consideration: Adapt priority based on item size.
    #    - Small items: prioritize almost-full bins to consolidate small items.
    #    - Large items: prioritize emptier bins to avoid fragmentation
    item_size_factor = np.where(item < 0.3, (1 - remaining_ratio)**2, remaining_ratio)


    # 5. Combine the factors with weights.  Crucially, use item-dependent weights.
    #    Adjust the weights based on item size for adaptive behavior.
    weight_feasibility = 1.0 if item < 0.7 else 1.0
    weight_remaining_ratio = 1.0 if item < 0.7 else 2.0
    weight_utilization = 2.0 if item < 0.3 else 1.0
    weight_item_size = 1.5

    priority = (weight_feasibility * feasibility +
                weight_remaining_ratio * remaining_ratio +
                weight_utilization * utilization +
                weight_item_size * item_size_factor)

    return priority
```
