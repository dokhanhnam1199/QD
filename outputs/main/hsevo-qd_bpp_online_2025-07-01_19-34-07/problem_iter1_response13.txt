```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.
       This version considers a combination of factors:
       1. How much space will be wasted if the item is placed in the bin.
       2. How full the bin becomes after adding the item.
       3. Whether the item fits at all.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    for i, remaining_capacity in enumerate(bins_remain_cap):
        if item <= remaining_capacity:
            # Calculate wasted space (remaining capacity after adding the item)
            wasted_space = remaining_capacity - item

            # Calculate fullness (percentage of bin filled after adding item)
            fullness = (1 - (wasted_space / remaining_capacity)) if remaining_capacity > 0 else 1 #handle edge case if bins_remain_cap = 0 initially

            # Combine factors to create a priority score. Higher is better.
            # We prefer bins that minimize wasted space but also fill up reasonably well.
            # Adjust the weights as needed to fine-tune the heuristic.
            priorities[i] = (1 - wasted_space/(np.max(bins_remain_cap) + 1e-6)) + fullness
            #add 1e-6 to avoid division by zero if all bins have capacity zero

            #priorities[i] = 1/(wasted_space + 1e-6) #minimise wasted space only

            #priorities[i] = fullness #maximize fullness only
        else:
            # Item doesn't fit, so give it a very low priority
            priorities[i] = -np.inf #or a very large negative number
    return priorities
```
