```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Uses a combination of remaining capacity and a 'gravitational' potential.
    Bins with capacity close to the item size get higher priority, but
    very small remaining capacities are penalized.
    The potential energy term encourages better space utilization overall.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Ensure bins_remain_cap is a NumPy array
    bins_remain_cap = np.array(bins_remain_cap)

    # Calculate how close the remaining capacity is to the item size.
    # The closer, the better (higher priority). Avoid division by zero.
    closeness = np.abs(bins_remain_cap - item)
    closeness_priority = np.where(closeness == 0, np.inf, 1 / (closeness + 1e-9)) # Add small value to avoid division by 0

    # Penalize very small remaining capacities to avoid fragmentation.
    # This creates a 'repulsive force' for nearly full bins.  We can add a parameter to tune it.
    min_cap_threshold = item * 0.1 # Adjust threshold based on item size
    small_capacity_penalty = np.where(bins_remain_cap < min_cap_threshold, -100, 0) # Flat penalty, alternative log penalty is possible. -np.log(min_cap_threshold / (bins_remain_cap+1e-9)) where bins_remain_cap < min_cap_threshold, 0)

    # Gravitational potential energy: Favor bins that are already somewhat full. The inverse of remaining capacity.
    # This encourages filling bins completely instead of spreading items across bins. Higher is better.
    #Add a scaler for tuning the gravitational energy term.
    gravitational_constant = 0.5
    gravitational_potential = gravitational_constant / (bins_remain_cap+1e-9)

    # Combine the priorities. Closeness is the primary driver, small capacity is avoided, gravitational helps to fill.
    priorities = closeness_priority + small_capacity_penalty + gravitational_potential

    return priorities
```
