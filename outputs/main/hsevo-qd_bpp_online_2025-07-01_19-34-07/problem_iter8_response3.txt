```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Adaptive heuristic: feasibility, utilization, and waste, with item size scaling."""

    # Feasibility: -inf for bins that can't fit the item.
    feasible = bins_remain_cap >= item
    priorities = np.where(feasible, 0, -np.inf)

    # Utilization: how full the bin will be. Avoid zero division
    remaining_after_fit = bins_remain_cap - item
    bins_remain_cap = np.where(bins_remain_cap <= 0, 1e-9, bins_remain_cap)
    remaining_after_fit = np.where(remaining_after_fit <= 0, 1e-9, remaining_after_fit)
    utilization_factor = 1 - (remaining_after_fit / bins_remain_cap)
    utilization_factor = np.where(utilization_factor < 0, 0, utilization_factor)

    # Waste minimization: penalize excessive empty space.
    waste_penalty = np.exp(-remaining_after_fit)

    # Combine factors, adaptive scaling
    relative_size = item / bins_remain_cap
    if np.any(relative_size > 0.5):  # Large item: focus on utilization
        priorities = np.where(feasible, 0.8 * utilization_factor + 0.2 * waste_penalty, priorities)
    elif np.all(relative_size < 0.2): # Small item: focus on minimizing waste
        priorities = np.where(feasible, 0.3 * utilization_factor + 0.7 * waste_penalty, priorities)
    else: #Balance utilization and waste
        priorities = np.where(feasible, 0.7 * utilization_factor + 0.3 * waste_penalty, priorities)
    return priorities
```
