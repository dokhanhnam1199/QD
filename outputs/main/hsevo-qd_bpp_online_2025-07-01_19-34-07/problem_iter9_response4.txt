```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.
    This version incorporates more nuanced factors, including:
    1. Feasibility (can the item fit?)
    2. Waste minimization (how much space is left *after* packing?)
    3. Bin utilization (how full is the bin *before* packing?)
    4. Item size relative to bin size

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Feasibility check: very important to exclude bins that cannot fit the item
    feasible = bins_remain_cap >= item
    priorities = np.zeros_like(bins_remain_cap, dtype=float) - np.inf  # Initialize to -inf so infeasible bins are never chosen
    priorities[feasible] = 0  # Reset feasible bin priorities to 0 for calculation

    feasible_bins_remain_cap = bins_remain_cap[feasible]

    if np.any(feasible):  # Only calculate if there are any feasible bins

        # Waste minimization: smaller waste is better
        waste = feasible_bins_remain_cap - item
        waste_priority = -waste  # Smaller waste gets higher priority

        # Bin utilization: higher utilization is better, scaled by item size ratio
        utilization = 1 - feasible_bins_remain_cap / (feasible_bins_remain_cap + item)
        utilization_priority = utilization

        # Item size relative to bin size: larger item relative to bin gets higher priority
        item_ratio = item / feasible_bins_remain_cap
        item_ratio_priority = item_ratio

        # Combine factors, weighting them based on importance. Adapt these weights
        # based on problem instance characteristics (e.g., larger items).

        priorities[feasible] = (
            0.5 * waste_priority +
            0.3 * utilization_priority +
            0.2 * item_ratio_priority
        )

        # Non-linear scaling (e.g., using sigmoid) to emphasize small waste:
        # This can help to avoid creating very small gaps.
        # Scale and shift sigmoid to better fit priority range.
        # Small bins are highly desirable
        sigmoid_scale = 5.0
        sigmoid_shift = np.mean(priorities[feasible])
        priorities[feasible] = 1 / (1 + np.exp(-sigmoid_scale * (priorities[feasible] - sigmoid_shift)))

    return priorities
```
