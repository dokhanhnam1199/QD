```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Heuristic 1: Remaining capacity close to item size is good, but not too close.
    # We want to leave some space, but not too much waste.
    diffs = bins_remain_cap - item
    priority_1 = np.exp(-np.abs(diffs) / (0.1 * item))  # Gaussian-like peak when diffs is small

    # Heuristic 2: Avoid bins that would become too empty after packing.
    # A bin is "too empty" if remaining capacity is less than a fraction of the total capacity.
    # The total capacity is assumed to be max of bins_remain_cap initially.

    penalty_2 = np.zeros_like(bins_remain_cap, dtype=float)
    penalty_2[diffs < 0.1] = -10 # drastically lower priority if we are overflowing

    # Heuristic 3: Try to balance usage - prefer bins that are already somewhat filled (more utilized).
    # We can quantify this via percentage filled: (initial_capacity - remaining) / initial_capacity
    # Assuming all bins have initial capacity of max(bins_remain_cap)

    priority_3 = (np.max(bins_remain_cap) - bins_remain_cap) / np.max(bins_remain_cap)


    # Heuristic 4: Give a boost to the fullest bin that still can fit the item to encourage usage.
    priority_4 = np.zeros_like(bins_remain_cap,dtype=float)
    feasible_bins = bins_remain_cap[bins_remain_cap>=item]
    if len(feasible_bins) > 0:
        max_feasible_cap = np.max(feasible_bins)
        priority_4[bins_remain_cap == max_feasible_cap] = 1.0


    # Combine the heuristics.
    priorities = 0.4*priority_1 + 0.1 * priority_3 + 0.4*priority_4+ penalty_2
    return priorities
```
