```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.
    This version introduces a more nuanced approach, considering multiple factors
    and non-linear combinations to improve bin packing efficiency.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Epsilon to avoid division by zero and log of zero
    epsilon = 1e-9
    bins_remain_cap = np.clip(bins_remain_cap, epsilon, None)  # Ensure bins_remain_cap is never exactly 0

    # 1. Remaining Capacity Factor: Favor bins with sufficient space.
    capacity_factor = np.log(bins_remain_cap / item + epsilon)

    # 2. Item Fit Factor: How well the item fits relative to the remaining capacity
    fit_ratio = item / bins_remain_cap
    fit_factor = np.exp(-np.abs(fit_ratio - 0.75)) # Gaussian-like preference around 0.75. Avoids both very tight and very loose fits. Replace abs with square to remove sign issues

    # 3. Bin Utilization Factor:  Encourage filling bins without overfilling
    utilization_factor = 1 - np.exp(-5 * (1 - bins_remain_cap))  # Exponential decay approaching 1 as bins fill.

    # 4. Heuristic to avoid bins that are too small.
    ineligibility_factor = np.where(bins_remain_cap < item, -np.inf, 0) #make inelligible when not fitting

    # 5. Combine factors with weights.  Experiment with different weights to tune performance.
    priority = (
        1.0 * capacity_factor +
        1.5 * fit_factor +
        0.8 * utilization_factor +
        ineligibility_factor
    )
    return priority
```
