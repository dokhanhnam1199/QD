```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version prioritizes bins where the item fits well, leaving less wasted space.
    It considers both how well the item fills the bin (higher ratio is better) and
    how much space remains *after* the item is added (less remaining is better).
    Avoids assigning negative priorities to infeasible bins, assigning lowest priority to those.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Infeasible bins get minimal priority
    feasible_bins = bins_remain_cap >= item

    if np.any(feasible_bins):
        remaining_capacity_after_placement = bins_remain_cap[feasible_bins] - item
        fill_ratios = item / bins_remain_cap[feasible_bins]
        waste_penalty = np.exp(remaining_capacity_after_placement) # Exponential penalty for waste
        priorities[feasible_bins] = fill_ratios / waste_penalty

    return priorities
```
