```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.
    This version prioritizes bins with sufficient capacity while also
    penalizing bins that are left with very little remaining capacity after
    packing, aiming to avoid fragmentation.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    # 1. Infeasible bins get a very low priority (negative infinity)
    infeasible_mask = bins_remain_cap < item
    priorities[infeasible_mask] = -np.inf
    
    # 2. Calculate remaining capacity AFTER placing the item (if feasible).
    remaining_after_placement = bins_remain_cap - item
    
    # 3. Prioritize bins with higher remaining capacity *after* placement, but only if feasible.
    feasible_mask = ~infeasible_mask  # Avoid double negative if ~infeasible_mask becomes an error
    priorities[feasible_mask] = remaining_after_placement[feasible_mask]  # Larger remaining gets higher score.

    # 4. Penalize bins that, if used, will leave very little remaining space.
    #    This is to prevent excessive fragmentation (leaving small slivers of capacity).
    tiny_remaining_mask = (remaining_after_placement > 0) & (remaining_after_placement < 0.1) #e.g. less than 10% of the total capacity
    priorities[tiny_remaining_mask] -= 10 # reduce score drastically if tiny_remaining
    
    #5. A slight adjustment: Prefer bins where the item fits reasonably well
    #   but doesn't nearly fill the bin.  This helps balance fragmentation vs. utilization
    fill_ratio = item / bins_remain_cap
    medium_fill_mask = (fill_ratio > 0.2) & (fill_ratio < 0.9)
    priorities[medium_fill_mask] += 1 # Slightly boost moderate fill ratios.

    return priorities
```
