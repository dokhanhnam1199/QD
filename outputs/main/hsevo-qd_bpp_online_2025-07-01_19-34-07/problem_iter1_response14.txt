```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.
    A harmonic mean based priority calculation incorporating best fit and avoiding near-full bins.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Initialize priorities with a very low default value.
    priorities = np.full(bins_remain_cap.shape, -np.inf)

    # Identify bins that can accommodate the item.
    valid_bins = bins_remain_cap >= item

    if np.any(valid_bins):
        # Calculate "best fit" component - how close is the fit?
        fit_component = bins_remain_cap[valid_bins] - item

        # Avoid filling bins almost completely (near capacity) to avoid fragmentation.
        near_full_penalty = np.exp(10 * (1 - bins_remain_cap[valid_bins] / item))
        near_full_penalty = np.clip(near_full_penalty, 0, 100)  # cap penalty

        # Apply penalty based on fill percentage
        fill_percentage = item / bins_remain_cap[valid_bins]
        fill_penalty = np.exp(5*(fill_percentage - 1)) # Heavily penalize fill % close to 1

        # Harmonic mean to combine fit and avoidance components - a bin must be BOTH a good fit
        # AND not be close to full. Adds both elements while balancing the need for a tight fit
        # with avoiding a near full state. Penalizes extreme values in either 'fit' or 'avoid' factors
        # Avoid division by zero using the Harmonic Mean Formula and appropriate handling.
        fit_component = np.maximum(0, fit_component)
        avoid_near_full = np.exp(-near_full_penalty)

        harmonic_mean = (2 * fit_component * avoid_near_full) / (fit_component + avoid_near_full + 1e-9)
        harmonic_mean = harmonic_mean/ np.max(harmonic_mean + 1e-9)

        fill_penalty_term = np.exp(-fill_penalty)
        harmonic_mean_corrected = harmonic_mean * fill_penalty_term

        # Assign final priority scores to the valid bins
        priorities[valid_bins] = harmonic_mean_corrected

    return priorities
```
