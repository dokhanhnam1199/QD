```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    A black hole inspired heuristic. We use a combination of factors:
    - Inverse of wasted space (smaller wasted space = higher priority, mimicking gravitational pull).
    - A "horizon" factor: If item doesn't fit, strongly penalize it.  This is akin to an event horizon - once crossed, there's no going back (can't fit).
    - A bit of randomness to escape local optima, simulating Hawking radiation.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    wasted_space = bins_remain_cap - item
    priorities = np.zeros_like(bins_remain_cap)

    for i, waste in enumerate(wasted_space):
        if waste >= 0:
            #Inverse of wasted space (avoid division by zero by adding a small epsilon). This reflects black hole gravity pulling in nearby matter. The smaller the waste, the stronger the pull.
            priorities[i] = 1 / (waste + 1e-9)

            #Add randomness akin to Hawking radiation: Smaller bins get a bit more random "quantum fluctuations"
            priorities[i] += np.random.rand() * (1.0 / (bins_remain_cap[i] + 1e-9))

        else:
            #Huge penalty if it doesn't fit (event horizon)
            priorities[i] = -1e9  # Or some very negative large number to heavily discourage
    return priorities
```
