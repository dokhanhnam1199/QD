```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    A more refined heuristic, considering several factors:
    1. How well the item fits (remaining capacity vs. item size)
    2. Penalizing bins that are almost full after adding the item (to avoid fragmentation)
    3. Prioritizing bins that can fit the item, but only just (encouraging filling)
    4. Providing a very small non-zero value when the item can't fit

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    for i, cap in enumerate(bins_remain_cap):
        if cap >= item:
            # Fit Score: Higher if the fit is tighter (lower remaining capacity after adding)
            fit_score = 1 / (cap - item + 0.00001) #Adding small constant to avoid division by zero

            # Fragmentation Penalty: Higher penalty if bin is almost full after adding
            remaining_after = cap - item
            frag_penalty = 0.0

            if remaining_after > 0: #Avoid zero remainaing after calculation and log() of zero in following lines

                frag_penalty = np.log(cap / remaining_after)  if remaining_after > 0 else 1000 #High penalty if cap/remaining after becomes very high or remaining becomes zero (bin is packed fully to a near point, but item fits anyway

            priorities[i] = fit_score - frag_penalty

        else:
            # A very small priority for bins that can't fit, ensuring they aren't completely ignored
            # but will be chosen only when no other bin can fit.
            priorities[i] = -1e9 # Large negative score to make this as lowest possible choice but negative infinity gives error so using negative number
    return priorities
```
