{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Combines fill ratio, remaining capacity, and feasibility.\"\"\"\n    min_capacity = 1e-9\n    bins_remain_cap = np.where(bins_remain_cap <= 0, min_capacity, bins_remain_cap)\n\n    # Fill ratio, penalize infeasible bins\n    fill_ratio = item / bins_remain_cap\n    fill_ratio = np.where(bins_remain_cap < item, -np.inf, fill_ratio)\n\n    # Remaining capacity utilization\n    capacity_utilization = 1 - (bins_remain_cap - item) / bins_remain_cap\n    capacity_utilization = np.where(bins_remain_cap < item, -np.inf, capacity_utilization)\n\n    priorities = fill_ratio + capacity_utilization\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n    This version refines the priority calculation by considering multiple factors\n    in a more nuanced and adaptive manner.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Handle edge cases: bins that cannot fit the item\n    infeasible_mask = bins_remain_cap < item\n    priorities = np.full_like(bins_remain_cap, -np.inf)  # Mark infeasible bins with -inf\n    \n    # Avoid division by zero and operate only on feasible bins\n    feasible_bins_remain_cap = bins_remain_cap[~infeasible_mask]\n    if feasible_bins_remain_cap.size == 0:\n        return priorities\n    \n    # Calculate remaining capacities after adding item, cliping negative values to 0\n    remaining_after_add = np.clip(feasible_bins_remain_cap - item, 0, np.inf)\n    \n    # 1. Capacity Utilization Score: favors bins filling up nicely without too much waste.\n    utilization_score = (feasible_bins_remain_cap - remaining_after_add) / feasible_bins_remain_cap # item / feasible_bins_remain_cap\n    \n    # 2. Waste Minimization Score: penalizes bins that would leave too much empty space.\n    waste_penalty = remaining_after_add / np.max(bins_remain_cap)  # Normalized to max bin size\n\n    # 3. Item Size Significance Score: Considers how significant is the item size comparing to available space\n    item_significance = item / np.max(bins_remain_cap)\n\n    #Adaptive Weighting: Dynamically adjust the importance of each factor.\n    alpha = 0.6 # Weight for utilization\n    beta = 0.3 # Weight for waste\n    gamma = 0.1 #Weight for item_significance\n\n    combined_priority = (alpha * utilization_score) - (beta * waste_penalty) + (gamma * item_significance)\n\n    # Assign priority to feasible bins and return\n    priorities[~infeasible_mask] = combined_priority\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see the first combines gravitational effect, fill factor, and capacity scaling, while the last only uses the log of the item/capacity ratio. 1st also handles the zero-capacity edge case, while 20th doesn't explicitly. Comparing (2nd best) vs (second worst), 2nd uses gravitational effect, fill ratio, and adaptive capacity scaling while 19th still only uses log ratios and lacks edge case handling. Comparing (1st) vs (2nd), we see that 2nd adds a gravity power parameter and an adaptive capacity scaling based on item size and weights the factors while 1st uses simpler capacity scaling. (3rd) vs (4th), 3rd introduces parameters `small_cap_threshold` and `gravity_power` and uses them, while 4th implements sophisticated factors utilization, fit, balance, and penalty with adaptive scaling. Comparing (second worst) vs (worst), we see they are identical and implement only a log ratio calculation. Overall: The better heuristics consider multiple factors, often with adaptive scaling or weighting. They also handle edge cases such as division by zero. Simpler heuristics rely on a single factor, such as the ratio of item size to remaining capacity. \"Gravitational effect\" and \"fill factor/ratio\" are re-occurring components. Adaptive scaling and edge-case handling also appear to be advantageous.\n- \nHere's a refined definition of \"Current Self-Reflection\" focusing on effective heuristic design:\n\n*   **Keywords:** Multi-factor integration, adaptive scaling, edge case handling, problem characteristics, robustness.\n\n*   **Advice:** Design heuristics by combining relevant factors, adapting their influence (weighting/scaling) based on problem-specific traits. Ensure robustness by addressing potential edge cases.\n\n*   **Avoid:** Overly simplistic calculations, purely linear combinations, disregarding problem context, focusing solely on log ratios.\n\n*   **Explanation:** Effective heuristic design requires a nuanced approach. Go beyond simple formulas by adapting factor influence based on problem characteristics and meticulously handling edge cases for robustness.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}