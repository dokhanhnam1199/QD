```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.
    This version prioritizes bins based on a multi-faceted approach, 
    considering remaining capacity, item fit, and potential waste.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # 1. Feasibility Check: Disqualify bins that can't fit the item
    feasible = bins_remain_cap >= item
    priorities = np.where(feasible, 0, -np.inf)  # Infeasible bins get -inf priority

    # 2. Remaining Capacity Utilization: Prioritize bins with smaller remaining capacity after placing the item, but not too small
    remaining_after_fit = bins_remain_cap - item
    
    #Avoid division by zero.
    bins_remain_cap = np.where(bins_remain_cap <= 0, 1e-9, bins_remain_cap)
    remaining_after_fit = np.where(remaining_after_fit <= 0, 1e-9, remaining_after_fit)

    #A term to maximize the utilization
    utilization_factor = 1 - (remaining_after_fit / bins_remain_cap)
    utilization_factor = np.where(utilization_factor < 0, 0, utilization_factor) #Ensure this is never negative

    # 3. Waste Minimization: Penalize bins that would leave too much empty space
    waste_penalty = np.exp(-remaining_after_fit) # Exponential decay.  Less waste, less penality.

    # 4. Combine Factors (weighted)
    priorities = np.where(feasible, 0.7 * utilization_factor + 0.3 * waste_penalty, priorities) # Prioritize bins that are feasible
    
    # 5. Adaptive Scaling: Dynamically adjust based on item size relative to bin size.
    relative_size = item / bins_remain_cap
    if np.any(relative_size > 0.5):  # If item is relatively large, emphasize utilization
        priorities = np.where(feasible, 0.8 * utilization_factor + 0.2 * waste_penalty, priorities)
    elif np.all(relative_size < 0.2): # If items are small, emphasize minimizing waste
        priorities = np.where(feasible, 0.3 * utilization_factor + 0.7 * waste_penalty, priorities)
        
    return priorities
```
