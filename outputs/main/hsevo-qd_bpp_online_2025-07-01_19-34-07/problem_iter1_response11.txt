```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Employing principles of space-time curvature, we prioritize bins where adding the item
    creates a "gravitational pull" effect, bringing the bin closer to full utilization
    without exceeding its capacity.  We also consider the "redshift" effect â€“ bins with
    very little remaining capacity are penalized to avoid overfilling.  The "equivalence
    principle" is reflected in treating near-full bins differently based on item size.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Avoid division by zero by adding a small constant.
    epsilon = 1e-9

    for i, remaining_capacity in enumerate(bins_remain_cap):
        if item <= remaining_capacity:
            # "Gravitational pull" - higher priority for bins where item fits relatively well.
            #  Proportional to the item size relative to remaining capacity. A larger item filling
            # more space grants a stronger pull.

            utilization_ratio = item / (remaining_capacity + epsilon)
            priorities[i] = utilization_ratio  # Basic utilization factor

            # Enhanced gravity for near-full bins (but only if adding item won't overflow)
            near_full_threshold = 0.2  # Define near-full relative to remaining capacity

            if remaining_capacity - item < near_full_threshold:
               priorities[i] += 1.0/(remaining_capacity + epsilon) # Strong pull

            # Small item, don't want too many near-full
            if item < 0.1 and remaining_capacity < 0.3 :
                priorities[i] -= 0.5 #Discourage
        else:
            # Item too large - negative priority (repulsive force)
            priorities[i] = -np.inf

    # Add a small amount of noise for exploration. Very important to overcome local optimas.
    noise = np.random.normal(0, 0.01, size=len(bins_remain_cap))
    priorities += noise

    return priorities
```
