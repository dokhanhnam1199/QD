```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.
    Favors bins where the item fits well, but not perfectly.
    Also includes a penalty for bins that are nearly full already (risk of wasting space).

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    for i, cap in enumerate(bins_remain_cap):
        if cap >= item:
            # Calculate how much space will be left if we add the item
            remaining_space = cap - item

            # A good fit is where we have some space left, but not too much
            # Aim for around 20% to 50% of the bin's original capacity (assume capacity is 1). Adjust for different bin sizes.

            ideal_remaining_space = 0.3  # Target remaining space as a fraction of full bin.
            difference_from_ideal = abs(remaining_space - ideal_remaining_space)

            # Give higher priority to bins that are closer to the ideal remaining space.  Use an exponential penalty.
            fit_priority = np.exp(-5 * difference_from_ideal) # Scale the effect

            # Add a slight penalty if the bin is almost full (reduces wasted space)
            #This is important when remaining_space is closer to zero.

            if cap < 0.2: #Low values may introduce infinity
                almost_full_penalty = -10
            else:
                almost_full_penalty = -np.exp(1/(cap)) # penalize if close to 0 cap


            priorities[i] = fit_priority + almost_full_penalty # Combines both heuristics
        else:
            # Cannot fit the item, very low priority
            priorities[i] = -np.inf

    return priorities
```
