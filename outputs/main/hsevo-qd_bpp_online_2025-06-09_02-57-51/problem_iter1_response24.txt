```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Prioritizes bins that can accommodate the item with minimal remaining space,
    but penalizes bins that are too full to hold the item.
    A touch of logarithmic scaling and exponential boosting adds Tesla-esque finesse.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap)

    # Give a huge penalty if item doesn't fit in the bin
    does_fit = bins_remain_cap >= item
    priorities[~does_fit] = -np.inf  # Very low priority for bins that are too small

    # Prioritize bins where the item fits, rewarding tighter fits exponentially
    # This avoids fragmentation by favoring utilization of smaller remaining space.

    remaining_space = bins_remain_cap[does_fit] - item
    priorities[does_fit] = np.exp(-5 * remaining_space / item) #Tesla's amplified effect

    # Add a small bonus based on how full the bin already is before adding the current item.
    # bins_remain_cap ==0 will be inf which is desired in this priority function. But we already excluded small bins
    # So it will be OK to divide it
    priorities[does_fit] += 0.1 * (1 - remaining_space / bins_remain_cap[does_fit]) #Avoid near empty bins.

    return priorities
```
