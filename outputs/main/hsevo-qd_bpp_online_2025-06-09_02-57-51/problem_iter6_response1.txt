```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version incorporates several improvements:
    1.  Adaptive Fragmentation Penalty: Adjusts penalty based on item size and bin capacity.
    2.  Bin Utilization Awareness: Encourages filling bins to a certain threshold.
    3.  Look-Ahead Consideration:  Evaluates potential future placements after adding the current item.
    4.  Dynamic Weight Adjustment: Modifies weights based on overall bin utilization.
    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap)
    remaining_after_add = bins_remain_cap - item
    valid_bins = remaining_after_add >= 0

    if np.any(valid_bins):
        # Initial priority based on space difference
        space_diff = np.abs(remaining_after_add)
        priorities[valid_bins] = 1.0 / (space_diff[valid_bins] + 1e-9)

        # Adaptive Fragmentation Penalty: Penalize bins that would leave very small fragments, adjusted by item size
        fragment_penalty = np.exp(-100 * (remaining_after_add[valid_bins] / item)**2)
        priorities[valid_bins] -= fragment_penalty*0.5  # Reduce priority for high fragmentation

        # Bin Utilization Awareness: Encourage bins to reach a certain fill threshold (e.g., 75%)
        bin_capacity = np.max(bins_remain_cap)  # Assuming all bins have the same capacity
        current_fill_ratio = (bin_capacity - bins_remain_cap[valid_bins]) / bin_capacity
        target_fill_ratio = 0.75
        fill_incentive = np.exp(-10 * (current_fill_ratio - target_fill_ratio)**2)  # Give incentive if close to target
        priorities[valid_bins] += fill_incentive*0.3

        # Look-Ahead Consideration:  Slightly favor bins that, after adding the item, *might* accommodate a future small item
        # This is a simplified lookahead, not a full search
        avg_item_size = np.mean(item) if isinstance(item, np.ndarray) else item  #Estimate of a future item
        lookahead_valid = remaining_after_add[valid_bins] >= (avg_item_size/2)
        priorities[valid_bins][lookahead_valid] += 0.1 #boost those bins

        # Dynamic Weight Adjustment based on overall bin utilization
        overall_utilization = 1 - np.mean(bins_remain_cap / bin_capacity)
        utilization_weight = 1 + 2*overall_utilization   # Increase influence as bins get full
        priorities[valid_bins] *= utilization_weight


    else: #No available bins
        priorities = 1/(1+np.abs(remaining_after_add)) # try anyway
    return priorities
```
