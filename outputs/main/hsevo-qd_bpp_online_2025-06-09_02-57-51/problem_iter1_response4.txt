```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This function implements a more sophisticated priority scheme:

    1.  **Feasibility Check:**  Bins that cannot accommodate the item receive a priority of -np.inf.
    2.  **Remaining Capacity Ratio:** Calculate the ratio of remaining capacity *after* adding the item to the original remaining capacity. Lower ratios (bins filling up more completely) are favored. This ratio is more insightful than just looking at the original capacity or the item size.
    3.  **Fill-Up Bias:**  Add a bonus to bins that have a remaining capacity close to the item size.  This encourages using bins that are already mostly filled.
    4.  **Normalization:** The final priorities are scaled to the range of [0,1] to ensure stable behaviour and comparable ranges, particularly important for future extensions.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    # Infeasible bins get -inf priority
    infeasible_mask = bins_remain_cap < item
    priorities[infeasible_mask] = -np.inf

    # Calculate remaining capacity AFTER adding the item.
    feasible_mask = ~infeasible_mask
    remaining_after = bins_remain_cap[feasible_mask] - item

    # Calculate Ratio: (remaining after) / (remaining before).  Favor smaller ratios
    capacity_ratios = remaining_after / bins_remain_cap[feasible_mask]
    
    # Smaller ratios become larger priorities
    priorities[feasible_mask] = -capacity_ratios  # Negate to make lower ratios have higher priority


    # Fill-Up Bonus:  Give bonus if bin size close to item size, scaled by original bin capacity.  This promotes using partially full bins
    fill_diff = np.abs(bins_remain_cap[feasible_mask] - item)
    fill_bonus = np.exp(-fill_diff) # Exponential decay means closer == much larger.
    priorities[feasible_mask] += fill_bonus
    

    # Normalize the priorities to the range [0, 1] for stability
    if np.any(np.isfinite(priorities)): #avoid division by zero if all are -inf
        finite_priorities = priorities[np.isfinite(priorities)]
        min_priority = np.min(finite_priorities)
        max_priority = np.max(finite_priorities)
        
        if min_priority != max_priority: # Avoid divide by zero in edge case
            priorities[np.isfinite(priorities)] = (priorities[np.isfinite(priorities)] - min_priority) / (max_priority - min_priority)

    return priorities
```
