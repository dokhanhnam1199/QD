```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version incorporates several improvements over v1:
    - Considers bin utilization rate (fullness) more effectively.
    - Introduces a small amount of randomness for diversification.
    - Adjusts priority based on the number of available bins.
    - Includes a penalty for creating very small remaining fragments.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    remaining_after_add = bins_remain_cap - item
    valid_bins = remaining_after_add >= 0

    if np.any(valid_bins):
        # Base priority: inverse of space difference
        space_diff = np.abs(remaining_after_add)
        priorities[valid_bins] = 1.0 / (space_diff[valid_bins] + 1e-9)

        # Utilization rate bonus: Favor bins that will be reasonably full
        fill_ratio_after_add = (bins_remain_cap[valid_bins] - remaining_after_add[valid_bins]) / (bins_remain_cap[valid_bins] + 1e-9)
        priorities[valid_bins] += 2 * fill_ratio_after_add  # Give more weight to fill ratio

        #Fragment penalty : Avoid bins leaving fragments smaller than 10% of the item size
        fragment_penalty = (remaining_after_add[valid_bins] < 0.1 * item).astype(float)
        priorities[valid_bins] -= 5*fragment_penalty


        # Randomization: Add a small amount of randomness to break ties and explore the solution space. The magnitude of randomness
        # is scaled down as the number of free bins increase, so as to not fully randomize selection when there are few choices.
        num_valid_bins = np.sum(valid_bins)
        randomness_factor = 0.1 / (1 + num_valid_bins) #Scale down randomness with many bins
        priorities[valid_bins] += np.random.uniform(low=-randomness_factor, high=randomness_factor, size=num_valid_bins)


        #Number of bins influence
        priorities[valid_bins] *= (1 + 0.05*np.exp(-0.01 * len(bins_remain_cap))) #slightly boost if many bins exist

    else: #No valid bins
        priorities = 1/(1+np.abs(remaining_after_add)) #Assign a score based on how close to fitting we are
    return priorities
```
