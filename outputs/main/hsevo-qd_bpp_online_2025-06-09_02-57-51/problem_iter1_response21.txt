```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Inspired by the concept of spacetime curvature in general relativity,
    this priority function considers not just the immediate fit but also
    the potential future impact on bin availability. Bins that are "almost full"
    but can still accommodate the item receive a higher priority to avoid
    fragmentation. Conversely, nearly empty bins receive lower priority
    to encourage efficient utilization of already partially filled bins.
    A small constant (epsilon) is added to avoid division by zero and to
    provide a baseline priority.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    epsilon = 1e-9  # Small constant to avoid division by zero
    bin_size = 1.0 # Assume bin size is 1.0; generalizable with an additional bin_size input

    # Calculate the waste if the item is placed in each bin
    waste = bins_remain_cap - item

    # Calculate a priority based on how 'full' the bin would become.
    # Higher priority is assigned to bins that, after placing the item,
    # are neither too full (leading to fragmentation) nor too empty.
    # A Gaussian-like function is used to model this preference, centered
    # around a sweet spot (e.g., 75% full). The sweet spot is configurable,
    # but not configured to maintain input consistency with V1
    sweet_spot = 0.75 * bin_size  # A desirable remaining capacity after placement

    priority = np.exp(-((bins_remain_cap - item - sweet_spot)**2) / (2 * (0.25 * bin_size)**2)) + epsilon #Gaussian
    
    #Adjustement based on item fit: give infinite penality if the item doesn't fit.
    priority = np.where(waste >= -epsilon, priority, -np.inf)
    
    return priority
```
