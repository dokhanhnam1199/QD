```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Uses a combination of factors to determine priority:
    1. How much space will be wasted (lower is better).
    2. How close the item's size is to the bin's remaining capacity (closer is better).
    3. Prevents using bins that are significantly larger than the item (efficiency).

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    waste = bins_remain_cap - item
    # Give very low priority to invalid bins
    waste[waste < 0] = np.inf

    # Smaller waste is better, so invert it (or subtract from a constant)
    waste_priority = 1 / (1 + waste) #Adding 1 to avoid division by zero

    #Closeness penalty: closer capacity is better, but avoids packing when cap>item
    closeness = np.abs(bins_remain_cap - item)
    closeness_priority = np.exp(-closeness / (item + 0.0001))

    # Capacity threshold: Bins significantly larger should not be prioritized
    cap_ratio = item / (bins_remain_cap + 0.0001)  # Avoid div by zero
    capacity_priority = np.where(bins_remain_cap >= item, np.exp(-5 * np.maximum(0, bins_remain_cap / item - 1)), 0)


    priorities = waste_priority * closeness_priority * capacity_priority
    return priorities
```
