```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.
    This version prioritizes bins with remaining capacity slightly larger than the item size,
    while also penalizing bins that are nearly full or too empty.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Calculate the difference between bin capacity and item size.
    diff = bins_remain_cap - item

    # Prioritize bins where the remaining capacity is close to the item size, but avoid overflow.
    # A small positive difference is ideal.
    close_enough = (diff >= 0)  # ensure we only select bins that can actually hold the item.
    priorities[close_enough] = np.exp(-np.abs(diff[close_enough]) / item)

    # Penalize near-full bins:  Very low remain_cap compared to bin_size
    near_full = (bins_remain_cap < 0.1)
    priorities[near_full] -= 10 # Large negative penalty

    # Add a small bonus for bins that are not already considered. This could
    # help distribute items more evenly. If all bins are full, then
    # near_full will apply

    too_empty = (bins_remain_cap > 2 * item)

    # Penalize those which are way to big, but avoid negatives in general.
    priorities[too_empty] -= 0.5 * (bins_remain_cap[too_empty] - 2 * item) / item

    return priorities
```
