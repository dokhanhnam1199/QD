{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, inverse_diff_epsilon: float = 9.816063462719647e-09,\n                nearly_full_bonus_weight: float = 11.372940705301689, nearly_full_exponent_scale: float = 12.350984135114247) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        inverse_diff_epsilon: Small value to avoid division by zero when calculating the inverse of the space difference.\n        nearly_full_bonus_weight: Weight of the bonus given to nearly full bins.\n        nearly_full_exponent_scale: Scaling factor in the exponent for the nearly full bonus.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Calculate remaining capacity after adding the item. Negative values indicate infeasibility.\n    remaining_after_add = bins_remain_cap - item\n\n    # Give high priority to bins that can accommodate the item, but avoid almost-full bins (first fit decreasing consideration).\n    # Slightly favor bins with space close to the item size to avoid excessive fragmentation.\n    valid_bins = remaining_after_add >= 0\n\n    if np.any(valid_bins):\n        space_diff = np.abs(remaining_after_add)\n        priorities[valid_bins] = 1.0 / (space_diff[valid_bins] + inverse_diff_epsilon)  # Inverse of difference, add small value to avoid division by zero\n        # Heuristics to promote bins that are sufficiently full (avoid too much space)\n        fill_ratios = (bins_remain_cap[valid_bins] - remaining_after_add[valid_bins]) / bins_remain_cap[valid_bins]\n\n        #Promote nearly full bins but penalize excessively small remainders\n        priorities[valid_bins] = priorities[valid_bins] + nearly_full_bonus_weight*np.exp(-nearly_full_exponent_scale*(remaining_after_add[valid_bins]/item)**2)\n\n\n    #Heuristic: Consider the overall fullness of the bins. If a bin is very full (high fill_ratio), it should receive a lower priority as that is more prone to produce unusable fragments\n    overall_fullness = (np.sum(bins_remain_cap) - np.sum(bins_remain_cap[remaining_after_add>=0]) + np.sum(item*np.ones_like(bins_remain_cap)[remaining_after_add>=0])) / np.sum(np.ones_like(bins_remain_cap) * np.max(bins_remain_cap))\n    #Consider the worst case bin that could not store the item as a dissuader\n\n    if np.sum(valid_bins) == 0:\n      priorities = 1/(1+np.abs(remaining_after_add))\n    return priorities\n\n[Heuristics 2nd]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, inverse_diff_epsilon: float = 9.816063462719647e-09,\n                nearly_full_bonus_weight: float = 11.372940705301689, nearly_full_exponent_scale: float = 12.350984135114247) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        inverse_diff_epsilon: Small value to avoid division by zero when calculating the inverse of the space difference.\n        nearly_full_bonus_weight: Weight of the bonus given to nearly full bins.\n        nearly_full_exponent_scale: Scaling factor in the exponent for the nearly full bonus.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Calculate remaining capacity after adding the item. Negative values indicate infeasibility.\n    remaining_after_add = bins_remain_cap - item\n\n    # Give high priority to bins that can accommodate the item, but avoid almost-full bins (first fit decreasing consideration).\n    # Slightly favor bins with space close to the item size to avoid excessive fragmentation.\n    valid_bins = remaining_after_add >= 0\n\n    if np.any(valid_bins):\n        space_diff = np.abs(remaining_after_add)\n        priorities[valid_bins] = 1.0 / (space_diff[valid_bins] + inverse_diff_epsilon)  # Inverse of difference, add small value to avoid division by zero\n        # Heuristics to promote bins that are sufficiently full (avoid too much space)\n        fill_ratios = (bins_remain_cap[valid_bins] - remaining_after_add[valid_bins]) / bins_remain_cap[valid_bins]\n\n        #Promote nearly full bins but penalize excessively small remainders\n        priorities[valid_bins] = priorities[valid_bins] + nearly_full_bonus_weight*np.exp(-nearly_full_exponent_scale*(remaining_after_add[valid_bins]/item)**2)\n\n\n    #Heuristic: Consider the overall fullness of the bins. If a bin is very full (high fill_ratio), it should receive a lower priority as that is more prone to produce unusable fragments\n    overall_fullness = (np.sum(bins_remain_cap) - np.sum(bins_remain_cap[remaining_after_add>=0]) + np.sum(item*np.ones_like(bins_remain_cap)[remaining_after_add>=0])) / np.sum(np.ones_like(bins_remain_cap) * np.max(bins_remain_cap))\n    #Consider the worst case bin that could not store the item as a dissuader\n\n    if np.sum(valid_bins) == 0:\n      priorities = 1/(1+np.abs(remaining_after_add))\n    return priorities\n\n[Heuristics 3rd]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, inverse_diff_epsilon: float = 9.816063462719647e-09,\n                nearly_full_bonus_weight: float = 11.372940705301689, nearly_full_exponent_scale: float = 12.350984135114247) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        inverse_diff_epsilon: Small value to avoid division by zero when calculating the inverse of the space difference.\n        nearly_full_bonus_weight: Weight of the bonus given to nearly full bins.\n        nearly_full_exponent_scale: Scaling factor in the exponent for the nearly full bonus.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Calculate remaining capacity after adding the item. Negative values indicate infeasibility.\n    remaining_after_add = bins_remain_cap - item\n\n    # Give high priority to bins that can accommodate the item, but avoid almost-full bins (first fit decreasing consideration).\n    # Slightly favor bins with space close to the item size to avoid excessive fragmentation.\n    valid_bins = remaining_after_add >= 0\n\n    if np.any(valid_bins):\n        space_diff = np.abs(remaining_after_add)\n        priorities[valid_bins] = 1.0 / (space_diff[valid_bins] + inverse_diff_epsilon)  # Inverse of difference, add small value to avoid division by zero\n        # Heuristics to promote bins that are sufficiently full (avoid too much space)\n        fill_ratios = (bins_remain_cap[valid_bins] - remaining_after_add[valid_bins]) / bins_remain_cap[valid_bins]\n\n        #Promote nearly full bins but penalize excessively small remainders\n        priorities[valid_bins] = priorities[valid_bins] + nearly_full_bonus_weight*np.exp(-nearly_full_exponent_scale*(remaining_after_add[valid_bins]/item)**2)\n\n\n    #Heuristic: Consider the overall fullness of the bins. If a bin is very full (high fill_ratio), it should receive a lower priority as that is more prone to produce unusable fragments\n    overall_fullness = (np.sum(bins_remain_cap) - np.sum(bins_remain_cap[remaining_after_add>=0]) + np.sum(item*np.ones_like(bins_remain_cap)[remaining_after_add>=0])) / np.sum(np.ones_like(bins_remain_cap) * np.max(bins_remain_cap))\n    #Consider the worst case bin that could not store the item as a dissuader\n\n    if np.sum(valid_bins) == 0:\n      priorities = 1/(1+np.abs(remaining_after_add))\n    return priorities\n\n[Heuristics 4th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, inverse_diff_epsilon: float = 9.816063462719647e-09,\n                nearly_full_bonus_weight: float = 11.372940705301689, nearly_full_exponent_scale: float = 12.350984135114247) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        inverse_diff_epsilon: Small value to avoid division by zero when calculating the inverse of the space difference.\n        nearly_full_bonus_weight: Weight of the bonus given to nearly full bins.\n        nearly_full_exponent_scale: Scaling factor in the exponent for the nearly full bonus.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Calculate remaining capacity after adding the item. Negative values indicate infeasibility.\n    remaining_after_add = bins_remain_cap - item\n\n    # Give high priority to bins that can accommodate the item, but avoid almost-full bins (first fit decreasing consideration).\n    # Slightly favor bins with space close to the item size to avoid excessive fragmentation.\n    valid_bins = remaining_after_add >= 0\n\n    if np.any(valid_bins):\n        space_diff = np.abs(remaining_after_add)\n        priorities[valid_bins] = 1.0 / (space_diff[valid_bins] + inverse_diff_epsilon)  # Inverse of difference, add small value to avoid division by zero\n        # Heuristics to promote bins that are sufficiently full (avoid too much space)\n        fill_ratios = (bins_remain_cap[valid_bins] - remaining_after_add[valid_bins]) / bins_remain_cap[valid_bins]\n\n        #Promote nearly full bins but penalize excessively small remainders\n        priorities[valid_bins] = priorities[valid_bins] + nearly_full_bonus_weight*np.exp(-nearly_full_exponent_scale*(remaining_after_add[valid_bins]/item)**2)\n\n\n    #Heuristic: Consider the overall fullness of the bins. If a bin is very full (high fill_ratio), it should receive a lower priority as that is more prone to produce unusable fragments\n    overall_fullness = (np.sum(bins_remain_cap) - np.sum(bins_remain_cap[remaining_after_add>=0]) + np.sum(item*np.ones_like(bins_remain_cap)[remaining_after_add>=0])) / np.sum(np.ones_like(bins_remain_cap) * np.max(bins_remain_cap))\n    #Consider the worst case bin that could not store the item as a dissuader\n\n    if np.sum(valid_bins) == 0:\n      priorities = 1/(1+np.abs(remaining_after_add))\n    return priorities\n\n[Heuristics 5th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    remaining_after_add = bins_remain_cap - item\n    valid_bins = remaining_after_add >= 0\n\n    if np.any(valid_bins):\n        # Prioritize bins with capacity close to item size\n        space_diff = np.abs(remaining_after_add)\n        priorities[valid_bins] = 1.0 / (space_diff[valid_bins] + 1e-9)\n\n        # Boost priority for bins that become nearly full after adding the item\n        fill_ratio_after = (bins_remain_cap[valid_bins] - remaining_after_add[valid_bins]) / np.max(bins_remain_cap)\n        priorities[valid_bins] += 5 * np.exp(-5 * (np.abs(remaining_after_add[valid_bins]) / np.max(bins_remain_cap)))\n\n        # Penalize bins that would have very small remaining capacity\n        priorities[valid_bins] -= 2 * np.exp(-5 * (bins_remain_cap[valid_bins]/item)) * (remaining_after_add[valid_bins] < 0.1*np.max(bins_remain_cap))\n\n        # Introduce randomness to diversify bin selection, favoring slightly less full bins\n        # This adds exploration to avoid getting stuck in local optima\n        relative_fill = bins_remain_cap[valid_bins] / np.max(bins_remain_cap)\n        randomness = np.random.rand(np.sum(valid_bins)) * (0.2 + 0.2*relative_fill) #Scale randomness by bin emptiness\n        priorities[valid_bins] += randomness\n    else:\n        # If no valid bins, prioritize bins with smallest required extra capacity\n        priorities = 1 / (np.abs(remaining_after_add) + 1e-9)\n        #Penalize bins that are almost empty\n        empty_bins = bins_remain_cap > 0.9*np.max(bins_remain_cap)\n        priorities[empty_bins] = priorities[empty_bins]*0.1\n\n\n    return priorities\n\n[Heuristics 6th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    remaining_after_add = bins_remain_cap - item\n    valid_bins = remaining_after_add >= 0\n\n    if np.any(valid_bins):\n        # Prioritize bins with capacity close to item size\n        space_diff = np.abs(remaining_after_add)\n        priorities[valid_bins] = 1.0 / (space_diff[valid_bins] + 1e-9)\n\n        # Boost priority for bins that become nearly full after adding the item\n        fill_ratio_after = (bins_remain_cap[valid_bins] - remaining_after_add[valid_bins]) / np.max(bins_remain_cap)\n        priorities[valid_bins] += 5 * np.exp(-5 * (np.abs(remaining_after_add[valid_bins]) / np.max(bins_remain_cap)))\n\n        # Penalize bins that would have very small remaining capacity\n        priorities[valid_bins] -= 2 * np.exp(-5 * (bins_remain_cap[valid_bins]/item)) * (remaining_after_add[valid_bins] < 0.1*np.max(bins_remain_cap))\n\n        # Introduce randomness to diversify bin selection, favoring slightly less full bins\n        # This adds exploration to avoid getting stuck in local optima\n        relative_fill = bins_remain_cap[valid_bins] / np.max(bins_remain_cap)\n        randomness = np.random.rand(np.sum(valid_bins)) * (0.2 + 0.2*relative_fill) #Scale randomness by bin emptiness\n        priorities[valid_bins] += randomness\n    else:\n        # If no valid bins, prioritize bins with smallest required extra capacity\n        priorities = 1 / (np.abs(remaining_after_add) + 1e-9)\n        #Penalize bins that are almost empty\n        empty_bins = bins_remain_cap > 0.9*np.max(bins_remain_cap)\n        priorities[empty_bins] = priorities[empty_bins]*0.1\n\n\n    return priorities\n\n[Heuristics 7th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    remaining_after_add = bins_remain_cap - item\n    valid_bins = remaining_after_add >= 0\n\n    if np.any(valid_bins):\n        # Prioritize bins with capacity close to item size\n        space_diff = np.abs(remaining_after_add)\n        priorities[valid_bins] = 1.0 / (space_diff[valid_bins] + 1e-9)\n\n        # Boost priority for bins that become nearly full after adding the item\n        fill_ratio_after = (bins_remain_cap[valid_bins] - remaining_after_add[valid_bins]) / np.max(bins_remain_cap)\n        priorities[valid_bins] += 5 * np.exp(-5 * (np.abs(remaining_after_add[valid_bins]) / np.max(bins_remain_cap)))\n\n        # Penalize bins that would have very small remaining capacity\n        priorities[valid_bins] -= 2 * np.exp(-5 * (bins_remain_cap[valid_bins]/item)) * (remaining_after_add[valid_bins] < 0.1*np.max(bins_remain_cap))\n\n        # Introduce randomness to diversify bin selection, favoring slightly less full bins\n        # This adds exploration to avoid getting stuck in local optima\n        relative_fill = bins_remain_cap[valid_bins] / np.max(bins_remain_cap)\n        randomness = np.random.rand(np.sum(valid_bins)) * (0.2 + 0.2*relative_fill) #Scale randomness by bin emptiness\n        priorities[valid_bins] += randomness\n    else:\n        # If no valid bins, prioritize bins with smallest required extra capacity\n        priorities = 1 / (np.abs(remaining_after_add) + 1e-9)\n        #Penalize bins that are almost empty\n        empty_bins = bins_remain_cap > 0.9*np.max(bins_remain_cap)\n        priorities[empty_bins] = priorities[empty_bins]*0.1\n\n\n    return priorities\n\n[Heuristics 8th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    remaining_after_add = bins_remain_cap - item\n    valid_bins = remaining_after_add >= 0\n\n    if np.any(valid_bins):\n        # Prioritize bins with capacity close to item size\n        space_diff = np.abs(remaining_after_add)\n        priorities[valid_bins] = 1.0 / (space_diff[valid_bins] + 1e-9)\n\n        # Boost priority for bins that become nearly full after adding the item\n        fill_ratio_after = (bins_remain_cap[valid_bins] - remaining_after_add[valid_bins]) / np.max(bins_remain_cap)\n        priorities[valid_bins] += 5 * np.exp(-5 * (np.abs(remaining_after_add[valid_bins]) / np.max(bins_remain_cap)))\n\n        # Penalize bins that would have very small remaining capacity\n        priorities[valid_bins] -= 2 * np.exp(-5 * (bins_remain_cap[valid_bins]/item)) * (remaining_after_add[valid_bins] < 0.1*np.max(bins_remain_cap))\n\n        # Introduce randomness to diversify bin selection, favoring slightly less full bins\n        # This adds exploration to avoid getting stuck in local optima\n        relative_fill = bins_remain_cap[valid_bins] / np.max(bins_remain_cap)\n        randomness = np.random.rand(np.sum(valid_bins)) * (0.2 + 0.2*relative_fill) #Scale randomness by bin emptiness\n        priorities[valid_bins] += randomness\n    else:\n        # If no valid bins, prioritize bins with smallest required extra capacity\n        priorities = 1 / (np.abs(remaining_after_add) + 1e-9)\n        #Penalize bins that are almost empty\n        empty_bins = bins_remain_cap > 0.9*np.max(bins_remain_cap)\n        priorities[empty_bins] = priorities[empty_bins]*0.1\n\n\n    return priorities\n\n[Heuristics 9th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    remaining_after_add = bins_remain_cap - item\n    valid_bins = remaining_after_add >= 0\n\n    if np.any(valid_bins):\n        # Prioritize bins with capacity close to item size\n        space_diff = np.abs(remaining_after_add)\n        priorities[valid_bins] = 1.0 / (space_diff[valid_bins] + 1e-9)\n\n        # Boost priority for bins that become nearly full after adding the item\n        fill_ratio_after = (bins_remain_cap[valid_bins] - remaining_after_add[valid_bins]) / np.max(bins_remain_cap)\n        priorities[valid_bins] += 5 * np.exp(-5 * (np.abs(remaining_after_add[valid_bins]) / np.max(bins_remain_cap)))\n\n        # Penalize bins that would have very small remaining capacity\n        priorities[valid_bins] -= 2 * np.exp(-5 * (bins_remain_cap[valid_bins]/item)) * (remaining_after_add[valid_bins] < 0.1*np.max(bins_remain_cap))\n\n        # Introduce randomness to diversify bin selection, favoring slightly less full bins\n        # This adds exploration to avoid getting stuck in local optima\n        relative_fill = bins_remain_cap[valid_bins] / np.max(bins_remain_cap)\n        randomness = np.random.rand(np.sum(valid_bins)) * (0.2 + 0.2*relative_fill) #Scale randomness by bin emptiness\n        priorities[valid_bins] += randomness\n    else:\n        # If no valid bins, prioritize bins with smallest required extra capacity\n        priorities = 1 / (np.abs(remaining_after_add) + 1e-9)\n        #Penalize bins that are almost empty\n        empty_bins = bins_remain_cap > 0.9*np.max(bins_remain_cap)\n        priorities[empty_bins] = priorities[empty_bins]*0.1\n\n\n    return priorities\n\n[Heuristics 10th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    remaining_after_add = bins_remain_cap - item\n    valid_bins = remaining_after_add >= 0\n\n    if np.any(valid_bins):\n        # Prioritize bins with capacity close to item size\n        space_diff = np.abs(remaining_after_add)\n        priorities[valid_bins] = 1.0 / (space_diff[valid_bins] + 1e-9)\n\n        # Boost priority for bins that become nearly full after adding the item\n        fill_ratio_after = (bins_remain_cap[valid_bins] - remaining_after_add[valid_bins]) / np.max(bins_remain_cap)\n        priorities[valid_bins] += 5 * np.exp(-5 * (np.abs(remaining_after_add[valid_bins]) / np.max(bins_remain_cap)))\n\n        # Penalize bins that would have very small remaining capacity\n        priorities[valid_bins] -= 2 * np.exp(-5 * (bins_remain_cap[valid_bins]/item)) * (remaining_after_add[valid_bins] < 0.1*np.max(bins_remain_cap))\n\n        # Introduce randomness to diversify bin selection, favoring slightly less full bins\n        # This adds exploration to avoid getting stuck in local optima\n        relative_fill = bins_remain_cap[valid_bins] / np.max(bins_remain_cap)\n        randomness = np.random.rand(np.sum(valid_bins)) * (0.2 + 0.2*relative_fill) #Scale randomness by bin emptiness\n        priorities[valid_bins] += randomness\n    else:\n        # If no valid bins, prioritize bins with smallest required extra capacity\n        priorities = 1 / (np.abs(remaining_after_add) + 1e-9)\n        #Penalize bins that are almost empty\n        empty_bins = bins_remain_cap > 0.9*np.max(bins_remain_cap)\n        priorities[empty_bins] = priorities[empty_bins]*0.1\n\n\n    return priorities\n\n[Heuristics 11th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    remaining_after_add = bins_remain_cap - item\n    valid_bins = remaining_after_add >= 0\n\n    if np.any(valid_bins):\n        # Prioritize bins with capacity close to item size\n        space_diff = np.abs(remaining_after_add)\n        priorities[valid_bins] = 1.0 / (space_diff[valid_bins] + 1e-9)\n\n        # Boost priority for bins that become nearly full after adding the item\n        fill_ratio_after = (bins_remain_cap[valid_bins] - remaining_after_add[valid_bins]) / np.max(bins_remain_cap)\n        priorities[valid_bins] += 5 * np.exp(-5 * (np.abs(remaining_after_add[valid_bins]) / np.max(bins_remain_cap)))\n\n        # Penalize bins that would have very small remaining capacity\n        priorities[valid_bins] -= 2 * np.exp(-5 * (bins_remain_cap[valid_bins]/item)) * (remaining_after_add[valid_bins] < 0.1*np.max(bins_remain_cap))\n\n        # Introduce randomness to diversify bin selection, favoring slightly less full bins\n        # This adds exploration to avoid getting stuck in local optima\n        relative_fill = bins_remain_cap[valid_bins] / np.max(bins_remain_cap)\n        randomness = np.random.rand(np.sum(valid_bins)) * (0.2 + 0.2*relative_fill) #Scale randomness by bin emptiness\n        priorities[valid_bins] += randomness\n    else:\n        # If no valid bins, prioritize bins with smallest required extra capacity\n        priorities = 1 / (np.abs(remaining_after_add) + 1e-9)\n        #Penalize bins that are almost empty\n        empty_bins = bins_remain_cap > 0.9*np.max(bins_remain_cap)\n        priorities[empty_bins] = priorities[empty_bins]*0.1\n\n\n    return priorities\n\n[Heuristics 12th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    remaining_after_add = bins_remain_cap - item\n    valid_bins = remaining_after_add >= 0\n\n    if np.any(valid_bins):\n        # Prioritize bins with capacity close to item size\n        space_diff = np.abs(remaining_after_add)\n        priorities[valid_bins] = 1.0 / (space_diff[valid_bins] + 1e-9)\n\n        # Boost priority for bins that become nearly full after adding the item\n        fill_ratio_after = (bins_remain_cap[valid_bins] - remaining_after_add[valid_bins]) / np.max(bins_remain_cap)\n        priorities[valid_bins] += 5 * np.exp(-5 * (np.abs(remaining_after_add[valid_bins]) / np.max(bins_remain_cap)))\n\n        # Penalize bins that would have very small remaining capacity\n        priorities[valid_bins] -= 2 * np.exp(-5 * (bins_remain_cap[valid_bins]/item)) * (remaining_after_add[valid_bins] < 0.1*np.max(bins_remain_cap))\n\n        # Introduce randomness to diversify bin selection, favoring slightly less full bins\n        # This adds exploration to avoid getting stuck in local optima\n        relative_fill = bins_remain_cap[valid_bins] / np.max(bins_remain_cap)\n        randomness = np.random.rand(np.sum(valid_bins)) * (0.2 + 0.2*relative_fill) #Scale randomness by bin emptiness\n        priorities[valid_bins] += randomness\n    else:\n        # If no valid bins, prioritize bins with smallest required extra capacity\n        priorities = 1 / (np.abs(remaining_after_add) + 1e-9)\n        #Penalize bins that are almost empty\n        empty_bins = bins_remain_cap > 0.9*np.max(bins_remain_cap)\n        priorities[empty_bins] = priorities[empty_bins]*0.1\n\n\n    return priorities\n\n[Heuristics 13th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines Gaussian priority with fill-up bonus and desperation handling.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap)\n    gaussian_width = np.mean(bins_remain_cap) / 5\n    gaussian_priority = np.exp(-((bins_remain_cap - item)**2) / (2 * gaussian_width**2))\n\n    remaining_after_add = bins_remain_cap - item\n    valid_bins = remaining_after_add >= 0\n\n    if np.any(valid_bins):\n      fill_ratios = (bins_remain_cap[valid_bins] - remaining_after_add[valid_bins]) / bins_remain_cap[valid_bins]\n      gaussian_priority[valid_bins] += 10*np.exp(-10*(remaining_after_add[valid_bins]/item)**2)\n    else:\n      min_cap = np.min(bins_remain_cap)\n      gaussian_priority = (bins_remain_cap == min_cap).astype(float)\n\n    randomness_strength = 0.001\n    priorities = gaussian_priority + np.random.rand(len(bins_remain_cap)) * randomness_strength\n    return priorities\n\n[Heuristics 14th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This function incorporates several factors to determine the priority:\n    1. Remaining capacity: Bins with capacity closer to the item size\n       are given higher priority (using a Gaussian-like function).  This\n       encourages filling bins reasonably well.\n    2. A \"desperation\" factor: If no bins can fit the item, prioritize\n       the least-full bin to minimize wasted space. This only applies if `item` is larger than the largest `bins_remain_cap`.\n    3.  Slight randomness:  To avoid being stuck in local optima and\n        explore slightly different packings.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Gaussian-like priority based on remaining capacity closeness to item size.\n    # The narrower the Gaussian, the more specific we are in matching item size to bin capacity.  Experiment with different widths (std).\n    gaussian_width = np.mean(bins_remain_cap)/5 #tuneable.  Smaller = more picky.\n\n    priorities = np.exp(-((bins_remain_cap - item)**2) / (2 * gaussian_width**2))\n\n\n    #Desperation: item doesn't fit in any bin. Prioritize least full bin.\n    if np.all(item > bins_remain_cap):\n\n        min_cap = np.min(bins_remain_cap)\n        priorities = (bins_remain_cap == min_cap).astype(float)  # Highest priority to least full.  Tie goes to the first.\n\n    #Add a bit of randomness to avoid local optima\n    randomness_strength = 0.001 #Tuneable. Keep very small.\n\n    priorities += np.random.rand(len(bins_remain_cap)) * randomness_strength\n    return priorities\n\n[Heuristics 15th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This function implements a more sophisticated priority scheme:\n\n    1.  **Feasibility Check:**  Bins that cannot accommodate the item receive a priority of -np.inf.\n    2.  **Remaining Capacity Ratio:** Calculate the ratio of remaining capacity *after* adding the item to the original remaining capacity. Lower ratios (bins filling up more completely) are favored. This ratio is more insightful than just looking at the original capacity or the item size.\n    3.  **Fill-Up Bias:**  Add a bonus to bins that have a remaining capacity close to the item size.  This encourages using bins that are already mostly filled.\n    4.  **Normalization:** The final priorities are scaled to the range of [0,1] to ensure stable behaviour and comparable ranges, particularly important for future extensions.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Infeasible bins get -inf priority\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] = -np.inf\n\n    # Calculate remaining capacity AFTER adding the item.\n    feasible_mask = ~infeasible_mask\n    remaining_after = bins_remain_cap[feasible_mask] - item\n\n    # Calculate Ratio: (remaining after) / (remaining before).  Favor smaller ratios\n    capacity_ratios = remaining_after / bins_remain_cap[feasible_mask]\n    \n    # Smaller ratios become larger priorities\n    priorities[feasible_mask] = -capacity_ratios  # Negate to make lower ratios have higher priority\n\n\n    # Fill-Up Bonus:  Give bonus if bin size close to item size, scaled by original bin capacity.  This promotes using partially full bins\n    fill_diff = np.abs(bins_remain_cap[feasible_mask] - item)\n    fill_bonus = np.exp(-fill_diff) # Exponential decay means closer == much larger.\n    priorities[feasible_mask] += fill_bonus\n    \n\n    # Normalize the priorities to the range [0, 1] for stability\n    if np.any(np.isfinite(priorities)): #avoid division by zero if all are -inf\n        finite_priorities = priorities[np.isfinite(priorities)]\n        min_priority = np.min(finite_priorities)\n        max_priority = np.max(finite_priorities)\n        \n        if min_priority != max_priority: # Avoid divide by zero in edge case\n            priorities[np.isfinite(priorities)] = (priorities[np.isfinite(priorities)] - min_priority) / (max_priority - min_priority)\n\n    return priorities\n\n[Heuristics 16th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines Gaussian priority with fill-up bonus and desperation handling.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap)\n    gaussian_width = np.mean(bins_remain_cap) / 5\n    gaussian_priority = np.exp(-((bins_remain_cap - item)**2) / (2 * gaussian_width**2))\n\n    remaining_after_add = bins_remain_cap - item\n    valid_bins = remaining_after_add >= 0\n\n    if np.any(valid_bins):\n      fill_ratios = (bins_remain_cap[valid_bins] - remaining_after_add[valid_bins]) / bins_remain_cap[valid_bins]\n      gaussian_priority[valid_bins] += 10*np.exp(-10*(remaining_after_add[valid_bins]/item)**2)\n    else:\n      min_cap = np.min(bins_remain_cap)\n      gaussian_priority = (bins_remain_cap == min_cap).astype(float)\n\n    randomness_strength = 0.001\n    priorities = gaussian_priority + np.random.rand(len(bins_remain_cap)) * randomness_strength\n    return priorities\n\n[Heuristics 17th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This function implements a more sophisticated priority scheme:\n\n    1.  **Feasibility Check:**  Bins that cannot accommodate the item receive a priority of -np.inf.\n    2.  **Remaining Capacity Ratio:** Calculate the ratio of remaining capacity *after* adding the item to the original remaining capacity. Lower ratios (bins filling up more completely) are favored. This ratio is more insightful than just looking at the original capacity or the item size.\n    3.  **Fill-Up Bias:**  Add a bonus to bins that have a remaining capacity close to the item size.  This encourages using bins that are already mostly filled.\n    4.  **Normalization:** The final priorities are scaled to the range of [0,1] to ensure stable behaviour and comparable ranges, particularly important for future extensions.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Infeasible bins get -inf priority\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] = -np.inf\n\n    # Calculate remaining capacity AFTER adding the item.\n    feasible_mask = ~infeasible_mask\n    remaining_after = bins_remain_cap[feasible_mask] - item\n\n    # Calculate Ratio: (remaining after) / (remaining before).  Favor smaller ratios\n    capacity_ratios = remaining_after / bins_remain_cap[feasible_mask]\n    \n    # Smaller ratios become larger priorities\n    priorities[feasible_mask] = -capacity_ratios  # Negate to make lower ratios have higher priority\n\n\n    # Fill-Up Bonus:  Give bonus if bin size close to item size, scaled by original bin capacity.  This promotes using partially full bins\n    fill_diff = np.abs(bins_remain_cap[feasible_mask] - item)\n    fill_bonus = np.exp(-fill_diff) # Exponential decay means closer == much larger.\n    priorities[feasible_mask] += fill_bonus\n    \n\n    # Normalize the priorities to the range [0, 1] for stability\n    if np.any(np.isfinite(priorities)): #avoid division by zero if all are -inf\n        finite_priorities = priorities[np.isfinite(priorities)]\n        min_priority = np.min(finite_priorities)\n        max_priority = np.max(finite_priorities)\n        \n        if min_priority != max_priority: # Avoid divide by zero in edge case\n            priorities[np.isfinite(priorities)] = (priorities[np.isfinite(priorities)] - min_priority) / (max_priority - min_priority)\n\n    return priorities\n\n[Heuristics 18th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines Gaussian priority with fill-up bonus and desperation handling.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap)\n    gaussian_width = np.mean(bins_remain_cap) / 5\n    gaussian_priority = np.exp(-((bins_remain_cap - item)**2) / (2 * gaussian_width**2))\n\n    remaining_after_add = bins_remain_cap - item\n    valid_bins = remaining_after_add >= 0\n\n    if np.any(valid_bins):\n      fill_ratios = (bins_remain_cap[valid_bins] - remaining_after_add[valid_bins]) / bins_remain_cap[valid_bins]\n      gaussian_priority[valid_bins] += 10*np.exp(-10*(remaining_after_add[valid_bins]/item)**2)\n    else:\n      min_cap = np.min(bins_remain_cap)\n      gaussian_priority = (bins_remain_cap == min_cap).astype(float)\n\n    randomness_strength = 0.001\n    priorities = gaussian_priority + np.random.rand(len(bins_remain_cap)) * randomness_strength\n    return priorities\n\n[Heuristics 19th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This function implements a more sophisticated priority scheme:\n\n    1.  **Feasibility Check:**  Bins that cannot accommodate the item receive a priority of -np.inf.\n    2.  **Remaining Capacity Ratio:** Calculate the ratio of remaining capacity *after* adding the item to the original remaining capacity. Lower ratios (bins filling up more completely) are favored. This ratio is more insightful than just looking at the original capacity or the item size.\n    3.  **Fill-Up Bias:**  Add a bonus to bins that have a remaining capacity close to the item size.  This encourages using bins that are already mostly filled.\n    4.  **Normalization:** The final priorities are scaled to the range of [0,1] to ensure stable behaviour and comparable ranges, particularly important for future extensions.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Infeasible bins get -inf priority\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] = -np.inf\n\n    # Calculate remaining capacity AFTER adding the item.\n    feasible_mask = ~infeasible_mask\n    remaining_after = bins_remain_cap[feasible_mask] - item\n\n    # Calculate Ratio: (remaining after) / (remaining before).  Favor smaller ratios\n    capacity_ratios = remaining_after / bins_remain_cap[feasible_mask]\n    \n    # Smaller ratios become larger priorities\n    priorities[feasible_mask] = -capacity_ratios  # Negate to make lower ratios have higher priority\n\n\n    # Fill-Up Bonus:  Give bonus if bin size close to item size, scaled by original bin capacity.  This promotes using partially full bins\n    fill_diff = np.abs(bins_remain_cap[feasible_mask] - item)\n    fill_bonus = np.exp(-fill_diff) # Exponential decay means closer == much larger.\n    priorities[feasible_mask] += fill_bonus\n    \n\n    # Normalize the priorities to the range [0, 1] for stability\n    if np.any(np.isfinite(priorities)): #avoid division by zero if all are -inf\n        finite_priorities = priorities[np.isfinite(priorities)]\n        min_priority = np.min(finite_priorities)\n        max_priority = np.max(finite_priorities)\n        \n        if min_priority != max_priority: # Avoid divide by zero in edge case\n            priorities[np.isfinite(priorities)] = (priorities[np.isfinite(priorities)] - min_priority) / (max_priority - min_priority)\n\n    return priorities\n\n[Heuristics 20th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This function incorporates several factors to determine the priority:\n    1. Remaining capacity: Bins with capacity closer to the item size\n       are given higher priority (using a Gaussian-like function).  This\n       encourages filling bins reasonably well.\n    2. A \"desperation\" factor: If no bins can fit the item, prioritize\n       the least-full bin to minimize wasted space. This only applies if `item` is larger than the largest `bins_remain_cap`.\n    3.  Slight randomness:  To avoid being stuck in local optima and\n        explore slightly different packings.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Gaussian-like priority based on remaining capacity closeness to item size.\n    # The narrower the Gaussian, the more specific we are in matching item size to bin capacity.  Experiment with different widths (std).\n    gaussian_width = np.mean(bins_remain_cap)/5 #tuneable.  Smaller = more picky.\n\n    priorities = np.exp(-((bins_remain_cap - item)**2) / (2 * gaussian_width**2))\n\n\n    #Desperation: item doesn't fit in any bin. Prioritize least full bin.\n    if np.all(item > bins_remain_cap):\n\n        min_cap = np.min(bins_remain_cap)\n        priorities = (bins_remain_cap == min_cap).astype(float)  # Highest priority to least full.  Tie goes to the first.\n\n    #Add a bit of randomness to avoid local optima\n    randomness_strength = 0.001 #Tuneable. Keep very small.\n\n    priorities += np.random.rand(len(bins_remain_cap)) * randomness_strength\n    return priorities\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}