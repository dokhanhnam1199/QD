{"system": "You are an expert in code review. Your task extract all threshold, weight or hardcode variable of the function make it become default parameters.", "user": "[code]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, inverse_diff_epsilon: float = 9.816063462719647e-09,\n                nearly_full_bonus_weight: float = 11.372940705301689, nearly_full_exponent_scale: float = 12.350984135114247) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        inverse_diff_epsilon: Small value to avoid division by zero when calculating the inverse of the space difference.\n        nearly_full_bonus_weight: Weight of the bonus given to nearly full bins.\n        nearly_full_exponent_scale: Scaling factor in the exponent for the nearly full bonus.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Calculate remaining capacity after adding the item. Negative values indicate infeasibility.\n    remaining_after_add = bins_remain_cap - item\n\n    # Give high priority to bins that can accommodate the item, but avoid almost-full bins (first fit decreasing consideration).\n    # Slightly favor bins with space close to the item size to avoid excessive fragmentation.\n    valid_bins = remaining_after_add >= 0\n\n    if np.any(valid_bins):\n        space_diff = np.abs(remaining_after_add)\n        priorities[valid_bins] = 1.0 / (space_diff[valid_bins] + inverse_diff_epsilon)  # Inverse of difference, add small value to avoid division by zero\n        # Heuristics to promote bins that are sufficiently full (avoid too much space)\n        fill_ratios = (bins_remain_cap[valid_bins] - remaining_after_add[valid_bins]) / bins_remain_cap[valid_bins]\n\n        #Promote nearly full bins but penalize excessively small remainders\n        priorities[valid_bins] = priorities[valid_bins] + nearly_full_bonus_weight*np.exp(-nearly_full_exponent_scale*(remaining_after_add[valid_bins]/item)**2)\n\n\n    #Heuristic: Consider the overall fullness of the bins. If a bin is very full (high fill_ratio), it should receive a lower priority as that is more prone to produce unusable fragments\n    overall_fullness = (np.sum(bins_remain_cap) - np.sum(bins_remain_cap[remaining_after_add>=0]) + np.sum(item*np.ones_like(bins_remain_cap)[remaining_after_add>=0])) / np.sum(np.ones_like(bins_remain_cap) * np.max(bins_remain_cap))\n    #Consider the worst case bin that could not store the item as a dissuader\n\n    if np.sum(valid_bins) == 0:\n      priorities = 1/(1+np.abs(remaining_after_add))\n    return priorities\n\nNow extract all threshold, weight or hardcode variable of the function make it become default parameters and give me a 'parameter_ranges' dictionary representation. Key of dict is name of variable. Value of key is a tuple in Python MUST include 2 float elements, first element is begin value, second element is end value corresponding with parameter.\n\n- Output code only and enclose your code with Python code block: ```python ... ```.\n- Output 'parameter_ranges' dictionary only and enclose your code with other Python code block: ```python ... ```."}