```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version prioritizes bins based on a combination of factors:
    1. Remaining capacity relative to item size.
    2. Overall bin utilization.
    3. A dynamic fragmentation penalty.
    4. A best-fit-decreasing inspired component.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    remaining_after_add = bins_remain_cap - item
    valid_bins = remaining_after_add >= 0

    if np.any(valid_bins):
        # Base priority: how close the fit is (smaller waste is better).  Prioritize tighter fits.
        space_diff = bins_remain_cap[valid_bins] - item
        priorities[valid_bins] = 1.0 / (space_diff + 1e-9)

        # Bin Utilization: Favor bins that are already relatively full.
        bin_utilization = (np.max(bins_remain_cap) - bins_remain_cap[valid_bins]) / (np.max(bins_remain_cap) + 1e-9)
        priorities[valid_bins] += 2 * bin_utilization  # Increase weight for utilization

        # Item-Size Consideration:  Items that are large relative to the max bin size should have a lower priority.
        item_ratio = item / (np.max(bins_remain_cap) + 1e-9)
        priorities[valid_bins] += (1 - item_ratio)

        # Fragmentation Penalty: Penalize bins that would result in very small remaining space.  Make it adaptive.
        fragmentation_penalty = np.exp(-5 * (space_diff / (item + 1e-9))**2)  # Adaptive penalty based on item size.
        priorities[valid_bins] -= fragmentation_penalty

        # Best-Fit Decreasing Inspired:  Prioritize bins such that adding the item will result in a remaining capacity
        # that is similar to the other remaining capacities.  This aims to keep bin levels relatively even.
        # Calculate standard deviation of remaining capacities after adding the item (only valid ones).
        temp_bins = bins_remain_cap.copy()
        temp_bins[valid_bins] = remaining_after_add[valid_bins]
        std_dev = np.std(temp_bins)

        # Calculate a similarity score to the std_dev. Lower difference implies better match.
        similarity_score = np.abs(space_diff - std_dev)
        priorities[valid_bins] -= similarity_score * 0.1 # A small penalty based on variance of remaining capacity
    else:
        # If no bin fits, prioritize the bin with the least wasted space (absolute difference).
        priorities = 1 / (np.abs(remaining_after_add) + 1e-9)

    return priorities
```
