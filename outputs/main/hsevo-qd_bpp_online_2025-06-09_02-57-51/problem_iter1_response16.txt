```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version prioritizes bins that are a good fit for the item,
    avoiding both bins that are much too small or much too large.
    It also adds a small random element to break ties.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    for i, cap in enumerate(bins_remain_cap):
        if cap >= item:
            # Prioritize bins where the item fits well. A good fit is one where
            # the item takes up a significant portion of the bin's capacity,
            # but also leaves some space remaining.

            # Capacity ratio: item_size / bin_capacity. Closer to 1 is better,
            # but penalize if the bin is *almost* full, to allow for future items.
            capacity_ratio = item / cap
            fit_score = np.exp(-((capacity_ratio - 0.75)**2) / 0.1) #Gaussian around 0.75

            # Remaining space penalty: penalize bins that are only slightly bigger
            # than the item, leaving very little room for future items.  Sigmoid.
            remaining_space = cap - item
            space_penalty = 1 / (1 + np.exp(-10 * (remaining_space - item * 0.1)))  # Penalize if rem space is less than 10% of item size

            priorities[i] = fit_score * (1-space_penalty) + np.random.rand()*0.001  # Add a small random number to break ties

        else:
            priorities[i] = -1e9 # Very low priority if it doesn't fit
    return priorities
```
