```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray, inverse_diff_epsilon: float = 1e-6) -> np.ndarray:
    """Calculate bin priorities, combining fill ratio, item size, and bin utilization."""
    priorities = np.zeros_like(bins_remain_cap)
    feasible_bins = bins_remain_cap >= item

    if np.any(feasible_bins):
        remaining_after_add = bins_remain_cap[feasible_bins] - item
        
        # Fill ratio prioritization
        fill_ratios = (bins_remain_cap[feasible_bins] - remaining_after_add) / bins_remain_cap[feasible_bins]
        priorities[feasible_bins] = fill_ratios

        # Item size consideration: bonus for closer fit
        space_diff = np.abs(remaining_after_add)
        priorities[feasible_bins] += 1.0 / (space_diff + inverse_diff_epsilon)
        
        # Normalize to [0, 1] to avoid magnitude dominance
        min_priority = np.min(priorities[feasible_bins])
        max_priority = np.max(priorities[feasible_bins])
        if max_priority > min_priority:
            priorities[feasible_bins] = (priorities[feasible_bins] - min_priority) / (max_priority - min_priority)

        # Bin utilization: Give empty bins a small penalty to avoid bias
        empty_bins = bins_remain_cap == np.max(bins_remain_cap)
        priorities[empty_bins] -= 0.01 #Avoid overfilling empty bins if any

    return priorities
```
