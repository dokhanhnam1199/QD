```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Combines gaussian priority with dynamic adjustments based on remaining capacity."""

    priorities = np.zeros_like(bins_remain_cap)
    
    # Gaussian priority based on difference between bin capacity and item size
    gaussian_width = np.mean(bins_remain_cap) / 5 if np.mean(bins_remain_cap) > 0 else 0.1
    gaussian_priority = np.exp(-((bins_remain_cap - item)**2) / (2 * gaussian_width**2))

    remaining_after_add = bins_remain_cap - item
    valid_bins = remaining_after_add >= 0

    if np.any(valid_bins):
        # Fill-up bonus: higher priority if bin becomes nearly full
        fill_ratio_after = (bins_remain_cap[valid_bins] - remaining_after_add[valid_bins]) / np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else 0
        gaussian_priority[valid_bins] += 5 * np.exp(-5 * (np.abs(remaining_after_add[valid_bins]) / np.max(bins_remain_cap)))

        # Dynamic randomness: adds exploration, scaled by bin emptiness. Less full bins get more randomness.
        relative_fill = bins_remain_cap[valid_bins] / np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else 0
        randomness = np.random.rand(np.sum(valid_bins)) * (0.2 + 0.2*relative_fill)
        gaussian_priority[valid_bins] += randomness
    else:
        # Desperation strategy: prioritize bins with smallest required extra capacity. Avoid almost empty bins.
        priorities = 1 / (np.abs(remaining_after_add) + 1e-9)
        empty_bins = bins_remain_cap > 0.9 * np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else np.array([False]*len(bins_remain_cap)) #Handling edge case
        priorities[empty_bins] = priorities[empty_bins] * 0.1
        gaussian_priority = priorities

    priorities = gaussian_priority
    return priorities
```
