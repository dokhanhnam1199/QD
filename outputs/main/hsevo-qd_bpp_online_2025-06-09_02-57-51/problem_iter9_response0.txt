```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version dynamically adjusts parameters based on bin characteristics and item size,
    and uses a ranking-based approach for normalization, to provide better discrimination
    between bins. It also incorporates a more aggressive fragmentation penalty and a
    refined fallback strategy.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    remaining_after_add = bins_remain_cap - item
    valid_bins = remaining_after_add >= 0

    max_bin_cap = np.max(bins_remain_cap)

    if np.any(valid_bins):
        # Base priority: inverse of wasted space, normalized by item size.
        space_diff = bins_remain_cap[valid_bins] - item
        priorities[valid_bins] = (item / (space_diff + 1e-9)) # Scale by item size

        # Bin Utilization Awareness: Favor bins with higher utilization, adaptive scaling.
        bin_utilization = (max_bin_cap - bins_remain_cap[valid_bins]) / max_bin_cap
        utilization_scale = 1 + np.mean(bin_utilization) #Adaptive Scaling
        priorities[valid_bins] += utilization_scale * bin_utilization

        # Item-Size Consideration: Adjust priority based on item size, non-linear scaling.
        item_ratio = item / max_bin_cap
        priorities[valid_bins] += (1 - item_ratio)**0.5 #Non linear scaling


        # Fragmentation Penalty: Aggressively penalize small remaining capacities, adaptive penalty
        fragmentation_penalty = np.exp(-20 * (space_diff / max_bin_cap)**2)  #Increased exponent
        penalty_scale = 1 + np.std(fragmentation_penalty) #Adaptive scale
        priorities[valid_bins] -= penalty_scale * fragmentation_penalty

        # Rank-based Normalization: Convert priorities to ranks for better discrimination
        ranked_priorities = np.zeros_like(priorities[valid_bins])
        ranked_priorities[np.argsort(priorities[valid_bins])] = np.arange(len(priorities[valid_bins]))
        priorities[valid_bins] = ranked_priorities / len(priorities[valid_bins]) #Normalize ranks

    else:
        # Fallback Strategy: prioritize bins with smallest *relative* wasted space, with capacity awareness
         priorities = item / (np.abs(remaining_after_add) + 1e-9) # Relative wasted space
         capacity_penalty = bins_remain_cap / max_bin_cap # Scale by remaining capacity
         priorities *= capacity_penalty


    return priorities
```
