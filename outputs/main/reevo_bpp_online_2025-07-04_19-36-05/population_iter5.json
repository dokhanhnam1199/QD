[
  {
    "stdout_filepath": "problem_iter4_response0.txt_stdout.txt",
    "code_path": "problem_iter4_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Prioritizes feasibility, then fullness. Aggressively reward near-full bins\n    and penalize fragmentation and wasted space, scaling rewards/penalties\n    proportionally to bin capacity. Vectorized operations for efficiency.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Calculate remaining space after placing the item. Negative values indicate item won't fit.\n    remaining_after_placement = bins_remain_cap - item\n\n    # Feasibility check: Only consider bins where the item fits.\n    feasible_bins = remaining_after_placement >= 0\n\n    if np.any(feasible_bins):\n        # Fullness reward: Higher score for bins that become fuller after placement.\n        fullness_reward = (item / bins_remain_cap) * feasible_bins  # Only apply to feasible bins. Higher score if item is large compared to bin capacity\n\n        # Fragmentation penalty: Penalize bins with significant remaining space after placement.\n        # Scale penalty by the *cube* of the remaining ratio to aggressively penalize wasted space. Using cube to penalize more.\n        fragmentation_penalty = -((remaining_after_placement / bins_remain_cap)**3) * feasible_bins\n\n        # Near-full bonus: Extra reward if the bin becomes nearly full after placement.\n        near_full_threshold = 0.2  # Define \"nearly full\" as remaining capacity <= 20% of total capacity.\n        near_full_bonus = (remaining_after_placement <= (near_full_threshold * bins_remain_cap)) * feasible_bins * 3  # Significantly boost priority if near full\n\n        # Combine rewards and penalties\n        priorities = fullness_reward + fragmentation_penalty + near_full_bonus\n\n    else:\n        # If no bin fits, assign a negative priority based on remaining capacity (prefer to open a new bin).\n        priorities = -bins_remain_cap #same approach as before\n\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response1.txt_stdout.txt",
    "code_path": "problem_iter4_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: Only consider bins that can fit the item.\n    feasible_bins = bins_remain_cap >= item\n\n    # 2. Best Fit Criterion: Prefer bins with remaining capacity closest to the item size.\n    residual_capacity = bins_remain_cap - item\n    best_fit_priority = np.where(feasible_bins, 1 / (residual_capacity + 1e-9), 0)  # Avoid division by zero\n\n    # 3. Avoid Fragmentation: Penalize bins with too much remaining capacity after placing the item.\n    fragmentation_penalty = np.where(feasible_bins, np.exp(-0.2 * residual_capacity), 0) # Exponential decay\n\n    # 4. Bonus for Almost Full Bins: Encourage filling nearly full bins.\n    almost_full_bonus = np.where(feasible_bins, np.exp(-5 * np.abs(residual_capacity)/item), 0)\n\n    # 5. Prioritize bins that are already somewhat full to avoid starting new bins unnecessarily.\n    # The more full the bin is (before adding the item), the higher the priority.  Scale by feasibility.\n    existing_fill_priority = feasible_bins * (bins_remain_cap / np.max(bins_remain_cap))\n\n    # 6. Item Size consideration: Give higher priority to bins which can fit the item perfectly or with minimal waste, relative to the item size.\n    item_size_priority = np.where(feasible_bins, np.exp(-2 * residual_capacity / item), 0)\n\n    priorities = best_fit_priority * fragmentation_penalty + almost_full_bonus + 0.1 * existing_fill_priority + 0.2 * item_size_priority\n\n    return priorities",
    "response_id": 1,
    "obj": 3.9190267251695206,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response2.txt_stdout.txt",
    "code_path": "problem_iter4_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Identify bins that can accommodate the item\n    can_accommodate = bins_remain_cap >= item\n\n    if np.any(can_accommodate):\n        # Base priority for bins that can accommodate the item\n        priorities[can_accommodate] = 1.0\n\n        # Prioritize bins with smaller remaining capacity, minimizing waste\n        remaining_capacity = bins_remain_cap[can_accommodate] - item\n        priorities[can_accommodate] += (1 - (remaining_capacity / bins_remain_cap[can_accommodate]))\n\n        # Prioritize bins where the remaining capacity is close to a certain threshold.\n        # This can be tuned.  Here, we prioritize if remaining capacity is close to 0.\n        priorities[can_accommodate] += np.exp(-5 * remaining_capacity) # exponential decay, tunable parameter\n\n        # Further bonus for bins that are already quite full (before adding the item).\n        # Avoids creating mostly empty new bins.\n        priorities[can_accommodate] += (bins_remain_cap[can_accommodate] / np.max(bins_remain_cap))\n\n    # Penalize bins that cannot accommodate the item\n    cannot_accommodate = bins_remain_cap < item\n    if np.any(cannot_accommodate):\n        # Negative priority based on how much the item exceeds the bin's capacity\n        priorities[cannot_accommodate] = - (item - bins_remain_cap[cannot_accommodate]) / item\n\n    return priorities",
    "response_id": 2,
    "obj": 86.58755484643,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response3.txt_stdout.txt",
    "code_path": "problem_iter4_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Prioritizes feasibility, then fullness. Aggressively reward near-full bins\n    and penalize fragmentation and wasted space, scaling rewards/penalties\n    proportionally to bin capacity. Vectorized operations for efficiency.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Calculate remaining space after placing the item. Negative values indicate item won't fit.\n    remaining_after_placement = bins_remain_cap - item\n\n    # Feasibility check: Only consider bins where the item fits.\n    feasible_bins = remaining_after_placement >= 0\n\n    if np.any(feasible_bins):\n        # Fullness reward: Higher score for bins that become fuller after placement.\n        fullness_reward = (item / bins_remain_cap) * feasible_bins # Only apply to feasible bins. Higher score if item is large compared to bin capacity\n\n        # Fragmentation penalty: Penalize bins with significant remaining space after placement.\n        # Scale penalty by the *square* of the remaining ratio to aggressively penalize wasted space\n        fragmentation_penalty = -((remaining_after_placement / bins_remain_cap)**3) * feasible_bins\n\n        # Near-full bonus: Extra reward if the bin becomes nearly full after placement.\n        near_full_threshold = 0.2 # Define \"nearly full\" as remaining capacity <= 20% of total capacity. Increased the threshold.\n        near_full_bonus = (remaining_after_placement <= (near_full_threshold * bins_remain_cap)) * feasible_bins * 3  # Significantly boost priority if near full, increased the factor\n\n        # Combine rewards and penalties\n        priorities = fullness_reward + fragmentation_penalty + near_full_bonus\n\n    else:\n        # If no bin fits, assign a negative priority based on remaining capacity (prefer to open a new bin).\n        priorities = -bins_remain_cap #same approach as before\n\n    return priorities",
    "response_id": 3,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response4.txt_stdout.txt",
    "code_path": "problem_iter4_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Calculate remaining space after placing the item. Negative values indicate item won't fit.\n    remaining_after_placement = bins_remain_cap - item\n\n    # High priority for bins where the item fits best (smallest waste).\n    # But only if the item *does* fit!\n    fit_indices = remaining_after_placement >= 0\n\n    if np.any(fit_indices):\n        # Prioritize bins with smaller remaining space after placement (tight fit).\n        priorities[fit_indices] = 1 / (remaining_after_placement[fit_indices] + 1e-6)  # Avoid division by zero\n\n        # Add a bonus for filling the bin close to full.\n        priorities[fit_indices] += (item / bins_remain_cap[fit_indices])\n\n    else:\n        # If no bin fits, assign a low priority based on the remaining capacity,\n        # preferring bins with smaller remaining capacity. Using a very large negative\n        # number to ensure a new bin is created if possible.\n        priorities = -bins_remain_cap\n\n    return priorities",
    "response_id": 4,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response5.txt_stdout.txt",
    "code_path": "problem_iter4_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Feasibility: Can the item fit?\n    fit_mask = bins_remain_cap >= item\n\n    # Infeasible bins get the lowest priority\n    priorities[~fit_mask] = -np.inf\n\n    # Prioritize bins where the item fits.\n    if np.any(fit_mask):\n        remaining_space = bins_remain_cap[fit_mask] - item\n\n        # Heuristic: Balance packing density with avoiding small gaps.\n        # Prioritize bins with smaller remaining space, but penalize very small gaps.\n\n        # Normalize remaining space by item size for relative comparison\n        normalized_remaining_space = remaining_space / item\n\n        # Give higher priority to bins that use more of their capacity, using exponential scaling.\n        priorities[fit_mask] = np.exp(-normalized_remaining_space)\n\n        # Penalize leaving gaps smaller than a fraction of the item size (e.g., 1/4)\n        small_gap_penalty = -0.5  # Adjust penalty as needed\n        priorities[fit_mask][normalized_remaining_space < 0.25] += small_gap_penalty\n\n        # Penalize leaving extremely small gaps even more.\n        extreme_small_gap_penalty = -1.0\n        priorities[fit_mask][normalized_remaining_space < 0.1] += extreme_small_gap_penalty\n\n        # Bonus for almost filling a bin\n        almost_full_bonus = 0.3\n        priorities[fit_mask][normalized_remaining_space < 0.05] += almost_full_bonus\n\n    return priorities",
    "response_id": 5,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response6.txt_stdout.txt",
    "code_path": "problem_iter4_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Feasibility: Can the item fit?\n    fit_mask = bins_remain_cap >= item\n\n    # Infeasible bins get the lowest priority\n    priorities[~fit_mask] = -np.inf\n\n    # Prioritize bins where the item fits.\n    if np.any(fit_mask):\n        remaining_space = bins_remain_cap[fit_mask] - item\n\n        # Heuristic: Balance packing density with avoiding small gaps.\n        # Prioritize bins with smaller remaining space, but penalize very small gaps.\n\n        # Normalize remaining space by item size for relative comparison\n        normalized_remaining_space = remaining_space / item\n\n        # Give higher priority to bins that use more of their capacity\n        priorities[fit_mask] = 1.0 - normalized_remaining_space\n\n        # Penalize leaving gaps smaller than a fraction of the item size (e.g., 1/4)\n        small_gap_penalty = -0.5  # Adjust penalty as needed\n        priorities[fit_mask][normalized_remaining_space < 0.25] += small_gap_penalty\n\n        # Penalize leaving extremely small gaps even more.\n        extreme_small_gap_penalty = -1.0\n        priorities[fit_mask][normalized_remaining_space < 0.1] += extreme_small_gap_penalty\n\n        # Bonus for bins that were already relatively full before adding the item\n        initial_fullness = bins_remain_cap[fit_mask] / np.max(bins_remain_cap)\n        priorities[fit_mask] += 0.1 * initial_fullness # Small bonus to break ties\n        \n\n    return priorities",
    "response_id": 6,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response7.txt_stdout.txt",
    "code_path": "problem_iter4_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Feasibility check: Identify bins that can accommodate the item.\n    can_accommodate = bins_remain_cap >= item\n\n    if np.any(can_accommodate):\n        # Base priority for feasible bins.\n        priorities[can_accommodate] = 1.0\n\n        # Remaining capacity after placing the item in feasible bins.\n        remaining_capacity = bins_remain_cap[can_accommodate] - item\n\n        # Prioritize bins based on how much they will be filled (utilization).\n        # Non-linear scaling to emphasize near-full bins.\n        utilization = 1 - (remaining_capacity / bins_remain_cap[can_accommodate])\n        priorities[can_accommodate] += np.power(utilization, 2)  # Squaring enhances the priority of fuller bins\n\n        # Further prioritize bins where the remaining capacity is close to zero.\n        priorities[can_accommodate] += np.exp(-5 * np.abs(remaining_capacity) / item) # Exponential scaling for proximity\n\n    # Handle bins that cannot accommodate the item (discourage overfilling).\n    cannot_accommodate = bins_remain_cap < item\n    if np.any(cannot_accommodate):\n        # Negative priority proportional to the overflow.\n        overflow = item - bins_remain_cap[cannot_accommodate]\n        # Scale the negative priority based on average bin size or the item size\n        scale = np.mean(bins_remain_cap[bins_remain_cap > 0]) if np.any(bins_remain_cap > 0) else item\n        priorities[cannot_accommodate] = -np.power(overflow / scale, 0.5) # Sublinear penalty to avoid over-penalizing\n\n    return priorities",
    "response_id": 7,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response8.txt_stdout.txt",
    "code_path": "problem_iter4_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: Disqualify bins that cannot fit the item.\n    priorities[bins_remain_cap < item] = -np.inf\n\n    # 2. Best Fit Criterion: Prioritize bins with minimal remaining space after adding the item.\n    feasible_bins = bins_remain_cap >= item\n    remaining_space = bins_remain_cap - item\n    priorities[feasible_bins] = -remaining_space[feasible_bins]  # Smaller remaining space = higher priority\n\n    # 3. Reward Near-Full Bins: Heavily prioritize bins that become almost full.\n    almost_full_threshold = 0.9\n    post_fill_ratio = (bins_remain_cap[feasible_bins] - remaining_space[feasible_bins]) / (bins_remain_cap[feasible_bins] + item - remaining_space[feasible_bins])\n    almost_full = feasible_bins & (post_fill_ratio >= almost_full_threshold)\n    priorities[almost_full] += 100\n\n    # 4. Small bonus for bins which are already relatively full to encourage reuse of bins.\n    initial_fill_ratio = 1 - (bins_remain_cap / np.max(bins_remain_cap)) if np.max(bins_remain_cap) > 0 else np.zeros_like(bins_remain_cap)\n    priorities[feasible_bins] += 10 * initial_fill_ratio[feasible_bins]\n\n    return priorities",
    "response_id": 8,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response9.txt_stdout.txt",
    "code_path": "problem_iter4_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # High priority for bins that can accommodate the item\n    can_accommodate = bins_remain_cap >= item\n    priorities[can_accommodate] = 1.0\n\n    # Prioritize bins with smaller remaining capacity (relative to bin size)\n    # among those that can fit the item.\n    remaining_ratio = (bins_remain_cap[can_accommodate] - item) / bins_remain_cap[can_accommodate]\n    priorities[can_accommodate] += (1.0 - remaining_ratio)\n\n    # Penalize bins that cannot accommodate the item, proportional to the overflow\n    cannot_accommodate = bins_remain_cap < item\n    if np.any(cannot_accommodate):\n        overflow_ratio = (item - bins_remain_cap[cannot_accommodate]) / np.mean(bins_remain_cap) if np.any(bins_remain_cap) else (item - bins_remain_cap[cannot_accommodate])\n        priorities[cannot_accommodate] = -overflow_ratio\n\n    return priorities",
    "response_id": 9,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response0.txt_stdout.txt",
    "code_path": "problem_iter5_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)  # Assuming all bins have the same max capacity\n\n    # 1. Feasibility: Only consider bins that can fit the item.\n    feasible_bins = bins_remain_cap >= item\n\n    # If no bin can fit the item, prioritize bins with the most remaining capacity\n    if not np.any(feasible_bins):\n        return bins_remain_cap / bin_capacity\n\n    # 2. Best Fit Criterion: Prefer bins with remaining capacity closest to the item size.\n    residual_capacity = bins_remain_cap - item\n    best_fit_priority = np.where(feasible_bins, 1.0 / (residual_capacity + 1e-9), 0)  # Avoid division by zero\n\n    # 3. Fragmentation Penalty: Heavily penalize bins with too much remaining capacity after placing the item.\n    fragmentation_penalty = np.where(feasible_bins, np.exp(-5 * residual_capacity / bin_capacity), 0)\n\n    # 4. Bonus for Almost Full Bins: Encourage filling nearly full bins. Non-linear scaling.\n    almost_full_bonus = np.where(feasible_bins, np.exp(-10 * np.abs(residual_capacity) / bin_capacity), 0)\n\n    # 5. Normalize Remaining Capacity\n    normalized_remaining_capacity = bins_remain_cap / bin_capacity\n\n    # 6. Explicit Penalty for Small Gaps (e.g., gaps smaller than 10% of bin capacity)\n    small_gap_penalty = np.where(feasible_bins & (residual_capacity < 0.1 * bin_capacity), -1, 0)  #Big negative score if small gap\n\n    # Combine the priorities\n    priorities = best_fit_priority * fragmentation_penalty + 2 * almost_full_bonus + small_gap_penalty\n\n    return priorities",
    "response_id": 0,
    "obj": 4.11846828879138,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response1.txt_stdout.txt",
    "code_path": "problem_iter5_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_size = np.max(bins_remain_cap)\n\n    # 1. Feasibility: Only consider bins that can fit the item.\n    feasible_bins = bins_remain_cap >= item\n\n    # If no bin is feasible, consider relative capacity.\n    if not np.any(feasible_bins):\n        return bins_remain_cap / bin_size # Return ratio of remaining capacity to bin size\n\n    # 2. Normalize remaining capacity.\n    normalized_cap = bins_remain_cap / bin_size\n\n    # 3. Best Fit Criterion: Prioritize bins with the smallest remaining capacity after placing the item.\n    residual_capacity = bins_remain_cap - item\n    best_fit_priority = np.where(feasible_bins, bin_size / (residual_capacity + 1e-9), 0) # Use bin size to scale priority.\n\n    # 4. Fragmentation Penalty: Heavily penalize small gaps after placement.\n    fragmentation_penalty = np.where(feasible_bins, np.exp(-5 * residual_capacity / bin_size), 0)\n\n    # 5. Near-Full Reward: Encourage filling bins close to full with a stronger non-linear scaling.\n    almost_full_bonus = np.where(feasible_bins, np.exp(-10 * (residual_capacity / bin_size)**2), 0)\n\n    # 6. Explicit Small Gap Penalty: Penalize remaining capacity below a certain threshold.\n    small_gap_penalty = np.where(feasible_bins & (residual_capacity < 0.1 * bin_size), -1, 0)\n\n    priorities = best_fit_priority + almost_full_bonus + fragmentation_penalty + small_gap_penalty\n    \n    #Ensure no negative priorities.\n    priorities = np.maximum(priorities, 0)\n\n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response2.txt_stdout.txt",
    "code_path": "problem_iter5_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)\n\n    # 1. Feasibility: Only consider bins that can fit the item.\n    feasible_bins = bins_remain_cap >= item\n\n    # If no bin is feasible, prioritize bins with largest remaining capacity (relative).\n    if not np.any(feasible_bins):\n      return bins_remain_cap / bin_capacity\n\n    # 2. Best Fit Criterion (emphasized): Prioritize bins with remaining capacity closest to the item size, but only if feasible.\n    residual_capacity = bins_remain_cap - item\n    best_fit_priority = np.where(feasible_bins, np.exp(-5 * np.abs(residual_capacity)), 0)  # Emphasized using exp\n\n    # 3. Fragmentation Penalty (stronger): Heavily penalize bins with too much remaining capacity.\n    fragmentation_penalty = np.where(feasible_bins, np.exp(-5 * residual_capacity / bin_capacity), 0)\n\n    # 4. Near-Full Bonus (enhanced): Significantly reward bins that become near-full after placing the item.\n    almost_full_bonus = np.where(feasible_bins, np.exp(-20 * np.abs(residual_capacity) / bin_capacity), 0) # More aggressive bonus\n\n    # 5. Explicit Small Gap Penalty: Penalize bins that leave a small gap after placing the item.\n    small_gap_penalty = np.where(feasible_bins & (residual_capacity > 0) & (residual_capacity < 0.1 * bin_capacity), -0.5, 0)\n\n    # 6. Normalize Remaining Space: To ensure consistent scaling.\n    normalized_remaining_space = bins_remain_cap / bin_capacity\n\n    priorities = (\n        best_fit_priority\n        + 0.8 * almost_full_bonus\n        + 0.3 * fragmentation_penalty\n        + small_gap_penalty # Apply penalty\n        + 0.1 * normalized_remaining_space # Add base priority\n    )\n\n    return priorities",
    "response_id": 2,
    "obj": 4.178300757877951,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response3.txt_stdout.txt",
    "code_path": "problem_iter5_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_size = np.max(bins_remain_cap)  # Assuming all bins have the same initial capacity\n\n    # 1. Feasibility: Only consider bins that can fit the item.  Infeasible bins get -inf priority\n    feasible_bins = bins_remain_cap >= item\n    priorities = np.where(feasible_bins, priorities, -np.inf)\n\n    # 2. Normalize remaining capacity for better comparison\n    normalized_remaining_cap = bins_remain_cap / bin_size\n\n    # 3. Best Fit & Fragmentation Penalty: Strongly penalize small gaps (fragmentation).\n    residual_capacity = bins_remain_cap - item\n    normalized_residual = residual_capacity / bin_size\n    \n    # Explicit penalty for small gaps; scaled by the bin size to make it relative.\n    small_gap_penalty = np.where(feasible_bins & (residual_capacity > 0) & (residual_capacity <= 0.1 * bin_size), -5, 0)\n\n    # Reward bins that are nearly full after adding the item.\n    near_full_bonus = np.where(feasible_bins, np.exp(-10 * normalized_residual), 0)\n    \n    # Prioritize bins with less remaining capacity before adding the item\n    fill_level_priority = normalized_remaining_cap\n    \n    # 4. Infeasible Bin Handling - Relative Capacity: if item doesn't fit in ANY bin, choose the bin with the largest capacity.\n    if not np.any(feasible_bins):\n        priorities = bins_remain_cap / bin_size # Use relative capacity\n        return priorities\n\n    priorities = near_full_bonus + fill_level_priority + small_gap_penalty\n    return priorities",
    "response_id": 3,
    "obj": 86.32828081372159,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response4.txt_stdout.txt",
    "code_path": "problem_iter5_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap) # Assume all bins have the same capacity\n\n    # 1. Feasibility: Only consider bins that can fit the item.\n    feasible_bins = bins_remain_cap >= item\n\n    # If no bin is feasible, prioritize based on remaining capacity relative to item size.\n    if not np.any(feasible_bins):\n         return bins_remain_cap / item\n    \n    # 2. Best Fit Criterion: Calculate remaining capacity after placing the item.\n    residual_capacity = bins_remain_cap - item\n\n    # 3. Fragmentation Penalty: Heavily penalize bins with small gaps relative to bin capacity.\n    fragmentation_penalty = np.where(feasible_bins, np.exp(-10 * residual_capacity / bin_capacity), 0)\n\n    # 4. Near-Full Bonus: Reward bins that become nearly full after placing the item.\n    near_full_bonus = np.where(feasible_bins, np.exp(-10 * np.abs(residual_capacity) / bin_capacity), 0)\n\n    # 5. Normalize Remaining Space: Give a bonus to bins that are already relatively full.\n    normalized_remaining_space = bins_remain_cap / bin_capacity\n    existing_fill_bonus = np.where(feasible_bins, normalized_remaining_space, 0)\n\n    priorities = feasible_bins * (near_full_bonus + existing_fill_bonus - fragmentation_penalty)\n\n    return priorities",
    "response_id": 4,
    "obj": 149.30195452732352,
    "exec_success": true
  }
]