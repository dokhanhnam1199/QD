[
  {
    "stdout_filepath": "problem_iter12_response0.txt_stdout.txt",
    "code_path": "problem_iter12_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        return priorities - 1.0  # Return low priority if no bin fits\n\n    residual_capacity = bins_remain_cap - item\n    bin_capacity = np.max(bins_remain_cap)\n\n    # 1. Best Fit Criterion (Exponential, item-relative)\n    best_fit_priority = np.where(feasible_bins, np.exp(-5 * np.abs(residual_capacity) / item), 0)\n\n    # 2. Fragmentation Penalty (Exponential, item-relative) - encourage smaller frag\n    fragmentation_penalty = np.where(feasible_bins, np.exp(-1 * residual_capacity / item), 0)\n\n    # 3. Encourage Filling (Bonus based on existing fill level, scaled)\n    existing_fill_level = (bin_capacity - bins_remain_cap) / bin_capacity\n    already_full_bonus = feasible_bins * existing_fill_level\n\n    # 4. Near-Full Bonus (Direct, item-relative threshold)\n    near_full_threshold = 0.1 * item\n    near_full_bonus = np.where(feasible_bins & (residual_capacity >= 0) & (residual_capacity <= near_full_threshold), 1.0, 0.0)\n    \n    # 5. Balance load among bins (variance penalty) - stronger penalty\n    bin_utilization = (bin_capacity - bins_remain_cap)/bin_capacity\n    load_imbalance_penalty = -10 * np.var(bin_utilization)\n\n    #6. Avoid creating very small fragments\n    small_fragment_penalty = np.where(feasible_bins & (residual_capacity > 0) & (residual_capacity < 0.05 * bin_capacity), -1.0, 0.0) #Avoid very small fragment\n\n    # Combine priorities additively with weights\n    priorities = (\n        best_fit_priority\n        + 0.5 * fragmentation_penalty\n        + 0.3 * already_full_bonus\n        + 0.8 * near_full_bonus\n        + 0.1 * load_imbalance_penalty\n        + 0.7 * small_fragment_penalty\n    )\n\n    return priorities",
    "response_id": 0,
    "obj": 4.188272836059035,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response1.txt_stdout.txt",
    "code_path": "problem_iter12_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        return priorities - 1.0  # Return low priority if no bin fits\n\n    residual_capacity = bins_remain_cap - item\n    bin_capacity = np.max(bins_remain_cap)\n\n    # 1. Best Fit Criterion (Exponential, item-relative)\n    best_fit_priority = np.where(feasible_bins, np.exp(-5 * np.abs(residual_capacity) / item), 0)\n\n    # 2. Fragmentation Penalty (Exponential, item-relative)\n    fragmentation_penalty = np.where(feasible_bins, np.exp(-1 * residual_capacity / item), 0)\n\n    # 3. Encourage Filling (Bonus based on existing fill level, scaled)\n    existing_fill_level = (bin_capacity - bins_remain_cap) / bin_capacity\n    already_full_bonus = feasible_bins * existing_fill_level\n\n    # 4. Near-Full Bonus (Direct, item-relative threshold)\n    near_full_threshold = 0.1 * item\n    near_full_bonus = np.where(feasible_bins & (residual_capacity >= 0) & (residual_capacity <= near_full_threshold), 1.0, 0.0)\n    \n    # 5. Balance load among bins (variance penalty)\n    bin_utilization = (bin_capacity - bins_remain_cap)/bin_capacity\n    load_imbalance_penalty = - np.var(bin_utilization)\n\n    # 6. Item Size consideration. Larger items need bins that are more empty.\n    empty_bin_bonus = np.where(feasible_bins, (bins_remain_cap / bin_capacity) * (item/bin_capacity), 0)\n\n\n    # Combine priorities additively with weights\n    priorities = (\n        best_fit_priority\n        + 0.5 * fragmentation_penalty\n        + 0.3 * already_full_bonus\n        + 0.8 * near_full_bonus\n        + 0.1 * load_imbalance_penalty\n        + 0.2 * empty_bin_bonus\n    )\n\n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response2.txt_stdout.txt",
    "code_path": "problem_iter12_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        return priorities - 1.0  # Return low priority if no bin fits\n\n    residual_capacity = bins_remain_cap - item\n    bin_capacity = np.max(bins_remain_cap)\n    bin_utilization = (bin_capacity - bins_remain_cap) / bin_capacity\n\n    # 1. Best Fit Criterion (Exponential, item-relative)\n    best_fit_priority = np.where(feasible_bins, np.exp(-5 * np.abs(residual_capacity) / item), 0)\n\n    # 2. Fragmentation Penalty (Exponential, item-relative)\n    fragmentation_penalty = np.where(feasible_bins, np.exp(-1 * residual_capacity / item), 0)\n\n    # 3. Encourage Filling (Bonus based on existing fill level, scaled)\n    existing_fill_level = bin_utilization\n    already_full_bonus = feasible_bins * existing_fill_level\n\n    # 4. Near-Full Bonus (Direct, item-relative threshold)\n    near_full_threshold = 0.1 * item\n    near_full_bonus = np.where(\n        feasible_bins & (residual_capacity >= 0) & (residual_capacity <= near_full_threshold),\n        1.0,\n        0.0,\n    )\n\n    # 5. Load balancing among bins (variance penalty); scaled by item size to normalize\n    load_imbalance_penalty = -np.var(bin_utilization) / item\n\n    # 6. Prioritize less utilized bins (inversely proportional to utilization)\n    utilization_penalty = -bin_utilization\n\n    # Combine priorities additively with weights\n    priorities = (\n        best_fit_priority\n        + 0.5 * fragmentation_penalty\n        + 0.3 * already_full_bonus\n        + 0.8 * near_full_bonus\n        + 0.1 * load_imbalance_penalty\n        + 0.2 * utilization_penalty\n    )\n\n    return priorities",
    "response_id": 2,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response3.txt_stdout.txt",
    "code_path": "problem_iter12_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    num_bins = len(bins_remain_cap)\n    bin_size = np.max(bins_remain_cap) # Assuming all bins have same capacity initially\n\n    # 1. Feasibility Mask\n    feasible_bins = bins_remain_cap >= item\n\n    # 2. Best Fit: Reward bins where item fits best\n    residual_capacity = bins_remain_cap - item\n    best_fit = np.exp(-2 * np.abs(residual_capacity) / bin_size)  # Exponential score based on residual, normalized by bin size\n    best_fit = np.where(feasible_bins, best_fit, 0)\n\n    # 3. Near-Full Reward: Encourage filling bins that are close to full after placement\n    near_full_reward = np.exp(-2 * np.abs(residual_capacity) / bin_size)\n    near_full_reward = np.where(feasible_bins, near_full_reward, 0)\n\n    # 4. Cubic Fragmentation Penalty: Heavily penalize leaving too much space\n    fragmentation_penalty = np.exp(-0.5 * (residual_capacity / bin_size)**3)\n    fragmentation_penalty = np.where(feasible_bins, fragmentation_penalty, 0)\n\n    # 5. Item Size Scaling: Scale the priority based on item size\n    item_size_factor = item\n\n    # 6. Combine Heuristics Additively with Learned Weights (Example weights)\n    w_best_fit = 0.4\n    w_near_full = 0.3\n    w_fragmentation = 0.3\n\n    priorities = w_best_fit * best_fit + w_near_full * near_full_reward + w_fragmentation * fragmentation_penalty\n    priorities = priorities * item_size_factor\n\n    # 7. Strong Penalty for Infeasibility\n    priorities = np.where(feasible_bins, priorities, -1e9) #Very small value for infeasible bins\n\n    return priorities",
    "response_id": 3,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response4.txt_stdout.txt",
    "code_path": "problem_iter12_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    num_bins = len(bins_remain_cap)\n    bin_size = 1.0  # Standard bin size, assume normalized\n\n    # Feasibility: Only consider bins that can fit the item.\n    feasible_bins = bins_remain_cap >= item\n\n    # Initialize priorities to a very small number for infeasible bins.\n    priorities = np.where(feasible_bins, 1.0, 1e-6)\n\n    # 1. Best Fit: Reward bins where the item fits with minimal remaining space.\n    residual_capacity = bins_remain_cap - item\n    best_fit_score = np.zeros(num_bins)\n    best_fit_score[feasible_bins] = np.exp(-10 * residual_capacity[feasible_bins] / bin_size)\n\n    # 2. Near-Full Reward: Give a bonus to bins that are close to being full after placing the item.\n    near_full_reward = np.zeros(num_bins)\n    near_full_reward[feasible_bins] = np.exp(-5 * np.abs(residual_capacity[feasible_bins]) / bin_size)\n\n    # 3. Fragmentation Penalty: Penalize bins that leave a significant amount of wasted space.  Cubic penalty\n    fragmentation_penalty = np.ones(num_bins)\n    fragmentation_penalty[feasible_bins] = np.clip(1 - 5 * (residual_capacity[feasible_bins] / bin_size)**3, 0.0, 1) #clip between 0 to 1\n\n\n    # Combination with learned weights (example weights)\n    w_best_fit = 0.6\n    w_near_full = 0.3\n    w_fragmentation = 0.1\n\n    # Combine multiplicatively for feasible bins\n    priorities[feasible_bins] = (best_fit_score[feasible_bins]**w_best_fit) * (near_full_reward[feasible_bins]**w_near_full) * (fragmentation_penalty[feasible_bins]**w_fragmentation)\n    \n    # Infeasibility Penalty:  Strongly penalize infeasible bins. Already done by initializing to a small value\n\n    return priorities",
    "response_id": 4,
    "obj": 4.198244914240141,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response5.txt_stdout.txt",
    "code_path": "problem_iter12_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        return priorities - 1.0  # Return low priority if no bin fits\n\n    residual_capacity = bins_remain_cap - item\n    bin_capacity = np.max(bins_remain_cap)\n\n    # 1. Best Fit Criterion (Exponential, item-relative)\n    best_fit_priority = np.where(feasible_bins, np.exp(-5 * np.abs(residual_capacity) / item), 0)\n\n    # 2. Fragmentation Penalty (Exponential, item-relative)\n    fragmentation_penalty = np.where(feasible_bins, np.exp(-1 * residual_capacity / item), 0)\n\n    # 3. Encourage Filling (Bonus based on existing fill level, scaled)\n    existing_fill_level = (bin_capacity - bins_remain_cap) / bin_capacity\n    already_full_bonus = feasible_bins * existing_fill_level\n\n    # 4. Near-Full Bonus (Direct, item-relative threshold)\n    near_full_threshold = 0.1 * item\n    near_full_bonus = np.where(feasible_bins & (residual_capacity >= 0) & (residual_capacity <= near_full_threshold), 1.0, 0.0)\n    \n    # 5. Balance load among bins (variance penalty)\n    bin_utilization = (bin_capacity - bins_remain_cap)/bin_capacity\n    load_imbalance_penalty = - np.var(bin_utilization)\n\n    # 6. Small item prefer to be together. Reward bins containing smaller items.\n    small_items_reward = np.where(feasible_bins, np.exp(-np.mean(bin_utilization)), 0) \n    # Combine priorities additively with weights\n    priorities = (\n        best_fit_priority\n        + 0.5 * fragmentation_penalty\n        + 0.3 * already_full_bonus\n        + 0.8 * near_full_bonus\n        + 0.1 * load_imbalance_penalty\n        + 0.2 * small_items_reward\n    )\n\n    return priorities",
    "response_id": 5,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response6.txt_stdout.txt",
    "code_path": "problem_iter12_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: Only consider bins that can fit the item.\n    feasible_bins = bins_remain_cap >= item\n\n    # 2. Best Fit Criterion: Prefer bins with remaining capacity closest to the item size.\n    residual_capacity = bins_remain_cap - item\n    best_fit_priority = np.where(feasible_bins, np.exp(-2 * np.abs(residual_capacity)), 0)\n\n    # 3. Avoid Fragmentation: Penalize bins with too much remaining capacity after placing the item.\n    fragmentation_penalty = np.where(feasible_bins, np.exp(-0.1 * residual_capacity), 1) # slightly reduce\n\n    # 4. Bonus for Almost Full Bins: Encourage filling nearly full bins.\n    almost_full_bonus = np.where(feasible_bins & (residual_capacity >=0) & (residual_capacity < 0.1), 1.0, 0) # if nearly full\n\n    # 5. Prioritize bins that are already somewhat full to avoid starting new bins unnecessarily.\n    existing_fill_level = (np.max(bins_remain_cap) - bins_remain_cap) / np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else 0\n    existing_fill_priority = feasible_bins * existing_fill_level\n\n    priorities = best_fit_priority * fragmentation_penalty + 0.8 * almost_full_bonus + 0.1 * existing_fill_priority\n\n    return priorities",
    "response_id": 6,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response7.txt_stdout.txt",
    "code_path": "problem_iter12_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    num_bins = len(bins_remain_cap)\n    bin_size = np.max(bins_remain_cap) # Assuming all bins have same capacity initially\n\n    # 1. Feasibility Mask\n    feasible_bins = bins_remain_cap >= item\n\n    # 2. Best Fit: Reward bins where item fits best\n    residual_capacity = bins_remain_cap - item\n    best_fit = np.where(feasible_bins, np.exp(-2 * np.abs(residual_capacity / bin_size)), 0)  # Exponential score based on residual, scaled by bin_size\n\n    # 3. Near-Full Reward: Encourage filling bins that are close to full after placement\n    near_full_reward = np.where(feasible_bins, np.exp(-2 * np.abs(residual_capacity) / bin_size), 0)\n\n    # 4. Cubic Fragmentation Penalty: Heavily penalize leaving too much space\n    fragmentation_penalty = np.where(feasible_bins, np.exp(-0.5 * (residual_capacity / bin_size)**3), 1e-6)  # Cubic penalty scaled by bin size\n\n    # 5. Item Size Scaling: Scale the priority based on item size. Normalize by bin size.\n    item_size_factor = item / bin_size\n\n    # 6. Combine Heuristics Multiplicatively with Learned Weights (Example weights)\n    w_best_fit = 0.4\n    w_near_full = 0.3\n    w_fragmentation = 0.3\n\n    priorities = (w_best_fit * best_fit + 1e-9) * (w_near_full * near_full_reward + 1e-9) * (w_fragmentation * fragmentation_penalty + 1e-9) * (0.1 + item_size_factor)\n\n    # 7. Strong Penalty for Infeasibility\n    priorities = np.where(feasible_bins, priorities, -1e9) #Very small value for infeasible bins\n\n    return priorities",
    "response_id": 7,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response8.txt_stdout.txt",
    "code_path": "problem_iter12_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)\n\n    # 1. Feasibility: Only consider bins that can fit the item.\n    feasible_bins = bins_remain_cap >= item\n\n    # 2. Best Fit Criterion: Favor bins where remaining capacity is close to the item size.\n    residual_capacity = bins_remain_cap - item\n    best_fit_priority = np.where(feasible_bins, 1 / (1 + np.abs(residual_capacity)), 0)\n\n    # 3. Fragmentation Penalty: Penalize leaving too much empty space.\n    fragmentation_penalty = np.where(feasible_bins, np.exp(-2 * residual_capacity / bin_capacity), 0)\n\n    # 4. Near-Full Bonus: Reward filling bins that are close to being full.\n    near_full_bonus = np.where(feasible_bins, np.exp(-5 * np.abs(residual_capacity) / bin_capacity), 0)\n\n    # 5. Existing Fill Level: Prioritize bins that are already somewhat full.\n    existing_fill_level = np.where(feasible_bins, bins_remain_cap / bin_capacity, 0)\n\n    # 6. Item Size Ratio: Consider the ratio of item size to remaining bin capacity.\n    item_size_ratio = np.where(feasible_bins, item / (bins_remain_cap + 1e-9), 0)\n\n    # Combine the priorities additively with weights\n    priorities = (\n        0.4 * best_fit_priority\n        + 0.2 * fragmentation_penalty\n        + 0.15 * near_full_bonus\n        + 0.15 * existing_fill_level\n        + 0.1 * item_size_ratio\n    )\n\n    return priorities",
    "response_id": 8,
    "obj": 4.058635819704831,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response9.txt_stdout.txt",
    "code_path": "problem_iter12_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: Only consider bins that can fit the item.\n    feasible_bins = bins_remain_cap >= item\n\n    # 2. Best Fit Criterion: Prefer bins with remaining capacity closest to the item size.\n    residual_capacity = bins_remain_cap - item\n    best_fit_priority = np.where(feasible_bins, np.exp(-np.abs(residual_capacity) / (item + 1e-9)), 0)\n\n    # 3. Avoid Fragmentation: Penalize bins with too much remaining capacity after placing the item.\n    fragmentation_penalty = np.where(feasible_bins, np.exp(-0.1 * residual_capacity), 0)\n\n    # 4. Bonus for Almost Full Bins: Encourage filling nearly full bins.\n    almost_full_bonus = np.where(feasible_bins, np.exp(-2 * np.abs(residual_capacity) / (item + 1e-9)), 0)\n\n    # 5. Prioritize bins that are already somewhat full to avoid starting new bins unnecessarily. Normalize by item size.\n    existing_fill_priority = np.where(feasible_bins, (bins_remain_cap - residual_capacity) / (np.max(bins_remain_cap) + 1e-9), 0)\n\n    # 6. Item Size consideration: Give higher priority to bins which can fit the item perfectly or with minimal waste, relative to the item size.\n    item_size_priority = np.where(feasible_bins, np.exp(-1 * residual_capacity / (item + 1e-9)), 0)\n\n    # Combine priorities with weights\n    w_best_fit = 0.4\n    w_fragmentation = 0.1\n    w_almost_full = 0.3\n    w_existing_fill = 0.1\n    w_item_size = 0.1\n\n    priorities = (w_best_fit * best_fit_priority +\n                  w_fragmentation * fragmentation_penalty +\n                  w_almost_full * almost_full_bonus +\n                  w_existing_fill * existing_fill_priority +\n                  w_item_size * item_size_priority)\n\n    return priorities",
    "response_id": 9,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter13_response0.txt_stdout.txt",
    "code_path": "problem_iter13_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)\n\n    # 1. Feasibility: Only consider bins that can fit the item.\n    feasible_bins = bins_remain_cap >= item\n\n    # 2. Remaining capacity ratio relative to item size. Clipped to avoid extreme values.\n    remaining_ratio = np.clip(bins_remain_cap / item, 0, 5)  # Clip to reasonable range\n\n    # 3. Best Fit - Additive bonus based on how well the item fits.\n    best_fit_bonus = np.where(feasible_bins, np.exp(-np.abs(bins_remain_cap - item) / item), 0)\n\n    # 4. Load Balancing - Prioritize bins with higher remaining capacity *relative to overall bin size*.\n    load_balance_bonus = bins_remain_cap / bin_capacity\n\n    # 5. Avoid Fragmentation - Penalty for leaving too much space *relative to item size*\n    frag_penalty = np.where(feasible_bins, np.exp(-bins_remain_cap / item), 0)\n\n    priorities = (\n        best_fit_bonus\n        + 0.2 * load_balance_bonus\n        - 0.1 * frag_penalty\n    )\n\n    return priorities",
    "response_id": 0,
    "obj": 4.068607897885915,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter13_response1.txt_stdout.txt",
    "code_path": "problem_iter13_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_size = np.max(bins_remain_cap) # added\n\n    # 1. Feasibility: Only consider bins that can fit the item.\n    feasible_bins = bins_remain_cap >= item\n\n    # 2. Residual Capacity: Scaled by item size.\n    residual_capacity = bins_remain_cap - item\n    scaled_residual = np.clip(residual_capacity / item, 0, 2) #clip scaled value\n    residual_priority = np.where(feasible_bins, 1 - scaled_residual/2, 0)\n\n    # 3. Load Balancing: Target bins with mid-range occupancy.\n    occupancy = (bin_size - bins_remain_cap) / bin_size # added, normalized occupancy\n    load_balance_bonus = np.exp(-((occupancy - 0.5)**2) / 0.1) * feasible_bins # Gaussian around 0.5\n\n    # 4. Direct Bonus: Small bonus if item fits snugly\n    snug_fit_bonus = np.where(feasible_bins & (residual_capacity <= 0.1 * item), 0.5, 0)\n\n    #Combine the features\n    priorities = residual_priority + 0.2 * load_balance_bonus + 0.3 * snug_fit_bonus\n\n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter13_response2.txt_stdout.txt",
    "code_path": "problem_iter13_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)  # Assume all bins have same initial capacity\n\n    # 1. Feasibility: Only consider bins that can fit the item.\n    feasible_bins = bins_remain_cap >= item\n\n    # 2. Remaining Capacity Priority (scaled by item size): Favor bins with tighter fit.\n    # Normalize residual capacity by item size and bin capacity. Clip to [0, 1].\n    residual_capacity = bins_remain_cap - item\n    normalized_residual = np.clip(residual_capacity / bin_capacity, 0, 1) # normalize to bin size\n    remaining_cap_priority = np.where(feasible_bins, 1 - normalized_residual, 0) # normalized to bin size\n\n    # 3. Load Balancing: Give a bonus to bins with less remaining capacity relative to mean\n    mean_remaining_cap = np.mean(bins_remain_cap)\n    load_balance_bonus = np.where(feasible_bins, np.exp(-2 * np.maximum(0, mean_remaining_cap - bins_remain_cap) / bin_capacity), 0) #compare to mean.\n\n    # 4. Direct Bonus: If the item fits perfectly (or nearly so), give a significant bonus.\n    perfect_fit_bonus = np.where(feasible_bins & (residual_capacity >= 0) & (residual_capacity <= 0.1 * item), 0.5, 0) #relative to item\n\n    # 5. Prioritize partly full bins, prevent extreme values with clipped feature\n    fill_level = np.clip((bin_capacity - bins_remain_cap)/bin_capacity, 0, 1) #relative to bin size\n    partly_full_bonus = np.where(feasible_bins, fill_level, 0)\n\n    priorities = remaining_cap_priority + 0.3 * load_balance_bonus + perfect_fit_bonus + 0.1 * partly_full_bonus\n    return priorities",
    "response_id": 2,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter13_response3.txt_stdout.txt",
    "code_path": "problem_iter13_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap) #Assumed same capacity for all bins\n\n    # 1. Feasibility: Only consider bins that can fit the item.\n    feasible_bins = bins_remain_cap >= item\n\n    # 2. Residual Capacity Priority: Favor bins where residual capacity after placing the item is small.\n    residual_capacity = np.clip((bins_remain_cap - item) / bin_capacity, 0, 1)  # Normalized, clipped\n    residual_priority = np.where(feasible_bins, 1 - residual_capacity, 0) # Higher priority for lower residual\n\n    # 3. Load Balancing: Give a bonus to bins that are less full. Normalize by max bin capacity.\n    load_priority = np.clip(bins_remain_cap / bin_capacity, 0, 1) # Normalize remaining capacity\n    load_priority = 1-load_priority\n    load_priority = np.where(feasible_bins, load_priority,0)\n\n    # 4. Bonus for good fit relative to the item. Clip and scale.\n    fit_score = np.clip((item - (bins_remain_cap - item))/item,0,1) #How much is wasted relative to item size\n    fit_bonus = np.where(feasible_bins, 1-fit_score, 0)\n\n\n    priorities = residual_priority + 0.5 * load_priority + 0.3 * fit_bonus\n\n\n    return priorities",
    "response_id": 3,
    "obj": 7.239728759473488,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter13_response4.txt_stdout.txt",
    "code_path": "problem_iter13_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_size = np.max(bins_remain_cap)  # Assuming all bins have the same size\n    # 1. Feasibility: Only consider bins that can fit the item.\n    feasible_bins = bins_remain_cap >= item\n\n    # 2. Residual Capacity Priority (Scaled to item size)\n    residual_capacity = bins_remain_cap - item\n    residual_capacity_normalized = np.clip(residual_capacity / item, 0, 1)  # Normalize and clip\n    residual_priority = np.where(feasible_bins, 1 - residual_capacity_normalized, 0)  # Higher priority for smaller residual\n\n    # 3. Fill-Level Bonus (Favor bins that are already somewhat full)\n    fill_level = (bin_size - bins_remain_cap) / bin_size  # Fraction of bin already filled\n    fill_level_bonus = np.clip(fill_level, 0, 1) * feasible_bins  # Bonus scaled by fill level\n\n    # 4. Load Balancing (Encourage using less full bins)\n    load_balancing_bonus = (bins_remain_cap / bin_size) * feasible_bins\n\n    # Combine priorities with additive bonuses and scaling\n    priorities = residual_priority + 0.2 * fill_level_bonus + 0.1 * load_balancing_bonus\n    return priorities",
    "response_id": 4,
    "obj": 4.048663741523748,
    "exec_success": true
  }
]