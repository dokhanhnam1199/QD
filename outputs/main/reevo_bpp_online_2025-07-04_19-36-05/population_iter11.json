[
  {
    "stdout_filepath": "problem_iter10_response0.txt_stdout.txt",
    "code_path": "problem_iter10_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        return priorities - 1.0  # Return low priority if no bin fits\n\n    residual_capacity = bins_remain_cap - item\n    bin_capacity = np.max(bins_remain_cap)\n\n    # 1. Best Fit Criterion (Exponential, item-relative)\n    best_fit_priority = np.where(feasible_bins, np.exp(-5 * np.abs(residual_capacity) / item), 0)\n\n    # 2. Fragmentation Penalty (Exponential, item-relative)\n    fragmentation_penalty = np.where(feasible_bins, np.exp(-1 * residual_capacity / item), 0)\n\n    # 3. Encourage Filling (Bonus based on existing fill level, scaled)\n    existing_fill_level = bins_remain_cap / bin_capacity\n    already_full_bonus = feasible_bins * existing_fill_level\n\n    # 4. Near-Full Bonus (Direct, item-relative threshold)\n    near_full_threshold = 0.1 * item\n    near_full_bonus = np.where(feasible_bins & (residual_capacity >= 0) & (residual_capacity <= near_full_threshold), 1.0, 0.0)\n    \n    # 5. Balance load among bins (variance penalty)\n    bin_utilization = (bin_capacity - bins_remain_cap)/bin_capacity\n    load_imbalance_penalty = - np.var(bin_utilization)\n\n\n    # Combine priorities additively with weights\n    priorities = (\n        best_fit_priority\n        + 0.5 * fragmentation_penalty\n        + 0.3 * already_full_bonus\n        + 0.8 * near_full_bonus\n        + 0.1 * load_imbalance_penalty\n    )\n\n    return priorities",
    "response_id": 0,
    "obj": 3.9389708815317115,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response1.txt_stdout.txt",
    "code_path": "problem_iter10_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap) # Assume all bins have same capacity\n    \n    # 1. Feasibility: Only consider bins that can fit the item. Infeasible bins get a very large negative priority.\n    feasible_bins = bins_remain_cap >= item\n    priorities = np.where(~feasible_bins, -1e9, 0) # Penalize infeasible bins harshly.\n\n    # 2. Best Fit Criterion: Prioritize bins where residual capacity is small (item-relative scaling).\n    residual_capacity = bins_remain_cap - item\n    best_fit_priority = np.where(feasible_bins, np.exp(-5 * residual_capacity / item), 0)\n\n    # 3. Fragmentation Avoidance: Heavily penalize leaving too much space (cubic penalty, bin-relative).\n    fragmentation_penalty = np.where(feasible_bins, np.exp(-10 * (residual_capacity / bin_capacity)**3), 1)\n\n    # 4. Reward Near-Full Bins: Directly reward bins close to being full after placement (bin-relative).\n    near_full_reward = np.where(feasible_bins, np.exp(-5 * np.abs(residual_capacity / bin_capacity)), 0)\n\n    # 5. Learned Weights (Illustrative): These would ideally be learned.\n    w_best_fit = 0.5\n    w_fragmentation = 0.25\n    w_near_full = 0.25\n\n    # 6. Combine Heuristics Multiplicatively (with feasibility check):\n    priorities = np.where(feasible_bins, w_best_fit * best_fit_priority + w_fragmentation * fragmentation_penalty + w_near_full * near_full_reward, priorities)\n\n    # 7. Directly Reward Almost Full (even more direct than near_full_reward, bin-relative).\n    almost_full_bonus = np.where(feasible_bins & (residual_capacity <= 0.1 * bin_capacity), 0.5, 0.0) # Binary Reward (stronger)\n    priorities = np.where(almost_full_bonus>0, priorities+almost_full_bonus, priorities) # Add bonus directly\n\n    # 8. Bonus for filling a bin completely.\n    full_bin_bonus = np.where(feasible_bins & (residual_capacity == 0), 1.0, 0.0)\n    priorities = np.where(full_bin_bonus > 0, priorities + full_bin_bonus, priorities)\n    \n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response2.txt_stdout.txt",
    "code_path": "problem_iter10_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)  # Assume all bins have same capacity\n\n    # 1. Feasibility: Only consider bins that can fit the item. Infeasible bins get a very large negative priority.\n    feasible_bins = bins_remain_cap >= item\n    priorities = np.where(~feasible_bins, -1e9, 0)  # Penalize infeasible bins harshly.\n\n    # 2. Best Fit Criterion: Prioritize bins where residual capacity is small (item-relative scaling).\n    residual_capacity = bins_remain_cap - item\n    best_fit_priority = np.where(feasible_bins, np.exp(-5 * residual_capacity / item), 1e-9)\n\n    # 3. Fragmentation Avoidance: Heavily penalize leaving too much space (cubic penalty).\n    fragmentation_penalty = np.where(feasible_bins, np.exp(-10 * (residual_capacity / bin_capacity)**3), 1e-9)\n\n    # 4. Reward Near-Full Bins: Directly reward bins close to being full after placement.\n    near_full_reward = np.where(feasible_bins, np.exp(-5 * np.abs(residual_capacity / bin_capacity)), 1e-9)\n\n    # 5. Learned Weights (Illustrative): These would ideally be learned.\n    w_best_fit = 0.6\n    w_fragmentation = 0.2\n    w_near_full = 0.2\n\n    # 6. Combine Heuristics Multiplicatively:\n    priorities = np.where(feasible_bins, w_best_fit * best_fit_priority * w_fragmentation * fragmentation_penalty * w_near_full * near_full_reward, priorities)\n\n    # 7. Directly Reward Almost Full (even more direct than near_full_reward).\n    almost_full_bonus = np.where(feasible_bins & (residual_capacity <= 0.1 * bin_capacity), 1.0, 0.0)  # Binary Reward\n    priorities = np.where(almost_full_bonus > 0, priorities + 1, priorities)\n\n    return priorities",
    "response_id": 2,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response3.txt_stdout.txt",
    "code_path": "problem_iter10_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Feasibility check\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        return priorities - 1.0  # Return low priority if no bin fits\n\n    # Residual capacity after placing the item\n    residual_capacity = bins_remain_cap - item\n\n    # 1. Best Fit Criterion (Exponential, scaled by item size)\n    best_fit_priority = np.where(feasible_bins, np.exp(-5 * np.abs(residual_capacity) / item), 0)\n\n    # 2. Fragmentation Penalty (Exponential, scaled by item size)\n    fragmentation_penalty = np.where(feasible_bins, np.exp(-1 * residual_capacity / item), 0)\n\n    # 3. Reward bins close to being full after placement\n    near_full_threshold = 0.2 * item  # Increased threshold for near-full\n    near_full_bonus = np.where((residual_capacity >= 0) & (residual_capacity <= near_full_threshold), 1.5, 0.0)  # Increased bonus\n\n    # Combine priorities with adjusted weights\n    priorities = (\n        best_fit_priority\n        + 0.5 * fragmentation_penalty\n        + 1.0 * near_full_bonus\n    )\n\n    return priorities",
    "response_id": 3,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response4.txt_stdout.txt",
    "code_path": "problem_iter10_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: Only consider bins that can fit the item.\n    feasible_bins = bins_remain_cap >= item\n\n    # 2. Best Fit Criterion: Prefer bins with remaining capacity closest to the item size.  Higher the score if the fit is better.\n    residual_capacity = bins_remain_cap - item\n    best_fit_priority = np.where(feasible_bins, np.exp(-5 * np.abs(residual_capacity)), 0)\n\n    # 3. Encourage Existing Bin Fill: The fuller a bin is, the more preferable to add the new item.\n    existing_fill_priority = feasible_bins * (1 - bins_remain_cap / np.max(bins_remain_cap))\n\n    # 4. Item-Relative Waste Consideration: Penalize bins based on the waste *relative to item size*\n    item_relative_waste_penalty = np.where(feasible_bins, np.exp(-2 * residual_capacity / item), 0)\n\n    # Combine the priorities\n    priorities = best_fit_priority + 0.5 * existing_fill_priority + 0.3 * item_relative_waste_penalty\n\n    return priorities",
    "response_id": 4,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response5.txt_stdout.txt",
    "code_path": "problem_iter10_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_size = np.max(bins_remain_cap)\n\n    # 1. Feasibility: Only consider bins that can fit the item. Infeasible bins get a large negative priority.\n    feasible_bins = bins_remain_cap >= item\n    priorities = np.where(~feasible_bins, -1e9, priorities)\n\n    # 2. Best Fit Criterion: Prefer bins with remaining capacity closest to the item size. Scale by bin size.\n    residual_capacity = bins_remain_cap - item\n    best_fit_priority = np.where(feasible_bins, np.exp(-5 * np.abs(residual_capacity) / bin_size), 0)\n\n    # 3. Avoid Fragmentation: Penalize bins with too much remaining capacity after placing the item. Scale penalty by item size. Make it cubic to penalize more heavily.\n    fragmentation_penalty = np.where(feasible_bins, -10 * (residual_capacity / bin_size)**3 * (item / bin_size), 0)\n\n    # 4. Reward Existing Fill Levels: Prioritize bins that are already somewhat full to avoid starting new bins unnecessarily. Scale by item size.\n    existing_fill_level = (bin_size - bins_remain_cap) / bin_size\n    existing_fill_priority = np.where(feasible_bins, 2 * existing_fill_level * (item / bin_size), 0)\n\n    # 5. Item Size Fit: Give a bonus if the item fits snugly (e.g., fills over 80% of remaining capacity).\n    snug_fit_threshold = 0.2 * bin_size  # Item takes up at least 80% of remaining\n    snug_fit_bonus = np.where(feasible_bins & (residual_capacity <= snug_fit_threshold) , 5 * (item / bin_size), 0)\n\n    # Combine priorities\n    priorities = best_fit_priority + fragmentation_penalty + existing_fill_priority + snug_fit_bonus\n\n    return priorities",
    "response_id": 5,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response6.txt_stdout.txt",
    "code_path": "problem_iter10_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Feasibility check\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        return priorities - 1.0  # Return low priority if no bin fits\n\n    # Residual capacity after placing the item\n    residual_capacity = bins_remain_cap - item\n\n    # 1. Best Fit Criterion (Exponential, scaled by item size)\n    best_fit_priority = np.where(feasible_bins, np.exp(-5 * np.abs(residual_capacity) / item), 0)\n\n    # 2. Fragmentation Penalty (Exponential, scaled by item size)\n    fragmentation_penalty = np.where(feasible_bins, np.exp(-1 * residual_capacity / item), 0)\n\n    # 3. Encourage Filling (Bonus based on current fill level relative to item size)\n    max_cap = np.max(bins_remain_cap)\n    existing_fill_level = (max_cap - bins_remain_cap) / max_cap if max_cap > 0 else 0\n    already_full_bonus = feasible_bins * existing_fill_level\n\n    # 4. Reward bins close to being full after placement\n    near_full_threshold = 0.2 * item  # Adjusted threshold\n    near_full_bonus = np.where(\n        (residual_capacity >= 0) & (residual_capacity <= near_full_threshold),\n        np.exp(-residual_capacity/item),\n        0.0,\n    )\n\n    # Combine priorities with adjusted weights\n    priorities = (\n        best_fit_priority\n        + 0.5 * fragmentation_penalty\n        + 0.4 * already_full_bonus\n        + 0.8 * near_full_bonus\n    )\n\n    return priorities",
    "response_id": 6,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response7.txt_stdout.txt",
    "code_path": "problem_iter10_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap) # Assume all bins have same capacity\n    \n    # 1. Feasibility: Only consider bins that can fit the item. Infeasible bins get a very large negative priority.\n    feasible_bins = bins_remain_cap >= item\n    priorities = np.where(~feasible_bins, -1e9, 0) # Penalize infeasible bins harshly.\n\n    # 2. Best Fit Criterion: Prioritize bins where residual capacity is small (bin-relative scaling).\n    residual_capacity = bins_remain_cap - item\n    best_fit_priority = np.where(feasible_bins, np.exp(-5 * residual_capacity / bin_capacity), 0)\n\n    # 3. Fragmentation Avoidance: Heavily penalize leaving too much space (cubic penalty, bin-relative). Stronger penalty.\n    fragmentation_penalty = np.where(feasible_bins, np.exp(-20 * (residual_capacity / bin_capacity)**3), 1)\n\n    # 4. Reward Near-Full Bins: Directly reward bins close to being full after placement (bin-relative).\n    near_full_reward = np.where(feasible_bins, np.exp(-5 * np.abs(residual_capacity / bin_capacity)), 0)\n\n    # 5. Learned Weights (Illustrative): These would ideally be learned.\n    w_best_fit = 0.6\n    w_fragmentation = 0.2\n    w_near_full = 0.2\n\n    # 6. Combine Heuristics Multiplicatively:\n    priorities = np.where(feasible_bins, w_best_fit * best_fit_priority * w_fragmentation * fragmentation_penalty + w_near_full * near_full_reward, priorities)\n\n    # 7. Directly Reward Almost Full (even more direct than near_full_reward).\n    almost_full_bonus = np.where(feasible_bins & (residual_capacity <= 0.1 * bin_capacity), 1.0, 0.0) # Binary Reward\n    priorities = np.where(almost_full_bonus>0, priorities+1, priorities)\n\n    # 8. Slightly prefer to use bins that already have some items in them (reduce number of bins used)\n    # Only apply this bonus when there are feasible bins, and the item is not too small.\n    existing_item_bonus = np.where(feasible_bins & (bins_remain_cap < bin_capacity) & (item > 0.1 * bin_capacity), 0.1, 0.0)\n    priorities = priorities + existing_item_bonus\n    \n\n    return priorities",
    "response_id": 7,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response8.txt_stdout.txt",
    "code_path": "problem_iter10_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Feasibility check\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        return priorities - 1.0  # Return low priority if no bin fits\n\n    # Residual capacity after placing the item\n    residual_capacity = bins_remain_cap - item\n\n    # 1. Best Fit Criterion (Exponential, scaled by item size) - Increased importance\n    best_fit_priority = np.where(feasible_bins, np.exp(-7 * np.abs(residual_capacity) / item), 0)\n\n    # 2. Fragmentation Penalty (Exponential, scaled by item size) - Slightly reduced\n    fragmentation_penalty = np.where(feasible_bins, np.exp(-0.75 * residual_capacity / item), 0)\n\n    # 3. Encourage Filling (Bonus based on current fill level) - Increased, also scale item size\n    max_cap = np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else 1 # avoid division by zero if all bins are empty\n    existing_fill_level = (max_cap - bins_remain_cap) / max_cap # fill level, normalized between 0 and 1.\n    already_full_bonus = feasible_bins * existing_fill_level * (item / max_cap)\n\n    # 4. Reward bins close to being full after placement - Adjusted threshold and bonus\n    near_full_threshold = 0.15 * item # increased threshold\n    near_full_bonus = np.where((residual_capacity >= 0) & (residual_capacity <= near_full_threshold), 1.2, 0.0) # increased bonus\n\n    # 5. Item size consideration : prefer bins that fit item snugly.\n    snug_fit_bonus = np.where(feasible_bins, np.exp(-3 * (bins_remain_cap - item) / bins_remain_cap),0)\n\n    # Combine priorities with adjusted weights\n    priorities = (\n        1.2 * best_fit_priority\n        + 0.5 * fragmentation_penalty\n        + 0.6 * already_full_bonus\n        + 0.9 * near_full_bonus\n        + 0.3 * snug_fit_bonus\n    )\n\n    return priorities",
    "response_id": 8,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response9.txt_stdout.txt",
    "code_path": "problem_iter10_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_size = 1.0  # Assuming bin size is 1, can be generalized.\n\n    # 1. Feasibility: Only consider bins that can fit the item.  Set to -inf if not feasible\n    feasible_bins = bins_remain_cap >= item\n    priorities = np.where(~feasible_bins, -np.inf, priorities)\n\n    # 2. Best Fit Criterion: Prefer bins with remaining capacity closest to the item size.\n    residual_capacity = bins_remain_cap - item\n    best_fit_priority = np.where(feasible_bins, np.exp(-2 * np.abs(residual_capacity) / bin_size), 0)\n\n    # 3. Avoid Fragmentation: Penalize bins with too much remaining capacity after placing the item.\n    fragmentation_penalty = np.where(feasible_bins, np.exp(-2 * residual_capacity / bin_size), 1)\n\n    # 4. Filling Existing Bins: Prioritize bins that are already somewhat full.\n    fill_level = (bin_size - bins_remain_cap) / bin_size\n    fill_priority = np.where(feasible_bins, fill_level, 0)\n\n    # Combine priorities.  Best fit and fragmentation are most important.\n    priorities = best_fit_priority * fragmentation_penalty + 0.2 * fill_priority\n\n    # Exploration: Add a small random component to encourage exploration of different bins.\n    exploration_bonus = 0.01 * np.random.rand(len(bins_remain_cap))\n    priorities = np.where(feasible_bins, priorities + exploration_bonus, priorities) # Add exploration only to feasible bins.\n\n    # Graceful Infeasibility Handling: If no bin is feasible, try to put in bin with least waste (least negative residual).\n    if not np.any(feasible_bins):\n        priorities = -np.abs(residual_capacity)  # Use negative residual as priority\n\n    return priorities",
    "response_id": 9,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response0.txt_stdout.txt",
    "code_path": "problem_iter11_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)\n\n    # 1. Feasibility: Only consider bins that can fit the item.\n    feasible_bins = bins_remain_cap >= item\n\n    # 2. Best Fit Criterion: Prefer bins with remaining capacity closest to the item size.\n    residual_capacity = bins_remain_cap - item\n    best_fit_priority = np.where(feasible_bins, np.exp(-np.abs(residual_capacity)), 0)\n\n    # 3. Fragmentation Penalty: Penalize leaving too much space using a cubic penalty.\n    fragmentation_penalty = np.where(feasible_bins, np.exp(-5 * (residual_capacity / bin_capacity)**3), 1e-9) #Avoid zero\n\n    # 4. Reward Near-Full Bins: Bonus for filling bins close to full, scaled by item size.\n    near_full_reward = np.where(feasible_bins, np.exp(-10 * np.abs(residual_capacity) / item), 1e-9) #Avoid zero\n\n    # 5. Combine Heuristics Multiplicatively:  Use weights to adjust influence.\n    w_best_fit = 0.4\n    w_fragmentation = 0.3\n    w_near_full = 0.3\n\n    priorities = np.where(feasible_bins, (best_fit_priority**w_best_fit) * (fragmentation_penalty**w_fragmentation) * (near_full_reward**w_near_full), 0)\n\n    # 6. Strong Infeasibility Penalty: Severely penalize infeasible bins.\n    priorities = np.where(feasible_bins, priorities, 1e-9)\n\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response1.txt_stdout.txt",
    "code_path": "problem_iter11_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    num_bins = len(bins_remain_cap)\n    bin_size = 1.0  # Standard bin size, assume normalized\n\n    # Feasibility: Only consider bins that can fit the item.\n    feasible_bins = bins_remain_cap >= item\n\n    # Initialize priorities to a very small number for infeasible bins.\n    priorities = np.where(feasible_bins, 1.0, 1e-6)\n\n    # 1. Best Fit: Reward bins where the item fits with minimal remaining space.\n    residual_capacity = bins_remain_cap - item\n    best_fit_score = np.zeros(num_bins)\n    best_fit_score[feasible_bins] = np.exp(-10 * residual_capacity[feasible_bins] / bin_size)\n\n    # 2. Near-Full Reward: Give a bonus to bins that are close to being full after placing the item.\n    near_full_reward = np.zeros(num_bins)\n    near_full_reward[feasible_bins] = np.exp(-5 * np.abs(residual_capacity[feasible_bins]) / bin_size)\n\n    # 3. Fragmentation Penalty: Penalize bins that leave a significant amount of wasted space.  Cubic penalty\n    fragmentation_penalty = np.ones(num_bins)\n    fragmentation_penalty[feasible_bins] = np.clip(1 - 5 * (residual_capacity[feasible_bins] / bin_size)**3, 0.1, 1)\n\n\n    # Combination with learned weights (example weights)\n    w_best_fit = 0.6\n    w_near_full = 0.3\n    w_fragmentation = 0.1\n\n    # Combine multiplicatively for feasible bins\n    priorities[feasible_bins] = (best_fit_score[feasible_bins]**w_best_fit) * (near_full_reward[feasible_bins]**w_near_full) * (fragmentation_penalty[feasible_bins]**w_fragmentation)\n    \n    # Infeasibility Penalty:  Strongly penalize infeasible bins. Already done by initializing to a small value\n\n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response2.txt_stdout.txt",
    "code_path": "problem_iter11_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    num_bins = len(bins_remain_cap)\n    bin_size = 1.0  # Assuming bin size is 1\n\n    # 1. Feasibility: Only consider bins that can fit the item.\n    feasible_bins = bins_remain_cap >= item\n\n    # Infeasibility penalty\n    priorities = np.where(feasible_bins, priorities, -1e9)\n\n    # 2. Best Fit Criterion: Prioritize bins with remaining capacity closest to the item size.\n    residual_capacity = bins_remain_cap - item\n    best_fit_score = np.zeros(num_bins)\n    best_fit_score[feasible_bins] = np.exp(-5 * np.abs(residual_capacity[feasible_bins]))\n\n    # 3. Reward near-full bins after placement: The fuller the better\n    near_full_reward = np.zeros(num_bins)\n    near_full_reward[feasible_bins] = (bin_size - residual_capacity[feasible_bins])**2\n\n    # 4. Cubic fragmentation penalty.\n    fragmentation_penalty = np.zeros(num_bins)\n    fragmentation_penalty[feasible_bins] = -10 * (residual_capacity[feasible_bins]**3)\n\n    # Scale rewards/penalties by item size.\n    scaled_best_fit = best_fit_score * item\n    scaled_near_full = near_full_reward * item\n    scaled_fragmentation = fragmentation_penalty * item\n\n    # Combine heuristics multiplicatively with learned weights.\n    weight_best_fit = 0.6\n    weight_near_full = 0.3\n    weight_fragmentation = 0.1\n\n    priorities[feasible_bins] = (weight_best_fit * scaled_best_fit[feasible_bins] +\n                                  weight_near_full * scaled_near_full[feasible_bins] +\n                                  weight_fragmentation * scaled_fragmentation[feasible_bins])\n    return priorities",
    "response_id": 2,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response3.txt_stdout.txt",
    "code_path": "problem_iter11_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    num_bins = len(bins_remain_cap)\n    bin_size = np.max(bins_remain_cap) # Assuming all bins have same capacity initially\n\n    # 1. Feasibility Mask\n    feasible_bins = bins_remain_cap >= item\n\n    # 2. Best Fit: Reward bins where item fits best\n    residual_capacity = bins_remain_cap - item\n    best_fit = np.where(feasible_bins, np.exp(-2 * np.abs(residual_capacity)), 0)  # Exponential score based on residual\n\n    # 3. Near-Full Reward: Encourage filling bins that are close to full after placement\n    near_full_reward = np.where(feasible_bins, np.exp(-2 * np.abs(residual_capacity) / bin_size), 0)\n\n    # 4. Cubic Fragmentation Penalty: Heavily penalize leaving too much space\n    fragmentation_penalty = np.where(feasible_bins, np.exp(-0.5 * (residual_capacity / bin_size)**3), 1e-6)  # Cubic penalty scaled by bin size\n\n    # 5. Item Size Scaling: Scale the priority based on item size\n    item_size_factor = item\n\n    # 6. Combine Heuristics Multiplicatively with Learned Weights (Example weights)\n    w_best_fit = 0.4\n    w_near_full = 0.3\n    w_fragmentation = 0.3\n\n    priorities = (w_best_fit * best_fit + 1e-9) * (w_near_full * near_full_reward + 1e-9) * (w_fragmentation * fragmentation_penalty + 1e-9) * item_size_factor\n\n    # 7. Strong Penalty for Infeasibility\n    priorities = np.where(feasible_bins, priorities, -1e9) #Very small value for infeasible bins\n\n    return priorities",
    "response_id": 3,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response4.txt_stdout.txt",
    "code_path": "problem_iter11_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)\n\n    # 1. Feasibility: Only consider bins that can fit the item.\n    feasible_bins = bins_remain_cap >= item\n\n    # 2. Best Fit Criterion: Prefer bins with remaining capacity closest to the item size.\n    residual_capacity = bins_remain_cap - item\n    best_fit_priority = np.where(feasible_bins, np.exp(-np.abs(residual_capacity - (0.1 * item)) / (0.1 * item + 1e-9)), 0)  # slight preference for slightly larger.\n\n    # 3. Fragmentation Penalty: Heavily penalize large remaining capacity after placement. Cubic penalty\n    fragmentation_penalty = np.where(feasible_bins, np.exp(-5 * (residual_capacity / bin_capacity)**3), 1e-9)  # Modified cubic scaling and stronger penalty. If infeasible, extremely low priority\n\n    # 4. Reward near-full bins: Encourage filling bins that are close to being full.\n    near_full_reward = np.where(feasible_bins, np.exp(-2 * np.abs(residual_capacity) / (0.2 * bin_capacity + 1e-9)), 1) # More lenient threshold based on bin capacity\n    # 5. Combine heuristics multiplicatively with learned weights. Initialize weights\n    w_best_fit = 0.4\n    w_fragmentation = 0.3\n    w_near_full = 0.3\n\n\n    priorities = np.where(feasible_bins, (best_fit_priority**w_best_fit) * (fragmentation_penalty**w_fragmentation) * (near_full_reward**w_near_full), 1e-9) # If infeasible, extremely low priority\n\n    return priorities",
    "response_id": 4,
    "obj": 4.786597526924611,
    "exec_success": true
  }
]