[
  {
    "stdout_filepath": "problem_iter2_response0.txt_stdout.txt",
    "code_path": "problem_iter2_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: Only consider bins that can fit the item.\n    feasible_bins = bins_remain_cap >= item\n\n    # 2. Best Fit Criterion: Prefer bins with remaining capacity closest to the item size.\n    residual_capacity = bins_remain_cap - item\n    best_fit_priority = np.where(feasible_bins, 1 / (residual_capacity + 1e-9), 0)  # Avoid division by zero\n\n    # 3. Avoid Fragmentation: Penalize bins with too much remaining capacity after placing the item.\n    fragmentation_penalty = np.where(feasible_bins, np.exp(-0.2 * residual_capacity), 0) # Exponential decay\n\n    # 4. Bonus for Almost Full Bins: Encourage filling nearly full bins.\n    almost_full_bonus = np.where(feasible_bins, np.exp(-5 * np.abs(residual_capacity)/item), 0)\n\n    # 5. Prioritize bins that are already somewhat full to avoid starting new bins unnecessarily.\n    # The more full the bin is (before adding the item), the higher the priority.  Scale by feasibility.\n    existing_fill_priority = feasible_bins * (bins_remain_cap / np.max(bins_remain_cap)) \n\n    priorities = best_fit_priority * fragmentation_penalty + almost_full_bonus + 0.1 * existing_fill_priority\n\n    return priorities",
    "response_id": 0,
    "obj": 4.5073793378540135,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response1.txt_stdout.txt",
    "code_path": "problem_iter2_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: Only consider bins that can fit the item.\n    feasible_bins = bins_remain_cap >= item\n\n    # 2. Best Fit Criterion: Prefer bins with remaining capacity closest to the item size.\n    residual_capacity = bins_remain_cap - item\n    best_fit_priority = np.where(feasible_bins, np.exp(-5 * np.abs(residual_capacity/item)), 0)\n\n    # 3. Avoid Fragmentation: Penalize bins with too much remaining capacity after placing the item.\n    fragmentation_penalty = np.where(feasible_bins, np.exp(-0.5 * residual_capacity/item), 1)\n\n    # 4. Bonus for Almost Full Bins: Encourage filling nearly full bins.\n    almost_full_bonus = np.where(feasible_bins, np.exp(-10 * np.abs(residual_capacity/item)), 0)\n    \n    priorities = best_fit_priority * fragmentation_penalty + almost_full_bonus\n\n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response2.txt_stdout.txt",
    "code_path": "problem_iter2_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Give very low priority to bins that cannot fit the item\n    priorities[bins_remain_cap < item] = -np.inf\n\n    # Calculate remaining space after placing item\n    remaining_space = bins_remain_cap - item\n    \n    #Prioritize tighter fills, but only for bins that can fit item\n    fits_item = bins_remain_cap >= item\n    priorities[fits_item] = -remaining_space[fits_item]\n\n    # Heavily reward near-full bins.\n    fill_threshold_high = 0.95\n    almost_full = fits_item & (item / bins_remain_cap >= fill_threshold_high)\n    priorities[almost_full] += 100\n\n    # Reward for bins becoming almost full with different threshold\n    fill_threshold_low = 0.75\n    becoming_almost_full = fits_item & (item / bins_remain_cap >= fill_threshold_low)\n    priorities[becoming_almost_full] += 50\n\n    # Add a small priority proportional to remaining capacity if bin will fit, to help differentiating when empty ones are present\n    priorities[fits_item] += bins_remain_cap[fits_item]/np.max(bins_remain_cap) if np.max(bins_remain_cap)>0 else 0\n    \n\n    return priorities",
    "response_id": 2,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response3.txt_stdout.txt",
    "code_path": "problem_iter2_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Invalidate bins that can't accommodate the item\n    invalid_bins = bins_remain_cap < item\n    priorities[invalid_bins] = -np.inf\n    \n    # Calculate remaining capacity after packing\n    remaining_after_pack = bins_remain_cap - item\n    \n    # Calculate fill ratio (how full the bin will be)\n    fill_ratio = (bins_remain_cap - remaining_after_pack) / bins_remain_cap\n    \n    # Base priority based on fill ratio\n    priorities[remaining_after_pack >= 0] = 100 * fill_ratio[remaining_after_pack >= 0]\n    \n    # Bonus for near perfect fits\n    near_fit = (remaining_after_pack >= 0) & (remaining_after_pack <= 0.1)\n    priorities[near_fit] += 50\n    \n    # Moderate penalty for bins becoming too empty\n    too_empty = (remaining_after_pack > 0.5)\n    priorities[too_empty] -= 20 * remaining_after_pack[too_empty]\n    \n    # Strong penalty for bins that will have very little left\n    very_empty = (remaining_after_pack > 0.8)\n    priorities[very_empty] -= 50 * remaining_after_pack[very_empty]\n\n    return priorities",
    "response_id": 3,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response4.txt_stdout.txt",
    "code_path": "problem_iter2_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # High priority for bins that can accommodate the item\n    can_accommodate = bins_remain_cap >= item\n    priorities[can_accommodate] = 1.0\n\n    # Prioritize bins with smaller remaining capacity (relative to bin size)\n    # among those that can fit the item.\n    remaining_ratio = (bins_remain_cap[can_accommodate] - item) / bins_remain_cap[can_accommodate]\n    priorities[can_accommodate] += (1.0 - remaining_ratio)\n\n    # Penalize bins that cannot accommodate the item, proportional to the overflow\n    cannot_accommodate = bins_remain_cap < item\n    overflow_ratio = (item - bins_remain_cap[cannot_accommodate]) / np.mean(bins_remain_cap) if np.any(bins_remain_cap) else (item - bins_remain_cap[cannot_accommodate])\n    priorities[cannot_accommodate] = -overflow_ratio\n\n    return priorities",
    "response_id": 4,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response5.txt_stdout.txt",
    "code_path": "problem_iter2_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Heuristic 1: Minimal wasted space after placing item.  Invalid moves penalized harshly.\n    can_fit = item <= bins_remain_cap\n    priorities[~can_fit] = -np.inf\n\n    remaining_space = bins_remain_cap - item\n    priorities[can_fit] = 1.0 / (remaining_space[can_fit] + 1e-9)  # Avoid division by zero. Higher priority for less wasted space.\n\n    # Heuristic 2: Utilization rate of the bin after placing the item.\n    utilization_after = item / (bins_remain_cap + 1e-9)\n    priorities[can_fit] += utilization_after[can_fit]  # Higher utilization is better.\n\n    # Heuristic 3: Penalize near-empty bins to encourage load balancing.\n    mean_remaining_capacity = np.mean(bins_remain_cap)\n    emptyish = bins_remain_cap > (mean_remaining_capacity * 1.2)  # Slightly more aggressive than v1\n    priorities[emptyish] -= 0.2  # More aggressive penalty.\n\n    # Heuristic 4: Immediate fit bonus - gives high priority to bins which exactly fits the item\n    immediate_fit = bins_remain_cap == item\n    priorities[immediate_fit] += 1  # Substantial bonus\n\n    return priorities",
    "response_id": 5,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response6.txt_stdout.txt",
    "code_path": "problem_iter2_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Calculate remaining space after placing the item. Negative values indicate item won't fit.\n    remaining_after_placement = bins_remain_cap - item\n\n    # High priority for bins where the item fits best (smallest waste).\n    # But only if the item *does* fit!\n    fit_indices = remaining_after_placement >= 0\n\n    if np.any(fit_indices):\n        # Prioritize bins with smaller remaining space after placement (tight fit).\n        priorities[fit_indices] = 1 / (remaining_after_placement[fit_indices] + 1e-6)  # Avoid division by zero\n\n        # Add a bonus for filling the bin close to full. This encourages packing items into bins that are already relatively full.\n        priorities[fit_indices] += (item / bins_remain_cap[fit_indices])\n\n        # Further improve by prioritizing bins that are already more full (before adding the item)\n        priorities[fit_indices] += (bins_remain_cap[fit_indices] / np.max(bins_remain_cap))\n    else:\n        # If no bin fits, assign a very low priority to all bins. The calling\n        # function should then create a new bin. Setting it to the *largest* remaining capacity\n        # increases probability of fitting future items.\n        priorities = bins_remain_cap # Prefer bins with larger capacity when the item does not fit, new bin will be created and it is better to create a bin that can hold many items.\n    return priorities",
    "response_id": 6,
    "obj": 65.35700039888313,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response7.txt_stdout.txt",
    "code_path": "problem_iter2_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Give a high priority to bins that can accommodate the item\n    can_accommodate = bins_remain_cap >= item\n    \n    if np.any(can_accommodate):\n        priorities[can_accommodate] = 1.0\n\n        # Prioritize bins with smaller remaining capacity among those that can fit the item.\n        # This encourages filling up bins as much as possible and reducing fragmentation.\n        remaining_capacity = bins_remain_cap[can_accommodate] - item\n        priorities[can_accommodate] += (1 - (remaining_capacity / bins_remain_cap[can_accommodate]))\n        \n        # Further prioritize bins with remaining capacity closest to the item size\n        priorities[can_accommodate] += np.exp(-np.abs(remaining_capacity) / item)\n\n    # For bins that cannot accommodate the item, give a negative priority\n    # based on how much the item exceeds the bin's capacity. This discourages\n    # selecting nearly full bins.\n    cannot_accommodate = bins_remain_cap < item\n    if np.any(cannot_accommodate):\n        priorities[cannot_accommodate] = - (item - bins_remain_cap[cannot_accommodate]) / (np.mean(bins_remain_cap[bins_remain_cap > 0]) if np.any(bins_remain_cap > 0) else item)\n        \n\n    return priorities",
    "response_id": 7,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response8.txt_stdout.txt",
    "code_path": "problem_iter2_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Feasibility: Can the item fit?\n    fit_mask = bins_remain_cap >= item\n\n    # Infeasible bins get the lowest priority\n    priorities[~fit_mask] = -np.inf\n\n    # Prioritize bins where the item fits.\n    if np.any(fit_mask):\n        remaining_space = bins_remain_cap[fit_mask] - item\n\n        # Heuristic: Balance packing density with avoiding small gaps.\n        # Prioritize bins with smaller remaining space, but penalize very small gaps.\n\n        # Normalize remaining space by item size for relative comparison\n        normalized_remaining_space = remaining_space / item\n\n        # Give higher priority to bins that use more of their capacity\n        priorities[fit_mask] = 1.0 - normalized_remaining_space\n\n        # Penalize leaving gaps smaller than a fraction of the item size (e.g., 1/4)\n        small_gap_penalty = -0.5  # Adjust penalty as needed\n        priorities[fit_mask][normalized_remaining_space < 0.25] += small_gap_penalty\n\n        # Penalize leaving extremely small gaps even more.\n        extreme_small_gap_penalty = -1.0\n        priorities[fit_mask][normalized_remaining_space < 0.1] += extreme_small_gap_penalty\n\n\n    return priorities",
    "response_id": 8,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response9.txt_stdout.txt",
    "code_path": "problem_iter2_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            # Prioritize bins where the item fits\n            waste = cap - item\n            priorities[i] = 1.0 / (waste + 1e-9)  # Inverse of wasted space.  Avoid division by zero and make smaller waste higher priority\n\n            # Reward good fill ratios, with a stronger boost for nearly full bins\n            fill_ratio = item / cap\n            if fill_ratio > 0.75:\n                priorities[i] *= (1 + 2 * (fill_ratio - 0.75))  # Boost priority more strongly as fill_ratio approaches 1\n\n            # Slightly penalize nearly perfect fills to encourage better overall packing in later steps.\n            if fill_ratio > 0.95:\n                priorities[i] *= 0.9  # A small reduction to make these bins slightly less desirable\n\n        else:\n            # Very low priority if item doesn't fit\n            priorities[i] = -1e9  # or a large negative number\n\n    return priorities",
    "response_id": 9,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.999995019999915 seconds"
  }
]