[
  {
    "stdout_filepath": "problem_iter1_response0.txt_stdout.txt",
    "code_path": "problem_iter1_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Calculate remaining space after placing the item.  Negative values indicate item won't fit.\n    remaining_after_placement = bins_remain_cap - item\n    \n    # High priority for bins where the item fits best (smallest waste).\n    # But only if the item *does* fit!\n\n    fit_indices = remaining_after_placement >= 0\n    \n    if np.any(fit_indices):\n        priorities[fit_indices] = 1 / (remaining_after_placement[fit_indices] + 1e-6) #avoid division by zero\n        # Optionally, add a bonus for filling the bin close to full\n        priorities[fit_indices] += (item / bins_remain_cap[fit_indices])\n    \n    \n    # If no bin fits, assign a very low priority to all bins.  The calling\n    # function should then create a new bin. Setting it to the most empty bin\n    # avoids having empty bins and many bins containing little material each.\n    else:\n        priorities = -bins_remain_cap #give a negative score based on the size, prefer smaller capacity bins.\n    \n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response1.txt_stdout.txt",
    "code_path": "problem_iter1_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Heuristic 1: Prefer bins where the item fits, but with minimal wasted space.\n    #   Bins that can't fit the item get a priority of -np.inf\n    #   Bins that fit get a score proportional to how much space is left after packing\n    #   This promotes filling bins as much as possible.\n    can_fit = item <= bins_remain_cap\n    priorities[~can_fit] = -np.inf  # Give a very low priority for bins that can't fit\n\n    remaining_space = bins_remain_cap - item\n    priorities[can_fit] = 1.0 / (remaining_space[can_fit] + 1e-9)  # Avoid division by zero\n    \n    # Heuristic 2: Add small bonus for almost full bins to finish them off.\n    almost_full = (bins_remain_cap > item) & (bins_remain_cap < (item * 1.2))\n    priorities[almost_full] += 0.5\n\n    # Heuristic 3: Consider the utilization rate if we placed the item in a particular bin\n    utilization = item / bins_remain_cap\n    priorities[can_fit] += utilization[can_fit]\n\n    #Heuristic 4: Try to balance loads, assign a small penalty for selecting near-empty bins.\n    #    this can avoid bins filling very slowly while others are filled close to full\n    emptyish = bins_remain_cap > (np.mean(bins_remain_cap) * 1.5)\n    priorities[emptyish] -= 0.1\n    \n\n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response2.txt_stdout.txt",
    "code_path": "problem_iter1_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # First Fit Decreasing heuristic inspired priority: Prefer bins where the item fits with the least wasted space.\n\n    potential_waste = bins_remain_cap - item\n    \n    # Give a high priority to bins where the item fits.\n    fit_indices = potential_waste >= 0\n    \n    if np.any(fit_indices):\n      priorities[fit_indices] = 1 / (potential_waste[fit_indices] + 1e-9)  # Avoid division by zero\n    \n    # Penalize bins where the item doesn't fit, but do it gradually (squared difference)\n    non_fit_indices = potential_waste < 0\n    priorities[non_fit_indices] = - (item - bins_remain_cap[non_fit_indices])**2\n\n    return priorities",
    "response_id": 2,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response3.txt_stdout.txt",
    "code_path": "problem_iter1_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Rule 1: Feasibility.  Infeasible bins get -inf priority.\n    infeasible = bins_remain_cap < item\n    priorities[infeasible] = -np.inf\n    \n    # Rule 2:  Try to fill bins as much as possible, but avoid overfilling significantly.\n    #          Use a penalty based on wasted space.\n    \n    feasible = ~infeasible\n    remaining_after_fit = bins_remain_cap[feasible] - item\n    \n    # Higher priority if closer to full.  Also, introduce a slight penalty for too much waste.\n    priorities[feasible] = bins_remain_cap[feasible] / (bins_remain_cap[feasible] + item) - 0.1 * (item - bins_remain_cap[feasible])\n    \n    # Rule 3: Small preference for bins that are already non-empty.\n    # This reduces the number of bins in use early on.\n    already_used = bins_remain_cap < 1.0 # Assumes bin size is 1.0\n    priorities[already_used] += 0.05\n    \n    \n    return priorities",
    "response_id": 3,
    "obj": 149.30195452732352,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response4.txt_stdout.txt",
    "code_path": "problem_iter1_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            # First Fit Decreasing-like: prioritize bins with smallest remaining capacity that fits the item\n            priorities[i] = cap - item # Smaller difference means higher priority (less wasted space)\n            priorities[i] = 1/(priorities[i] + 0.000001) #avoid division by zero. Large reward for minimal wastage\n            #Alternative idea : prioritize bins that, after adding the item, leave the closest capacity to some 'ideal' value\n            #ideal_capacity = 0.5 #Target 50% full bins\n            #priorities[i] = -abs((cap - item) - ideal_capacity) #Prioritize bins that get close to ideal capacity\n\n        else:\n            priorities[i] = -1000 # Very low priority if the item doesn't fit\n            #Alternative:\n            #priorities[i] = -np.inf #Item does not fit\n\n    return priorities",
    "response_id": 4,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.999992490000295 seconds"
  },
  {
    "stdout_filepath": "problem_iter1_response5.txt_stdout.txt",
    "code_path": "problem_iter1_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # First-Fit-Decreasing Inspired: Prioritize bins that can fit the item reasonably well.\n    # Avoid bins that are either too full or have way too much remaining capacity.\n    fit_mask = bins_remain_cap >= item\n    priorities[fit_mask] = (bins_remain_cap[fit_mask] - item) / bins_remain_cap[fit_mask]  # Remaining space ratio after placing the item. Smaller ratio is better.\n    priorities[fit_mask] = 1 - priorities[fit_mask] #Invert so that smaller ratio gives larger priority.\n\n    # Give a slight boost to bins that are close to full (to consolidate).  This helps with \"almost full\" bins\n    almost_full_mask = (bins_remain_cap < item * 1.2) & (bins_remain_cap >= item) #Bins that can fit but with not much remaining\n    priorities[almost_full_mask] += 0.1 #Boost\n\n    # Penalize bins with significantly more capacity than the item size (avoid fragmentation).\n    large_capacity_mask = bins_remain_cap > item * 2  # Arbitrary threshold\n    priorities[large_capacity_mask] -= 0.05 #Slight penalize\n\n    # Avoid selecting bins that are already full or nearly full\n    too_full_mask = bins_remain_cap < item\n    priorities[too_full_mask] = -np.inf\n\n    return priorities",
    "response_id": 5,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response6.txt_stdout.txt",
    "code_path": "problem_iter1_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if item <= cap:\n            # First-Fit Decreasing heuristic influence (but online)\n            priorities[i] = cap - item  # Prefer bins with tighter fit\n            \n            # Try to balance number of used bins, avoiding near empty bins\n            if cap - item > 0.75: #Avoid wasting space\n               priorities[i] -= (cap-item) * 0.5 # penalize largely empty bins\n            elif cap - item < 0.05:\n                priorities[i] -= 0.1 # slight penalty to almost full bins to create diversity.\n            else:\n                priorities[i]+=0.1 #Slighly preffered when near fit\n\n        else:\n            priorities[i] = -np.inf  # Disqualify bins that cannot fit the item\n\n    return priorities",
    "response_id": 6,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.99998830000004 seconds"
  },
  {
    "stdout_filepath": "problem_iter1_response7.txt_stdout.txt",
    "code_path": "problem_iter1_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Feasibility: Only consider bins that can fit the item\n    feasible_bins = bins_remain_cap >= item\n    \n    if np.any(feasible_bins):\n        # 1. Remaining Capacity: Prioritize bins with smaller remaining capacity AFTER adding the item\n        remaining_capacity_after = bins_remain_cap - item\n        remaining_capacity_after[remaining_capacity_after < 0] = np.inf # Set to infinity if it doesn't fit (only for calculation)\n        \n        priorities[feasible_bins] = -remaining_capacity_after[feasible_bins]  # Smaller remaining capacity = higher priority\n\n        # 2. Item Size Ratio:  Also factor in how much of the bin the item will fill.\n        # This can help to consolidate items instead of spreading them too thin.\n        item_size_ratio = item / bins_remain_cap\n        priorities[feasible_bins] += item_size_ratio[feasible_bins] * 0.5 # Weigh the ratio effect.\n\n        # 3. Avoid nearly full bins to improve future packing\n        near_full_threshold = 0.9\n        near_full_bins = (bins_remain_cap - item) / bins_remain_cap < (1 - near_full_threshold)\n        priorities[near_full_bins & feasible_bins] -= 10  # Penalize nearly full bins\n\n    else:\n        # No bin can fit the item - assign low priority to all bins. This should not happen during online BPP, because a new bin should be added\n        # If this happens, means there might be a need to initialize the capacity, return -inf\n        priorities[:] = -np.inf\n        \n    return priorities",
    "response_id": 7,
    "obj": 5.554447546868772,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response8.txt_stdout.txt",
    "code_path": "problem_iter1_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Prioritize bins that can accommodate the item\n    valid_bins = bins_remain_cap >= item\n    \n    # If no bin can accommodate, assign a very low priority everywhere except the fullest bin, for which the priority is zero.\n    if not np.any(valid_bins):\n        min_capacity_index = np.argmin(bins_remain_cap)\n        priorities[min_capacity_index] = 0.0\n        priorities[np.arange(len(bins_remain_cap)) != min_capacity_index] = -np.inf\n        return priorities\n    \n    # Base priority: higher remaining capacity is penalized more (First Fit Decreasing heuristic)\n    priorities[valid_bins] = -bins_remain_cap[valid_bins]\n\n    # Bonus for bins where the item fits relatively snugly. Goal: leave as little free space as possible\n    slack = bins_remain_cap[valid_bins] - item\n    priorities[valid_bins] += (1 / (slack + 1e-6)) # Avoid division by zero\n\n    # Huge bonus for bins that become perfectly full with the addition of this item.\n    perfect_fit = (slack == 0)\n    priorities[valid_bins][perfect_fit] += 1000\n\n    return priorities",
    "response_id": 8,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response9.txt_stdout.txt",
    "code_path": "problem_iter1_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Prioritize bins where the item fits\n    fit_indices = bins_remain_cap >= item\n    priorities[fit_indices] = 1\n\n    # Adjust priorities based on remaining capacity after placing the item\n    remaining_after_fit = bins_remain_cap[fit_indices] - item\n    \n    # Give higher priority to bins with less remaining capacity after placing item (First-Fit Decreasing heuristic idea)\n    priorities[fit_indices] += 1/(remaining_after_fit + 0.000001) # Adding small value to avoid zero division\n\n    # If no bin can fit the item, give some priority to bins closest to fitting to avoid wasted space\n    if not np.any(fit_indices):\n      diffs = item - bins_remain_cap\n      positive_diffs = diffs[diffs > 0]\n      if positive_diffs.size > 0:\n        min_diff = np.min(positive_diffs)\n        closest_bins = diffs == min_diff\n        priorities[closest_bins] = 0.01  # Small non-zero priority\n\n    return priorities",
    "response_id": 9,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response10.txt_stdout.txt",
    "code_path": "problem_iter1_code10.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # First-Fit Decreasing inspired heuristic: Prefer bins where the item fits best,\n    # but penalize bins that are almost full or too empty.\n\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            # Base priority: remaining capacity after packing item\n            remaining = cap - item\n            priorities[i] = remaining\n\n            # Bonus for better fit: prioritize bins that use more of their capacity\n            priorities[i] += item / cap  # Ratio of item size to bin capacity\n\n            # Penalty for being too empty afterwards\n            priorities[i] -= (remaining / cap)**2 # Squaring the remaining capacity\n\n            # Bonus for smaller items - to fill smaller bins better.\n            priorities[i] += np.exp(-item)\n        else:\n            priorities[i] = -np.inf  # Item does not fit\n\n    return priorities",
    "response_id": 10,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.999993179999365 seconds"
  },
  {
    "stdout_filepath": "problem_iter1_response11.txt_stdout.txt",
    "code_path": "problem_iter1_code11.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Calculate remaining capacity after adding the item.\n    remaining_capacities = bins_remain_cap - item\n    \n    # Give high priority to bins where the item fits (positive remaining capacity).\n    # Give higher priority to bins that result in less wasted space.\n    valid_bins = remaining_capacities >= 0\n    \n    if np.any(valid_bins):  # If any bin can accommodate the item:\n        priorities[valid_bins] = (1 / (remaining_capacities[valid_bins] + 1e-9)) # Avoid division by zero, prioritize less wasted space\n    else:\n        # If no bin can accommodate the item, try to find the bin with the smallest remaining capacity\n        # Prioritize the bin that needs least space to fit the item.\n        priorities = -bins_remain_cap # assign negative priority\n        # Give a large penalty\n        priorities = priorities - 1000\n    return priorities",
    "response_id": 11,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response12.txt_stdout.txt",
    "code_path": "problem_iter1_code12.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Give a high priority to bins that can accommodate the item\n    can_accommodate = bins_remain_cap >= item\n    priorities[can_accommodate] = 1\n\n    # Prioritize bins with smaller remaining capacity among those that can fit the item.\n    # This encourages filling up bins as much as possible and reducing fragmentation.\n    priorities[can_accommodate] = priorities[can_accommodate] + (1 - (bins_remain_cap[can_accommodate] - item) / bins_remain_cap[can_accommodate])\n\n    # For bins that cannot accommodate the item, give a negative priority\n    # based on how much the item exceeds the bin's capacity. This discourages\n    # selecting nearly full bins.\n\n    cannot_accommodate = bins_remain_cap < item\n    priorities[cannot_accommodate] = - (item - bins_remain_cap[cannot_accommodate]) / np.mean(bins_remain_cap) if np.any(bins_remain_cap) > 0 else -1\n\n    return priorities",
    "response_id": 12,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response13.txt_stdout.txt",
    "code_path": "problem_iter1_code13.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Give very low priority (high negative value) to bins that cannot fit the item\n    priorities[bins_remain_cap < item] = -np.inf\n    \n    # For bins that can fit the item, prioritize bins that result in the least wasted space.\n    # Calculate wasted space if the item is placed in each bin.\n    wasted_space = bins_remain_cap - item\n    \n    # Give higher priority to bins with smaller wasted space. Using inverse of wasted space.\n    # Adding a small constant to avoid division by zero and to ensure all priorities are positive\n    priorities[bins_remain_cap >= item] = 1 / (wasted_space[bins_remain_cap >= item] + 0.001)\n\n    # Further prioritize bins close to being full *after* placing the item\n    # This encourages closing bins and reduces fragmentation\n    remaining_fraction = (bins_remain_cap[bins_remain_cap >= item] - item) / bins_remain_cap[bins_remain_cap >= item]\n    priorities[bins_remain_cap >= item] += (1-remaining_fraction)*10  # Scale factor can be tuned\n    \n    return priorities",
    "response_id": 13,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response14.txt_stdout.txt",
    "code_path": "problem_iter1_code14.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # First priority: Can the item even fit?\n    fit_mask = bins_remain_cap >= item\n\n    # If it doesn't fit, give it a very low priority (negative infinity)\n    priorities[~fit_mask] = -np.inf\n\n    # For bins where it *does* fit, calculate a priority based on remaining space\n    remaining_space = bins_remain_cap[fit_mask] - item\n\n    # A good heuristic is to prefer bins where the remaining space is small, but not too small\n    # We want to avoid leaving tiny slivers that are useless for later items\n\n    # Option 1: Using the absolute remaining space\n    # priorities[fit_mask] = -np.abs(remaining_space - item / 2)\n\n    # Option 2: A combined approach: Favor near-full bins, but penalize leaving very small gaps\n    priorities[fit_mask] = (bins_remain_cap[fit_mask] / (item + 1e-9)) - (np.abs(remaining_space - item/3) / (item + 1e-9))\n    \n    #Option 3 : Best Fit heuristic (prioritize bins where item fits most snugly)\n    #priorities[fit_mask] = -remaining_space\n\n    #Option 4 : Reward using more space and penalize wasting space.\n    # priorities[fit_mask] = item / bins_remain_cap[fit_mask] - remaining_space\n\n    return priorities",
    "response_id": 14,
    "obj": 19.355803749501412,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response15.txt_stdout.txt",
    "code_path": "problem_iter1_code15.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # First Fit Decreasing heuristic component: prefer bins that can fit the item\n    fit_mask = bins_remain_cap >= item\n    priorities[fit_mask] += 1  # Give a base priority if it fits\n\n    # Best Fit heuristic component: prioritize bins with smallest remaining capacity after placing item, but only if item fits\n    remaining_after_fit = bins_remain_cap - item\n    remaining_after_fit[~fit_mask] = np.inf  # set to infinity if it does not fit so it will not be considered the best fit\n    best_fit_idx = np.argmin(remaining_after_fit)\n    if np.isfinite(remaining_after_fit[best_fit_idx]): #check that there exists a feasible bin\n        priorities[best_fit_idx] += 2  # Higher priority for best fit\n\n    # Avoid Fragmentation: Penalize bins where the item would create small fragment\n    fragmentation_threshold = 0.1 #parameterizable\n    small_fragment_mask = (remaining_after_fit > 0) & (remaining_after_fit < fragmentation_threshold * np.max(bins_remain_cap)) & fit_mask\n    priorities[small_fragment_mask] -= 1 #reduce the priorities for those bins if available.\n\n\n    # Encourage filling bins before opening new ones: Boost the score for partially filled bins significantly more than empty bins\n    empty_bin_mask = bins_remain_cap == np.max(bins_remain_cap) #assuming all bins are initially the same size. If not, this needs to be an input.\n    priorities[~empty_bin_mask] += 0.5 # a boost to non empty bins.\n    return priorities",
    "response_id": 15,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 34, in priority_v2\nnumpy._core._exceptions._UFuncOutputCastingError: Cannot cast ufunc 'add' output from dtype('float64') to dtype('int64') with casting rule 'same_kind'\n"
  },
  {
    "stdout_filepath": "problem_iter1_response16.txt_stdout.txt",
    "code_path": "problem_iter1_code16.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # First Fit Decreasing (FFD) Inspired: Prioritize bins that can fit the item snugly.\n    fit_mask = bins_remain_cap >= item\n    \n    # Give a bonus to bins where the item fits with little wasted space.  The smaller the\n    # waste, the better the fit, the higher the priority.  Use a non-linear scaling.\n    waste = bins_remain_cap - item\n    priorities[fit_mask] = 1.0 / (waste[fit_mask] + 0.0001) # Avoid division by zero\n    \n    # Next Fit Inspired: Give a small bonus to the last bin used (or the first if none are used)\n    # This encourages using the same bin repeatedly, before opening a new one, but \n    # the \"snug fit\" above will generally outweigh it.\n\n    # Bins that cannot fit receive very low priority, slightly randomized.\n    priorities[~fit_mask] = -1000 + np.random.rand(np.sum(~fit_mask))\n    \n    return priorities",
    "response_id": 16,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response17.txt_stdout.txt",
    "code_path": "problem_iter1_code17.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # First-Fit Decreasing heuristic inspiration\n    # Give high priority to bins where the item fits well, but not perfectly\n    fit_well = (bins_remain_cap >= item) & (bins_remain_cap <= 2 * item)\n    priorities[fit_well] += 1.0 / (bins_remain_cap[fit_well] - item + 0.0001)  # Avoid division by zero\n\n    # If no bin fits 'well', prioritize bins that can at least fit the item\n    can_fit = bins_remain_cap >= item\n    priorities[can_fit] += 0.5 / (bins_remain_cap[can_fit] + 0.0001)  #Give some priority if bin can fit, prioritize fuller bins.\n\n    # Penalize bins that are too full (small capacity remaining)\n    too_full = bins_remain_cap < item\n    priorities[too_full] -= 10  # Very low priority if item does not fit.\n\n    # Give a small bonus to bins that are nearly empty to encourage utilization of these\n    nearly_empty = bins_remain_cap > 0.75 #If bin still has greater than 75% cap give slight bonus, otherwise do nothing to the priorities.\n    priorities[nearly_empty] += 0.1\n\n    return priorities",
    "response_id": 17,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response18.txt_stdout.txt",
    "code_path": "problem_iter1_code18.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Heuristic 1: Prefer bins that can fit the item\n    can_fit = bins_remain_cap >= item\n    priorities[can_fit] += 1\n\n    # Heuristic 2: Prefer bins with smallest remaining capacity AFTER adding item\n    remaining_after_add = bins_remain_cap - item\n    \n    valid_remaining = remaining_after_add[can_fit]\n    if len(valid_remaining) > 0:\n        min_remaining = np.min(valid_remaining)\n        indices = np.where((remaining_after_add == min_remaining) & can_fit)[0] # Use & for element-wise boolean AND\n        priorities[indices] += 2 # Stronger preference\n\n    # Heuristic 3: avoid waste\n    waste = bins_remain_cap - item\n    # If Waste is a small portion of item size (<=20%), then provide small preference to it.\n    avoid_waste = (waste <= 0.2 * item) & can_fit # only consider candidates that item fits into\n    priorities[avoid_waste] += 0.5\n    \n    # Heuristic 4: Give negative priority to items that cannot fit\n    priorities[~can_fit] -= 0.1 # slight negative preference\n\n\n    return priorities",
    "response_id": 18,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response19.txt_stdout.txt",
    "code_path": "problem_iter1_code19.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            # Reward bins that can accommodate the item\n            priorities[i] = 1 / (cap - item + 1e-6)  # Smaller remaining space is better\n        else:\n            # Penalize bins that cannot accommodate the item\n            priorities[i] = -1e9 # Very low priority\n    return priorities",
    "response_id": 19,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response20.txt_stdout.txt",
    "code_path": "problem_iter1_code20.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Big enough to fit? If not, priority = -inf\n    eligible = bins_remain_cap >= item\n    priorities[~eligible] = -np.inf\n\n    # Sort eligible bins by remaining capacity in descending order.\n    eligible_indices = np.where(eligible)[0]\n    sorted_eligible_indices = eligible_indices[np.argsort(bins_remain_cap[eligible_indices])[::-1]]\n\n    # Assign priority based on how full the bin will be if item is placed.\n    for i, bin_index in enumerate(sorted_eligible_indices):\n        remaining_after_pack = bins_remain_cap[bin_index] - item\n        fill_ratio = 1 - (remaining_after_pack / bins_remain_cap[bin_index])\n        \n        # Prefer bins that get closest to full. Slightly penalize bins that become too full.\n        if remaining_after_pack >=0:\n            priorities[bin_index] = 100 * fill_ratio  # Give this fill ratio some magnitude\n        else:\n            priorities[bin_index] = -100 # avoid putting into bins that can not contain item after precision errors etc\n                \n        # Bonus for nearly perfect fits, but prevent tiny empty spaces (reduces fragmentation)\n        if 0 <= remaining_after_pack <= 0.1:  # Tweak threshold as needed\n            priorities[bin_index] += 50\n\n        # Penalize large empty spaces\n        if remaining_after_pack > 0.5:\n           priorities[bin_index] -= remaining_after_pack\n\n    return priorities",
    "response_id": 20,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response21.txt_stdout.txt",
    "code_path": "problem_iter1_code21.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: Only consider bins that can fit the item.\n    feasible_bins = bins_remain_cap >= item\n\n    # 2. Best Fit Criterion: Prefer bins with remaining capacity closest to the item size.\n    residual_capacity = bins_remain_cap - item\n    best_fit_priority = np.where(feasible_bins, 1 / (residual_capacity + 0.000001), 0)  # Avoid division by zero\n\n    # 3. Avoid Fragmentation: Penalize bins with too much remaining capacity after placing the item.\n    fragmentation_penalty = np.where(feasible_bins, np.exp(-0.1 * residual_capacity), 0) # Exponential decay\n   \n\n    # 4. Bonus for Almost Full Bins: Encourage filling nearly full bins.\n    almost_full_bonus = np.where(bins_remain_cap > 0.0, np.exp(-10 * np.abs(bins_remain_cap -item)/item) * feasible_bins, 0)\n\n    priorities = best_fit_priority * fragmentation_penalty + almost_full_bonus\n\n    return priorities",
    "response_id": 21,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response22.txt_stdout.txt",
    "code_path": "problem_iter1_code22.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            # Prioritize bins where the item fits\n            remaining_space = cap - item\n            priorities[i] = (item / cap)  # Fill ratio - higher fill is better\n            priorities[i] += 1/(remaining_space + 0.001) # Lower the remaining space, the better\n\n            if remaining_space < 0.1: # if remaining cap is really small, add bonus.\n                priorities[i] += 1\n\n        else:\n            priorities[i] = -1e9  # Very low priority if item doesn't fit\n    return priorities",
    "response_id": 22,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response23.txt_stdout.txt",
    "code_path": "problem_iter1_code23.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            # First Fit Decreasing variant\n            space_waste = cap - item\n            # Try to fill bins as much as possible\n            priorities[i] = 1 / (space_waste + 1e-9) # Add small number to avoid division by zero\n\n            # Modified First Fit Decreasing - penalize bins that are almost full\n            if space_waste < 0.1:  # If bin is almost full\n                priorities[i] *= 0.5 # Lower priority\n\n            # Give a bonus to bins that fit the item perfectly (or near perfectly)\n            if abs(space_waste) < 1e-6: # within tolerance\n                 priorities[i] = np.inf\n\n        else:\n            priorities[i] = -np.inf\n\n    return priorities",
    "response_id": 23,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response24.txt_stdout.txt",
    "code_path": "problem_iter1_code24.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if item <= cap:\n            # Base priority: higher remaining capacity is better.\n            priorities[i] = cap\n\n            # Bonus for filling the bin well (but not too perfectly).\n            fill_ratio = item / cap\n            if 0.6 <= fill_ratio <= 1.0: #was 0.95\n                priorities[i] += 10 * (1-abs(fill_ratio-0.8))  #add a bonus for fill ratios around 0.8\n\n            # Potential slight penalty to avoid nearly perfect fills (can hinder future placements)\n            if 0.95 <= fill_ratio <= 1.0: #prevents perfect fills, encourages fragmentation and less total bins\n                priorities[i] -= 0.5 * (fill_ratio-0.95)\n        else:\n            priorities[i] = -np.inf  # Impossible to fit\n\n    return priorities",
    "response_id": 24,
    "obj": 147.5368966892701,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response25.txt_stdout.txt",
    "code_path": "problem_iter1_code25.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            # Prioritize bins where the item fits\n            waste = cap - item\n            priorities[i] = (1 / (waste + 1e-6))  # Inverse of wasted space. Avoid division by zero\n\n            # Boost priority if item fills bin nicely (e.g., > 75% filled)\n            fill_ratio = item / cap\n            if fill_ratio > 0.75:\n                priorities[i] *= 1.5 # give a boost to nearly full bins\n        else:\n            # Very low priority if item doesn't fit, to discourage placement\n            priorities[i] = -1e9 # or a large negative number\n    return priorities",
    "response_id": 25,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response26.txt_stdout.txt",
    "code_path": "problem_iter1_code26.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # First Fit Decreasing-like approach with a bonus for tight fits.\n    # Prioritize bins that can fit the item.\n\n    valid_bins = bins_remain_cap >= item\n    \n    if not np.any(valid_bins):\n      # If item doesn't fit into any bins. prioritize bins with the largest available space.\n      priorities = bins_remain_cap # Prioritize larger bins\n      return priorities\n\n    \n    remaining_space = bins_remain_cap - item\n    remaining_space[remaining_space < 0] = np.inf  # Mark invalid bins with infinity.\n\n    # Calculate a score based on the tightness of the fit.  Smaller remaining space is better.\n    tightness = np.exp(-remaining_space)  # Exponential decay of the remaining space.\n\n    #Prioritize by tightness, but only for bins that can fit.\n    priorities = np.where(valid_bins, tightness, -np.inf)  #High tightness, high score; if not valid -inf\n    \n    \n    return priorities",
    "response_id": 26,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response27.txt_stdout.txt",
    "code_path": "problem_iter1_code27.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Assign high priority to bins that can fit the item\n    can_fit = bins_remain_cap >= item\n    priorities[can_fit] = 1.0\n\n    # Scale priority based on remaining capacity after packing the item.\n    remaining_capacity = bins_remain_cap[can_fit] - item\n    priorities[can_fit] += remaining_capacity / np.max(bins_remain_cap) # np.max(bins_remain_cap) serves as scaling factor\n\n    # If no bin can fit the item, assign some default priorities. Avoid selecting fully empty bins first if possible.\n    if not np.any(can_fit):\n        priorities = bins_remain_cap / np.max(bins_remain_cap) # scaled remaining capacity.\n    \n    return priorities",
    "response_id": 27,
    "obj": 149.30195452732352,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response28.txt_stdout.txt",
    "code_path": "problem_iter1_code28.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Give very low priority to bins that cannot fit the item\n    priorities[bins_remain_cap < item] = -np.inf\n    \n    # Calculate remaining space after placing item\n    remaining_space = bins_remain_cap - item\n    \n    # Prioritize bins with smaller remaining space (but still enough to fit the item)\n    priorities[bins_remain_cap >= item] = -remaining_space[bins_remain_cap >= item]\n    \n    # Boost the priority of bins that will be filled to a certain threshold\n    fill_threshold = 0.95  # Adjust as needed\n    filled_bins = (bins_remain_cap >= item) & ((bins_remain_cap - item) / bins_remain_cap <= (1 - fill_threshold))\n    priorities[filled_bins] += 100  # A significant boost\n    \n    #Add a small priority proportional to remaining capacity if bin will fit, to help differentiating when empty ones are present\n    fits_items = bins_remain_cap >= item\n    priorities[fits_items] += bins_remain_cap[fits_items]/np.max(bins_remain_cap) if np.max(bins_remain_cap)>0 else 0\n\n    return priorities",
    "response_id": 28,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response29.txt_stdout.txt",
    "code_path": "problem_iter1_code29.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Immediate fit bonus\n    immediate_fit = bins_remain_cap == item\n    priorities[immediate_fit] += 1000\n\n    # Near fit bonus\n    near_fit = (bins_remain_cap > item) & (bins_remain_cap <= item * 1.1) # within 10%\n    priorities[near_fit] += 500\n\n    # Try to fill fullest bins first, avoiding excessive fragmentation\n    valid_bins = bins_remain_cap >= item\n    priorities[valid_bins] += bins_remain_cap[valid_bins] # higher remaining cap -> lower fragmentation -> higher priority\n\n    # Avoid bins that will become too empty, leading to wastage\n    too_empty = (bins_remain_cap - item) < 0.2 # e.g., remaining cap < 20% bin size\n    priorities[too_empty] -= 100  # Penalize\n\n    # Invalidate bins that can't accommodate the item\n    invalid_bins = bins_remain_cap < item\n    priorities[invalid_bins] = -np.inf\n    \n    return priorities",
    "response_id": 29,
    "obj": 77.46310331072995,
    "exec_success": true
  }
]