[
  {
    "stdout_filepath": "problem_iter6_response0.txt_stdout.txt",
    "code_path": "problem_iter6_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)\n\n    # 1. Feasibility: Only consider bins that can fit the item.\n    feasible_bins = bins_remain_cap >= item\n\n    # If no bin can fit the item, prioritize bins with the most remaining capacity. Important to avoid infinite loops.\n    if not np.any(feasible_bins):\n        return bins_remain_cap / bin_capacity\n\n    # 2. Best Fit Criterion: Prefer bins with remaining capacity closest to the item size.\n    residual_capacity = bins_remain_cap - item\n    best_fit_priority = np.where(feasible_bins, 1 / (residual_capacity + 1e-9), 0)  # Avoid division by zero\n\n    # 3. Avoid Fragmentation: Penalize bins with too much remaining capacity after placing the item, relative to item size.\n    fragmentation_penalty = np.where(feasible_bins, np.exp(-0.5 * residual_capacity / item), 0)  # More aggressive penalty\n\n    # 4. Bonus for Almost Full Bins: Encourage filling nearly full bins, relative to bin capacity.\n    almost_full_bonus = np.where(feasible_bins, np.exp(-5 * np.abs(residual_capacity) / bin_capacity), 0)\n\n    # 5. Prioritize bins that are already somewhat full to avoid starting new bins unnecessarily.\n    existing_fill_priority = feasible_bins * (1 - bins_remain_cap / bin_capacity)\n\n    # 6. Item Size consideration: Give higher priority to bins which can fit the item perfectly or with minimal waste, relative to the item size.\n    item_size_priority = np.where(feasible_bins, np.exp(-1 * residual_capacity / item), 0)\n\n    # Combine the priorities with adjusted scaling\n    priorities = (\n        0.4 * best_fit_priority\n        + 0.2 * fragmentation_penalty\n        + 0.3 * almost_full_bonus\n        + 0.1 * existing_fill_priority\n        + 0.1 * item_size_priority\n    )\n\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response1.txt_stdout.txt",
    "code_path": "problem_iter6_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Prioritizes feasibility, then fullness. Aggressively reward near-full bins\n    and penalize fragmentation and wasted space, scaling rewards/penalties\n    proportionally to bin capacity. Vectorized operations for efficiency.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    original_capacities = bins_remain_cap + 1e-9  #avoid zero divison error in case all the bins were filled\n\n    # Calculate remaining space after placing the item. Negative values indicate item won't fit.\n    remaining_after_placement = bins_remain_cap - item\n\n    # Feasibility check: Only consider bins where the item fits.\n    feasible_bins = remaining_after_placement >= 0\n\n    if np.any(feasible_bins):\n        # Fullness reward: Higher score for bins that become fuller after placement.\n        fullness_reward = (item / original_capacities) * feasible_bins  # Only apply to feasible bins. Higher score if item is large compared to bin capacity\n\n        # Fragmentation penalty: Penalize bins with significant remaining space after placement.\n        # Scale penalty by the *cube* of the remaining ratio to aggressively penalize wasted space\n        fragmentation_penalty = -((remaining_after_placement / original_capacities)**3) * feasible_bins\n\n        # Near-full bonus: Extra reward if the bin becomes nearly full after placement.\n        near_full_threshold = 0.2  # Define \"nearly full\" as remaining capacity <= 20% of original_capacities capacity.\n        near_full_bonus = (remaining_after_placement <= (near_full_threshold * original_capacities)) * feasible_bins * 5  # Significantly boost priority if near full\n\n        # Combine rewards and penalties\n        priorities = fullness_reward + fragmentation_penalty + near_full_bonus\n\n    else:\n        # If no bin fits, assign a negative priority based on remaining capacity (prefer to open a new bin).\n        priorities = -bins_remain_cap\n\n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response2.txt_stdout.txt",
    "code_path": "problem_iter6_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: Only consider bins that can fit the item.\n    feasible_bins = bins_remain_cap >= item\n\n    # If no bin can accommodate, return a low priority for all bins.\n    if not np.any(feasible_bins):\n        return priorities - 1.0\n\n    # 2. Best Fit Criterion: Prioritize bins with remaining capacity closest to the item size.\n    residual_capacity = bins_remain_cap - item\n    best_fit_priority = np.where(feasible_bins, np.exp(-10 * np.abs(residual_capacity)), 0) # Sharp exponential\n\n    # 3. Minimize Fragmentation: Penalize bins with large residual capacity after placement.\n    fragmentation_penalty = np.where(feasible_bins, np.exp(-0.5 * residual_capacity / item), 0) # Scale by item size\n\n    # 4. Encourage Filling: Bonus for bins that are already relatively full.\n    existing_fill_level = bins_remain_cap / np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else 0  # Avoid division by zero\n    already_full_bonus = feasible_bins * existing_fill_level\n\n    # 5. Item Fit: Prioritize bins where item fits well relative to item size.\n    item_fit_score = np.where(feasible_bins, np.exp(-5 * np.abs(residual_capacity) / item), 0)\n\n    # Combine priorities. Adjust weights as needed.\n    priorities = (\n        best_fit_priority\n        + 0.7 * fragmentation_penalty\n        + 0.5 * already_full_bonus\n        + 0.8 * item_fit_score\n    )\n\n    return priorities",
    "response_id": 2,
    "obj": 3.9589150378939015,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response3.txt_stdout.txt",
    "code_path": "problem_iter6_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_size = np.max(bins_remain_cap)\n\n    # 1. Feasibility: Only consider bins that can fit the item.\n    feasible_bins = bins_remain_cap >= item\n\n    # If no bin is feasible, consider relative capacity. Open a new bin.\n    if not np.any(feasible_bins):\n         return bins_remain_cap / bin_size # Return ratio of remaining capacity to bin size\n\n    # 2. Normalize remaining capacity.\n    normalized_cap = bins_remain_cap / bin_size\n\n    # 3. Best Fit Criterion: Prioritize bins with the smallest remaining capacity after placing the item.\n    residual_capacity = bins_remain_cap - item\n    best_fit_priority = np.where(feasible_bins, bin_size / (residual_capacity + 1e-9), 0) # Use bin size to scale priority.\n\n    # 4. Fragmentation Penalty: Heavily penalize small gaps after placement.\n    fragmentation_penalty = np.where(feasible_bins, np.exp(-5 * residual_capacity / bin_size), 0)\n\n    # 5. Near-Full Reward: Encourage filling bins close to full with a stronger non-linear scaling.\n    almost_full_bonus = np.where(feasible_bins, np.exp(-10 * (residual_capacity / bin_size)**2), 0)\n\n    # 6. Explicit Small Gap Penalty: Penalize remaining capacity below a certain threshold.\n    small_gap_penalty = np.where(feasible_bins & (residual_capacity < 0.1 * bin_size), -1, 0)\n\n    # 7. Introduce a capacity utilization reward. Higher utilization is better.\n    capacity_utilization = np.where(feasible_bins, (bin_size - residual_capacity) / bin_size, 0)\n    capacity_reward = capacity_utilization * 2 #scale to amplify its effect\n\n    priorities = best_fit_priority + almost_full_bonus + fragmentation_penalty + small_gap_penalty + capacity_reward\n    \n    #Ensure no negative priorities.\n    priorities = np.maximum(priorities, 0)\n\n    return priorities",
    "response_id": 3,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response4.txt_stdout.txt",
    "code_path": "problem_iter6_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)\n\n    # 1. Feasibility: Only consider bins that can fit the item.\n    feasible_bins = bins_remain_cap >= item\n\n    # If no bin can fit the item, prioritize bins with the most remaining capacity\n    if not np.any(feasible_bins):\n        return bins_remain_cap / bin_capacity #Try to open a new bin by prioritizing bins with larger remaining capacity\n\n    # 2. Best Fit Criterion: Prefer bins with remaining capacity closest to the item size.\n    residual_capacity = bins_remain_cap - item\n    best_fit_priority = np.where(feasible_bins, 1 / (residual_capacity + 1e-9), 0)  # Avoid division by zero\n\n    # 3. Avoid Fragmentation: Penalize bins with too much remaining capacity after placing the item.\n    fragmentation_penalty = np.where(feasible_bins, np.exp(-0.5 * residual_capacity / item), 0) #Penalize based on the item size\n\n    # 4. Bonus for Almost Full Bins: Encourage filling nearly full bins.\n    almost_full_bonus = np.where(feasible_bins, np.exp(-5 * np.abs(residual_capacity) / item), 0) #Relative to item size\n\n    # 5. Prioritize bins that are already somewhat full to avoid starting new bins unnecessarily.\n    existing_fill_priority = feasible_bins * (1 - (bins_remain_cap / bin_capacity)) #Scale it by the bin capacity\n\n    # 6. Item Size consideration: Give higher priority to bins which can fit the item perfectly or with minimal waste, relative to the item size.\n    item_size_priority = np.where(feasible_bins, np.exp(-2 * residual_capacity / item), 0) #Relative to item size\n\n    # 7. Bin diversity: Encourage using different bins by adding a small random number to the priority.\n    diversity_bonus = 0.01 * np.random.rand(len(bins_remain_cap))\n\n    priorities = best_fit_priority * fragmentation_penalty + almost_full_bonus + 0.2 * existing_fill_priority + 0.3 * item_size_priority + diversity_bonus\n\n    return priorities",
    "response_id": 4,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response5.txt_stdout.txt",
    "code_path": "problem_iter6_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)\n\n    # 1. Feasibility: Only consider bins that can fit the item.\n    feasible_bins = bins_remain_cap >= item\n\n    # If no bin is feasible, prioritize bins with largest remaining capacity (relative).\n    if not np.any(feasible_bins):\n      return bins_remain_cap / bin_capacity\n\n    # 2. Best Fit Criterion (highly emphasized): Prioritize bins with remaining capacity closest to the item size, but only if feasible.\n    residual_capacity = bins_remain_cap - item\n    best_fit_priority = np.where(feasible_bins, np.exp(-10 * np.abs(residual_capacity) / bin_capacity), 0)  # Strong emphasis\n\n    # 3. Fragmentation Penalty (very strong): Heavily penalize bins with too much remaining capacity.\n    fragmentation_penalty = np.where(feasible_bins, np.exp(-10 * residual_capacity / bin_capacity), 0)\n\n    # 4. Near-Full Bonus (extremely aggressive): Significantly reward bins that become near-full after placing the item.\n    almost_full_bonus = np.where(feasible_bins, np.exp(-40 * np.abs(residual_capacity) / bin_capacity), 0) # Very aggressive\n\n    # 5. Explicit Small Gap Penalty (more severe): Penalize bins that leave a small gap after placing the item.\n    small_gap_penalty = np.where(feasible_bins & (residual_capacity > 0) & (residual_capacity < 0.1 * bin_capacity), -1, 0) # Increased penalty\n\n    # 6. Normalize Remaining Space: To ensure consistent scaling.\n    normalized_remaining_space = bins_remain_cap / bin_capacity\n\n    priorities = (\n        best_fit_priority\n        + 0.9 * almost_full_bonus\n        + 0.2 * fragmentation_penalty\n        + small_gap_penalty\n        + 0.05 * normalized_remaining_space\n    )\n\n    return priorities",
    "response_id": 5,
    "obj": 4.417630634224167,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response6.txt_stdout.txt",
    "code_path": "problem_iter6_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_size = np.max(bins_remain_cap)  # Assuming all bins have the same initial capacity\n\n    # 1. Feasibility: Only consider bins that can fit the item. Infeasible bins get -inf priority\n    feasible_bins = bins_remain_cap >= item\n    priorities = np.where(feasible_bins, priorities, -np.inf)\n\n    # 2. Normalize remaining capacity for better comparison\n    normalized_remaining_cap = bins_remain_cap / bin_size\n\n    # 3. Best Fit & Fragmentation Penalty: Strongly penalize small gaps (fragmentation).\n    residual_capacity = bins_remain_cap - item\n    normalized_residual = residual_capacity / bin_size\n    \n    # Explicit penalty for small gaps; scaled by the bin size to make it relative.\n    small_gap_threshold = 0.1\n    small_gap_penalty = np.where(feasible_bins & (residual_capacity > 0) & (residual_capacity <= small_gap_threshold * bin_size), -5, 0)\n\n    # Reward bins that are nearly full after adding the item.\n    near_full_bonus = np.where(feasible_bins, np.exp(-10 * normalized_residual), 0)\n    \n    # Prioritize bins with less remaining capacity before adding the item, but after filtering infeasible ones\n    fill_level_priority = np.where(feasible_bins, 1 - normalized_remaining_cap, 0)\n    \n    # 4. Infeasible Bin Handling - Relative Capacity: if item doesn't fit in ANY bin, choose the bin with the largest remaining capacity.\n    if not np.any(feasible_bins):\n        priorities = bins_remain_cap / bin_size # Use relative capacity. Remove infeasible marker (-inf)\n        return priorities\n\n    priorities = near_full_bonus + fill_level_priority + small_gap_penalty\n    return priorities",
    "response_id": 6,
    "obj": 6.531711208615876,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response7.txt_stdout.txt",
    "code_path": "problem_iter6_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: Only consider bins that can fit the item.\n    feasible_bins = bins_remain_cap >= item\n\n    # 2. Best Fit Criterion: Prefer bins with remaining capacity closest to the item size.\n    residual_capacity = bins_remain_cap - item\n    best_fit_priority = np.where(feasible_bins, np.exp(-np.abs(residual_capacity)), 0)\n\n    # 3. Avoid Fragmentation: Penalize bins with too much remaining capacity after placing the item.\n    fragmentation_penalty = np.where(feasible_bins, np.exp(-0.5 * residual_capacity / np.max(bins_remain_cap)), 0) # Scale by bin size\n\n    # 4. Bonus for Almost Full Bins: Encourage filling nearly full bins.\n    almost_full_bonus = np.where(feasible_bins, np.exp(-5 * np.abs(residual_capacity) / item), 0) # Scale residual by item size\n\n    # 5. Prioritize bins that are already somewhat full to avoid starting new bins unnecessarily.\n    existing_fill_priority = feasible_bins * (bins_remain_cap / np.max(bins_remain_cap))\n\n    # 6. Item Size consideration: Give higher priority to bins which can fit the item perfectly or with minimal waste, relative to the item size.\n    item_size_priority = np.where(feasible_bins, np.exp(-2 * residual_capacity / item), 0)\n\n    priorities = best_fit_priority + 0.5 * fragmentation_penalty + almost_full_bonus + 0.1 * existing_fill_priority + 0.2 * item_size_priority\n\n    return priorities",
    "response_id": 7,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response8.txt_stdout.txt",
    "code_path": "problem_iter6_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Prioritizes feasibility, aggressively rewards fullness, penalizes fragmentation cubically, and adds a near-full bonus.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Calculate remaining space after placing the item.\n    remaining_after_placement = bins_remain_cap - item\n\n    # Feasibility check: Only consider bins where the item fits.\n    feasible_bins = remaining_after_placement >= 0\n\n    if np.any(feasible_bins):\n        # Fullness reward: Higher score for bins that become fuller after placement.\n        fullness_reward = (item / bins_remain_cap) * feasible_bins\n\n        # Fragmentation penalty: Penalize bins with significant remaining space after placement.\n        fragmentation_penalty = -((remaining_after_placement[feasible_bins] / bins_remain_cap[feasible_bins])**3)\n        priorities[feasible_bins] += fragmentation_penalty\n\n        # Near-full bonus: Extra reward if the bin becomes nearly full after placement.\n        near_full_threshold = 0.2\n        near_full_bins = (remaining_after_placement <= (near_full_threshold * bins_remain_cap)) & feasible_bins\n        priorities[near_full_bins] += 3\n\n        # Combine rewards and penalties\n        priorities[feasible_bins] += fullness_reward[feasible_bins]\n\n    else:\n        # If no bin fits, assign a negative priority based on remaining capacity.\n        priorities = -bins_remain_cap\n\n    return priorities",
    "response_id": 8,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response9.txt_stdout.txt",
    "code_path": "problem_iter6_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Prioritizes feasibility, then fullness. Aggressively reward near-full bins\n    and penalize fragmentation and wasted space, scaling rewards/penalties\n    proportionally to bin capacity. Vectorized operations for efficiency.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Calculate remaining space after placing the item. Negative values indicate item won't fit.\n    remaining_after_placement = bins_remain_cap - item\n\n    # Feasibility check: Only consider bins where the item fits.\n    feasible_bins = remaining_after_placement >= 0\n\n    if np.any(feasible_bins):\n        # Fullness reward: Higher score for bins that become fuller after placement. Scaled by feasibility.\n        fullness_reward = (item / bins_remain_cap) * feasible_bins\n\n        # Fragmentation penalty: Penalize bins with significant remaining space after placement.\n        # Scale penalty by the *cube* of the remaining ratio to aggressively penalize wasted space.\n        fragmentation_penalty = -((remaining_after_placement / bins_remain_cap)**3) * feasible_bins\n\n        # Near-full bonus: Extra reward if the bin becomes nearly full after placement.\n        near_full_threshold = 0.2  # Define \"nearly full\" as remaining capacity <= 20% of total capacity.\n        near_full_bonus = (remaining_after_placement <= (near_full_threshold * bins_remain_cap)) * feasible_bins * 3  # Significantly boost priority if near full\n\n        # Combine rewards and penalties\n        priorities = fullness_reward + fragmentation_penalty + near_full_bonus\n\n    else:\n        # If no bin fits, assign a priority based on remaining capacity, prefer larger. Make it negative.\n        priorities = -bins_remain_cap / np.max(bins_remain_cap) if bins_remain_cap.size > 0 else np.array([-1.0])\n\n    return priorities",
    "response_id": 9,
    "obj": 4.048663741523748,
    "exec_success": true
  }
]