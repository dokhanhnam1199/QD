[
  {
    "stdout_filepath": "problem_iter8_response0.txt_stdout.txt",
    "code_path": "problem_iter8_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_size = np.max(bins_remain_cap) if bins_remain_cap.size > 0 else 1.0 #Avoid division by zero if bins_remain_cap is empty\n\n    # 1. Feasibility: Only consider bins that can fit the item.\n    feasible_bins = bins_remain_cap >= item\n\n    # If no bin can accommodate, return a low priority for all bins.\n    if not np.any(feasible_bins):\n        return priorities - 1.0\n\n    # 2. Best Fit Criterion: Prioritize bins with remaining capacity closest to the item size.\n    residual_capacity = bins_remain_cap - item\n    best_fit_priority = np.where(feasible_bins, np.exp(-20 * np.abs(residual_capacity) / item), 0)  # Sharper exponential, item-relative\n\n    # 3. Minimize Fragmentation: Penalize bins with large residual capacity after placement.\n    fragmentation_penalty = np.where(feasible_bins, np.exp(-1 * residual_capacity / item), 0)  # Scale by item size\n\n    # 4. Encourage Filling: Bonus for bins that are already relatively full.\n    existing_fill_level = (bin_size - bins_remain_cap) / bin_size\n    already_full_bonus = np.where(feasible_bins, existing_fill_level, 0)\n\n    # 5. Item Fit: Prioritize bins where item fits well relative to item size.\n    item_fit_score = np.where(feasible_bins, np.exp(-10 * np.abs(residual_capacity) / item), 0)\n\n    # 6. Balance: Incentivize using bins with low fill levels when almost full bins are not availabe\n    balance_term = np.where(feasible_bins, 1 - existing_fill_level, 0)\n\n    # Combine priorities. Adjust weights as needed.\n    priorities = (\n        best_fit_priority\n        + 0.6 * fragmentation_penalty\n        + 0.5 * already_full_bonus\n        + 0.8 * item_fit_score\n        + 0.3 * balance_term\n    )\n\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response1.txt_stdout.txt",
    "code_path": "problem_iter8_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: Only consider bins that can fit the item.\n    feasible_bins = bins_remain_cap >= item\n\n    # If no bin can accommodate, return a low priority for all bins.\n    if not np.any(feasible_bins):\n        return priorities - 1.0\n\n    # 2. Best Fit Criterion: Prioritize bins with remaining capacity closest to the item size.\n    residual_capacity = bins_remain_cap - item\n    best_fit_priority = np.where(feasible_bins, np.exp(-20 * np.abs(residual_capacity) / item), 0)\n\n    # 3. Minimize Fragmentation: Heavily penalize bins with large residual capacity relative to the item size.\n    fragmentation_penalty = np.where(feasible_bins, -np.exp(2 * residual_capacity / item) + 1, 0)\n\n    # 4. Encourage Filling: Bonus for bins that are already relatively full. Scale by item size\n    current_fill_level = (np.max(bins_remain_cap) - bins_remain_cap) / np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else 0\n    already_full_bonus = feasible_bins * current_fill_level * (item / np.max(bins_remain_cap)) if np.max(bins_remain_cap) > 0 else feasible_bins * current_fill_level\n\n    # 5. Ensure Item Fits Reasonably Well: Penalize bins where the item barely fits.\n    item_barely_fits_penalty = np.where(feasible_bins, -np.exp(-10 * residual_capacity / item), 0)\n\n\n    # Combine priorities with carefully chosen weights.\n    priorities = (\n        2 * best_fit_priority\n        + 1.5 * fragmentation_penalty\n        + already_full_bonus\n        + 0.5 * item_barely_fits_penalty\n    )\n\n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response2.txt_stdout.txt",
    "code_path": "problem_iter8_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: Only consider bins that can fit the item.\n    feasible_bins = bins_remain_cap >= item\n\n    # If no bin can accommodate, return a low priority for all bins.\n    if not np.any(feasible_bins):\n        return priorities - 1.0\n\n    # 2. Best Fit Criterion: Prioritize bins with remaining capacity closest to the item size.\n    residual_capacity = bins_remain_cap - item\n    best_fit_priority = np.where(feasible_bins, np.exp(-20 * np.abs(residual_capacity)), 0) # Sharper exponential\n\n    # 3. Minimize Fragmentation: Penalize bins with large residual capacity after placement.\n    fragmentation_penalty = np.where(feasible_bins, np.exp(-1 * residual_capacity / item), 0) # Scale by item size\n\n    # 4. Encourage Filling: Bonus for bins that are already relatively full. Direct fill level used.\n    already_full_bonus = feasible_bins * (1 - bins_remain_cap / np.max(bins_remain_cap)) if np.max(bins_remain_cap) > 0 else np.zeros_like(bins_remain_cap)\n\n    # 5. Item Fit: Prioritize bins where item fits well relative to item size. Stronger item fit score\n    item_fit_score = np.where(feasible_bins, np.exp(-10 * np.abs(residual_capacity) / item), 0)\n\n    # Combine priorities. Adjust weights as needed.\n    priorities = (\n        best_fit_priority\n        + 0.6 * fragmentation_penalty\n        + 0.5 * already_full_bonus\n        + 0.9 * item_fit_score\n    )\n\n    return priorities",
    "response_id": 2,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response3.txt_stdout.txt",
    "code_path": "problem_iter8_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: Only consider bins that can fit the item.\n    feasible_bins = bins_remain_cap >= item\n\n    # 2. Best Fit Criterion: Prefer bins with remaining capacity closest to the item size.\n    residual_capacity = bins_remain_cap - item\n    best_fit_priority = np.where(feasible_bins, np.exp(-np.abs(residual_capacity) / item), 0)\n\n    # 3. Avoid Fragmentation: Penalize bins with too much remaining capacity after placing the item.\n    fragmentation_penalty = np.where(feasible_bins, np.exp(-0.5 * residual_capacity / np.max(bins_remain_cap)), 1)\n\n    # 4. Filling Existing Bins: Prioritize bins that are already somewhat full.\n    existing_fill_level = bins_remain_cap / np.max(bins_remain_cap)\n    existing_fill_priority = np.where(feasible_bins, 1 - existing_fill_level, 0)\n\n    # Combine priorities multiplicatively and additively\n    priorities = best_fit_priority * fragmentation_penalty + 0.1 * existing_fill_priority\n\n    # If no bin is feasible, choose the one with least waste if we were to put it in\n    if not np.any(feasible_bins):\n      priorities = -np.abs(bins_remain_cap - item)\n\n    return priorities",
    "response_id": 3,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response4.txt_stdout.txt",
    "code_path": "problem_iter8_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_size = np.max(bins_remain_cap)\n\n    # 1. Feasibility: Only consider bins that can fit the item.  Infeasible bins get a large negative priority.\n    feasible_bins = bins_remain_cap >= item\n    priorities = np.where(~feasible_bins, -1e9, priorities)\n\n    # 2. Best Fit Criterion: Prefer bins with remaining capacity closest to the item size.\n    residual_capacity = bins_remain_cap - item\n    best_fit_priority = np.where(feasible_bins, np.exp(-5 * np.abs(residual_capacity) / bin_size), 0) # Scale by bin size\n\n    # 3. Avoid Fragmentation: Penalize bins with too much remaining capacity after placing the item.  Scale penalty by item size.  Make it cubic to penalize more heavily.\n    fragmentation_penalty = np.where(feasible_bins, -10 * (residual_capacity / bin_size)**3 * (item / bin_size), 0)\n\n    # 4. Bonus for Almost Full Bins: Encourage filling nearly full bins.\n    almost_full_bonus = np.where(feasible_bins, 5 * np.exp(-10 * np.abs(residual_capacity) / bin_size), 0)\n\n    # 5. Prioritize bins that are already somewhat full to avoid starting new bins unnecessarily.\n    existing_fill_level = (bin_size - bins_remain_cap) / bin_size\n    existing_fill_priority = np.where(feasible_bins, 2 * existing_fill_level * (item / bin_size), 0)  # Scale by item size\n\n    # 6. Slightly prefer bins with larger remaining capacity, but only if feasible\n    larger_cap_bonus = np.where(feasible_bins, 0.1 * bins_remain_cap / bin_size, 0)\n\n    # Combine priorities\n    priorities = best_fit_priority + fragmentation_penalty + almost_full_bonus + existing_fill_priority + larger_cap_bonus\n\n    return priorities",
    "response_id": 4,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response5.txt_stdout.txt",
    "code_path": "problem_iter8_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)  # Assuming all bins have the same capacity\n\n    # 1. Feasibility: Only consider bins that can fit the item.\n    feasible_bins = bins_remain_cap >= item\n\n    # 2. Best Fit: Reward bins where the remaining capacity after placing the item is minimal.\n    residual_capacity = bins_remain_cap - item\n    best_fit_priority = np.where(feasible_bins, np.exp(-5 * residual_capacity / bin_capacity), 0)\n\n    # 3. Fragmentation Penalty: Heavily penalize creating small fragments, scaled to item size.\n    # Cubic penalty makes smaller fragments much less desirable\n    fragmentation_penalty = np.where(feasible_bins, -10 * (residual_capacity / bin_capacity)**3 * item, 0)\n\n\n    # 4. Reward Near-Full Bins: Encourage filling bins that are already close to full.\n    near_full_bonus = np.where(feasible_bins, ((bin_capacity - bins_remain_cap) / bin_capacity)**2 * item, 0)\n\n    # 5. Combine Factors: Emphasize best fit and penalize fragmentation, with a small bonus for near-full bins.\n    priorities = best_fit_priority + fragmentation_penalty + near_full_bonus\n\n    # Ensure infeasible bins have -inf priority\n    priorities = np.where(feasible_bins, priorities, -np.inf)\n\n    return priorities",
    "response_id": 5,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response6.txt_stdout.txt",
    "code_path": "problem_iter8_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)\n\n    # 1. Feasibility: Only consider bins that can fit the item.\n    feasible_bins = bins_remain_cap >= item\n\n    # 2. Best Fit Criterion: Prefer bins with remaining capacity closest to the item size.\n    residual_capacity = bins_remain_cap - item\n    best_fit_priority = np.where(feasible_bins, np.exp(-2 * np.abs(residual_capacity) / item), 0)  # Scale by item size\n\n    # 3. Avoid Fragmentation: Penalize bins with too much remaining capacity after placing the item.\n    fragmentation_penalty = np.where(feasible_bins, np.exp(-0.5 * residual_capacity / bin_capacity), 0)  # Scale by bin size\n\n    # 4. Bonus for Almost Full Bins: Encourage filling nearly full bins.\n    almost_full_bonus = np.where(feasible_bins, np.exp(-5 * np.abs(residual_capacity) / bin_capacity), 0)  # Scale by bin capacity\n\n    # 5. Prioritize bins that are already somewhat full to avoid starting new bins unnecessarily.\n    existing_fill_priority = feasible_bins * (1 - bins_remain_cap / bin_capacity)  # Use ratio of filled capacity\n\n    # 6. Item Size consideration: Give higher priority to bins which can fit the item perfectly or with minimal waste, relative to the item size.\n    item_size_priority = np.where(feasible_bins, np.exp(-1 * residual_capacity / item), 0)\n\n    priorities = (\n        best_fit_priority\n        + 0.4 * fragmentation_penalty\n        + 0.7 * almost_full_bonus\n        + 0.1 * existing_fill_priority\n        + 0.3 * item_size_priority\n    )\n\n    return priorities",
    "response_id": 6,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response7.txt_stdout.txt",
    "code_path": "problem_iter8_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Feasibility check\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        return priorities - 1.0  # Return low priority if no bin fits\n\n    # Residual capacity after placing the item\n    residual_capacity = bins_remain_cap - item\n\n    # 1. Best Fit Criterion (Exponential, scaled by item size)\n    best_fit_priority = np.where(feasible_bins, np.exp(-5 * np.abs(residual_capacity) / item), 0)\n\n    # 2. Fragmentation Penalty (Exponential, scaled by item size)\n    fragmentation_penalty = np.where(feasible_bins, np.exp(-1 * residual_capacity / item), 0)\n\n    # 3. Encourage Filling (Bonus based on current fill level)\n    existing_fill_level = (bins_remain_cap) / np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else 0\n    already_full_bonus = feasible_bins * existing_fill_level\n\n    # 4. Reward bins close to being full after placement\n    near_full_threshold = 0.1 * item\n    near_full_bonus = np.where((residual_capacity >= 0) & (residual_capacity <= near_full_threshold), 1.0, 0.0)\n\n    # Combine priorities with adjusted weights\n    priorities = (\n        best_fit_priority\n        + 0.6 * fragmentation_penalty\n        + 0.4 * already_full_bonus\n        + 0.7 * near_full_bonus\n    )\n\n    return priorities",
    "response_id": 7,
    "obj": 3.9389708815317115,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response8.txt_stdout.txt",
    "code_path": "problem_iter8_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_size = np.max(bins_remain_cap)\n\n    # 1. Feasibility: Only consider bins that can fit the item.\n    feasible_bins = bins_remain_cap >= item\n\n    # If no bin is feasible, consider relative capacity. Open a new bin.\n    if not np.any(feasible_bins):\n         return bins_remain_cap / bin_size # Return ratio of remaining capacity to bin size\n\n    # 2. Normalize remaining capacity. (unused, but good to keep for potential features)\n    normalized_cap = bins_remain_cap / bin_size\n\n    # 3. Best Fit Criterion: Prioritize bins with the smallest remaining capacity after placing the item.\n    residual_capacity = bins_remain_cap - item\n    best_fit_priority = np.where(feasible_bins, bin_size / (residual_capacity + 1e-9), 0) # Use bin size to scale priority.\n    best_fit_priority *= 2  # Increased importance\n\n    # 4. Fragmentation Penalty: Heavily penalize small gaps after placement.  Scale with bin_size\n    fragmentation_penalty = np.where(feasible_bins, np.exp(-5 * residual_capacity / bin_size), 0)\n    fragmentation_penalty *= bin_size / 2 # Reduce penalty strength, but scaled to bin size\n\n    # 5. Near-Full Reward: Encourage filling bins close to full with a stronger non-linear scaling.\n    almost_full_bonus = np.where(feasible_bins, np.exp(-10 * (residual_capacity / bin_size)**2), 0)\n    almost_full_bonus *= 3 # Increased bonus strength\n\n    # 6. Explicit Small Gap Penalty: Penalize remaining capacity below a certain threshold.\n    small_gap_threshold = 0.1 * bin_size\n    small_gap_penalty = np.where(feasible_bins & (residual_capacity < small_gap_threshold), -bin_size/5, 0) #Scale penalty with bin size and make it negative.\n\n\n    # 7. Introduce a capacity utilization reward. Higher utilization is better.\n    capacity_utilization = np.where(feasible_bins, (bin_size - residual_capacity) / bin_size, 0)\n    capacity_reward = capacity_utilization * bin_size # scale with bin size\n\n    priorities = best_fit_priority + almost_full_bonus + fragmentation_penalty + small_gap_penalty + capacity_reward\n    \n    #Ensure no negative priorities.\n    priorities = np.maximum(priorities, 0)\n\n    return priorities",
    "response_id": 8,
    "obj": 4.098524132429212,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response9.txt_stdout.txt",
    "code_path": "problem_iter8_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_size = np.max(bins_remain_cap)\n\n    # 1. Feasibility: Only consider bins that can fit the item. Infeasible bins get a large negative priority.\n    feasible_bins = bins_remain_cap >= item\n    priorities = np.where(~feasible_bins, -1e9, priorities)\n\n    # 2. Best Fit Criterion: Prefer bins with remaining capacity closest to the item size.\n    residual_capacity = bins_remain_cap - item\n    best_fit_priority = np.where(feasible_bins, np.exp(-5 * np.abs(residual_capacity) / bin_size), 0)  # Scale by bin size\n\n    # 3. Avoid Fragmentation: Penalize bins with too much remaining capacity after placing the item. Scale penalty by item size. Make it cubic to penalize more heavily.\n    fragmentation_penalty = np.where(feasible_bins, -10 * (residual_capacity / bin_size)**3 * (item / bin_size), 0)\n\n    # 4. Reward Existing Fill Levels: Prioritize bins that are already somewhat full to avoid starting new bins unnecessarily. Scale by item size.\n    existing_fill_level = (bin_size - bins_remain_cap) / bin_size\n    existing_fill_priority = np.where(feasible_bins, 2 * existing_fill_level * (item / bin_size), 0)  # Scale by item size\n\n    # Combine priorities\n    priorities = best_fit_priority + fragmentation_penalty + existing_fill_priority\n\n    return priorities",
    "response_id": 9,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response0.txt_stdout.txt",
    "code_path": "problem_iter9_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_size = 1.0 # Assuming bin size is 1, can be generalized.\n\n    # 1. Feasibility: Only consider bins that can fit the item.  Penalize infeasible bins hard.\n    feasible_bins = bins_remain_cap >= item\n    priorities = np.where(~feasible_bins, -1e9, priorities) # Large negative priority for infeasible bins\n\n    # 2. Best Fit Criterion: Prefer bins with remaining capacity closest to the item size.\n    residual_capacity = bins_remain_cap - item\n    best_fit_priority = np.where(feasible_bins, np.exp(-5 * np.abs(residual_capacity) / item), 0)\n\n    # 3. Avoid Fragmentation: Penalize bins with too much remaining capacity after placing the item. Cubic penalty to punish fragmentation.\n    fragmentation_penalty = np.where(feasible_bins, 1 - (residual_capacity / bin_size)**3, 0)\n    fragmentation_penalty = np.clip(fragmentation_penalty, 0, 1) # Ensure penalty is between 0 and 1.\n\n    # 4. Bonus for Almost Full Bins: Reward near-full bins directly.\n    almost_full_bonus = np.where(feasible_bins, np.exp(-10 * np.abs(residual_capacity)), 0)\n\n    # 5. Item Size consideration: Prefer bins that result in minimal waste relative to the item size.\n    item_size_priority = np.where(feasible_bins, np.exp(-5 * residual_capacity / item), 0)\n\n    # Combine the heuristics multiplicatively, focusing on best-fit and fragmentation.\n    priorities = best_fit_priority * fragmentation_penalty * (1 + almost_full_bonus) * (1 + item_size_priority)\n\n    return priorities",
    "response_id": 0,
    "obj": 4.198244914240141,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response1.txt_stdout.txt",
    "code_path": "problem_iter9_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_size = np.max(bins_remain_cap) # Implicitly relies on bins having the same capacity\n\n    # Feasibility check:\n    feasible = bins_remain_cap >= item\n\n    # Best-fit scaled to item size:\n    residual = bins_remain_cap - item\n    best_fit = np.where(feasible, np.exp(-2 * np.abs(residual) / item), 0)\n\n    # Fragmentation penalty (cubic):\n    frag_penalty = np.where(feasible, 1 - (residual / bin_size)**3, 0)\n    frag_penalty = np.clip(frag_penalty, 0, 1) # Ensure penalty is within [0, 1]\n\n    # Near-full reward:\n    near_full_reward = np.where(feasible, np.exp(-5 * np.abs(residual) / bin_size), 0)\n\n    # Infeasibility penalty (large negative value):\n    infeasibility_penalty = np.where(~feasible, -1e9, 0)\n\n    # Learned weights (example values):\n    w_best_fit = 0.4\n    w_frag = 0.3\n    w_near_full = 0.3\n\n    # Multiplicative combination:\n    priorities = w_best_fit * best_fit + w_frag * frag_penalty + w_near_full * near_full_reward + infeasibility_penalty\n\n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response2.txt_stdout.txt",
    "code_path": "problem_iter9_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap) #Assume all bins have same capacity\n\n    # 1. Feasibility (Hard Constraint): Only consider bins that can fit the item.\n    feasible_bins = bins_remain_cap >= item\n\n    # 2. Best Fit (Item-Relative Scaling): Prioritize bins where the remaining capacity after placing the item is small relative to the item size.\n    residual_capacity = bins_remain_cap - item\n    best_fit = np.where(feasible_bins, np.exp(-3 * residual_capacity / item), 0)\n\n    # 3. Fragmentation Avoidance (Cubic Penalty): Heavily penalize bins that would result in significant fragmentation.\n    fragmentation_penalty = np.where(feasible_bins, 1 - np.power(residual_capacity / bin_capacity, 3), 0)\n\n    # 4. Near-Full Reward (Direct Reward): Directly reward bins that are close to being full after placing the item.\n    near_full_reward = np.where(feasible_bins, np.exp(-5 * residual_capacity/bin_capacity), 0)\n\n    # Explicit Infeasibility penalty\n    priorities = feasible_bins * (0.5 * best_fit + 0.3 * fragmentation_penalty + 0.2 * near_full_reward)\n\n    return priorities",
    "response_id": 2,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response3.txt_stdout.txt",
    "code_path": "problem_iter9_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap) # Assume all bins have same capacity\n    \n    # 1. Feasibility: Only consider bins that can fit the item. Infeasible bins get a very large negative priority.\n    feasible_bins = bins_remain_cap >= item\n    priorities = np.where(~feasible_bins, -1e9, 0) # Penalize infeasible bins harshly.\n\n    # 2. Best Fit Criterion: Prioritize bins where residual capacity is small (item-relative scaling).\n    residual_capacity = bins_remain_cap - item\n    best_fit_priority = np.where(feasible_bins, np.exp(-5 * residual_capacity / item), 0)\n\n    # 3. Fragmentation Avoidance: Heavily penalize leaving too much space (cubic penalty).\n    fragmentation_penalty = np.where(feasible_bins, np.exp(-10 * (residual_capacity / bin_capacity)**3), 1)\n\n    # 4. Reward Near-Full Bins: Directly reward bins close to being full after placement.\n    near_full_reward = np.where(feasible_bins, np.exp(-5 * np.abs(residual_capacity / bin_capacity)), 0)\n\n    # 5. Learned Weights (Illustrative): These would ideally be learned.\n    w_best_fit = 0.6\n    w_fragmentation = 0.2\n    w_near_full = 0.2\n\n    # 6. Combine Heuristics Multiplicatively:\n    priorities = np.where(feasible_bins, w_best_fit * best_fit_priority * w_fragmentation * fragmentation_penalty + w_near_full * near_full_reward, priorities)\n\n    # 7. Directly Reward Almost Full (even more direct than near_full_reward).\n    almost_full_bonus = np.where(feasible_bins & (residual_capacity <= 0.1 * bin_capacity), 1.0, 0.0) # Binary Reward\n    priorities = np.where(almost_full_bonus>0, priorities+1, priorities)\n\n    return priorities",
    "response_id": 3,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response4.txt_stdout.txt",
    "code_path": "problem_iter9_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    num_bins = len(bins_remain_cap)\n    bin_size = 1 # Implicitly assume bin size is 1, as capacity is the only info given\n\n    # 1. Feasibility: Only consider bins that can fit the item.  Explicit Infeasibility Penalty\n    feasible_bins = bins_remain_cap >= item\n    priorities = np.where(~feasible_bins, -1e9, priorities)  # Massive penalty for infeasible bins\n\n\n    # 2. Best Fit (Item-Relative):  Maximize use of bin relative to item size.\n    residual_capacity = bins_remain_cap - item\n    best_fit_score = np.where(feasible_bins, np.exp(-5 * np.abs(residual_capacity) / item), 0)\n\n\n    # 3. Fragmentation Avoidance (Cubic Penalty): Heavily penalize leaving small gaps.\n    fragmentation_penalty = np.where(feasible_bins, -10 * (residual_capacity / bin_size)**3, 0) #Cubic penalty, scaled by bin size\n\n    # 4. Reward Near-Full Bins:  Incentivize completely filling bins.\n    near_full_reward = np.where(feasible_bins, np.exp(-20 * np.abs(residual_capacity) / bin_size), 0) #Scaled by bin size\n\n    # Combine Heuristics Multiplicatively & Additively\n    priorities = best_fit_score * (1 + near_full_reward) + fragmentation_penalty\n\n\n    return priorities",
    "response_id": 4,
    "obj": 4.048663741523748,
    "exec_success": true
  }
]