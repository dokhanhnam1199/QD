```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Generates heuristics for the Traveling Salesman Problem (TSP)
    based on a combination of distance and node degree.

    Args:
        distance_matrix (np.ndarray): A square matrix representing the
                                       pairwise distances between cities.
                                       distance_matrix[i, j] is the distance
                                       from city i to city j.

    Returns:
        np.ndarray: A matrix of the same shape as distance_matrix,
                      containing heuristic values for each edge. Higher
                      values indicate more promising edges.
    """

    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix, dtype=float)

    # Calculate a basic inverse distance heuristic
    inverse_distance = 1.0 / (distance_matrix + np.eye(n)) # avoid divide by zero and self-loops

    # Calculate a degree-based heuristic.  Prioritize connecting nodes with low connectivity
    # to encourage diverse exploration and avoid premature closure of short loops.

    degree_penalty = np.zeros_like(distance_matrix, dtype=float)

    # Degree penalty calculation: Nodes with smaller distance to other nodes contribute less penalty, or if a node is far from everywhere, this node is still penalized.
    total_inverse_distance = np.sum(inverse_distance, axis=0)

    degree_factor = total_inverse_distance / np.mean(total_inverse_distance) #normalize by mean for a robust range

    for i in range(n):
        for j in range(n):
            degree_penalty[i,j] = min(degree_factor[i], degree_factor[j])  # penalized based on low connectivity (i.e., far from other nodes in the matrix)



    # Combine the heuristics (inverse distance and degree)
    heuristics = inverse_distance * degree_penalty


    # Normalize heuristics.  Avoid excessively large or small values and possible zero divisions later on.
    min_h = np.min(heuristics)
    max_h = np.max(heuristics)

    if max_h - min_h > 0:
      heuristics = (heuristics - min_h) / (max_h - min_h)
    else:
      heuristics = np.ones_like(heuristics) #All values are same

    return heuristics
```
