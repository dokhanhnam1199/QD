```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristics for TSP using a combination of inverse distance,
    a "Tesla potential" inspired by electrical fields (nodes repel each other),
    and a simple attractiveness factor to the starting node.

    Args:
        distance_matrix: A numpy array representing the distance between cities.

    Returns:
        A numpy array representing the heuristic values for each edge.
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix, dtype=float)

    # Inverse distance - shorter distances are more promising
    inverse_distance = 1.0 / (distance_matrix + 1e-9)  # Avoid division by zero
    heuristics += inverse_distance

    # "Tesla Potential" - nodes repel each other based on distance
    for i in range(n):
        for j in range(n):
            if i != j:
                # Calculate the "electric field" strength between nodes
                repulsion = -1.0 * (1.0 / (distance_matrix[i, j] + 1e-9))
                heuristics[i, j] += repulsion #nodes tend to not go together. Avoid repeating edges

    # Attractiveness to the starting node - encourages returning to the origin
    start_node_attraction = np.zeros((n,n))
    for i in range(n):
        start_node_attraction[0,i] = 0.5 #Attractiveness to return to node 0
        start_node_attraction[i,0] = 0.5
    heuristics += start_node_attraction

    # Normalize the heuristics to be between 0 and 1 (approximately)
    max_val = np.max(heuristics)
    min_val = np.min(heuristics)

    if max_val > min_val:
        heuristics = (heuristics - min_val) / (max_val - min_val) #Rescale values
    else:
        heuristics = np.ones_like(heuristics) #return values close to 1

    return heuristics
```
