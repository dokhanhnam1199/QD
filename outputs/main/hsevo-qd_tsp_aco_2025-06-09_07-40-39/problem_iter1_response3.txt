```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Generates heuristics for the Traveling Salesman Problem (TSP) based on
    a combination of distance, a nearest neighbor idea, and a penalty
    for closing subtours too early. This approach balances exploration and
    exploitation.

    Args:
        distance_matrix (np.ndarray): A square matrix where
            distance_matrix[i, j] is the distance between city i and city j.
            Diagonals (i.e., distance_matrix[i, i]) should be sufficiently
            large (e.g., np.inf) to prevent self-loops.

    Returns:
        np.ndarray: A heuristic matrix of the same shape as
        distance_matrix, indicating the desirability of including each edge
        in the solution. Higher values indicate more promising edges.
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)

    # 1. Inverse Distance Component (like v1)
    inverse_distance = 1 / distance_matrix
    inverse_distance[np.isinf(inverse_distance)] = 0  # Handle potential infinities

    # 2. Nearest Neighbor Component
    nearest_neighbor = np.zeros_like(distance_matrix)
    for i in range(n):
        # Find the closest 'k' neighbors for city 'i'
        k = min(5, n - 1) #consider at most 5 nearest neighbours
        neighbors = np.argsort(distance_matrix[i, :])[1:k+1] # Exclude self-loop
        for j in neighbors:
            nearest_neighbor[i, j] = 1  # Mark as nearest neighbor

    # 3. Subtour Prevention (Rudimentary)
    subtour_penalty = np.ones_like(distance_matrix)

    # The subtour penalty encourages longer edges initially and punishes forming
    # very small cycles early in the construction process.  This is a simple
    # implementation; more sophisticated subtour elimination methods could be
    # included for better performance.
    average_distance = np.mean(distance_matrix[~np.isinf(distance_matrix)])
    subtour_penalty[distance_matrix < (0.2 * average_distance)] = 0.2 # Penalize too short edges in initial exploration

    # Combine the components. Weights can be tuned.
    heuristics = (0.6 * inverse_distance +
                  0.3 * nearest_neighbor +
                  0.1 * subtour_penalty)

    return heuristics
```
