```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    TSP Heuristics function based on distance and node degree.

    Inspired by Tesla's understanding of fields and potentials,
    this heuristic considers both the inverse distance between nodes
    (representing a "potential field") and a node degree penalty
    to encourage balanced exploration and prevent premature convergence
    on high-degree nodes (representing "overloaded" points).

    Args:
        distance_matrix (np.ndarray): Distance matrix representing the TSP problem.

    Returns:
        np.ndarray: Prior indicators of edge promise.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # Calculate inverse distance (potential field)
    inverse_distance = 1.0 / (distance_matrix + 1e-9)  # Adding small constant to avoid division by zero

    # Node degree penalty (normalized). Higher degree nodes are penalized more.
    degree_penalty = np.zeros_like(distance_matrix, dtype=float)
    for i in range(n):
        for j in range(n):
            if i != j:
                # Rough degree estimate: average of inverse distances connected to nodes i and j
                degree_i = np.sum(inverse_distance[i, :]) - inverse_distance[i,i]
                degree_j = np.sum(inverse_distance[j, :]) - inverse_distance[j,j]

                # Scale degree to (0,1). If distance are all close, then the penalty is less effective.
                max_degree = n * np.max(inverse_distance) # an over estimate but that is okay, degree penalty will not overpower inverse_distance.

                normalized_degree_i = degree_i / max_degree if max_degree > 0 else 0
                normalized_degree_j = degree_j / max_degree if max_degree > 0 else 0

                degree_penalty[i, j] = (normalized_degree_i + normalized_degree_j)/2.0
    # Combine inverse distance and degree penalty. Higher the inverse_distance and lower the penalty, the better the heuristic.
    heuristic_matrix = inverse_distance * np.exp(-degree_penalty)

    return heuristic_matrix
```
