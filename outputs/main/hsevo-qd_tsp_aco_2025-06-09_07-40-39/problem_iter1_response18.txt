```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristics for the Traveling Salesman Problem based on a combination of distance and node connectivity.

    This heuristic combines inverse distance with a measure of how "central" a node is.  Nodes that are
    generally closer to other nodes (higher degree centrality in a distance-weighted graph) are favored
    more.  This attempts to balance greedily choosing short edges with encouraging routes to pass through
    well-connected nodes.

    Args:
        distance_matrix (np.ndarray): A square matrix where element (i, j) is the distance between node i and node j.

    Returns:
        np.ndarray: A matrix of the same shape as distance_matrix, where each element (i, j) represents
                    a prior indicator of how promising it is to include the edge between node i and node j
                    in a TSP solution.  Higher values indicate a more promising edge.  Zero distances are avoided
                    by adding a tiny value.
    """
    n = distance_matrix.shape[0]
    epsilon = 1e-9  # Small value to avoid division by zero
    
    # Inverse distance, but avoid div by zero.
    inverse_distance = 1 / (distance_matrix + np.eye(n) * epsilon)  # Add epsilon only on diagonal.

    # Node centrality: how close is each node to all other nodes on average?
    # High centrality means the node is "central" to the graph.
    node_centrality = np.sum(inverse_distance, axis=1)

    # Combine inverse distance and node centrality. Give preference to
    # edges connecting to high-centrality nodes *on both sides of the edge.*
    heuristic_matrix = inverse_distance * np.outer(node_centrality, node_centrality)

    #Set diagonal to zero to discourage self loops
    np.fill_diagonal(heuristic_matrix, 0)

    return heuristic_matrix
```
