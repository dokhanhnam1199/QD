```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristics for TSP based on a combination of inverse distance and node degree.

    This version tries to balance short edge distances with an awareness of
    overall connectivity. It gives higher prior indicators to edges that are short
    and connect to relatively "sparse" nodes. The core idea is that
    connecting sparsely connected nodes via a short distance offers a good opportunity
    to decrease the overall tour length without prematurely locking nodes.

    Args:
        distance_matrix: A numpy array representing the distance matrix.

    Returns:
        A numpy array of the same shape as distance_matrix, representing
        prior indicators for each edge.
    """

    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix, dtype=float)

    # Calculate node degree (number of close neighbors) for each node.
    # A simple approximation is to count neighbors within a certain radius.
    # The radius can be set relative to the average distance.
    avg_distance = np.mean(distance_matrix[np.triu_indices_from(distance_matrix, k=1)])
    radius = avg_distance * 0.8  # Adjust this factor as needed.

    node_degrees = np.zeros(n)
    for i in range(n):
        node_degrees[i] = np.sum(distance_matrix[i, :] < radius) - 1 # Subtract 1 for itself

    # The lower the degree the more sparse the node, so the higher the "sparseness_indicator".
    # Normalize node degrees to be in the range [0, 1].
    normalized_degrees = node_degrees / (n - 1) # degree between 0 to 1

    # Calculate the "sparseness_indicator" based on node degree.
    sparseness_indicator = 1.0 - normalized_degrees  # higher = sparser

    for i in range(n):
        for j in range(n):
            if i != j:
                # A good edge is short AND connects to sparse nodes
                heuristics[i, j] = (1 / distance_matrix[i, j]) * (sparseness_indicator[i] + sparseness_indicator[j]) / 2.0 #average sparseness indicator for two nodes

            else:
                heuristics[i, j] = 0.0 # Avoid self-loops

    return heuristics
```
