```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    A more sophisticated heuristics function for the Traveling Salesman Problem (TSP).
    This version incorporates a combination of inverse distance, a simulated annealing-inspired temperature,
    and a local search influence to prioritize promising edges.

    Args:
        distance_matrix (np.ndarray): A square matrix where distance_matrix[i, j] represents the distance between node i and node j.

    Returns:
        np.ndarray: A matrix of the same shape as distance_matrix, representing the desirability of each edge.
                      Higher values indicate more promising edges.
    """

    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix, dtype=float)

    # Inverse distance (basic desirability)
    inverse_distance = 1.0 / (distance_matrix + 1e-9)  # Add a small constant to avoid division by zero

    # Temperature parameter (simulated annealing influence) - promotes exploration early on.
    # This effectively reduces the influence of very short edges early in the search,
    # allowing for exploration of longer, potentially better paths.
    temperature = np.mean(distance_matrix)  # Could also be a function of iteration number
    annealed_inverse_distance = inverse_distance * (1 - np.exp(-distance_matrix / temperature))


    # Local search influence: Prioritize edges connected to nodes with high average distance to others.
    # The intuition is that these nodes might be "bridges" between clusters, and including edges
    # connected to them could lead to more efficient tours.
    node_average_distances = np.mean(distance_matrix, axis=0)  # average distance from each node to all other nodes.

    # Normalize the average distances for stability and better range.
    normalized_node_distances = (node_average_distances - np.min(node_average_distances)) / (np.max(node_average_distances) - np.min(node_average_distances) + 1e-9)

    #Create edge weights based on average distance
    edge_weights = np.zeros_like(distance_matrix, dtype=float)
    for i in range(n):
      for j in range(n):
        edge_weights[i,j] = (normalized_node_distances[i] + normalized_node_distances[j]) /2.0


    #Combine the heuristics.
    heuristics = annealed_inverse_distance + 0.5*edge_weights   # Balance the contributions
    # zero out the diagonal
    np.fill_diagonal(heuristics,0)


    return heuristics
```
