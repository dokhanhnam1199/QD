```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Improves upon heuristics_v1 by incorporating node degree considerations,
    encouraging exploration of edges connected to nodes with fewer connections.
    This adds "uncertainty" to avoid being stuck in local minima and promote exploration.
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # Inverse distance, plus small epsilon to avoid division by zero.
    inverse_distance = 1 / (distance_matrix + 1e-9)

    # Calculate node degrees based on inverse distances - like a probability of visiting each edge.
    node_degrees = np.sum(inverse_distance, axis=1, keepdims=True) + np.sum(inverse_distance, axis=0, keepdims=True).T - np.diag(np.diag(inverse_distance)) # sum each edge to estimate degree, and remove diagonal twice.

    # Node importance is the reciprocal of the degree. High degree means a lower value.
    node_importance = 1 / (node_degrees + 1e-9)

    # Heuristic combines inverse distance with node importances.
    # A node is important if the edge coming into it is more uncertain.

    for i in range(n):
        for j in range(n):
            if i != j:
                heuristic_matrix[i, j] = inverse_distance[i, j] * (node_importance[i, 0] + node_importance[j, 0])

    return heuristic_matrix
```
