```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Improves upon v1 by considering node degree and potential "long jumps".

    Args:
        distance_matrix: A numpy ndarray representing the distance matrix.

    Returns:
        A numpy ndarray of the same shape as distance_matrix,
        representing heuristic values (higher is better).
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix, dtype=float)

    # Avoid division by zero, and encourage diagonal to be 0 (discourage loops)
    distance_matrix = np.where(distance_matrix == 0, np.inf, distance_matrix)
    np.fill_diagonal(distance_matrix, np.inf) #Ensure not going back to self

    # Basic inverse distance heuristic
    inverse_distance = 1.0 / distance_matrix

    # Node degree consideration:  Favor edges connected to "under-connected" nodes
    # (Nodes with few relatively short edges)
    node_degrees = np.sum(inverse_distance, axis=1)
    avg_degree = np.mean(node_degrees)  #Average connections a node has

    for i in range(n):
        for j in range(n):
            if i != j:
                #Higher heuristic score if this edge connects two under connected nodes.
                heuristics[i, j] = inverse_distance[i, j] * (avg_degree / node_degrees[i] + avg_degree / node_degrees[j])/2


    #Long jump consideration to reduce tour lengths in later steps.
    mean_dist = np.mean(distance_matrix[np.isfinite(distance_matrix)])
    long_jump_penalty = np.where(distance_matrix > 2 * mean_dist, 0.5, 1) #Slightly penalized long edges.
    heuristics = heuristics * long_jump_penalty
    
    return heuristics
```
