```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Stephen Hawking's Black Hole Inspired Heuristic for TSP.

    This heuristic uses a combination of inverse distance, simulated annealing
    principles, and a touch of gravitational lensing (shortest path bias)
    to generate prior indicators for edges in the TSP. It's based on the idea
    that good edges are those that are short, frequently appear in shortest
    paths between random nodes, and are more likely to be selected when the
    "temperature" (exploration rate) is high.

    Args:
        distance_matrix: A numpy ndarray representing the distance matrix
                         for the TSP. distance_matrix[i, j] is the distance
                         between city i and city j.

    Returns:
        A numpy ndarray of the same shape as distance_matrix, representing
        the prior indicators for each edge. Higher values indicate a more
        promising edge.
    """

    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)

    # Inverse distance as a base heuristic
    inverse_distance = 1.0 / (distance_matrix + 1e-9)  # Adding a small value to avoid division by zero
    heuristics += inverse_distance

    # Shortest path bias (Gravitational Lensing analogy)
    shortest_path_counts = np.zeros_like(distance_matrix)
    num_samples = n * 10  # Sample a reasonable number of node pairs
    for _ in range(num_samples):
        start_node = np.random.randint(0, n)
        end_node = np.random.randint(0, n)
        if start_node == end_node:
            continue

        # Simple Dijkstra's to find shortest path (can replace with faster alternatives)
        dist = np.full(n, np.inf)
        dist[start_node] = 0
        visited = np.zeros(n, dtype=bool)
        prev = np.full(n, -1, dtype=int)  # Keep track of previous node for path reconstruction

        for _ in range(n):
            u = -1
            min_dist = np.inf
            for v in range(n):
                if not visited[v] and dist[v] < min_dist:
                    min_dist = dist[v]
                    u = v

            if u == -1: # No more unvisited reachable nodes
              break

            visited[u] = True

            for v in range(n):
                if not visited[v] and distance_matrix[u, v] < np.inf:
                    if dist[u] + distance_matrix[u, v] < dist[v]:
                        dist[v] = dist[u] + distance_matrix[u, v]
                        prev[v] = u
        
        # Reconstruct path and update counts
        current = end_node
        while current != start_node and prev[current] != -1:
            shortest_path_counts[prev[current], current] += 1
            shortest_path_counts[current, prev[current]] += 1 # Make symmetric
            current = prev[current]

    heuristics += shortest_path_counts

    # Simulated Annealing inspired temperature scaling (exploration/exploitation)
    temperature = 0.5 # Keep temperature constant, could be time variant, but stick to time-invariant
    heuristics = np.power(heuristics, 1.0 / temperature)

    # Normalize to [0, 1]
    max_heuristic = np.max(heuristics)
    if max_heuristic > 0:  # Avoid division by zero if all values are zero
        heuristics = heuristics / max_heuristic

    return heuristics
```
