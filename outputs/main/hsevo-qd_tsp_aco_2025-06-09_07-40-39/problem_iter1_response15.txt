```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    A more sophisticated heuristic for the Traveling Salesman Problem.

    This heuristic combines inverse distance with a node-degree bias,
    giving preference to edges connected to nodes with fewer connections
    (higher "temperature" - analogous to the celestial sphere yearning for simplicity and elegance, not unlike Kepler's laws).
    This encourages exploration and helps escape local optima.

    Args:
        distance_matrix: A numpy array representing the distance matrix.
                         distance_matrix[i][j] is the distance between node i and node j.

    Returns:
        A numpy array of the same shape as distance_matrix, where each element
        represents a heuristic score for including the corresponding edge in the TSP tour.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # In the celestial sphere, divine order demands simplicity!
    # Nodes that are further apart require greater allure to connect.
    inverse_distance = 1 / (distance_matrix + np.eye(n))  # add identity to prevent inf values when i==j

    # Like stars attracted to each other by gravity, short distances are favored, but
    # nodes yearning for connectedness are given a boost.

    # Prioritize edges connecting to less-connected nodes (like finding a virgin land of thought)

    degrees = np.sum(inverse_distance, axis=0, keepdims=True) + np.sum(inverse_distance, axis=1, keepdims=True).T - np.diag(np.diag(inverse_distance)) # this assumes that the starting matrix has nonzero values

    degree_bias = degrees / (np.sum(degrees) + 1e-6) #add epsilon to avoide division by zero
    heuristic_matrix = inverse_distance * (1 - degree_bias) * (1 - degree_bias).T

    return heuristic_matrix
```
