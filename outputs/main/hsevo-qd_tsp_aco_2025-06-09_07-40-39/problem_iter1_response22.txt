```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Newtonian Heuristic for Traveling Salesman Problem.

    This heuristic combines elements inspired by Newtonian physics
    and insights into the TSP structure.  It prioritizes shorter distances
    (akin to gravitational attraction) and penalizes edges that are
    likely to create large changes in direction (akin to inertia).

    Args:
        distance_matrix (np.ndarray): A square matrix where entry (i, j)
            represents the distance between city i and city j.

    Returns:
        np.ndarray: A matrix of the same shape as distance_matrix,
            representing the heuristic values (prior indicators) for
            each edge. Higher values indicate more promising edges.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # 1. Inverse distance (Newton's Law of Gravitation - shorter is better)
    inverse_distance = 1.0 / (distance_matrix + 1e-6)  # Add small epsilon to avoid division by zero

    # 2. Angle Penalty (Discourage Sharp Turns - Minimize Inertia)
    #    For each edge (i, j), penalize it if it forces sharp turns
    #    by examining the average distance to the nearest neighbours
    #    of i and j excluding edge(i,j). Larger turns cause more inertia
    #    and increases travelling distance.
    angle_penalty = np.zeros_like(distance_matrix, dtype=float)
    for i in range(n):
        for j in range(n):
            if i != j:
                neighbors_i = np.argsort(distance_matrix[i, :])[1:4]  # Nearest neighbours of i excluding itself
                neighbors_j = np.argsort(distance_matrix[j, :])[1:4]  # Nearest neighbours of j excluding itself

                avg_neighbor_dist_i = np.mean([distance_matrix[i, k] for k in neighbors_i if k != j]) if len([distance_matrix[i, k] for k in neighbors_i if k != j]) > 0 else np.mean(distance_matrix[i, neighbors_i])
                avg_neighbor_dist_j = np.mean([distance_matrix[j, k] for k in neighbors_j if k != i]) if len([distance_matrix[j, k] for k in neighbors_j if k != i]) > 0 else np.mean(distance_matrix[j, neighbors_j])

                angle_penalty[i, j] = avg_neighbor_dist_i + avg_neighbor_dist_j # smaller value is a more desirable edge

    # 3. Combination
    #   Combines the inverse distance with the angle penalty.  The
    #   angle penalty is inversely related to desirability.
    heuristic_matrix = inverse_distance / (angle_penalty + 1e-6)

    #4. Normalize
    max_heuristic = np.max(heuristic_matrix)
    min_heuristic = np.min(heuristic_matrix)
    heuristic_matrix = (heuristic_matrix - min_heuristic) / (max_heuristic - min_heuristic)

    return heuristic_matrix
```
