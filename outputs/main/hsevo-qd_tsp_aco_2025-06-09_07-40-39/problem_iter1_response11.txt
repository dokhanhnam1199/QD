```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristics for TSP based on a combination of factors, 
    including inverse distance, node degree desirability, 
    and a touch of stochasticity inspired by quantum mechanics.
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)

    # 1. Inverse Distance (Gravity - attraction is stronger with closer objects)
    inverse_distance = 1.0 / (distance_matrix + 1e-6)  # Avoid division by zero
    heuristics += inverse_distance

    # 2. Node Degree Desirability (Avoiding High-Degree Nodes Too Early)
    #    We discourage connecting to nodes that already have many close neighbors.
    degree_penalty = np.zeros((n, n))
    for i in range(n):
        distances = distance_matrix[i, :]
        sorted_indices = np.argsort(distances)
        # Penalize connections to nodes that are already among the closest to many others
        for j in range(n):
            neighbor_count = 0
            for k in range(n):
                if k != i and k != j and distance_matrix[k, j] < np.mean(distances):  #Check for neighbours. Use mean dist. as a threshold for 'closeness'
                    neighbor_count += 1
            degree_penalty[i,j] = neighbor_count #larger values show high density

    # Rescale degree penalty to [0,1]
    max_penalty = np.max(degree_penalty)
    if max_penalty > 0:
      degree_penalty = degree_penalty / max_penalty

    heuristics -= 0.5 * degree_penalty # Subtract a fraction of the degree penalty.


    # 3. Stochasticity (Quantum Tunneling - probability of unexpected connections)
    #    Introduce a small random perturbation to allow for exploration.
    random_noise = np.random.normal(0, 0.1, size=(n, n))
    heuristics += 0.1 * random_noise


    # 4. Normalize (Rescale heuristic values)
    max_heuristic = np.max(heuristics)
    min_heuristic = np.min(heuristics)
    if max_heuristic > min_heuristic:
        heuristics = (heuristics - min_heuristic) / (max_heuristic - min_heuristic)
    else:
        heuristics = np.ones_like(heuristics)  # All edges equally promising if heuristics are uniform

    return heuristics
```
