```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    A heuristic function for the Traveling Salesman Problem (TSP).

    This version combines inverse distance with a "gravity" inspired factor
    that encourages connections to nodes with high centrality (i.e., are
    closer to many other nodes). It also considers a more nuanced way
    to exploit locality: If nodes `i` and `j` are frequently each other's
    nearest neighbors, the prior should be higher.

    Args:
        distance_matrix: A numpy array representing the distance matrix
                         between cities.  distance_matrix[i, j] is the
                         distance between city i and city j.  It is assumed
                         that distance_matrix[i, i] = np.inf

    Returns:
        A numpy array of the same shape as distance_matrix, representing
        the heuristic values for each edge. Higher values indicate a
        more promising edge.
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # 1. Inverse Distance (basic attraction)
    inverse_distance = 1.0 / (distance_matrix + 1e-9)  # Avoid division by zero
    heuristic_matrix += inverse_distance

    # 2. "Gravity" factor based on centrality
    # The more "central" a node is (lower average distance to others), the more attractive it should be.
    node_centrality = np.mean(distance_matrix, axis=1)
    for i in range(n):
        for j in range(n):
            heuristic_matrix[i, j] += 1.0 / (node_centrality[i] + node_centrality[j] + 1e-9)  # Favor edges connecting central nodes

    # 3. Mutual Nearest Neighbors
    # If i and j are each other's nearest neighbors, that's a good sign.
    mutual_nearest_neighbor_bonus = np.zeros((n, n))
    for i in range(n):
        nearest_neighbors_i = np.argsort(distance_matrix[i, :])
        for k in range(1, n): # start from index 1 to exclude self
            j = nearest_neighbors_i[k]

            nearest_neighbors_j = np.argsort(distance_matrix[j, :])
            for l in range(1,n): # start from index 1 to exclude self
                 if nearest_neighbors_j[l] == i:
                     mutual_nearest_neighbor_bonus[i,j] = 1.0/(k+l)
                     break


    heuristic_matrix += mutual_nearest_neighbor_bonus



    # Ensure no self-loops are encouraged
    for i in range(n):
        heuristic_matrix[i, i] = 0.0


    return heuristic_matrix
```
