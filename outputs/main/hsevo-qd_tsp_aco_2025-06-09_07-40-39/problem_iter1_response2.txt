```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    A heuristic function for the Traveling Salesman Problem (TSP) based on physics principles.

    This heuristic combines inverse distance (gravity) with a temperature-dependent
    exploration factor, inspired by simulated annealing.  Shorter distances are generally
    preferred, but with some randomness to avoid local optima.  A modified gravity inspired method.
    The longer distance the less attractive.

    Args:
        distance_matrix (np.ndarray): A square matrix representing the distances between cities.

    Returns:
        np.ndarray: A matrix of the same shape as distance_matrix, where each element
                      indicates the desirability of including the corresponding edge in a TSP tour.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # Temperature parameter (can be adjusted)
    temperature = np.std(distance_matrix)  # Use std as proxy for global scale to adaptively scale noise
    if temperature == 0:
        temperature = 1.0 # prevent division by zero if all values are identical (unlikely, but robust.)


    # Gravity-inspired component (inverse distance)
    inverse_distance = 1.0 / (distance_matrix + 1e-6) # Add small constant to avoid divide by zero

    # Noise scaling with Temperature

    noise = np.random.normal(0, temperature, size=distance_matrix.shape)

    heuristic_matrix = inverse_distance + 0.1 * noise # Relative weight on noise vs. deterministic part.
    np.fill_diagonal(heuristic_matrix, 0)  # Remove self-loops

    return heuristic_matrix
```
