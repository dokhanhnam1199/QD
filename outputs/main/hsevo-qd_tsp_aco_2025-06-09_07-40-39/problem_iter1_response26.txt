```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Stephen Hawking's Black Hole Inspired TSP Heuristic.

    This heuristic attempts to mimic the gravitational pull of black holes.
    Shorter distances have a stronger "gravitational" pull, thus are more
    likely to be included.  Also includes a component for connectivity.

    Args:
        distance_matrix (np.ndarray): A 2D numpy array representing the distance
                                         matrix between cities.

    Returns:
        np.ndarray: A 2D numpy array of the same shape as distance_matrix,
                      representing the heuristic values for each edge.  Higher
                      values indicate a more promising edge.
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # Inverse distance:  Shorter distances are more attractive
    inverse_distance = 1.0 / (distance_matrix + 1e-9)  # Adding a small value to avoid division by zero

    # Connectivity Bonus:  Favor edges connected to nodes with few connections
    connectivity_bonus = np.zeros_like(distance_matrix, dtype=float)
    for i in range(n):
        for j in range(n):
            if i != j:
                degree_i = np.sum(distance_matrix[i, :] > 0) -1 # Subtract 1 to remove self loop

                degree_j = np.sum(distance_matrix[j, :] > 0) -1

                connectivity_bonus[i, j] = 1.0 / (degree_i * degree_j + 1e-9) # Prefer connecting to low-degree node, prevent disconnected subgraphs.

    # Edge Uniqueness Bonus: Encourages more distinct/uncommon edges
    edge_uniqueness_bonus = np.zeros_like(distance_matrix, dtype=float)
    for i in range(n):
      for j in range(n):
        edge_uniqueness_bonus[i, j] = 1.0 / (np.std(distance_matrix) + 1e-9) # Add bonus if edges deviate from most other distances in graph.
        #edge_uniqueness_bonus[i, j] = 1.0 / (distance_matrix[i,j] + 1e-9) # Alternative : Bonus for using edges very different from existing edges

    # Combine the heuristics
    heuristic_matrix = inverse_distance + 0.5 * connectivity_bonus + 0.1 * edge_uniqueness_bonus

    # Normalize the heuristic matrix (optional, but can improve performance)
    heuristic_matrix = heuristic_matrix / np.max(heuristic_matrix)

    return heuristic_matrix
```
