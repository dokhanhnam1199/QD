[
  {
    "stdout_filepath": "problem_iter1_response0.txt_stdout.txt",
    "code_path": "problem_iter1_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This implementation prioritizes bins using a \"Best Fit\" strategy.\n    It calculates a score based on the proportion of the bin's remaining\n    capacity that the item would fill. Bins that cannot accommodate the\n    item are assigned a very low (negative infinity) priority to ensure\n    they are not selected.\n\n    A higher score indicates a tighter fit (i.e., the item uses a larger\n    proportion of the available space in the bin), which is the essence\n    of Best Fit heuristic.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priority array with a very low value (-np.inf) for all bins.\n    # This ensures that bins where the item does not fit will automatically\n    # have the lowest priority and will not be chosen.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Create a boolean mask to identify bins where the item can actually fit.\n    # A bin can fit the item if its remaining capacity is greater than or equal to the item size.\n    can_fit_mask = bins_remain_cap >= item\n\n    # For the bins that can accommodate the item, calculate their priority score.\n    # The score is the ratio of the item's size to the bin's remaining capacity.\n    # This ratio is between 0 (for a very small item in a relatively large bin)\n    # and 1 (for an item that perfectly fills the bin's remaining capacity).\n    # A higher ratio indicates a tighter fit, which is desired by the \"Best Fit\" rule.\n    priorities[can_fit_mask] = item / bins_remain_cap[can_fit_mask]\n\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response1.txt_stdout.txt",
    "code_path": "problem_iter1_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    From the perspective of universal order and efficiency, one must always\n    strive to fill existing 'spacetime vessels' as compactly as possible\n    before creating new ones.\n\n    My heuristic, which I shall call 'The Best Fit of Relativity',\n    dictates that an item should preferentially be placed into the bin\n    that will result in the smallest possible 'remaining void' once the\n    item has settled. This minimizes the 'unutilized capacity curvature'\n    and ensures that our 'energy-matter packets' (items) are arrayed\n    with the utmost density.\n\n    If an item cannot 'coexist' within a bin due to insufficient space,\n    that bin is, naturally, assigned an infinitely low priority, as it\n    is not a viable candidate in this dimension of packing.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize all priorities to negative infinity. This ensures that any bin\n    # that cannot fit the item will never be chosen over one that can.\n    priorities = np.full_like(bins_remain_cap, np.NINF, dtype=float)\n\n    # Determine which bins have sufficient remaining capacity to accommodate the item.\n    can_fit_mask = bins_remain_cap >= item\n\n    # For the bins that can fit the item, calculate the remaining capacity if the item is placed.\n    # We want to select the bin that results in the *smallest* remaining capacity (tightest fit).\n    # To achieve this with a 'highest priority wins' mechanism, we take the negative of this value.\n    # A smaller positive remainder will result in a larger (less negative) priority score.\n    remaining_space_after_fit = bins_remain_cap[can_fit_mask] - item\n    priorities[can_fit_mask] = -remaining_space_after_fit\n\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 30, in priority_v2\n    # a score equal to the negative of this remaining space.\n  File \"/home/dokhanhnam1199/.local/lib/python3.10/site-packages/numpy/__init__.py\", line 400, in __getattr__\n    raise AttributeError(\nAttributeError: `np.NINF` was removed in the NumPy 2.0 release. Use `-np.inf` instead.\n6\n1\n"
  },
  {
    "stdout_filepath": "problem_iter1_response2.txt_stdout.txt",
    "code_path": "problem_iter1_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    This heuristic, akin to the 'Best Fit' strategy, aims to minimize the\n    remaining idle capacity in a bin after placing the item. By striving\n    for the snuggest possible fit, we endeavor to consolidate items\n    efficiently, thereby reducing the total number of receptacles required.\n    It is a principle of economy, much like Nature abhors a vacuum.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of current capacities remaining in each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        A higher score indicates a more desirable bin.\n    \"\"\"\n    # Initialize all priorities to an infinitely low value.\n    # Any bin that cannot accommodate the item shall be rejected.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Ascertain which bins possess sufficient remaining capacity to receive the item.\n    # These are the only candidates for consideration.\n    can_fit = bins_remain_cap >= item\n\n    # For those bins capable of holding the item, we calculate the remaining space\n    # should the item be placed therein. We seek to minimize this remainder.\n    # To transform this minimization into a maximization for priority, we assign\n    # a score equal to the negative of this remaining space.\n    # Thus, a smaller positive remainder (a snugger fit) yields a value closer to zero (higher).\n    # A perfect fit (remainder 0) will yield a score of 0, the highest possible for a fitting bin.\n    snugness_scores = -(bins_remain_cap[can_fit] - item)\n\n    # Assign these calculated scores to the eligible bins.\n    priorities[can_fit] = snugness_scores\n\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response3.txt_stdout.txt",
    "code_path": "problem_iter1_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Inspired by the principles of atomic stability and efficient energy release,\n    this heuristic aims for the most \"stable\" packing, minimizing wasted space\n    and optimizing the utilization of each bin's capacity.\n\n    This strategy is a refined Best Fit approach: it prioritizes bins that,\n    after placing the item, would have the smallest remaining capacity. Perfect\n    fits are given the highest possible priority, akin to achieving a highly\n    stable, optimal configuration.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Returns:\n        Array of the same size as bins_remain_cap with a priority score for each bin.\n        Higher scores indicate a more desirable bin for the current item.\n    \"\"\"\n    # Initialize priorities. Bins where the item cannot fit are given an\n    # infinitely low priority, rendering them \"unstable\" or impossible choices.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify all bins where the current item can physically be placed.\n    can_fit_mask = bins_remain_cap >= item\n\n    # For these eligible bins, calculate the remaining capacity if the item were placed inside.\n    # This 'remaining space' is analogous to unutilized potential or \"excess energy\" we wish to minimize.\n    remaining_space_after_placement = bins_remain_cap[can_fit_mask] - item\n\n    # To prioritize bins that leave the least remaining space, we use the inverse\n    # of this remaining space as the priority score. A smaller remaining space\n    # results in a larger inverse value, thus a higher priority.\n    #\n    # Add a small epsilon to the denominator to prevent division by zero in cases\n    # where an item fits perfectly (remaining_space = 0). This ensures perfect\n    # fits receive the highest possible (finite) priority score, reflecting their\n    # ideal, stable configuration.\n    epsilon = np.finfo(float).eps  # Smallest positive float representable\n\n    # Calculate the \"stability score\" for eligible bins.\n    # A higher score indicates a more 'stable' or optimally packed bin.\n    priorities[can_fit_mask] = 1.0 / (remaining_space_after_placement + epsilon)\n\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response4.txt_stdout.txt",
    "code_path": "problem_iter1_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    As Nikola Tesla, I envision this process much like routing an electrical current.\n    We seek the path of least \"resistance\" in terms of wasted capacity, aiming for the\n    most efficient \"connection\" or \"transfer\" of the item (our electrical charge)\n    into its vessel (the bin). This method prioritizes snugly fitting items, minimizing\n    the \"idle capacity\" and thus optimizing the overall \"power grid\" of our bins.\n    It embodies the 'Best Fit' heuristic, ensuring minimal remaining \"electrical potential\"\n    (unused space) within the chosen receptacle.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the theoretical remaining space if the item were placed in each bin.\n    # This is our measure of 'impedance' or 'unused potential'.\n    theoretical_remaining_space = bins_remain_cap - item\n\n    # Initialize priorities to a very low value (negative infinity).\n    # Bins that cannot accommodate the item are effectively 'open circuits'\n    # and must have a negligible priority.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify the 'closed circuits' \u2013 bins where the item can physically fit.\n    can_fit_mask = theoretical_remaining_space >= 0\n\n    # For the bins where the item can fit, we assign a priority.\n    # We desire the bin with the *smallest positive* remaining space.\n    # By taking the negative of this remaining space, a smaller positive value\n    # (e.g., 1 unit remaining) becomes a higher (less negative) priority\n    # (e.g., -1) compared to a larger positive value (e.g., 10 units remaining,\n    # resulting in a priority of -10). This effectively converts the minimization\n    # problem (of remaining space) into a maximization problem (of priority score).\n    priorities[can_fit_mask] = -theoretical_remaining_space[can_fit_mask]\n\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response5.txt_stdout.txt",
    "code_path": "problem_iter1_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    As Galileo, I seek order and efficiency in the cosmos, much like the\n    planets find their precise orbits. For bin packing, this translates to\n    finding the 'snuggest' fit possible, minimizing wasted space. A perfect\n    fit, where the item precisely fills the remaining capacity, is truly\n    celestial and receives the highest praise! This heuristic, therefore,\n    prioritizes bins that leave the least amount of leftover space, making\n    the system as compact and harmonious as possible.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    \n    # Initialize all priorities to a very low value. Bins that cannot fit the item\n    # will retain this low priority, ensuring they are not chosen.\n    # In my studies of the heavens, a lack of capacity to align is a severe detriment!\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # First, identify the bins that are capacious enough to accept this new item.\n    # We must only consider valid placements, for one cannot place the moon into a thimble.\n    can_fit_mask = bins_remain_cap >= item\n\n    # For those fortunate bins that can accommodate the item, we calculate the 'leftover'\n    # space if the item were placed there. This is our measure of 'snugness'.\n    # A smaller leftover space indicates a more harmonious fit.\n    remaining_space_if_placed = bins_remain_cap[can_fit_mask] - item\n\n    # Our priority is inversely related to this remaining space.\n    # We negate the remaining space: a smaller positive remaining space (e.g., 0.1)\n    # results in a less negative score (-0.1), which is a higher priority.\n    # A perfect fit (0 remaining space) receives a score of 0, the highest possible value\n    # amongst the valid options, signaling its utmost preference.\n    # This best-fit approach ensures minimal fragmentation, keeping our bins as tidy as a\n    # well-understood planetary system.\n    priorities[can_fit_mask] = -remaining_space_if_placed\n    \n    return priorities",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response6.txt_stdout.txt",
    "code_path": "problem_iter1_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add an item to each bin.\n    Inspired by the gravitational imperative to achieve maximum density, this\n    heuristic aims for the 'tightest fit' within existing 'spacetime singularities'\n    (bins). We seek to minimize the 'cosmic void' left after an item's placement.\n\n    Args:\n        item: Size of item to be added to the bin. This is our incoming quantum of matter.\n        bins_remain_cap: Array of remaining capacities for each bin. These are our\n                         existing 'proto-black holes', awaiting further accretion.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        The bin offering the highest 'gravitational pull' (tightest fit) will be chosen.\n    \"\"\"\n\n    # Calculate the 'potential residual void' if the item were to be placed in each bin.\n    # A smaller void indicates a more efficient packing, analogous to a stronger\n    # gravitational collapse and higher density.\n    potential_remaining_void = bins_remain_cap - item\n\n    # Initialize priorities. Bins that cannot accommodate the item are effectively\n    # 'outside the event horizon' for this particular quantum of matter; they get\n    # an infinitely low priority score, making them ineligible.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify the 'viable universes' (bins) where the item can actually reside\n    # without violating the laws of physics (i.e., where remaining capacity is non-negative).\n    viable_universes_mask = potential_remaining_void >= 0\n\n    # For the viable bins, the priority is inverse to the 'remaining void'.\n    # A 'perfect fit' (zero void) yields the highest possible score, signifying\n    # the ultimate density, much like a singularity. We use the negative to\n    # transform minimization of void into maximization of priority.\n    priorities[viable_universes_mask] = -potential_remaining_void[viable_universes_mask]\n\n    return priorities",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response7.txt_stdout.txt",
    "code_path": "problem_iter1_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    \n    This function implements a \"Best Fit\" like heuristic, inspired by how\n    particles seek the lowest energy state, or how objects naturally\n    settle into the snuggest available spot.\n    \n    We prefer bins that, after accommodating the item, will have the\n    smallest positive remaining capacity. A perfect fit (0 remaining capacity)\n    is considered the highest priority among valid placements.\n    Bins where the item cannot fit are given an infinitely low priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    \n    # Calculate the hypothetical remaining capacity for each bin\n    # if the current item were placed there.\n    potential_remaining_cap = bins_remain_cap - item\n\n    # Initialize a priority array. We'll start by giving an infinitely low\n    # priority to all bins, signifying they are undesirable unless proven otherwise.\n    # This ensures that bins where the item does not fit will never be chosen\n    # if there is at least one bin where it does fit.\n    priority_scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify which bins can actually accommodate the item.\n    # These are the bins where the 'potential_remaining_cap' is non-negative.\n    can_fit_mask = potential_remaining_cap >= 0\n\n    # For the bins where the item *can* fit:\n    # We want to find the bin that leaves the *least* amount of space remaining.\n    # In other words, we want to minimize 'potential_remaining_cap' for these bins.\n    # To do this using a maximization priority function, we take the negative\n    # of 'potential_remaining_cap'.\n    # A smaller 'potential_remaining_cap' (e.g., 0 for a perfect fit)\n    # will result in a larger (less negative) priority score (e.g., 0).\n    # A larger 'potential_remaining_cap' (e.g., 0.5) will result in a smaller\n    # (more negative) priority score (e.g., -0.5).\n    priority_scores[can_fit_mask] = -potential_remaining_cap[can_fit_mask]\n\n    return priority_scores",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response8.txt_stdout.txt",
    "code_path": "problem_iter1_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    This priority function is inspired by the \"Best Fit\" heuristic, aiming to\n    mimic Rosalind Franklin's meticulous approach to fitting components together\n    with minimal wasted space, much like nucleotides in a DNA helix.\n\n    It prioritizes bins that, if the item were placed in them, would leave the\n    smallest amount of remaining capacity. This encourages filling bins as\n    tightly as possible, saving larger available spaces for larger items that\n    might come later, thereby optimizing bin utilization and minimizing the\n    total number of bins used.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        A higher score indicates a higher preference. Bins where the item cannot\n        fit are assigned a very low (negative infinity) priority.\n    \"\"\"\n    # Initialize all scores to negative infinity. This ensures that any bin\n    # where the item cannot fit will never be selected, as their priority\n    # will be lowest.\n    scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Create a boolean mask to identify bins where the item actually fits.\n    can_fit_mask = bins_remain_cap >= item\n\n    # For bins where the item can fit, calculate the \"tightness\" of the fit.\n    # The quantity `bins_remain_cap - item` represents the space left after placing the item.\n    # We want to minimize this value. By taking the negative of this difference,\n    # a smaller remaining space will result in a larger (less negative, or positive) score.\n    # A perfect fit (remaining_capacity - item = 0) will yield a score of 0,\n    # which is the highest possible score and represents the most desirable fit.\n    scores[can_fit_mask] = -(bins_remain_cap[can_fit_mask] - item)\n\n    return scores",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response9.txt_stdout.txt",
    "code_path": "problem_iter1_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This heuristic is based on the 'Best Fit' strategy, aiming to minimize\n    the wasted space in each chosen bin. It prioritizes bins that, after\n    receiving the item, would have the smallest amount of remaining capacity.\n    This helps to \"tightly pack\" bins, potentially leaving larger gaps in\n    other bins for future, larger items, or closing bins quickly.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        A higher score indicates a more preferred bin. Bins that cannot fit\n        the item will have a very low (negative infinity) priority.\n    \"\"\"\n    # Calculate the remaining capacity if the item were placed in each bin.\n    # We want to find a bin where this value is small and non-negative.\n    potential_remaining_capacity = bins_remain_cap - item\n\n    # Initialize priorities for all bins.\n    # Bins that cannot fit the item should have an extremely low priority,\n    # ensuring they are never chosen if any valid bin exists.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify bins that *can* accommodate the current item.\n    can_fit_mask = potential_remaining_capacity >= 0\n\n    # For bins that can fit the item, their priority is the negative of the\n    # remaining capacity. This way, a smaller positive remaining capacity\n    # (e.g., 0.1) results in a higher priority (e.g., -0.1), while a larger\n    # remaining capacity (e.g., 0.8) results in a lower priority (e.g., -0.8).\n    # Since we choose the bin with the MAX priority, this correctly implements Best Fit.\n    priorities[can_fit_mask] = -potential_remaining_capacity[can_fit_mask]\n\n    return priorities",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  }
]