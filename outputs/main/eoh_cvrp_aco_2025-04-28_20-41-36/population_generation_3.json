[
     {
          "algorithm": "This algorithm constructs a heuristic matrix based on savings values, a capacity penalty that scales with distance, and a proximity bonus that is inversely proportional to the square of the distance.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"{This algorithm constructs a heuristic matrix based on savings values, a capacity penalty that scales with distance, and a proximity bonus that is inversely proportional to the square of the distance.}\"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n\n    # Calculate savings values\n    savings_matrix = np.zeros_like(distance_matrix)\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                savings_matrix[i][j] = distance_matrix[0][i] + distance_matrix[0][j] - distance_matrix[i][j]\n\n    # Construct heuristic matrix\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                # Base heuristic score from savings\n                heuristics_matrix[i][j] = savings_matrix[i][j]\n\n                # Capacity penalty: penalize linking nodes that would exceed capacity, scaling with distance\n                if demands[i] + demands[j] > capacity:\n                    heuristics_matrix[i][j] -= (demands[i] + demands[j] - capacity) * distance_matrix[i][j]\n\n                # Proximity bonus: reward linking nodes that are close to each other, inversely proportional to squared distance\n                euclidean_distance = np.sqrt(np.sum((coordinates[i] - coordinates[j])**2))\n                heuristics_matrix[i][j] += (np.mean(distance_matrix) / ((euclidean_distance**2) + 1e-6))  # Add a small constant to avoid division by zero\n\n    return heuristics_matrix",
          "objective": 9.58126,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm adaptively adjusts edge weights based on distance, demand, and route feasibility, learning from successful and unsuccessful route combinations.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"{This algorithm adaptively adjusts edge weights based on distance, demand, and route feasibility, learning from successful and unsuccessful route combinations.}\"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    edge_weights = np.ones_like(distance_matrix)  # Initialize edge weights\n    learning_rate = 0.1\n\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            # Initial heuristic based on distance and demand\n            heuristics_matrix[i, j] = (1 / distance_matrix[i, j]) * (1 / (demands[i] + demands[j] + 1e-6)) * edge_weights[i, j]\n            heuristics_matrix[j, i] = heuristics_matrix[i, j]\n            \n    # Simulate route construction and update edge weights\n    num_simulations = 100\n    for _ in range(num_simulations):\n        current_route_demand = 0\n        current_node = 0\n        route = [0]\n        \n        while len(route) < n:\n          \n            eligible_nodes = [node for node in range(1, n) if node not in route and current_route_demand + demands[node] <= capacity]\n            \n            if not eligible_nodes:\n              if current_node != 0:\n                route.append(0)\n                current_route_demand = 0\n                current_node = 0\n                eligible_nodes = [node for node in range(1, n) if node not in route and current_route_demand + demands[node] <= capacity]\n              else:\n                break\n\n            if not eligible_nodes:\n              break\n            \n            probabilities = [heuristics_matrix[current_node, node] for node in eligible_nodes]\n            probabilities = np.exp(probabilities) / np.sum(np.exp(probabilities))\n            \n            next_node = random.choices(eligible_nodes, probabilities)[0]\n            \n            route.append(next_node)\n            current_route_demand += demands[next_node]\n            current_node = next_node\n            \n        if len(route) == n:\n            # Reward edges in successful route\n            for i in range(len(route) - 1):\n                edge_weights[route[i], route[i+1]] += learning_rate\n                edge_weights[route[i+1], route[i]] += learning_rate\n        else:\n            # Penalize edges in unsuccessful route\n            for i in range(len(route) - 1):\n                edge_weights[route[i], route[i+1]] -= learning_rate\n                edge_weights[route[i+1], route[i]] -= learning_rate\n\n    # Update heuristic matrix based on learned edge weights\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            heuristics_matrix[i, j] = (1 / distance_matrix[i, j]) * (1 / (demands[i] + demands[j] + 1e-6)) * edge_weights[i, j]\n            heuristics_matrix[j, i] = heuristics_matrix[i, j]\n\n    return heuristics_matrix",
          "objective": 10.67223,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm constructs a heuristic matrix based on savings values, a penalty for exceeding capacity, and a proximity bonus based on node location.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"{This algorithm constructs a heuristic matrix based on savings values, a penalty for exceeding capacity, and a proximity bonus based on node location.}\"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n\n    # Calculate savings values\n    savings_matrix = np.zeros_like(distance_matrix)\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                savings_matrix[i][j] = distance_matrix[0][i] + distance_matrix[0][j] - distance_matrix[i][j]\n\n    # Construct heuristic matrix\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                # Base heuristic score from savings\n                heuristics_matrix[i][j] = savings_matrix[i][j]\n\n                # Capacity penalty: penalize linking nodes that would exceed capacity\n                if demands[i] + demands[j] > capacity:\n                    heuristics_matrix[i][j] -= (demands[i] + demands[j] - capacity) * np.mean(distance_matrix)\n\n                # Proximity bonus: reward linking nodes that are close to each other\n                euclidean_distance = np.sqrt(np.sum((coordinates[i] - coordinates[j])**2))\n                heuristics_matrix[i][j] += (np.mean(distance_matrix) / (euclidean_distance + 1e-6))  # Add a small constant to avoid division by zero\n\n    return heuristics_matrix",
          "objective": 10.68848,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm constructs a heuristic matrix based on savings values, a penalty for exceeding capacity, and a modified proximity bonus based on node location and demand.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"{This algorithm constructs a heuristic matrix based on savings values, a penalty for exceeding capacity, and a modified proximity bonus based on node location and demand.}\"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n\n    # Calculate savings values\n    savings_matrix = np.zeros_like(distance_matrix)\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                savings_matrix[i][j] = distance_matrix[0][i] + distance_matrix[0][j] - distance_matrix[i][j]\n\n    # Construct heuristic matrix\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                # Base heuristic score from savings\n                heuristics_matrix[i][j] = savings_matrix[i][j]\n\n                # Capacity penalty: penalize linking nodes that would exceed capacity, scaled by average saving\n                if demands[i] + demands[j] > capacity:\n                    heuristics_matrix[i][j] -= (demands[i] + demands[j] - capacity) * np.mean(savings_matrix)\n\n                # Proximity bonus: reward linking nodes that are close to each other, scaled by inverse of demand.\n                euclidean_distance = np.sqrt(np.sum((coordinates[i] - coordinates[j])**2))\n                heuristics_matrix[i][j] += (np.mean(distance_matrix) / (euclidean_distance + 1e-6)) * (1 / (demands[i] + demands[j])) # Add a small constant to avoid division by zero\n\n    return heuristics_matrix",
          "objective": 10.96675,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm prioritizes edges connecting nodes with high demand and short distances while discouraging edges that would exceed vehicle capacity, with an added emphasis on cost savings.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm prioritizes edges connecting nodes with high demand and short distances while discouraging edges that would exceed vehicle capacity, with an added emphasis on cost savings.}\n    \"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    savings_matrix = np.zeros_like(distance_matrix)\n\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings_matrix[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings_matrix[j, i] = savings_matrix[i, j]\n\n    demand_distance_ratio = np.zeros_like(distance_matrix)\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                demand_distance_ratio[i, j] = (demands[i] + demands[j]) / distance_matrix[i, j]\n            else:\n                demand_distance_ratio[i, j] = 0\n                \n    penalty_matrix = np.zeros_like(distance_matrix)\n    for i in range(1, n):\n      for j in range(1, n):\n        if i!=j:\n          if demands[i] + demands[j] > capacity:\n            penalty_matrix[i, j] = -10 #Increased penalty\n            penalty_matrix[j, i] = -10\n        else:\n          penalty_matrix[i,j] = -10\n\n\n    normalized_savings = savings_matrix / (np.max(savings_matrix) if np.any(savings_matrix) else 1)\n    normalized_demand_distance = demand_distance_ratio / (np.max(demand_distance_ratio) if np.any(demand_distance_ratio) else 1)\n\n    heuristics_matrix = 0.5 * normalized_savings + normalized_demand_distance + penalty_matrix #Reduced weight on savings\n\n    return heuristics_matrix",
          "objective": 11.06343,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm adjusts the weights of savings, demand-distance ratio, and penalty components, emphasizing the penalty for exceeding capacity and slightly reducing the influence of savings.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm adjusts the weights of savings, demand-distance ratio, and penalty components, emphasizing the penalty for exceeding capacity and slightly reducing the influence of savings.}\n    \"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    savings_matrix = np.zeros_like(distance_matrix)\n\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings_matrix[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings_matrix[j, i] = savings_matrix[i, j]\n\n    demand_distance_ratio = np.zeros_like(distance_matrix)\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                demand_distance_ratio[i, j] = (demands[i] + demands[j]) / distance_matrix[i, j]\n            else:\n                demand_distance_ratio[i, j] = 0\n                \n    penalty_matrix = np.zeros_like(distance_matrix)\n    for i in range(1, n):\n      for j in range(1, n):\n        if i!=j:\n          if demands[i] + demands[j] > capacity:\n            penalty_matrix[i, j] = -10\n            penalty_matrix[j, i] = -10\n        else:\n          penalty_matrix[i,j] = -10\n\n\n    normalized_savings = savings_matrix / (np.max(savings_matrix) if np.any(savings_matrix) else 1)\n    normalized_demand_distance = demand_distance_ratio / (np.max(demand_distance_ratio) if np.any(demand_distance_ratio) else 1)\n\n    heuristics_matrix = 0.5 * normalized_savings + normalized_demand_distance + penalty_matrix\n\n    return heuristics_matrix",
          "objective": 11.2037,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm refines the savings approach by incorporating a penalty for exceeding capacity during route construction and prioritizing connections to nodes with higher demand relative to their distance.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm refines the savings approach by incorporating a penalty for exceeding capacity during route construction and prioritizing connections to nodes with higher demand relative to their distance.}\n    \"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    savings_matrix = np.zeros_like(distance_matrix)\n\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings_matrix[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings_matrix[j, i] = savings_matrix[i, j]\n\n    demand_distance_ratio = np.zeros_like(distance_matrix)\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                demand_distance_ratio[i, j] = (demands[i] + demands[j]) / distance_matrix[i, j]\n            else:\n                demand_distance_ratio[i, j] = 0\n                \n    penalty_matrix = np.zeros_like(distance_matrix)\n    for i in range(1, n):\n      for j in range(1, n):\n        if i!=j:\n          if demands[i] + demands[j] > capacity:\n            penalty_matrix[i, j] = -1\n            penalty_matrix[j, i] = -1\n        else:\n          penalty_matrix[i,j] = -1\n\n\n    normalized_savings = savings_matrix / (np.max(savings_matrix) if np.any(savings_matrix) else 1)\n    normalized_demand_distance = demand_distance_ratio / (np.max(demand_distance_ratio) if np.any(demand_distance_ratio) else 1)\n\n    heuristics_matrix = normalized_savings + normalized_demand_distance + penalty_matrix\n\n    return heuristics_matrix",
          "objective": 11.25901,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm emphasizes cost savings while balancing demand-distance ratio and applying a more nuanced penalty based on proximity to capacity limits, encouraging efficient route construction.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm emphasizes cost savings while balancing demand-distance ratio and applying a more nuanced penalty based on proximity to capacity limits, encouraging efficient route construction.}\n    \"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    savings_matrix = np.zeros_like(distance_matrix)\n\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings_matrix[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings_matrix[j, i] = savings_matrix[i, j]\n\n    demand_distance_ratio = np.zeros_like(distance_matrix)\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                demand_distance_ratio[i, j] = (demands[i] + demands[j]) / distance_matrix[i, j]\n            else:\n                demand_distance_ratio[i, j] = 0\n                \n    penalty_matrix = np.zeros_like(distance_matrix)\n    for i in range(1, n):\n      for j in range(1, n):\n        if i!=j:\n          combined_demand = demands[i] + demands[j]\n          if combined_demand > capacity:\n            penalty_amount = -10\n          elif combined_demand > 0.8 * capacity:\n            penalty_amount = -5  # Moderate penalty as we approach capacity\n          else:\n            penalty_amount = 0\n          penalty_matrix[i, j] = penalty_amount\n          penalty_matrix[j, i] = penalty_amount\n        else:\n          penalty_matrix[i,j] = -10\n\n\n    normalized_savings = savings_matrix / (np.max(savings_matrix) if np.any(savings_matrix) else 1)\n    normalized_demand_distance = demand_distance_ratio / (np.max(demand_distance_ratio) if np.any(demand_distance_ratio) else 1)\n\n    heuristics_matrix = normalized_savings + 0.5 * normalized_demand_distance + penalty_matrix #Increased weight on savings, reduced on demand_distance\n\n    return heuristics_matrix",
          "objective": 11.33895,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm prioritizes demand-distance ratio and savings, while penalizing capacity violations and adding a weaker clustering term based on node proximity to encourage intra-cluster connections.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm prioritizes demand-distance ratio and savings, while penalizing capacity violations and adding a weaker clustering term based on node proximity to encourage intra-cluster connections.}\n    \"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    savings_matrix = np.zeros_like(distance_matrix)\n\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings_matrix[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings_matrix[j, i] = savings_matrix[i, j]\n\n    demand_distance_ratio = np.zeros_like(distance_matrix)\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                demand_distance_ratio[i, j] = (demands[i] + demands[j]) / distance_matrix[i, j]\n            else:\n                demand_distance_ratio[i, j] = 0\n                \n    penalty_matrix = np.zeros_like(distance_matrix)\n    for i in range(1, n):\n      for j in range(1, n):\n        if i!=j:\n          if demands[i] + demands[j] > capacity:\n            penalty_matrix[i, j] = -10 #Increased penalty\n            penalty_matrix[j, i] = -10\n        else:\n          penalty_matrix[i,j] = -10\n\n    normalized_savings = savings_matrix / (np.max(savings_matrix) if np.any(savings_matrix) else 1)\n    normalized_demand_distance = demand_distance_ratio / (np.max(demand_distance_ratio) if np.any(demand_distance_ratio) else 1)\n    \n    # Clustering term based on node proximity\n    clustering_matrix = np.zeros_like(distance_matrix)\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                clustering_matrix[i, j] = np.exp(-distance_matrix[i, j] / np.mean(distance_matrix))\n            else:\n                clustering_matrix[i, j] = 0\n\n    normalized_clustering = clustering_matrix / (np.max(clustering_matrix) if np.any(clustering_matrix) else 1)\n\n    heuristics_matrix = 0.2 * normalized_savings + 0.5 * normalized_demand_distance + penalty_matrix + 0.1 * normalized_clustering #Adjusted weights, reduced clustering\n    \n\n    return heuristics_matrix",
          "objective": 11.35149,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm refines the savings approach by incorporating a smaller penalty for exceeding capacity during route construction and decreasing the weight of prioritizing connections to nodes with higher demand relative to their distance.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm refines the savings approach by incorporating a smaller penalty for exceeding capacity during route construction and decreasing the weight of prioritizing connections to nodes with higher demand relative to their distance.}\n    \"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    savings_matrix = np.zeros_like(distance_matrix)\n\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings_matrix[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings_matrix[j, i] = savings_matrix[i, j]\n\n    demand_distance_ratio = np.zeros_like(distance_matrix)\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                demand_distance_ratio[i, j] = (demands[i] + demands[j]) / distance_matrix[i, j]\n            else:\n                demand_distance_ratio[i, j] = 0\n                \n    penalty_matrix = np.zeros_like(distance_matrix)\n    for i in range(1, n):\n      for j in range(1, n):\n        if i!=j:\n          if demands[i] + demands[j] > capacity:\n            penalty_matrix[i, j] = -0.5  \n            penalty_matrix[j, i] = -0.5\n        else:\n          penalty_matrix[i,j] = -1\n\n\n    normalized_savings = savings_matrix / (np.max(savings_matrix) if np.any(savings_matrix) else 1)\n    normalized_demand_distance = demand_distance_ratio / (np.max(demand_distance_ratio) if np.any(demand_distance_ratio) else 1)\n\n    heuristics_matrix = normalized_savings + 0.5 * normalized_demand_distance + penalty_matrix\n\n    return heuristics_matrix",
          "objective": 11.49956,
          "other_inf": null
     }
]