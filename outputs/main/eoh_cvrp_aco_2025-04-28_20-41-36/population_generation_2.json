[
     {
          "algorithm": "This algorithm prioritizes edges connecting nodes with high demand and short distances while discouraging edges that would exceed vehicle capacity, with an added emphasis on cost savings.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm prioritizes edges connecting nodes with high demand and short distances while discouraging edges that would exceed vehicle capacity, with an added emphasis on cost savings.}\n    \"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    savings_matrix = np.zeros_like(distance_matrix)\n\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings_matrix[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings_matrix[j, i] = savings_matrix[i, j]\n\n    demand_distance_ratio = np.zeros_like(distance_matrix)\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                demand_distance_ratio[i, j] = (demands[i] + demands[j]) / distance_matrix[i, j]\n            else:\n                demand_distance_ratio[i, j] = 0\n                \n    penalty_matrix = np.zeros_like(distance_matrix)\n    for i in range(1, n):\n      for j in range(1, n):\n        if i!=j:\n          if demands[i] + demands[j] > capacity:\n            penalty_matrix[i, j] = -10 #Increased penalty\n            penalty_matrix[j, i] = -10\n        else:\n          penalty_matrix[i,j] = -10\n\n\n    normalized_savings = savings_matrix / (np.max(savings_matrix) if np.any(savings_matrix) else 1)\n    normalized_demand_distance = demand_distance_ratio / (np.max(demand_distance_ratio) if np.any(demand_distance_ratio) else 1)\n\n    heuristics_matrix = 0.5 * normalized_savings + normalized_demand_distance + penalty_matrix #Reduced weight on savings\n\n    return heuristics_matrix",
          "objective": 11.06343,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm adjusts the weights of savings, demand-distance ratio, and penalty components, emphasizing the penalty for exceeding capacity and slightly reducing the influence of savings.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm adjusts the weights of savings, demand-distance ratio, and penalty components, emphasizing the penalty for exceeding capacity and slightly reducing the influence of savings.}\n    \"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    savings_matrix = np.zeros_like(distance_matrix)\n\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings_matrix[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings_matrix[j, i] = savings_matrix[i, j]\n\n    demand_distance_ratio = np.zeros_like(distance_matrix)\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                demand_distance_ratio[i, j] = (demands[i] + demands[j]) / distance_matrix[i, j]\n            else:\n                demand_distance_ratio[i, j] = 0\n                \n    penalty_matrix = np.zeros_like(distance_matrix)\n    for i in range(1, n):\n      for j in range(1, n):\n        if i!=j:\n          if demands[i] + demands[j] > capacity:\n            penalty_matrix[i, j] = -10\n            penalty_matrix[j, i] = -10\n        else:\n          penalty_matrix[i,j] = -10\n\n\n    normalized_savings = savings_matrix / (np.max(savings_matrix) if np.any(savings_matrix) else 1)\n    normalized_demand_distance = demand_distance_ratio / (np.max(demand_distance_ratio) if np.any(demand_distance_ratio) else 1)\n\n    heuristics_matrix = 0.5 * normalized_savings + normalized_demand_distance + penalty_matrix\n\n    return heuristics_matrix",
          "objective": 11.2037,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm refines the savings approach by incorporating a penalty for exceeding capacity during route construction and prioritizing connections to nodes with higher demand relative to their distance.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm refines the savings approach by incorporating a penalty for exceeding capacity during route construction and prioritizing connections to nodes with higher demand relative to their distance.}\n    \"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    savings_matrix = np.zeros_like(distance_matrix)\n\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings_matrix[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings_matrix[j, i] = savings_matrix[i, j]\n\n    demand_distance_ratio = np.zeros_like(distance_matrix)\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                demand_distance_ratio[i, j] = (demands[i] + demands[j]) / distance_matrix[i, j]\n            else:\n                demand_distance_ratio[i, j] = 0\n                \n    penalty_matrix = np.zeros_like(distance_matrix)\n    for i in range(1, n):\n      for j in range(1, n):\n        if i!=j:\n          if demands[i] + demands[j] > capacity:\n            penalty_matrix[i, j] = -1\n            penalty_matrix[j, i] = -1\n        else:\n          penalty_matrix[i,j] = -1\n\n\n    normalized_savings = savings_matrix / (np.max(savings_matrix) if np.any(savings_matrix) else 1)\n    normalized_demand_distance = demand_distance_ratio / (np.max(demand_distance_ratio) if np.any(demand_distance_ratio) else 1)\n\n    heuristics_matrix = normalized_savings + normalized_demand_distance + penalty_matrix\n\n    return heuristics_matrix",
          "objective": 11.25901,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm refines the savings approach by incorporating a smaller penalty for exceeding capacity during route construction and decreasing the weight of prioritizing connections to nodes with higher demand relative to their distance.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm refines the savings approach by incorporating a smaller penalty for exceeding capacity during route construction and decreasing the weight of prioritizing connections to nodes with higher demand relative to their distance.}\n    \"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    savings_matrix = np.zeros_like(distance_matrix)\n\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings_matrix[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings_matrix[j, i] = savings_matrix[i, j]\n\n    demand_distance_ratio = np.zeros_like(distance_matrix)\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                demand_distance_ratio[i, j] = (demands[i] + demands[j]) / distance_matrix[i, j]\n            else:\n                demand_distance_ratio[i, j] = 0\n                \n    penalty_matrix = np.zeros_like(distance_matrix)\n    for i in range(1, n):\n      for j in range(1, n):\n        if i!=j:\n          if demands[i] + demands[j] > capacity:\n            penalty_matrix[i, j] = -0.5  \n            penalty_matrix[j, i] = -0.5\n        else:\n          penalty_matrix[i,j] = -1\n\n\n    normalized_savings = savings_matrix / (np.max(savings_matrix) if np.any(savings_matrix) else 1)\n    normalized_demand_distance = demand_distance_ratio / (np.max(demand_distance_ratio) if np.any(demand_distance_ratio) else 1)\n\n    heuristics_matrix = normalized_savings + 0.5 * normalized_demand_distance + penalty_matrix\n\n    return heuristics_matrix",
          "objective": 11.49956,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm constructs a nearest neighbor tour, applies a 2-opt local search to improve it, and uses the edges present in the locally optimized tour to generate the heuristics matrix.}\"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n\n    # Construct nearest neighbor tour\n    current_node = 0\n    unvisited_nodes = set(range(1, n))\n    tour = [0]\n    current_capacity = capacity\n\n    while unvisited_nodes:\n        feasible_nodes = {\n            node for node in unvisited_nodes if demands[node] <= current_capacity\n        }\n\n        if not feasible_nodes:\n            tour.append(0)\n            current_capacity = capacity\n            current_node = 0\n            feasible_nodes = {\n                node for node in unvisited_nodes if demands[node] <= current_capacity\n            ",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"{This algorithm constructs a nearest neighbor tour, applies a 2-opt local search to improve it, and uses the edges present in the locally optimized tour to generate the heuristics matrix.}\"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n\n    # Construct nearest neighbor tour\n    current_node = 0\n    unvisited_nodes = set(range(1, n))\n    tour = [0]\n    current_capacity = capacity\n\n    while unvisited_nodes:\n        feasible_nodes = {\n            node for node in unvisited_nodes if demands[node] <= current_capacity\n        }\n\n        if not feasible_nodes:\n            tour.append(0)\n            current_capacity = capacity\n            current_node = 0\n            feasible_nodes = {\n                node for node in unvisited_nodes if demands[node] <= current_capacity\n            }\n            if not feasible_nodes:\n                break\n\n        next_node = min(\n            feasible_nodes, key=lambda node: distance_matrix[current_node][node]\n        )\n        tour.append(next_node)\n        unvisited_nodes.remove(next_node)\n        current_capacity -= demands[next_node]\n        current_node = next_node\n    tour.append(0)\n\n    # 2-opt local search\n    def two_opt_swap(route, i, k):\n        new_route = route[:i] + route[i:k+1][::-1] + route[k+1:]\n        return new_route\n\n    def calculate_route_distance(route):\n        total_distance = 0\n        for i in range(len(route) - 1):\n            total_distance += distance_matrix[route[i]][route[i+1]]\n        return total_distance\n    \n    improved = True\n    while improved:\n        improved = False\n        for i in range(1, len(tour) - 2):\n            for k in range(i + 1, len(tour) - 1):\n                new_tour = two_opt_swap(tour, i, k)\n                if calculate_route_distance(new_tour) < calculate_route_distance(tour):\n                    tour = new_tour\n                    improved = True\n                    break\n            if improved:\n                break\n\n    # Update heuristics matrix\n    for i in range(len(tour) - 1):\n        heuristics_matrix[tour[i], tour[i+1]] = 1\n        heuristics_matrix[tour[i+1], tour[i]] = 1\n\n    return heuristics_matrix",
          "objective": 11.53878,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm samples multiple random routes satisfying capacity constraints, then weights the edge frequencies by the inverse of the edge distance to generate a heuristic matrix.}\"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    num_samples = 1000\n\n    for _ in range(num_samples):\n        route = [0]\n        remaining_nodes = set(range(1, n))\n        current_capacity = capacity\n\n        while remaining_nodes:\n            feasible_nodes = {\n                node for node in remaining_nodes if demands[node] <= current_capacity\n            }\n\n            if not feasible_nodes:\n                route.append(0)\n                current_capacity = capacity\n                feasible_nodes = {\n                    node for node in remaining_nodes if demands[node] <= current_capacity\n                ",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"{This algorithm samples multiple random routes satisfying capacity constraints, then weights the edge frequencies by the inverse of the edge distance to generate a heuristic matrix.}\"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    num_samples = 1000\n\n    for _ in range(num_samples):\n        route = [0]\n        remaining_nodes = set(range(1, n))\n        current_capacity = capacity\n\n        while remaining_nodes:\n            feasible_nodes = {\n                node for node in remaining_nodes if demands[node] <= current_capacity\n            }\n\n            if not feasible_nodes:\n                route.append(0)\n                current_capacity = capacity\n                feasible_nodes = {\n                    node for node in remaining_nodes if demands[node] <= current_capacity\n                }\n                if not feasible_nodes:\n                    break\n\n            next_node = min(\n                feasible_nodes, key=lambda node: distance_matrix[route[-1]][node]\n            )\n\n            route.append(next_node)\n            remaining_nodes.remove(next_node)\n            current_capacity -= demands[next_node]\n\n        route.append(0)\n        for i in range(len(route) - 1):\n            distance = distance_matrix[route[i]][route[i+1]]\n            if distance > 0:\n                heuristics_matrix[route[i]][route[i+1]] += 1 / distance\n                heuristics_matrix[route[i+1]][route[i]] += 1 / distance\n            else:\n                heuristics_matrix[route[i]][route[i+1]] += 1\n                heuristics_matrix[route[i+1]][route[i]] += 1\n\n    heuristics_matrix = heuristics_matrix / num_samples\n    return heuristics_matrix",
          "objective": 12.43079,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm constructs a heuristic matrix by combining savings, demand priority, and route length considerations, penalizing exceeding capacity and favoring shorter routes for nodes with high demand.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm constructs a heuristic matrix by combining savings, demand priority, and route length considerations, penalizing exceeding capacity and favoring shorter routes for nodes with high demand.}\n    \"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    savings_matrix = np.zeros_like(distance_matrix)\n\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings_matrix[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings_matrix[j, i] = savings_matrix[i, j]\n            \n    demand_priority = np.zeros_like(distance_matrix)\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                demand_priority[i, j] = (demands[i] + demands[j]) \n            else:\n                demand_priority[i, j] = 0\n\n    penalty_matrix = np.zeros_like(distance_matrix)\n    for i in range(1, n):\n      for j in range(1, n):\n        if i!=j:\n          if demands[i] + demands[j] > capacity:\n            penalty_matrix[i, j] = -1\n            penalty_matrix[j, i] = -1\n        else:\n          penalty_matrix[i,j] = -1\n\n    route_length = np.zeros_like(distance_matrix)\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                route_length[i, j] = 1/distance_matrix[i,j]\n            else:\n                route_length[i, j] = 0\n\n    normalized_savings = savings_matrix / (np.max(savings_matrix) if np.any(savings_matrix) else 1)\n    normalized_demand_priority = demand_priority / (np.max(demand_priority) if np.any(demand_priority) else 1)\n    normalized_route_length = route_length / (np.max(route_length) if np.any(route_length) else 1)\n    \n\n    heuristics_matrix = normalized_savings + normalized_demand_priority + normalized_route_length + penalty_matrix\n\n    return heuristics_matrix",
          "objective": 13.44842,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm uses a clustering approach to group nodes based on proximity and demand, then prioritizes edges connecting nodes within the same cluster and edges connecting clusters, incorporating simulated annealing to refine edge weights.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"{This algorithm uses a clustering approach to group nodes based on proximity and demand, then prioritizes edges connecting nodes within the same cluster and edges connecting clusters, incorporating simulated annealing to refine edge weights.}\"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    num_clusters = int(np.sqrt(n)) + 1\n    \n    # K-means clustering\n    clusters = [[] for _ in range(num_clusters)]\n    centroids = coordinates[np.random.choice(n, num_clusters, replace=False)]\n    \n    for _ in range(10):\n        clusters = [[] for _ in range(num_clusters)]\n        cluster_assignments = []\n        for i in range(n):\n            distances = np.linalg.norm(coordinates[i] - centroids, axis=1)\n            cluster_id = np.argmin(distances)\n            clusters[cluster_id].append(i)\n            cluster_assignments.append(cluster_id)\n\n        for i in range(num_clusters):\n            if clusters[i]:\n                centroids[i] = np.mean(coordinates[clusters[i]], axis=0)\n\n    # Intra-cluster and inter-cluster edge prioritization\n    intra_cluster_weight = 1.0\n    inter_cluster_weight = 0.5\n    depot_cluster_weight = 0.75\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            cluster_i = cluster_assignments[i]\n            cluster_j = cluster_assignments[j]\n\n            if cluster_i == cluster_j:\n                heuristics_matrix[i, j] = intra_cluster_weight / distance_matrix[i, j] if distance_matrix[i,j] > 0 else intra_cluster_weight\n                heuristics_matrix[j, i] = intra_cluster_weight / distance_matrix[j, i] if distance_matrix[j,i] > 0 else intra_cluster_weight\n            else:\n                heuristics_matrix[i, j] = inter_cluster_weight / distance_matrix[i, j] if distance_matrix[i,j] > 0 else inter_cluster_weight\n                heuristics_matrix[j, i] = inter_cluster_weight / distance_matrix[j, i] if distance_matrix[j,i] > 0 else inter_cluster_weight\n\n            if i == 0 or j == 0:\n                heuristics_matrix[i, j] *= depot_cluster_weight\n                heuristics_matrix[j, i] *= depot_cluster_weight\n    \n    #Simulated Annealing (very basic)\n    temperature = 100\n    cooling_rate = 0.95\n    \n    for _ in range(100):\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            old_value = heuristics_matrix[i, j]\n            \n            change = random.uniform(-0.1, 0.1)\n            new_value = old_value + change\n            new_value = max(0, min(1, new_value))\n            \n            delta_e = new_value - old_value\n            \n            if delta_e > 0 or random.random() < np.exp(delta_e / temperature):\n                heuristics_matrix[i, j] = new_value\n                heuristics_matrix[j, i] = new_value\n                \n        temperature *= cooling_rate\n\n    return heuristics_matrix",
          "objective": 13.90691,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm constructs a Clarke-Wright savings matrix, then iteratively merges nodes based on a weighted combination of savings and distance, prioritizing shorter routes while respecting capacity constraints, and updates a heuristics matrix based on the merged routes.}\n    \"\"\"\n    n = len(demands)\n    savings_matrix = np.zeros_like(distance_matrix)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n\n    # Calculate savings matrix\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings_matrix[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings_matrix[j, i] = savings_matrix[i, j]\n\n    # Initialize routes with individual customers\n    routes = {i: [i] for i in range(1, n)}\n    route_capacities = {i: demands[i] for i in range(1, n)",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm constructs a Clarke-Wright savings matrix, then iteratively merges nodes based on a weighted combination of savings and distance, prioritizing shorter routes while respecting capacity constraints, and updates a heuristics matrix based on the merged routes.}\n    \"\"\"\n    n = len(demands)\n    savings_matrix = np.zeros_like(distance_matrix)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n\n    # Calculate savings matrix\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings_matrix[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings_matrix[j, i] = savings_matrix[i, j]\n\n    # Initialize routes with individual customers\n    routes = {i: [i] for i in range(1, n)}\n    route_capacities = {i: demands[i] for i in range(1, n)}\n\n    # Iteratively merge routes based on savings and distance\n    while True:\n        best_score = -1\n        best_i = None\n        best_j = None\n\n        for i in routes:\n            for j in routes:\n                if i != j and i < j:\n                    if route_capacities[i] + route_capacities[j] <= capacity:\n                        # Weighted score: savings - distance\n                        score = savings_matrix[routes[i][-1], routes[j][0]] - 0.1 * distance_matrix[routes[i][-1], routes[j][0]]\n                        if score > best_score:\n                            best_score = score\n                            best_i = i\n                            best_j = j\n\n        if best_score > -1:\n            # Merge routes i and j\n            routes[best_i].extend(routes[best_j])\n            route_capacities[best_i] += route_capacities[best_j]\n            del routes[best_j]\n            del route_capacities[best_j]\n        else:\n            break\n\n    # Update heuristics matrix based on merged routes\n    for route_id in routes:\n        route = [0] + routes[route_id] + [0]\n        for i in range(len(route) - 1):\n            heuristics_matrix[route[i], route[i+1]] = 1\n            heuristics_matrix[route[i+1], route[i]] = 1\n\n    return heuristics_matrix",
          "objective": 14.28748,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm constructs a Clarke-Wright savings matrix, then iteratively merges nodes based on the highest savings while respecting capacity constraints, updating the heuristics matrix based on merged routes.}\n    \"\"\"\n    n = len(demands)\n    savings_matrix = np.zeros_like(distance_matrix)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n\n    # Calculate savings matrix\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings_matrix[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings_matrix[j, i] = savings_matrix[i, j]\n\n    # Initialize routes with individual customers\n    routes = {i: [i] for i in range(1, n)}\n    route_capacities = {i: demands[i] for i in range(1, n)",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm constructs a Clarke-Wright savings matrix, then iteratively merges nodes based on the highest savings while respecting capacity constraints, updating the heuristics matrix based on merged routes.}\n    \"\"\"\n    n = len(demands)\n    savings_matrix = np.zeros_like(distance_matrix)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n\n    # Calculate savings matrix\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings_matrix[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings_matrix[j, i] = savings_matrix[i, j]\n\n    # Initialize routes with individual customers\n    routes = {i: [i] for i in range(1, n)}\n    route_capacities = {i: demands[i] for i in range(1, n)}\n\n    # Iteratively merge routes based on savings\n    while True:\n        best_savings = -1\n        best_i = None\n        best_j = None\n\n        for i in routes:\n            for j in routes:\n                if i != j and i < j:\n                    if route_capacities[i] + route_capacities[j] <= capacity:\n                        savings = savings_matrix[routes[i][-1], routes[j][0]]\n                        if savings > best_savings:\n                            best_savings = savings\n                            best_i = i\n                            best_j = j\n\n        if best_savings > -1:\n            # Merge routes i and j\n            routes[best_i].extend(routes[best_j])\n            route_capacities[best_i] += route_capacities[best_j]\n            del routes[best_j]\n            del route_capacities[best_j]\n        else:\n            break\n\n    # Update heuristics matrix based on merged routes\n    for route_id in routes:\n        route = [0] + routes[route_id] + [0]\n        for i in range(len(route) - 1):\n            heuristics_matrix[route[i], route[i+1]] = 1\n            heuristics_matrix[route[i+1], route[i]] = 1\n\n    return heuristics_matrix",
          "objective": 14.39732,
          "other_inf": null
     }
]