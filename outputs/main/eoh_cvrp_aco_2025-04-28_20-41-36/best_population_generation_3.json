{
     "algorithm": "This algorithm constructs a heuristic matrix based on savings values, a capacity penalty that scales with distance, and a proximity bonus that is inversely proportional to the square of the distance.",
     "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"{This algorithm constructs a heuristic matrix based on savings values, a capacity penalty that scales with distance, and a proximity bonus that is inversely proportional to the square of the distance.}\"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n\n    # Calculate savings values\n    savings_matrix = np.zeros_like(distance_matrix)\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                savings_matrix[i][j] = distance_matrix[0][i] + distance_matrix[0][j] - distance_matrix[i][j]\n\n    # Construct heuristic matrix\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                # Base heuristic score from savings\n                heuristics_matrix[i][j] = savings_matrix[i][j]\n\n                # Capacity penalty: penalize linking nodes that would exceed capacity, scaling with distance\n                if demands[i] + demands[j] > capacity:\n                    heuristics_matrix[i][j] -= (demands[i] + demands[j] - capacity) * distance_matrix[i][j]\n\n                # Proximity bonus: reward linking nodes that are close to each other, inversely proportional to squared distance\n                euclidean_distance = np.sqrt(np.sum((coordinates[i] - coordinates[j])**2))\n                heuristics_matrix[i][j] += (np.mean(distance_matrix) / ((euclidean_distance**2) + 1e-6))  # Add a small constant to avoid division by zero\n\n    return heuristics_matrix",
     "objective": 9.58126,
     "other_inf": null
}