[
     {
          "algorithm": "This algorithm refines the savings approach by incorporating a penalty for exceeding capacity during route construction and prioritizing connections to nodes with higher demand relative to their distance.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm refines the savings approach by incorporating a penalty for exceeding capacity during route construction and prioritizing connections to nodes with higher demand relative to their distance.}\n    \"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    savings_matrix = np.zeros_like(distance_matrix)\n\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings_matrix[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings_matrix[j, i] = savings_matrix[i, j]\n\n    demand_distance_ratio = np.zeros_like(distance_matrix)\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                demand_distance_ratio[i, j] = (demands[i] + demands[j]) / distance_matrix[i, j]\n            else:\n                demand_distance_ratio[i, j] = 0\n                \n    penalty_matrix = np.zeros_like(distance_matrix)\n    for i in range(1, n):\n      for j in range(1, n):\n        if i!=j:\n          if demands[i] + demands[j] > capacity:\n            penalty_matrix[i, j] = -1\n            penalty_matrix[j, i] = -1\n        else:\n          penalty_matrix[i,j] = -1\n\n\n    normalized_savings = savings_matrix / (np.max(savings_matrix) if np.any(savings_matrix) else 1)\n    normalized_demand_distance = demand_distance_ratio / (np.max(demand_distance_ratio) if np.any(demand_distance_ratio) else 1)\n\n    heuristics_matrix = normalized_savings + normalized_demand_distance + penalty_matrix\n\n    return heuristics_matrix",
          "objective": 11.25901,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm samples multiple random routes satisfying capacity constraints, then weights the edge frequencies by the inverse of the edge distance to generate a heuristic matrix.}\"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    num_samples = 1000\n\n    for _ in range(num_samples):\n        route = [0]\n        remaining_nodes = set(range(1, n))\n        current_capacity = capacity\n\n        while remaining_nodes:\n            feasible_nodes = {\n                node for node in remaining_nodes if demands[node] <= current_capacity\n            }\n\n            if not feasible_nodes:\n                route.append(0)\n                current_capacity = capacity\n                feasible_nodes = {\n                    node for node in remaining_nodes if demands[node] <= current_capacity\n                ",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"{This algorithm samples multiple random routes satisfying capacity constraints, then weights the edge frequencies by the inverse of the edge distance to generate a heuristic matrix.}\"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    num_samples = 1000\n\n    for _ in range(num_samples):\n        route = [0]\n        remaining_nodes = set(range(1, n))\n        current_capacity = capacity\n\n        while remaining_nodes:\n            feasible_nodes = {\n                node for node in remaining_nodes if demands[node] <= current_capacity\n            }\n\n            if not feasible_nodes:\n                route.append(0)\n                current_capacity = capacity\n                feasible_nodes = {\n                    node for node in remaining_nodes if demands[node] <= current_capacity\n                }\n                if not feasible_nodes:\n                    break\n\n            next_node = min(\n                feasible_nodes, key=lambda node: distance_matrix[route[-1]][node]\n            )\n\n            route.append(next_node)\n            remaining_nodes.remove(next_node)\n            current_capacity -= demands[next_node]\n\n        route.append(0)\n        for i in range(len(route) - 1):\n            distance = distance_matrix[route[i]][route[i+1]]\n            if distance > 0:\n                heuristics_matrix[route[i]][route[i+1]] += 1 / distance\n                heuristics_matrix[route[i+1]][route[i]] += 1 / distance\n            else:\n                heuristics_matrix[route[i]][route[i+1]] += 1\n                heuristics_matrix[route[i+1]][route[i]] += 1\n\n    heuristics_matrix = heuristics_matrix / num_samples\n    return heuristics_matrix",
          "objective": 12.43079,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm constructs a Clarke-Wright savings matrix, then iteratively merges nodes based on the highest savings while respecting capacity constraints, updating the heuristics matrix based on merged routes.}\n    \"\"\"\n    n = len(demands)\n    savings_matrix = np.zeros_like(distance_matrix)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n\n    # Calculate savings matrix\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings_matrix[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings_matrix[j, i] = savings_matrix[i, j]\n\n    # Initialize routes with individual customers\n    routes = {i: [i] for i in range(1, n)}\n    route_capacities = {i: demands[i] for i in range(1, n)",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm constructs a Clarke-Wright savings matrix, then iteratively merges nodes based on the highest savings while respecting capacity constraints, updating the heuristics matrix based on merged routes.}\n    \"\"\"\n    n = len(demands)\n    savings_matrix = np.zeros_like(distance_matrix)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n\n    # Calculate savings matrix\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings_matrix[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings_matrix[j, i] = savings_matrix[i, j]\n\n    # Initialize routes with individual customers\n    routes = {i: [i] for i in range(1, n)}\n    route_capacities = {i: demands[i] for i in range(1, n)}\n\n    # Iteratively merge routes based on savings\n    while True:\n        best_savings = -1\n        best_i = None\n        best_j = None\n\n        for i in routes:\n            for j in routes:\n                if i != j and i < j:\n                    if route_capacities[i] + route_capacities[j] <= capacity:\n                        savings = savings_matrix[routes[i][-1], routes[j][0]]\n                        if savings > best_savings:\n                            best_savings = savings\n                            best_i = i\n                            best_j = j\n\n        if best_savings > -1:\n            # Merge routes i and j\n            routes[best_i].extend(routes[best_j])\n            route_capacities[best_i] += route_capacities[best_j]\n            del routes[best_j]\n            del route_capacities[best_j]\n        else:\n            break\n\n    # Update heuristics matrix based on merged routes\n    for route_id in routes:\n        route = [0] + routes[route_id] + [0]\n        for i in range(len(route) - 1):\n            heuristics_matrix[route[i], route[i+1]] = 1\n            heuristics_matrix[route[i+1], route[i]] = 1\n\n    return heuristics_matrix",
          "objective": 14.39732,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm combines the savings approach with random route sampling, iteratively merging nodes based on a weighted combination of savings and sampled route frequencies to build a heuristics matrix.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm combines the savings approach with random route sampling, iteratively merging nodes based on a weighted combination of savings and sampled route frequencies to build a heuristics matrix.}\n    \"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    num_samples = 500\n    savings_weight = 0.5\n    sample_weight = 0.5\n    \n    savings_matrix = np.zeros_like(distance_matrix)\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings_matrix[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings_matrix[j, i] = savings_matrix[i, j]\n\n    sample_frequency_matrix = np.zeros_like(distance_matrix)\n    for _ in range(num_samples):\n        route = [0]\n        remaining_nodes = set(range(1, n))\n        current_capacity = capacity\n        \n        while remaining_nodes:\n            next_node_candidates = sorted(remaining_nodes, key=lambda node: distance_matrix[route[-1]][node])\n            \n            found_next_node = False\n            for next_node in next_node_candidates:\n                if demands[next_node] <= current_capacity:\n                    route.append(next_node)\n                    remaining_nodes.remove(next_node)\n                    current_capacity -= demands[next_node]\n                    found_next_node = True\n                    break\n\n            if not found_next_node:\n                route.append(0)\n                current_capacity = capacity\n            \n        route.append(0)\n\n        for i in range(len(route) - 1):\n            sample_frequency_matrix[route[i]][route[i+1]] += 1\n            sample_frequency_matrix[route[i+1]][route[i]] += 1\n\n    max_savings = np.max(savings_matrix) if np.any(savings_matrix) else 1\n    max_frequency = np.max(sample_frequency_matrix) if np.any(sample_frequency_matrix) else 1\n\n    normalized_savings = savings_matrix / max_savings\n    normalized_frequency = sample_frequency_matrix / max_frequency\n\n    heuristics_matrix = savings_weight * normalized_savings + sample_weight * normalized_frequency\n\n    return heuristics_matrix",
          "objective": 14.73408,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm constructs a Clarke-Wright savings matrix, then iteratively merges nodes based on a weighted combination of savings and distance, while respecting capacity constraints, updating the heuristics matrix based on merged routes.}\n    \"\"\"\n    n = len(demands)\n    savings_matrix = np.zeros_like(distance_matrix)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n\n    # Calculate savings matrix\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings_matrix[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings_matrix[j, i] = savings_matrix[i, j]\n\n    # Initialize routes with individual customers\n    routes = {i: [i] for i in range(1, n)}\n    route_capacities = {i: demands[i] for i in range(1, n)",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm constructs a Clarke-Wright savings matrix, then iteratively merges nodes based on a weighted combination of savings and distance, while respecting capacity constraints, updating the heuristics matrix based on merged routes.}\n    \"\"\"\n    n = len(demands)\n    savings_matrix = np.zeros_like(distance_matrix)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n\n    # Calculate savings matrix\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings_matrix[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings_matrix[j, i] = savings_matrix[i, j]\n\n    # Initialize routes with individual customers\n    routes = {i: [i] for i in range(1, n)}\n    route_capacities = {i: demands[i] for i in range(1, n)}\n\n    # Iteratively merge routes based on savings and distance\n    while True:\n        best_score = -1\n        best_i = None\n        best_j = None\n\n        for i in routes:\n            for j in routes:\n                if i != j and i < j:\n                    if route_capacities[i] + route_capacities[j] <= capacity:\n                        # Weighted score based on savings and distance\n                        savings = savings_matrix[routes[i][-1], routes[j][0]]\n                        distance = distance_matrix[routes[i][-1], routes[j][0]]\n                        score = 0.7 * savings - 0.3 * distance  # Example weights, can be tuned\n\n                        if score > best_score:\n                            best_score = score\n                            best_i = i\n                            best_j = j\n\n        if best_score > -1:\n            # Merge routes i and j\n            routes[best_i].extend(routes[best_j])\n            route_capacities[best_i] += route_capacities[best_j]\n            del routes[best_j]\n            del route_capacities[best_j]\n        else:\n            break\n\n    # Update heuristics matrix based on merged routes\n    for route_id in routes:\n        route = [0] + routes[route_id] + [0]\n        for i in range(len(route) - 1):\n            heuristics_matrix[route[i], route[i+1]] = 1\n            heuristics_matrix[route[i+1], route[i]] = 1\n\n    return heuristics_matrix",
          "objective": 14.98339,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm iteratively refines routes by probabilistically swapping edges based on their impact on route length and capacity feasibility, generating a heuristic matrix that reflects edge usage in improved routes.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"{This algorithm iteratively refines routes by probabilistically swapping edges based on their impact on route length and capacity feasibility, generating a heuristic matrix that reflects edge usage in improved routes.}\"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    num_iterations = 500\n    num_routes = 5\n\n    def create_initial_routes():\n        routes = []\n        for _ in range(num_routes):\n            unvisited = set(range(1, n))\n            current_route = [0]\n            current_load = 0\n\n            while unvisited:\n                feasible_nodes = [node for node in unvisited if current_load + demands[node] <= capacity]\n                if not feasible_nodes:\n                    current_route.append(0)\n                    routes.append(current_route)\n                    current_route = [0]\n                    current_load = 0\n                    feasible_nodes = [node for node in unvisited if current_load + demands[node] <= capacity]\n                    if not feasible_nodes:\n                        break\n\n                next_node = min(feasible_nodes, key=lambda node: distance_matrix[current_route[-1], node])\n                current_route.append(next_node)\n                current_load += demands[next_node]\n                unvisited.remove(next_node)\n\n            current_route.append(0)\n            routes.append(current_route)\n        return routes\n    \n    def calculate_route_distance(route):\n        distance = 0\n        for i in range(len(route) - 1):\n            distance += distance_matrix[route[i], route[i+1]]\n        return distance\n\n    routes = create_initial_routes()\n\n    for _ in range(num_iterations):\n        for route_index in range(len(routes)):\n            route = routes[route_index]\n            if len(route) <= 3:\n              continue\n            \n            i = random.randint(1, len(route) - 2)\n            j = random.randint(1, len(route) - 2)\n\n            if i == j:\n                continue\n            \n            new_route = route[:min(i,j)] + route[min(i,j):max(i,j)+1][::-1] + route[max(i,j)+1:]\n            \n            new_route_load = [0] * len(new_route)\n            for k in range(1,len(new_route)):\n              if new_route[k] == 0:\n                continue\n              new_route_load[k] = new_route_load[k-1] + demands[new_route[k]]\n\n            is_feasible = True\n            max_load = 0\n            temp_load = 0\n            for k in range(1, len(new_route)):\n              if new_route[k] == 0:\n                max_load = max(max_load, temp_load)\n                temp_load = 0\n                continue\n              temp_load += demands[new_route[k]]\n            max_load = max(max_load, temp_load)\n            \n            if max_load > capacity:\n                is_feasible = False\n\n            if is_feasible:\n                old_distance = calculate_route_distance(route)\n                new_distance = calculate_route_distance(new_route)\n\n                if new_distance < old_distance:\n                    routes[route_index] = new_route\n\n    for route in routes:\n        for i in range(len(route) - 1):\n            heuristics_matrix[route[i]][route[i+1]] += 1\n            heuristics_matrix[route[i+1]][route[i]] += 1\n\n    heuristics_matrix = heuristics_matrix / (num_iterations * num_routes) if (num_iterations * num_routes) > 0 else heuristics_matrix\n\n    return heuristics_matrix",
          "objective": 15.47206,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm refines routes by iteratively applying a 2-opt swap to improve route length while maintaining feasibility, and updates a heuristic matrix based on edge usage in the improved routes.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"{This algorithm refines routes by iteratively applying a 2-opt swap to improve route length while maintaining feasibility, and updates a heuristic matrix based on edge usage in the improved routes.}\"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    num_iterations = 500\n    num_routes = 5\n\n    def create_initial_routes():\n        routes = []\n        for _ in range(num_routes):\n            unvisited = set(range(1, n))\n            current_route = [0]\n            current_load = 0\n\n            while unvisited:\n                feasible_nodes = [node for node in unvisited if current_load + demands[node] <= capacity]\n                if not feasible_nodes:\n                    current_route.append(0)\n                    routes.append(current_route)\n                    current_route = [0]\n                    current_load = 0\n                    feasible_nodes = [node for node in unvisited if current_load + demands[node] <= capacity]\n                    if not feasible_nodes:\n                        break\n\n                next_node = min(feasible_nodes, key=lambda node: distance_matrix[current_route[-1], node])\n                current_route.append(next_node)\n                current_load += demands[next_node]\n                unvisited.remove(next_node)\n\n            current_route.append(0)\n            routes.append(current_route)\n        return routes\n    \n    def calculate_route_distance(route):\n        distance = 0\n        for i in range(len(route) - 1):\n            distance += distance_matrix[route[i], route[i+1]]\n        return distance\n\n    routes = create_initial_routes()\n\n    for _ in range(num_iterations):\n        for route_index in range(len(routes)):\n            route = routes[route_index]\n            if len(route) <= 3:\n              continue\n            \n            best_route = route\n            best_distance = calculate_route_distance(route)\n\n            for i in range(1, len(route) - 2):\n                for j in range(i + 1, len(route) - 1):\n                    new_route = route[:i] + route[i:j+1][::-1] + route[j+1:]\n            \n                    new_route_load = [0] * len(new_route)\n                    for k in range(1,len(new_route)):\n                      if new_route[k] == 0:\n                        continue\n                      new_route_load[k] = new_route_load[k-1] + demands[new_route[k]]\n\n                    is_feasible = True\n                    max_load = 0\n                    temp_load = 0\n                    for k in range(1, len(new_route)):\n                      if new_route[k] == 0:\n                        max_load = max(max_load, temp_load)\n                        temp_load = 0\n                        continue\n                      temp_load += demands[new_route[k]]\n                    max_load = max(max_load, temp_load)\n                    \n                    if max_load > capacity:\n                        is_feasible = False\n\n                    if is_feasible:\n                        new_distance = calculate_route_distance(new_route)\n                        if new_distance < best_distance:\n                            best_distance = new_distance\n                            best_route = new_route\n\n            routes[route_index] = best_route\n\n    for route in routes:\n        for i in range(len(route) - 1):\n            heuristics_matrix[route[i]][route[i+1]] += 1\n            heuristics_matrix[route[i+1]][route[i]] += 1\n\n    heuristics_matrix = heuristics_matrix / (num_iterations * num_routes) if (num_iterations * num_routes) > 0 else heuristics_matrix\n\n    return heuristics_matrix",
          "objective": 15.52098,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm iteratively refines routes by probabilistically accepting edge swaps based on a score function that combines route length improvement and capacity feasibility, dynamically adjusting the acceptance probability based on temperature annealing.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"{This algorithm iteratively refines routes by probabilistically accepting edge swaps based on a score function that combines route length improvement and capacity feasibility, dynamically adjusting the acceptance probability based on temperature annealing.}\"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    num_iterations = 500\n    num_routes = 5\n    initial_temperature = 100\n    cooling_rate = 0.95\n\n    def create_initial_routes():\n        routes = []\n        for _ in range(num_routes):\n            unvisited = set(range(1, n))\n            current_route = [0]\n            current_load = 0\n\n            while unvisited:\n                feasible_nodes = [node for node in unvisited if current_load + demands[node] <= capacity]\n                if not feasible_nodes:\n                    current_route.append(0)\n                    routes.append(current_route)\n                    current_route = [0]\n                    current_load = 0\n                    feasible_nodes = [node for node in unvisited if current_load + demands[node] <= capacity]\n                    if not feasible_nodes:\n                        break\n\n                next_node = min(feasible_nodes, key=lambda node: distance_matrix[current_route[-1], node])\n                current_route.append(next_node)\n                current_load += demands[next_node]\n                unvisited.remove(next_node)\n\n            current_route.append(0)\n            routes.append(current_route)\n        return routes\n\n    def calculate_route_distance(route):\n        distance = 0\n        for i in range(len(route) - 1):\n            distance += distance_matrix[route[i], route[i+1]]\n        return distance\n    \n    def calculate_route_load(route):\n      max_load = 0\n      temp_load = 0\n      for k in range(1, len(route)):\n        if route[k] == 0:\n          max_load = max(max_load, temp_load)\n          temp_load = 0\n          continue\n        temp_load += demands[route[k]]\n      max_load = max(max_load, temp_load)\n      return max_load\n\n    routes = create_initial_routes()\n    temperature = initial_temperature\n\n    for _ in range(num_iterations):\n        for route_index in range(len(routes)):\n            route = routes[route_index]\n            if len(route) <= 3:\n              continue\n            \n            i = random.randint(1, len(route) - 2)\n            j = random.randint(1, len(route) - 2)\n\n            if i == j:\n                continue\n            \n            new_route = route[:min(i,j)] + route[min(i,j):max(i,j)+1][::-1] + route[max(i,j)+1:]\n\n            is_feasible = calculate_route_load(new_route) <= capacity\n\n            old_distance = calculate_route_distance(route)\n            new_distance = calculate_route_distance(new_route)\n            distance_change = new_distance - old_distance\n            \n            if is_feasible:\n                if distance_change < 0:\n                    routes[route_index] = new_route\n                else:\n                    acceptance_probability = np.exp(-distance_change / temperature)\n                    if random.random() < acceptance_probability:\n                        routes[route_index] = new_route\n            \n        temperature *= cooling_rate\n\n    for route in routes:\n        for i in range(len(route) - 1):\n            heuristics_matrix[route[i]][route[i+1]] += 1\n            heuristics_matrix[route[i+1]][route[i]] += 1\n\n    heuristics_matrix = heuristics_matrix / (num_iterations * num_routes) if (num_iterations * num_routes) > 0 else heuristics_matrix\n\n    return heuristics_matrix",
          "objective": 15.61608,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm constructs a Clarke-Wright savings matrix, then iteratively merges nodes based on the weighted highest savings while respecting capacity constraints, updating the heuristics matrix based on merged routes.}\n    \"\"\"\n    n = len(demands)\n    savings_matrix = np.zeros_like(distance_matrix)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n\n    # Calculate savings matrix\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings_matrix[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings_matrix[j, i] = savings_matrix[i, j]\n\n    # Initialize routes with individual customers\n    routes = {i: [i] for i in range(1, n)}\n    route_capacities = {i: demands[i] for i in range(1, n)",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm constructs a Clarke-Wright savings matrix, then iteratively merges nodes based on the weighted highest savings while respecting capacity constraints, updating the heuristics matrix based on merged routes.}\n    \"\"\"\n    n = len(demands)\n    savings_matrix = np.zeros_like(distance_matrix)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n\n    # Calculate savings matrix\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings_matrix[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings_matrix[j, i] = savings_matrix[i, j]\n\n    # Initialize routes with individual customers\n    routes = {i: [i] for i in range(1, n)}\n    route_capacities = {i: demands[i] for i in range(1, n)}\n\n    # Iteratively merge routes based on savings\n    while True:\n        best_savings = -1\n        best_i = None\n        best_j = None\n\n        for i in routes:\n            for j in routes:\n                if i != j and i < j:\n                    if route_capacities[i] + route_capacities[j] <= capacity:\n                        # Weighted savings calculation\n                        savings = savings_matrix[routes[i][-1], routes[j][0]] / (distance_matrix[routes[i][-1], routes[j][0]] + 1e-6)\n                        if savings > best_savings:\n                            best_savings = savings\n                            best_i = i\n                            best_j = j\n\n        if best_savings > -1:\n            # Merge routes i and j\n            routes[best_i].extend(routes[best_j])\n            route_capacities[best_i] += route_capacities[best_j]\n            del routes[best_j]\n            del route_capacities[best_j]\n        else:\n            break\n\n    # Update heuristics matrix based on merged routes\n    for route_id in routes:\n        route = [0] + routes[route_id] + [0]\n        for i in range(len(route) - 1):\n            heuristics_matrix[route[i], route[i+1]] = 1\n            heuristics_matrix[route[i+1], route[i]] = 1\n\n    return heuristics_matrix",
          "objective": 15.7101,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm samples multiple random routes satisfying capacity constraints,\n    then averages the edge frequencies across all routes to generate a heuristic matrix.}\n    \"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    num_samples = 1000\n\n    for _ in range(num_samples):\n        route = [0]\n        remaining_nodes = set(range(1, n))\n        current_capacity = capacity\n\n        while remaining_nodes:\n            feasible_nodes = {\n                node for node in remaining_nodes if demands[node] <= current_capacity\n            }\n\n            if not feasible_nodes:\n                route.append(0)\n                current_capacity = capacity\n                feasible_nodes = {\n                    node for node in remaining_nodes if demands[node] <= current_capacity\n                ",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm samples multiple random routes satisfying capacity constraints,\n    then averages the edge frequencies across all routes to generate a heuristic matrix.}\n    \"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    num_samples = 1000\n\n    for _ in range(num_samples):\n        route = [0]\n        remaining_nodes = set(range(1, n))\n        current_capacity = capacity\n\n        while remaining_nodes:\n            feasible_nodes = {\n                node for node in remaining_nodes if demands[node] <= current_capacity\n            }\n\n            if not feasible_nodes:\n                route.append(0)\n                current_capacity = capacity\n                feasible_nodes = {\n                    node for node in remaining_nodes if demands[node] <= current_capacity\n                }\n                if not feasible_nodes:\n                  break\n\n            next_node = min(\n                feasible_nodes, key=lambda node: distance_matrix[route[-1]][node]\n            )\n\n            route.append(next_node)\n            remaining_nodes.remove(next_node)\n            current_capacity -= demands[next_node]\n\n        route.append(0)\n        for i in range(len(route) - 1):\n            heuristics_matrix[route[i]][route[i+1]] += 1\n            heuristics_matrix[route[i+1]][route[i]] += 1\n    \n    heuristics_matrix = heuristics_matrix / num_samples\n    return heuristics_matrix",
          "objective": 16.02473,
          "other_inf": null
     }
]