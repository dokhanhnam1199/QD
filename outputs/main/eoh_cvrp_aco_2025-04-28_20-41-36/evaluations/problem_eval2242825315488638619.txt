import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm starts with a random feasible solution and iteratively improves it by swapping nodes between routes, guided by a stochastic acceptance criterion based on savings and capacity constraints.}"""
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)

    # Initialize routes randomly
    unassigned_customers = list(range(1, n))
    routes = []
    while unassigned_customers:
        route = [0]
        current_capacity = 0
        while unassigned_customers:
            candidate = random.choice(unassigned_customers)
            if current_capacity + demands[candidate] <= capacity:
                route.append(candidate)
                current_capacity += demands[candidate]
                unassigned_customers.remove(candidate)
            else:
                break
        route.append(0)
        routes.append(route)

    # Iteratively improve routes by swapping nodes
    for _ in range(1000): #Number of iterations
        route1_idx = random.randint(0, len(routes) - 1)
        route2_idx = random.randint(0, len(routes) - 1)
        if route1_idx == route2_idx:
            continue

        route1 = routes[route1_idx]
        route2 = routes[route2_idx]

        if len(route1) <= 2 or len(route2) <= 2:
            continue
            
        node1_idx = random.randint(1, len(route1) - 2)
        node2_idx = random.randint(1, len(route2) - 2)

        node1 = route1[node1_idx]
        node2 = route2[node2_idx]

        # Calculate the change in capacity
        capacity_change1 = demands[node2] - demands[node1]
        capacity_change2 = demands[node1] - demands[node2]

        # Check if the swap is feasible
        route1_capacity = sum(demands[node] for node in route1[1:-1])
        route2_capacity = sum(demands[node] for node in route2[1:-1])
        
        if route1_capacity + capacity_change1 > capacity or route2_capacity + capacity_change2 > capacity:
            continue

        # Calculate the change in distance
        delta_distance = (
            distance_matrix[route1[node1_idx - 1], node2] + distance_matrix[node2, route1[node1_idx + 1]] -
            distance_matrix[route1[node1_idx - 1], node1] - distance_matrix[node1, route1[node1_idx + 1]] +
            distance_matrix[route2[node2_idx - 1], node1] + distance_matrix[node1, route2[node2_idx + 1]] -
            distance_matrix[route2[node2_idx - 1], node2] - distance_matrix[node2, route2[node2_idx + 1]]
        )

        # Accept the swap based on a stochastic criterion
        if delta_distance < 0 or random.random() < np.exp(-delta_distance / 10):  # Simulated annealing-like acceptance
            route1[node1_idx] = node2
            route2[node2_idx] = node1


    # Update heuristics matrix based on routes
    for route in routes:
        for i in range(len(route) - 1):
            heuristics_matrix[route[i], route[i+1]] = 1
            heuristics_matrix[route[i+1], route[i]] = 1

    return heuristics_matrix
