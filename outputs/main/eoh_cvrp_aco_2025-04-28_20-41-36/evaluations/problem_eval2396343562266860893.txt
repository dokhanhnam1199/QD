import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm adaptively combines the savings and nearest neighbor approaches by probabilistically selecting edges based on their weighted heuristic scores, dynamically adjusting weights to balance exploration and exploitation.}"""
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)
    
    # Savings calculation (as in Algorithm 1)
    savings_matrix = np.zeros_like(distance_matrix)
    for i in range(1, n):
        for j in range(i + 1, n):
            savings_matrix[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]
            savings_matrix[j, i] = savings_matrix[i, j]

    # Nearest neighbor component (similar to Algorithm 2's starting point)
    def nearest_neighbor(start_node, unvisited, current_capacity):
        feasible_nodes = [node for node in unvisited if demands[node] <= current_capacity]
        if not feasible_nodes:
            return None, None
        next_node = min(feasible_nodes, key=lambda node: distance_matrix[start_node][node])
        return next_node, distance_matrix[start_node][next_node]

    # Adaptive combination and route construction
    routes = []
    unvisited_nodes = set(range(1, n))
    current_route = [0]
    current_capacity = capacity
    alpha = 0.5  # Weight for savings
    beta = 0.5   # Weight for nearest neighbor

    while unvisited_nodes:
        current_node = current_route[-1]

        # Calculate combined heuristic scores for unvisited nodes
        scores = {}
        for node in unvisited_nodes:
            savings_score = savings_matrix[current_node, node] if current_node != 0 else 0 # Savings applicable only from depot
            nn_node, nn_dist = nearest_neighbor(current_node, unvisited_nodes, current_capacity)
            
            nn_score = 0
            if nn_node == node:
              nn_score = 1 / (nn_dist + 1e-6)
            
            if demands[node] > current_capacity:
              scores[node] = -1 #disqualify by a negative score
            else:
              scores[node] = alpha * (savings_score / (np.max(savings_matrix) if np.any(savings_matrix) else 1)) + beta * nn_score

        # Probabilistic selection based on scores
        eligible_nodes = [node for node in unvisited_nodes if scores[node] >= 0]
        if not eligible_nodes:
            routes.append(current_route + [0])
            current_route = [0]
            current_capacity = capacity
            continue

        probabilities = np.array([scores[node] for node in eligible_nodes])
        probabilities = np.exp(probabilities) / np.sum(np.exp(probabilities)) #softmax

        try:
          next_node = random.choices(eligible_nodes, weights=probabilities, k=1)[0]
        except ValueError:
          # Handle edge case where all scores are -inf
          routes.append(current_route + [0])
          current_route = [0]
          current_capacity = capacity
          continue

        current_route.append(next_node)
        unvisited_nodes.remove(next_node)
        current_capacity -= demands[next_node]

        if current_capacity < 0: #capacity check
              routes.append(current_route[:-1] + [0]) #return to depot without last node
              current_route = [0,next_node] #start new route from depot to the last node
              current_capacity = capacity - demands[next_node] #reset capacity
              
    routes.append(current_route + [0])

    # Update heuristics matrix based on constructed routes
    for route in routes:
        for i in range(len(route) - 1):
            heuristics_matrix[route[i], route[i+1]] = 1
            heuristics_matrix[route[i+1], route[i]] = 1

    return heuristics_matrix
