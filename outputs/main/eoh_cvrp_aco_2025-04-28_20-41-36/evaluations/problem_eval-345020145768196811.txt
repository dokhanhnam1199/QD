import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm constructs a heuristic matrix by combining savings, demand priority, and route length considerations, penalizing exceeding capacity and favoring shorter routes for nodes with high demand.}
    """
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)
    savings_matrix = np.zeros_like(distance_matrix)

    for i in range(1, n):
        for j in range(i + 1, n):
            savings_matrix[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]
            savings_matrix[j, i] = savings_matrix[i, j]
            
    demand_priority = np.zeros_like(distance_matrix)
    for i in range(1, n):
        for j in range(1, n):
            if i != j:
                demand_priority[i, j] = (demands[i] + demands[j]) 
            else:
                demand_priority[i, j] = 0

    penalty_matrix = np.zeros_like(distance_matrix)
    for i in range(1, n):
      for j in range(1, n):
        if i!=j:
          if demands[i] + demands[j] > capacity:
            penalty_matrix[i, j] = -1
            penalty_matrix[j, i] = -1
        else:
          penalty_matrix[i,j] = -1

    route_length = np.zeros_like(distance_matrix)
    for i in range(1, n):
        for j in range(1, n):
            if i != j:
                route_length[i, j] = 1/distance_matrix[i,j]
            else:
                route_length[i, j] = 0

    normalized_savings = savings_matrix / (np.max(savings_matrix) if np.any(savings_matrix) else 1)
    normalized_demand_priority = demand_priority / (np.max(demand_priority) if np.any(demand_priority) else 1)
    normalized_route_length = route_length / (np.max(route_length) if np.any(route_length) else 1)
    

    heuristics_matrix = normalized_savings + normalized_demand_priority + normalized_route_length + penalty_matrix

    return heuristics_matrix
