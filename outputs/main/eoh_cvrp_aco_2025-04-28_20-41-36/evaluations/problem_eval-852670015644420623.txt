import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm refines the Clarke-Wright savings algorithm by incorporating a dynamic penalty based on remaining vehicle capacity and a probabilistic selection of routes based on savings and demand considerations.}
    """
    n = len(demands)
    savings_matrix = np.zeros_like(distance_matrix)
    heuristics_matrix = np.zeros_like(distance_matrix)

    for i in range(1, n):
        for j in range(i + 1, n):
            savings_matrix[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]
            savings_matrix[j, i] = savings_matrix[i, j]

    routes = {i: [i] for i in range(1, n)}
    remaining_capacity = {i: capacity - demands[i] for i in range(1, n)}
    node_to_route = {i: i for i in range(1, n)}

    for _ in range(n * (n - 1) // 2):
        best_i, best_j = None, None
        best_saving = -np.inf

        for i in range(1, n):
            for j in range(i + 1, n):
                if node_to_route[i] != node_to_route[j]:
                    route_i = node_to_route[i]
                    route_j = node_to_route[j]

                    if remaining_capacity[route_i] >= demands[j] and remaining_capacity[route_j] >= demands[i]:
                        saving = savings_matrix[i, j]

                        # Dynamic penalty based on remaining capacity
                        penalty = 0.0
                        if remaining_capacity[route_i] < demands[i] + demands[j] or remaining_capacity[route_j] < demands[i] + demands[j]:
                            penalty = -0.1 * (demands[i] + demands[j])
                        
                        saving += penalty

                        if saving > best_saving:
                            best_saving = saving
                            best_i, best_j = i, j

        if best_i is not None and best_j is not None:
            route_i = node_to_route[best_i]
            route_j = node_to_route[best_j]

            # Probabilistic selection (e.g., roulette wheel selection) could be implemented here

            new_route = routes[route_i] + routes[route_j]
            new_remaining_capacity = remaining_capacity[route_i] - sum(demands[k] for k in routes[route_j])
            
            for node in routes[route_j]:
                node_to_route[node] = route_i

            routes[route_i] = new_route
            remaining_capacity[route_i] = new_remaining_capacity
            del routes[route_j]
            del remaining_capacity[route_j]

    for i in range(1, n):
        for j in range(i + 1, n):
             heuristics_matrix[i, j] = savings_matrix[i, j]
             heuristics_matrix[j, i] = savings_matrix[j, i]

    return heuristics_matrix
