import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm iteratively refines routes by stochastically swapping nodes between routes to improve load balance and reduce overall distance, building a heuristic matrix based on edge frequency in the best routes found.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    num_vehicles = int(np.ceil(np.sum(demands[1:]) / capacity))
    num_iterations = 100
    swap_attempts_per_iteration = 10

    # Initialize routes randomly
    routes = [[] for _ in range(num_vehicles)]
    unassigned_nodes = list(range(1, n))

    for i in range(len(unassigned_nodes)):
        vehicle_index = i % num_vehicles
        routes[vehicle_index].append(unassigned_nodes[i])
        
    best_routes = routes
    best_cost = float('inf')
    
    def calculate_route_cost(routes):
        total_cost = 0
        for route in routes:
            current_route = [0] + route + [0]
            for i in range(len(current_route) - 1):
                total_cost += distance_matrix[current_route[i], current_route[i+1]]
        return total_cost

    for _ in range(num_iterations):
        
        for _ in range(swap_attempts_per_iteration):
            # Select two random routes
            route_index1, route_index2 = random.sample(range(num_vehicles), 2)
            route1, route2 = routes[route_index1], routes[route_index2]

            if not route1 or not route2:
                continue

            # Select a random node from each route
            node1, node2 = random.choice(route1), random.choice(route2)

            # Check capacity constraints after swap
            route1_demand = sum([demands[node] for node in route1])
            route2_demand = sum([demands[node] for node in route2])

            if (route1_demand - demands[node1] + demands[node2] <= capacity) and \
               (route2_demand - demands[node2] + demands[node1] <= capacity):

                # Swap nodes
                route1.remove(node1)
                route2.remove(node2)
                route1.append(node2)
                route2.append(node1)
                
                routes[route_index1], routes[route_index2] = route1, route2
                
        current_cost = calculate_route_cost(routes)

        if current_cost < best_cost:
            best_cost = current_cost
            best_routes = [route[:] for route in routes] # Deep copy
    
    # Update heuristics matrix based on the best routes
    for route in best_routes:
        current_route = [0] + route + [0]
        for i in range(len(current_route) - 1):
            u = current_route[i]
            v = current_route[i+1]
            heuristics_matrix[u, v] += 1
            heuristics_matrix[v, u] += 1

    return heuristics_matrix
