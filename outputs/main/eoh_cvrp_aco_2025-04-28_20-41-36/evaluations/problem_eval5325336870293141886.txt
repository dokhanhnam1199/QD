import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm prioritizes edges connecting nodes with high combined demand while considering proximity and penalizing exceeding capacity, but incorporates a probabilistic element based on the distance to the depot.}
    """
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)

    demand_priority = np.zeros_like(distance_matrix)
    for i in range(1, n):
        for j in range(1, n):
            if i != j:
                demand_priority[i, j] = demands[i] + demands[j]
            else:
                demand_priority[i, j] = 0

    proximity_bonus = np.zeros_like(distance_matrix)
    for i in range(1, n):
        for j in range(1, n):
            if i != j:
                proximity_bonus[i, j] = 1 / (distance_matrix[i, j] + 1e-6)
            else:
                proximity_bonus[i, j] = 0

    capacity_penalty = np.zeros_like(distance_matrix)
    for i in range(1, n):
        for j in range(1, n):
            if i != j and demands[i] + demands[j] > capacity:
                capacity_penalty[i, j] = -5
            else:
                capacity_penalty[i, j] = 0
    
    depot_distance_prob = np.zeros_like(distance_matrix)
    for i in range(1, n):
        for j in range(1, n):
            if i !=j:
                depot_distance_prob[i, j] = random.uniform(0, 1) * (1 / (distance_matrix[0, i] + distance_matrix[0, j] + 1e-6))
            else:
                depot_distance_prob[i,j] = 0

    normalized_demand_priority = demand_priority / (np.max(demand_priority) if np.any(demand_priority) else 1)
    normalized_proximity_bonus = proximity_bonus / (np.max(proximity_bonus) if np.any(proximity_bonus) else 1)

    heuristics_matrix = normalized_demand_priority + normalized_proximity_bonus + capacity_penalty + depot_distance_prob

    return heuristics_matrix
