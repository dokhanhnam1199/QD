import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm iteratively constructs solutions by probabilistically selecting edges based on a combination of distance, demand feasibility, and edge frequency from previous solution attempts.}"""
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)
    num_iterations = 500
    alpha = 0.7  # Weight for distance
    beta = 0.3   # Weight for frequency

    for _ in range(num_iterations):
        current_node = 0
        current_route = [0]
        remaining_nodes = set(range(1, n))
        current_capacity = capacity

        while remaining_nodes:
            feasible_nodes = [node for node in remaining_nodes if demands[node] <= current_capacity]

            if not feasible_nodes:
                current_route.append(0)
                current_capacity = capacity
                current_node = 0
                feasible_nodes = [node for node in remaining_nodes if demands[node] <= current_capacity]
                if not feasible_nodes:
                  break

            probabilities = []
            for node in feasible_nodes:
                distance_score = distance_matrix[current_node, node]
                frequency_score = heuristics_matrix[current_node, node]
                combined_score = alpha * (1 / (distance_score + 1e-6)) + beta * frequency_score
                probabilities.append(combined_score)

            total_probability = sum(probabilities)
            if total_probability == 0:
                probabilities = [1] * len(feasible_nodes)
                total_probability = len(feasible_nodes)


            probabilities = [p / total_probability for p in probabilities]
            
            next_node = random.choices(feasible_nodes, probabilities)[0]

            current_route.append(next_node)
            remaining_nodes.remove(next_node)
            current_capacity -= demands[next_node]
            current_node = next_node

        current_route.append(0)

        for i in range(len(current_route) - 1):
            heuristics_matrix[current_route[i], current_route[i+1]] += 1
            heuristics_matrix[current_route[i+1], current_route[i]] += 1

    heuristics_matrix = heuristics_matrix / num_iterations
    return heuristics_matrix
