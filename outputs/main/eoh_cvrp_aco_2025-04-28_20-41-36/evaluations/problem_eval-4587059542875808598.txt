import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm uses a weighted combination of savings, demand-distance ratio, and penalty for exceeding capacity, while adding a clustering term based on node proximity to encourage intra-cluster connections.}
    """
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)
    savings_matrix = np.zeros_like(distance_matrix)

    for i in range(1, n):
        for j in range(i + 1, n):
            savings_matrix[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]
            savings_matrix[j, i] = savings_matrix[i, j]

    demand_distance_ratio = np.zeros_like(distance_matrix)
    for i in range(1, n):
        for j in range(1, n):
            if i != j:
                demand_distance_ratio[i, j] = (demands[i] + demands[j]) / distance_matrix[i, j]
            else:
                demand_distance_ratio[i, j] = 0
                
    penalty_matrix = np.zeros_like(distance_matrix)
    for i in range(1, n):
      for j in range(1, n):
        if i!=j:
          if demands[i] + demands[j] > capacity:
            penalty_matrix[i, j] = -10 #Increased penalty
            penalty_matrix[j, i] = -10
        else:
          penalty_matrix[i,j] = -10

    normalized_savings = savings_matrix / (np.max(savings_matrix) if np.any(savings_matrix) else 1)
    normalized_demand_distance = demand_distance_ratio / (np.max(demand_distance_ratio) if np.any(demand_distance_ratio) else 1)
    
    # Clustering term based on node proximity
    clustering_matrix = np.zeros_like(distance_matrix)
    for i in range(1, n):
        for j in range(1, n):
            if i != j:
                clustering_matrix[i, j] = np.exp(-distance_matrix[i, j] / np.mean(distance_matrix))
            else:
                clustering_matrix[i, j] = 0

    normalized_clustering = clustering_matrix / (np.max(clustering_matrix) if np.any(clustering_matrix) else 1)

    heuristics_matrix = 0.3 * normalized_savings + 0.4 * normalized_demand_distance + penalty_matrix + 0.3 * normalized_clustering #Adjusted weights, added clustering
    

    return heuristics_matrix
