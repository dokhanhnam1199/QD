import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm refines the Clarke-Wright savings algorithm by incorporating a dynamic penalty based on remaining vehicle capacity and demand proximity, and it introduces a temperature parameter for simulated annealing-like acceptance of less promising merges.}
    """
    n = len(demands)
    savings_matrix = np.zeros_like(distance_matrix)
    heuristics_matrix = np.zeros_like(distance_matrix)

    for i in range(1, n):
        for j in range(i + 1, n):
            savings_matrix[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]
            savings_matrix[j, i] = savings_matrix[i, j]

    routes = {i: [i] for i in range(1, n)}
    remaining_capacity = {i: capacity - demands[i] for i in range(1, n)}
    node_to_route = {i: i for i in range(1, n)}

    temperature = 1.0  # Initial temperature for simulated annealing
    cooling_rate = 0.995 # Cooling rate

    for _ in range(n * (n - 1) // 2):
        best_i, best_j = None, None
        best_score = -np.inf

        for i in range(1, n):
            for j in range(i + 1, n):
                if node_to_route[i] != node_to_route[j]:
                    route_i = node_to_route[i]
                    route_j = node_to_route[j]

                    if remaining_capacity[route_i] >= demands[j] and remaining_capacity[route_j] >= demands[i]:
                        saving = savings_matrix[i, j]

                        # Dynamic penalty based on remaining capacity
                        penalty = 0.0
                        if remaining_capacity[route_i] < demands[i] + demands[j] or remaining_capacity[route_j] < demands[i] + demands[j]:
                            penalty = -0.2 * (demands[i] + demands[j])

                        # Demand Proximity Penalty (higher penalty for distant demands)
                        demand_proximity_penalty = -0.01 * distance_matrix[i, j]

                        score = saving + penalty + demand_proximity_penalty

                        if score > best_score:
                            best_score = score
                            best_i, best_j = i, j

        if best_i is not None and best_j is not None:
            route_i = node_to_route[best_i]
            route_j = node_to_route[best_j]

            # Simulated annealing acceptance criterion
            if best_score >= 0 or random.random() < np.exp(best_score / temperature):
                new_route = routes[route_i] + routes[route_j]
                new_remaining_capacity = remaining_capacity[route_i] - sum(demands[k] for k in routes[route_j])

                for node in routes[route_j]:
                    node_to_route[node] = route_i

                routes[route_i] = new_route
                remaining_capacity[route_i] = new_remaining_capacity
                del routes[route_j]
                del remaining_capacity[route_j]

        temperature *= cooling_rate #Cooling the temperature

    for i in range(1, n):
        for j in range(i + 1, n):
             heuristics_matrix[i, j] = savings_matrix[i, j]
             heuristics_matrix[j, i] = savings_matrix[i, j]

    return heuristics_matrix
