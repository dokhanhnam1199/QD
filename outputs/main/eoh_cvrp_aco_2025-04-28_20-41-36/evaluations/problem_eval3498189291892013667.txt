import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm iteratively refines a heuristic matrix by constructing solutions using the current heuristic, evaluating their cost, and then reinforcing edges present in better solutions while penalizing edges present in worse solutions, incorporating a simulated annealing-inspired acceptance probability to escape local optima.}"""
    n = len(demands)
    heuristics_matrix = np.ones_like(distance_matrix)  # Initialize with all edges equally promising
    temperature = 100.0
    cooling_rate = 0.99
    num_iterations = 50

    for iteration in range(num_iterations):
        routes = []
        route_costs = []

        # Construct a route using the current heuristic matrix
        unvisited = set(range(1, n))
        current_route = [0]
        current_load = 0

        while unvisited:
            feasible_nodes = [node for node in unvisited if current_load + demands[node] <= capacity]
            if not feasible_nodes:
                current_route.append(0)
                routes.append(current_route)
                route_costs.append(calculate_route_cost(current_route, distance_matrix))
                current_route = [0]
                current_load = 0
                feasible_nodes = [node for node in unvisited if current_load + demands[node] <= capacity]
                if not feasible_nodes:
                    break

            next_node = max(feasible_nodes, key=lambda node: heuristics_matrix[current_route[-1], node]) #Select the node with highest heuristic value
            current_route.append(next_node)
            current_load += demands[next_node]
            unvisited.remove(next_node)

        current_route.append(0)
        routes.append(current_route)
        route_costs.append(calculate_route_cost(current_route, distance_matrix))

        total_cost = sum(route_costs)

        # Perturb the heuristic matrix based on the quality of the route.
        for route in routes:
            for i in range(len(route) - 1):
                edge_i = route[i]
                edge_j = route[i+1]

                # Calculate a score for the edge.
                edge_score = 1.0 / (1.0 + total_cost) # Lower cost has higher score

                # Simulated annealing acceptance probability
                delta = edge_score - heuristics_matrix[edge_i, edge_j] #Change in heuristic value
                acceptance_probability = np.exp(delta / temperature)

                if random.random() < acceptance_probability:
                  heuristics_matrix[edge_i, edge_j] += edge_score * 0.1
                  heuristics_matrix[edge_j, edge_i] += edge_score * 0.1
                else:
                  heuristics_matrix[edge_i, edge_j] -= edge_score * 0.05
                  heuristics_matrix[edge_j, edge_i] -= edge_score * 0.05

                heuristics_matrix[edge_i, edge_j] = np.clip(heuristics_matrix[edge_i, edge_j], 0.01, 1.0)
                heuristics_matrix[edge_j, edge_i] = np.clip(heuristics_matrix[edge_j, edge_i], 0.01, 1.0)

        temperature *= cooling_rate #Cool down the temperature
    return heuristics_matrix

def calculate_route_cost(route, distance_matrix):
    cost = 0
    for i in range(len(route) - 1):
        cost += distance_matrix[route[i], route[i+1]]
    return heuristics_matrix
