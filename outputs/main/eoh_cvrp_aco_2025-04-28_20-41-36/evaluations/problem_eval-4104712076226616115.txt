import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm refines the Clarke-Wright savings algorithm by incorporating a dynamic penalty based on remaining vehicle capacity and demand proximity, then uses a probabilistic route selection.}
    """
    n = len(demands)
    savings_matrix = np.zeros_like(distance_matrix)
    heuristics_matrix = np.zeros_like(distance_matrix)

    for i in range(1, n):
        for j in range(i + 1, n):
            savings_matrix[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]
            savings_matrix[j, i] = savings_matrix[i, j]

    routes = {i: [i] for i in range(1, n)}
    remaining_capacity = {i: capacity - demands[i] for i in range(1, n)}
    node_to_route = {i: i for i in range(1, n)}

    for _ in range(n * (n - 1) // 2):
        best_i, best_j = None, None
        best_saving = -np.inf

        for i in range(1, n):
            for j in range(i + 1, n):
                if node_to_route[i] != node_to_route[j]:
                    route_i = node_to_route[i]
                    route_j = node_to_route[j]

                    if remaining_capacity[route_i] >= demands[j] and remaining_capacity[route_j] >= demands[i]:
                        saving = savings_matrix[i, j]

                        # Dynamic penalty based on remaining capacity and demand proximity
                        penalty = 0.0
                        if remaining_capacity[route_i] < demands[i] + demands[j] or remaining_capacity[route_j] < demands[i] + demands[j]:
                            penalty += -0.2 * (demands[i] + demands[j])

                        # Demand proximity penalty - prioritize merging nodes with high demand
                        penalty += -0.05 * abs(demands[i] - demands[j])  # Favor routes with similar demand
                            
                        saving += penalty

                        if saving > best_saving:
                            best_saving = saving
                            best_i, best_j = i, j

        if best_i is not None and best_j is not None:
            route_i = node_to_route[best_i]
            route_j = node_to_route[best_j]

            # Probabilistic selection based on normalized savings
            probabilities = [max(0, best_saving) / (max(0,best_saving)+0.0000001)]  # Avoid division by zero
            
            if random.random() < probabilities[0]:
                new_route = routes[route_i] + routes[route_j]
                new_remaining_capacity = remaining_capacity[route_i] - sum(demands[k] for k in routes[route_j])
                
                for node in routes[route_j]:
                    node_to_route[node] = route_i

                routes[route_i] = new_route
                remaining_capacity[route_i] = new_remaining_capacity
                del routes[route_j]
                del remaining_capacity[route_j]
    
    for i in range(1, n):
        for j in range(i + 1, n):
             heuristics_matrix[i, j] = savings_matrix[i, j]
             heuristics_matrix[j, i] = savings_matrix[i, j]
             
    return heuristics_matrix
