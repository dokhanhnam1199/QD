import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm iteratively builds routes by probabilistically adding the nearest feasible node to the current route based on a sampling of candidate nodes and a weighted random selection favoring shorter distances and lower demand until all nodes are visited.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros((n, n))
    unvisited_nodes = set(range(1, n))
    routes = []
    
    while unvisited_nodes:
        current_route = [0]
        current_capacity = capacity
        current_node = 0  # Start at the depot

        while True:
            # Find feasible candidate nodes based on remaining capacity
            feasible_nodes = [node for node in unvisited_nodes if demands[node] <= current_capacity]

            if not feasible_nodes:
                break  # End the route if no feasible nodes are left
            
            # Sample a subset of candidate nodes based on proximity
            num_candidates = min(5, len(feasible_nodes))  # Limit the number of candidates
            candidate_nodes = random.sample(feasible_nodes, num_candidates)

            # Assign weights based on distance and demand (shorter distance, lower demand = higher weight)
            weights = []
            for node in candidate_nodes:
                distance = distance_matrix[current_node, node]
                demand = demands[node]
                weight = (1 / (distance + 1e-6)) * (1 / (demand + 1e-6))  # Avoid division by zero
                weights.append(weight)

            # Normalize weights to create a probability distribution
            total_weight = sum(weights)
            if total_weight > 0:
                probabilities = [w / total_weight for w in weights]
            else:
                probabilities = [1 / len(candidate_nodes)] * len(candidate_nodes) # Assign equal probability if all weights are zero.

            # Select the next node probabilistically
            next_node = random.choices(candidate_nodes, probabilities)[0]

            # Add the selected node to the route
            current_route.append(next_node)
            unvisited_nodes.remove(next_node)
            current_capacity -= demands[next_node]
            current_node = next_node

        current_route.append(0)  # Return to the depot
        routes.append(current_route)

    # Update heuristics matrix based on generated routes
    for route in routes:
        for i in range(len(route) - 1):
            u = route[i]
            v = route[i+1]
            heuristics_matrix[u, v] += 1
            heuristics_matrix[v, u] += 1

    return heuristics_matrix
