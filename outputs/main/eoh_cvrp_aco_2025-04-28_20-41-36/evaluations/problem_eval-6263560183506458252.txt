import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm combines shortest path computations with demand-based edge weighting to create a heuristic matrix.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

    # Shortest Path Component with Demand Consideration
    for i in range(n):
        for j in range(n):
            if i != j:
                # Weight the distance by the demands of the nodes.  Nodes with larger combined demand should be penalized.
                demand_factor = (demands[i] + demands[j]) / (2 * capacity)  # Normalize by capacity
                weighted_distance = distance_matrix[i, j] * (1 + demand_factor)
                heuristics_matrix[i, j] = 1 / (1 + weighted_distance) # Invert to favor smaller weighted distances
    
    # Increase the weights of edges connecting nodes whose combined demand is less than the capacity.
    for i in range(1, n):
        for j in range(i + 1, n):
            if demands[i] + demands[j] <= capacity:
                heuristics_matrix[i, j] += 0.1  # Add a small bonus
                heuristics_matrix[j, i] += 0.1

    return heuristics_matrix
