import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm uses a clustering approach based on node proximity to the depot and remaining vehicle capacity to construct initial routes, then refines these routes by swapping nodes between routes to reduce the overall travel distance and balance vehicle loads.}
    """
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)
    num_clusters = 4 # Number of clusters

    # 1. Clustering based on distance to depot and capacity
    clusters = [[] for _ in range(num_clusters)]
    cluster_capacities = [0] * num_clusters

    customer_indices = list(range(1, n))
    random.shuffle(customer_indices)  # Randomize assignment

    for customer in customer_indices:
        best_cluster = -1
        min_increase = float('inf')

        for i in range(num_clusters):
            if cluster_capacities[i] + demands[customer] <= capacity:
                increase = distance_matrix[0, customer]  # Proximity to depot
                if increase < min_increase:
                    min_increase = increase
                    best_cluster = i

        if best_cluster != -1:
            clusters[best_cluster].append(customer)
            cluster_capacities[best_cluster] += demands[customer]
        else:
            # If no cluster can accommodate, create a new route/cluster
            min_cluster_cap = min(cluster_capacities)
            min_cluster_ind = cluster_capacities.index(min_cluster_cap)
            clusters[min_cluster_ind].append(customer)
            cluster_capacities[min_cluster_ind] = demands[customer]


    # 2. Route Construction from Clusters
    routes = []
    for cluster in clusters:
        route = [0] + cluster + [0]  # Start and end at depot
        routes.append(route)

    # 3. Route Refinement (Node Swapping)
    num_iterations = 50
    for _ in range(num_iterations):
        # Select two random routes
        route1_idx, route2_idx = random.sample(range(len(routes)), 2)
        route1, route2 = routes[route1_idx], routes[route2_idx]

        # Select two random nodes from the routes (excluding the depot)
        if len(route1) > 2 and len(route2) > 2:
            node1_idx = random.randint(1, len(route1) - 2)
            node2_idx = random.randint(1, len(route2) - 2)
            node1, node2 = route1[node1_idx], route2[node2_idx]

            # Check capacity constraints after swapping
            route1_demand = sum(demands[i] for i in route1[1:-1]) - demands[node1] + demands[node2]
            route2_demand = sum(demands[i] for i in route2[1:-1]) - demands[node2] + demands[node1]

            if route1_demand <= capacity and route2_demand <= capacity:
                # Calculate the change in distance
                old_distance = distance_matrix[route1[node1_idx - 1], node1] + distance_matrix[node1, route1[node1_idx + 1]] + \
                                distance_matrix[route2[node2_idx - 1], node2] + distance_matrix[node2, route2[node2_idx + 1]]
                new_distance = distance_matrix[route1[node1_idx - 1], node2] + distance_matrix[node2, route1[node1_idx + 1]] + \
                                distance_matrix[route2[node2_idx - 1], node1] + distance_matrix[node1, route2[node2_idx + 1]]

                # If swapping reduces the distance, perform the swap
                if new_distance < old_distance:
                    route1[node1_idx], route2[node2_idx] = node2, node1
                    routes[route1_idx], routes[route2_idx] = route1, route2

    # 4. Heuristic Matrix Update based on final routes
    for route in routes:
        for i in range(len(route) - 1):
            u = route[i]
            v = route[i + 1]
            heuristics_matrix[u, v] += 1
            heuristics_matrix[v, u] += 1

    return heuristics_matrix
