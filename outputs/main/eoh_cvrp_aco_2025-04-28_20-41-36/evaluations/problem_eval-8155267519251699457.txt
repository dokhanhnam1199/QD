import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm combines stochastic sampling with a penalty-based approach, generating multiple feasible routes and penalizing edge selection based on distance and capacity utilization to create a weighted heuristic matrix.}"""
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)
    num_samples = 500
    penalty_factor = 0.5

    for _ in range(num_samples):
        route = [0]
        remaining_nodes = set(range(1, n))
        current_capacity = capacity
        route_demand = 0

        while remaining_nodes:
            feasible_nodes = {
                node for node in remaining_nodes if demands[node] <= current_capacity
            }

            if not feasible_nodes:
                route.append(0)
                current_capacity = capacity
                route_demand = 0
                feasible_nodes = {
                    node for node in remaining_nodes if demands[node] <= current_capacity
                }
                if not feasible_nodes:
                    break

            penalties = np.zeros(n)
            for node in feasible_nodes:
                remaining_capacity = current_capacity - demands[node]
                capacity_utilization = 1 - (remaining_capacity / capacity)
                penalties[node] = distance_matrix[route[-1]][node] + penalty_factor * capacity_utilization

            next_node = min(feasible_nodes, key=lambda node: penalties[node])

            route.append(next_node)
            remaining_nodes.remove(next_node)
            current_capacity -= demands[next_node]
            route_demand += demands[next_node]

        route.append(0)

        route_length = len(route)
        for i in range(route_length - 1):
            node1 = route[i]
            node2 = route[i + 1]
            distance = distance_matrix[node1][node2]
            if distance > 0:
                heuristics_matrix[node1][node2] += (1 / distance)
                heuristics_matrix[node2][node1] += (1 / distance)
            else:
                heuristics_matrix[node1][node2] += 1
                heuristics_matrix[node2][node1] += 1


    heuristics_matrix = heuristics_matrix / num_samples
    return heuristics_matrix
