import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm prioritizes connecting nodes based on a combined score of savings, demand proximity, and a capacity-based encouragement, dynamically adjusting the encouragement based on current route load.}
    """
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)
    savings_matrix = np.zeros_like(distance_matrix)

    for i in range(1, n):
        for j in range(i + 1, n):
            savings_matrix[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]
            savings_matrix[j, i] = savings_matrix[i, j]

    demand_proximity = np.zeros_like(distance_matrix)
    for i in range(1, n):
        for j in range(1, n):
            if i != j:
                demand_proximity[i, j] = demands[j] / distance_matrix[i, j]
            else:
                demand_proximity[i, j] = 0

    capacity_encouragement = np.zeros_like(distance_matrix)
    for i in range(1, n):
        for j in range(1, n):
            if i != j:
                remaining_capacity = capacity - demands[i]
                if demands[j] <= remaining_capacity:
                    capacity_encouragement[i, j] = 1 - (demands[j] / remaining_capacity)
                else:
                    capacity_encouragement[i, j] = -1  # Discourage exceeding capacity
            else:
                capacity_encouragement[i, j] = -1

    normalized_savings = savings_matrix / (np.max(savings_matrix) if np.any(savings_matrix) else 1)
    normalized_demand_proximity = demand_proximity / (np.max(demand_proximity) if np.any(demand_proximity) else 1)

    heuristics_matrix = normalized_savings + normalized_demand_proximity + capacity_encouragement

    return heuristics_matrix
