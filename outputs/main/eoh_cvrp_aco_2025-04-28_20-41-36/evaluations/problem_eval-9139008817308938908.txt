import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm uses a Clarke-Wright savings heuristic to build routes and constructs a heuristics matrix based on edges appearing in these routes.}"""
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)

    # Calculate savings
    savings = np.zeros((n, n))
    for i in range(1, n):
        for j in range(i + 1, n):
            savings[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]
            savings[j, i] = savings[i, j]

    # Sort savings in descending order
    savings_list = []
    for i in range(1, n):
        for j in range(i + 1, n):
            savings_list.append((i, j, savings[i, j]))
    savings_list.sort(key=lambda x: x[2], reverse=True)

    # Initialize routes
    routes = {}
    node_route = {}
    route_id = 0
    for i in range(1, n):
        routes[route_id] = [i]
        node_route[i] = route_id
        route_id += 1

    # Merge routes based on savings
    for i, j, _ in savings_list:
        route_i = node_route[i]
        route_j = node_route[j]

        if route_i != route_j:
            total_demand = 0
            for node in routes[route_i]:
                total_demand += demands[node]
            for node in routes[route_j]:
                total_demand += demands[node]

            if total_demand <= capacity:
                # Merge routes
                routes[route_i].extend(routes[route_j])
                for node in routes[route_j]:
                    node_route[node] = route_i
                
                # Delete merged route
                del routes[route_j]

    # Construct the solution (routes with depot) and update the heuristics matrix
    final_routes = []
    for route_id in routes:
      current_route = [0] + routes[route_id] + [0]
      final_routes.append(current_route)

      for k in range(len(current_route) - 1):
        heuristics_matrix[current_route[k], current_route[k+1]] = 1
        heuristics_matrix[current_route[k+1], current_route[k]] = 1
            
    return heuristics_matrix
