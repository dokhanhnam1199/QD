import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm adaptively weights proximity, demand, and route density based on a learning rate, encouraging exploration of diverse routes.}"""
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)

    proximity_matrix = 1 / (distance_matrix + 1e-6)  # Avoid division by zero
    normalized_proximity = proximity_matrix / np.max(proximity_matrix)

    demand_compatibility = np.zeros_like(distance_matrix)
    for i in range(1, n):
        for j in range(1, n):
            if i != j:
                demand_compatibility[i, j] = 1 - abs(demands[i] + demands[j] - capacity) / capacity if demands[i] + demands[j] <= 2 * capacity else -1
            else:
                demand_compatibility[i, j] = -1

    normalized_demand_compatibility = demand_compatibility / (np.max(np.abs(demand_compatibility)) if np.any(demand_compatibility) else 1)

    route_density_penalty = np.zeros_like(distance_matrix)
    for i in range(1, n):
        for j in range(1, n):
            if i != j:
                nodes_within_radius = 0
                radius = distance_matrix[i, j]
                for k in range(1, n):
                    if k != i and k !=j and distance_matrix[i, k] <= radius:
                        nodes_within_radius += 1
                route_density_penalty[i, j] = -nodes_within_radius
            else:
                route_density_penalty[i, j] = 0

    normalized_route_density_penalty = route_density_penalty / (np.max(np.abs(route_density_penalty)) if np.any(route_density_penalty) else 1)

    # Adaptive weighting using a learning rate
    learning_rate = 0.1 
    proximity_weight = 0.4 + learning_rate * random.uniform(-0.2, 0.2)
    demand_weight = 0.4 + learning_rate * random.uniform(-0.2, 0.2)
    density_weight = 0.2 + learning_rate * random.uniform(-0.1, 0.1)

    heuristics_matrix = proximity_weight * normalized_proximity + demand_weight * normalized_demand_compatibility + density_weight * normalized_route_density_penalty

    return heuristics_matrix
