import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm constructs a heuristic matrix by iteratively building routes, favoring edges that connect to nodes with higher demand while penalizing routes exceeding capacity and incorporating a proximity factor.}"""
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)
    num_iterations = 100

    for _ in range(num_iterations):
        current_route = [0]
        remaining_nodes = set(range(1, n))
        current_capacity = capacity

        while remaining_nodes:
            # Calculate a score for each feasible node
            node_scores = {}
            for node in remaining_nodes:
                if demands[node] <= current_capacity:
                    demand_factor = demands[node]
                    proximity_factor = 1 / distance_matrix[current_route[-1]][node] if distance_matrix[current_route[-1]][node] > 0 else 1
                    node_scores[node] = demand_factor * proximity_factor
                else:
                    node_scores[node] = -1  # Mark as infeasible

            # Select the next node based on the scores
            if node_scores:
                best_node = max(node_scores, key=node_scores.get)
            else:
                best_node = None
            
            if best_node is None or node_scores[best_node] <=0: # If no feasible node is found
                heuristics_matrix[current_route[-1], 0] += 0.1 # Encourages returning to depot
                heuristics_matrix[0, current_route[-1]] += 0.1
                current_route.append(0)
                current_capacity = capacity
                remaining_nodes = set(range(1, n))
                continue

            if demands[best_node] > current_capacity:
              heuristics_matrix[current_route[-1], 0] -= 0.1 #Penalize if exceeds capacity
              heuristics_matrix[0, current_route[-1]] -= 0.1
              current_route.append(0)
              current_capacity = capacity
              continue


            # Update route and capacity
            heuristics_matrix[current_route[-1]][best_node] += 1
            heuristics_matrix[best_node][current_route[-1]] += 1
            current_route.append(best_node)
            remaining_nodes.remove(best_node)
            current_capacity -= demands[best_node]
            
        # Return to depot at the end of the route
        heuristics_matrix[current_route[-1]][0] += 1
        heuristics_matrix[0][current_route[-1]] += 1

    heuristics_matrix = heuristics_matrix / num_iterations
    return heuristics_matrix
