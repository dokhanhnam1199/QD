import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm combines savings, route sampling, and a distance-based penalty to create a heuristic matrix, prioritizing high savings and frequent edges while discouraging long edges.}
    """
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)
    num_samples = 500
    savings_weight = 0.4
    sample_weight = 0.4
    distance_weight = 0.2
    
    savings_matrix = np.zeros_like(distance_matrix)
    for i in range(1, n):
        for j in range(i + 1, n):
            savings_matrix[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]
            savings_matrix[j, i] = savings_matrix[i, j]

    sample_frequency_matrix = np.zeros_like(distance_matrix)
    for _ in range(num_samples):
        route = [0]
        remaining_nodes = set(range(1, n))
        current_capacity = capacity
        
        while remaining_nodes:
            next_node_candidates = sorted(remaining_nodes, key=lambda node: distance_matrix[route[-1]][node])
            
            found_next_node = False
            for next_node in next_node_candidates:
                if demands[next_node] <= current_capacity:
                    route.append(next_node)
                    remaining_nodes.remove(next_node)
                    current_capacity -= demands[next_node]
                    found_next_node = True
                    break

            if not found_next_node:
                route.append(0)
                current_capacity = capacity
            
        route.append(0)

        for i in range(len(route) - 1):
            sample_frequency_matrix[route[i]][route[i+1]] += 1
            sample_frequency_matrix[route[i+1]][route[i]] += 1

    max_savings = np.max(savings_matrix) if np.any(savings_matrix) else 1
    max_frequency = np.max(sample_frequency_matrix) if np.any(sample_frequency_matrix) else 1
    max_distance = np.max(distance_matrix) if np.any(distance_matrix) else 1


    normalized_savings = savings_matrix / max_savings
    normalized_frequency = sample_frequency_matrix / max_frequency
    normalized_distance = (max_distance - distance_matrix) / max_distance 

    heuristics_matrix = savings_weight * normalized_savings + sample_weight * normalized_frequency + distance_weight * normalized_distance

    return heuristics_matrix
