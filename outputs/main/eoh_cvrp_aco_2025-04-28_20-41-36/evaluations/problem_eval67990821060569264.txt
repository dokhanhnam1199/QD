import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm combines a modified savings approach with clustering based on node similarity, iteratively merging nodes within clusters and across clusters based on weighted savings and cluster proximity to build a heuristics matrix.}
    """
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)
    num_clusters = int(np.sqrt(n)) 
    savings_weight = 0.6
    cluster_weight = 0.4

    # Calculate savings matrix
    savings_matrix = np.zeros_like(distance_matrix)
    for i in range(1, n):
        for j in range(i + 1, n):
            savings_matrix[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]
            savings_matrix[j, i] = savings_matrix[i, j]

    # Cluster nodes based on coordinates (k-means) - Simplified version
    clusters = [[] for _ in range(num_clusters)]
    for i in range(1, n):
        cluster_index = i % num_clusters
        clusters[cluster_index].append(i)

    # Calculate cluster proximity matrix (distance between cluster centroids)
    cluster_centroids = []
    for cluster in clusters:
        if cluster:
            centroid_x = np.mean([coordinates[i][0] for i in cluster])
            centroid_y = np.mean([coordinates[i][1] for i in cluster])
            cluster_centroids.append((centroid_x, centroid_y))
        else:
            cluster_centroids.append((0,0)) # avoid empty list problems

    cluster_proximity_matrix = np.zeros((num_clusters, num_clusters))
    for i in range(num_clusters):
        for j in range(i + 1, num_clusters):
            dist_x = cluster_centroids[i][0] - cluster_centroids[j][0]
            dist_y = cluster_centroids[i][1] - cluster_centroids[j][1]
            cluster_proximity_matrix[i, j] = np.sqrt(dist_x**2 + dist_y**2)
            cluster_proximity_matrix[j, i] = cluster_proximity_matrix[i, j]

    # Normalize matrices
    max_savings = np.max(savings_matrix) if np.any(savings_matrix) else 1
    max_proximity = np.max(cluster_proximity_matrix) if np.any(cluster_proximity_matrix) else 1

    normalized_savings = savings_matrix / max_savings
    normalized_proximity = np.zeros_like(distance_matrix)

    for i in range(1, n):
        for j in range(i + 1, n):
            cluster_i = -1
            cluster_j = -1
            for k in range(num_clusters):
                if i in clusters[k]:
                    cluster_i = k
                if j in clusters[k]:
                    cluster_j = k
            if cluster_i != -1 and cluster_j != -1:
                normalized_proximity[i, j] = cluster_proximity_matrix[cluster_i, cluster_j] / max_proximity if max_proximity > 0 else 0
                normalized_proximity[j, i] = normalized_proximity[i, j]

    # Combine savings and cluster proximity
    heuristics_matrix = savings_weight * normalized_savings + cluster_weight * (1 - normalized_proximity)

    return heuristics_matrix
