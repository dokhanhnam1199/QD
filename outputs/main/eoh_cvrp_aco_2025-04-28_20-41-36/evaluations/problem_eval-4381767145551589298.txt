import numpy as np

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm employs an ant colony optimization (ACO) approach, where artificial ants construct routes probabilistically based on pheromone trails and heuristic information (distance), and pheromone is updated based on route quality and feasibility.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    pheromone_matrix = np.ones_like(distance_matrix, dtype=float)
    
    num_ants = 50
    num_iterations = 100
    alpha = 1.0  # Pheromone influence
    beta = 2.0   # Heuristic influence (distance)
    rho = 0.5    # Evaporation rate
    Q = 100.0   # Pheromone deposit constant

    for iteration in range(num_iterations):
        all_routes = []
        all_costs = []

        for ant in range(num_ants):
            unvisited = set(range(1, n))
            current_route = [0]
            current_load = 0
            route_cost = 0

            while unvisited:
                feasible_nodes = [node for node in unvisited if current_load + demands[node] <= capacity]

                if not feasible_nodes:
                    current_route.append(0)
                    all_routes.append(current_route)
                    route_cost += distance_matrix[current_route[-2],0]
                    current_route = [0]
                    current_load = 0
                    feasible_nodes = [node for node in unvisited if current_load + demands[node] <= capacity]
                    if not feasible_nodes:
                        route_cost = float('inf')
                        break

                probabilities = []
                for node in feasible_nodes:
                    pheromone = pheromone_matrix[current_route[-1], node]
                    heuristic = 1.0 / distance_matrix[current_route[-1], node]
                    prob = (pheromone**alpha) * (heuristic**beta)
                    probabilities.append(prob)

                probabilities = np.array(probabilities)
                if np.sum(probabilities) == 0:
                    probabilities = np.ones(len(probabilities)) # Handle zero probabilities
                probabilities /= np.sum(probabilities)

                next_node = np.random.choice(feasible_nodes, p=probabilities)
                route_cost += distance_matrix[current_route[-1], next_node]
                current_route.append(next_node)
                current_load += demands[next_node]
                unvisited.remove(next_node)

            current_route.append(0)
            all_routes.append(current_route)
            route_cost += distance_matrix[current_route[-1],0]
            all_costs.append(route_cost)

        # Update pheromones
        delta_pheromone_matrix = np.zeros_like(distance_matrix, dtype=float)
        for k in range(len(all_routes)):
          if all_costs[k] != float('inf'):
            for route in all_routes[k]:
                for i in range(len(route) - 1):
                    delta_pheromone_matrix[route[i], route[i+1]] += Q / all_costs[k]
                    delta_pheromone_matrix[route[i+1], route[i]] += Q / all_costs[k]
        pheromone_matrix = (1 - rho) * pheromone_matrix + delta_pheromone_matrix
    
    heuristics_matrix = pheromone_matrix
    return heuristics_matrix
