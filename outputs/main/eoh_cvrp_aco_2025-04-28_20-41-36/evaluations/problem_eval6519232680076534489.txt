import numpy as np

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm constructs a heuristic matrix based on savings values, a capacity penalty that scales with distance, and a proximity bonus that is inversely proportional to the square of the distance.}"""
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)

    # Calculate savings values
    savings_matrix = np.zeros_like(distance_matrix)
    for i in range(1, n):
        for j in range(1, n):
            if i != j:
                savings_matrix[i][j] = distance_matrix[0][i] + distance_matrix[0][j] - distance_matrix[i][j]

    # Construct heuristic matrix
    for i in range(1, n):
        for j in range(1, n):
            if i != j:
                # Base heuristic score from savings
                heuristics_matrix[i][j] = savings_matrix[i][j]

                # Capacity penalty: penalize linking nodes that would exceed capacity, scaling with distance
                if demands[i] + demands[j] > capacity:
                    heuristics_matrix[i][j] -= (demands[i] + demands[j] - capacity) * distance_matrix[i][j]

                # Proximity bonus: reward linking nodes that are close to each other, inversely proportional to squared distance
                euclidean_distance = np.sqrt(np.sum((coordinates[i] - coordinates[j])**2))
                heuristics_matrix[i][j] += (np.mean(distance_matrix) / ((euclidean_distance**2) + 1e-6))  # Add a small constant to avoid division by zero

    return heuristics_matrix
