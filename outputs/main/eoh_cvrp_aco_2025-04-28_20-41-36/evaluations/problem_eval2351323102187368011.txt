import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm constructs a heuristic matrix based on node proximity, demand compatibility, and route density, encouraging closer, compatible nodes while penalizing dense connections.}"""
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)

    proximity_matrix = 1 / (distance_matrix + 1e-6)  # Avoid division by zero
    normalized_proximity = proximity_matrix / np.max(proximity_matrix)

    demand_compatibility = np.zeros_like(distance_matrix)
    for i in range(1, n):
        for j in range(1, n):
            if i != j:
                demand_compatibility[i, j] = 1 - abs(demands[i] + demands[j] - capacity) / capacity if demands[i] + demands[j] <= 2 * capacity else -1
            else:
                demand_compatibility[i, j] = -1

    normalized_demand_compatibility = demand_compatibility / (np.max(np.abs(demand_compatibility)) if np.any(demand_compatibility) else 1)

    route_density_penalty = np.zeros_like(distance_matrix)
    for i in range(1, n):
        for j in range(1, n):
            if i != j:
                nodes_within_radius = 0
                radius = distance_matrix[i, j]
                for k in range(1, n):
                    if k != i and k !=j and distance_matrix[i, k] <= radius:
                        nodes_within_radius += 1
                route_density_penalty[i, j] = -nodes_within_radius
            else:
                route_density_penalty[i, j] = 0

    normalized_route_density_penalty = route_density_penalty / (np.max(np.abs(route_density_penalty)) if np.any(route_density_penalty) else 1)

    heuristics_matrix = normalized_proximity + normalized_demand_compatibility + 0.5 * normalized_route_density_penalty

    return heuristics_matrix
