import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm combines clustering and route optimization by first assigning nodes to clusters based on proximity and demand, then constructing and iteratively improving routes within each cluster using a greedy insertion heuristic and a variable neighborhood search strategy, updating a heuristic matrix based on the frequency of edge usage in the improved routes.}"""
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)
    num_clusters = int(np.sqrt(n)) + 1
    num_iterations = 100
    
    # Clustering (similar to algorithm 1)
    clusters = [[] for _ in range(num_clusters)]
    centroids = coordinates[np.random.choice(n, num_clusters, replace=False)]
    
    for _ in range(5):
        clusters = [[] for _ in range(num_clusters)]
        cluster_assignments = []
        for i in range(n):
            distances = np.linalg.norm(coordinates[i] - centroids, axis=1)
            cluster_id = np.argmin(distances)
            clusters[cluster_id].append(i)
            cluster_assignments.append(cluster_id)

        for i in range(num_clusters):
            if clusters[i]:
                centroids[i] = np.mean(coordinates[clusters[i]], axis=0)
    
    # Route construction and improvement within each cluster
    for cluster_id in range(num_clusters):
        cluster_nodes = clusters[cluster_id]
        if not cluster_nodes:
            continue
        
        for _ in range(num_iterations):
            # Greedy route construction
            routes = []
            unvisited = set(cluster_nodes)
            if 0 not in unvisited:
                unvisited.add(0)
            current_route = [0]
            current_load = 0

            while unvisited:
                feasible_nodes = [node for node in unvisited if current_load + demands[node] <= capacity]
                if not feasible_nodes:
                    current_route.append(0)
                    routes.append(current_route)
                    current_route = [0]
                    current_load = 0
                    feasible_nodes = [node for node in unvisited if current_load + demands[node] <= capacity]
                    if not feasible_nodes:
                        break
                
                next_node = min(feasible_nodes, key=lambda node: distance_matrix[current_route[-1], node])
                current_route.append(next_node)
                current_load += demands[next_node]
                unvisited.remove(next_node)
            current_route.append(0)
            routes.append(current_route)

            #Variable Neighborhood Search (VNS) - simplified 2-opt swap
            for route_index in range(len(routes)):
                route = routes[route_index]

                if len(route) <= 3:
                    continue

                i = random.randint(1, len(route) - 2)
                j = random.randint(i + 1, len(route) - 1)

                new_route = route[:i] + route[i:j+1][::-1] + route[j+1:]

                new_route_load = [0] * len(new_route)
                for k in range(1,len(new_route)):
                  if new_route[k] == 0:
                    continue
                  new_route_load[k] = new_route_load[k-1] + demands[new_route[k]]

                is_feasible = True
                max_load = 0
                temp_load = 0
                for k in range(1, len(new_route)):
                  if new_route[k] == 0:
                    max_load = max(max_load, temp_load)
                    temp_load = 0
                    continue
                  temp_load += demands[new_route[k]]
                max_load = max(max_load, temp_load)

                if max_load > capacity:
                    is_feasible = False

                if is_feasible:

                  routes[route_index] = new_route


            #Update heuristics_matrix
            for route in routes:
                for i in range(len(route) - 1):
                    node1 = route[i]
                    node2 = route[i+1]
                    heuristics_matrix[node1, node2] += 1
                    heuristics_matrix[node2, node1] += 1

    heuristics_matrix = heuristics_matrix / (num_iterations * num_clusters) if (num_iterations * num_clusters) > 0 else heuristics_matrix

    return heuristics_matrix
