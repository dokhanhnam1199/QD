import numpy as np

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm calculates a heuristic matrix by combining node proximity, demand compatibility, and angle cost, favoring closer, compatible nodes and penalizing sharp turns.}"""
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)

    proximity_matrix = 1 / (distance_matrix + 1e-6)  # Avoid division by zero
    normalized_proximity = proximity_matrix / np.max(proximity_matrix)

    demand_compatibility = np.zeros_like(distance_matrix)
    for i in range(1, n):
        for j in range(1, n):
            if i != j:
                demand_compatibility[i, j] = 1 - abs(demands[i] + demands[j] - capacity) / capacity if demands[i] + demands[j] <= 2 * capacity else -1
            else:
                demand_compatibility[i, j] = -1

    normalized_demand_compatibility = demand_compatibility / (np.max(np.abs(demand_compatibility)) if np.any(demand_compatibility) else 1)

    angle_cost = np.zeros_like(distance_matrix)
    for i in range(1, n):
        for j in range(1, n):
            if i != j:
                angles = []
                for k in range(1,n):
                    if k != i and k != j:
                        v1 = coordinates[i] - coordinates[k]
                        v2 = coordinates[j] - coordinates[k]
                        
                        norm_v1 = np.linalg.norm(v1)
                        norm_v2 = np.linalg.norm(v2)

                        if norm_v1 > 0 and norm_v2 > 0:
                            dot_product = np.dot(v1, v2)
                            cosine_angle = dot_product / (norm_v1 * norm_v2)
                            angle = np.arccos(np.clip(cosine_angle, -1.0, 1.0))
                            angles.append(angle)
                if angles:
                    angle_cost[i, j] = np.mean(angles) # Average angle. Could also be min or max.
                else:
                    angle_cost[i,j] = 0
            else:
                angle_cost[i, j] = 0

    normalized_angle_cost = angle_cost / (np.max(np.abs(angle_cost)) if np.any(angle_cost) else 1)

    heuristics_matrix = normalized_proximity + normalized_demand_compatibility - 0.5 * normalized_angle_cost

    return heuristics_matrix
