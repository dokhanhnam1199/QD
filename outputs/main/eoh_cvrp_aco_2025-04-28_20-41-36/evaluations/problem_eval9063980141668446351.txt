import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm iteratively perturbs a set of initial routes, evaluating and accepting perturbations based on a probabilistic acceptance criterion guided by route cost and heuristics from demand similarity and route coherence.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    num_vehicles = 5
    num_iterations = 100
    temperature = 10.0
    cooling_rate = 0.95
    alpha = 0.7

    def create_initial_routes():
        unassigned_customers = set(range(1, n))
        routes = []
        for _ in range(num_vehicles):
            route = [0]
            current_load = 0
            while unassigned_customers:
                feasible_customers = [c for c in unassigned_customers if current_load + demands[c] <= capacity]
                if not feasible_customers:
                    break
                next_customer = random.choice(feasible_customers)
                route.append(next_customer)
                current_load += demands[next_customer]
                unassigned_customers.remove(next_customer)
            route.append(0)
            routes.append(route)
        
        remaining_customers = list(unassigned_customers)
        idx = 0
        while remaining_customers:
            routes[idx % num_vehicles].insert(len(routes[idx % num_vehicles]) - 1, remaining_customers.pop(0))
            idx += 1
            
        return routes

    def calculate_route_cost(route):
        cost = 0
        for i in range(len(route) - 1):
            cost += distance_matrix[route[i], route[i+1]]
        return cost

    def calculate_total_cost(routes):
        total_cost = 0
        for route in routes:
            total_cost += calculate_route_cost(route)
        return total_cost
    
    def demand_similarity(i, j):
        return 1 / (1 + abs(demands[i] - demands[j]))
    
    def route_coherence(route, i, j):
        if i in route and j in route:
            i_idx = route.index(i)
            j_idx = route.index(j)
            if abs(i_idx - j_idx) <= 2:
                return 1
        return 0


    initial_routes = create_initial_routes()
    best_routes = initial_routes
    best_cost = calculate_total_cost(initial_routes)

    for _ in range(num_iterations):
        new_routes = [route[:] for route in best_routes]  # Deep copy
        
        # Choose a random route to perturb
        route_index = random.randint(0, len(new_routes) - 1)
        route_to_perturb = new_routes[route_index]

        # Choose two random customers in the route
        if len(route_to_perturb) > 2:
            idx1 = random.randint(1, len(route_to_perturb) - 2)
            idx2 = random.randint(1, len(route_to_perturb) - 2)
            
            # Swap the two customers
            route_to_perturb[idx1], route_to_perturb[idx2] = route_to_perturb[idx2], route_to_perturb[idx1]
        
        new_cost = calculate_total_cost(new_routes)
        
        # Acceptance criterion (Metropolis)
        cost_delta = new_cost - best_cost
        if cost_delta < 0:
            best_routes = new_routes
            best_cost = new_cost
        else:
            acceptance_probability = np.exp(-cost_delta / temperature)
            if random.random() < acceptance_probability:
                best_routes = new_routes
                best_cost = new_cost
        
        temperature *= cooling_rate

    for route in best_routes:
        for i in range(len(route) - 1):
            heuristics_matrix[route[i], route[i+1]] += 1
            heuristics_matrix[route[i+1], route[i]] += 1

    # Incorporate demand similarity
    for i in range(1, n):
        for j in range(i + 1, n):
            similarity = demand_similarity(i, j)
            heuristics_matrix[i, j] += alpha * similarity
            heuristics_matrix[j, i] += alpha * similarity

    return heuristics_matrix
