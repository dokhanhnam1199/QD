import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm samples a large number of random routes respecting capacity constraints, evaluates the quality of each route by its total distance, and then averages the occurrence of each edge across the sampled routes weighted by the inverse of the route's distance to generate a heuristic matrix.}
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros((n, n))
    num_samples = 1000

    for _ in range(num_samples):
        # Generate a random route
        unvisited = list(range(1, n))
        current_node = 0
        route = [0]
        current_capacity = capacity
        
        while unvisited:
            # Find feasible next nodes
            feasible_nodes = [node for node in unvisited if demands[node] <= current_capacity]

            if not feasible_nodes:
                route.append(0)  # Return to depot
                current_capacity = capacity
                feasible_nodes = [node for node in unvisited if demands[node] <= current_capacity]
                if not feasible_nodes:
                    break # if there isn't feasible node, break

            if feasible_nodes:
                next_node = random.choice(feasible_nodes)
                route.append(next_node)
                unvisited.remove(next_node)
                current_capacity -= demands[next_node]

        route.append(0)  # Return to depot

        # Calculate route distance
        route_distance = 0
        for i in range(len(route) - 1):
            route_distance += distance_matrix[route[i], route[i+1]]
        
        # Update heuristics matrix
        if route_distance > 0:
            weight = 1.0 / route_distance  # Inverse distance as weight
        else:
            weight = 0.0

        for i in range(len(route) - 1):
            u = route[i]
            v = route[i+1]
            heuristics_matrix[u, v] += weight
            heuristics_matrix[v, u] += weight  # Assuming symmetric distance matrix

    return heuristics_matrix
