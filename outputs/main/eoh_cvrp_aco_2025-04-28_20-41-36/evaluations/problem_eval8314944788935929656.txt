import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm constructs a randomized nearest neighbor tour, applies a stochastic 2-opt local search to improve it, and uses the edges present in the locally optimized tour to generate the heuristics matrix.}"""
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)

    # Construct randomized nearest neighbor tour
    current_node = 0
    unvisited_nodes = set(range(1, n))
    tour = [0]
    current_capacity = capacity

    while unvisited_nodes:
        feasible_nodes = {
            node for node in unvisited_nodes if demands[node] <= current_capacity
        }

        if not feasible_nodes:
            tour.append(0)
            current_capacity = capacity
            current_node = 0
            feasible_nodes = {
                node for node in unvisited_nodes if demands[node] <= current_capacity
            }
            if not feasible_nodes:
                break

        # Randomized nearest neighbor selection
        distances = {node: distance_matrix[current_node][node] for node in feasible_nodes}
        min_distance = min(distances.values())
        candidates = [node for node, dist in distances.items() if dist <= min_distance * 1.2]  # Explore nodes within 20% of the minimum distance
        next_node = random.choice(candidates)

        tour.append(next_node)
        unvisited_nodes.remove(next_node)
        current_capacity -= demands[next_node]
        current_node = next_node
    tour.append(0)

    # Stochastic 2-opt local search
    def two_opt_swap(route, i, k):
        new_route = route[:i] + route[i:k+1][::-1] + route[k+1:]
        return new_route

    def calculate_route_distance(route):
        total_distance = 0
        for i in range(len(route) - 1):
            total_distance += distance_matrix[route[i]][route[i+1]]
        return total_distance
    
    num_iterations = 500  # Limit the number of iterations for stochastic search
    for _ in range(num_iterations):
        i = random.randint(1, len(tour) - 2)
        k = random.randint(i + 1, len(tour) - 1)
        new_tour = two_opt_swap(tour, i, k)
        if calculate_route_distance(new_tour) < calculate_route_distance(tour):
            tour = new_tour

    # Update heuristics matrix
    for i in range(len(tour) - 1):
        heuristics_matrix[tour[i], tour[i+1]] = 1
        heuristics_matrix[tour[i+1], tour[i]] = 1

    return heuristics_matrix
