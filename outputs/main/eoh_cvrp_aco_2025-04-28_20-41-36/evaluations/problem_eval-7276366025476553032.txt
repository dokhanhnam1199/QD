import numpy as np

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm samples multiple random routes satisfying capacity constraints,
    evaluates the frequency of each edge's appearance in those routes,
    and uses this frequency to construct a heuristics matrix.}
    """
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)
    num_samples = 1000

    for _ in range(num_samples):
        route = [0]
        remaining_nodes = set(range(1, n))
        current_capacity = capacity
        
        while remaining_nodes:
            # Sort the nodes according to their distance from the current node.
            next_node_candidates = sorted(remaining_nodes, key=lambda node: distance_matrix[route[-1]][node])
            
            # Find the first node that satisfies the capacity constraint.
            found_next_node = False
            for next_node in next_node_candidates:
                if demands[next_node] <= current_capacity:
                    route.append(next_node)
                    remaining_nodes.remove(next_node)
                    current_capacity -= demands[next_node]
                    found_next_node = True
                    break

            # If no node can be added, return to the depot
            if not found_next_node:
                route.append(0)
                current_capacity = capacity
            
        route.append(0) # Return to depot

        # Update heuristics matrix
        for i in range(len(route) - 1):
            heuristics_matrix[route[i]][route[i+1]] += 1
            heuristics_matrix[route[i+1]][route[i]] += 1

    return heuristics_matrix
