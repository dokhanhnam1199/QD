import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm refines the savings approach by incorporating a penalty for exceeding capacity and rewards connections to nodes based on a weighted combination of savings, capacity utilization, and closeness to the depot.}
    """
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)
    savings_matrix = np.zeros_like(distance_matrix)

    for i in range(1, n):
        for j in range(i + 1, n):
            savings_matrix[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]
            savings_matrix[j, i] = savings_matrix[i, j]

    # Capacity awareness
    capacity_term = np.zeros_like(distance_matrix)
    for i in range(1, n):
        for j in range(1, n):
            if i != j:
                if demands[i] + demands[j] > capacity:
                    capacity_term[i, j] = -1e9  # Huge penalty for exceeding capacity
                else:
                    capacity_term[i, j] = (capacity - (demands[i] + demands[j])) / capacity
            else:
                capacity_term[i, j] = -1e9

    # Closeness to depot
    depot_proximity_term = np.zeros_like(distance_matrix)
    for i in range(1, n):
        for j in range(1, n):
            if i != j:
                depot_proximity_term[i, j] = 1 / (distance_matrix[0, i] + distance_matrix[0, j] + 1e-6)
            else:
                depot_proximity_term[i,j] = -1e9

    # Normalize terms
    normalized_savings = savings_matrix / (np.max(savings_matrix) if np.any(savings_matrix) else 1)
    normalized_capacity = capacity_term / (np.max(capacity_term) if np.any(capacity_term) else 1)
    normalized_proximity = depot_proximity_term / (np.max(depot_proximity_term) if np.any(depot_proximity_term) else 1)
    
    # Weighted heuristic matrix
    alpha = 0.5
    beta = 0.3
    gamma = 0.2
    heuristics_matrix = alpha * normalized_savings + beta * normalized_capacity + gamma * normalized_proximity

    return heuristics_matrix
