import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm constructs routes by iteratively inserting unvisited nodes into the best possible position within existing routes based on minimizing insertion cost, with a simulated annealing-like acceptance probability to escape local optima, and updates edge frequencies based on route quality.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    num_iterations = 1000
    initial_temperature = 100.0
    cooling_rate = 0.99

    for iteration in range(num_iterations):
        temperature = initial_temperature * (cooling_rate ** iteration)
        
        unvisited = set(range(1, n))
        all_routes = [[0, 0]]  # Initialize with a single empty route (depot to depot)

        while unvisited:
            best_insertion = None
            best_insertion_cost = float('inf')
            
            for node_to_insert in list(unvisited):
                for route_index, route in enumerate(all_routes):
                    current_load = sum(demands[n] for n in route[1:-1]) # Exclude depot's from calculation of current load
                    if current_load + demands[node_to_insert] <= capacity:
                        for i in range(len(route) - 1):
                            insertion_cost = distance_matrix[route[i], node_to_insert] + distance_matrix[node_to_insert, route[i+1]] - distance_matrix[route[i], route[i+1]]
                            if insertion_cost < best_insertion_cost:
                                best_insertion_cost = insertion_cost
                                best_insertion = (node_to_insert, route_index, i)

            if best_insertion:
                node_to_insert, route_index, insert_position = best_insertion
                
                # Simulated annealing acceptance criterion
                if best_insertion_cost < 0:
                    accept = True
                else:
                    acceptance_probability = np.exp(-best_insertion_cost / temperature)
                    accept = random.random() < acceptance_probability

                if accept:
                    all_routes[route_index].insert(insert_position + 1, node_to_insert)
                    unvisited.remove(node_to_insert)
                else:
                    # If no good insertion found, start a new route (depot, node, depot)
                    new_route = [0, unvisited.pop(), 0]
                    all_routes.append(new_route)
            else: # If all nodes have demand more than vehicle capacity remaining
                break
        
        # Calculate route length and weight
        total_route_length = 0
        for route in all_routes:
          route_length = sum(distance_matrix[route[i], route[i+1]] for i in range(len(route) - 1)) if len(route) > 1 else 0
          total_route_length += route_length

        if total_route_length > 0:
            weight = 1.0 / total_route_length
        else:
            weight = 0.0
        
        # Update heuristics matrix
        for route in all_routes:
            for i in range(len(route) - 1):
                heuristics_matrix[route[i], route[i+1]] += weight
                heuristics_matrix[route[i+1], route[i]] += weight

    return heuristics_matrix
