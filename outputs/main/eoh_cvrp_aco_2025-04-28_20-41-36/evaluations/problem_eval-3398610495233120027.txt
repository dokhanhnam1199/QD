import numpy as np

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm samples multiple random routes satisfying capacity constraints,
    then averages the edge frequencies across all routes to generate a heuristic matrix.}
    """
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)
    num_samples = 1000

    for _ in range(num_samples):
        route = [0]
        remaining_nodes = set(range(1, n))
        current_capacity = capacity

        while remaining_nodes:
            feasible_nodes = {
                node for node in remaining_nodes if demands[node] <= current_capacity
            }

            if not feasible_nodes:
                route.append(0)
                current_capacity = capacity
                feasible_nodes = {
                    node for node in remaining_nodes if demands[node] <= current_capacity
                }
                if not feasible_nodes:
                  break

            next_node = min(
                feasible_nodes, key=lambda node: distance_matrix[route[-1]][node]
            )

            route.append(next_node)
            remaining_nodes.remove(next_node)
            current_capacity -= demands[next_node]

        route.append(0)
        for i in range(len(route) - 1):
            heuristics_matrix[route[i]][route[i+1]] += 1
            heuristics_matrix[route[i+1]][route[i]] += 1
    
    heuristics_matrix = heuristics_matrix / num_samples
    return heuristics_matrix
