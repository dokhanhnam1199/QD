import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm uses a greedy randomized adaptive search procedure (GRASP) to iteratively construct solutions, incorporating a restricted candidate list based on distance and demand, and updating a pheromone matrix based on solution quality.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    num_iterations = 1000
    alpha = 0.2  # Parameter for restricted candidate list size
    pheromone_decay = 0.1
    
    pheromone_matrix = np.ones_like(distance_matrix)  # Initialize pheromone matrix

    for iteration in range(num_iterations):
        unvisited = set(range(1, n))
        current_route = [0]
        current_load = 0
        all_routes = []

        while unvisited:
            feasible_nodes = [node for node in unvisited if current_load + demands[node] <= capacity]

            if not feasible_nodes:
                current_route.append(0)
                all_routes.append(current_route)
                current_route = [0]
                current_load = 0
                feasible_nodes = [node for node in unvisited if current_load + demands[node] <= capacity]
                if not feasible_nodes:
                    break

            if feasible_nodes:
                # Restricted Candidate List (RCL)
                distances = {node: distance_matrix[current_route[-1], node] for node in feasible_nodes}
                sorted_distances = sorted(distances.items(), key=lambda item: item[1])
                rcl_size = max(1, int(alpha * len(feasible_nodes)))
                rcl = sorted_distances[:rcl_size]

                # Select a node from the RCL probabilistically based on pheromone
                probabilities = [pheromone_matrix[current_route[-1], node] for node, dist in rcl]
                probabilities = np.array(probabilities)
                probabilities = probabilities / np.sum(probabilities)

                next_node = random.choices([node for node, dist in rcl], weights=probabilities)[0]

                current_route.append(next_node)
                current_load += demands[next_node]
                unvisited.remove(next_node)

        current_route.append(0)
        all_routes.append(current_route)

        route_length = sum(distance_matrix[all_routes[-1][i], all_routes[-1][i+1]] for i in range(len(all_routes[-1]) - 1)) if len(all_routes) > 0 and len(all_routes[-1]) > 1 else 0

        if route_length > 0:
            weight = 1.0 / route_length
        else:
            weight = 0.0

        # Update pheromone matrix
        for route in all_routes:
            for i in range(len(route) - 1):
                pheromone_matrix[route[i], route[i+1]] = (1 - pheromone_decay) * pheromone_matrix[route[i], route[i+1]] + pheromone_decay * weight
                pheromone_matrix[route[i+1], route[i]] = (1 - pheromone_decay) * pheromone_matrix[route[i+1], route[i]] + pheromone_decay * weight
                heuristics_matrix[route[i], route[i+1]] += weight
                heuristics_matrix[route[i+1], route[i]] += weight
    
    return heuristics_matrix
