import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm iteratively refines routes by probabilistically selecting and merging promising route segments based on a combination of distance, capacity, and a learned edge preference matrix.}"""
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)
    num_iterations = 300

    # Initialize routes randomly
    routes = []
    unvisited = set(range(1, n))
    while unvisited:
        route = [0]
        current_capacity = capacity
        
        while unvisited and current_capacity >= min(demands[node] for node in unvisited):
            possible_nodes = [node for node in unvisited if demands[node] <= current_capacity]
            if not possible_nodes:
                break
            next_node = random.choice(possible_nodes)
            route.append(next_node)
            unvisited.remove(next_node)
            current_capacity -= demands[next_node]
        route.append(0)
        routes.append(route)

    edge_preference = np.ones_like(distance_matrix)

    for iteration in range(num_iterations):
        # Select two routes probabilistically
        if len(routes) < 2:
            break
        route_index1 = random.randint(0, len(routes) - 1)
        route_index2 = random.randint(0, len(routes) - 1)
        while route_index2 == route_index1:
            route_index2 = random.randint(0, len(routes) - 1)

        route1 = routes[route_index1]
        route2 = routes[route_index2]

        # Select merge points within the routes
        merge_point1 = random.randint(0, len(route1) - 1)
        merge_point2 = random.randint(0, len(route2) - 1)

        # Check capacity constraint
        route1_demand = sum(demands[node] for node in route1[1:-1])
        route2_demand = sum(demands[node] for node in route2[1:-1])
        if route1_demand + route2_demand > capacity:
            continue

        # Calculate merge cost
        cost_increase = distance_matrix[route1[merge_point1]][route2[merge_point2]] - distance_matrix[route1[merge_point1]][0] - distance_matrix[route2[merge_point2]][0]

        # Apply edge preference
        merge_probability = edge_preference[route1[merge_point1], route2[merge_point2]] * np.exp(-cost_increase)
        if random.random() < 0.5: #merge_probability
            # Merge the routes
            new_route = route1[:merge_point1] + route2[merge_point2:]
            routes.append(new_route)
            routes.pop(route_index1)
            if route_index2 > route_index1:
              routes.pop(route_index2-1)
            else:
              routes.pop(route_index2)

            # Update edge preference
            for i in range(len(new_route) - 1):
                edge_preference[new_route[i], new_route[i+1]] += 0.1
                edge_preference[new_route[i+1], new_route[i]] += 0.1
        else:
            edge_preference[route1[merge_point1], route2[merge_point2]] *= 0.9

    # Update heuristics matrix based on final routes
    for route in routes:
        for i in range(len(route) - 1):
            heuristics_matrix[route[i], route[i+1]] += 1
            heuristics_matrix[route[i+1], route[i]] += 1

    return heuristics_matrix
