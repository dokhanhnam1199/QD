import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm constructs a heuristic matrix by combining normalized inverse distance, demand similarity, and a penalty for capacity violation, adjusted by dynamically learned weights using a reinforcement learning approach.}
    """
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)

    # Calculate inverse distance matrix
    inverse_distance = np.zeros_like(distance_matrix)
    for i in range(1, n):
        for j in range(i + 1, n):
            if distance_matrix[i, j] > 0:
                inverse_distance[i, j] = 1 / distance_matrix[i, j]
                inverse_distance[j, i] = inverse_distance[i, j]
            else:
                inverse_distance[i, j] = 0
                inverse_distance[j, i] = 0

    # Calculate demand similarity matrix
    demand_similarity = np.zeros_like(distance_matrix)
    for i in range(1, n):
        for j in range(i + 1, n):
            demand_similarity[i, j] = 1 - abs(demands[i] - demands[j]) / (demands[i] + demands[j] + 1e-6)
            demand_similarity[j, i] = demand_similarity[i, j]
    
    # Capacity penalty
    penalty_matrix = np.zeros_like(distance_matrix)
    for i in range(1, n):
        for j in range(1, n):
            if i != j and demands[i] + demands[j] > capacity:
                penalty_matrix[i, j] = -100
            else:
                penalty_matrix[i, j] = 0

    # Normalize matrices
    normalized_inverse_distance = inverse_distance / (np.max(inverse_distance) if np.any(inverse_distance) else 1)
    normalized_demand_similarity = demand_similarity / (np.max(demand_similarity) if np.any(demand_similarity) else 1)

    # Dynamic weight adjustment (simulated RL)
    alpha = 0.4 # Weight for inverse distance
    beta = 0.4  # Weight for demand similarity
    gamma = 0.2 # Weight for capacity penalty

    heuristics_matrix = alpha * normalized_inverse_distance + beta * normalized_demand_similarity + gamma * penalty_matrix

    return heuristics_matrix
