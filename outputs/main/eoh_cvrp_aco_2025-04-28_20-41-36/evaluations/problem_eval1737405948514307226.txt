import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm adaptively adjusts edge weights based on distance, demand, and route feasibility, learning from successful and unsuccessful route combinations, prioritizing routes with fewer vehicles and shorter distances.}"""
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)
    edge_weights = np.ones_like(distance_matrix)  # Initialize edge weights
    learning_rate = 0.1
    vehicle_penalty = 0.5

    for i in range(1, n):
        for j in range(i + 1, n):
            # Initial heuristic based on distance and demand
            heuristics_matrix[i, j] = (1 / distance_matrix[i, j]) * (1 / (demands[i] + demands[j] + 1e-6)) * edge_weights[i, j]
            heuristics_matrix[j, i] = heuristics_matrix[i, j]
            
    # Simulate route construction and update edge weights
    num_simulations = 100
    for _ in range(num_simulations):
        current_route_demand = 0
        current_node = 0
        route = [0]
        routes = []
        num_vehicles = 1
        total_distance = 0
        
        while len(route) < n:
          
            eligible_nodes = [node for node in range(1, n) if node not in route and current_route_demand + demands[node] <= capacity]
            
            if not eligible_nodes:
              if current_node != 0:
                route.append(0)
                routes.append(route)
                num_vehicles += 1
                current_route_demand = 0
                current_node = 0
                route = [0]
                eligible_nodes = [node for node in range(1, n) if node not in route and current_route_demand + demands[node] <= capacity]
              else:
                break

            if not eligible_nodes:
              break
            
            probabilities = [heuristics_matrix[current_node, node] for node in eligible_nodes]
            probabilities = np.exp(probabilities) / np.sum(np.exp(probabilities))
            
            next_node = random.choices(eligible_nodes, probabilities)[0]
            
            total_distance += distance_matrix[current_node, next_node]
            route.append(next_node)
            current_route_demand += demands[next_node]
            current_node = next_node
        
        if len(route) > 1:
            routes.append(route)

        if len(set([node for sublist in routes for node in sublist])) == n:
            # Reward edges in successful route
            reward = 1 - vehicle_penalty * (num_vehicles - 1) / (n-1) # Fewer vehicles is better
            reward = max(0, reward)

            for sub_route in routes:
              for i in range(len(sub_route) - 1):
                  edge_weights[sub_route[i], sub_route[i+1]] += learning_rate * reward
                  edge_weights[sub_route[i+1], sub_route[i]] += learning_rate * reward
        else:
            # Penalize edges in unsuccessful route
            penalty = 1

            if len(routes) > 0:
              for sub_route in routes:
                for i in range(len(sub_route) - 1):
                    edge_weights[sub_route[i], sub_route[i+1]] -= learning_rate * penalty
                    edge_weights[sub_route[i+1], sub_route[i]] -= learning_rate * penalty

    # Update heuristic matrix based on learned edge weights
    for i in range(1, n):
        for j in range(i + 1, n):
            heuristics_matrix[i, j] = (1 / distance_matrix[i, j]) * (1 / (demands[i] + demands[j] + 1e-6)) * edge_weights[i, j]
            heuristics_matrix[j, i] = heuristics_matrix[i, j]

    return heuristics_matrix
