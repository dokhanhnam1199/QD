import numpy as np

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm samples a set of random routes, evaluates their feasibility and cost, and updates a heuristic matrix based on the frequency with which each edge appears in feasible, low-cost routes.}
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros((n, n))
    num_samples = 1000
    alpha = 0.1  # Weight for cost when updating heuristic

    for _ in range(num_samples):
        # 1. Generate a random route (permutation of nodes excluding the depot)
        route = np.random.permutation(range(1, n))
        
        # 2. Split the route into feasible sub-routes based on capacity
        sub_routes = []
        current_route = []
        current_demand = 0
        
        for node in route:
            if current_demand + demands[node] <= capacity:
                current_route.append(node)
                current_demand += demands[node]
            else:
                sub_routes.append(current_route)
                current_route = [node]
                current_demand = demands[node]
        
        if current_route:
            sub_routes.append(current_route)

        # 3. Calculate the cost of the route
        total_cost = 0
        is_feasible = True
        for sub_route in sub_routes:
            sub_route_cost = distance_matrix[0, sub_route[0]]  # From depot to first node
            for i in range(len(sub_route) - 1):
                sub_route_cost += distance_matrix[sub_route[i], sub_route[i+1]]
            sub_route_cost += distance_matrix[sub_route[-1], 0]  # From last node to depot
            total_cost += sub_route_cost
            
            sub_route_demand = sum([demands[node] for node in sub_route])
            if sub_route_demand > capacity:
                is_feasible = False
                break


        # 4. Update the heuristic matrix based on cost and feasibility
        if is_feasible:
            # Scale the cost to a range [0, 1] (higher costs = smaller updates)
            normalized_cost = 1 / (1 + alpha * total_cost)  # Add 1 to avoid division by zero
            
            for sub_route in sub_routes:
                # Depot to first node
                heuristics_matrix[0, sub_route[0]] += normalized_cost
                heuristics_matrix[sub_route[0], 0] += normalized_cost

                # Between nodes in the sub-route
                for i in range(len(sub_route) - 1):
                    heuristics_matrix[sub_route[i], sub_route[i+1]] += normalized_cost
                    heuristics_matrix[sub_route[i+1], sub_route[i]] += normalized_cost  # Symmetry

                # Last node to depot
                heuristics_matrix[sub_route[-1], 0] += normalized_cost
                heuristics_matrix[0, sub_route[-1]] += normalized_cost


    return heuristics_matrix
