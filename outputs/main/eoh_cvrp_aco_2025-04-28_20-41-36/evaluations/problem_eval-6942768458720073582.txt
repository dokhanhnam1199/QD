import numpy as np

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm iteratively constructs routes by selecting the nearest feasible node based on a probability distribution biased by distance and demand, accumulating edge frequencies to build a heuristic matrix.}"""
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)
    num_samples = 1000

    for _ in range(num_samples):
        route = [0]
        remaining_nodes = set(range(1, n))
        current_capacity = capacity

        while remaining_nodes:
            feasible_nodes = {
                node for node in remaining_nodes if demands[node] <= current_capacity
            }

            if not feasible_nodes:
                route.append(0)
                current_capacity = capacity
                feasible_nodes = {
                    node for node in remaining_nodes if demands[node] <= current_capacity
                }
                if not feasible_nodes:
                    break

            # Calculate probabilities based on distance and demand
            probabilities = []
            for node in feasible_nodes:
                distance = distance_matrix[route[-1]][node]
                demand = demands[node]
                probabilities.append((node, 1 / (distance * demand)))

            # Normalize probabilities
            total_probability = sum(prob[1] for prob in probabilities)
            if total_probability == 0:
                #Handle edge case where all probabilities are zero, select node randomly.
                next_node = list(feasible_nodes)[0]
            else:

                normalized_probabilities = [(node, prob / total_probability) for node, prob in probabilities]

                # Select next node based on probability distribution
                next_node = np.random.choice([node for node, prob in normalized_probabilities], p=[prob for node, prob in normalized_probabilities])

            route.append(next_node)
            remaining_nodes.remove(next_node)
            current_capacity -= demands[next_node]

        route.append(0)
        for i in range(len(route) - 1):
            heuristics_matrix[route[i]][route[i+1]] += 1
            heuristics_matrix[route[i+1]][route[i]] += 1

    heuristics_matrix = heuristics_matrix / num_samples
    return heuristics_matrix
