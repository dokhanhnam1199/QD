import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm emphasizes cost savings while balancing demand-distance ratio and applying a more nuanced penalty based on proximity to capacity limits, encouraging efficient route construction.}
    """
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)
    savings_matrix = np.zeros_like(distance_matrix)

    for i in range(1, n):
        for j in range(i + 1, n):
            savings_matrix[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]
            savings_matrix[j, i] = savings_matrix[i, j]

    demand_distance_ratio = np.zeros_like(distance_matrix)
    for i in range(1, n):
        for j in range(1, n):
            if i != j:
                demand_distance_ratio[i, j] = (demands[i] + demands[j]) / distance_matrix[i, j]
            else:
                demand_distance_ratio[i, j] = 0
                
    penalty_matrix = np.zeros_like(distance_matrix)
    for i in range(1, n):
      for j in range(1, n):
        if i!=j:
          combined_demand = demands[i] + demands[j]
          if combined_demand > capacity:
            penalty_amount = -10
          elif combined_demand > 0.8 * capacity:
            penalty_amount = -5  # Moderate penalty as we approach capacity
          else:
            penalty_amount = 0
          penalty_matrix[i, j] = penalty_amount
          penalty_matrix[j, i] = penalty_amount
        else:
          penalty_matrix[i,j] = -10


    normalized_savings = savings_matrix / (np.max(savings_matrix) if np.any(savings_matrix) else 1)
    normalized_demand_distance = demand_distance_ratio / (np.max(demand_distance_ratio) if np.any(demand_distance_ratio) else 1)

    heuristics_matrix = normalized_savings + 0.5 * normalized_demand_distance + penalty_matrix #Increased weight on savings, reduced on demand_distance

    return heuristics_matrix
