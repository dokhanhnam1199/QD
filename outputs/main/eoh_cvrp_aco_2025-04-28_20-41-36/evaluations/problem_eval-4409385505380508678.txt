import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm constructs initial routes randomly, then iteratively refines them by swapping customers between routes based on cost reduction and a penalty for capacity violation, guided by a temperature parameter that decreases over time to control exploration vs exploitation.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    num_vehicles = 5
    num_iterations = 100
    temperature = 100
    cooling_rate = 0.95

    def create_initial_routes():
        unassigned_customers = list(range(1, n))
        random.shuffle(unassigned_customers)
        routes = [[] for _ in range(num_vehicles)]
        
        idx = 0
        for customer in unassigned_customers:
            routes[idx % num_vehicles].append(customer)
            idx += 1
        
        routes = [[0] + route + [0] for route in routes]
        return routes

    def calculate_route_cost(route):
        cost = 0
        for i in range(len(route) - 1):
            cost += distance_matrix[route[i], route[i+1]]
        return cost

    def calculate_total_cost(routes):
        total_cost = 0
        for route in routes:
            total_cost += calculate_route_cost(route)
        return total_cost
    
    def calculate_capacity_penalty(routes, capacity, demands):
        penalty = 0
        for route in routes:
            load = sum(demands[c] for c in route[1:-1])
            if load > capacity:
                penalty += (load - capacity) * 100  # Adjust penalty factor as needed
        return penalty

    current_routes = create_initial_routes()
    best_routes = [route[:] for route in current_routes]
    best_cost = calculate_total_cost(current_routes) + calculate_capacity_penalty(current_routes, capacity, demands)

    for _ in range(num_iterations):
        route1_idx = random.randint(0, num_vehicles - 1)
        route2_idx = random.randint(0, num_vehicles - 1)
        while len(current_routes[route1_idx]) <= 2 or len(current_routes[route2_idx]) <= 2 or route1_idx == route2_idx:
            route1_idx = random.randint(0, num_vehicles - 1)
            route2_idx = random.randint(0, num_vehicles - 1)
        
        customer1_idx = random.randint(1, len(current_routes[route1_idx]) - 2)
        customer2_idx = random.randint(1, len(current_routes[route2_idx]) - 2)
        
        customer1 = current_routes[route1_idx][customer1_idx]
        customer2 = current_routes[route2_idx][customer2_idx]
        
        new_routes = [route[:] for route in current_routes]
        new_routes[route1_idx][customer1_idx] = customer2
        new_routes[route2_idx][customer2_idx] = customer1
        
        current_cost = calculate_total_cost(current_routes) + calculate_capacity_penalty(current_routes, capacity, demands)
        new_cost = calculate_total_cost(new_routes) + calculate_capacity_penalty(new_routes, capacity, demands)
        cost_diff = new_cost - current_cost
        
        if cost_diff < 0 or random.random() < np.exp(-cost_diff / temperature):
            current_routes = new_routes
            if new_cost < best_cost:
                best_cost = new_cost
                best_routes = [route[:] for route in current_routes]

        temperature *= cooling_rate

    for route in best_routes:
        for i in range(len(route) - 1):
            heuristics_matrix[route[i], route[i+1]] += 1
            heuristics_matrix[route[i+1], route[i]] += 1

    return heuristics_matrix
