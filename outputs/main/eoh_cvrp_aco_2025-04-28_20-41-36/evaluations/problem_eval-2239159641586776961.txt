import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm constructs routes by iteratively inserting the most cost-effective unvisited node into the best possible position within existing routes, considering both distance and capacity constraints.}"""
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)
    routes = []
    unvisited = set(range(1, n))

    while unvisited:
        if not routes:
            # Create initial route from depot
            best_node = -1
            best_cost = float('inf')
            for node in unvisited:
                if demands[node] <= capacity:
                    cost = distance_matrix[0, node]
                    if cost < best_cost:
                        best_cost = cost
                        best_node = node

            if best_node == -1:
                break

            routes.append([0, best_node, 0])
            unvisited.remove(best_node)

        else:
            # Insert best node into best route position
            best_node_insert = -1
            best_route_insert = -1
            best_position_insert = -1
            best_insertion_cost = float('inf')

            for node in unvisited:
                for r_idx, route in enumerate(routes):
                    current_load = sum(demands[v] for v in route[1:-1])
                    if current_load + demands[node] <= capacity:
                        for pos in range(1, len(route)):
                            cost = distance_matrix[route[pos-1], node] + distance_matrix[node, route[pos]] - distance_matrix[route[pos-1], route[pos]]
                            if cost < best_insertion_cost:
                                best_insertion_cost = cost
                                best_node_insert = node
                                best_route_insert = r_idx
                                best_position_insert = pos

            if best_node_insert == -1:
                break

            routes[best_route_insert] = routes[best_route_insert][:best_position_insert] + [best_node_insert] + routes[best_route_insert][best_position_insert:]
            unvisited.remove(best_node_insert)

    # Update heuristics matrix based on routes
    for route in routes:
        for i in range(len(route) - 1):
            heuristics_matrix[route[i], route[i+1]] += 1
            heuristics_matrix[route[i+1], route[i]] += 1

    return heuristics_matrix
