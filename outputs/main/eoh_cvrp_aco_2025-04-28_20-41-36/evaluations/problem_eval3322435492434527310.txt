import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm combines adaptive large neighborhood search (ALNS) principles with route-based perturbation and a heuristic score based on distance, demand, and capacity to iteratively improve route quality.}"""
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)

    def initial_solution():
        unvisited = set(range(1, n))
        routes = []
        current_route = [0]
        current_load = 0

        while unvisited:
            best_node = None
            best_score = -np.inf

            for node in unvisited:
                if current_load + demands[node] <= capacity:
                    score = (1 / distance_matrix[current_route[-1], node]) * (1 / demands[node]) if distance_matrix[current_route[-1], node] > 0 else np.inf
                    if score > best_score:
                        best_score = score
                        best_node = node

            if best_node is not None:
                current_route.append(best_node)
                current_load += demands[best_node]
                unvisited.remove(best_node)
            else:
                current_route.append(0)
                routes.append(current_route)
                current_route = [0]
                current_load = 0

        current_route.append(0)
        routes.append(current_route)
        return routes

    def route_length(route):
        length = 0
        for i in range(len(route) - 1):
            length += distance_matrix[route[i], route[i+1]]
        return length

    def calculate_heuristics_matrix(routes):
        heuristics_matrix = np.zeros_like(distance_matrix)
        for route in routes:
            for i in range(len(route) - 1):
                node1 = route[i]
                node2 = route[i+1]
                heuristics_matrix[node1, node2] = 1 / distance_matrix[node1, node2] if distance_matrix[node1, node2] > 0 else 1
                heuristics_matrix[node2, node1] = 1 / distance_matrix[node2, node1] if distance_matrix[node2, node1] > 0 else 1
        return heuristics_matrix

    def perturb_solution(routes):
        # Route Removal: Remove a random route and re-insert nodes elsewhere
        if len(routes) > 1:
            route_to_remove_index = random.randint(0, len(routes) - 1)
            removed_route = routes.pop(route_to_remove_index)
            nodes_to_reinsert = removed_route[1:-1] # Exclude depot

            for node in nodes_to_reinsert:
                best_insertion_route_index = -1
                best_insertion_index = -1
                best_insertion_cost = np.inf

                for route_index in range(len(routes)):
                    for i in range(1, len(routes[route_index])):
                        new_route = routes[route_index][:i] + [node] + routes[route_index][i:]
                        new_route_load = sum(demands[n] for n in new_route if n!=0)

                        if new_route_load <= capacity:
                            insertion_cost = distance_matrix[routes[route_index][i-1], node] + distance_matrix[node, routes[route_index][i]] - distance_matrix[routes[route_index][i-1], routes[route_index][i]]
                            if insertion_cost < best_insertion_cost:
                                best_insertion_cost = insertion_cost
                                best_insertion_route_index = route_index
                                best_insertion_index = i

                if best_insertion_route_index != -1:
                    routes[best_insertion_route_index] = routes[best_insertion_route_index][:best_insertion_index] + [node] + routes[best_insertion_route_index][best_insertion_index:]
                else:  # Node could not be reinserted due to capacity constraints, create a new route
                    routes.append([0, node, 0])
        return routes

    best_routes = initial_solution()
    best_route_length = sum(route_length(route) for route in best_routes)

    temperature = 100
    cooling_rate = 0.95

    for _ in range(100):
        perturbed_routes = perturb_solution([route[:] for route in best_routes]) #deep copy
        perturbed_route_length = sum(route_length(route) for route in perturbed_routes)

        delta = perturbed_route_length - best_route_length

        if delta < 0 or random.random() < np.exp(-delta / temperature):
            best_routes = perturbed_routes
            best_route_length = perturbed_route_length

        temperature *= cooling_rate

    heuristics_matrix = calculate_heuristics_matrix(best_routes)

    return heuristics_matrix
