import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm refines the savings approach by incorporating a capacity-aware term that penalizes routes nearing capacity and rewards connections to nodes that improve route compactness and balance load.}
    """
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)
    savings_matrix = np.zeros_like(distance_matrix)

    for i in range(1, n):
        for j in range(i + 1, n):
            savings_matrix[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]
            savings_matrix[j, i] = savings_matrix[i, j]

    # Capacity awareness
    capacity_term = np.zeros_like(distance_matrix)
    for i in range(1, n):
        for j in range(1, n):
            if i != j:
                remaining_capacity_i = capacity - demands[i]
                remaining_capacity_j = capacity - demands[j]
                
                if demands[i] + demands[j] > capacity:
                    capacity_term[i, j] = -1  # Significant penalty for exceeding capacity
                else:
                    # Reward compactness and load balancing
                    capacity_term[i,j] = (remaining_capacity_i + remaining_capacity_j) / (2 * capacity)

            else:
                capacity_term[i, j] = -1  # Penalize connecting to itself
                
    compactness_term = np.zeros_like(distance_matrix)
    for i in range(1, n):
        for j in range(1,n):
            if i != j:
                compactness_term[i,j] = 1 / distance_matrix[i, j]
            else:
                compactness_term[i,j] = -1

    normalized_savings = savings_matrix / (np.max(savings_matrix) if np.any(savings_matrix) else 1)
    normalized_capacity = capacity_term / (np.max(capacity_term) if np.any(capacity_term) else 1)
    normalized_compactness = compactness_term / (np.max(compactness_term) if np.any(compactness_term) else 1)

    heuristics_matrix = normalized_savings + normalized_capacity + normalized_compactness

    return heuristics_matrix
