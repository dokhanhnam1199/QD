import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm constructs routes using a nearest-neighbor approach with probabilistic selection based on distance and demand, favoring closer and less demanding nodes, and uses the frequency of edge occurrences in these routes to build a heuristic matrix.}
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros((n, n))
    num_samples = 1000

    for _ in range(num_samples):
        unvisited = list(range(1, n))
        current_node = 0
        route = [0]
        current_capacity = capacity

        while unvisited:
            # Calculate probabilities for each unvisited node
            probabilities = []
            total_prob = 0
            for node in unvisited:
                if demands[node] <= current_capacity:
                    #prob = (1 / distance_matrix[current_node, node]) * (1 / demands[node]) #original
                    prob = np.exp(-distance_matrix[current_node, node]) * np.exp(-demands[node]/capacity)
                    probabilities.append((node, prob))
                    total_prob += prob
                else:
                    probabilities.append((node, 0))  # Node is infeasible
            
            # Normalize probabilities
            if total_prob > 0:
                probabilities = [(node, prob / total_prob) for node, prob in probabilities]
            else: # All nodes are infeasible at this point, so return to depot
                route.append(0)
                current_capacity = capacity
                probabilities = []
                total_prob = 0
                unvisited_temp = unvisited.copy()
                for node in unvisited_temp:
                    if demands[node] <= current_capacity:
                        #prob = (1 / distance_matrix[0, node]) * (1 / demands[node])  #Distance from depot
                        prob = np.exp(-distance_matrix[0, node]) * np.exp(-demands[node]/capacity)
                        probabilities.append((node, prob))
                        total_prob += prob
                    else:
                        probabilities.append((node, 0))

                if total_prob > 0:
                    probabilities = [(node, prob / total_prob) for node, prob in probabilities]
                else:
                    break  #No feasible node, break the loop

            # Choose next node based on probabilities
            if total_prob > 0:
                cumulative_prob = 0
                rand = random.random()
                next_node = None
                for node, prob in probabilities:
                    if demands[node] <= current_capacity:
                        cumulative_prob += prob
                        if rand <= cumulative_prob:
                            next_node = node
                            break
                    
                if next_node is None: #if all the nodes are infeasible, return to depot and break
                    route.append(0)
                    break
                
                route.append(next_node)
                unvisited.remove(next_node)
                current_capacity -= demands[next_node]
            else: #if all the nodes are infeasible, return to depot and break
                route.append(0)
                break

        route.append(0)

        # Update heuristic matrix
        for i in range(len(route) - 1):
            u = route[i]
            v = route[i+1]
            heuristics_matrix[u, v] += 1
            heuristics_matrix[v, u] += 1

    return heuristics_matrix
