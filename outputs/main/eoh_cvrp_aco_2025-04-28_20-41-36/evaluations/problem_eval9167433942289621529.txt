import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm iteratively refines routes by probabilistically accepting edge swaps based on a score function that combines route length improvement and capacity feasibility, dynamically adjusting the acceptance probability based on temperature annealing.}"""
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)
    num_iterations = 500
    num_routes = 5
    initial_temperature = 100
    cooling_rate = 0.95

    def create_initial_routes():
        routes = []
        for _ in range(num_routes):
            unvisited = set(range(1, n))
            current_route = [0]
            current_load = 0

            while unvisited:
                feasible_nodes = [node for node in unvisited if current_load + demands[node] <= capacity]
                if not feasible_nodes:
                    current_route.append(0)
                    routes.append(current_route)
                    current_route = [0]
                    current_load = 0
                    feasible_nodes = [node for node in unvisited if current_load + demands[node] <= capacity]
                    if not feasible_nodes:
                        break

                next_node = min(feasible_nodes, key=lambda node: distance_matrix[current_route[-1], node])
                current_route.append(next_node)
                current_load += demands[next_node]
                unvisited.remove(next_node)

            current_route.append(0)
            routes.append(current_route)
        return routes

    def calculate_route_distance(route):
        distance = 0
        for i in range(len(route) - 1):
            distance += distance_matrix[route[i], route[i+1]]
        return distance
    
    def calculate_route_load(route):
      max_load = 0
      temp_load = 0
      for k in range(1, len(route)):
        if route[k] == 0:
          max_load = max(max_load, temp_load)
          temp_load = 0
          continue
        temp_load += demands[route[k]]
      max_load = max(max_load, temp_load)
      return max_load

    routes = create_initial_routes()
    temperature = initial_temperature

    for _ in range(num_iterations):
        for route_index in range(len(routes)):
            route = routes[route_index]
            if len(route) <= 3:
              continue
            
            i = random.randint(1, len(route) - 2)
            j = random.randint(1, len(route) - 2)

            if i == j:
                continue
            
            new_route = route[:min(i,j)] + route[min(i,j):max(i,j)+1][::-1] + route[max(i,j)+1:]

            is_feasible = calculate_route_load(new_route) <= capacity

            old_distance = calculate_route_distance(route)
            new_distance = calculate_route_distance(new_route)
            distance_change = new_distance - old_distance
            
            if is_feasible:
                if distance_change < 0:
                    routes[route_index] = new_route
                else:
                    acceptance_probability = np.exp(-distance_change / temperature)
                    if random.random() < acceptance_probability:
                        routes[route_index] = new_route
            
        temperature *= cooling_rate

    for route in routes:
        for i in range(len(route) - 1):
            heuristics_matrix[route[i]][route[i+1]] += 1
            heuristics_matrix[route[i+1]][route[i]] += 1

    heuristics_matrix = heuristics_matrix / (num_iterations * num_routes) if (num_iterations * num_routes) > 0 else heuristics_matrix

    return heuristics_matrix
