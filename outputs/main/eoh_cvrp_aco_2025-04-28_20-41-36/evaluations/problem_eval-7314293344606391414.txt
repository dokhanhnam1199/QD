import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm uses a clustering approach to group nodes based on proximity and demand, then prioritizes edges connecting nodes within the same cluster and edges connecting clusters, incorporating simulated annealing to refine edge weights.}"""
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)
    num_clusters = int(np.sqrt(n)) + 1
    
    # K-means clustering
    clusters = [[] for _ in range(num_clusters)]
    centroids = coordinates[np.random.choice(n, num_clusters, replace=False)]
    
    for _ in range(10):
        clusters = [[] for _ in range(num_clusters)]
        cluster_assignments = []
        for i in range(n):
            distances = np.linalg.norm(coordinates[i] - centroids, axis=1)
            cluster_id = np.argmin(distances)
            clusters[cluster_id].append(i)
            cluster_assignments.append(cluster_id)

        for i in range(num_clusters):
            if clusters[i]:
                centroids[i] = np.mean(coordinates[clusters[i]], axis=0)

    # Intra-cluster and inter-cluster edge prioritization
    intra_cluster_weight = 1.0
    inter_cluster_weight = 0.5
    depot_cluster_weight = 0.75
    
    for i in range(n):
        for j in range(i + 1, n):
            cluster_i = cluster_assignments[i]
            cluster_j = cluster_assignments[j]

            if cluster_i == cluster_j:
                heuristics_matrix[i, j] = intra_cluster_weight / distance_matrix[i, j] if distance_matrix[i,j] > 0 else intra_cluster_weight
                heuristics_matrix[j, i] = intra_cluster_weight / distance_matrix[j, i] if distance_matrix[j,i] > 0 else intra_cluster_weight
            else:
                heuristics_matrix[i, j] = inter_cluster_weight / distance_matrix[i, j] if distance_matrix[i,j] > 0 else inter_cluster_weight
                heuristics_matrix[j, i] = inter_cluster_weight / distance_matrix[j, i] if distance_matrix[j,i] > 0 else inter_cluster_weight

            if i == 0 or j == 0:
                heuristics_matrix[i, j] *= depot_cluster_weight
                heuristics_matrix[j, i] *= depot_cluster_weight
    
    #Simulated Annealing (very basic)
    temperature = 100
    cooling_rate = 0.95
    
    for _ in range(100):
        i = random.randint(0, n-1)
        j = random.randint(0, n-1)
        if i != j:
            old_value = heuristics_matrix[i, j]
            
            change = random.uniform(-0.1, 0.1)
            new_value = old_value + change
            new_value = max(0, min(1, new_value))
            
            delta_e = new_value - old_value
            
            if delta_e > 0 or random.random() < np.exp(delta_e / temperature):
                heuristics_matrix[i, j] = new_value
                heuristics_matrix[j, i] = new_value
                
        temperature *= cooling_rate

    return heuristics_matrix
