import numpy as np

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm samples multiple random routes satisfying capacity constraints and uses reinforcement learning to update edge probabilities based on route quality.}
    """
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)
    edge_probabilities = np.ones_like(distance_matrix) / n # Initial probability
    learning_rate = 0.1
    discount_factor = 0.9
    num_samples = 1000

    def calculate_route_cost(route):
        cost = 0
        for i in range(len(route) - 1):
            cost += distance_matrix[route[i]][route[i+1]]
        return cost

    for _ in range(num_samples):
        route = [0]
        remaining_nodes = set(range(1, n))
        current_capacity = capacity

        while remaining_nodes:
            feasible_nodes = {
                node for node in remaining_nodes if demands[node] <= current_capacity
            }

            if not feasible_nodes:
                route.append(0)
                current_capacity = capacity
                feasible_nodes = {
                    node for node in remaining_nodes if demands[node] <= current_capacity
                }
                if not feasible_nodes:
                  break

            probabilities = [edge_probabilities[route[-1]][node] for node in feasible_nodes]
            probabilities = np.array(probabilities)
            probabilities /= np.sum(probabilities)
            
            next_node = np.random.choice(list(feasible_nodes), p=probabilities)
            
            route.append(next_node)
            remaining_nodes.remove(next_node)
            current_capacity -= demands[next_node]

        route.append(0)
        
        route_cost = calculate_route_cost(route)
        
        #Update edge probabilities
        for i in range(len(route) - 1):
            u = route[i]
            v = route[i+1]
            
            heuristics_matrix[u][v] += 1
            heuristics_matrix[v][u] += 1
            
            edge_probabilities[u][v] += learning_rate * (discount_factor/route_cost - edge_probabilities[u][v])
            edge_probabilities[v][u] = edge_probabilities[u][v]

    return heuristics_matrix
