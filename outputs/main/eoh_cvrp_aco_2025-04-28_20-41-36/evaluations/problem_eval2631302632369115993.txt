import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm uses a genetic algorithm approach to evolve a population of routes, selecting and mutating routes based on fitness (total distance), and constructing a heuristic matrix by averaging edge frequencies across the best routes in the final population.}"""
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)
    population_size = 50
    num_generations = 100
    mutation_rate = 0.1

    def create_initial_population():
        population = []
        for _ in range(population_size):
            routes = []
            unvisited = set(range(1, n))
            current_route = [0]
            current_load = 0

            while unvisited:
                feasible_nodes = [node for node in unvisited if current_load + demands[node] <= capacity]
                if not feasible_nodes:
                    current_route.append(0)
                    routes.append(current_route)
                    current_route = [0]
                    current_load = 0
                    feasible_nodes = [node for node in unvisited if current_load + demands[node] <= capacity]
                    if not feasible_nodes:
                        break

                next_node = random.choice(feasible_nodes)
                current_route.append(next_node)
                current_load += demands[next_node]
                unvisited.remove(next_node)

            current_route.append(0)
            routes.append(current_route)
            population.append(routes)
        return population

    def calculate_fitness(routes):
        total_distance = 0
        for route in routes:
            for i in range(len(route) - 1):
                total_distance += distance_matrix[route[i], route[i+1]]
        return 1 / (total_distance + 1e-9)

    def crossover(parent1, parent2):
        child = []
        for i in range(len(parent1)):
            if random.random() < 0.5 and i < len(parent2):
                child.append(parent1[i])
            elif i < len(parent2):
                child.append(parent2[i])
            else:
                child.append(parent1[i])

        return child
            

    def mutate(routes):
        for route_index in range(len(routes)):
            if random.random() < mutation_rate:
                route = routes[route_index]
                if len(route) <= 3:
                    continue
                i = random.randint(1, len(route) - 2)
                j = random.randint(i + 1, len(route) - 1)
                routes[route_index] = route[:i] + route[i:j+1][::-1] + route[j+1:]
        return routes
                

    population = create_initial_population()

    for _ in range(num_generations):
        fitness_scores = [calculate_fitness(routes) for routes in population]
        
        # Selection (roulette wheel selection)
        probabilities = [score / sum(fitness_scores) for score in fitness_scores]
        selected_indices = np.random.choice(len(population), size=population_size, p=probabilities)
        selected_population = [population[i] for i in selected_indices]
        
        # Crossover and Mutation
        new_population = []
        for i in range(0, population_size, 2):
            parent1 = selected_population[i]
            if i+1 < population_size:
                parent2 = selected_population[i+1]
                child = crossover(parent1, parent2)
            else:
                child = parent1
            child = mutate(child)

            new_population.append(child)

        population = new_population
    
    # Average the edges of the best route
    fitness_scores = [calculate_fitness(routes) for routes in population]
    best_route_index = np.argmax(fitness_scores)
    best_route = population[best_route_index]

    for route in best_route:
        for i in range(len(route) - 1):
            heuristics_matrix[route[i]][route[i+1]] += 1
            heuristics_matrix[route[i+1]][route[i]] += 1

    heuristics_matrix = heuristics_matrix / (num_generations) if (num_generations) > 0 else heuristics_matrix
    
    return heuristics_matrix
