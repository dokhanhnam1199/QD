import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm constructs routes incrementally using a nearest neighbor approach with stochastic acceptance based on route cost improvement and edge usage, updating a heuristic matrix accordingly.}"""
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)
    num_iterations = 500
    
    def create_initial_route():
        unvisited = set(range(1, n))
        current_route = [0]
        current_load = 0
        
        while unvisited:
            feasible_nodes = [node for node in unvisited if current_load + demands[node] <= capacity]
            if not feasible_nodes:
                current_route.append(0)
                return current_route
            
            next_node = min(feasible_nodes, key=lambda node: distance_matrix[current_route[-1], node])
            current_route.append(next_node)
            current_load += demands[next_node]
            unvisited.remove(next_node)
        
        current_route.append(0)
        return current_route
    
    def calculate_route_distance(route):
        distance = 0
        for i in range(len(route) - 1):
            distance += distance_matrix[route[i], route[i+1]]
        return distance
    
    for _ in range(num_iterations):
        route = create_initial_route()
        original_distance = calculate_route_distance(route)
        
        for i in range(1, len(route) - 1):
            for j in range(i + 1, len(route)):
                new_route = route[:i] + route[i:j][::-1] + route[j:]
                
                new_route_load = [0] * len(new_route)
                for k in range(1,len(new_route)):
                  if new_route[k] == 0:
                    continue
                  new_route_load[k] = new_route_load[k-1] + demands[new_route[k]]

                is_feasible = True
                max_load = 0
                temp_load = 0
                for k in range(1, len(new_route)):
                  if new_route[k] == 0:
                    max_load = max(max_load, temp_load)
                    temp_load = 0
                    continue
                  temp_load += demands[new_route[k]]
                max_load = max(max_load, temp_load)
                
                if max_load > capacity:
                    is_feasible = False
                    continue
                    
                new_distance = calculate_route_distance(new_route)
                
                if is_feasible:
                  if new_distance < original_distance:
                    acceptance_probability = np.exp((original_distance - new_distance) / original_distance)
                  else:
                    acceptance_probability = 0

                  if random.random() < acceptance_probability:
                    route = new_route
                    original_distance = new_distance

        for i in range(len(route) - 1):
            heuristics_matrix[route[i]][route[i+1]] += 1
            heuristics_matrix[route[i+1]][route[i]] += 1
            
    heuristics_matrix = heuristics_matrix / num_iterations if num_iterations > 0 else heuristics_matrix
    
    return heuristics_matrix
