import numpy as np

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm constructs a heuristic matrix based on savings values, a penalty for exceeding capacity, and a modified proximity bonus based on node location and demand.}"""
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)

    # Calculate savings values
    savings_matrix = np.zeros_like(distance_matrix)
    for i in range(1, n):
        for j in range(1, n):
            if i != j:
                savings_matrix[i][j] = distance_matrix[0][i] + distance_matrix[0][j] - distance_matrix[i][j]

    # Construct heuristic matrix
    for i in range(1, n):
        for j in range(1, n):
            if i != j:
                # Base heuristic score from savings
                heuristics_matrix[i][j] = savings_matrix[i][j]

                # Capacity penalty: penalize linking nodes that would exceed capacity, scaled by average saving
                if demands[i] + demands[j] > capacity:
                    heuristics_matrix[i][j] -= (demands[i] + demands[j] - capacity) * np.mean(savings_matrix)

                # Proximity bonus: reward linking nodes that are close to each other, scaled by inverse of demand.
                euclidean_distance = np.sqrt(np.sum((coordinates[i] - coordinates[j])**2))
                heuristics_matrix[i][j] += (np.mean(distance_matrix) / (euclidean_distance + 1e-6)) * (1 / (demands[i] + demands[j])) # Add a small constant to avoid division by zero

    return heuristics_matrix
