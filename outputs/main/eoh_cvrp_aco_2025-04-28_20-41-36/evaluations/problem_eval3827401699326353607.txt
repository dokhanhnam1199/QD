import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm combines the nearest neighbor approach with a capacity-aware insertion heuristic to construct initial routes, then refines the edge selection probabilities using a simulated annealing-inspired process that prioritizes edges on promising routes and penalizes those exceeding capacity.}"""
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)
    
    # Initialize routes using nearest neighbor and capacity constraints
    routes = []
    unvisited = set(range(1, n))
    while unvisited:
        current_route = [0]
        current_capacity = capacity
        current_node = 0
        
        while True:
            feasible_nodes = {node for node in unvisited if demands[node] <= current_capacity}
            if not feasible_nodes:
                break
            
            next_node = min(feasible_nodes, key=lambda node: distance_matrix[current_node, node])
            current_route.append(next_node)
            unvisited.remove(next_node)
            current_capacity -= demands[next_node]
            current_node = next_node
        
        current_route.append(0)
        routes.append(current_route)

    #Initial heuristic matrix based on current route
    for route in routes:
        for i in range(len(route) -1):
            heuristics_matrix[route[i], route[i+1]] = 1
            heuristics_matrix[route[i+1], route[i]] = 1
    
    #Refine the heuristic matrix using simulated annealing concept.
    T = 1.0 #initial temperature
    T_min = 0.00001 #minimum temperature
    alpha = 0.9 #cooling rate

    while T > T_min:
        for i in range(1,n):
            for j in range(i+1, n):
                current_heuristic = heuristics_matrix[i, j]
                
                #Calculate the change in heuristics
                new_heuristic = random.uniform(0, 1) #random value
                
                #Consider accepting the new heuristics value using Metropolis criteria
                delta = new_heuristic - current_heuristic
                
                if delta > 0:
                    #Accept better solutions
                    heuristics_matrix[i, j] = new_heuristic
                    heuristics_matrix[j, i] = new_heuristic
                else:
                    #Accept worse solutions with probability exp(-delta/T)
                    if random.uniform(0, 1) < np.exp(delta / T):
                        heuristics_matrix[i, j] = new_heuristic
                        heuristics_matrix[j, i] = new_heuristic
        #Cooling
        T = T * alpha
        
    return heuristics_matrix
