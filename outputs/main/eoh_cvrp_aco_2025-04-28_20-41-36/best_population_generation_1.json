{
     "algorithm": "This algorithm refines the savings approach by incorporating a penalty for exceeding capacity during route construction and prioritizing connections to nodes with higher demand relative to their distance.",
     "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm refines the savings approach by incorporating a penalty for exceeding capacity during route construction and prioritizing connections to nodes with higher demand relative to their distance.}\n    \"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    savings_matrix = np.zeros_like(distance_matrix)\n\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings_matrix[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings_matrix[j, i] = savings_matrix[i, j]\n\n    demand_distance_ratio = np.zeros_like(distance_matrix)\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                demand_distance_ratio[i, j] = (demands[i] + demands[j]) / distance_matrix[i, j]\n            else:\n                demand_distance_ratio[i, j] = 0\n                \n    penalty_matrix = np.zeros_like(distance_matrix)\n    for i in range(1, n):\n      for j in range(1, n):\n        if i!=j:\n          if demands[i] + demands[j] > capacity:\n            penalty_matrix[i, j] = -1\n            penalty_matrix[j, i] = -1\n        else:\n          penalty_matrix[i,j] = -1\n\n\n    normalized_savings = savings_matrix / (np.max(savings_matrix) if np.any(savings_matrix) else 1)\n    normalized_demand_distance = demand_distance_ratio / (np.max(demand_distance_ratio) if np.any(demand_distance_ratio) else 1)\n\n    heuristics_matrix = normalized_savings + normalized_demand_distance + penalty_matrix\n\n    return heuristics_matrix",
     "objective": 11.25901,
     "other_inf": null
}