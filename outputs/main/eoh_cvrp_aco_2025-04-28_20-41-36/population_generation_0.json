[
     {
          "algorithm": "This algorithm samples multiple random routes satisfying capacity constraints,\n    then averages the edge frequencies across all routes to generate a heuristic matrix.}\n    \"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    num_samples = 1000\n\n    for _ in range(num_samples):\n        route = [0]\n        remaining_nodes = set(range(1, n))\n        current_capacity = capacity\n\n        while remaining_nodes:\n            feasible_nodes = {\n                node for node in remaining_nodes if demands[node] <= current_capacity\n            }\n\n            if not feasible_nodes:\n                route.append(0)\n                current_capacity = capacity\n                feasible_nodes = {\n                    node for node in remaining_nodes if demands[node] <= current_capacity\n                ",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm samples multiple random routes satisfying capacity constraints,\n    then averages the edge frequencies across all routes to generate a heuristic matrix.}\n    \"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    num_samples = 1000\n\n    for _ in range(num_samples):\n        route = [0]\n        remaining_nodes = set(range(1, n))\n        current_capacity = capacity\n\n        while remaining_nodes:\n            feasible_nodes = {\n                node for node in remaining_nodes if demands[node] <= current_capacity\n            }\n\n            if not feasible_nodes:\n                route.append(0)\n                current_capacity = capacity\n                feasible_nodes = {\n                    node for node in remaining_nodes if demands[node] <= current_capacity\n                }\n                if not feasible_nodes:\n                  break\n\n            next_node = min(\n                feasible_nodes, key=lambda node: distance_matrix[route[-1]][node]\n            )\n\n            route.append(next_node)\n            remaining_nodes.remove(next_node)\n            current_capacity -= demands[next_node]\n\n        route.append(0)\n        for i in range(len(route) - 1):\n            heuristics_matrix[route[i]][route[i+1]] += 1\n            heuristics_matrix[route[i+1]][route[i]] += 1\n    \n    heuristics_matrix = heuristics_matrix / num_samples\n    return heuristics_matrix",
          "objective": 16.02473,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm samples multiple random routes satisfying capacity constraints,\n    evaluates the frequency of each edge's appearance in those routes,\n    and uses this frequency to construct a heuristics matrix.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm samples multiple random routes satisfying capacity constraints,\n    evaluates the frequency of each edge's appearance in those routes,\n    and uses this frequency to construct a heuristics matrix.}\n    \"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    num_samples = 1000\n\n    for _ in range(num_samples):\n        route = [0]\n        remaining_nodes = set(range(1, n))\n        current_capacity = capacity\n        \n        while remaining_nodes:\n            # Sort the nodes according to their distance from the current node.\n            next_node_candidates = sorted(remaining_nodes, key=lambda node: distance_matrix[route[-1]][node])\n            \n            # Find the first node that satisfies the capacity constraint.\n            found_next_node = False\n            for next_node in next_node_candidates:\n                if demands[next_node] <= current_capacity:\n                    route.append(next_node)\n                    remaining_nodes.remove(next_node)\n                    current_capacity -= demands[next_node]\n                    found_next_node = True\n                    break\n\n            # If no node can be added, return to the depot\n            if not found_next_node:\n                route.append(0)\n                current_capacity = capacity\n            \n        route.append(0) # Return to depot\n\n        # Update heuristics matrix\n        for i in range(len(route) - 1):\n            heuristics_matrix[route[i]][route[i+1]] += 1\n            heuristics_matrix[route[i+1]][route[i]] += 1\n\n    return heuristics_matrix",
          "objective": 16.16831,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm constructs multiple random routes, evaluates their feasibility and cost, and updates a heuristic matrix based on edge frequencies in feasible solutions, favoring shorter edges and penalizing edges that lead to capacity violations.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm constructs multiple random routes, evaluates their feasibility and cost, and updates a heuristic matrix based on edge frequencies in feasible solutions, favoring shorter edges and penalizing edges that lead to capacity violations.}\n    \"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    num_samples = 100  # Number of random routes to generate\n    \n    for _ in range(num_samples):\n        # Generate a random permutation of customers (excluding the depot)\n        permutation = list(range(1, n))\n        random.shuffle(permutation)\n\n        routes = []\n        current_route = [0]\n        current_capacity = 0\n        \n        for customer in permutation:\n            if current_capacity + demands[customer] <= capacity:\n                current_route.append(customer)\n                current_capacity += demands[customer]\n            else:\n                current_route.append(0)  # Return to depot\n                routes.append(current_route)\n                current_route = [0, customer]\n                current_capacity = demands[customer]\n\n        current_route.append(0)\n        routes.append(current_route)\n        \n        # Evaluate the feasibility and cost of the routes\n        is_feasible = True\n        for route in routes:\n            total_demand = sum(demands[i] for i in route)\n            if total_demand > capacity:\n                is_feasible = False\n                break\n\n        if is_feasible:\n            # Update the heuristic matrix based on edge frequencies\n            for route in routes:\n                for i in range(len(route) - 1):\n                    u = route[i]\n                    v = route[i+1]\n                    heuristics_matrix[u, v] += 1\n                    heuristics_matrix[v, u] += 1  # Assuming symmetric distance matrix\n\n    # Incorporate distance information into the heuristic matrix\n    # Favor shorter edges\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                heuristics_matrix[i, j] /= (distance_matrix[i, j] + 1e-6)  # Avoid division by zero\n\n    return heuristics_matrix",
          "objective": 24.97995,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm estimates edge inclusion probabilities by stochastically generating feasible routes, favoring edges appearing in many feasible routes.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"{This algorithm estimates edge inclusion probabilities by stochastically generating feasible routes, favoring edges appearing in many feasible routes.}\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    num_samples = 1000\n\n    for _ in range(num_samples):\n        unvisited = set(range(1, n))\n        current_route = [0]\n        current_load = 0\n        all_routes = []\n\n        while unvisited:\n            # Find feasible next nodes\n            feasible_nodes = [node for node in unvisited if current_load + demands[node] <= capacity]\n\n            if not feasible_nodes:\n                # Return to depot\n                current_route.append(0)\n                all_routes.append(current_route)\n                current_route = [0]\n                current_load = 0\n                feasible_nodes = [node for node in unvisited if current_load + demands[node] <= capacity]\n                if not feasible_nodes:\n                    #Restart if no route possible\n                    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n                    return heuristics_matrix\n\n            # Select the next node stochastically (biased towards closer nodes)\n            probabilities = []\n            for node in feasible_nodes:\n                probabilities.append(1.0 / distance_matrix[current_route[-1], node])  # Inverse distance as probability\n\n            probabilities = np.array(probabilities)\n            probabilities /= np.sum(probabilities)\n\n            next_node = np.random.choice(feasible_nodes, p=probabilities)\n            current_route.append(next_node)\n            current_load += demands[next_node]\n            unvisited.remove(next_node)\n\n        # Close the final route\n        current_route.append(0)\n        all_routes.append(current_route)\n\n        # Update heuristics matrix based on edges used in the routes\n        for route in all_routes:\n            for i in range(len(route) - 1):\n                heuristics_matrix[route[i], route[i+1]] += 1\n                heuristics_matrix[route[i+1], route[i]] += 1  # Symmetric\n\n    # Normalize heuristics matrix\n    heuristics_matrix /= num_samples\n    return heuristics_matrix",
          "objective": 25.5146,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm samples multiple stochastic solutions based on a nearest neighbor heuristic, evaluates their feasibility and cost, and then aggregates the edge usage frequencies to construct a heuristic matrix guiding future search.}\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros((n, n))\n    num_samples = 100\n\n    for _ in range(num_samples):\n        # Construct a random but feasible route\n        current_node = 0\n        remaining_nodes = set(range(1, n))\n        current_load = 0\n        route = [0]\n        \n        while remaining_nodes:\n            # Find nearest neighbors that fit within capacity\n            feasible_neighbors = []\n            for neighbor in remaining_nodes:\n                if current_load + demands[neighbor] <= capacity:\n                    feasible_neighbors.append(neighbor)\n            \n            if not feasible_neighbors:\n                # Return to depot if no feasible neighbors\n                route.append(0)\n                current_load = 0\n                continue\n                \n            # Pick a random neighbor from the feasible neighbors based on distance\n            neighbor_distances = {neighbor: distance_matrix[current_node, neighbor] for neighbor in feasible_neighbors",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"{This algorithm samples multiple stochastic solutions based on a nearest neighbor heuristic, evaluates their feasibility and cost, and then aggregates the edge usage frequencies to construct a heuristic matrix guiding future search.}\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros((n, n))\n    num_samples = 100\n\n    for _ in range(num_samples):\n        # Construct a random but feasible route\n        current_node = 0\n        remaining_nodes = set(range(1, n))\n        current_load = 0\n        route = [0]\n        \n        while remaining_nodes:\n            # Find nearest neighbors that fit within capacity\n            feasible_neighbors = []\n            for neighbor in remaining_nodes:\n                if current_load + demands[neighbor] <= capacity:\n                    feasible_neighbors.append(neighbor)\n            \n            if not feasible_neighbors:\n                # Return to depot if no feasible neighbors\n                route.append(0)\n                current_load = 0\n                continue\n                \n            # Pick a random neighbor from the feasible neighbors based on distance\n            neighbor_distances = {neighbor: distance_matrix[current_node, neighbor] for neighbor in feasible_neighbors}\n            \n            if neighbor_distances:\n                probabilities = np.array(list(neighbor_distances.values()))\n                probabilities = 1 / (probabilities + 1e-6) # Inverse distance based probabilities\n                probabilities /= np.sum(probabilities)\n                \n                chosen_neighbor = np.random.choice(list(neighbor_distances.keys()), p=probabilities)\n                \n                route.append(chosen_neighbor)\n                current_load += demands[chosen_neighbor]\n                remaining_nodes.remove(chosen_neighbor)\n                current_node = chosen_neighbor\n            else:\n                # No feasible neighbors and the current_load is not zero. Return to depot.\n                route.append(0)\n                current_load = 0\n                current_node = 0\n\n        route.append(0) # Return to depot\n\n        # Update heuristics matrix based on route\n        for i in range(len(route) - 1):\n            heuristics_matrix[route[i], route[i+1]] += 1\n            heuristics_matrix[route[i+1], route[i]] += 1 # Assume symmetric distance matrix\n\n    return heuristics_matrix",
          "objective": 25.54374,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm samples a set of random routes, evaluates their feasibility and cost, and then constructs a heuristic matrix based on the frequency with which each edge appears in feasible, low-cost routes.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm samples a set of random routes, evaluates their feasibility and cost, and then constructs a heuristic matrix based on the frequency with which each edge appears in feasible, low-cost routes.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros((n, n))\n    num_samples = 1000\n\n    for _ in range(num_samples):\n        # Generate a random permutation of customers (excluding the depot)\n        customer_indices = np.random.permutation(range(1, n))\n        \n        # Construct a route and evaluate feasibility\n        routes = []\n        current_route = [0]\n        current_capacity = 0\n        \n        for customer in customer_indices:\n            if current_capacity + demands[customer] <= capacity:\n                current_route.append(customer)\n                current_capacity += demands[customer]\n            else:\n                current_route.append(0)\n                routes.append(current_route)\n                current_route = [0, customer]\n                current_capacity = demands[customer]\n\n        current_route.append(0)  # Return to depot\n        routes.append(current_route)\n\n        # Calculate total distance of current solution\n        total_distance = 0\n        for route in routes:\n            for i in range(len(route) - 1):\n                total_distance += distance_matrix[route[i], route[i+1]]\n\n        # Update heuristics matrix with edges from the current feasible solution\n        if len(routes) > 0:\n            for route in routes:\n                for i in range(len(route) - 1):\n                     heuristics_matrix[route[i], route[i+1]] += 1\n            \n\n    # Normalize heuristics matrix\n    heuristics_matrix = heuristics_matrix / num_samples\n\n    return heuristics_matrix",
          "objective": 29.34993,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm samples a large number of random routes respecting capacity constraints, evaluates the quality of each route by its total distance, and then averages the occurrence of each edge across the sampled routes weighted by the inverse of the route's distance to generate a heuristic matrix.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm samples a large number of random routes respecting capacity constraints, evaluates the quality of each route by its total distance, and then averages the occurrence of each edge across the sampled routes weighted by the inverse of the route's distance to generate a heuristic matrix.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros((n, n))\n    num_samples = 1000\n\n    for _ in range(num_samples):\n        # Generate a random route\n        unvisited = list(range(1, n))\n        current_node = 0\n        route = [0]\n        current_capacity = capacity\n        \n        while unvisited:\n            # Find feasible next nodes\n            feasible_nodes = [node for node in unvisited if demands[node] <= current_capacity]\n\n            if not feasible_nodes:\n                route.append(0)  # Return to depot\n                current_capacity = capacity\n                feasible_nodes = [node for node in unvisited if demands[node] <= current_capacity]\n                if not feasible_nodes:\n                    break # if there isn't feasible node, break\n\n            if feasible_nodes:\n                next_node = random.choice(feasible_nodes)\n                route.append(next_node)\n                unvisited.remove(next_node)\n                current_capacity -= demands[next_node]\n\n        route.append(0)  # Return to depot\n\n        # Calculate route distance\n        route_distance = 0\n        for i in range(len(route) - 1):\n            route_distance += distance_matrix[route[i], route[i+1]]\n        \n        # Update heuristics matrix\n        if route_distance > 0:\n            weight = 1.0 / route_distance  # Inverse distance as weight\n        else:\n            weight = 0.0\n\n        for i in range(len(route) - 1):\n            u = route[i]\n            v = route[i+1]\n            heuristics_matrix[u, v] += weight\n            heuristics_matrix[v, u] += weight  # Assuming symmetric distance matrix\n\n    return heuristics_matrix",
          "objective": 29.48214,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm samples a set of random routes, evaluates their feasibility and cost, and updates a heuristic matrix based on the frequency with which each edge appears in feasible, low-cost routes.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm samples a set of random routes, evaluates their feasibility and cost, and updates a heuristic matrix based on the frequency with which each edge appears in feasible, low-cost routes.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros((n, n))\n    num_samples = 1000\n    alpha = 0.1  # Weight for cost when updating heuristic\n\n    for _ in range(num_samples):\n        # 1. Generate a random route (permutation of nodes excluding the depot)\n        route = np.random.permutation(range(1, n))\n        \n        # 2. Split the route into feasible sub-routes based on capacity\n        sub_routes = []\n        current_route = []\n        current_demand = 0\n        \n        for node in route:\n            if current_demand + demands[node] <= capacity:\n                current_route.append(node)\n                current_demand += demands[node]\n            else:\n                sub_routes.append(current_route)\n                current_route = [node]\n                current_demand = demands[node]\n        \n        if current_route:\n            sub_routes.append(current_route)\n\n        # 3. Calculate the cost of the route\n        total_cost = 0\n        is_feasible = True\n        for sub_route in sub_routes:\n            sub_route_cost = distance_matrix[0, sub_route[0]]  # From depot to first node\n            for i in range(len(sub_route) - 1):\n                sub_route_cost += distance_matrix[sub_route[i], sub_route[i+1]]\n            sub_route_cost += distance_matrix[sub_route[-1], 0]  # From last node to depot\n            total_cost += sub_route_cost\n            \n            sub_route_demand = sum([demands[node] for node in sub_route])\n            if sub_route_demand > capacity:\n                is_feasible = False\n                break\n\n\n        # 4. Update the heuristic matrix based on cost and feasibility\n        if is_feasible:\n            # Scale the cost to a range [0, 1] (higher costs = smaller updates)\n            normalized_cost = 1 / (1 + alpha * total_cost)  # Add 1 to avoid division by zero\n            \n            for sub_route in sub_routes:\n                # Depot to first node\n                heuristics_matrix[0, sub_route[0]] += normalized_cost\n                heuristics_matrix[sub_route[0], 0] += normalized_cost\n\n                # Between nodes in the sub-route\n                for i in range(len(sub_route) - 1):\n                    heuristics_matrix[sub_route[i], sub_route[i+1]] += normalized_cost\n                    heuristics_matrix[sub_route[i+1], sub_route[i]] += normalized_cost  # Symmetry\n\n                # Last node to depot\n                heuristics_matrix[sub_route[-1], 0] += normalized_cost\n                heuristics_matrix[0, sub_route[-1]] += normalized_cost\n\n\n    return heuristics_matrix",
          "objective": 29.53705,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm generates multiple random routes, evaluates their feasibility and cost,\n     and uses the information to update a heuristic matrix that favors edges appearing in good solutions.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    Solves Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.\n\n    {The algorithm generates multiple random routes, evaluates their feasibility and cost,\n     and uses the information to update a heuristic matrix that favors edges appearing in good solutions.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros((n, n))\n    num_samples = 100  # Number of random solutions to sample\n    \n    for _ in range(num_samples):\n        # Generate a random permutation of customers (excluding the depot)\n        customer_indices = np.random.permutation(range(1, n))\n        \n        # Build routes based on capacity constraint\n        routes = []\n        current_route = [0]  # Start at depot\n        current_demand = 0\n        \n        for customer in customer_indices:\n            if current_demand + demands[customer] <= capacity:\n                current_route.append(customer)\n                current_demand += demands[customer]\n            else:\n                current_route.append(0)  # Return to depot\n                routes.append(current_route)\n                current_route = [0, customer]  # Start new route from depot\n                current_demand = demands[customer]\n        \n        current_route.append(0) # Close last route by returning to depot\n        routes.append(current_route)\n        \n\n        # Calculate the cost of the solution\n        total_cost = 0\n        for route in routes:\n            for i in range(len(route) - 1):\n                total_cost += distance_matrix[route[i], route[i+1]]\n        \n        # Update the heuristic matrix based on the solution's edges. edges from good solution are promoted by increasing heuristics_matrix value.\n        if total_cost > 0:  # Avoid division by zero\n            for route in routes:\n                for i in range(len(route) - 1):\n                    node1 = route[i]\n                    node2 = route[i+1]\n                    heuristics_matrix[node1, node2] += 1 / total_cost\n                    heuristics_matrix[node2, node1] += 1 / total_cost  # Make it symmetric\n\n    return heuristics_matrix",
          "objective": 29.53955,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm samples many random routes, evaluates their feasibility with respect to capacity constraints, and then uses the frequency with which each edge appears in feasible routes to generate a heuristic matrix.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm samples many random routes, evaluates their feasibility with respect to capacity constraints, and then uses the frequency with which each edge appears in feasible routes to generate a heuristic matrix.}\n    \"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros((n, n))\n    num_samples = 1000\n\n    for _ in range(num_samples):\n        # Generate a random permutation of customers\n        customer_indices = list(range(1, n))\n        random.shuffle(customer_indices)\n\n        # Build routes respecting capacity\n        routes = []\n        current_route = [0]\n        current_capacity = 0\n        for customer in customer_indices:\n            if current_capacity + demands[customer] <= capacity:\n                current_route.append(customer)\n                current_capacity += demands[customer]\n            else:\n                current_route.append(0)\n                routes.append(current_route)\n                current_route = [0, customer]\n                current_capacity = demands[customer]\n        current_route.append(0)\n        routes.append(current_route)\n\n        # Update heuristic matrix based on edges in feasible routes\n        for route in routes:\n            for i in range(len(route) - 1):\n                u = route[i]\n                v = route[i+1]\n                heuristics_matrix[u, v] += 1\n                heuristics_matrix[v, u] += 1  # Assuming symmetric distance matrix\n\n    # Normalize the heuristic matrix\n    heuristics_matrix = heuristics_matrix / num_samples\n\n    return heuristics_matrix",
          "objective": 29.57792,
          "other_inf": null
     }
]