[
  {
    "stdout_filepath": "problem_iter0_stdout0.txt",
    "code_path": "problem_iter0_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    ratios = item / bins_remain_cap\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities",
    "response_id": 0,
    "obj": 149.30195452732352,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 11.60964047443681,
    "mi": 94.04446327225541,
    "token_count": 47.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response0.txt_stdout.txt",
    "code_path": "problem_iter1_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that can fit the item get a higher priority\n    can_fit = remaining_after_addition >= 0\n    \n    # Prioritize bins that have just enough capacity for the item\n    priorities = np.where(can_fit, -np.abs(remaining_after_addition), -np.inf)\n    \n    # To avoid division by zero, we add a small value to bins_remain_cap before calculating the ratio\n    epsilon = 1e-6\n    ratios = item / (bins_remain_cap + epsilon)\n    \n    # Combine the two factors: the ability to fit the item and the ratio of item size to remaining capacity\n    priorities = np.where(can_fit, priorities + np.log(1 + 1 / ratios), priorities)\n    \n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 76.0,
    "mi": 82.48240259189015,
    "token_count": 100.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response1.txt_stdout.txt",
    "code_path": "problem_iter1_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that can fit the item will have a non-negative remaining capacity\n    can_fit = remaining_after_addition >= 0\n    \n    # For bins that can fit the item, the priority is inversely proportional to the remaining capacity\n    # This encourages packing items tightly\n    priorities = np.where(can_fit, 1 / (1 + remaining_after_addition), -np.inf)\n    \n    # To avoid division by zero and make the priority score more robust\n    priorities = np.where(remaining_after_addition == 0, np.inf, priorities)\n    \n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 76.0,
    "mi": 82.48240259189015,
    "token_count": 100.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response2.txt_stdout.txt",
    "code_path": "problem_iter1_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot accommodate the item\n    priorities = np.where(remaining_capacities >= 0, -np.abs(bins_remain_cap - item), -1e6)\n    \n    # Add a small noise to break ties\n    np.random.seed(0)\n    priorities += np.random.uniform(0, 1e-6, size=len(priorities))\n    \n    return priorities",
    "response_id": 2,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 76.0,
    "mi": 82.48240259189015,
    "token_count": 100.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response3.txt_stdout.txt",
    "code_path": "problem_iter1_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Mask for bins that have enough capacity for the item\n    valid_bins = remaining_after_addition >= 0\n    \n    # For bins with enough capacity, priority is the remaining capacity after addition\n    # For bins without enough capacity, priority is a large negative value\n    priorities = np.where(valid_bins, remaining_after_addition, -1e6)\n    \n    # Add a small random noise to break ties\n    priorities += np.random.uniform(0, 1e-6, size=len(priorities))\n    \n    return priorities",
    "response_id": 3,
    "obj": 149.30195452732352,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 76.0,
    "mi": 82.48240259189015,
    "token_count": 100.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response4.txt_stdout.txt",
    "code_path": "problem_iter1_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    \n    # Mask for bins that can fit the item\n    valid_bins = remaining_capacities >= 0\n    \n    # Initialize priorities with negative infinity for bins that can't fit the item\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n    \n    # For bins that can fit the item, calculate priority as a combination of \n    # the remaining capacity and the ratio of item size to bin remaining capacity\n    priorities[valid_bins] = 0.5 * remaining_capacities[valid_bins] + 0.5 * (1 - (item / bins_remain_cap[valid_bins]))\n    \n    return priorities",
    "response_id": 4,
    "obj": 149.30195452732352,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 76.0,
    "mi": 82.48240259189015,
    "token_count": 100.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response5.txt_stdout.txt",
    "code_path": "problem_iter1_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Compute the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot accommodate the item\n    priorities = np.where(remaining_after_addition >= 0, \n                          bins_remain_cap - item,  # Higher remaining capacity is better\n                          -np.inf)  # Cannot accommodate the item\n    \n    # Normalize the priorities to ensure they are on the same scale\n    max_remaining = np.max(bins_remain_cap)\n    priorities = np.where(remaining_after_addition >= 0, \n                          remaining_after_addition / max_remaining, \n                          -np.inf)\n    \n    return priorities",
    "response_id": 5,
    "obj": 149.30195452732352,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 76.0,
    "mi": 82.48240259189015,
    "token_count": 100.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response6.txt_stdout.txt",
    "code_path": "problem_iter1_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot accommodate the item\n    priorities = np.where(remaining_after_addition >= 0, \n                          bins_remain_cap - item,  # Prioritize bins with the least remaining capacity that can still fit the item\n                          -1e9)  # A very negative number to represent \"not feasible\"\n    \n    # Further prioritize bins that are almost full (higher remaining capacity is less preferred)\n    priorities = np.where(remaining_after_addition == 0, 1e9, priorities)  # Assign the highest priority to bins that will be exactly full\n    \n    return priorities",
    "response_id": 6,
    "obj": 86.58755484643,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 76.0,
    "mi": 82.48240259189015,
    "token_count": 100.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response7.txt_stdout.txt",
    "code_path": "problem_iter1_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Compute the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that can fit the item get a higher priority\n    can_fit = remaining_after_addition >= 0\n    \n    # Prioritize bins that have just enough capacity for the item\n    priorities = np.where(can_fit, -np.abs(remaining_after_addition), -np.inf)\n    \n    # To avoid division by zero, we add a small epsilon to bins_remain_cap\n    epsilon = 1e-8\n    priorities += np.log(bins_remain_cap + epsilon)\n    \n    return priorities",
    "response_id": 7,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 76.0,
    "mi": 82.48240259189015,
    "token_count": 100.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response8.txt_stdout.txt",
    "code_path": "problem_iter1_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # For bins that have enough capacity, prioritize the one with the least remaining capacity\n    enough_capacity = bins_remain_cap >= item\n    priorities_enough = np.where(enough_capacity, -remaining_cap_after_addition, -np.inf)\n    \n    # For bins without enough capacity, assign a very low priority\n    priorities_not_enough = np.where(~enough_capacity, -np.abs(remaining_cap_after_addition), -np.inf)\n    \n    # Combine the two priorities, use the one for bins with enough capacity if available\n    priorities = np.maximum(priorities_enough, priorities_not_enough)\n    \n    return priorities",
    "response_id": 8,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 76.0,
    "mi": 82.48240259189015,
    "token_count": 100.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response9.txt_stdout.txt",
    "code_path": "problem_iter1_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Mask for bins that can fit the item\n    valid_bins_mask = remaining_after_addition >= 0\n    \n    # Initialize priorities with negative infinity for bins that cannot fit the item\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n    \n    # For bins that can fit the item, calculate priority based on remaining capacity\n    priorities[valid_bins_mask] = remaining_after_addition[valid_bins_mask] / bins_remain_cap[valid_bins_mask]\n    \n    return priorities",
    "response_id": 9,
    "obj": 4.487435181491823,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 76.0,
    "mi": 82.48240259189015,
    "token_count": 100.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response10.txt_stdout.txt",
    "code_path": "problem_iter1_code10.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that can fit the item get a higher priority\n    valid_bins = remaining_after_addition >= 0\n    \n    # Calculate the priority score\n    # A bin with more remaining capacity after adding the item gets lower priority\n    priorities = np.where(valid_bins, -remaining_after_addition, -np.inf)\n    \n    # Normalize the priorities to avoid extremely large or small values\n    priorities = priorities - np.max(priorities)\n    priorities = np.exp(priorities)\n    \n    return priorities",
    "response_id": 10,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 76.0,
    "mi": 82.48240259189015,
    "token_count": 100.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response11.txt_stdout.txt",
    "code_path": "problem_iter1_code11.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that can fit the item should have higher priority\n    can_fit = remaining_after_addition >= 0\n    \n    # Priority is a combination of how well the item fits and whether it can fit\n    priorities = np.where(can_fit, -np.abs(remaining_after_addition), -np.inf)\n    \n    # Normalize priorities to avoid overflow\n    priorities = priorities - np.max(priorities)\n    \n    # Return the priorities\n    return priorities",
    "response_id": 11,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 76.0,
    "mi": 82.48240259189015,
    "token_count": 100.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response12.txt_stdout.txt",
    "code_path": "problem_iter1_code12.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after placing the item in each bin\n    remaining_caps = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot accommodate the item\n    priorities = np.where(remaining_caps >= 0, -np.abs(remaining_caps - item), -1e6)\n    \n    # Give a slight preference to bins that are more filled\n    priorities += np.where(remaining_caps >= 0, bins_remain_cap / (bins_remain_cap.max() + 1e-6), 0)\n    \n    return priorities",
    "response_id": 12,
    "obj": 31.97048264858398,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 76.0,
    "mi": 82.48240259189015,
    "token_count": 100.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response13.txt_stdout.txt",
    "code_path": "problem_iter1_code13.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot fit the item\n    priorities = np.where(remaining_after_addition >= 0, \n                          bins_remain_cap - item,  # Priority is the remaining capacity after addition for valid bins\n                          -1e10)  # Very low priority for bins that cannot fit the item\n    \n    # To avoid choosing the bin with zero remaining capacity, slightly decrease the priority for bins that will be full after addition\n    priorities = np.where(remaining_after_addition == 0, priorities - 1, priorities)\n    \n    return priorities",
    "response_id": 13,
    "obj": 149.30195452732352,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 76.0,
    "mi": 82.48240259189015,
    "token_count": 100.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response14.txt_stdout.txt",
    "code_path": "problem_iter1_code14.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot hold the item\n    priorities = np.where(remaining_capacities >= 0, -np.abs(bins_remain_cap - item), -1e6)\n    \n    # Add a small noise to break ties\n    priorities += np.random.uniform(0, 1e-6, size=len(priorities))\n    \n    return priorities",
    "response_id": 14,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 76.0,
    "mi": 82.48240259189015,
    "token_count": 100.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response15.txt_stdout.txt",
    "code_path": "problem_iter1_code15.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that can fit the item should have higher priority\n    valid_bins = remaining_after_addition >= 0\n    \n    # For valid bins, the priority is inversely proportional to the remaining capacity after addition\n    # This encourages packing items tightly\n    priorities_valid = 1 / (1 + remaining_after_addition[valid_bins])\n    \n    # For invalid bins, assign a very low priority\n    priorities_invalid = np.zeros_like(remaining_after_addition[~valid_bins]) - 1e6\n    \n    # Combine priorities for valid and invalid bins\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    priorities[valid_bins] = priorities_valid\n    priorities[~valid_bins] = priorities_invalid\n    \n    return priorities",
    "response_id": 15,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 76.0,
    "mi": 82.48240259189015,
    "token_count": 100.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response16.txt_stdout.txt",
    "code_path": "problem_iter1_code16.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Create a mask to identify bins that have enough capacity for the item\n    valid_bins = remain_cap_after_add >= 0\n    \n    # For bins with enough capacity, the priority is the negative of the remaining capacity after adding the item\n    # This encourages packing into bins that are filled as much as possible\n    priorities = np.where(valid_bins, -remain_cap_after_add, -np.inf)\n    \n    # For bins without enough capacity, the priority is negative infinity, so they will not be selected\n    return priorities",
    "response_id": 16,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 76.0,
    "mi": 82.48240259189015,
    "token_count": 100.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response17.txt_stdout.txt",
    "code_path": "problem_iter1_code17.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    \n    This function calculates the priority score based on the remaining capacity \n    of each bin and the size of the item. The priority score is a combination \n    of the 'First-Fit Decreasing' and 'Best-Fit Decreasing' heuristics.\n    \n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Mask for bins that have enough capacity for the item\n    valid_bins = remaining_after_addition >= 0\n    \n    # Initialize priorities with a very low value for bins that cannot fit the item\n    priorities = np.where(valid_bins, remaining_after_addition, -1e10)\n    \n    # For bins that can fit the item, higher priority is given to those with less remaining capacity\n    priorities = np.where(valid_bins, -remaining_after_addition, priorities)\n    \n    # Add a small random noise to the priorities to avoid tie-breaks\n    priorities += np.random.uniform(0, 1e-6, size=len(bins_remain_cap))\n    \n    return priorities",
    "response_id": 17,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 76.0,
    "mi": 82.48240259189015,
    "token_count": 100.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response18.txt_stdout.txt",
    "code_path": "problem_iter1_code18.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot accommodate the item\n    priorities = np.where(remaining_after_addition >= 0, \n                          -np.abs(remaining_after_addition - np.mean(remaining_after_addition[remaining_after_addition >= 0])), \n                          -1e6)\n    \n    # Normalize the priorities to be between 0 and 1\n    min_priority = np.min(priorities)\n    max_priority = np.max(priorities)\n    priorities = (priorities - min_priority) / (max_priority - min_priority)\n    \n    return priorities",
    "response_id": 18,
    "obj": 60.62026326286399,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 76.0,
    "mi": 82.48240259189015,
    "token_count": 100.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response19.txt_stdout.txt",
    "code_path": "problem_iter1_code19.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # mask bins that cannot accommodate the item\n    valid_bins_mask = remaining_after_addition >= 0\n    \n    # for valid bins, the priority is inversely proportional to the remaining capacity after addition\n    # this encourages packing items tightly\n    priorities_valid_bins = 1 / (remaining_after_addition[valid_bins_mask] + 1e-6)\n    \n    # for invalid bins, assign a very low priority\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n    priorities[valid_bins_mask] = priorities_valid_bins\n    \n    return priorities",
    "response_id": 19,
    "obj": 4.198244914240141,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 76.0,
    "mi": 82.48240259189015,
    "token_count": 100.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response20.txt_stdout.txt",
    "code_path": "problem_iter1_code20.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_add = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot accommodate the item\n    priorities = np.where(remaining_after_add >= 0, bins_remain_cap - item, -1e9)\n    \n    # Normalize the priorities to emphasize the bins with the least remaining capacity\n    priorities = np.where(priorities != -1e9, priorities / bins_remain_cap, priorities)\n    \n    return priorities",
    "response_id": 20,
    "obj": 149.30195452732352,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 76.0,
    "mi": 82.48240259189015,
    "token_count": 100.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response21.txt_stdout.txt",
    "code_path": "problem_iter1_code21.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot hold the item\n    priorities = np.where(remaining_after_addition < 0, -np.inf, \n                          # For bins that can hold the item, prioritize those with the least remaining capacity\n                          # after adding the item (i.e., most full after addition)\n                          -remaining_after_addition / bins_remain_cap)\n    \n    return priorities",
    "response_id": 21,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 76.0,
    "mi": 82.48240259189015,
    "token_count": 100.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response22.txt_stdout.txt",
    "code_path": "problem_iter1_code22.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that can fit the item get a higher priority\n    valid_bins = remaining_after_addition >= 0\n    \n    # Prioritize bins that have just enough capacity for the item (First-Fit Decreasing inspiration)\n    priorities = np.where(valid_bins, -np.abs(remaining_after_addition), -np.inf)\n    \n    # To avoid division by zero, we add a small epsilon to the denominator\n    epsilon = 1e-6\n    ratios = item / (bins_remain_cap + epsilon)\n    log_ratios = np.log(ratios)\n    \n    # Combine the two strategies: prioritize bins that fit the item and have a smaller remaining capacity\n    priorities = np.where(valid_bins, -log_ratios, -np.inf)\n    \n    return priorities",
    "response_id": 22,
    "obj": 149.30195452732352,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 76.0,
    "mi": 82.48240259189015,
    "token_count": 100.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response23.txt_stdout.txt",
    "code_path": "problem_iter1_code23.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that can fit the item will have a positive remaining capacity\n    can_fit = remaining_after_addition >= 0\n    \n    # Prioritize bins that can fit the item\n    priorities = np.where(can_fit, remaining_after_addition, -np.inf)\n    \n    # Among bins that can fit the item, prioritize those with the least remaining capacity\n    # This is a \"best fit\" strategy, which tends to pack bins more tightly\n    return priorities",
    "response_id": 23,
    "obj": 149.30195452732352,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 76.0,
    "mi": 82.48240259189015,
    "token_count": 100.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response24.txt_stdout.txt",
    "code_path": "problem_iter1_code24.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using a more sophisticated heuristic.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity ratio after placing the item in each bin\n    remaining_ratios = (bins_remain_cap - item) / bins_remain_cap\n    \n    # Apply a penalty for bins that cannot accommodate the item\n    penalties = np.where(bins_remain_cap >= item, 0, -np.inf)\n    \n    # Prioritize bins that have a remaining capacity ratio closer to 0 (i.e., are more full after adding the item)\n    priorities = np.where(bins_remain_cap >= item, -np.abs(remaining_ratios - 0), penalties)\n    \n    # Add a small random noise to break ties\n    priorities += np.random.uniform(0, 1e-6, size=len(bins_remain_cap))\n    \n    return priorities",
    "response_id": 24,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 76.0,
    "mi": 82.48240259189015,
    "token_count": 100.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response25.txt_stdout.txt",
    "code_path": "problem_iter1_code25.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Set the priority to negative infinity for bins that cannot hold the item\n    priorities = np.where(remaining_after_addition < 0, -np.inf, remaining_after_addition)\n    \n    # Normalize the priorities to emphasize the bins with more remaining capacity\n    max_remaining = np.max(bins_remain_cap)\n    normalized_priorities = priorities / max_remaining\n    \n    # Add a small random noise to break ties\n    noise = np.random.uniform(0, 1e-6, size=len(bins_remain_cap))\n    priorities = normalized_priorities + noise\n    \n    return priorities",
    "response_id": 25,
    "obj": 149.30195452732352,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 76.0,
    "mi": 82.48240259189015,
    "token_count": 100.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response26.txt_stdout.txt",
    "code_path": "problem_iter1_code26.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that can fit the item should have higher priority\n    can_fit = remaining_after_addition >= 0\n    \n    # Prioritize bins that have just enough capacity for the item\n    priorities = np.where(can_fit, -np.abs(remaining_after_addition), -np.inf)\n    \n    # To avoid division by zero, we add a small value to bins_remain_cap before calculating the ratio\n    epsilon = 1e-8\n    ratios = item / (bins_remain_cap + epsilon)\n    \n    # Combine the two factors: the ability to fit the item and the ratio of item size to remaining capacity\n    priorities = np.where(can_fit, priorities + np.log(1 + 1 / ratios), priorities)\n    \n    return priorities",
    "response_id": 26,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 76.0,
    "mi": 82.48240259189015,
    "token_count": 100.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response27.txt_stdout.txt",
    "code_path": "problem_iter1_code27.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot accommodate the item\n    priorities = np.where(remaining_after_addition >= 0, \n                          # For bins that can accommodate the item, \n                          # prioritize those with the least remaining capacity\n                          -remaining_after_addition / bins_remain_cap, \n                          # For bins that cannot accommodate the item, assign a low priority\n                          -np.inf)\n    \n    return priorities",
    "response_id": 27,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 76.0,
    "mi": 82.48240259189015,
    "token_count": 100.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response28.txt_stdout.txt",
    "code_path": "problem_iter1_code28.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Mask out bins that cannot fit the item\n    valid_bins = remaining_after_addition >= 0\n    \n    # For valid bins, prioritize those with the least remaining capacity after addition\n    priorities = np.where(valid_bins, -remaining_after_addition, -np.inf)\n    \n    # Apply a slight penalty for bins that are almost full to encourage packing tightly\n    almost_full_bins = (bins_remain_cap < 2 * item) & valid_bins\n    priorities = np.where(almost_full_bins, priorities + 0.1, priorities)\n    \n    return priorities",
    "response_id": 28,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 76.0,
    "mi": 82.48240259189015,
    "token_count": 100.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response29.txt_stdout.txt",
    "code_path": "problem_iter1_code29.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    \n    # For bins that can accommodate the item, the priority is inversely proportional to the remaining capacity\n    # This encourages packing items into bins that are almost full\n    valid_bins = remaining_capacities >= 0\n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[valid_bins] = 1 / (1 + remaining_capacities[valid_bins])\n    \n    # For bins that cannot accommodate the item, the priority is negative and proportional to the item size\n    # relative to the bin's remaining capacity. This discourages using bins that are too small for the item\n    invalid_bins = ~valid_bins\n    priorities[invalid_bins] = -np.abs(item / remaining_capacities[invalid_bins])\n    \n    return priorities",
    "response_id": 29,
    "obj": 4.198244914240141,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 76.0,
    "mi": 82.48240259189015,
    "token_count": 100.0,
    "exec_success": true
  }
]