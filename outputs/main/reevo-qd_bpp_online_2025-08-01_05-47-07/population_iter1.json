[
  {
    "stdout_filepath": "problem_iter0_stdout0.txt",
    "code_path": "problem_iter0_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    return np.zeros_like(bins_remain_cap)",
    "response_id": 0,
    "obj": 4.487435181491823,
    "SLOC": 2.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response0.txt_stdout.txt",
    "code_path": "problem_iter1_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    This heuristic implements a Best-Fit-like strategy by prioritizing bins\n    that will have the least remaining capacity (tightest fit) after the item is placed.\n    Bins where the item does not fit are assigned the lowest possible priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity for each bin if the item were placed in it.\n    # A negative value indicates the item does not fit.\n    hypothetical_remaining = bins_remain_cap - item\n\n    # Initialize priority scores for all bins to a very low value (-infinity).\n    # This ensures that bins where the item does not fit will never be selected\n    # by argmax.\n    priority_scores = np.full_like(bins_remain_cap, -np.inf)\n\n    # Create a boolean mask for bins where the item actually fits (i.e.,\n    # hypothetical_remaining is non-negative).\n    fits_mask = hypothetical_remaining >= 0\n\n    # For bins where the item fits, assign a score based on the remaining capacity.\n    # To implement Best Fit, we want to select the bin that results in the\n    # *smallest* hypothetical_remaining value (tightest fit).\n    # Since np.argmax selects the maximum score, we negate the hypothetical_remaining.\n    # A smaller positive hypothetical_remaining (e.g., 0 for a perfect fit)\n    # will result in a larger score (e.g., 0). A larger positive\n    # hypothetical_remaining (e.g., 10) will result in a smaller score (e.g., -10).\n    priority_scores[fits_mask] = -hypothetical_remaining[fits_mask]\n\n    return priority_scores",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response1.txt_stdout.txt",
    "code_path": "problem_iter1_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin,\n    implementing a Best Fit strategy with a focus on maximizing fill efficiency.\n\n    This heuristic aims to place the item into the bin that will leave the\n    least remaining space after the item is placed. This is often effective\n    in online bin packing as it attempts to \"tighten\" existing bins,\n    reserving larger empty bins for potentially larger future items.\n\n    For each bin:\n    - If the item fits (item_size <= bin_remaining_capacity):\n      The priority score is calculated as `-(bin_remaining_capacity - item_size)`.\n      This transformation ensures that a smaller `(remaining_capacity - item_size)`\n      (meaning a tighter fit) results in a priority score closer to zero (i.e.,\n      a larger, less negative value), which will be picked as the \"highest\"\n      priority. An exact fit (remaining_capacity - item_size == 0) will yield\n      a priority of 0, which is the highest possible.\n    - If the item does not fit (item_size > bin_remaining_capacity):\n      The priority score is set to negative infinity (`-np.inf`), ensuring\n      these bins are never selected.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        The bin with the highest score should be chosen.\n    \"\"\"\n    # Initialize all priorities to negative infinity. Bins that don't fit\n    # will retain this score, making them ineligible.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Create a boolean mask for bins where the item can fit\n    can_fit_mask = bins_remain_cap >= item\n\n    # Calculate the remaining space if the item were placed in fitting bins\n    remaining_space_after_placement = bins_remain_cap[can_fit_mask] - item\n\n    # Assign priority scores for fitting bins based on the Best Fit principle.\n    # We want to minimize 'remaining_space_after_placement', so we negate it\n    # to convert the minimization problem into a maximization problem for\n    # priority scores (e.g., -0.1 > -0.5).\n    priorities[can_fit_mask] = -remaining_space_after_placement\n\n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response2.txt_stdout.txt",
    "code_path": "problem_iter1_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin based on the Best Fit heuristic.\n\n    The Best Fit heuristic places the item into the bin where it fits most snugly,\n    i.e., the bin that will have the smallest remaining capacity after the item is placed.\n    This aims to minimize wasted space and keep bins as full as possible.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Bins where the item does not fit will have a very low (negative infinity) score.\n        For bins where it fits, the score is the negative of the remaining space,\n        meaning a tighter fit (less remaining space) yields a higher (less negative) score.\n    \"\"\"\n    # Initialize scores with negative infinity. Bins where the item doesn't fit\n    # will keep this very low score, ensuring they are not chosen.\n    scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Find indices of bins where the item can actually fit\n    fitting_bins_mask = bins_remain_cap >= item\n\n    # Calculate the remaining capacity if the item were placed in the fitting bins\n    remaining_space_after_placement = bins_remain_cap[fitting_bins_mask] - item\n\n    # For fitting bins, assign a score based on the negative of the remaining space.\n    # This means:\n    # - A perfect fit (0 remaining space) gets a score of 0.\n    # - A tight fit (small positive remaining space) gets a small negative score.\n    # - A loose fit (large positive remaining space) gets a large negative score.\n    # By maximizing this score (which `np.argmax` does), we effectively minimize\n    # the remaining space, achieving the Best Fit strategy.\n    scores[fitting_bins_mask] = -remaining_space_after_placement\n\n    return scores",
    "response_id": 2,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response3.txt_stdout.txt",
    "code_path": "problem_iter1_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin,\n    implementing a Best Fit-like strategy.\n\n    This function prioritizes bins that will have the smallest remaining capacity\n    after the item is placed, aiming for the 'snug fit'. A perfect fit (0\n    remaining capacity) receives a very high priority score. For other bins\n    where the item fits but leaves some space, the priority is inversely\n    proportional to the remaining space (smaller space implies higher priority).\n    Bins where the item does not fit receive a priority score of 0.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    scores = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Step 1: Identify bins where the item can fit.\n    can_fit_mask = bins_remain_cap >= item\n\n    # If no bin can fit the item, return all zeros.\n    if not np.any(can_fit_mask):\n        return scores\n\n    # Calculate the remaining capacity if the item were placed in suitable bins.\n    # This array will only contain values for bins where can_fit_mask is True.\n    remaining_after_placement_for_fit_bins = bins_remain_cap[can_fit_mask] - item\n\n    # Step 2: Identify perfect fits (remaining capacity is 0).\n    # This mask refers to the indices within the 'can_fit_mask' subset.\n    perfect_fit_in_subset_mask = (remaining_after_placement_for_fit_bins == 0)\n\n    # Assign a very high score for perfect fits to ensure they are chosen first.\n    # Using a large constant like 1e10 ensures it's higher than any inverse value.\n    LARGE_PERFECT_FIT_SCORE = 1e10\n    \n    # Apply the perfect fit score to the corresponding bins in the original 'scores' array.\n    # We use can_fit_mask to index the original array, and then perfect_fit_in_subset_mask\n    # to select the specific ones that are perfect fits from that subset.\n    original_indices_of_perfect_fits = np.where(can_fit_mask)[0][perfect_fit_in_subset_mask]\n    scores[original_indices_of_perfect_fits] = LARGE_PERFECT_FIT_SCORE\n\n    # Step 3: Handle non-perfect fits (item fits, but remaining capacity > 0).\n    # This mask identifies bins in the original array that fit the item AND have space remaining.\n    non_perfect_fit_mask = (bins_remain_cap > item) # This implies can_fit_mask is also true\n    \n    # Only calculate scores for these bins.\n    remaining_non_perfect = bins_remain_cap[non_perfect_fit_mask] - item\n    \n    # Assign score based on the inverse of remaining space.\n    # A small epsilon is added to the denominator to prevent division by zero for\n    # very tiny positive floating-point remainders, and to ensure finite scores.\n    # This makes smaller remaining spaces result in higher priority scores.\n    EPSILON = 1e-9 \n    \n    scores[non_perfect_fit_mask] = 1.0 / (remaining_non_perfect + EPSILON)\n\n    return scores",
    "response_id": 3,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response4.txt_stdout.txt",
    "code_path": "problem_iter1_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin,\n    implementing a Best Fit (BF) strategy.\n\n    Prioritizes bins that can fit the item and would leave the least\n    remaining capacity after the item is placed (i.e., the \"tightest fit\").\n    Bins that cannot fit the item receive a very low priority (-np.inf),\n    ensuring they are never selected unless no other bin can fit the item.\n\n    The priority score is calculated as the negative of the remaining space\n    after placing the item. Thus, a smaller positive remaining space results\n    in a larger (closer to zero or positive) priority score, making it the\n    preferred choice. An exact fit results in a priority of 0, which is\n    the highest possible score for a valid bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priorities with a very low value for all bins.\n    # This ensures that bins which cannot fit the item will have the lowest priority.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Create a boolean mask for bins that can accommodate the item.\n    can_fit_mask = bins_remain_cap >= item\n\n    # Calculate the remaining capacity for only those bins that can fit the item.\n    # We want to minimize this remaining capacity (Best Fit).\n    # To convert this into a priority (where higher is better), we negate the value.\n    # For example:\n    #   - If remaining capacity is 1, priority is -1.\n    #   - If remaining capacity is 5, priority is -5.\n    #   - If remaining capacity is 0 (exact fit), priority is 0 (highest).\n    # Since -1 is greater than -5, this correctly prioritizes the \"tightest\" fit.\n    valid_bins_remaining_space = bins_remain_cap[can_fit_mask] - item\n    priorities[can_fit_mask] = -valid_bins_remaining_space\n\n    return priorities",
    "response_id": 4,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response5.txt_stdout.txt",
    "code_path": "problem_iter1_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin based on a Best Fit approach.\n\n    The \"Best Fit\" heuristic places an item into the bin that has the smallest\n    remaining capacity but is still large enough to hold the item. This strategy\n    aims to leave larger spaces in other bins for larger items or to pack bins as\n    densely as possible.\n\n    For this priority function:\n    - Bins where the item *cannot* fit receive a very low (negative infinity) priority.\n    - Bins where the item *can* fit receive a priority score equal to the negative of\n      the remaining capacity after placing the item. This way, a smaller remaining\n      capacity (which is desired for Best Fit) results in a priority score closer to zero\n      (or less negative), thus being higher. A perfect fit (0 remaining capacity)\n      gets the highest possible score of 0 among valid bins.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priorities for all bins.\n    # By default, set priority to negative infinity, implying the item cannot be placed.\n    # This ensures that bins where the item does not fit will never be chosen\n    # unless there are no other options (in which case, the main BPP algorithm\n    # should typically open a new bin).\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Create a boolean mask for bins where the item can actually fit.\n    can_fit_mask = bins_remain_cap >= item\n\n    # Calculate the remaining capacity in bins where the item can fit.\n    # For Best Fit, we want to minimize this value (bins_remain_cap - item).\n    # To convert this to a priority (higher is better), we take the negative.\n    # Example:\n    # - If item fits perfectly (capacity left = 0), priority = 0.\n    # - If item leaves small space (e.g., 0.1), priority = -0.1.\n    # - If item leaves large space (e.g., 0.5), priority = -0.5.\n    # 0 > -0.1 > -0.5, so higher priority corresponds to a tighter fit.\n    remaining_after_placement = bins_remain_cap[can_fit_mask] - item\n\n    # Assign the calculated priorities to the bins that can fit the item.\n    priorities[can_fit_mask] = -remaining_after_placement\n\n    return priorities",
    "response_id": 5,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response6.txt_stdout.txt",
    "code_path": "problem_iter1_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Implements a Best Fit (BF) heuristic by assigning higher priority to bins\n    that will have the smallest remaining capacity after the item is placed,\n    among those where the item fits. Bins where the item does not fit\n    receive a very low (negative infinity) priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity if the item were placed in each bin.\n    # For a perfect fit (remaining_cap == item), this would be 0.\n    potential_new_remaining_cap = bins_remain_cap - item\n\n    # Initialize priority scores as an array of negative infinities.\n    # This ensures that bins where the item does not fit will have\n    # the lowest possible priority.\n    priority_scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Create a boolean mask for bins where the item actually fits (i.e.,\n    # where the potential new remaining capacity is non-negative).\n    fits_mask = potential_new_remaining_cap >= 0\n\n    # For bins where the item fits:\n    # We want to assign a higher priority score to bins that result in a\n    # smaller 'potential_new_remaining_cap'.\n    # Multiplying by -1 achieves this: a smaller positive value of\n    # `potential_new_remaining_cap` becomes a larger (less negative) value\n    # when negated. For example, 0.1 becomes -0.1, and 0.5 becomes -0.5.\n    # Since np.argmax selects the largest value, -0.1 will be preferred over -0.5.\n    priority_scores[fits_mask] = -potential_new_remaining_cap[fits_mask]\n\n    return priority_scores",
    "response_id": 6,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response7.txt_stdout.txt",
    "code_path": "problem_iter1_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    This implementation uses a Best Fit heuristic: it prioritizes bins\n    that will have the smallest non-negative remaining capacity after the\n    item is placed. Bins where the item does not fit receive a very low priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of current remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Higher scores indicate a more desirable bin.\n    \"\"\"\n    # Calculate the remaining capacity if the item were hypothetically placed in each bin.\n    # This also naturally handles cases where the item does not fit, resulting in negative values.\n    potential_remaining_cap = bins_remain_cap - item\n\n    # Initialize priority scores for all bins to a very low value.\n    # Bins that cannot fit the item will retain this -np.inf score.\n    priority_scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Create a boolean mask for bins where the item can actually fit.\n    fitting_bins_mask = potential_remaining_cap >= 0\n\n    # For bins where the item fits, calculate the priority score.\n    # The Best Fit strategy aims to minimize the remaining space.\n    # To convert this minimization into a maximization problem (for priority scores),\n    # we negate the potential_remaining_cap.\n    #\n    # Examples:\n    # - If potential_remaining_cap is 0.0 (perfect fit), priority is 0.0 (highest).\n    # - If potential_remaining_cap is 0.1 (small leftover), priority is -0.1.\n    # - If potential_remaining_cap is 0.5 (large leftover), priority is -0.5.\n    # This ensures that smaller non-negative remainders yield higher (less negative) priority scores.\n    priority_scores[fitting_bins_mask] = -potential_remaining_cap[fitting_bins_mask]\n\n    return priority_scores",
    "response_id": 7,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response8.txt_stdout.txt",
    "code_path": "problem_iter1_code8.py",
    "code": "import numpy as np\nimport sys\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    This version implements a Modified Best-Fit strategy with a preference for\n    bins with lower indices (older/more \"settled\" bins).\n\n    The core idea is:\n    1. **Best Fit Principle:** Prioritize bins that result in the smallest remaining capacity\n       after the item is placed. This minimizes wasted space within a bin and encourages\n       bins to be filled completely. A perfect fit (0 remaining capacity) receives the highest score.\n       Score contribution: `-(bins_remain_cap - item)`.\n       (Smaller positive remaining capacity leads to a higher, less negative score).\n    2. **Positional Bias (Tie-breaker/Preference):** Add a slight positive bias to bins\n       with lower indices. This means if two or more bins offer an equally good \"Best Fit\",\n       the one that was \"opened\" earlier (lower index) will be preferred. This can help\n       in consistently closing off earlier bins.\n       Score contribution: `alpha * (num_bins - 1 - bin_index)`.\n\n    Bins where the item cannot fit receive a very low priority to ensure they are never selected.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    num_bins = len(bins_remain_cap)\n    \n    # Calculate potential remaining capacity if the item is placed into each bin.\n    # A smaller positive potential_rem_cap means a tighter, more efficient fit.\n    potential_rem_cap = bins_remain_cap - item\n\n    # Base Best-Fit scores: Maximize -potential_rem_cap.\n    # If potential_rem_cap is 0 (perfect fit), score is 0.\n    # If potential_rem_cap is 0.1, score is -0.1.\n    # If potential_rem_cap is 0.5, score is -0.5.\n    # So, higher score means better (smaller positive) remaining capacity.\n    base_scores = -potential_rem_cap\n\n    # Add a positional bias to favor bins with lower indices.\n    # This acts as a tie-breaker for equally good best fits, or a slight preference.\n    # alpha should be a small positive constant. It needs to be small enough\n    # not to disrupt the Best Fit primary sorting, but large enough to break ties.\n    # A value like 0.001 ensures it's usually less than typical differences\n    # in remaining capacities (assuming capacities are floats like 0.1, 0.05 etc.).\n    alpha = 0.001 \n    \n    # Create an array of indices [0, 1, ..., num_bins-1]\n    bin_indices = np.arange(num_bins)\n    \n    # Calculate the bias term:\n    # (num_bins - 1 - bin_index) ensures that bin_indices[0] (the first bin)\n    # gets the largest positive bias (alpha * (num_bins - 1)), and\n    # bin_indices[num_bins-1] (the last bin) gets the smallest bias (alpha * 0).\n    bin_index_bias = alpha * (num_bins - 1 - bin_indices)\n\n    # Combine the Best-Fit score with the positional bias.\n    priorities = base_scores + bin_index_bias\n    \n    # Identify bins where the item cannot fit (remaining capacity is less than item size).\n    can_fit_mask = bins_remain_cap >= item\n    \n    # Assign a very low priority to bins where the item cannot fit.\n    # This ensures these bins are never selected as long as there's a valid option.\n    # Using -sys.float_info.max ensures it's the absolute lowest float value.\n    min_priority_val = -sys.float_info.max\n    priorities[~can_fit_mask] = min_priority_val\n\n    return priorities",
    "response_id": 8,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response9.txt_stdout.txt",
    "code_path": "problem_iter1_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This strategy, 'Targeted Remaining Capacity Fit', aims to find a bin\n    such that after placing the item, the bin's remaining capacity (slack)\n    is as close as possible to a predefined 'target slack'.\n    \n    The 'target slack' is defined as a small fraction of the item's size.\n    This heuristic attempts to balance two objectives:\n    1. Fill bins efficiently (similar to Best Fit) by minimizing remaining space.\n    2. Avoid creating excessively tiny, potentially unusable gaps, or leaving bins\n       too full, by aiming for a \"just right\" amount of remaining space that might\n       be useful for future, possibly small, items.\n\n    Bins that cannot accommodate the item receive the lowest possible priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize all priorities to a very low value (negative infinity)\n    # This ensures that bins where the item does not fit are never chosen.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify which bins can accommodate the item\n    can_fit = bins_remain_cap >= item\n\n    # Calculate the remaining capacity in each fitting bin after placing the item\n    remaining_after_placement = bins_remain_cap[can_fit] - item\n\n    # Define a 'target slack' for the remaining capacity.\n    # This factor is a heuristic choice; 0.0 would revert to a pure Best Fit.\n    # A positive factor biases towards leaving a small, specific amount of slack.\n    TARGET_SLACK_FACTOR = 0.05  # Aim to leave 5% of the item's size as remaining capacity\n    TARGET_SLACK = TARGET_SLACK_FACTOR * item\n\n    # If item is zero (or very small near float precision limit), set target slack to zero\n    # to avoid numerical issues or unreasonable targets for tiny items.\n    if item <= np.finfo(float).eps:\n        TARGET_SLACK = 0.0\n\n    # The priority score is the negative of the absolute difference\n    # between the actual remaining capacity and the target slack.\n    # A smaller absolute difference results in a higher (less negative) priority score.\n    priorities[can_fit] = -np.abs(remaining_after_placement - TARGET_SLACK)\n\n    return priorities",
    "response_id": 9,
    "obj": 4.4674910251296325,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  }
]