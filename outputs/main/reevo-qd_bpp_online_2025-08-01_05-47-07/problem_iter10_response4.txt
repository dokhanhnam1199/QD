```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.
    This heuristic greedily minimizes wasted space by prioritizing:
    1. Perfect fits: Bins where the item exactly fills the remaining capacity.
    2. Best fits: Among bins where the item fits, choose the one that leaves
       the smallest positive remaining capacity (tightest fit).
    Bins where the item does not fit are assigned the lowest possible priority.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Calculate the remaining capacity for each bin if the item were placed in it.
    # A negative value indicates the item does not fit.
    hypothetical_remaining = bins_remain_cap - item

    # Initialize priority scores for all bins to a very low value (-infinity).
    # This ensures that bins where the item does not fit (hypothetical_remaining < 0)
    # will never be selected by argmax, effectively avoiding invalid placements.
    priority_scores = np.full_like(bins_remain_cap, -np.inf)

    # Define a high score for perfect fits. This value must be significantly
    # larger than any score generated by the Best-Fit part of the heuristic
    # (which produces non-positive scores, typically between -BIN_CAPACITY and 0).
    HIGH_PERFECT_FIT_SCORE = 1e9

    # 1. Identify and prioritize perfect fits.
    # A perfect fit occurs when hypothetical_remaining is exactly 0.
    perfect_fits_mask = (hypothetical_remaining == 0)
    priority_scores[perfect_fits_mask] = HIGH_PERFECT_FIT_SCORE

    # 2. For bins where the item fits but not perfectly, apply Best Fit.
    # This means selecting the bin that results in the *smallest positive*
    # hypothetical_remaining value (tightest fit).
    # We negate hypothetical_remaining because np.argmax selects the maximum score,
    # and we want to select the bin with the smallest positive remaining capacity.
    # The condition `hypothetical_remaining > 0` ensures the item fits and
    # it's not a perfect fit.
    best_fit_mask = (hypothetical_remaining > 0)
    priority_scores[best_fit_mask] = -hypothetical_remaining[best_fit_mask]

    return priority_scores
```
