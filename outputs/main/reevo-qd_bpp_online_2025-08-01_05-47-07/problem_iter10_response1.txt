```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.
    This heuristic explicitly prioritizes perfect fits (using a numerical tolerance).
    If no perfect fit is available, it then applies a Best-Fit strategy by prioritizing
    bins that will have the least remaining capacity (tightest fit) after the item is placed.
    Bins where the item does not fit are assigned the lowest possible priority.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Calculate the remaining capacity for each bin if the item were placed in it.
    # A negative value indicates the item would exceed the bin's capacity.
    hypothetical_remaining = bins_remain_cap - item

    # Initialize priority scores for all bins to a very low value (-infinity).
    # This ensures that bins where the item does not fit (or would result in negative capacity)
    # will never be selected by argmax.
    priority_scores = np.full_like(bins_remain_cap, -np.inf)

    # Define a high score for perfect fits to ensure they are chosen first.
    # This value must be significantly larger than any score generated by the
    # Best-Fit part of the heuristic (which produces non-positive scores).
    HIGH_PERFECT_FIT_SCORE = 1e9

    # Define a small tolerance for floating point comparisons.
    # This is crucial if item sizes or capacities might be floats
    # and exact equality checks (== 0) are problematic due to precision.
    TOLERANCE = 1e-9 # A common epsilon for float comparisons.

    # 1. Identify bins where the item genuinely fits.
    # This means the hypothetical remaining capacity must be non-negative.
    # We strictly ensure item <= capacity here, no negative remaining capacity from "fitting".
    fits_mask = hypothetical_remaining >= 0

    # 2. For bins where the item fits, apply the Best-Fit strategy.
    # Best-Fit aims to minimize the remaining capacity (tightest fit).
    # To achieve this with `np.argmax` (which selects the maximum score),
    # we negate the hypothetical_remaining. A smaller positive remaining capacity
    # (e.g., 0.1) will result in a less negative score (-0.1) than a larger one (e.g., 10 -> -10).
    # This correctly prioritizes tighter fits.
    priority_scores[fits_mask] = -hypothetical_remaining[fits_mask]

    # 3. Explicitly boost priority for perfect fits.
    # A perfect fit is when the remaining capacity is effectively zero, considering float tolerance.
    perfect_fits_mask = np.isclose(hypothetical_remaining, 0, atol=TOLERANCE)

    # Apply the high perfect fit score only to bins that actually fit AND are perfect fits.
    # This prevents giving a high score to bins where the item is slightly too large (e.g., -1e-10 remaining).
    truly_perfect_fits_mask = np.logical_and(fits_mask, perfect_fits_mask)
    priority_scores[truly_perfect_fits_mask] = HIGH_PERFECT_FIT_SCORE

    return priority_scores
```
