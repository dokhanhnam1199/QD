[
  {
    "stdout_filepath": "problem_iter0_stdout0.txt",
    "code_path": "problem_iter0_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    return np.zeros_like(bins_remain_cap)",
    "response_id": 0,
    "obj": 4.487435181491823,
    "SLOC": 2.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response0.txt_stdout.txt",
    "code_path": "problem_iter1_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    This heuristic implements a Best-Fit-like strategy by prioritizing bins\n    that will have the least remaining capacity (tightest fit) after the item is placed.\n    Bins where the item does not fit are assigned the lowest possible priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity for each bin if the item were placed in it.\n    # A negative value indicates the item does not fit.\n    hypothetical_remaining = bins_remain_cap - item\n\n    # Initialize priority scores for all bins to a very low value (-infinity).\n    # This ensures that bins where the item does not fit will never be selected\n    # by argmax.\n    priority_scores = np.full_like(bins_remain_cap, -np.inf)\n\n    # Create a boolean mask for bins where the item actually fits (i.e.,\n    # hypothetical_remaining is non-negative).\n    fits_mask = hypothetical_remaining >= 0\n\n    # For bins where the item fits, assign a score based on the remaining capacity.\n    # To implement Best Fit, we want to select the bin that results in the\n    # *smallest* hypothetical_remaining value (tightest fit).\n    # Since np.argmax selects the maximum score, we negate the hypothetical_remaining.\n    # A smaller positive hypothetical_remaining (e.g., 0 for a perfect fit)\n    # will result in a larger score (e.g., 0). A larger positive\n    # hypothetical_remaining (e.g., 10) will result in a smaller score (e.g., -10).\n    priority_scores[fits_mask] = -hypothetical_remaining[fits_mask]\n\n    return priority_scores",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response0.txt_stdout.txt",
    "code_path": "problem_iter2_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    This implementation extends the Best Fit heuristic (v1) by introducing a\n    strategic approach to remaining capacities, aiming to \"optimize future bin state\n    to minimize overall waste\" by being smart about leftover space.\n\n    It prioritizes bins based on the following hierarchy:\n    1.  **Perfect Fit**: Highest priority (remaining capacity is 0). This fully utilizes a bin,\n        effectively \"closing\" it and preventing fragmentation.\n    2.  **Avoid Small Fragments**: Lowest priority for bins that would be left with a very small,\n        non-zero remaining capacity. These are considered \"dead space\" or hard-to-use fragments,\n        which contribute to overall waste by making bins appear partially full but practically unusable.\n    3.  **Best Fit for Others**: For all other cases where the item fits (i.e., not a perfect fit\n        and not a \"small fragment\"), it prefers bins that leave a smaller positive remainder.\n        This follows the Best Fit principle of packing tightly.\n\n    This heuristic tries to consolidate items efficiently while avoiding the creation of\n    small, unusable gaps that contribute to overall waste.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of current remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Higher scores indicate a more desirable bin.\n    \"\"\"\n    # Define thresholds for remaining capacity types.\n    # EPSILON_FOR_ZERO: A very small number to account for floating point inaccuracies\n    #                   when checking if a remaining capacity is effectively zero.\n    # SMALL_REMAINDER_THRESHOLD: Defines what constitutes a \"very small\" or \"dead\" remaining space.\n    #                            This value might need tuning based on the typical range of item sizes\n    #                            and bin capacity. For normalized items/bins (0 to 1), 0.05 is a\n    #                            reasonable starting point, meaning remnants less than 5% of bin cap\n    #                            are considered \"dead space\".\n    EPSILON_FOR_ZERO = 1e-9 \n    SMALL_REMAINDER_THRESHOLD = 0.05\n\n    # Calculate the remaining capacity if the item were hypothetically placed in each bin.\n    potential_remaining_cap = bins_remain_cap - item\n\n    # Initialize priority scores for all bins.\n    # Bins where the item does not fit will retain a very low priority (-np.inf).\n    priority_scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify bins where the item can fit.\n    # Allow for a very tiny negative due to floating point precision, treating it as 0.\n    fitting_bins_mask = potential_remaining_cap >= -EPSILON_FOR_ZERO\n\n    # Extract potential remaining capacities for only the fitting bins.\n    fitting_caps_actual = potential_remaining_cap[fitting_bins_mask]\n\n    # Initialize scores for fitting bins using the standard Best Fit approach (negative of remainder).\n    # This means smaller positive remainders get higher (less negative) scores.\n    fitting_scores = -fitting_caps_actual\n\n    # Apply specific rules for different types of remainders:\n\n    # 1. Perfect Fit (remaining capacity is zero or very close to it)\n    perfect_fit_mask = np.isclose(fitting_caps_actual, 0.0, atol=EPSILON_FOR_ZERO)\n    # Assign a very high score to perfect fits to ensure they are always chosen first.\n    fitting_scores[perfect_fit_mask] = float('inf')\n\n    # 2. Small, Non-Zero Remainder (considered \"dead space\")\n    # This applies to capacities that are greater than zero but below the threshold.\n    small_remainder_mask = (fitting_caps_actual > EPSILON_FOR_ZERO) & \\\n                           (fitting_caps_actual < SMALL_REMAINDER_THRESHOLD)\n    # Assign a very low score to discourage leaving such small, potentially unusable gaps.\n    fitting_scores[small_remainder_mask] = -float('inf')\n\n    # For all other fitting bins (those with larger, \"useful\" remaining capacities),\n    # the initial Best Fit scoring (`-fitting_caps_actual`) remains,\n    # ensuring that among these, smaller remainders are still preferred.\n\n    # Assign the calculated fitting scores back to the main priority_scores array.\n    priority_scores[fitting_bins_mask] = fitting_scores\n\n    return priority_scores",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response0.txt_stdout.txt",
    "code_path": "problem_iter3_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    This heuristic implements a Best-Fit strategy by prioritizing bins\n    that will have the least remaining capacity (tightest fit) after the item is placed.\n    Bins where the item does not fit are assigned the lowest possible priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity for each bin if the item were placed in it.\n    # A negative value indicates the item does not fit.\n    hypothetical_remaining = bins_remain_cap - item\n\n    # Assign priority scores directly using np.where.\n    # If the item fits (hypothetical_remaining >= 0), the score is the negative\n    # of the remaining capacity. This means smaller remaining capacities (tighter fits)\n    # yield higher scores (e.g., 0 for a perfect fit, -5 for 5 units remaining).\n    # If the item does not fit, assign a very low priority score (-np.inf)\n    # to ensure it's never selected.\n    priority_scores = np.where(\n        hypothetical_remaining >= 0,\n        -hypothetical_remaining,\n        -np.inf\n    )\n\n    return priority_scores",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response1.txt_stdout.txt",
    "code_path": "problem_iter4_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    This heuristic implements a Best-Fit-like strategy by prioritizing bins\n    that will have the least remaining capacity (tightest fit) after the item is placed.\n    Bins where the item does not fit are assigned the lowest possible priority.\n\n    This improved version leverages `np.where` for more concise and explicit\n    conditional assignment of priority scores, clearly separating the logic for\n    bins where the item fits versus where it doesn't. It reinforces the 'minimal\n    waste' objective by giving higher scores to bins that result in smaller\n    remaining capacities.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity for each bin if the item were hypothetically placed.\n    hypothetical_remaining = bins_remain_cap - item\n\n    # Assign priority scores using np.where for clear conditional logic:\n    # - If the item fits (hypothetical_remaining is non-negative), the score is\n    #   the negative of the hypothetical remaining capacity. This means smaller\n    #   remaining capacities (tighter fits, less \"waste\") result in higher\n    #   (less negative, closer to zero) priority scores, aligning with Best Fit.\n    # - If the item does not fit (hypothetical_remaining is negative), assign\n    #   a very low priority (-np.inf) to ensure these bins are never selected.\n    priority_scores = np.where(\n        hypothetical_remaining >= 0,\n        -hypothetical_remaining,\n        -np.inf\n    )\n\n    return priority_scores",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 19.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response0.txt_stdout.txt",
    "code_path": "problem_iter5_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add an item to each bin.\n    This heuristic implements a Best-Fit-like strategy that strongly prioritizes\n    perfect fits. For cases that are not perfect fits, it falls back to the\n    standard Best Fit approach (minimizing remaining capacity).\n    The design addresses the \"Prior reflection\" by:\n    1. Prioritizing Best Fit for immediate utilization by preferring tighter fits.\n    2. Rewarding perfect fits with an exceptionally high score to \"fill bins\".\n    3. Implicitly \"penalizing small fragments\" by making perfect fits vastly\n       more attractive than any non-perfect fit, even those that result in a\n       very small remaining capacity. The value of a perfectly utilized bin\n       outweighs the marginal benefit of a very small (but non-zero) fragment.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity for each bin if the item were placed in it.\n    # A negative value indicates the item does not fit.\n    hypothetical_remaining = bins_remain_cap - item\n\n    # Initialize priority scores for all bins to a very low value (-infinity).\n    # This ensures that bins where the item does not fit (hypothetical_remaining < 0)\n    # will never be selected by argmax, as their score will remain -np.inf.\n    priority_scores = np.full_like(bins_remain_cap, -np.inf)\n\n    # --- Step 1: Identify and assign scores for perfect fits ---\n    # A perfect fit leaves exactly 0 capacity remaining.\n    perfect_fit_mask = hypothetical_remaining == 0\n\n    # Assign a very high positive score for perfect fits. This score must be\n    # guaranteed to be higher than any possible score from a non-perfect fit.\n    # If bins_remain_cap is empty, max_bin_capacity would be invalid, handle this.\n    if bins_remain_cap.size > 0:\n        # A score derived from the max bin capacity ensures it's relative to the problem scale\n        # and sufficiently large to dominate any negative scores from non-perfect fits.\n        perfect_fit_value = np.max(bins_remain_cap) + 1.0\n    else:\n        # If there are no bins, the specific value doesn't matter, but set a default.\n        perfect_fit_value = 1.0 \n\n    priority_scores[perfect_fit_mask] = perfect_fit_value\n\n    # --- Step 2: Handle bins where the item fits but is not a perfect fit ---\n    # These are bins where hypothetical_remaining is positive (0 < hypothetical_remaining <= original_capacity).\n    non_perfect_fit_mask = (hypothetical_remaining > 0)\n\n    # For these bins, implement the Best Fit strategy: prioritize bins that result\n    # in the smallest remaining capacity. To do this with np.argmax (which selects\n    # the maximum score), we negate the hypothetical_remaining.\n    # These scores will be negative (or zero if hypothetical_remaining is very small,\n    # but still less than 1), ensuring that perfect fits (with their large positive score)\n    # are always preferred over any non-perfect fit.\n    priority_scores[non_perfect_fit_mask] = -hypothetical_remaining[non_perfect_fit_mask]\n\n    return priority_scores",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 14.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response0.txt_stdout.txt",
    "code_path": "problem_iter6_code0.py",
    "code": "import numpy as np\n\n# Assume a standard bin size for the Bin Packing Problem.\n# In many contexts, items and bin capacities are normalized, so 1.0 is a common default.\n# If specific problem constraints dictate a different size (e.g., integer capacities),\n# this constant should be adjusted accordingly or passed as an argument.\nBIN_SIZE = 1.0\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add an item to each bin.\n\n    This heuristic refines the Best-Fit strategy by introducing a subtle bias\n    towards using partially-filled bins over completely empty (newly-opened) bins.\n    The primary goal remains to achieve a tight fit (minimize waste), but if\n    multiple bins offer similar levels of tightness, this strategy nudges the\n    selection towards bins that are already in use. This can help consolidate\n    items and potentially reduce the total number of bins utilized.\n\n    Bins where the item does not fit are assigned the lowest possible priority (-inf).\n\n    Args:\n        item: Size of the item to be added to a bin.\n        bins_remain_cap: NumPy array of remaining capacities for each bin.\n                         Assumes `BIN_SIZE` (defaulting to 1.0) is the full\n                         capacity of an empty bin for identification purposes.\n\n    Return:\n        NumPy array of the same size as `bins_remain_cap`, containing the\n        priority score for each bin. The bin with the highest score is preferred.\n    \"\"\"\n    # Calculate the remaining capacity for each bin if the item were hypothetically placed.\n    hypothetical_remaining = bins_remain_cap - item\n\n    # Step 1: Calculate the base priority based on a Best-Fit strategy.\n    # A smaller hypothetical remaining capacity (tighter fit, less waste)\n    # results in a higher (less negative) priority score.\n    base_priority_scores = -hypothetical_remaining\n\n    # Step 2: Initialize priority scores, setting non-fitting bins to -np.inf.\n    # This ensures that bins where the item does not fit are never selected.\n    priority_scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # A mask to identify bins where the item actually fits (i.e., hypothetical_remaining is non-negative).\n    fits_mask = hypothetical_remaining >= 0\n\n    # Apply the base Best-Fit priority to the bins where the item fits.\n    priority_scores[fits_mask] = base_priority_scores[fits_mask]\n\n    # Step 3: Refinement - Introduce a penalty for using completely empty bins.\n    # This encourages filling partially used bins first, provided the fit quality\n    # is comparable, aiming to defer the opening of new bins.\n\n    # Identify bins that are currently completely empty. Use a small epsilon for robust\n    # floating-point comparison, as capacities can be floats.\n    EPSILON = 1e-9\n    is_empty_bin = np.isclose(bins_remain_cap, BIN_SIZE, atol=EPSILON)\n\n    # Define a small penalty value. This value should be small enough that it\n    # doesn't override a significantly better Best-Fit in an empty bin,\n    # but large enough to break ties or influence very close choices.\n    PENALTY_FOR_EMPTY_BIN = -0.001  # A small negative value\n\n    # Apply the penalty only to empty bins that the item can fit into.\n    # This slightly reduces their priority, making them less attractive than\n    # a partially-filled bin with a very similar resulting remaining capacity.\n    empty_bins_that_fit_mask = is_empty_bin & fits_mask\n    priority_scores[empty_bins_that_fit_mask] += PENALTY_FOR_EMPTY_BIN\n\n    return priority_scores",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter7_response0.txt_stdout.txt",
    "code_path": "problem_iter7_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    This heuristic explicitly prioritizes perfect fits by assigning a very high score.\n    If no perfect fit is available, it then applies a Best-Fit strategy by prioritizing\n    bins that will have the least remaining capacity (tightest fit) after the item is placed.\n    Bins where the item does not fit are assigned the lowest possible priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity for each bin if the item were placed in it.\n    # A negative value indicates the item does not fit.\n    hypothetical_remaining = bins_remain_cap - item\n\n    # Initialize priority scores for all bins to a very low value (-infinity).\n    # This ensures that bins where the item does not fit will never be selected\n    # by argmax.\n    priority_scores = np.full_like(bins_remain_cap, -np.inf)\n\n    # Define a high score for perfect fits to ensure they are chosen first.\n    # This value must be significantly larger than any score generated by the\n    # Best-Fit part of the heuristic (which produces non-positive scores).\n    HIGH_PERFECT_FIT_SCORE = 1e9\n\n    # 1. Identify and prioritize perfect fits.\n    # A perfect fit occurs when hypothetical_remaining is exactly 0.\n    perfect_fits_mask = hypothetical_remaining == 0\n    priority_scores[perfect_fits_mask] = HIGH_PERFECT_FIT_SCORE\n\n    # 2. For bins where the item fits but not perfectly, apply Best Fit.\n    # This means selecting the bin that results in the *smallest positive*\n    # hypothetical_remaining value (tightest fit).\n    # Since np.argmax selects the maximum score, we negate the hypothetical_remaining.\n    # We only consider bins where the item fits and is NOT a perfect fit.\n    non_perfect_fits_mask = np.logical_and(hypothetical_remaining > 0, hypothetical_remaining >= 0) # The second part is redundant but explicit\n    priority_scores[non_perfect_fits_mask] = -hypothetical_remaining[non_perfect_fits_mask]\n\n    return priority_scores",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response0.txt_stdout.txt",
    "code_path": "problem_iter8_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    This heuristic implements a Best-Fit strategy, prioritizing bins that\n    will have the least remaining capacity (tightest fit) after the item is placed.\n    It improves upon v1 by scaling the priority scores for valid bins to be\n    non-negative, where higher scores always indicate a better (tighter) fit.\n    Bins where the item does not fit are assigned the lowest possible priority (-np.inf).\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity for each bin if the item were placed in it.\n    # A negative value indicates the item does not fit.\n    hypothetical_remaining = bins_remain_cap - item\n\n    # Create a boolean mask for bins where the item actually fits (remaining capacity is non-negative).\n    can_fit_mask = hypothetical_remaining >= 0\n\n    # Initialize all priority scores to -np.inf. This ensures bins where the item doesn't fit\n    # are never selected.\n    priority_scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Only process bins where the item can fit\n    if np.any(can_fit_mask):\n        # Extract the hypothetical remaining capacities for only the bins that can fit the item.\n        valid_hypothetical_remaining = hypothetical_remaining[can_fit_mask]\n\n        # Determine the maximum remaining capacity among all bins where the item fits.\n        # This value represents the \"loosest\" valid fit, or the maximum possible\n        # remaining space if an item is placed in a valid bin.\n        # We use this to scale our scores. A perfect fit (0 remaining) will get\n        # the highest score, which is this max_valid_remaining_capacity.\n        max_valid_remaining_capacity = np.max(valid_hypothetical_remaining)\n\n        # Assign priority scores for valid bins:\n        # The score is calculated as (max_valid_remaining_capacity - current_hypothetical_remaining).\n        # This means:\n        # - A perfect fit (hypothetical_remaining = 0) gets the highest score (equal to max_valid_remaining_capacity).\n        # - The \"loosest\" valid fit (hypothetical_remaining = max_valid_remaining_capacity) gets a score of 0.\n        # - All other valid fits get scores between 0 and max_valid_remaining_capacity.\n        # This ensures that higher scores always represent tighter fits, and all valid scores are non-negative.\n        priority_scores[can_fit_mask] = max_valid_remaining_capacity - valid_hypothetical_remaining\n\n    return priority_scores",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 18.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response0.txt_stdout.txt",
    "code_path": "problem_iter9_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    This heuristic refines the Best-Fit strategy by giving an overwhelmingly\n    high priority to perfect fits, ensuring they are always selected first.\n    For non-perfect fits, it falls back to a tightest-fit (Best-Fit) strategy.\n    This explicitly rewards full bin utilization and minimizes wasted space,\n    while addressing \"arbitrary or poor quality outcomes\" by making the\n    optimal perfect fit choice numerically distinct and highly preferred.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity for each bin if the item were placed in it.\n    # A negative value indicates the item does not fit.\n    hypothetical_remaining = bins_remain_cap - item\n\n    # Initialize priority scores for all bins to a very low value (-infinity).\n    # This ensures that bins where the item does not fit will never be selected.\n    priority_scores = np.full_like(bins_remain_cap, -np.inf)\n\n    # Create a boolean mask for bins where the item actually fits (i.e.,\n    # hypothetical_remaining is non-negative).\n    fits_mask = hypothetical_remaining >= 0\n\n    # For bins where the item fits, assign a score based on the remaining capacity.\n    # To implement a Best-Fit-like strategy, we want to select the bin that results\n    # in the *smallest* hypothetical_remaining value (tightest fit).\n    # Since np.argmax selects the maximum score, we negate the hypothetical_remaining.\n    # A smaller positive hypothetical_remaining (e.g., 0.01) will result in a\n    # larger score (e.g., -0.01).\n    priority_scores[fits_mask] = -hypothetical_remaining[fits_mask]\n\n    # **Improvement for v2: Explicitly boost perfect fits.**\n    # This directly addresses \"rewarding full bin utilization\" by making\n    # a perfect fit (hypothetical_remaining == 0) unequivocally the highest priority.\n    # While v1 already made 0 the highest possible score for fitting bins,\n    # this makes its numerical priority significantly higher than any non-zero tight fit,\n    # reinforcing its optimality and avoiding any \"arbitrary\" tie-breaking if floating point\n    # precision were to make a very small positive remnant score equal to a perfect fit score\n    # (though unlikely with standard floats, it makes the intent clear and robust).\n    perfect_fit_mask = (hypothetical_remaining == 0)\n\n    # Determine a bonus value that is guaranteed to be larger than any possible\n    # negative score derived from -hypothetical_remaining.\n    # The maximum possible value for hypothetical_remaining (when fitting)\n    # would be the original bin capacity (if item is very small).\n    # So, a bonus slightly larger than the maximum bin capacity ensures this.\n    if bins_remain_cap.size > 0:\n        PERFECT_FIT_BONUS = np.max(bins_remain_cap) + 1.0\n    else:\n        # Fallback for empty bins_remain_cap array (though it should not happen in typical BPP)\n        PERFECT_FIT_BONUS = 1000.0 \n    \n    priority_scores[perfect_fit_mask] = PERFECT_FIT_BONUS\n\n    return priority_scores",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 16.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response0.txt_stdout.txt",
    "code_path": "problem_iter10_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    This heuristic extends the Best-Fit strategy by giving a significantly higher\n    priority to bins where the item fits perfectly, resulting in zero remaining capacity.\n    For other valid bins, it still prioritizes the tightest fit (least remaining capacity).\n    Bins where the item does not fit are assigned the lowest possible priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity for each bin if the item were placed in it.\n    # A negative value indicates the item does not fit.\n    hypothetical_remaining = bins_remain_cap - item\n\n    # Initialize priority scores for all bins to a very low value (-infinity).\n    # This ensures that bins where the item does not fit will never be selected\n    # by argmax.\n    priority_scores = np.full_like(bins_remain_cap, -np.inf)\n\n    # Create a boolean mask for bins where the item actually fits (i.e.,\n    # hypothetical_remaining is non-negative).\n    fits_mask = hypothetical_remaining >= 0\n\n    # For bins where the item fits, assign a score based on the remaining capacity.\n    # To implement Best Fit, we want to select the bin that results in the\n    # *smallest* hypothetical_remaining value (tightest fit).\n    # Since np.argmax selects the maximum score, we negate the hypothetical_remaining.\n    # A smaller positive hypothetical_remaining (e.g., 0 for a perfect fit)\n    # will result in a larger score (e.g., 0). A larger positive\n    # hypothetical_remaining (e.g., 10) will result in a smaller score (e.g., -10).\n    priority_scores[fits_mask] = -hypothetical_remaining[fits_mask]\n\n    # Identify bins where the item fits perfectly (remaining capacity is exactly 0).\n    # Using np.isclose for robust floating-point comparison to zero.\n    perfect_fit_mask = np.isclose(hypothetical_remaining, 0.0)\n\n    # Assign a significantly higher score to perfect fits. This ensures that\n    # if a perfect fit exists, it will always be chosen over any non-perfect fit,\n    # regardless of how tight the non-perfect fit is.\n    # A score of 1.0 is chosen because all other valid scores are <= 0.\n    PERFECT_FIT_BONUS_SCORE = 1.0\n    priority_scores[perfect_fit_mask] = PERFECT_FIT_BONUS_SCORE\n\n    return priority_scores",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  }
]