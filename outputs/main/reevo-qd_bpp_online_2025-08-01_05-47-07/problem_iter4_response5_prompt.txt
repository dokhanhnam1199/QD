{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    return np.zeros_like(bins_remain_cap)\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n    This implementation extends the Best Fit heuristic (v1) by introducing a\n    strategic approach to remaining capacities, aiming to \"optimize future bin state\n    to minimize overall waste\" by being smart about leftover space.\n\n    It prioritizes bins based on the following hierarchy:\n    1.  **Perfect Fit**: Highest priority (remaining capacity is 0). This fully utilizes a bin,\n        effectively \"closing\" it and preventing fragmentation.\n    2.  **Avoid Small Fragments**: Lowest priority for bins that would be left with a very small,\n        non-zero remaining capacity. These are considered \"dead space\" or hard-to-use fragments,\n        which contribute to overall waste by making bins appear partially full but practically unusable.\n    3.  **Best Fit for Others**: For all other cases where the item fits (i.e., not a perfect fit\n        and not a \"small fragment\"), it prefers bins that leave a smaller positive remainder.\n        This follows the Best Fit principle of packing tightly.\n\n    This heuristic tries to consolidate items efficiently while avoiding the creation of\n    small, unusable gaps that contribute to overall waste.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of current remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Higher scores indicate a more desirable bin.\n    \"\"\"\n    # Define thresholds for remaining capacity types.\n    # EPSILON_FOR_ZERO: A very small number to account for floating point inaccuracies\n    #                   when checking if a remaining capacity is effectively zero.\n    # SMALL_REMAINDER_THRESHOLD: Defines what constitutes a \"very small\" or \"dead\" remaining space.\n    #                            This value might need tuning based on the typical range of item sizes\n    #                            and bin capacity. For normalized items/bins (0 to 1), 0.05 is a\n    #                            reasonable starting point, meaning remnants less than 5% of bin cap\n    #                            are considered \"dead space\".\n    EPSILON_FOR_ZERO = 1e-9 \n    SMALL_REMAINDER_THRESHOLD = 0.05\n\n    # Calculate the remaining capacity if the item were hypothetically placed in each bin.\n    potential_remaining_cap = bins_remain_cap - item\n\n    # Initialize priority scores for all bins.\n    # Bins where the item does not fit will retain a very low priority (-np.inf).\n    priority_scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify bins where the item can fit.\n    # Allow for a very tiny negative due to floating point precision, treating it as 0.\n    fitting_bins_mask = potential_remaining_cap >= -EPSILON_FOR_ZERO\n\n    # Extract potential remaining capacities for only the fitting bins.\n    fitting_caps_actual = potential_remaining_cap[fitting_bins_mask]\n\n    # Initialize scores for fitting bins using the standard Best Fit approach (negative of remainder).\n    # This means smaller positive remainders get higher (less negative) scores.\n    fitting_scores = -fitting_caps_actual\n\n    # Apply specific rules for different types of remainders:\n\n    # 1. Perfect Fit (remaining capacity is zero or very close to it)\n    perfect_fit_mask = np.isclose(fitting_caps_actual, 0.0, atol=EPSILON_FOR_ZERO)\n    # Assign a very high score to perfect fits to ensure they are always chosen first.\n    fitting_scores[perfect_fit_mask] = float('inf')\n\n    # 2. Small, Non-Zero Remainder (considered \"dead space\")\n    # This applies to capacities that are greater than zero but below the threshold.\n    small_remainder_mask = (fitting_caps_actual > EPSILON_FOR_ZERO) & \\\n                           (fitting_caps_actual < SMALL_REMAINDER_THRESHOLD)\n    # Assign a very low score to discourage leaving such small, potentially unusable gaps.\n    fitting_scores[small_remainder_mask] = -float('inf')\n\n    # For all other fitting bins (those with larger, \"useful\" remaining capacities),\n    # the initial Best Fit scoring (`-fitting_caps_actual`) remains,\n    # ensuring that among these, smaller remainders are still preferred.\n\n    # Assign the calculated fitting scores back to the main priority_scores array.\n    priority_scores[fitting_bins_mask] = fitting_scores\n\n    return priority_scores\n\n[Reflection]\nStrategic scoring: Maximize perfect fits, minimize unusable fragments, optimize future bin states.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}