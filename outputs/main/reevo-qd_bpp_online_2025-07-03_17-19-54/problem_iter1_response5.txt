```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # First-Fit Decreasing heuristic inspired: Prioritize bins where the item fits best
    # Score proportional to the remaining space AFTER placing the item
    feasible_bins = bins_remain_cap >= item
    remaining_space = bins_remain_cap - item
    remaining_space[~feasible_bins] = -1  # Make infeasible bins have very low priority

    priorities[feasible_bins] = remaining_space[feasible_bins]  # Higher remaining space, higher priority (avoid fragmentation)

    # Add a bonus for bins that are almost full after adding the item
    almost_full_threshold = 0.1  # Bin is considered almost full if remaining cap is less than 10% of total capacity AFTER placing item

    total_capacity = bins_remain_cap + remaining_space # estimate total capacity for all bins

    is_almost_full = (remaining_space >= 0) & (remaining_space / total_capacity) <= almost_full_threshold

    priorities[is_almost_full] += total_capacity[is_almost_full] * 0.5  # Adding substantial priority boost


    #Large Item Penalty (avoiding putting large items in nearly full bins as that limits future potential)

    large_item_threshold = 0.5
    large_item_penalty = 0.2

    if item > large_item_threshold: #consider item as large if size > 50% of the bin size

       nearly_full_bins_large = (bins_remain_cap> item) & ((bins_remain_cap - item)/ total_capacity < 0.2) #Check nearly full bins after adding the item

       priorities[nearly_full_bins_large] -= total_capacity[nearly_full_bins_large] * large_item_penalty #Decrease priority if item is large
    return priorities
```
