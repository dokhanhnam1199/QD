[
  {
    "stdout_filepath": "problem_iter2_response0.txt_stdout.txt",
    "code_path": "problem_iter2_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on how close their remaining capacity is to the item size.\n    Bins with less capacity than the item get zero priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Bins with less capacity than the item get zero priority\n    priority_score = np.where(bins_remain_cap < item, 0, \n                              # Priority is higher for bins that can just hold the item\n                              1 / (1 + np.abs(bins_remain_cap - item)))\n    return priority_score",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 70.32403072095333,
    "mi": 55.84856430961238,
    "token_count": 98.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response1.txt_stdout.txt",
    "code_path": "problem_iter2_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on the ratio of the remaining capacity to the item size.\n    If a bin has just enough capacity to hold the item, it gets the highest priority.\n    Bins with less capacity than the item get zero priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Bins with less capacity than the item get zero priority\n    priority_score = np.where(bins_remain_cap < item, 0, \n                              # Priority is higher for bins that can just hold the item\n                              bins_remain_cap / (bins_remain_cap + item))\n    return priority_score",
    "response_id": 1,
    "obj": 149.30195452732352,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 70.32403072095333,
    "mi": 55.84856430961238,
    "token_count": 98.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response2.txt_stdout.txt",
    "code_path": "problem_iter2_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to minimize waste and prioritize bins \n    that are almost full, thereby reducing the number of bins needed.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the waste that would be generated if the item is added to each bin\n    waste = np.maximum(0, bins_remain_cap - item)\n    \n    # Calculate the priority score as the inverse of the waste, with a higher priority for near-full bins\n    priority = np.where(bins_remain_cap >= item, 1 / (waste + 1e-6), 0)\n    \n    # Adjust the priority to prioritize near-full bins\n    near_full_priority = 1 - np.clip((bins_remain_cap - item) / bins_remain_cap, a_min=0, a_max=1)\n    priority = np.where(bins_remain_cap >= item, np.maximum(priority, near_full_priority), priority)\n    \n    return priority",
    "response_id": 2,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 70.32403072095333,
    "mi": 55.84856430961238,
    "token_count": 98.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response3.txt_stdout.txt",
    "code_path": "problem_iter2_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins that have the least amount of remaining capacity and \n    can still fit the item. If a bin cannot fit the item, its priority is set to negative infinity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity for each bin that can still fit the item\n    # If a bin cannot fit the item, set its capacity to infinity\n    remaining_cap_with_item = np.where(bins_remain_cap >= item, bins_remain_cap - item, np.inf)\n    \n    # Assign a high priority to bins with the least amount of remaining capacity\n    priority = -remaining_cap_with_item\n    \n    # Set priority to negative infinity if the item cannot fit in a bin\n    # This step is not necessary because where() already sets the value to infinity,\n    # which will be converted to negative infinity when negating\n    # priority[bins_remain_cap < item] = -np.inf\n    \n    return priority",
    "response_id": 3,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 70.32403072095333,
    "mi": 55.84856430961238,
    "token_count": 98.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response4.txt_stdout.txt",
    "code_path": "problem_iter2_code4.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to encourage the packing of items into bins \n    where the item size is close to or less than the remaining capacity, thereby \n    minimizing waste and reducing the number of bins needed. Perfect fits are \n    prioritized.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity of each bin\n    remaining_cap = np.copy(bins_remain_cap)\n\n    # Calculate the absolute difference between item size and remaining capacity\n    diff = np.abs(remaining_cap - item)\n\n    # Use the inverse of the difference as the priority score, so that bins \n    # with smaller differences (i.e., closer to fitting the item perfectly) \n    # have higher priority scores. Also, prioritize perfect fits.\n    priority = np.where(diff == 0, 1e10, 1 / (diff + 1e-8))  # Perfect fit gets highest priority\n\n    # Further prioritize bins where item size is less than or equal to remaining capacity\n    priority = np.where(remaining_cap >= item, priority, priority / 10)\n\n    return priority",
    "response_id": 4,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 70.32403072095333,
    "mi": 55.84856430961238,
    "token_count": 98.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response5.txt_stdout.txt",
    "code_path": "problem_iter2_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on the absolute difference between the remaining capacity and the item size.\n    If a bin has just enough capacity to hold the item, it gets the highest priority.\n    Bins with less capacity than the item get zero priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Bins with less capacity than the item get zero priority\n    priority_score = np.where(bins_remain_cap < item, 0, \n                              # Priority is higher for bins that can just hold the item, penalize excess capacity\n                              1 / (1 + np.abs(bins_remain_cap - item)))\n    return priority_score",
    "response_id": 5,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 70.32403072095333,
    "mi": 55.84856430961238,
    "token_count": 98.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response6.txt_stdout.txt",
    "code_path": "problem_iter2_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins where the item size is close to the remaining capacity,\n    thereby minimizing waste and reducing the number of bins needed.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the absolute difference between item size and remaining capacity\n    diff = np.abs(bins_remain_cap - item)\n\n    # Use the inverse of the difference as the priority score, with a small constant to avoid division by zero\n    priority = 1 / (diff + 1e-8)\n\n    # To further encourage packing into bins that are more empty, multiply the priority by the remaining capacity\n    priority *= bins_remain_cap\n\n    return priority",
    "response_id": 6,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 70.32403072095333,
    "mi": 55.84856430961238,
    "token_count": 98.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response7.txt_stdout.txt",
    "code_path": "problem_iter2_code7.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes exact fits, penalizes excess capacity, and ignores bins with insufficient capacity.\n    \n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Bins with less capacity than the item get zero priority\n    priority_score = np.where(bins_remain_cap < item, 0, \n                              # Exact fits get the highest priority\n                              np.where(bins_remain_cap == item, 1, \n                                       # Penalty for excess capacity\n                                       1 / (1 + bins_remain_cap - item)))\n    return priority_score",
    "response_id": 7,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 70.32403072095333,
    "mi": 55.84856430961238,
    "token_count": 98.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response8.txt_stdout.txt",
    "code_path": "problem_iter2_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on the ratio of the remaining capacity to the item size.\n    If a bin has just enough capacity to hold the item, it gets the highest priority.\n    Bins with less capacity than the item get zero priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Bins with less capacity than the item get zero priority\n    priority_score = np.where(bins_remain_cap < item, 0, \n                              # Priority is higher for bins that can just hold the item\n                              bins_remain_cap / (bins_remain_cap + item))\n    return priority_score",
    "response_id": 8,
    "obj": 149.30195452732352,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 70.32403072095333,
    "mi": 55.84856430961238,
    "token_count": 98.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response9.txt_stdout.txt",
    "code_path": "problem_iter2_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on the inverse difference between \n    the remaining capacity and the item size. Bins with remaining capacities closest \n    to the item size receive the highest priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the absolute difference between item size and remaining capacity\n    diff = np.abs(bins_remain_cap - item)\n\n    # Bins with less capacity than the item get zero priority\n    diff = np.where(bins_remain_cap < item, np.inf, diff)\n\n    # Use the inverse of the difference as the priority score, so that bins \n    # with smaller differences (i.e., closer to fitting the item perfectly) \n    # have higher priority scores\n    priority = 1 / (diff + 1e-8)  # Add a small constant to avoid division by zero\n\n    # Add a small fraction of random noise to break ties and increase exploration\n    priority += np.random.rand(*priority.shape) * 1e-6\n    \n    return priority",
    "response_id": 9,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 70.32403072095333,
    "mi": 55.84856430961238,
    "token_count": 98.0,
    "exec_success": true
  }
]