```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Returns priority with which we want to add item to each bin.

    This priority function combines multiple factors with weighted priorities:
    1. **Exact fit**: Prioritizes bins where the item size is closest to the remaining capacity.
    2. **Near-full bins**: Encourages efficient packing by prioritizing near-full bins.
    3. **Waste minimization**: Prioritizes bins that minimize waste (i.e., remaining capacity after adding the item).
    4. **Remaining capacity**: Prioritizes bins with more remaining capacity to discourage overfilling.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    # Calculate the ratio of the remaining capacity of each bin to the item size
    capacity_ratio = np.where(bins_remain_cap == 0, 0, item / bins_remain_cap)
    
    # Invert the ratios to give higher priority to bins with ratios closer to 1 (exact fit)
    ratio_priorities = 1 / np.abs(capacity_ratio - 1 + 1e-8)  # add a small value to avoid division by zero
    
    # Calculate the difference between the remaining capacity of each bin and the item size
    capacity_diff = np.abs(bins_remain_cap - item)
    
    # Invert the differences to give higher priority to bins with smaller differences
    diff_priorities = 1 / (capacity_diff + 1e-8)  # add a small value to avoid division by zero
    
    # Calculate the waste (remaining capacity after adding the item) for each bin
    waste = np.maximum(0, bins_remain_cap - item)
    
    # Invert the waste to give higher priority to bins with less waste
    waste_priorities = 1 / (waste + 1e-8)  # add a small value to avoid division by zero
    
    # Calculate the priority based on remaining capacity
    remaining_cap_priorities = bins_remain_cap / (bins_remain_cap + item + 1e-8)
    
    # Combine the priorities with weighted priorities
    priority_scores = (
        0.3 * ratio_priorities +  # prioritize exact fit
        0.25 * diff_priorities +  # prioritize small differences
        0.2 * waste_priorities +  # prioritize less waste
        0.25 * remaining_cap_priorities  # prioritize bins with more remaining capacity
    )
    
    # Give higher priority to near-full bins to encourage efficient packing
    near_full_priorities = 1 - (bins_remain_cap - item) / (bins_remain_cap + 1e-8)
    priority_scores *= near_full_priorities
    
    return priority_scores
```
