[
  {
    "stdout_filepath": "problem_iter4_response0.txt_stdout.txt",
    "code_path": "problem_iter4_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to minimize waste and prioritize bins \n    that are almost full, thereby reducing the number of bins needed.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the waste that would be generated if the item is added to each bin\n    waste = np.maximum(0, bins_remain_cap - item)\n    \n    # Calculate the priority score as the inverse of the waste, with a higher priority for near-full bins\n    priority = np.where(bins_remain_cap >= item, 1 / (waste + 1e-6), 0)\n    \n    # Adjust the priority to prioritize near-full bins\n    near_full_priority = 1 - np.clip((bins_remain_cap - item) / (bins_remain_cap + 1e-6), a_min=0, a_max=1)\n    priority = np.where(bins_remain_cap >= item, np.maximum(priority, near_full_priority), priority)\n    \n    # Calculate the fullness ratio of each bin\n    fullness_ratio = np.where(bins_remain_cap > 0, (bins_remain_cap - item) / bins_remain_cap, 0)\n    \n    # Adjust the priority based on the fullness ratio\n    priority = np.where(bins_remain_cap >= item, priority * (1 - fullness_ratio), priority)\n    \n    return priority",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 312.1143675543732,
    "mi": 70.61007815413564,
    "token_count": 174.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response3.txt_stdout.txt",
    "code_path": "problem_iter5_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to encourage the packing of items into bins \n    where the item size is closest to the remaining capacity, thereby minimizing waste.\n    It combines ratio, difference, and exact fit considerations with weighted priorities, \n    prioritizing near-full bins and minimal waste.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the difference between the remaining capacity of each bin and the item size\n    capacity_diff = np.abs(bins_remain_cap - item)\n    \n    # Calculate the ratio of the item size to the remaining capacity of each bin\n    capacity_ratio = item / (bins_remain_cap + 1e-8)  # add a small value to avoid division by zero\n    \n    # Calculate the exact fit score, giving higher priority to exact fits\n    exact_fit_score = 1.0 - np.abs(capacity_diff / (item + 1e-8))  # add a small value to avoid division by zero\n    \n    # Calculate the priority scores, combining the different considerations with weighted priorities\n    priority_scores = 0.4 * (1 / (capacity_diff + 1e-8)) + 0.3 * capacity_ratio + 0.3 * exact_fit_score\n    \n    # Give higher priority to bins with more remaining capacity to discourage overfilling\n    priority_scores *= bins_remain_cap / (bins_remain_cap + item + 1e-8)  # add a small value to avoid division by zero\n    \n    # Give higher priority to near-full bins\n    near_full_score = 1.0 - (capacity_diff / (bins_remain_cap + 1e-8))  # add a small value to avoid division by zero\n    priority_scores *= near_full_score\n    \n    return priority_scores",
    "response_id": 3,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 206.32331253245206,
    "mi": 53.63509311736133,
    "token_count": 120.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response1.txt_stdout.txt",
    "code_path": "problem_iter6_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to encourage the packing of items into bins \n    where the item size is closest to the remaining capacity, thereby minimizing waste.\n    It combines ratio, difference, and exact fit considerations with weighted priorities, \n    prioritizing near-full bins and minimal waste.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the difference between the remaining capacity of each bin and the item size\n    capacity_diff = np.abs(bins_remain_cap - item)\n    \n    # Calculate the ratio of the item size to the remaining capacity of each bin\n    capacity_ratio = item / (bins_remain_cap + 1e-8)  # add a small value to avoid division by zero\n    \n    # Calculate the exact fit score, giving higher priority to exact fits\n    exact_fit_score = 1.0 - np.abs(capacity_diff / (item + 1e-8))  # add a small value to avoid division by zero\n    \n    # Calculate the near-full score, giving higher priority to near-full bins\n    near_full_score = 1.0 - (capacity_diff / (bins_remain_cap + 1e-8))  # add a small value to avoid division by zero\n    \n    # Calculate the priority scores, combining the different considerations with weighted priorities\n    priority_scores = 0.4 * (1 / (capacity_diff + 1e-8)) + 0.2 * capacity_ratio + 0.2 * exact_fit_score + 0.2 * near_full_score\n    \n    # Give higher priority to bins with more remaining capacity to discourage overfilling\n    priority_scores *= bins_remain_cap / (bins_remain_cap + item + 1e-8)  # add a small value to avoid division by zero\n    \n    return priority_scores",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 17.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 406.3373625190581,
    "mi": 69.62741936586059,
    "token_count": 195.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter7_response3.txt_stdout.txt",
    "code_path": "problem_iter7_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to encourage the packing of items into bins \n    where the item size is closest to the remaining capacity, thereby minimizing waste.\n    It combines ratio, difference, and exact fit with weighted priorities, emphasizing \n    near-full bins, minimal waste, and perfect fits.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the difference between the remaining capacity of each bin and the item size\n    capacity_diff = np.abs(bins_remain_cap - item)\n    \n    # Calculate the ratio of the item size to the remaining capacity\n    capacity_ratio = np.where(bins_remain_cap > 0, item / bins_remain_cap, 1e8)  # avoid division by zero\n    \n    # Calculate a smoothed exact fit score\n    exact_fit_score = np.exp(-((capacity_diff / (item + 1e-8))**2) / (2 * 0.1**2))  # using a Gaussian kernel\n    \n    # Combine the scores with weighted priorities\n    priority_scores = (\n        0.4 * (1 / (capacity_diff + 1e-8))  # give higher priority to bins with smaller differences\n        + 0.3 * (1 - capacity_ratio)  # give higher priority to bins with smaller ratios\n        + 0.3 * exact_fit_score  # give higher priority to bins with exact fits\n    )\n    \n    # Give higher priority to bins with more remaining capacity to discourage overfilling\n    priority_scores *= np.where(bins_remain_cap > 0, bins_remain_cap / (bins_remain_cap + item), 1e-8)\n    \n    return priority_scores",
    "response_id": 3,
    "obj": 75.01994415636219,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 162.84823041805248,
    "mi": 62.123120861062574,
    "token_count": 138.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response0.txt_stdout.txt",
    "code_path": "problem_iter8_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to encourage the packing of items into bins \n    where the item size is closest to the remaining capacity, thereby minimizing waste.\n    It combines ratio, difference, and exact fit considerations with balanced weights, \n    prioritizing near-full bins and minimal waste.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the difference between the remaining capacity of each bin and the item size\n    capacity_diff = np.abs(bins_remain_cap - item)\n    \n    # Calculate the ratio of the item size to the remaining capacity of each bin\n    capacity_ratio = item / (bins_remain_cap + 1e-8)  # add a small value to avoid division by zero\n    \n    # Calculate the exact fit score, giving higher priority to exact fits\n    exact_fit_score = 1.0 - np.abs(capacity_diff / (item + 1e-8))  # add a small value to avoid division by zero\n    \n    # Calculate the near-full score, giving higher priority to near-full bins\n    near_full_score = 1.0 - (capacity_diff / (bins_remain_cap + 1e-8))  # add a small value to avoid division by zero\n    \n    # Calculate the priority scores, combining the different considerations with balanced weights\n    priority_scores = 0.25 * (1 / (capacity_diff + 1e-8)) + 0.25 * (1 - capacity_ratio) + 0.25 * exact_fit_score + 0.25 * near_full_score\n    \n    # Give higher priority to bins with more remaining capacity to discourage overfilling\n    priority_scores *= bins_remain_cap / (bins_remain_cap + item + 1e-8)  # add a small value to avoid division by zero\n    \n    return priority_scores",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 271.0285876233177,
    "mi": 52.805587025372475,
    "token_count": 120.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response0.txt_stdout.txt",
    "code_path": "problem_iter9_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to prioritize near-full bins, minimize waste, and simplify weights for better online Bin Packing heuristics performance.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the difference between the remaining capacity of each bin and the item size\n    capacity_diff = np.abs(bins_remain_cap - item)\n    \n    # Invert the differences to give higher priority to bins with smaller differences\n    priority_scores = 1 / (capacity_diff + 1e-8)  # add a small value to avoid division by zero\n    \n    # Prioritize near-full bins by multiplying with a factor that increases as the bin gets fuller\n    priority_scores *= (1 - (bins_remain_cap / (bins_remain_cap + item))) + 1e-8\n    \n    # Give higher priority to bins with more remaining capacity to discourage overfilling, \n    # but with a smaller weight to avoid over-prioritizing large remaining capacities\n    priority_scores *= np.sqrt(bins_remain_cap)\n    \n    return priority_scores",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 110.36149671375918,
    "mi": 66.43790462495691,
    "token_count": 85.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response0.txt_stdout.txt",
    "code_path": "problem_iter10_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to minimize waste and prioritize bins \n    that are almost full, thereby reducing the number of bins needed.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the waste that would be generated if the item is added to each bin\n    waste = np.maximum(0, bins_remain_cap - item)\n    \n    # Calculate the priority score as the inverse of the waste, with a higher priority for near-full bins\n    priority = np.where(bins_remain_cap >= item, 1 / (waste + 1e-6), 0)\n    \n    # Adjust the priority to prioritize near-full bins\n    near_full_priority = 1 - np.clip((bins_remain_cap - item) / (bins_remain_cap + 1e-6), a_min=0, a_max=1)\n    priority = np.where(bins_remain_cap >= item, np.maximum(priority, near_full_priority), priority)\n    \n    # Prioritize bins with the smallest remaining capacity\n    priority *= np.where(bins_remain_cap > 0, 1 / (bins_remain_cap + 1e-6), 1e-6)\n    \n    return priority",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 171.30037948837168,
    "mi": 53.14120392595227,
    "token_count": 96.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response2.txt_stdout.txt",
    "code_path": "problem_iter11_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to prioritize near-full bins and minimize waste.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the difference between the remaining capacity of each bin and the item size\n    capacity_diff = np.abs(bins_remain_cap - item)\n    \n    # Calculate the ratio of remaining capacity to bin capacity\n    remaining_ratio = bins_remain_cap / (bins_remain_cap + item)\n    \n    # Invert the differences to give higher priority to bins with smaller differences\n    priority_scores = 1 / (capacity_diff + 1e-8)  # add a small value to avoid division by zero\n    \n    # Give higher priority to near-full bins and minimize waste\n    priority_scores *= (1 - remaining_ratio)\n    \n    # Simplify weights to reduce overfilling\n    priority_scores *= np.sqrt(bins_remain_cap)\n    \n    return priority_scores",
    "response_id": 2,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 149.27754454988144,
    "mi": 75.0925472923933,
    "token_count": 111.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response0.txt_stdout.txt",
    "code_path": "problem_iter12_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to encourage the packing of items into bins \n    where the item size is closest to the remaining capacity, thereby minimizing waste.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority scores based on the remaining capacity of each bin\n    priority_scores = bins_remain_cap / (np.abs(bins_remain_cap - item) + 1e-8)\n    \n    # This gives higher priority to bins with more remaining capacity and smaller differences\n    return priority_scores",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 93.76537429460444,
    "mi": 63.28698231039419,
    "token_count": 76.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter13_response0.txt_stdout.txt",
    "code_path": "problem_iter13_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to prioritize near-full bins and balance remaining capacity, \n    thereby minimizing waste and optimizing online Bin Packing heuristics performance.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the difference between the remaining capacity of each bin and the item size\n    capacity_diff = np.abs(bins_remain_cap - item)\n    \n    # Simplify weights by applying a logarithmic function to the differences\n    weight = 1 / (1 + np.log(capacity_diff + 1))\n    \n    # Prioritize near-full bins\n    near_full_priority = bins_remain_cap / (bins_remain_cap + item + 1e-8)\n    \n    # Balance remaining capacity by applying a linear function to the remaining capacity\n    balance_priority = 1 - (bins_remain_cap / (bins_remain_cap.max() + item + 1e-8))\n    \n    # Combine the priorities using a weighted sum\n    priority_scores = 0.4 * weight + 0.3 * near_full_priority + 0.3 * balance_priority\n    \n    return priority_scores",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 79.95445336320968,
    "mi": 64.18154165613439,
    "token_count": 81.0,
    "exec_success": true
  }
]