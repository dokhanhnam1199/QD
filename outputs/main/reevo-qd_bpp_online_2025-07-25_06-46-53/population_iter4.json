[
  {
    "stdout_filepath": "problem_iter4_response0.txt_stdout.txt",
    "code_path": "problem_iter4_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to minimize waste and prioritize bins \n    that are almost full, thereby reducing the number of bins needed.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the waste that would be generated if the item is added to each bin\n    waste = np.maximum(0, bins_remain_cap - item)\n    \n    # Calculate the priority score as the inverse of the waste, with a higher priority for near-full bins\n    priority = np.where(bins_remain_cap >= item, 1 / (waste + 1e-6), 0)\n    \n    # Adjust the priority to prioritize near-full bins\n    near_full_priority = 1 - np.clip((bins_remain_cap - item) / (bins_remain_cap + 1e-6), a_min=0, a_max=1)\n    priority = np.where(bins_remain_cap >= item, np.maximum(priority, near_full_priority), priority)\n    \n    # Calculate the fullness ratio of each bin\n    fullness_ratio = np.where(bins_remain_cap > 0, (bins_remain_cap - item) / bins_remain_cap, 0)\n    \n    # Adjust the priority based on the fullness ratio\n    priority = np.where(bins_remain_cap >= item, priority * (1 - fullness_ratio), priority)\n    \n    return priority",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 312.1143675543732,
    "mi": 70.61007815413564,
    "token_count": 174.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response1.txt_stdout.txt",
    "code_path": "problem_iter4_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on how close their remaining capacity is to the item size.\n    The closer the remaining capacity is to the item size, the higher the priority.\n    Bins with less capacity than the item get zero priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Bins with less capacity than the item get zero priority\n    priority_score = np.where(bins_remain_cap < item, 0, \n                              # Priority is higher for bins that can just hold the item\n                              1 / (1 + np.power(bins_remain_cap - item, 2)))\n    return priority_score",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 312.1143675543732,
    "mi": 70.61007815413564,
    "token_count": 174.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response2.txt_stdout.txt",
    "code_path": "problem_iter4_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to encourage the packing of items into bins \n    where the item size is closest to the remaining capacity, thereby minimizing waste.\n    It prioritizes ratio over difference, near-full bins, exact fits, and penalizes excess capacity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Bins with less capacity than the item get zero priority\n    priority_score = np.where(bins_remain_cap < item, 0, \n                              # Calculate the ratio between the item size and the remaining capacity of each bin\n                              bins_remain_cap / (bins_remain_cap + item))\n    \n    # Calculate the inverse of the absolute difference between the remaining capacity and the item size\n    inv_diff = 1 / (np.abs(bins_remain_cap - item) + 1e-8)  # add a small value to avoid division by zero\n    \n    # Give higher priority to exact fits and near-full bins\n    priority_score = np.where(bins_remain_cap == item, 1e6, priority_score * inv_diff)\n    \n    # Prioritize bins based on the ratio and inverse difference\n    ratio = item / (bins_remain_cap + 1e-8)  # add a small value to avoid division by zero\n    priority_score = np.where(ratio <= 1, priority_score * ratio, priority_score)\n    \n    # Penalize excess capacity to encourage perfect fits\n    excess_capacity_penalty = 1 / (bins_remain_cap - item + 1e-8 + 1)  # add a small value to avoid division by zero\n    excess_capacity_penalty = np.where(bins_remain_cap > item, excess_capacity_penalty, 1)\n    priority_score *= excess_capacity_penalty\n    \n    return priority_score",
    "response_id": 2,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 312.1143675543732,
    "mi": 70.61007815413564,
    "token_count": 174.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response3.txt_stdout.txt",
    "code_path": "problem_iter4_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes perfect fits, minimizes waste, and penalizes poor fits.\n    Bins that can hold the item perfectly or have a small remaining capacity after adding the item\n    get higher priority scores.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity of each bin if the item is added\n    remaining_cap = bins_remain_cap - item\n\n    # Bins with less capacity than the item get zero priority\n    priority = np.where(bins_remain_cap < item, 0, 1)\n\n    # Prioritize perfect fits\n    priority = np.where(remaining_cap == 0, 1e10, priority)\n\n    # Further prioritize bins where item size is less than or equal to remaining capacity\n    priority = np.where(remaining_cap > 0, priority * (1 / (1 + np.abs(remaining_cap))), priority / 10)\n\n    # Penalize poor fits by reducing priority score based on the difference between item size and remaining capacity\n    priority = np.where(remaining_cap < 0, priority / (1 + np.abs(remaining_cap)), priority)\n\n    return priority",
    "response_id": 3,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 312.1143675543732,
    "mi": 70.61007815413564,
    "token_count": 174.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response4.txt_stdout.txt",
    "code_path": "problem_iter4_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on the ratio of the item size to the remaining capacity,\n    encouraging the packing of items into bins where the item size is closest to the remaining capacity,\n    thereby minimizing waste. It also prioritizes near-full bins and exact fits.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Calculate the ratio between the item size and the remaining capacity of each bin\n    ratio = item / (bins_remain_cap + 1e-8)  # add a small value to avoid division by zero\n    \n    # Calculate the inverse differences to give higher priority to bins with smaller differences\n    inv_diff = 1 / (np.abs(bins_remain_cap - item) + 1e-8)\n    \n    # Calculate the priority score as a combination of the ratio and the inverse differences\n    # Near-full bins and exact fits are prioritized\n    priority_scores = (1 - np.abs(1 - ratio)) * inv_diff\n    \n    # Give higher priority to near-full bins and exact fits\n    priority_scores *= (1 - (np.abs(bins_remain_cap - item) / (bins_remain_cap + 1e-8)))\n    \n    # Ensure bins with insufficient capacity get zero priority\n    priority_scores = np.where(bins_remain_cap < item, 0, priority_scores)\n    \n    return priority_scores",
    "response_id": 4,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 312.1143675543732,
    "mi": 70.61007815413564,
    "token_count": 174.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response5.txt_stdout.txt",
    "code_path": "problem_iter4_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins where the item size is close to the remaining capacity,\n    thereby minimizing waste and reducing the number of bins needed.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Bins with less capacity than the item get zero priority\n    priority_score = np.where(bins_remain_cap < item, 0, \n                              # Calculate the waste if the item is added to the bin\n                              bins_remain_cap - item)\n    \n    # Use the inverse of the waste as the priority score, with a small constant to avoid division by zero\n    priority = np.where(priority_score < 0, 0, 1 / (priority_score + 1e-8))\n\n    # To further encourage packing into bins that are more empty, multiply the priority by the remaining capacity\n    priority *= bins_remain_cap\n\n    return priority",
    "response_id": 5,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 312.1143675543732,
    "mi": 70.61007815413564,
    "token_count": 174.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response6.txt_stdout.txt",
    "code_path": "problem_iter4_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on minimizing waste and \n    filling nearly full bins, thereby reducing the number of bins needed.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the waste that would be generated if the item is added to each bin\n    waste = np.maximum(0, bins_remain_cap - item)\n    \n    # Calculate the priority score as the inverse of the waste, with a higher priority for near-full bins\n    priority = np.where(bins_remain_cap >= item, 1 / (waste + 1e-6), 0)\n    \n    # Adjust the priority to prioritize near-full bins\n    near_full_priority = 1 - np.clip((bins_remain_cap - item) / bins_remain_cap, a_min=0, a_max=1)\n    priority = np.where(bins_remain_cap >= item, priority * (1 + near_full_priority), priority)\n    \n    return priority",
    "response_id": 6,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 312.1143675543732,
    "mi": 70.61007815413564,
    "token_count": 174.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response7.txt_stdout.txt",
    "code_path": "problem_iter4_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on minimizing waste and \n    favoring near-full bins to reduce the overall number of bins needed.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the waste that would be generated if the item is added to each bin\n    waste = np.maximum(0, bins_remain_cap - item)\n    \n    # Calculate the priority score as a combination of waste minimization and near-full bin prioritization\n    priority = np.where(bins_remain_cap >= item, \n                        # For bins that can hold the item, prioritize near-full bins and minimize waste\n                        (1 - (waste / bins_remain_cap)) + (1 - np.clip((bins_remain_cap - item) / bins_remain_cap, a_min=0, a_max=1)),\n                        0)\n    \n    # Normalize the priority scores to ensure they add up to 1\n    priority /= np.sum(priority) if np.sum(priority) > 0 else 1\n    \n    return priority",
    "response_id": 7,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 312.1143675543732,
    "mi": 70.61007815413564,
    "token_count": 174.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response8.txt_stdout.txt",
    "code_path": "problem_iter4_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function combines considerations of ratio, difference, and exact fit.\n    It prioritizes bins based on the ratio of the remaining capacity to the item size,\n    the difference between the remaining capacity and the item size, and exact fits.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the ratio of the remaining capacity of each bin to the item size\n    capacity_ratio = np.where(bins_remain_cap == 0, 0, item / bins_remain_cap)\n    \n    # Invert the ratios to give higher priority to bins with smaller ratios\n    ratio_priority = np.where(capacity_ratio == 0, 0, 1 / (np.abs(capacity_ratio - 1) + 1e-8))\n    \n    # Calculate the difference between the remaining capacity and the item size\n    capacity_diff = np.abs(bins_remain_cap - item)\n    \n    # Give higher priority to bins with smaller differences\n    diff_priority = np.where(capacity_diff == 0, 1e6, 1 / (capacity_diff + 1e-8))\n    \n    # Give higher priority to exact fits\n    exact_fit_priority = np.where(np.isclose(bins_remain_cap, item), 1e6, 0)\n    \n    # Combine the priorities\n    priority_scores = ratio_priority + diff_priority + exact_fit_priority\n    \n    # Penalize bins with less capacity than the item\n    priority_scores = np.where(bins_remain_cap < item, 0, priority_scores)\n    \n    return priority_scores",
    "response_id": 8,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 312.1143675543732,
    "mi": 70.61007815413564,
    "token_count": 174.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response9.txt_stdout.txt",
    "code_path": "problem_iter4_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function combines multiple factors with weighted priorities:\n    1. **Exact fit**: Prioritizes bins where the item size is closest to the remaining capacity.\n    2. **Near-full bins**: Encourages efficient packing by prioritizing near-full bins.\n    3. **Waste minimization**: Prioritizes bins that minimize waste (i.e., remaining capacity after adding the item).\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Calculate the ratio of the remaining capacity of each bin to the item size\n    capacity_ratio = np.where(bins_remain_cap == 0, 0, item / bins_remain_cap)\n    \n    # Invert the ratios to give higher priority to bins with ratios closer to 1 (exact fit)\n    ratio_priorities = 1 / np.abs(capacity_ratio - 1 + 1e-8)  # add a small value to avoid division by zero\n    \n    # Calculate the difference between the remaining capacity of each bin and the item size\n    capacity_diff = np.abs(bins_remain_cap - item)\n    \n    # Invert the differences to give higher priority to bins with smaller differences\n    diff_priorities = 1 / (capacity_diff + 1e-8)  # add a small value to avoid division by zero\n    \n    # Calculate the waste (remaining capacity after adding the item) for each bin\n    waste = np.maximum(0, bins_remain_cap - item)\n    \n    # Invert the waste to give higher priority to bins with less waste\n    waste_priorities = 1 / (waste + 1e-8)  # add a small value to avoid division by zero\n    \n    # Combine the priorities with weighted priorities\n    priority_scores = (\n        0.4 * ratio_priorities +  # prioritize exact fit\n        0.3 * diff_priorities +  # prioritize small differences\n        0.3 * waste_priorities  # prioritize less waste\n    )\n    \n    # Give higher priority to near-full bins to encourage efficient packing\n    near_full_priorities = 1 - (bins_remain_cap - item) / (bins_remain_cap + 1e-8)\n    priority_scores *= near_full_priorities\n    \n    return priority_scores",
    "response_id": 9,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 312.1143675543732,
    "mi": 70.61007815413564,
    "token_count": 174.0,
    "exec_success": true
  }
]