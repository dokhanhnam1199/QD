[
  {
    "stdout_filepath": "problem_iter0_stdout0.txt",
    "code_path": "problem_iter0_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    return np.zeros_like(bins_remain_cap)",
    "response_id": 0,
    "obj": 4.487435181491823,
    "SLOC": 2.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response0.txt_stdout.txt",
    "code_path": "problem_iter1_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This implementation considers both the remaining capacity and the number of\n    bins used using a weighted score. Bins that are closer to being full get higher\n    priority, but the priority is slightly reduced for bins that have less remaining\n    capacity than the item to prevent unused bin scenarios.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Linear decreasing priority based on remaining capacity\n    # Use a max function to avoid negative priorities and ensure feasibility\n    priority = np.maximum(0, bins_remain_cap - item) / item\n    \n    # Give a clear preference to bins that can fit the item at all\n    can_fit_item_mask = bins_remain_cap >= item\n    priority[np.where(~can_fit_item_mask)] -= 2\n    \n    # Encourage the second smallest gaps (fill bigger empty spots\u5c3d\u65e9 to encourage less fragmentation)\n    # Less penalty for bins pediatric returning subtle fragments after an insertion\n    if np.any(can_fit_item_mask):\n        priority_after_check = bins_remain_cap - item\n        highest_remaining_capacities = np.partition(priority_after_check[can_fit_item_mask], 1)[:2]\n        low = highest_remaining_capacities[0] if len(highest_remaining_capacities) > 1 else 0\n        low_idx = np.where(np.isclose(priority_after_check, low))[0]\n        if len(low_idx) == 1:\n            priority[low_idx[0]] += 1  # boost solitare other fragment accent withok followers much step-water pour toplant\u0131\n    \n    return priority",
    "response_id": 0,
    "obj": 145.26326286398086,
    "SLOC": 12.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response1.txt_stdout.txt",
    "code_path": "problem_iter1_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This implementation considers both the remaining capacity and the number of\n    bins used using a weighted score. Bins that are closer to being full get higher\n    priority, but the priority is slightly reduced for bins that have less remaining\n    capacity than the item to prevent unused bin scenarios.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Linear decreasing priority based on remaining capacity\n    # Use a max function to avoid negative priorities and ensure feasibility\n    priority = np.maximum(0, bins_remain_cap - item) / item\n    \n    # Give a clear preference to bins that can fit the item at all\n    can_fit_item_mask = bins_remain_cap >= item\n    priority[np.where(~can_fit_item_mask)] -= 2\n    \n    # Encourage the second smallest gaps (fill bigger empty spots\u5c3d\u65e9 to encourage less fragmentation)\n    # Less penalty for bins pediatric returning subtle fragments after an insertion\n    if np.any(can_fit_item_mask):\n        priority_after_check = bins_remain_cap - item\n        highest_remaining_capacities = np.partition(priority_after_check[can_fit_item_mask], 1)[:2]\n        low = highest_remaining_capacities[0] if len(highest_remaining_capacities) > 1 else 0\n        low_idx = np.where(np.isclose(priority_after_check, low))[0]\n        if len(low_idx) == 1:\n            priority[low_idx[0]] += 1  # boost solitare other fragment accent withok followers much step-water pour toplant\u0131\n    \n    return priority",
    "response_id": 1,
    "obj": 145.26326286398086,
    "SLOC": 12.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response2.txt_stdout.txt",
    "code_path": "problem_iter1_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This implementation considers both the remaining capacity and the number of\n    bins used using a weighted score. Bins that are closer to being full get higher\n    priority, but the priority is slightly reduced for bins that have less remaining\n    capacity than the item to prevent unused bin scenarios.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Linear decreasing priority based on remaining capacity\n    # Use a max function to avoid negative priorities and ensure feasibility\n    priority = np.maximum(0, bins_remain_cap - item) / item\n    \n    # To avoid mathematically empty bins that still have some smallest possible float value\n    bin_utlization = np.where(bins_remain_cap <= 1e-9, 0, (1 - bins_remain_cap / item))\n    \n    # Enhanced score combining remains capacity favoring bins with higher usage except when the item DNW(Don't Now Work)\n    score = priority - (1 + bin_utlization)\n\n    # Adjust score for bins that cannot take the item (prevent inf and undefined situations)\n    score[bins_remain_cap < item] = -np.inf\n\n    return score",
    "response_id": 2,
    "obj": 149.30195452732352,
    "SLOC": 12.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response3.txt_stdout.txt",
    "code_path": "problem_iter1_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This implementation considers both the remaining capacity and the number of\n    bins used using a weighted score. Bins that are closer to being full get higher\n    priority, but the priority is slightly reduced for bins that have less remaining\n    capacity than the item to prevent unused bin scenarios.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Linear decreasing priority based on remaining capacity\n    # Use a max function to avoid negative priorities and ensure feasibility\n    priority = np.maximum(0, bins_remain_cap - item) / item\n    \n    # Give a diminishing return for bins that can't fit the item at all\n    priority = priority * (bins_remain_cap >= item)\n\n    return priority",
    "response_id": 3,
    "obj": 149.30195452732352,
    "SLOC": 12.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response4.txt_stdout.txt",
    "code_path": "problem_iter1_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Heuristic: The larger the remaining capacity, the higher the priority,\n    # but prioritize bins that will have more balanced capacity after the item is added.\n    priority_scores = bins_remain_cap - item\n    # Encourage balance by subtracting a small value for deviation from the average remaining capacity\n    avg_remain_cap = np.mean(bins_remain_cap)\n    balance_factor = 0.1 * (bins_remain_cap - avg_remain_cap)\n    priority_scores -= balance_factor\n    return priority_scores",
    "response_id": 4,
    "obj": 149.30195452732352,
    "SLOC": 12.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response5.txt_stdout.txt",
    "code_path": "problem_iter1_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This implementation considers both the remaining capacity and the number of\n    bins used an optimization heuristic. It favors bins with remaining capacity\n    just above the item size and penalizes bins that are very full, as they might\n    lead to fragmentation. \n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize scores with zeros\n    scores = np.zeros_like(bins_remain_cap)\n\n    # Calculate difference between remaining capacity and item size\n    diff = bins_remain_cap - item\n\n    # Assign scores: prioritize bins where item fits\n    # Penalize bins that are almost full but cannot fit the item\n    scores[diff == 0] = 1  # Perfect fit, highest priority\n    scores[(diff > 0) & (diff < min(item * 1.2, 10))] = 0.9  # Good matches,second priority\n    scores[(diff < 0) & (np.abs(diff) <= max(item * 0.2, 5))] = -0.5  # Small undercut, avoided the bin\n    scores[(diff < 0) & (np.abs(diff) > max(item * 0.2, 5))] = -1  # Large undercut, discouraged the bin\n\n    # Normalize scores with respect to the number of available bins\n    scores = scores / (np.sum(bins_remain_cap > 0) + 1)\n\n    return scores",
    "response_id": 5,
    "obj": 4.198244914240141,
    "SLOC": 12.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response6.txt_stdout.txt",
    "code_path": "problem_iter1_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This implementation considers both the remaining capacity and the number of\n    bins used penalties to encourage efficient packing while filling larger spaces.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # We give higher priority to bins with larger remaining capacity after placing the item\n    priority_score = bins_remain_cap - item\n    \n    # Bins that cannot fit the item should have a very low priority\n    priority_score[priority_score < 0] = -np.inf\n    \n    # Penalty for the number of bins used: more bins -> lower score\n    # Normalize the decrease in score by the maximum possible capacity to give relative importance\n    max_bin_cap = np.max(bins_remain_cap)\n    normalized_active_bins = np.sum(bins_remain_cap >= item) / len(bins_remain_cap)\n    penalty_per_bin = -normalized_active_bins * (max_bin_cap / len(bins_remain_cap))\n    \n    # Apply the penalty to the bins that can accept the item\n    valid_bins_mask = bins_remain_cap >= item\n    priority_score[valid_bins_mask] += penalty_per_bin[valid_bins_mask]\n    \n    return priority_score",
    "response_id": 6,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 30, in priority_v2\n    # Esteem higher prioritization to bins that, when using this item, have a higher density\nIndexError: invalid index to scalar variable.\n12\n4\n"
  },
  {
    "stdout_filepath": "problem_iter1_response7.txt_stdout.txt",
    "code_path": "problem_iter1_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This implementation considers both the remaining capacity and the number of\n    bins used using a weighted score. Bins that are closer to being full get higher\n    priority, but the priority is slightly reduced for bins that have less remaining\n    capacity than the item to prevent unused bin scenarios.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # If an item is larger than any remaining space in a bin, give it a negative priority\n    bins_full_enough = bins_remain_cap >= item\n    \n    # Create a base priority inversely proportional to the remaining space\n    base_priority = 1 / np.where(bins_full_enough, bins_remain_cap, np.inf)\n    \n    # Find the density score for each bin: inversely proportional to remaining capacity\n    bin_density_scores = 1 / np.maximum(bins_remain_cap, 1)  # Avoid infinites at zero capacity\n    \n    # Ensure non-eligible bins receive the minimum possible priority\n    densities_with_penalty = np.where(bins_full_enough, bin_density_scores, 0)\n    \n    # Esteem higher prioritization to bins that, when using this item, have a higher density\n    # Overall score will be average between base conclusion and density punishment\n    priority_score = 0.5 * densities_with_penalty + 0.5 * base_priority\n    \n    return priority_score",
    "response_id": 7,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response8.txt_stdout.txt",
    "code_path": "problem_iter1_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This implementation considers both the remaining capacity and the number of\n    bins used through a combination of the fullness score and the spread score.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the empty space in each bin\n    empty_space = bins_remain_cap\n    \n    # Calculate the fullness score for each bin (lower is better, as it means less wasted space)\n    # Prevent division by zero by adding a small epsilon\n    fullness_score = empty_space / (bins_remain_cap.sum() + 1e-10)\n    \n    # Calculate the spread score for each bin\n    # This score encourages choosing items that help in filling the bins more uniformly\n    filled_space = 1 - fullness_score\n    spread_score = filled_space.sum() - filled_space**2\n    \n    # Create a priority score that is high for bins with simulateous lowest fullness score and balanced distribution of items\n    # Adjust coefficients to tune between \"searching for a tight fit\" and \"saving room\"\n    priority_score = (1 - fullness_score - 0.1 * spread_score) * (bins_remain_cap >= item)\n    \n    # Penalize bins that cannot hold the item sufficiently\n    priority_score[bins_remain_cap < item] = -1\n    \n    return priority_score",
    "response_id": 8,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response9.txt_stdout.txt",
    "code_path": "problem_iter1_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This implementation considers both the remaining capacity and the number of\n    bins used logic to make a decision, slightly adjusting to favor bins that are \n    near full but can still fit the item. It minimizes the bin count by trying to \n    make use of spaces  optimally.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Ensuring that bins which do not have adequate remaining capacity get very low priority\n    feasible_mask = bins_remain_cap >= item\n    \n    # Inverse distance to full, the bins that have less space remaining after adding are prioritized\n    inverse_distance_to_full = (bins_remain_cap - item)[feasible_mask]\n    max_remaining = bins_remain_cap.max() if bins_remain_cap.max() != item else item\n    min_in_distance_to_full = 1 if bins_remain_cap.max() == item else 1 / (min(max_remaining - item, np.min(inverse_distance_to_full[np.nonzero(inverse_distance_to_full)])) if np.any(inverse_distance_to_full) else 1)\n    # Priorities are maximised if remaining spaces are least after adding, scaled linearly.\n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[feasible_mask] = min_in_distance_to_full / (inverse_distance_to_full + 1e-6)\n    \n    # Adding very small positive bias to capacities that are exactly the item size.\n    capacity_equals_item = (bins_remain_cap == item)\n    if np.any(capacity_equals_item):\n        priorities[target] += 1  # Increasing priority for upcoming near filled bins aromatic-ally, practically small-nudge\n    \n    return priorities",
    "response_id": 9,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 32, in priority_v2\n    low_plus_one = highest_remaining_capacities[1] if len(highest_remaining_capacities) > 1 else 0\nNameError: name 'target' is not defined\n12\n4\n"
  },
  {
    "stdout_filepath": "problem_iter1_response10.txt_stdout.txt",
    "code_path": "problem_iter1_code10.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This implementation considers both the remaining capacity and the number of\n    bins used using a weighted score. Bins that are closer to being full get higher\n    priority, but the priority is slightly reduced for bins that have less remaining\n    capacity than the item to prevent unused bin scenarios.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Linear decreasing priority based on remaining capacity\n    # Use a max function to avoid negative priorities and ensure feasibility\n    priority = np.maximum(0, bins_remain_cap - item) / item\n    \n    # Give a clear preference to bins that can fit the item at all\n    can_fit_item_mask = bins_remain_cap >= item\n    priority[np.where(~can_fit_item_mask)] -= 2\n    \n    # Encourage the second smallest gaps (fill bigger empty spots\u5c3d\u65e9 to encourage less fragmentation)\n    # Less penalty for bins pediatric returning subtle fragments after an insertion\n    if np.any(can_fit_item_mask):\n        priority_after_check = bins_remain_cap - item\n        highest_remaining_capacities = np.partition(priority_after_check[can_fit_item_mask], 1)[:2]\n        low = highest_remaining_capacities[0] if len(highest_remaining_capacities) > 1 else 0\n        low_plus_one = highest_remaining_capacities[1] if len(highest_remaining_capacities) > 1 else 0\n        near_low_wh_diff = (abs(low - priority_after_check[can_fit_item_mask]) \n                             <= (1 +\u998b (0.5**np.array(range(len(policy[can_fit_spresent_mask])))) * np.abs(low - low_plus_one)))\n        ind_second_low = near_low_wh_diff\n        priority[np.where(priority >= 0)[0][ind_second_low]] *= 0.5\n\n    return priority",
    "response_id": 10,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 34, in priority_v2\nNameError: name '\u998b' is not defined\n12\n4\n"
  },
  {
    "stdout_filepath": "problem_iter1_response11.txt_stdout.txt",
    "code_path": "problem_iter1_code11.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Penalty for creating empty spaces is proportional to the square of the space left\n    # if the item is placed in the bin. Also, bins with less remaining capacity get a higher priority.\n    priority_scores = bins_remain_cap - (bins_remain_cap - item) ** 2\n    # Give a penalty to bins where the item would overflow\n    priority_scores[bins_remain_cap < item] = -np.inf\n    return priority_scores",
    "response_id": 11,
    "obj": 4.11846828879138,
    "SLOC": 12.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response12.txt_stdout.txt",
    "code_path": "problem_iter1_code12.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This implementation considers both the remaining capacity and the number of\n    bins used using a heuristic that penalizes placing an item in a nearly full bin\n    and rewards placing it in a less occupied bin to avoid excessive fragmentation.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Avoid division by zero by ensuring that where bins_remain_cap is zero,\n    # we get a high penalty (. or low priority).\n    epsilon = 1e-10\n    remaining_cap = np.clip(bins_remain_cap, a_min=epsilon, a_max=None)\n    priority_scores = remaining_cap - item\n    \n    # Penalize bins that already contain many items by also considering the \n    # effect on future space occupancy.\n    # Using heuristic score that combines remaining capacity and current fragments\n    num_bins = bins_remain_cap.shape[0]\n    current_bin_state = (bins_remain_cap <= 0).astype(int)  # 1 if full else 0\n    delta_full_bins = np.zeros_like(bins_remain_cap)\n    \n    # Assuming max size of one bin = representative for problem average bin size\n    bin_size = bins_remain_cap[0] + item * (current_bin_state == 0).mean()\n    item_size_ratio = item / bin_size\n    \n    # LARGE penalty if it will overflow the bin, positive gain if benefits packing efficiency\n    penalty_for_overflow = 10 * item if (remaining_cap < item).any() else 0\n    \n    total_priority_score = (\n        (priority_scores / remaining_cap) -\n        0.3 * item_size_ratio * current_bin_state.sum() +\n        penalty_for_overflow\n    )\n    return total_priority_score",
    "response_id": 12,
    "obj": 149.30195452732352,
    "SLOC": 12.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response13.txt_stdout.txt",
    "code_path": "problem_iter1_code13.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This implementation considers both the remaining capacity and the number of\n    bins used penalties to encourage efficient packing while distributing load.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Penalize bins that are already fairly full\n    fullness_penalty = 1 - (bins_remain_cap / np.max(bins_remain_cap)) ** 2\n    \n    # Encourage using bins with enough space in comparison to the item size\n    capacity_utility = (bins_remain_cap - item) / bins_remain_cap\n    \n    # Penalize bins to avoid a situation where a singular bin is overloaded\n    num_bins_penalty = np.arange(len(bins_remain_cap)) / len(bins_remain_cap)\n    \n    # Combine different strategies\n    priority_scores = (\n        capacity_utility * 5  # Highly important, do not risk putting big items in small bins\n        - fullness_penalty  # Encourage full but not overcrowded bins\n        - num_bins_penalty * 0.1  # Slightly discourage using more bins\n    )\n    \n    # Prevent any negative utility due to insulting combinations of large items and small bins\n    priority_scores = np.clip(priority_scores, a_min=0, a_max=None)\n    \n    return priority_scores",
    "response_id": 13,
    "obj": 149.24212205823696,
    "SLOC": 12.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response14.txt_stdout.txt",
    "code_path": "problem_iter1_code14.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This implementation considers both the remaining capacity and the number of\n    bins used using a weighted score. Bins that are closer to being full get higher\n    priority, but the priority is slightly reduced for bins that have less remaining\n    capacity than the item to prevent unused bin scenarios.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Linear decreasing priority based on remaining capacity\n    # Use a max function to avoid negative priorities and ensure feasibility\n    priority = np.maximum(0, bins_remain_cap - item) / item\n    \n    # Give a diminishing return for bins that can't fit the current item\n    priority[bins_remain_cap < item] *= 0.1  # Reduce the priority significantly\n    \n    # Secondary measure: prioritize bins with lower remaining capacities to decrease fragmentation\n    normalized_capacity_remaining = (bins_remain_cap - bins_remain_cap.min()) * -1 / (bins_remain_cap.max() - bins_remain_cap.min()) if bins_remain_cap.max() != bins_remain_cap.min() else 0\n    priority += normalized_capacity_remaining * 0.4\n    \n    return priority",
    "response_id": 14,
    "obj": 145.13362584762663,
    "SLOC": 12.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response15.txt_stdout.txt",
    "code_path": "problem_iter1_code15.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This implementation considers both the remaining capacity and the number of\n    bins used using a weighted score. Bins that are closer to being full get higher\n    priority, but the priority is slightly reduced for bins that have less remaining\n    capacity than the item to prevent unused bin scenarios.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Linear decreasing priority based on remaining capacity\n    # Use a max function to avoid negative priorities and penalize bins with less remaining capacity than the item\n    priority_scores = np.where(bins_remain_cap >= item, (bins_remain_cap - item) / bins_remain_cap, -1)\n    \n    # Add a slight penalty for the number of empty spaces in bin capacity\n    # Assuming penalize larger empty spaces more by using cubed space\n    remaining_bins_after_placing_item = bins_remain_cap - item\n    penaltyBarButtonItemfeit Space} = [space^3]\n    penalty_scores = np.cbrt(remaining_bins_after_placing_item)\n    \n    # Discount penalty scores of bins with insufficient space to accommodate item\n    conditional_penalty_scores = np.where(bins_remain_cap >= item, penalty_scores, 0)\n    \n    # Final priority score by reducing penalty suggesting fill bins optimally\n    final_priority_scores = priority_scores - (conditional_penalty_scores / np.max(penalty_scores) if np.max(penalty_scores) > 0 else 0)\n\n    return final_priority_scores",
    "response_id": 15,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 9, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 25\n    penaltyBarButtonItemfeit Space} = [space^3]\n                                  ^\nSyntaxError: unmatched '}'\n12\n4\n"
  },
  {
    "stdout_filepath": "problem_iter1_response16.txt_stdout.txt",
    "code_path": "problem_iter1_code16.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Prioritize bins where adding the item will leave the least space unused\n    fullness_penalty = (bins_remain_cap - item) ** 2\n    overflow_penalty = np.where(bins_remain_cap < item, bins_remain_cap - item, 0) ** 2\n    priority_scores = -(fullness_penalty + overflow_penalty)\n\n    return priority_scores",
    "response_id": 16,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response17.txt_stdout.txt",
    "code_path": "problem_iter1_code17.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This implementation considers both the remaining capacity and the number of\n    bins used policy (First-Fit-Decreasing strategy).\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Give higher priority to bins where the item fits perfectly or almost perfectly\n    perfect_fit_scores = (bins_remain_cap - item == 0).astype(int) * 100\n    near_fit_scores = ((bins_remain_cap - item > 0) & (bins_remain_cap - item <= item * 0.1)).astype(int) * 50\n    \n    # Penalize bins that are already very small\n    size_penalty = - ((bins_remain_cap / np.max(bins_remain_cap, initial=1)) ** 2)\n    \n    # Calculate the final priority as a weighted sum\n    priority_scores = perfect_fit_scores + near_fit_scores + size_penalty\n    \n    return priority_scores",
    "response_id": 17,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response18.txt_stdout.txt",
    "code_path": "problem_iter1_code18.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This implementation considers both the remaining capacity and the number of\n    bins used logic to make a decision, where an attempt is made to balance\n    item distribution across bins to avoid any single bin being overloaded too\n    early.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Priority calculation: Higher scores are more favorable\n    # Encourages placing items in bins that have ideal room (not empty but not full either)\n    # Subtracts small value if the bin already contains an item to avoid first-item-in-bin policy\n    ideal_fit_score = np.where(bins_remain_cap >= item, (bins_remain_cap - item), -np.inf)\n    balance_score = np.array(bins_remain_cap != np.max(bins_remain_cap), dtype=float) * np.max(bins_remain_cap) * 0.1\n    non_empty_adjustment = np.full_like(bins_remain_cap, -1e-3)\n    non_empty_adjustment[bins_remain_cap < np.max(bins_remain_cap)] = 0\n\n    priority_scores = ideal_fit_score + balance_score + non_empty_adjustment\n    return priority_scores",
    "response_id": 18,
    "obj": 146.11088950937378,
    "SLOC": 12.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response19.txt_stdout.txt",
    "code_path": "problem_iter1_code19.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This implementation considers both the remaining capacity and the number of\n    bins used since favoring bins with lower remaining capacities (worse fit) may\n    lead to more bins being used overall.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    bins_new_cap = bins_remain_cap - item\n    \n    # Negative because our main criteria is how little space is left after the item\n    primary_criteria = -bins_new_cap\n    \n    # Secondary criteria: less used bins (favors filling existing ones)\n    secondary_criteria = np.count_nonzero(bins_remain_cap == max(bins_remain_cap))\n    \n    # Total priority will make sure primary is more important than secondary but take secondary into account\n    priority_score = primary_criteria - secondary_criteria * (np.min(bins_remain_cap) / 10 + 0.1)\n    \n    # Ensuring that negative priorities (cannot fit item) get negative scores\n    priority_score[bins_new_cap < 0] = -np.inf\n    \n    return priority_score",
    "response_id": 19,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response20.txt_stdout.txt",
    "code_path": "problem_iter1_code20.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This implementation considers both the remaining capacity and the number of\n    bins used penalties to encourage efficient packing while distributing load.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate normalized remaining capacity\n    remain_cap_normalized = bins_remain_cap / np.max(bins_remain_cap)\n    \n    # Penalize for each full bin\n    full_bins_penalty = np.where(bins_remain_cap > item, 1, 0)\n    \n    # Reward for larger remaining capacity\n    remaining_space_reward = remain_cap_normalized\n    \n    # Encourage the use of bins while avoiding overpacking\n    priority_scores = full_bins_penalty * remaining_space_reward / (np.sum(full_bins_penalty) + 1e-9)\n    \n    return priority_scores",
    "response_id": 20,
    "obj": 149.30195452732352,
    "SLOC": 12.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response21.txt_stdout.txt",
    "code_path": "problem_iter1_code21.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This implementation considers both the remaining capacity and the number of\n    bins used.\n    \n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the exact fit of the item in the remaining capacity\n    exact_fit = bins_remain_cap == item\n    \n    # Calculate a soft priority score for items that fit nearly perfectly with a small leftover\n    nearly_exact_fit = (bins_remain_cap / item) > 0.95\n    \n    # Penalty for leaving a lot of space, reducing the fill ratio\n    fill_ratio = (bins_remain_cap - item) / bins_remain_cap\n    \n    # Priority increases if the bin is not overly influenced by previously packed larger items\n    potential_wastage = (bins_remain_cap - item) ** 2\n    \n    # Combination of all these factors\n    priority_scores = (\n        100 * exact_fit + 60 * nearly_exact_fit -\n        50 * fill_ratio + \n        2 * (bins_remain_cap > item) / potential_wastage\n    )\n    \n    # Avoid nan values caused by division by zero\n    priority_scores[np.isnan(priority_scores)] = -np.inf\n    \n    return priority_scores",
    "response_id": 21,
    "obj": 5.195452732349436,
    "SLOC": 12.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response22.txt_stdout.txt",
    "code_path": "problem_iter1_code22.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This implementation considers both the remaining capacity and the number of\n    bins used the least. It aims to maximize space utilization while balancing the\n    distribution of items across bins.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Ensure we don't consider bins that don't have enough space\n    valid_bins = np.where(bins_remain_cap >= item)[0]\n    \n    # Stop considering any bins that are full or don't fit the item\n    if valid_bins.size == 0:\n        return np.zeros_like(bins_remain_cap)\n    \n    remaining_capacities = bins_remain_cap[valid_bins]\n    \n    # For strong capacity preference, square the remaining capacities to penalize free space.\n    # This encourages the policy to reduce the free space left in almost filled bins.\n    priorities = np.array([x**2 for x in remaining_capacities];\n    \n    # Penalize bins that already have items by a function of already used space.\n    existing_used_space = np.array([1 - capacity for capacity in remaining_capacities])\n    sqrt_used_space_len = np.sqrt(len(existing_used_space)) if len(existing_used_space) > 0 else 1\n    \n    # This method to balance communal spreading of weight across bins\n    priority_discounts = np.array([-np.log(idx + 1) / sqrt_used_space_len for idx in range(len(existing_used_space))])\n    \n    # Above can be any primitive means for producing less gives priority.\n    priorities -= existing_used_space * 2  /*** Arithmetic combined spreading.penalty RISKY\u5168\u80fd Against generic assignEntityManager.prepend ***/\n    \n    # Cheap alternative that if bin ith already being bigger ti end up no decredy abandon last is len(bins_remain_cp then choose ..\n    # other gaining fixed helium of keto(dr refers krist offsets alternatives))+priority_discounts\n    \n    final_priorities = np.zeros_like(bins_remain_cap)\n    final_priorities[valid_bins] = priorities\n    \n    return final_priorities",
    "response_id": 22,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 9, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 28\n    priorities = np.array([x**2 for x in remaining_capacities];\n                                                              ^\nSyntaxError: invalid syntax\n12\n4\n"
  },
  {
    "stdout_filepath": "problem_iter1_response23.txt_stdout.txt",
    "code_path": "problem_iter1_code23.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This implementation considers both the remaining capacity and the number of\n    bins used using a weighted score. Bins that are closer to being full get higher\n    priority, but the priority is slightly reduced for bins that have less remaining\n    capacity than the item to fit as we aim to avoid creating a completely full bin.\n    \n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    #Scores considering remaining capacity inversely\n    score_remaining_cap = np.where(bins_remain_cap >= item, bins_remain_cap, -np.inf)\n    # Adjusting the score making bins with smaller remaining capacity less attractive\n    score_remaining_cap -= (1/(bins_remain_cap + 1e-6) - 1/(bins_remain_cap + 1 - item + 1e-6)) * (bins_remain_cap > item) * 100\n    \n    # Penal Concavity:a smooth function like sqrt or tanh can be used instead of-linear.\n    score_variance= np.sqrt(bins_remain_cap) *10 # Bin with capacity spread well attracts less.i.e unless\u7cb1 squize peacefully.\n\n    # Final scores\n    scores = score_remaining_cap - score_variance  \n    return scores",
    "response_id": 23,
    "obj": 80.92341443956921,
    "SLOC": 12.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response24.txt_stdout.txt",
    "code_path": "problem_iter1_code24.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Heuristic: First calculate how much space would be left in each bin if we add the item\n    space_left = bins_remain_cap - item\n    \n    # Calculate the priority score: bins with less space left after adding the item have higher priority\n    # Also consider bins that can fit the item with some remaining space rather than bins left completely empty\n    priority_scores = np.where(space_left >= 0, space_left, -np.inf)  # Penalize bins that can't fit the item\n    \n    # Normalize the priority scores to avoid bias based on bin size\n    normalized_priorities = (priority_scores - np.min(priority_scores)) / (np.max(priority_scores) - np.min(priority_scores))\n    \n    # Increase the priority of bins with remaining space but favor bins that can fit the item with some space balancing emptier bins\n    return normalized_priorities + (bins_remain_cap / np.max(bins_remain_cap))",
    "response_id": 24,
    "obj": 149.30195452732352,
    "SLOC": 12.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response25.txt_stdout.txt",
    "code_path": "problem_iter1_code25.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This implementation prioritizes bins that have the least remaining capacity above the item size or are already full.\n    Such an approach helps in keeping bins from becoming unused and underutilized.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Bins that can fit the item\n    can_fit_mask = bins_remain_cap >= item\n    # Priority scores: bins that can't fit the item have priority 0\n    priority_scores = np.where(can_fit_mask, bins_remain_cap - item, -np.inf)\n    # Inverse the priority so bins with just enough space have higher priority\n    priority_scores = -priority_scores\n    # Ensure that bins with exact fit get highest priority, denoted by np.inf\n    priority_scores = np.where(bins_remain_cap - item == 0, np.inf, priority_scores)\n    return priority_scores",
    "response_id": 25,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response26.txt_stdout.txt",
    "code_path": "problem_iter1_code26.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This implementation considers both the remaining capacity and the number of\n    bins used using a weighted score. Bins that are closer to being full get higher\n    priority, but the priority is slightly reduced for bins that have less remaining\n    capacity than the item to prevent unused bin scenarios.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Linear decreasing priority based on remaining capacity\n    # Use a max function to avoid negative priorities and ensure feasibility\n    priority = np.maximum(0, bins_remain_cap - item) / item\n    \n    # Give a clear preference to bins that can fit the item at all\n    can_fit_item_mask = bins_remain_cap >= item\n    priority[np.where(~can_fit_item_mask)] -= 2\n    \n    # Encourage the second smallest gaps (fill bigger empty spots\u5c3d\u65e9 to encourage less fragmentation)\n    # Less penalty for bins pediatric returning subtle fragments after an insertion\n    if np.any(can_fit_item_mask):\n        priority_after_check = bins_remain_cap - item\n        highest_remaining_capacities = np.partition(priority_after_check[can_fit_item_mask], 1)[:2]\n        low = highest_remaining_capacities[0] if len(highest_remaining_capacities) > 1 else 0\n        low_idx = np.where(np.isclose(priority_after_check, low))[0]\n        if len(low_idx) == 1:\n            priority[low_idx[0]] += 1  # boost solitare other fragment accent withok followers much step-water pour toplant\u0131\n    \n    return priority",
    "response_id": 26,
    "obj": 145.26326286398086,
    "SLOC": 12.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response27.txt_stdout.txt",
    "code_path": "problem_iter1_code27.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This implementation considers both the remaining capacity and the number of\n    bins used using a weighted score. Bins that are closer to being full get higher\n    priority, but the priority is slightly reduced for bins that have less remaining\n    capacity than the item to prevent unused bin scenarios.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Linear decreasing priority based on remaining capacity\n    # Use a max function to avoid negative priorities and ensure feasibility\n    priority = np.maximum(0, bins_remain_cap - item) / item\n    \n    # Give a clear preference to bins that can fit the item at all\n    can_fit_item_mask = bins_remain_cap >= item\n    priority[np.where(~can_fit_item_mask)] -= 2\n    \n    # Encourage the second smallest gaps (fill bigger empty spots\u5c3d\u65e9 to encourage less fragmentation)\n    # Less penalty for bins pediatric returning subtle fragments after an insertion\n    if np.any(can_fit_item_mask):\n        priority_after_check = bins_remain_cap - item\n        highest_remaining_capacities = np.partition(priority_after_check[can_fit_item_mask], 1)[:2]\n        low = highest_remaining_capacities[0] if len(highest_remaining_capacities) > 1 else 0\n        low_idx = np.where(np.isclose(priority_after_check, low))[0]\n        if len(low_idx) == 1:\n            priority[low_idx[0]] += 1  # boost solitare other fragment accent withok followers much step-water pour toplant\u0131\n    \n    return priority",
    "response_id": 27,
    "obj": 145.26326286398086,
    "SLOC": 12.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response28.txt_stdout.txt",
    "code_path": "problem_iter1_code28.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This implementation considers both the remaining capacity and the number of\n    bins used using a weighted score. Bins that are closer to being full get higher\n    priority, but the priority is slightly reduced for bins that have less remaining\n    capacity than the item to prevent unused bin scenarios.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Linear decreasing priority based on remaining capacity\n    # Use a max function to avoid negative priorities and ensure feasibility\n    priority = np.maximum(0, bins_remain_cap - item) / item\n    \n    # Give a clear preference to bins that can fit the item at all\n    can_fit_item_mask = bins_remain_cap >= item\n    priority[np.where(~can_fit_item_mask)] -= 2\n    \n    # Encourage the second smallest gaps (fill bigger empty spots\u5c3d\u65e9 to encourage less fragmentation)\n    # Less penalty for bins pediatric returning subtle fragments after an insertion\n    if np.any(can_fit_item_mask):\n        priority_after_check = bins_remain_cap - item\n        highest_remaining_capacities = np.partition(priority_after_check[can_fit_item_mask], 1)[:2]\n        low = highest_remaining_capacities[0] if len(highest_remaining_capacities) > 1 else 0\n        low_idx = np.where(np.isclose(priority_after_check, low))[0]\n        if len(low_idx) == 1:\n            priority[low_idx[0]] += 1  # boost solitare other fragment accent withok followers much step-water pour toplant\u0131\n    \n    return priority",
    "response_id": 28,
    "obj": 145.26326286398086,
    "SLOC": 12.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response29.txt_stdout.txt",
    "code_path": "problem_iter1_code29.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This implementation considers both the remaining capacity and the number of\n    bins used using a weighted score. Bins that are closer to being full get higher\n    priority, but the priority is slightly reduced for bins that have less remaining\n    capacity than the item to prevent unused bin scenarios.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Linear decreasing priority based on remaining capacity\n    # Use a max function to avoid negative priorities and ensure feasibility\n    priority = np.maximum(0, bins_remain_cap - item) / item\n    \n    # Give a clear preference to bins that can fit the item at all\n    can_fit_item_mask = bins_remain_cap >= item\n    priority[np.where(~can_fit_item_mask)] -= 2\n    \n    # Encourage the second smallest gaps (fill bigger empty spots\u5c3d\u65e9 to encourage less fragmentation)\n    # Less penalty for bins pediatric returning subtle fragments after an insertion\n    if np.any(can_fit_item_mask):\n        priority_after_check = bins_remain_cap - item\n        highest_remaining_capacities = np.partition(priority_after_check[can_fit_item_mask], 1)[:2]\n        low = highest_remaining_capacities[0] if len(highest_remaining_capacities) > 1 else 0\n        low_idx = np.where(np.isclose(priority_after_check, low))[0]\n        if len(low_idx) == 1:\n            priority[low_idx[0]] += 1  # boost solitare other fragment accent withok followers much step-water pour toplant\u0131\n    \n    return priority",
    "response_id": 29,
    "obj": 145.26326286398086,
    "SLOC": 12.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  }
]