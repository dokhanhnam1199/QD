import numpy as np

def heuristics_v2(distance_matrix):
  """{This algorithm samples multiple solutions using a nearest neighbor heuristic with stochastic restarts and edge acceptance probabilities based on edge distance normalized to the minimum edge distance and an exponential decay based on the frequency of edge occurrences in the sampled solutions.}"""
  n = distance_matrix.shape[0]
  num_samples = 100
  heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

  for _ in range(num_samples):
    start_node = np.random.randint(n)
    current_node = start_node
    unvisited_nodes = set(range(n))
    unvisited_nodes.remove(current_node)
    path = [current_node]

    while unvisited_nodes:
      nearest_neighbor = None
      min_distance = float('inf')
      for neighbor in unvisited_nodes:
        distance = distance_matrix[current_node, neighbor]
        if distance < min_distance:
          min_distance = distance
          nearest_neighbor = neighbor

      path.append(nearest_neighbor)
      unvisited_nodes.remove(nearest_neighbor)
      current_node = nearest_neighbor

    path.append(start_node)

    for i in range(n):
      node1 = path[i]
      node2 = path[i+1]
      heuristics_matrix[node1, node2] += 1
      heuristics_matrix[node2, node1] += 1

  min_distance = np.min(distance_matrix[distance_matrix > 0])

  for i in range(n):
    for j in range(n):
      if i != j:
        heuristics_matrix[i, j] = np.exp(-(distance_matrix[i, j] / min_distance)) * (heuristics_matrix[i, j] / num_samples)
      else:
        heuristics_matrix[i, j] = 0

  return heuristics_matrix
