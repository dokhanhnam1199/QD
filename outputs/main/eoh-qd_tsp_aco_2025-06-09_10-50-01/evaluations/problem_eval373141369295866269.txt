import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm iteratively samples random tours, uses reinforcement learning to update edge probabilities based on tour length, and returns a matrix representing edge desirability.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.ones_like(distance_matrix, dtype=float) / n  # Initialize with uniform probabilities
    learning_rate = 0.1
    num_samples = 1000
    
    for _ in range(num_samples):
        # Generate a random tour based on current edge probabilities
        tour = [np.random.choice(n)]
        available_nodes = set(range(n))
        available_nodes.remove(tour[0])
        
        while available_nodes:
            current_node = tour[-1]
            probabilities = heuristics_matrix[current_node, :]
            probabilities[tour] = 0  # Avoid visiting already visited nodes
            probabilities = probabilities / np.sum(probabilities)
            next_node = np.random.choice(n, p=probabilities)
            tour.append(next_node)
            available_nodes.remove(next_node)

        tour = np.array(tour)
        
        # Calculate the tour length
        tour_length = 0
        for i in range(n - 1):
            tour_length += distance_matrix[tour[i], tour[i+1]]
        tour_length += distance_matrix[tour[-1], tour[0]]
        
        # Update heuristics matrix based on tour length (reinforcement learning)
        reward = -tour_length  # Shorter tours get higher rewards
        
        for i in range(n - 1):
            heuristics_matrix[tour[i], tour[i+1]] += learning_rate * reward
            heuristics_matrix[tour[i+1], tour[i]] += learning_rate * reward  # Ensure symmetry
        heuristics_matrix[tour[-1], tour[0]] += learning_rate * reward
        heuristics_matrix[tour[0], tour[-1]] += learning_rate * reward  # Ensure symmetry
        
        # Ensure probabilities are non-negative and normalize
        heuristics_matrix = np.clip(heuristics_matrix, 0, None)
        for i in range(n):
            row_sum = np.sum(heuristics_matrix[i,:])
            if row_sum > 0:
                heuristics_matrix[i,:] = heuristics_matrix[i,:]/row_sum
            else:
                heuristics_matrix[i,:] = np.ones(n)/n

    return heuristics_matrix
