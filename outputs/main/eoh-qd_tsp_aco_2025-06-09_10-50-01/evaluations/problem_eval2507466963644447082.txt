import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm constructs a spanning tree using Prim's algorithm with a random starting node, then performs a depth-first search (DFS) to generate a tour, and aggregates edge frequencies from multiple such tours to create a heuristics matrix.}"""
    n = distance_matrix.shape[0]
    num_samples = 100
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

    for _ in range(num_samples):
        # 1. Prim's Algorithm for Minimum Spanning Tree (MST)
        start_node = np.random.randint(n)
        visited = {start_node}
        edges = []
        
        while len(visited) < n:
            min_dist = float('inf')
            best_edge = None

            for u in visited:
                for v in range(n):
                    if v not in visited and distance_matrix[u, v] < min_dist:
                        min_dist = distance_matrix[u, v]
                        best_edge = (u, v)

            if best_edge:
                u, v = best_edge
                edges.append((u, v))
                visited.add(v)

        # 2. Depth-First Search (DFS) for Tour Generation
        graph = {i: [] for i in range(n)}
        for u, v in edges:
            graph[u].append(v)
            graph[v].append(u)

        tour = []
        stack = [start_node]
        visited_dfs = set()

        while stack:
            node = stack.pop()
            if node not in visited_dfs:
                tour.append(node)
                visited_dfs.add(node)
                
                neighbors = graph[node]
                for neighbor in sorted(neighbors, reverse=True):  # Visit neighbors in reverse order
                    if neighbor not in visited_dfs:
                        stack.append(neighbor)
                        
        tour.append(start_node)  # Return to starting node

        # 3. Aggregate Edge Frequencies
        for i in range(len(tour) - 1):
            u = tour[i]
            v = tour[i+1]
            heuristics_matrix[u, v] += 1
            heuristics_matrix[v, u] += 1

    heuristics_matrix = heuristics_matrix / num_samples
    return heuristics_matrix
