import numpy as np

def heuristics_v2(distance_matrix):
    """
    {This algorithm generates multiple random tours, applies a greedy nearest neighbor approach to refine them, and aggregates edge frequencies across these refined tours to estimate edge desirability.}
    """
    num_nodes = distance_matrix.shape[0]
    num_iterations = 100
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

    for _ in range(num_iterations):
        # 1. Generate a random tour
        tour = np.random.permutation(num_nodes)
        
        # 2. Refine the tour using a greedy nearest neighbor approach
        refined_tour = greedy_nearest_neighbor(tour, distance_matrix)

        # 3. Update heuristics_matrix based on the refined tour
        for i in range(num_nodes):
            node1 = refined_tour[i]
            node2 = refined_tour[(i + 1) % num_nodes]
            heuristics_matrix[node1, node2] += 1
            heuristics_matrix[node2, node1] += 1

    # Normalize the heuristics matrix
    heuristics_matrix = heuristics_matrix / num_iterations

    return heuristics_matrix

def greedy_nearest_neighbor(initial_tour, distance_matrix):
    """
    Refines a tour using a greedy nearest neighbor approach.
    """
    num_nodes = len(initial_tour)
    current_tour = initial_tour.copy()
    
    for start_node_index in range(num_nodes):
      start_node = current_tour[start_node_index]
      best_neighbor = -1
      best_neighbor_index = -1
      min_distance = float('inf')

      for i in range(num_nodes):
          if i != start_node_index:
              neighbor = current_tour[i]
              distance = distance_matrix[start_node, neighbor]
              if distance < min_distance:
                  min_distance = distance
                  best_neighbor = neighbor
                  best_neighbor_index = i
      
      if best_neighbor_index != (start_node_index + 1) % num_nodes:
          
          neighbor_to_swap = current_tour[(start_node_index + 1) % num_nodes]
          
          index_to_swap = -1
          for k in range(num_nodes):
              if current_tour[k] == best_neighbor:
                  index_to_swap = k
                  break
                  
          current_tour[(start_node_index + 1) % num_nodes] = best_neighbor
          current_tour[index_to_swap] = neighbor_to_swap
    
    return heuristics_matrix
