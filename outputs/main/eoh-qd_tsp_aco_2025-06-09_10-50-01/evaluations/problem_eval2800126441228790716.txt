import numpy as np

def heuristics_v2(distance_matrix):
  """{This algorithm samples multiple random tours, scores edges based on their frequency in short tours, and returns a matrix indicating the likelihood of each edge being in a good TSP solution, weighting shorter tours more heavily.}"""
  n = distance_matrix.shape[0]
  num_samples = 1000
  heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
  tour_lengths = []

  for _ in range(num_samples):
    tour = np.random.permutation(n)
    tour_length = 0
    for i in range(n - 1):
      tour_length += distance_matrix[tour[i], tour[i+1]]
    tour_length += distance_matrix[tour[-1], tour[0]]
    tour_lengths.append((tour, tour_length))
  
  tour_lengths.sort(key=lambda x: x[1])
  
  top_tours = tour_lengths[:int(num_samples * 0.1)]
  
  min_tour_length = top_tours[0][1]
  
  for tour, tour_length in top_tours:
    weight = max(0, (2 * min_tour_length) / (tour_length + min_tour_length))
    for i in range(n - 1):
      heuristics_matrix[tour[i], tour[i+1]] += weight
      heuristics_matrix[tour[i+1], tour[i]] += weight
    heuristics_matrix[tour[-1], tour[0]] += weight
    heuristics_matrix[tour[0], tour[-1]] += weight

  return heuristics_matrix
