import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm combines random tour sampling with local search and updates edge probabilities based on improved tour lengths.}"""
    n = distance_matrix.shape[0]
    num_samples = 500
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

    for _ in range(num_samples):
        # Generate a random tour
        tour = np.random.permutation(n)
        
        # Improve tour using 2-opt local search
        best_tour = tour
        best_tour_length = calculate_tour_length(distance_matrix, tour)
        
        for i in range(n):
            for j in range(i + 2, n):
                new_tour = tour[:i] + list(reversed(tour[i:j+1])) + tour[j+1:]
                new_tour_length = calculate_tour_length(distance_matrix, new_tour)

                if new_tour_length < best_tour_length:
                    best_tour = new_tour
                    best_tour_length = new_tour_length
        
        # Update the heuristics matrix based on the improved tour length
        for i in range(n - 1):
            heuristics_matrix[best_tour[i], best_tour[i+1]] += 1.0 / best_tour_length
            heuristics_matrix[best_tour[i+1], best_tour[i]] += 1.0 / best_tour_length # Ensure symmetry
        heuristics_matrix[best_tour[-1], best_tour[0]] += 1.0 / best_tour_length
        heuristics_matrix[best_tour[0], best_tour[-1]] += 1.0 / best_tour_length # Ensure symmetry

    return heuristics_matrix

def calculate_tour_length(distance_matrix, tour):
    n = len(tour)
    tour_length = 0
    for i in range(n - 1):
        tour_length += distance_matrix[tour[i], tour[i+1]]
    tour_length += distance_matrix[tour[-1], tour[0]]
    return heuristics_matrix
