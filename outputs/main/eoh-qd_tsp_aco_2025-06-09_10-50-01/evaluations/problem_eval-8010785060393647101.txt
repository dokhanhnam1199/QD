import numpy as np

def heuristics_v2(distance_matrix):
    """
    {This algorithm constructs a heuristic matrix by iteratively improving random tours through local search (2-opt swaps) and recording the frequency of edges in the refined tours.}
    """
    num_nodes = distance_matrix.shape[0]
    num_samples = 100
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

    def two_opt_swap(tour, i, k):
        """Performs a 2-opt swap on a tour."""
        new_tour = tour[:i] + tour[i:k+1][::-1] + tour[k+1:]
        return new_tour

    def tour_length(tour):
        """Calculates the length of a given tour."""
        length = 0
        for i in range(num_nodes - 1):
            length += distance_matrix[tour[i], tour[i+1]]
        length += distance_matrix[tour[-1], tour[0]]
        return length

    for _ in range(num_samples):
        # Generate a random initial tour
        tour = np.random.permutation(num_nodes).tolist()
        
        # Improve the tour using 2-opt swaps
        improved = True
        while improved:
            improved = False
            for i in range(num_nodes):
                for k in range(i + 1, num_nodes):
                    new_tour = two_opt_swap(tour, i, k)
                    if tour_length(new_tour) < tour_length(tour):
                        tour = new_tour
                        improved = True
        
        # Update the heuristics matrix based on edge inclusion in the improved tour
        for i in range(num_nodes):
            node1 = tour[i]
            node2 = tour[(i + 1) % num_nodes]
            heuristics_matrix[node1, node2] += 1
            heuristics_matrix[node2, node1] += 1  # Assuming symmetric distance matrix

    heuristics_matrix /= num_samples  # Normalize to get frequency
    return heuristics_matrix
