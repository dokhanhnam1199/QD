import numpy as np

def heuristics_v2(distance_matrix):
    """
    {This algorithm generates multiple random tours, improves them using a simplified 2-opt swap that only considers a fixed number of neighbors, and aggregates edge frequencies with a weighted average based on tour length to estimate edge desirability.}
    """
    num_nodes = distance_matrix.shape[0]
    num_iterations = 100
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

    for _ in range(num_iterations):
        # 1. Generate a random tour
        tour = np.random.permutation(num_nodes)
        
        # 2. Improve the tour using a simplified 2-opt swaps
        improved_tour, tour_length = simplified_two_opt(tour, distance_matrix)

        # 3. Update heuristics_matrix based on the improved tour and its length
        weight = 1.0 / (tour_length + 1e-6)  # Weight inversely proportional to tour length
        for i in range(num_nodes):
            node1 = improved_tour[i]
            node2 = improved_tour[(i + 1) % num_nodes]
            heuristics_matrix[node1, node2] += weight
            heuristics_matrix[node2, node1] += weight

    # Normalize the heuristics matrix
    heuristics_matrix = heuristics_matrix / num_iterations

    return heuristics_matrix

def simplified_two_opt(route, distance_matrix, neighborhood_size=5):
    """
    Implements a simplified 2-opt swap that only considers a fixed number of neighbors.
    Returns the improved route and its length.
    """
    best_route = route.copy()
    best_length = calculate_tour_length(route, distance_matrix)
    improved = True
    while improved:
        improved = False
        for i in range(1, len(route) - 2):
            for k_index in range(1, min(neighborhood_size + 1, len(route) - i)):
                k = i + k_index
                if k >= len(route):
                    break

                new_route = route[:i] + route[i:k][::-1] + route[k:]
                new_length = calculate_tour_length(new_route, distance_matrix)

                if new_length < best_length:
                    best_route = new_route.copy()
                    best_length = new_length
                    improved = True
        route = best_route.copy()  # update route for next iteration
    return best_route, best_length

def calculate_tour_length(route, distance_matrix):
    """
    Calculates the total length of a given tour.
    """
    total_length = 0
    num_nodes = len(route)
    for i in range(num_nodes):
        node1 = route[i]
        node2 = route[(i + 1) % num_nodes]
        total_length += distance_matrix[node1, node2]
    return heuristics_matrix
