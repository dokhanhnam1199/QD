import numpy as np

def heuristics_v2(distance_matrix):
    """
    {This algorithm estimates edge importance by sampling random tours, accepting tours probabilistically based on their length relative to the average distance, and then averaging the frequency with which each edge appears in the accepted tours, weighted by the acceptance probability.}
    """
    n = distance_matrix.shape[0]
    num_samples = 1000
    avg_distance = np.mean(distance_matrix)
    
    edge_counts = np.zeros_like(distance_matrix, dtype=float)
    total_weight = 0.0

    for _ in range(num_samples):
        # Generate a random tour
        tour = np.random.permutation(n)
        tour_length = 0
        for i in range(n - 1):
            tour_length += distance_matrix[tour[i], tour[i+1]]
        tour_length += distance_matrix[tour[-1], tour[0]]

        # Calculate acceptance probability based on tour length
        acceptance_prob = np.exp(-tour_length / (avg_distance * n))
        
        #Update the total weights
        total_weight += acceptance_prob

        # Update edge counts weighted by acceptance probability
        for i in range(n - 1):
            edge_counts[tour[i], tour[i+1]] += acceptance_prob
            edge_counts[tour[i+1], tour[i]] += acceptance_prob  # Ensure symmetry
        edge_counts[tour[-1], tour[0]] += acceptance_prob
        edge_counts[tour[0], tour[-1]] += acceptance_prob
            
    # Normalize edge counts to get probabilities
    if total_weight > 0:
        heuristics_matrix = edge_counts / total_weight
    else:
        heuristics_matrix = np.ones_like(distance_matrix) / (n * (n - 1)) # Initialize with small values, avoiding division by zero.

    return heuristics_matrix
