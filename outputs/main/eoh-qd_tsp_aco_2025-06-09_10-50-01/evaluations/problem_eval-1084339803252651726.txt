import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm uses a genetic algorithm approach to evolve promising edge sets and constructs a heuristic matrix based on the frequency of edges in the final population.}"""
    n = distance_matrix.shape[0]
    num_samples = 50
    population_size = 100
    mutation_rate = 0.1
    generations = 30

    # Initialize population with random edge sets
    population = []
    for _ in range(population_size):
        edge_set = set()
        for i in range(n):
            for j in range(i + 1, n):
                if np.random.rand() < 0.1:  #sparse connection
                    edge_set.add((i, j))
        population.append(edge_set)

    def calculate_fitness(edge_set):
        total_distance = 0
        if not edge_set:
          return float('inf')

        
        try:
          import networkx as nx
          graph = nx.Graph()
          graph.add_nodes_from(range(n))
          graph.add_edges_from(edge_set)
          if not nx.is_connected(graph):
            return float('inf')
          
          degrees = [graph.degree(node) for node in graph.nodes()]
          if any(degree == 0 for degree in degrees):
            return float('inf')

          mst = nx.minimum_spanning_tree(graph, weight = lambda u, v, d: distance_matrix[u][v])
          total_distance = sum(distance_matrix[edge[0], edge[1]] for edge in mst.edges())
        except:
          return float('inf')
        return total_distance
        


    # Evolve the population
    for _ in range(generations):
        # Evaluate fitness
        fitness_scores = [calculate_fitness(edge_set) for edge_set in population]
        
        # Selection (tournament selection)
        selected_parents = []
        for _ in range(population_size):
            tournament_indices = np.random.choice(population_size, 2, replace=False)
            if fitness_scores[tournament_indices[0]] < fitness_scores[tournament_indices[1]]:
                selected_parents.append(population[tournament_indices[0]])
            else:
                selected_parents.append(population[tournament_indices[1]])

        # Crossover (combine edges from parents)
        new_population = []
        for i in range(0, population_size, 2):
            parent1 = selected_parents[i]
            parent2 = selected_parents[i+1 if i+1 < population_size else i]
            child_edge_set = parent1.union(parent2)
            new_population.append(child_edge_set)

        # Mutation (add or remove random edges)
        for edge_set in new_population:
            if np.random.rand() < mutation_rate:
                node1 = np.random.randint(n)
                node2 = np.random.randint(n)
                if node1 != node2:
                    if (node1, node2) in edge_set:
                        edge_set.remove((node1, node2))
                    elif (node2, node1) in edge_set:
                        edge_set.remove((node2, node1))
                    else:
                        edge_set.add((node1, node2))

        population = new_population
    # Aggregate edge frequencies in the final population
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    for edge_set in population:
        for edge in edge_set:
            u, v = edge
            heuristics_matrix[u, v] += 1
            heuristics_matrix[v, u] += 1

    # Normalize the heuristic matrix
    heuristics_matrix /= population_size

    return heuristics_matrix
