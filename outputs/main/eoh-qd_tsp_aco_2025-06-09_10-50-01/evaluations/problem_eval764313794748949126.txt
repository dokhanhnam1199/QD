import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm samples multiple random tours, biases their edge weights based on tour length, and averages those biased weights to create a heuristic.}"""
    num_nodes = distance_matrix.shape[0]
    num_samples = 100
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

    for _ in range(num_samples):
        # Generate a random tour
        nodes = list(range(num_nodes))
        np.random.shuffle(nodes)
        nodes.append(nodes[0])  # Return to start

        # Calculate tour length
        tour_length = 0
        for i in range(num_nodes):
            tour_length += distance_matrix[nodes[i], nodes[i+1]]

        # Bias edge weights based on tour length (shorter tours get higher weights)
        if tour_length > 0:  # Avoid division by zero
            weight = 1.0 / tour_length
        else:
            weight = 0.0  # Assign a zero weight if the tour length is zero.

        # Update heuristics matrix
        for i in range(num_nodes):
            node1 = nodes[i]
            node2 = nodes[i + 1]
            heuristics_matrix[node1, node2] += weight
            heuristics_matrix[node2, node1] += weight  # Symmetric

    heuristics_matrix /= num_samples
    return heuristics_matrix
