import numpy as np

def heuristics_v2(distance_matrix):
  """{This algorithm constructs a heuristic matrix by iteratively refining edge weights based on the shortest path found using Dijkstra's algorithm with stochastically perturbed edge costs, rewarding edges used in shorter paths.}"""
  n = distance_matrix.shape[0]
  heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
  num_iterations = 100

  for _ in range(num_iterations):
    # Perturb the distance matrix to explore different paths
    perturbed_matrix = distance_matrix + np.random.normal(0, np.std(distance_matrix)/10, size=distance_matrix.shape)
    perturbed_matrix = np.maximum(perturbed_matrix, 0)  # Ensure distances are non-negative

    # Choose a random starting node
    start_node = np.random.randint(n)

    # Run Dijkstra's algorithm to find the shortest path from the start node to all other nodes
    distances = np.full(n, np.inf)
    distances[start_node] = 0
    visited = np.zeros(n, dtype=bool)
    previous = np.full(n, -1, dtype=int)

    for _ in range(n):
      # Find the unvisited node with the smallest distance
      min_dist = np.inf
      u = -1
      for v in range(n):
        if not visited[v] and distances[v] < min_dist:
          min_dist = distances[v]
          u = v

      if u == -1:
        break

      visited[u] = True

      # Update distances to neighbors of u
      for v in range(n):
        if perturbed_matrix[u, v] > 0 and distances[u] + perturbed_matrix[u, v] < distances[v]:
          distances[v] = distances[u] + perturbed_matrix[u, v]
          previous[v] = u

    # Update the heuristics matrix based on the edges used in the shortest paths
    for end_node in range(n):
      if end_node != start_node and previous[end_node] != -1:
        current_node = end_node
        while current_node != start_node:
          prev_node = previous[current_node]
          heuristics_matrix[prev_node, current_node] += 1
          heuristics_matrix[current_node, prev_node] += 1
          current_node = prev_node

  # Normalize the heuristics matrix
  heuristics_matrix = heuristics_matrix / num_iterations
  return heuristics_matrix
