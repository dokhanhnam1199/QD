import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm constructs a heuristic matrix by combining shortest path distances with a penalty for distant nodes and a bonus for close nodes, reflecting the likelihood of an edge being part of an optimal tour.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    
    # Calculate shortest path between all pairs of nodes
    shortest_paths = np.zeros_like(distance_matrix, dtype=float)
    for i in range(n):
        for j in range(n):
            if i != j:
                
                unvisited = set(range(n))
                current_distances = np.full(n, np.inf)
                current_distances[i] = 0
                
                while unvisited:
                    current_node = min(unvisited, key=lambda node: current_distances[node])
                    unvisited.remove(current_node)
                    
                    for neighbor in range(n):
                        if distance_matrix[current_node, neighbor] != 0:
                            new_distance = current_distances[current_node] + distance_matrix[current_node, neighbor]
                            if new_distance < current_distances[neighbor]:
                                current_distances[neighbor] = new_distance
                shortest_paths[i,j] = current_distances[j]
    
    max_dist = np.max(shortest_paths)
    
    for i in range(n):
        for j in range(n):
            if i != j:
                # Base heuristic: inverse of shortest path distance
                heuristics_matrix[i, j] = 1 / (shortest_paths[i, j] + 1e-6)  # Avoid division by zero

                # Penalty for distant nodes
                heuristics_matrix[i, j] -= shortest_paths[i, j] / (2 * max_dist)

                # Bonus for very close nodes
                heuristics_matrix[i,j] += (max_dist - shortest_paths[i, j])/(2*max_dist) # add a bonus if the nodes are close to each other

    return heuristics_matrix
