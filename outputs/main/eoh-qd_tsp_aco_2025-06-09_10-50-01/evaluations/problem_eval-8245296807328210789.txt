import numpy as np

def heuristics_v2(distance_matrix):
  """{This algorithm samples multiple near-optimal TSP solutions using a greedy nearest neighbor heuristic with random restarts and incorporates edge costs based on distance into a heuristic matrix.}"""
  n = distance_matrix.shape[0]
  num_samples = 100

  edge_costs = np.zeros_like(distance_matrix, dtype=float)
  
  for _ in range(num_samples):
    start_node = np.random.randint(n)
    unvisited = set(range(n))
    unvisited.remove(start_node)
    current_node = start_node
    tour = [start_node]
    
    while unvisited:
      nearest_neighbor = min(unvisited, key=lambda node: distance_matrix[current_node, node])
      tour.append(nearest_neighbor)
      edge_costs[current_node, nearest_neighbor] += 1 / distance_matrix[current_node, nearest_neighbor]
      edge_costs[nearest_neighbor, current_node] += 1 / distance_matrix[nearest_neighbor, current_node]
      current_node = nearest_neighbor
      unvisited.remove(nearest_neighbor)
      
    tour.append(start_node)
    edge_costs[current_node, start_node] += 1 / distance_matrix[current_node, start_node]
    edge_costs[start_node, current_node] += 1 / distance_matrix[start_node, current_node]

  heuristics_matrix = edge_costs / num_samples
  return heuristics_matrix
