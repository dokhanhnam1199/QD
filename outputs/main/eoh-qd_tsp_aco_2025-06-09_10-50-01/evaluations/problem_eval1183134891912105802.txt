import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm iteratively samples random tours, biases the sampling towards shorter tours using an inverse power law, and accumulates edge usage counts to estimate edge probabilities for inclusion in the final solution.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    num_samples = 1000  # Number of tours to sample
    
    for _ in range(num_samples):
        # Generate a random tour
        tour = np.random.permutation(n)
        
        # Calculate the tour length
        tour_length = 0
        for i in range(n - 1):
            tour_length += distance_matrix[tour[i], tour[i+1]]
        tour_length += distance_matrix[tour[-1], tour[0]]
        
        # Bias the contribution based on tour length using inverse power law
        weight = 1.0 / (tour_length ** 2) if tour_length > 0 else 0  # Avoid division by zero

        # Update heuristics matrix based on edges in the tour
        for i in range(n - 1):
            heuristics_matrix[tour[i], tour[i+1]] += weight
            heuristics_matrix[tour[i+1], tour[i]] += weight  # Ensure symmetry
        heuristics_matrix[tour[-1], tour[0]] += weight
        heuristics_matrix[tour[0], tour[-1]] += weight  # Ensure symmetry
    
    # Normalize heuristics matrix
    if np.max(heuristics_matrix) > 0:
        heuristics_matrix = heuristics_matrix / np.max(heuristics_matrix)

    return heuristics_matrix
