import numpy as np

def heuristics_v2(distance_matrix):
    """
    {This algorithm constructs tours by iteratively adding the shortest edge that doesn't create subtours, biasing edge selection based on a combination of edge length and a pheromone-like trace updated by successful tours.}
    """
    n = distance_matrix.shape[0]
    pheromone = np.ones_like(distance_matrix)
    alpha = 1  # Pheromone influence
    beta = 2   # Distance influence
    num_iterations = 100

    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

    for _ in range(num_iterations):
        tour = []
        unvisited = set(range(n))
        current_node = np.random.choice(list(unvisited))
        tour.append(current_node)
        unvisited.remove(current_node)

        while unvisited:
            probabilities = np.zeros(n)
            for neighbor in range(n):
                if neighbor in unvisited:
                    probabilities[neighbor] = (pheromone[current_node, neighbor]**alpha) / (distance_matrix[current_node, neighbor]**beta)
            
            if np.sum(probabilities) == 0:
                next_node = np.random.choice(list(unvisited))
            else:
                probabilities /= np.sum(probabilities)
                next_node = np.random.choice(n, p=probabilities)
                while next_node not in unvisited: #In case of numerical instability
                    next_node = np.random.choice(n, p=probabilities)
            
            tour.append(next_node)
            unvisited.remove(next_node)
            current_node = next_node
        
        tour.append(tour[0])
        tour_length = 0
        for i in range(n):
            tour_length += distance_matrix[tour[i], tour[i+1]]

        # Update pheromone and heuristics matrix
        delta_pheromone = 1.0 / tour_length
        for i in range(n):
            pheromone[tour[i], tour[i+1]] += delta_pheromone
            pheromone[tour[i+1], tour[i]] += delta_pheromone
            heuristics_matrix[tour[i], tour[i+1]] += 1.0
            heuristics_matrix[tour[i+1], tour[i]] += 1.0
            
    # Normalize
    heuristics_matrix = (heuristics_matrix + heuristics_matrix.T) / 2
    total = np.sum(heuristics_matrix)

    if total>0:
        heuristics_matrix /= total

    return heuristics_matrix
