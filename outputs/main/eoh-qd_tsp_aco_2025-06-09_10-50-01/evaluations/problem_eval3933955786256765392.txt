import numpy as np

def heuristics_v3(distance_matrix):
    """
    {This algorithm samples multiple random tours, calculates the length of each tour, weights the edges based on the inverse of the tour length, and uses these weighted edge frequencies as heuristics.}
    """
    n = distance_matrix.shape[0]
    num_samples = 1000
    edge_weights = np.zeros_like(distance_matrix, dtype=float)

    for _ in range(num_samples):
        nodes = list(range(1, n))
        np.random.shuffle(nodes)
        tour = [0] + nodes + [0]
        
        tour_length = 0
        for i in range(n):
            tour_length += distance_matrix[tour[i], tour[i+1]]

        # Weight the contribution of this tour based on its length
        weight = 1.0 / tour_length if tour_length > 0 else 0.0  # Avoid division by zero

        for i in range(n):
            u = tour[i]
            v = tour[i+1]
            edge_weights[u, v] += weight
            edge_weights[v, u] += weight

    # Normalize the edge weights
    total_weight = np.sum(edge_weights)
    if total_weight > 0:
        heuristics_matrix = edge_weights / total_weight
    else:
        heuristics_matrix = np.zeros_like(distance_matrix)

    return heuristics_matrix
