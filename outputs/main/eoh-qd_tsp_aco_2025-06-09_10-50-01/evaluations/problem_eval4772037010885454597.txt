import numpy as np

def heuristics_v2(distance_matrix):
    """
    {This algorithm estimates the probability of including an edge in the optimal TSP tour by sampling random tours, records edge occurrences in tours shorter than the best tour found so far, and normalizes the counts to obtain a heuristic matrix.}
    """
    n = distance_matrix.shape[0]
    num_samples = 1000
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    best_tour_length = float('inf')

    for _ in range(num_samples):
        # Generate a random tour
        tour = np.random.permutation(n)
        
        # Calculate the tour length
        tour_length = 0
        for i in range(n - 1):
            tour_length += distance_matrix[tour[i], tour[i + 1]]
        tour_length += distance_matrix[tour[n - 1], tour[0]]
        
        # Update best tour length
        if tour_length < best_tour_length:
            best_tour_length = tour_length

        if tour_length < best_tour_length:
            # Increment the counts for edges in the tour
            for i in range(n - 1):
                heuristics_matrix[tour[i], tour[i + 1]] += 1
                heuristics_matrix[tour[i + 1], tour[i]] += 1 # Symmetry
            heuristics_matrix[tour[n - 1], tour[0]] += 1
            heuristics_matrix[tour[0], tour[n-1]] += 1
            
    # Normalize the matrix to get probabilities
    total_occurrences = np.sum(heuristics_matrix)
    if total_occurrences > 0:
        heuristics_matrix /= total_occurrences

    return heuristics_matrix
