import numpy as np

def heuristics_v2(distance_matrix):
  """{This algorithm iteratively refines tours by swapping edges to minimize length, storing frequency of edges in improved tours as heuristics.}"""
  n = distance_matrix.shape[0]
  num_iterations = 1000
  heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
  num_accepted = 0

  for _ in range(num_iterations):
    tour = np.random.permutation(n)
    tour_length = 0
    for i in range(n - 1):
      tour_length += distance_matrix[tour[i], tour[i+1]]
    tour_length += distance_matrix[tour[-1], tour[0]]

    improved_tour = tour.copy()
    improved_length = tour_length

    for i in range(n):
      for j in range(i + 2, n):
        new_tour = tour.copy()
        new_tour[i+1:j+1] = np.flip(new_tour[i+1:j+1])

        new_length = 0
        for k in range(n - 1):
          new_length += distance_matrix[new_tour[k], new_tour[k+1]]
        new_length += distance_matrix[new_tour[-1], new_tour[0]]
        
        if new_length < improved_length:
          improved_tour = new_tour
          improved_length = new_length

    if improved_length < tour_length:
      num_accepted += 1
      for i in range(n - 1):
        heuristics_matrix[improved_tour[i], improved_tour[i+1]] += 1
        heuristics_matrix[improved_tour[i+1], improved_tour[i]] += 1
      heuristics_matrix[improved_tour[-1], improved_tour[0]] += 1
      heuristics_matrix[improved_tour[0], improved_tour[-1]] += 1

  if num_accepted > 0:
    heuristics_matrix = heuristics_matrix / num_accepted
  return heuristics_matrix
