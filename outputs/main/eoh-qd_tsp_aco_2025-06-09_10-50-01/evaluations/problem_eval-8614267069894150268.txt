import numpy as np

def heuristics_v2(distance_matrix):
    """
    {This algorithm samples multiple near-optimal tours using a greedy approach, calculates the frequency of each edge appearing in these tours, and uses these frequencies as heuristics to indicate the likelihood of an edge being part of the optimal TSP solution.}
    """
    n = distance_matrix.shape[0]
    num_samples = 1000
    edge_counts = np.zeros_like(distance_matrix, dtype=float)

    for _ in range(num_samples):
        # Generate a tour using a greedy approach
        current_node = 0
        unvisited_nodes = set(range(1, n))
        tour = [0]

        while unvisited_nodes:
            nearest_node = None
            min_distance = float('inf')
            for neighbor in unvisited_nodes:
                distance = distance_matrix[current_node, neighbor]
                if distance < min_distance:
                    min_distance = distance
                    nearest_node = neighbor

            tour.append(nearest_node)
            unvisited_nodes.remove(nearest_node)
            current_node = nearest_node

        tour.append(0)  # Return to the starting node

        # Count the occurrences of each edge in the tour
        for i in range(n):
            u = tour[i]
            v = tour[i+1]
            edge_counts[u, v] += 1
            edge_counts[v, u] += 1  # Assuming symmetric distance matrix

    # Normalize the edge counts to get probabilities (heuristics)
    heuristics_matrix = edge_counts / num_samples

    return heuristics_matrix
