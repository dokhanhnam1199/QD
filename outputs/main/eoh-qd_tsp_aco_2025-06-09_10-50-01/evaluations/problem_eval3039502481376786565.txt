import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm samples TSP solutions using a stochastic nearest neighbor heuristic and scores each edge based on a combination of frequency and normalized distance, favoring frequent edges and penalizing long edges more heavily.}"""
    n = distance_matrix.shape[0]
    num_samples = 100
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

    for _ in range(num_samples):
        start_node = np.random.randint(n)
        current_node = start_node
        unvisited_nodes = set(range(n))
        unvisited_nodes.remove(current_node)
        path = [current_node]

        while unvisited_nodes:
            neighbors = list(unvisited_nodes)
            distances = [distance_matrix[current_node, neighbor] for neighbor in neighbors]
            probabilities = np.exp(-np.array(distances) / np.mean(distances))  # Softmax-like
            probabilities /= np.sum(probabilities)
            
            nearest_neighbor = np.random.choice(neighbors, p=probabilities)

            path.append(nearest_neighbor)
            unvisited_nodes.remove(nearest_neighbor)
            current_node = nearest_neighbor

        path.append(start_node)

        for i in range(n):
            node1 = path[i]
            node2 = path[i+1]
            heuristics_matrix[node1, node2] += 1
            heuristics_matrix[node2, node1] += 1

    mean_distance = np.mean(distance_matrix)

    for i in range(n):
        for j in range(n):
            if i != j:
                heuristics_matrix[i, j] = (heuristics_matrix[i, j] / num_samples) / (distance_matrix[i, j] / mean_distance)**2
            else:
                heuristics_matrix[i, j] = 0

    return heuristics_matrix
