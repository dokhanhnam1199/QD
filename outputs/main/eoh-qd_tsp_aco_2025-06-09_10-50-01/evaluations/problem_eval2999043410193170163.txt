import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm uses simulated annealing to sample low-cost tours and uses the frequency of edge appearance in these tours to build a heuristic matrix.}"""
    n = distance_matrix.shape[0]
    num_samples = 100
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

    def calculate_cost(path):
        cost = 0
        for i in range(len(path) - 1):
            cost += distance_matrix[path[i], path[i+1]]
        return cost

    def generate_neighbor(path):
        a = np.random.randint(1, len(path) - 1)
        b = np.random.randint(1, len(path) - 1)
        if a > b:
            a, b = b, a
        new_path = path[:a] + path[a:b+1][::-1] + path[b+1:]
        return new_path

    for _ in range(num_samples):
        # Initial random tour
        path = np.random.permutation(n).tolist()
        path.append(path[0])
        
        current_cost = calculate_cost(path)
        current_path = path[:]

        temperature = 1.0
        cooling_rate = 0.95
        
        for _ in range(100): # Iterate to converge a single tour
            neighbor_path = generate_neighbor(current_path)
            neighbor_cost = calculate_cost(neighbor_path)
            
            cost_diff = neighbor_cost - current_cost

            if cost_diff < 0:
                current_cost = neighbor_cost
                current_path = neighbor_path[:]
            else:
                if np.random.rand() < np.exp(-cost_diff / temperature):
                    current_cost = neighbor_cost
                    current_path = neighbor_path[:]
            
            temperature *= cooling_rate
        
        # Update heuristics matrix based on edge inclusion
        for i in range(n):
            node1 = current_path[i]
            node2 = current_path[i+1]
            heuristics_matrix[node1, node2] += 1
            heuristics_matrix[node2, node1] += 1
            
    heuristics_matrix /= num_samples
    return heuristics_matrix
