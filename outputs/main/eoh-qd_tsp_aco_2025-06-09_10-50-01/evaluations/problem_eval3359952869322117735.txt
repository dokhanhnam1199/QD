import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm iteratively refines a heuristic matrix by rewarding edges present in short tours constructed using the current heuristic and penalizing edges in long tours.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.ones_like(distance_matrix)
    alpha = 0.1  # Learning rate
    num_iterations = 100

    for _ in range(num_iterations):
        # Construct a tour based on the current heuristics
        tour = [0]
        unvisited = set(range(1, n))
        while unvisited:
            current_node = tour[-1]
            best_neighbor = None
            best_heuristic_value = -np.inf
            for neighbor in unvisited:
                heuristic_value = heuristics_matrix[current_node, neighbor]
                if heuristic_value > best_heuristic_value:
                    best_heuristic_value = heuristic_value
                    best_neighbor = neighbor
            tour.append(best_neighbor)
            unvisited.remove(best_neighbor)
        tour.append(0)

        # Calculate the tour length
        tour_length = 0
        for i in range(n):
            tour_length += distance_matrix[tour[i], tour[i+1]]

        # Update the heuristic matrix based on the tour length
        for i in range(n):
            u = tour[i]
            v = tour[i+1]
            if tour_length < np.mean(distance_matrix):
                heuristics_matrix[u, v] += alpha
                heuristics_matrix[v, u] += alpha
            else:
                heuristics_matrix[u, v] -= alpha
                heuristics_matrix[v, u] -= alpha

        # Normalize the heuristic matrix
        min_val = np.min(heuristics_matrix)
        max_val = np.max(heuristics_matrix)
        heuristics_matrix = (heuristics_matrix - min_val) / (max_val - min_val)

    return heuristics_matrix
