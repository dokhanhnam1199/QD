import numpy as np

def heuristics_v2(distance_matrix):
  """{This algorithm samples multiple random tours, scores edges based on their frequency in short tours, and returns a matrix indicating the likelihood of each edge being in a good TSP solution, where the edge score is weighted by the inverse rank of the tour length.}"""
  n = distance_matrix.shape[0]
  num_samples = 1000
  heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
  tour_lengths = []

  for _ in range(num_samples):
    tour = np.random.permutation(n)
    tour_length = 0
    for i in range(n - 1):
      tour_length += distance_matrix[tour[i], tour[i+1]]
    tour_length += distance_matrix[tour[-1], tour[0]]
    tour_lengths.append((tour, tour_length))
  
  tour_lengths.sort(key=lambda x: x[1])
  
  for rank, (tour, _) in enumerate(tour_lengths):
    weight = 1.0 / (rank + 1)
    for i in range(n - 1):
      heuristics_matrix[tour[i], tour[i+1]] += weight
      heuristics_matrix[tour[i+1], tour[i]] += weight
    heuristics_matrix[tour[-1], tour[0]] += weight
    heuristics_matrix[tour[0], tour[-1]] += weight

  return heuristics_matrix
