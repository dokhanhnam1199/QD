import numpy as np

def heuristics_v2(distance_matrix):
  """{This algorithm uses a genetic algorithm approach to evolve a population of tours and returns a heuristic matrix based on the frequency of edges in the best tours.}"""
  n = distance_matrix.shape[0]
  population_size = 100
  num_generations = 50
  mutation_rate = 0.01

  def calculate_tour_length(tour):
    length = 0
    for i in range(n - 1):
      length += distance_matrix[tour[i], tour[i+1]]
    length += distance_matrix[tour[-1], tour[0]]
    return length

  def create_initial_population(population_size):
    population = []
    for _ in range(population_size):
      population.append(np.random.permutation(n))
    return population

  def selection(population, fitness_scores):
    # Tournament selection
    selected_indices = np.random.choice(len(population), size=population_size, replace=True, p=fitness_scores/np.sum(fitness_scores))
    selected_population = [population[i] for i in selected_indices]
    return selected_population

  def crossover(parent1, parent2):
      start = np.random.randint(0, n)
      end = np.random.randint(start + 1, n + 1) if start < n-1 else n
      
      child1 = np.concatenate((parent1[start:end], [city for city in parent2 if city not in parent1[start:end]]))
      return child1

  def mutate(tour, mutation_rate):
    if np.random.rand() < mutation_rate:
      i, j = np.random.choice(n, 2, replace=False)
      tour[i], tour[j] = tour[j], tour[i]
    return tour

  population = create_initial_population(population_size)

  for _ in range(num_generations):
    fitness_scores = np.array([1 / calculate_tour_length(tour) for tour in population])
    selected_population = selection(population, fitness_scores)

    new_population = []
    for i in range(0, population_size, 2):
      parent1 = selected_population[i]
      parent2 = selected_population[i+1 if i+1 < population_size else i]

      child1 = crossover(parent1, parent2)
      child2 = crossover(parent2, parent1)

      child1 = mutate(child1, mutation_rate)
      child2 = mutate(child2, mutation_rate)

      new_population.append(child1)
      new_population.append(child2)
    
    population = new_population[:population_size]

  best_tour = min(population, key=calculate_tour_length)
  
  heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
  for i in range(n - 1):
    heuristics_matrix[best_tour[i], best_tour[i+1]] = 1
    heuristics_matrix[best_tour[i+1], best_tour[i]] = 1
  heuristics_matrix[best_tour[-1], best_tour[0]] = 1
  heuristics_matrix[best_tour[0], best_tour[-1]] = 1
  
  return heuristics_matrix
