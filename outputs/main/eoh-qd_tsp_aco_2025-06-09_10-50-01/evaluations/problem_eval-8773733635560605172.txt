import numpy as np

def heuristics_v2(distance_matrix):
    """
    {This algorithm estimates the probability of including an edge in the optimal TSP tour by sampling random tours, weighting them by their length, and normalizing the weighted edge occurrences to obtain a heuristic matrix.}
    """
    n = distance_matrix.shape[0]
    num_samples = 1000
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

    for _ in range(num_samples):
        # Generate a random tour
        tour = np.random.permutation(n)
        
        # Calculate the tour length
        tour_length = 0
        for i in range(n - 1):
            tour_length += distance_matrix[tour[i], tour[i + 1]]
        tour_length += distance_matrix[tour[n - 1], tour[0]]

        # Weight based on tour length (shorter tours have higher weight)
        weight = np.exp(-tour_length / (n * np.mean(distance_matrix)))

        # Increment the counts for edges in the tour, weighted by tour length
        for i in range(n - 1):
            heuristics_matrix[tour[i], tour[i + 1]] += weight
            heuristics_matrix[tour[i + 1], tour[i]] += weight  # Symmetry
        heuristics_matrix[tour[n - 1], tour[0]] += weight
        heuristics_matrix[tour[0], tour[n - 1]] += weight

    # Normalize the matrix to get probabilities
    total_occurrences = np.sum(heuristics_matrix)
    if total_occurrences > 0:
        heuristics_matrix /= total_occurrences

    return heuristics_matrix
