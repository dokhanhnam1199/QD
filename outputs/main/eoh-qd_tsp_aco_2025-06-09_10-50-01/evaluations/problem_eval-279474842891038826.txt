import numpy as np

def heuristics_v2(distance_matrix):
    """
    {This algorithm samples multiple random tours, calculates the frequency of each edge appearing in those tours, and uses these frequencies as heuristics to indicate the likelihood of an edge being part of the optimal TSP solution.}
    """
    n = distance_matrix.shape[0]
    num_samples = 1000
    edge_counts = np.zeros_like(distance_matrix, dtype=float)

    for _ in range(num_samples):
        # Generate a random permutation of nodes (excluding the starting node)
        nodes = list(range(1, n))
        np.random.shuffle(nodes)
        tour = [0] + nodes + [0]  # Start and end at node 0

        # Count the occurrences of each edge in the tour
        for i in range(n):
            u = tour[i]
            v = tour[i+1]
            edge_counts[u, v] += 1
            edge_counts[v, u] += 1  # Assuming symmetric distance matrix

    # Normalize the edge counts to get probabilities (heuristics)
    heuristics_matrix = edge_counts / num_samples

    return heuristics_matrix
