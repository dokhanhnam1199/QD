import numpy as np

def heuristics_v2(distance_matrix):
  """{This algorithm uses a genetic algorithm approach to evolve a population of tours, scoring edges based on their frequency in the best tours of each generation.}"""
  n = distance_matrix.shape[0]
  population_size = 100
  num_generations = 50
  mutation_rate = 0.01

  population = [np.random.permutation(n) for _ in range(population_size)]

  def calculate_fitness(tour):
    tour_length = 0
    for i in range(n - 1):
      tour_length += distance_matrix[tour[i], tour[i+1]]
    tour_length += distance_matrix[tour[-1], tour[0]]
    return -tour_length  # Negative because we want to maximize fitness (minimize length)

  def crossover(parent1, parent2):
    start = np.random.randint(n)
    end = np.random.randint(start + 1, n + 1)
    child = np.zeros(n, dtype=int) - 1
    child[start:end] = parent1[start:end]
    
    remaining = [node for node in parent2 if node not in child]
    
    child_idx = 0
    for i in range(n):
      if child[i] == -1:
        child[i] = remaining[child_idx]
        child_idx += 1
    return child

  def mutate(tour):
    if np.random.rand() < mutation_rate:
      i, j = np.random.choice(n, 2, replace=False)
      tour[i], tour[j] = tour[j], tour[i]
    return tour
  
  heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

  for _ in range(num_generations):
    fitness_scores = [calculate_fitness(tour) for tour in population]
    
    # Select best parents based on fitness
    selected_indices = np.argsort(fitness_scores)[-population_size // 2:]
    selected_parents = [population[i] for i in selected_indices]

    # Create new population through crossover and mutation
    new_population = selected_parents.copy()
    while len(new_population) < population_size:
      parent1 = np.random.choice(selected_parents)
      parent2 = np.random.choice(selected_parents)
      child = crossover(parent1, parent2)
      child = mutate(child)
      new_population.append(child)
    
    population = new_population

    # Score edges based on the best tour in the current generation
    best_tour = population[np.argmax([calculate_fitness(tour) for tour in population])]
    for i in range(n - 1):
      heuristics_matrix[best_tour[i], best_tour[i+1]] += 1
      heuristics_matrix[best_tour[i+1], best_tour[i]] += 1
    heuristics_matrix[best_tour[-1], best_tour[0]] += 1
    heuristics_matrix[best_tour[0], best_tour[-1]] += 1

  return heuristics_matrix
