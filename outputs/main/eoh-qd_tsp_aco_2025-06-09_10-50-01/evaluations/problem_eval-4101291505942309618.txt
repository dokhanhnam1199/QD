import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm combines random tour generation with a biased edge selection based on shortest distances and refines the tour using iterative edge swapping and edge frequency updating.}"""
    num_nodes = distance_matrix.shape[0]
    num_iterations = 100
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

    for _ in range(num_iterations):
        # 1. Generate a random tour
        tour = np.random.permutation(num_nodes)

        # 2. Bias the tour based on edge distances
        biased_tour = tour.copy()
        for i in range(num_nodes):
            node1 = biased_tour[i]
            node2 = biased_tour[(i + 1) % num_nodes]

            # With a small probability, swap node2 with a closer node
            if np.random.rand() < 0.1:
                closest_node = -1
                min_dist = np.inf
                for j in range(num_nodes):
                    if biased_tour[j] != node1 and distance_matrix[node1, biased_tour[j]] < min_dist:
                        min_dist = distance_matrix[node1, biased_tour[j]]
                        closest_node = biased_tour[j]

                if closest_node != -1:
                    index_closest = np.where(biased_tour == closest_node)[0][0]
                    biased_tour[(i + 1) % num_nodes], biased_tour[index_closest] = biased_tour[index_closest], biased_tour[(i + 1) % num_nodes]
            
        # 3. Improve the biased tour using 2-opt swaps
        improved_tour = two_opt(biased_tour, distance_matrix)
        
        # 4. Update heuristics_matrix based on the improved tour
        for i in range(num_nodes):
            node1 = improved_tour[i]
            node2 = improved_tour[(i + 1) % num_nodes]
            heuristics_matrix[node1, node2] += 1
            heuristics_matrix[node2, node1] += 1

    # Normalize the heuristics matrix
    heuristics_matrix = heuristics_matrix / num_iterations

    return heuristics_matrix

def two_opt(route, distance_matrix):
    """
    Implements 2-opt swaps to improve a given route.
    """
    best_route = route.copy()
    improved = True
    while improved:
        improved = False
        for i in range(1, len(route) - 2):
            for k in range(i + 1, len(route)):
                if k - i == 1:
                    continue  # Skip adjacent edges
                new_route = route[:i] + route[i:k][::-1] + route[k:]
                
                current_cost = (
                    distance_matrix[route[i - 1], route[i]] +
                    distance_matrix[route[k - 1], route[k]]
                )
                new_cost = (
                    distance_matrix[route[i - 1], route[k - 1]] +
                    distance_matrix[route[i], route[k]]
                )
                
                if new_cost < current_cost:
                    best_route = new_route.copy()
                    route = new_route.copy()
                    improved = True
    return heuristics_matrix
