import numpy as np

def heuristics_v2(distance_matrix):
    """
    {This algorithm constructs a Minimum Spanning Tree (MST) using Prim's algorithm, then derives heuristics from the MST structure and shortest paths between nodes.}
    """
    n = distance_matrix.shape[0]
    mst = np.zeros_like(distance_matrix)
    
    # Prim's Algorithm for MST
    visited = [False] * n
    key = [float('inf')] * n
    parent = [None] * n
    
    key[0] = 0
    
    for _ in range(n):
        u = np.argmin(key)
        visited[u] = True
        key[u] = float('inf')
        
        for v in range(n):
            if not visited[v] and distance_matrix[u, v] > 0 and distance_matrix[u, v] < key[v]:
                parent[v] = u
                key[v] = distance_matrix[u, v]
                
    for v in range(1, n):
        if parent[v] is not None:
            mst[v, parent[v]] = 1
            mst[parent[v], v] = 1
            
    # Shortest path heuristic
    shortest_paths = np.zeros_like(distance_matrix)
    for i in range(n):
        for j in range(n):
            if i != j:
                #Dijkstra Algorithm
                dist = [float('inf')] * n
                dist[i] = 0
                unvisited = list(range(n))

                while unvisited:
                    u = min(unvisited, key=lambda node: dist[node])
                    unvisited.remove(u)

                    for v in range(n):
                        if distance_matrix[u, v] > 0 and dist[u] + distance_matrix[u, v] < dist[v]:
                            dist[v] = dist[u] + distance_matrix[u, v]
                shortest_paths[i,j] = dist[j]

    # Combine MST and shortest path information
    heuristics_matrix = mst + (1.0 / (shortest_paths + np.eye(n)))

    return heuristics_matrix
