import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm iteratively refines a heuristics matrix by sampling solutions using a combination of shortest distance and edge frequency from previous iterations, balancing exploration and exploitation.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.ones_like(distance_matrix)  # Initialize with equal probability

    num_iterations = 50
    num_samples = 30
    alpha = 0.7 #weight for distance
    beta = 0.3 #weight for edge frequency

    for iteration in range(num_iterations):
        edge_frequencies = np.zeros_like(distance_matrix)
        
        for _ in range(num_samples):
            current_node = np.random.randint(n)
            unvisited_nodes = set(range(n))
            unvisited_nodes.remove(current_node)
            path = [current_node]

            while unvisited_nodes:
                # Combine distance and edge frequency
                combined_metric = (alpha * (1.0 / (distance_matrix[current_node, :] + 1e-6))) + (beta * heuristics_matrix[current_node,:])
                
                # Mask visited nodes
                combined_metric[list(path)] = 0
                
                # Normalize probabilities
                probabilities = combined_metric / np.sum(combined_metric)

                # Select next node
                next_node = np.random.choice(n, p=probabilities)
                
                if next_node not in unvisited_nodes: #safety check
                   available_nodes = list(unvisited_nodes)
                   if available_nodes:
                       next_node = available_nodes[0] #take the first one
                   else:
                       break
                
                path.append(next_node)
                unvisited_nodes.remove(next_node)
                current_node = next_node
            
            path.append(path[0]) # Return to start

            # Update edge frequencies
            for i in range(len(path) - 1):
                u = path[i]
                v = path[i + 1]
                edge_frequencies[u, v] += 1
                edge_frequencies[v, u] += 1
        
        # Normalize edge frequencies
        edge_frequencies /= num_samples

        # Update heuristics matrix
        heuristics_matrix = (0.8 * heuristics_matrix) + (0.2 * edge_frequencies)

    return heuristics_matrix
