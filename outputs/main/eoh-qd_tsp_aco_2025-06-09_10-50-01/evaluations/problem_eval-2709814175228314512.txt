import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm uses simulated annealing to explore the solution space and constructs a heuristic matrix based on the frequency of edges appearing in accepted states.}"""
    num_nodes = distance_matrix.shape[0]
    num_iterations = 10000
    temperature = 1.0
    cooling_rate = 0.999
    
    # Initialize a random tour
    current_tour = np.random.permutation(num_nodes)
    current_cost = tour_cost(distance_matrix, current_tour)
    
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    
    for _ in range(num_iterations):
        # Generate a neighbor by swapping two random nodes
        i, j = np.random.choice(num_nodes, 2, replace=False)
        new_tour = current_tour.copy()
        new_tour[i], new_tour[j] = new_tour[j], new_tour[i]
        new_cost = tour_cost(distance_matrix, new_tour)
        
        # Acceptance probability
        if new_cost < current_cost or np.random.rand() < np.exp((current_cost - new_cost) / temperature):
            current_tour = new_tour
            current_cost = new_cost
            
            # Update heuristics matrix
            for k in range(num_nodes):
                node1 = current_tour[k]
                node2 = current_tour[(k + 1) % num_nodes]
                heuristics_matrix[node1, node2] += 1
                heuristics_matrix[node2, node1] += 1
        
        # Cool down the temperature
        temperature *= cooling_rate
    
    # Normalize the heuristics matrix
    heuristics_matrix /= num_iterations
    
    return heuristics_matrix

def tour_cost(distance_matrix, tour):
    """Calculate the cost of a given tour."""
    cost = 0
    num_nodes = len(tour)
    for i in range(num_nodes):
        cost += distance_matrix[tour[i], tour[(i + 1) % num_nodes]]
    return heuristics_matrix
