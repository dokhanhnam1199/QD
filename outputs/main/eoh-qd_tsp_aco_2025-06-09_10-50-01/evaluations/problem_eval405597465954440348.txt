import numpy as np

def heuristics_v2(distance_matrix):
    """
    {This algorithm initializes heuristics based on inverse distance, then iteratively samples solutions using these heuristics, and updates the heuristics based on edge frequency in sampled solutions, enhanced with edge-closeness in top solutions.}
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = 1.0 / (distance_matrix + np.eye(n))
    
    num_iterations = 100
    num_samples = 50
    temperature = 1.0

    for _ in range(num_iterations):
        solutions = []
        solution_costs = []
        
        # Sample solutions based on current heuristics
        for _ in range(num_samples):
            current_node = np.random.randint(n)
            unvisited_nodes = list(range(n))
            unvisited_nodes.remove(current_node)
            
            solution = [current_node]
            solution_cost = 0
            
            while unvisited_nodes:
                probabilities = heuristics_matrix[current_node, unvisited_nodes]
                probabilities = np.exp(probabilities / temperature) / np.sum(np.exp(probabilities / temperature))
                
                next_node_index = np.random.choice(len(unvisited_nodes), p=probabilities)
                next_node = unvisited_nodes[next_node_index]
                
                solution.append(next_node)
                solution_cost += distance_matrix[current_node, next_node]
                
                current_node = next_node
                unvisited_nodes.remove(next_node)
            
            solution_cost += distance_matrix[solution[-1], solution[0]]
            solutions.append(solution)
            solution_costs.append(solution_cost)
        
        # Update heuristics based on sampled solutions
        edge_counts = np.zeros_like(distance_matrix)
        
        # Prioritize top solutions
        top_solutions_indices = np.argsort(solution_costs)[:num_samples // 5]
        for solution_index in top_solutions_indices:
            solution = solutions[solution_index]
            for i in range(n):
                u = solution[i]
                v = solution[(i + 1) % n]
                edge_counts[u, v] += 2  # Higher weight for top solutions
                edge_counts[v, u] += 2

        # Add all sampled solutions to edge counts
        for solution in solutions:
            for i in range(n):
                u = solution[i]
                v = solution[(i + 1) % n]
                edge_counts[u, v] += 1
                edge_counts[v, u] += 1
                
        # Normalize edge counts
        edge_counts /= np.max(edge_counts) if np.max(edge_counts) > 0 else 1

        heuristics_matrix = 0.9 * heuristics_matrix + 0.1 * edge_counts
        temperature *= 0.95 

    return heuristics_matrix
