import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm employs a minimum spanning tree (MST) approximation, followed by edge weighting based on frequency of inclusion in shortest paths within the MST.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

    # Prim's algorithm for MST approximation
    mst_edges = set()
    visited = {0}
    available_edges = []
    for i in range(n):
        if i != 0:
            available_edges.append((0, i, distance_matrix[0, i]))
    
    import heapq
    heapq.heapify(available_edges)
    
    while len(visited) < n:
        cost, u, v = heapq.heappop(available_edges)
        if v in visited:
            continue
        
        mst_edges.add(frozenset({u,v}))
        visited.add(v)
        
        for w in range(n):
            if w not in visited:
                heapq.heappush(available_edges, (distance_matrix[v, w], v, w))
                
    # Weight edges based on shortest paths within MST
    for i in range(n):
        for j in range(i + 1, n):
            if frozenset({i, j}) in mst_edges:
                heuristics_matrix[i, j] = 1.0
                heuristics_matrix[j, i] = 1.0
            else:
                 # Calculate shortest path between i and j within MST
                import networkx as nx
                G = nx.Graph()
                for edge in mst_edges:
                    u, v = tuple(edge)
                    G.add_edge(u,v, weight=distance_matrix[u,v])
                try:
                  path = nx.shortest_path(G, source=i, target=j, weight='weight')
                  path_len = nx.shortest_path_length(G, source=i, target=j, weight='weight')

                  for k in range(len(path) - 1):
                    u,v = path[k], path[k+1]
                    heuristics_matrix[u, v] += 0.1 / (path_len + 1e-9)
                    heuristics_matrix[v, u] += 0.1/ (path_len + 1e-9)
                except nx.NetworkXNoPath:
                    pass


    # Normalize heuristics matrix
    heuristics_matrix = heuristics_matrix / np.max(heuristics_matrix) if np.max(heuristics_matrix) > 0 else heuristics_matrix

    return heuristics_matrix
