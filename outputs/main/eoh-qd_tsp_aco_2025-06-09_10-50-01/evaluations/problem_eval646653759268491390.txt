import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm samples TSP solutions using a greedy insertion heuristic, scoring edges based on their frequency in sampled solutions.}"""
    n = distance_matrix.shape[0]
    num_samples = 100

    edge_counts = np.zeros_like(distance_matrix, dtype=int)

    for _ in range(num_samples):
        # Initialize path with a random node
        start_node = np.random.randint(n)
        path = [start_node]
        unvisited_nodes = set(range(n))
        unvisited_nodes.remove(start_node)

        # Iteratively insert the best node into the path
        while unvisited_nodes:
            best_node_to_insert = -1
            best_insertion_index = -1
            min_insertion_cost = np.inf

            for node_to_insert in unvisited_nodes:
                for i in range(len(path)):
                    # Calculate insertion cost
                    insertion_cost = distance_matrix[path[i-1], node_to_insert] + distance_matrix[node_to_insert, path[i]] - distance_matrix[path[i-1], path[i]]
                    if insertion_cost < min_insertion_cost:
                        min_insertion_cost = insertion_cost
                        best_node_to_insert = node_to_insert
                        best_insertion_index = i
            
            path.insert(best_insertion_index, best_node_to_insert)
            unvisited_nodes.remove(best_node_to_insert)
        path.append(path[0]) # Return to start

        # Update edge counts based on the sampled path
        for i in range(n):
            node1 = path[i]
            node2 = path[i + 1]
            edge_counts[node1, node2] += 1
            edge_counts[node2, node1] += 1 #Symmetric

    heuristics_matrix = edge_counts / num_samples
    return heuristics_matrix
