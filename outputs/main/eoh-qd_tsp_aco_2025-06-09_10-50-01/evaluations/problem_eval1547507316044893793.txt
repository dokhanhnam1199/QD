import numpy as np

def heuristics_v2(distance_matrix):
    """
    {This algorithm generates multiple random tours, iteratively improves them using 2-opt swaps, and aggregates edge frequencies across these improved tours with a weighted score based on tour length to estimate edge desirability.}
    """
    num_nodes = distance_matrix.shape[0]
    num_iterations = 100
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

    for _ in range(num_iterations):
        # 1. Generate a random tour
        tour = np.random.permutation(num_nodes)
        
        # 2. Improve the tour using 2-opt swaps
        improved_tour = two_opt(tour, distance_matrix)
        
        # 3. Calculate tour length
        tour_length = calculate_tour_length(improved_tour, distance_matrix)
        
        # 4. Calculate weight based on tour length (shorter tours get higher weight)
        weight = 1.0 / (tour_length + 1e-6)  # Adding a small constant to avoid division by zero

        # 5. Update heuristics_matrix based on the improved tour and weight
        for i in range(num_nodes):
            node1 = improved_tour[i]
            node2 = improved_tour[(i + 1) % num_nodes]
            heuristics_matrix[node1, node2] += weight
            heuristics_matrix[node2, node1] += weight

    # Normalize the heuristics matrix
    heuristics_matrix = heuristics_matrix / num_iterations

    return heuristics_matrix

def two_opt(route, distance_matrix):
    """
    Implements 2-opt swaps to improve a given route.
    """
    best_route = route.copy()
    improved = True
    while improved:
        improved = False
        for i in range(1, len(route) - 2):
            for k in range(i + 1, len(route)):
                if k - i == 1:
                    continue  # Skip adjacent edges
                new_route = route[:i] + route[i:k][::-1] + route[k:]
                
                current_cost = (
                    distance_matrix[route[i - 1], route[i]] +
                    distance_matrix[route[k - 1], route[k]]
                )
                new_cost = (
                    distance_matrix[route[i - 1], route[k - 1]] +
                    distance_matrix[route[i], route[k]]
                )
                
                if new_cost < current_cost:
                    best_route = new_route.copy()
                    route = new_route.copy()
                    improved = True
    return best_route

def calculate_tour_length(tour, distance_matrix):
    """
    Calculates the total length of a tour.
    """
    total_length = 0
    num_nodes = len(tour)
    for i in range(num_nodes):
        node1 = tour[i]
        node2 = tour[(i + 1) % num_nodes]
        total_length += distance_matrix[node1, node2]
    return heuristics_matrix
