{
     "algorithm": "This algorithm samples multiple near-optimal TSP solutions using a nearest neighbor heuristic with random restarts and edge perturbation, then aggregates edge frequencies across these samples to create a heuristic matrix indicating edge importance.",
     "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm samples multiple near-optimal TSP solutions using a nearest neighbor heuristic with random restarts and edge perturbation, then aggregates edge frequencies across these samples to create a heuristic matrix indicating edge importance.}\"\"\"\n    n = distance_matrix.shape[0]\n    num_samples = 100\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    for _ in range(num_samples):\n        start_node = np.random.randint(n)\n        current_node = start_node\n        unvisited = set(range(n))\n        unvisited.remove(start_node)\n        tour = [start_node]\n        \n        while unvisited:\n            nearest_neighbor = -1\n            min_distance = np.inf\n            for neighbor in unvisited:\n                distance = distance_matrix[current_node, neighbor]\n                if distance < min_distance:\n                    min_distance = distance\n                    nearest_neighbor = neighbor\n\n            tour.append(nearest_neighbor)\n            unvisited.remove(nearest_neighbor)\n            current_node = nearest_neighbor\n            \n        tour.append(start_node)  # Return to starting node\n        \n        #Perturb the tour with random swaps of close nodes\n        for _ in range(n):\n            i = np.random.randint(1, n+1)\n            j = np.random.randint(1, n+1)\n\n            if i != j:\n                if distance_matrix[tour[i-1], tour[j-1]] + distance_matrix[tour[i], tour[j]] < distance_matrix[tour[i-1], tour[i]] + distance_matrix[tour[j-1], tour[j]]:\n                        tour[i], tour[j] = tour[j], tour[i]\n                        \n        # Update heuristic matrix based on edge frequencies\n        for i in range(n):\n            node1 = tour[i]\n            node2 = tour[i+1]\n            heuristics_matrix[node1, node2] += 1\n            heuristics_matrix[node2, node1] += 1  # Assuming symmetric distance matrix\n\n    heuristics_matrix /= num_samples  # Normalize to get frequencies\n    return heuristics_matrix",
     "objective": 6.08597,
     "other_inf": null,
     "SLOC": 32.0,
     "cyclomatic_complexity": 9.0,
     "halstead": 223.47971260168305
}