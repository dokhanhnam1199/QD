```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    # 1. Feasibility: Only consider bins that can fit the item.
    feasible_bins = bins_remain_cap >= item
    
    # 2. Remaining Capacity as a Metric:
    #   - Give higher priority to bins with smaller remaining capacity *after* packing.
    #     This aims to fill bins as much as possible before opening new ones.
    remaining_after_packing = bins_remain_cap - item
    priorities[feasible_bins] = 1 / (remaining_after_packing[feasible_bins] + 1e-9)  # Adding a small constant for numerical stability. Invert and add 1 to always yield positive values.
    
    # 3. Bonus for Near-Perfect Fit:
    #   - A bin that results in near-perfect fit will be given extra weight, but less so as the bin gets filled with more item (to avoid filling very small bin before very large bin that both give near perfect fit).
    near_perfect_fit = (remaining_after_packing >= 0) & (remaining_after_packing <= 0.1 * np.mean(bins_remain_cap)) # Threshold adjusted
    priorities[near_perfect_fit] *= 2  # Increase priority for near-perfect fits

    return priorities
```
