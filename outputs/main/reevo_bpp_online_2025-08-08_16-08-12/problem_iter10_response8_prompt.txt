{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Returns priority with which we want to add item to each bin using a\n    First Fit strategy with an emphasis on exact fits and minimal slack,\n    and incorporates a softmax-like scaling for exploration.\n\n    This heuristic prioritizes bins that can fit the item. Among those that fit,\n    it assigns a higher priority to bins that result in an exact fit (zero remaining capacity)\n    and then to bins with minimal positive remaining capacity. A scaling factor (temperature)\n    is applied to the inverse of the slack to control exploration. Bins that cannot fit\n    the item are given a priority of zero.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    temperature = 1.0  # Tunable parameter for exploration\n\n    # Identify bins that can accommodate the item\n    can_fit_mask = bins_remain_cap >= item\n\n    # Calculate the slack (remaining capacity after placement) for fitting bins\n    slack = bins_remain_cap[can_fit_mask] - item\n\n    # Assign priorities:\n    # - Highest priority for exact fits (slack == 0)\n    # - High priority for minimal positive slack, inversely proportional to slack\n    #   scaled by temperature for exploration.\n    # - Zero priority for bins that cannot fit the item.\n\n    # Handle exact fits separately to give them maximum priority\n    exact_fit_mask = slack == 0\n    priorities[can_fit_mask][exact_fit_mask] = 1e6  # A very high value for exact fits\n\n    # Calculate priorities for bins with positive slack\n    positive_slack_mask = slack > 0\n    positive_slack_values = slack[positive_slack_mask]\n\n    # Inverse slack scaled by temperature. Higher priority for smaller slack.\n    # Add epsilon to avoid division by zero if slack is very close to zero but not exactly zero.\n    scaled_priorities = 1.0 / (positive_slack_values + 1e-9)\n    priorities[can_fit_mask][positive_slack_mask] = np.exp(scaled_priorities / temperature)\n\n\n    # Normalize priorities to be between 0 and 1 (optional, but good practice for some selection methods)\n    # If no bins can fit the item, max_priority will be 0, so division by zero is avoided.\n    max_priority = np.max(priorities)\n    if max_priority > 0:\n        priorities /= max_priority\n\n    return priorities\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin, prioritizing\n    minimal slack after placement. This version refines the penalty for exact\n    fills and introduces a more nuanced exploratory boost by favoring bins with\n    small positive remaining capacity.\n\n    This heuristic prioritizes bins that can fit the item. Among those that fit,\n    it assigns a higher priority to bins that will have less remaining capacity\n    after the item is placed (minimal slack). This encourages denser packing.\n    A more aggressive penalty is applied to bins that would become completely full,\n    more strongly discouraging exact fits. To introduce a more structured\n    exploratory element, bins that result in a small, positive remainder (e.g.,\n    up to 10% of the item's size) are given a moderate boost to their priority.\n    This encourages leaving a useful, but not excessive, amount of space.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Identify bins that can accommodate the item\n    can_fit_mask = bins_remain_cap >= item\n\n    # If no bin can fit the item, return all zeros\n    if not np.any(can_fit_mask):\n        return priorities\n\n    # Calculate the remaining capacity if the item is placed in a fitting bin\n    remaining_after_placement = bins_remain_cap[can_fit_mask] - item\n\n    # Base priority: prioritize bins with minimal slack.\n    # Higher score for smaller remainders. Add epsilon for numerical stability.\n    # Using negative of remaining capacity to ensure higher priority for smaller values.\n    base_priorities = -remaining_after_placement\n\n    # Penalty for bins that would become exactly full.\n    # Subtract a larger value to strongly discourage exact fits.\n    penalty_for_full = 1.0\n    fully_filled_mask = (remaining_after_placement == 0)\n    priorities[can_fit_mask] = base_priorities\n    priorities[can_fit_mask][fully_filled_mask] -= penalty_for_full\n\n    # Exploratory boost: favor bins that have a small positive remainder.\n    # A small positive remainder is considered to be up to 10% of the item's size.\n    # This is a heuristic value and can be tuned.\n    exploratory_boost_threshold = 0.1 * item\n    small_positive_remainder_mask = (remaining_after_placement > 0) & (remaining_after_placement <= exploratory_boost_threshold)\n    exploratory_boost_value = 0.5  # Moderate boost value\n    priorities[can_fit_mask][small_positive_remainder_mask] += exploratory_boost_value\n\n    # Normalize priorities to be non-negative.\n    # Find the minimum priority among valid choices and shift all priorities up.\n    # This ensures that the relative ordering is maintained while making values non-negative.\n    valid_priorities = priorities[can_fit_mask]\n    if valid_priorities.size > 0:\n        min_valid_priority = np.min(valid_priorities)\n        # If min_valid_priority is negative, shift all valid priorities to be >= 0\n        if min_valid_priority < 0:\n            priorities[can_fit_mask] -= min_valid_priority\n\n    # Ensure all non-fitting bins have the lowest possible priority (effectively zero after shift)\n    priorities[~can_fit_mask] = 0.0\n\n    return priorities\n\n[Reflection]\nPrioritize minimal slack, penalize exact fits, and explore small positive remainders.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}