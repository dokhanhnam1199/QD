```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin, prioritizing Exact Fit, then Best Fit.

    This heuristic prioritizes bins that offer an exact fit for the item.
    If no exact fit is available, it then prioritizes bins that can accommodate the item
    with the smallest remaining capacity (Best Fit approach among the remaining options).
    This aims to minimize wasted space and leave larger capacities available for subsequent items.
    It avoids penalizing good fits, ensuring that tighter fits receive higher priority.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Returns:
        Array of same size as bins_remain_cap with priority score of each bin.
        Exact fits get the highest priority (e.g., 100). Bins that fit but not exactly
        get a priority based on the "tightness" of the fit, inversely proportional to
        the slack (remaining capacity - item size). Bins that cannot fit get 0 priority.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins where the item can fit
    can_fit_mask = bins_remain_cap >= item
    fitting_bins_capacities = bins_remain_cap[can_fit_mask]
    fitting_indices = np.where(can_fit_mask)[0]

    if fitting_bins_capacities.size == 0:
        return priorities  # No bin can fit the item

    # Calculate slack for bins that can fit the item
    slacks = fitting_bins_capacities - item

    # Exact fit has the highest priority
    exact_fit_mask = slacks == 0
    exact_fit_indices = fitting_indices[exact_fit_mask]
    priorities[exact_fit_indices] = 100.0

    # For bins that are not an exact fit, assign priority based on the slack (Best Fit)
    # Smaller slack (tighter fit) gets a higher priority.
    non_exact_fit_mask = slacks > 0
    non_exact_fit_indices = fitting_indices[non_exact_fit_mask]
    non_exact_slacks = slacks[non_exact_fit_mask]

    if non_exact_fit_indices.size > 0:
        # Sort these bins by slack in ascending order.
        # The bin with the smallest slack (closest to fitting perfectly) gets the highest priority
        # among the non-exact fits.
        sorted_slack_indices = np.argsort(non_exact_slacks)

        # Assign priorities decreasingly.
        # Max priority for non-exact fits will be 99 (if exact fits exist),
        # down to a lower value.
        # The number of non-exact fits determines the range of these priorities.
        max_non_exact_priority = 99.0
        # Assign priorities from highest (99) to lowest based on sorted slack
        priorities[non_exact_fit_indices[sorted_slack_indices]] = max_non_exact_priority - np.arange(non_exact_slacks.size)

    return priorities
```
