```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using an improved Almost Full Fit strategy.

    This strategy prioritizes bins that can fit the item, aiming to minimize the
    remaining capacity (gap) after packing. Exact fits are given the highest priority.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Initialize priorities to a very low value to signify that bins that cannot
    # fit the item have the lowest priority.
    priorities = np.full_like(bins_remain_cap, -np.inf)

    # Find bins where the item fits exactly. These should have the highest priority.
    exact_fit_mask = (bins_remain_cap - item) == 0
    priorities[exact_fit_mask] = 100.0  # High priority for exact fits

    # Find bins where the item fits but not exactly.
    # For these bins, we want to prioritize those with the smallest remaining capacity
    # after placing the item (i.e., minimize bins_remain_cap - item).
    # This means we want to prioritize bins with the smallest bins_remain_cap.
    # We assign priorities as negative remaining capacity.
    valid_fit_mask = bins_remain_cap >= item
    eligible_bins_mask = valid_fit_mask & ~exact_fit_mask

    if np.any(eligible_bins_mask):
        # Calculate the negative remaining capacity for eligible bins.
        # Smaller remaining capacity (closer to 'item') will result in a less negative
        # number, hence a higher priority among these eligible bins.
        priorities[eligible_bins_mask] = -bins_remain_cap[eligible_bins_mask]

    return priorities
```
