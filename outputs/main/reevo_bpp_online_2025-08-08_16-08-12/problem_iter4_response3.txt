```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using an improved strategy that prioritizes exact fits then near fits.

    This strategy prioritizes bins that can fit the item, aiming to minimize the
    remaining capacity (gap) after packing. Exact fits are given the highest priority.
    Among bins that don't offer an exact fit but can accommodate the item,
    it prioritizes those that leave the least remaining capacity.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Initialize priorities to a very low value. Bins that cannot fit the item
    # will retain this low priority.
    priorities = np.full_like(bins_remain_cap, -np.inf)

    # Identify bins that can accommodate the item.
    can_fit_mask = bins_remain_cap >= item

    if not np.any(can_fit_mask):
        return priorities  # No bin can fit the item

    # Calculate the remaining capacity after placing the item in fitting bins.
    remaining_after_placement = bins_remain_cap[can_fit_mask] - item

    # Assign high priority to exact fits.
    exact_fit_mask_subset = (remaining_after_placement == 0)
    priorities[can_fit_mask][exact_fit_mask_subset] = 100.0

    # For bins that fit but are not exact fits, prioritize those with the least remaining capacity.
    # This means we want to prioritize bins with smaller remaining_after_placement.
    # We use the negative of remaining_after_placement as the score.
    # Smaller remaining_after_placement values will result in less negative scores, hence higher priority.
    near_fit_mask_subset = ~exact_fit_mask_subset
    if np.any(near_fit_mask_subset):
        priorities[can_fit_mask][near_fit_mask_subset] = -remaining_after_placement[near_fit_mask_subset]

    return priorities
```
