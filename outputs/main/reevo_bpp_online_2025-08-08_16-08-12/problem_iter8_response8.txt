```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Returns priority with which we want to add item to each bin, prioritizing
    minimal slack after placement. This version refines the penalty for exact
    fills and introduces a more nuanced exploratory boost by favoring bins with
    small positive remaining capacity.

    This heuristic prioritizes bins that can fit the item. Among those that fit,
    it assigns a higher priority to bins that will have less remaining capacity
    after the item is placed (minimal slack). This encourages denser packing.
    A more aggressive penalty is applied to bins that would become completely full,
    more strongly discouraging exact fits. To introduce a more structured
    exploratory element, bins that result in a small, positive remainder (e.g.,
    up to 10% of the item's size) are given a moderate boost to their priority.
    This encourages leaving a useful, but not excessive, amount of space.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Returns:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins that can accommodate the item
    can_fit_mask = bins_remain_cap >= item

    # If no bin can fit the item, return all zeros
    if not np.any(can_fit_mask):
        return priorities

    # Calculate the remaining capacity if the item is placed in a fitting bin
    remaining_after_placement = bins_remain_cap[can_fit_mask] - item

    # Base priority: prioritize bins with minimal slack.
    # Higher score for smaller remainders. Add epsilon for numerical stability.
    # Using negative of remaining capacity to ensure higher priority for smaller values.
    base_priorities = -remaining_after_placement

    # Penalty for bins that would become exactly full.
    # Subtract a larger value to strongly discourage exact fits.
    penalty_for_full = 1.0
    fully_filled_mask = (remaining_after_placement == 0)
    priorities[can_fit_mask] = base_priorities
    priorities[can_fit_mask][fully_filled_mask] -= penalty_for_full

    # Exploratory boost: favor bins that have a small positive remainder.
    # A small positive remainder is considered to be up to 10% of the item's size.
    # This is a heuristic value and can be tuned.
    exploratory_boost_threshold = 0.1 * item
    small_positive_remainder_mask = (remaining_after_placement > 0) & (remaining_after_placement <= exploratory_boost_threshold)
    exploratory_boost_value = 0.5  # Moderate boost value
    priorities[can_fit_mask][small_positive_remainder_mask] += exploratory_boost_value

    # Normalize priorities to be non-negative.
    # Find the minimum priority among valid choices and shift all priorities up.
    # This ensures that the relative ordering is maintained while making values non-negative.
    valid_priorities = priorities[can_fit_mask]
    if valid_priorities.size > 0:
        min_valid_priority = np.min(valid_priorities)
        # If min_valid_priority is negative, shift all valid priorities to be >= 0
        if min_valid_priority < 0:
            priorities[can_fit_mask] -= min_valid_priority

    # Ensure all non-fitting bins have the lowest possible priority (effectively zero after shift)
    priorities[~can_fit_mask] = 0.0

    return priorities
```
