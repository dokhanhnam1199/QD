```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Prioritizes bins using a refined "Best Fit" heuristic, with a mild exploration component.

    This heuristic aims to find the bin that, after placing the item, will have the
    least remaining capacity (i.e., the tightest fit) among all bins that can
    accommodate the item. It prioritizes bins that are closer to being full.
    An exact fit (remaining capacity == item size) is implicitly handled as
    it results in zero remaining capacity, which is the minimum possible.

    The priority is calculated as:
    - For bins that can fit the item: A score that rewards tighter fits.
      Specifically, `-(bins_remain_cap - item)` is used, which means bins with
      less remaining capacity after placing the item get higher scores.
      A small penalty is added for bins that leave a *very* small positive remainder
      to slightly encourage exploration if the best fit is only marginally better
      than another option.
    - For bins that cannot fit the item: A priority of negative infinity to ensure
      they are never selected.

    Args:
        item: The size of the item to be packed.
        bins_remain_cap: A numpy array containing the remaining capacity of each bin.

    Returns:
        A numpy array of the same size as bins_remain_cap, where each element
        represents the priority score for placing the item in the corresponding bin.
    """
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)
    epsilon = 1e-6  # Small constant to slightly penalize near-zero remainders

    # Identify bins that have enough capacity to fit the item
    can_fit_mask = bins_remain_cap >= item

    # For bins that can fit the item, calculate the remaining capacity after packing
    remaining_capacities_after_fit = bins_remain_cap[can_fit_mask] - item

    # Assign priorities. Higher priority for smaller remaining capacity (tighter fit).
    # We use the negative of the remaining capacity.
    # A small epsilon is added to the remaining capacity before negation to slightly
    # discourage extremely tight fits when there are other good options, promoting
    # a mild form of exploration by making slightly looser fits appear more attractive
    # if the difference is negligible.
    # The primary goal is still best fit, but this adds a slight nudge.
    priorities[can_fit_mask] = -(remaining_capacities_after_fit + epsilon)

    return priorities
```
