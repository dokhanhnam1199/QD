```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Prioritizes bins for the online Bin Packing Problem using a hybrid approach
    that balances "Best Fit" (exploitation) with a small chance of "First Fit"
    or random choice among fitting bins (exploration).

    The "Best Fit" component prioritizes bins that leave the least remaining
    capacity after the item is placed. This is achieved by assigning a priority
    that is the negative of the remaining capacity after fitting the item.
    A tighter fit (smaller remaining capacity) results in a higher (less negative)
    priority.

    The exploration component is introduced to prevent getting stuck in local
    optima. With a small probability (epsilon), it favors bins that are not
    necessarily the best fit, by assigning a random priority among those that
    can fit the item. This allows for exploring different packing configurations.

    Args:
        item: The size of the item to be packed.
        bins_remain_cap: A numpy array containing the remaining capacity of each bin.

    Returns:
        A numpy array of the same size as bins_remain_cap, where each element
        represents the priority score for placing the item in the corresponding bin.
    """
    epsilon = 0.05  # Probability of exploration
    num_bins = len(bins_remain_cap)

    # Initialize priorities to negative infinity for all bins
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Identify bins that have enough capacity to fit the item
    can_fit_mask = bins_remain_cap >= item

    # Calculate the remaining capacity for bins that can fit the item
    remaining_capacities_after_fit = bins_remain_cap[can_fit_mask] - item

    # --- Exploitation Component (Best Fit) ---
    # Assign priorities based on the tightness of the fit.
    # The negative of the remaining capacity is used: smaller remaining capacity
    # leads to a less negative (higher) priority.
    exploitation_scores = np.full_like(bins_remain_cap, -np.inf)
    exploitation_scores[can_fit_mask] = -remaining_capacities_after_fit

    # --- Exploration Component ---
    # Generate random scores for exploration among fitting bins.
    # We want to give a chance to bins that might not be the "best" according to Best Fit.
    # A simple approach is to assign a random value if exploration is chosen.
    exploration_scores_random = np.random.rand(num_bins)

    # Combine exploitation and exploration using an epsilon-greedy strategy.
    # Generate a random choice for each bin: True for exploration, False for exploitation.
    explore_choice_mask = np.random.rand(num_bins) < epsilon

    # For bins where exploration is chosen AND they can fit the item, use the random score.
    # For bins where exploitation is chosen AND they can fit the item, use the exploitation score.
    # For bins that cannot fit, their priority remains -np.inf.
    
    # Create a mask for bins that are candidates for selection (can fit the item)
    candidate_mask = can_fit_mask
    
    # Apply exploration choice: if exploration is chosen for a candidate bin, use its random score.
    priorities[explore_choice_mask & candidate_mask] = exploration_scores_random[explore_choice_mask & candidate_mask]
    
    # Apply exploitation choice: if exploitation is chosen for a candidate bin, use its exploitation score.
    # We only update if the bin was NOT chosen for exploration (or if exploration wasn't chosen for it).
    # The condition `~explore_choice_mask` ensures we only apply exploitation if exploration wasn't picked.
    priorities[~explore_choice_mask & candidate_mask] = exploitation_scores[~explore_choice_mask & candidate_mask]

    # Ensure that bins that cannot fit remain at -np.inf
    priorities[~can_fit_mask] = -np.inf

    return priorities
```
