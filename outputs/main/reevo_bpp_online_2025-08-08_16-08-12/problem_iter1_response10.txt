```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using First Fit.

    The priority is determined by the remaining capacity of the bin after placing the item.
    A bin is only considered if it has enough capacity for the item.
    Among eligible bins, the one with the smallest remaining capacity AFTER placing the item
    is prioritized (to minimize wasted space). If no bin can fit the item, a score of -1
    is returned for all bins.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.full_like(bins_remain_cap, -1.0)  # Initialize with -1 (ineligible)

    # Find bins that can accommodate the item
    eligible_bins_mask = bins_remain_cap >= item

    if np.any(eligible_bins_mask):
        # Calculate remaining capacity after placing the item in eligible bins
        remaining_capacities_after_fit = bins_remain_cap[eligible_bins_mask] - item

        # Higher priority for bins with less remaining capacity after fitting (First Fit preference)
        # We want to select the bin that leaves the LEAST remaining space.
        # So, we assign a score based on the inverse of the remaining capacity,
        # but we want to minimize it. A simple way is to use the remaining capacity itself
        # and take the minimum among those.
        # To achieve "First Fit" behavior, we prioritize the *first* bin that meets the criteria.
        # In this priority function, we are assigning scores. The selection logic *outside*
        # this function will pick the highest score. So, we want to assign a higher score
        # to the "best fit" bin according to First Fit.

        # The goal of First Fit is to place the item in the first bin that can accommodate it.
        # If we want to translate this to a priority score where higher means better,
        # we should give the highest score to the *first* eligible bin.

        # Let's redefine the priority for the selection algorithm:
        # Higher score means more preferred.
        # For First Fit, the most preferred bin is the *first* one that fits.
        # So, let's assign a high score to the first eligible bin and lower scores to subsequent ones.

        # A simple way to implement this within a priority function is to give a
        # "value" to each eligible bin. The selection process (outside this function)
        # will pick the bin with the highest value.
        # If we want First Fit, we assign a decreasing priority to bins as we find them.

        # Let's assign priorities based on the bin index for First Fit:
        # The first bin that fits gets the highest priority, the second gets the next highest, etc.
        # To make this concrete: if the item fits in bins at indices 0 and 2,
        # bin 0 gets a higher priority than bin 2.

        # Assign a score that prioritizes earlier bins if they are eligible.
        # We can use a large number and subtract the index.
        # The "best" fit in terms of minimizing remaining space is implicitly handled by
        # the fact that we only consider bins that *can* fit the item.

        # Let's try a simple approach: assign a base score to eligible bins.
        # The highest score will go to the first eligible bin.

        # Option 1: Score based on "best fit" if we consider that within First Fit's spirit.
        # This means, among eligible bins, pick the one that leaves the least remaining space.
        # A higher priority for a smaller remaining_capacity_after_fit.
        # We can negate the remaining capacity to make smaller capacities have higher priority.
        # Example: if remaining_capacities_after_fit are [2.0, 0.5], we want 0.5 to be preferred.
        # Negating gives [-2.0, -0.5]. The maximum of these is -0.5. This corresponds to the best fit.
        # This isn't strictly First Fit but a common heuristic variation.

        # Option 2: Strict First Fit priority.
        # The highest priority should be given to the *first* bin encountered that can fit the item.
        # Let's assign a priority score such that the earliest available bin gets the highest score.
        # For example, if bins_remain_cap = [5, 3, 6] and item = 2:
        # Eligible bins are at indices 0 (rem=3), 1 (rem=1), 2 (rem=4).
        # First Fit would pick bin 0.
        # To make bin 0 have the highest score, we can assign a large number minus its index.
        # Let's say we assign `N - index` for eligible bins, where N is the total number of bins.
        # Bin 0 (eligible): N - 0 = N
        # Bin 1 (eligible): N - 1
        # Bin 2 (eligible): N - 2
        # The maximum score would be N, corresponding to bin 0.

        # Let's use the index-based priority for strict First Fit
        base_priority = len(bins_remain_cap) # A large enough number
        priorities[eligible_bins_mask] = base_priority - np.arange(len(bins_remain_cap))[eligible_bins_mask]

    return priorities
```
