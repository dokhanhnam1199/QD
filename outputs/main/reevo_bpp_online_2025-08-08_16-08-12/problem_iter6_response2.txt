```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Returns priority for each bin to pack an item.
    Prioritizes exact fits, then near fits.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Returns:
        Array of priority scores for each bin. Bins that cannot fit the item
        will have a very low priority.
    """
    # Initialize priorities to a very low value.
    priorities = np.full_like(bins_remain_cap, -float('inf'))

    # Identify bins where the item can fit.
    can_fit_mask = bins_remain_cap >= item

    if not np.any(can_fit_mask):
        return priorities  # No bin can fit the item

    # Calculate potential remaining capacities for bins that can fit the item.
    potential_remainders = bins_remain_cap[can_fit_mask] - item

    # Assign priority:
    # 1. Exact fits (remainder is 0) get the highest priority.
    # 2. Near fits (smaller positive remainder) get higher priority than larger remainders.
    # We can achieve this by assigning a high value for exact fits and then
    # using the negative of the remainder for near fits, so smaller remainders
    # (less negative values) get higher priority.

    # For exact fits
    exact_fit_indices = np.where(potential_remainders == 0)[0]
    if len(exact_fit_indices) > 0:
        priorities[can_fit_mask][exact_fit_indices] = 100.0  # High priority for exact fits

    # For near fits
    near_fit_indices = np.where(potential_remainders > 0)[0]
    if len(near_fit_indices) > 0:
        # Assign priorities based on the negative of the remainder.
        # This means smaller remainders get higher (less negative) scores.
        priorities[can_fit_mask][near_fit_indices] = -potential_remainders[near_fit_indices]

    return priorities
```
