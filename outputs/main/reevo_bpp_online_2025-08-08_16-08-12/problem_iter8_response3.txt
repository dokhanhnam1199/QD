```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using a Best-Fit approach with explicit prioritization of exact fits.

    This heuristic prioritizes bins that can fit the item. Among those that fit,
    it first gives the highest priority to exact fits. For bins that are not
    exact fits but can accommodate the item, it assigns priority based on
    how much remaining capacity is left, favoring smaller remaining capacities.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Identify bins that can accommodate the item.
    can_fit_mask = bins_remain_cap >= item

    if not np.any(can_fit_mask):
        return priorities  # No bin can fit the item

    fitting_bins_remain_cap = bins_remain_cap[can_fit_mask]
    remaining_after_placement = fitting_bins_remain_cap - item

    # Assign highest priority to exact fits.
    exact_fit_mask_subset = (remaining_after_placement == 0)
    # Use a very high priority for exact fits
    priorities[can_fit_mask][exact_fit_mask_subset] = 1000.0

    # For bins that fit but are not exact fits, assign priorities.
    # Prioritize smaller remaining capacities (closer to zero).
    near_fit_mask_subset = ~exact_fit_mask_subset
    if np.any(near_fit_mask_subset):
        near_fit_priorities_raw = remaining_after_placement[near_fit_mask_subset]
        
        # Invert remaining capacity to prioritize smaller values. Add a small epsilon for stability.
        # The larger the value (less remaining capacity), the higher the priority.
        priorities[can_fit_mask][near_fit_mask_subset] = 1.0 / (near_fit_priorities_raw + 1e-9)

    return priorities
```
