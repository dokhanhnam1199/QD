```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Almost Full Fit.

    The Almost Full Fit strategy prioritizes bins that have a remaining capacity
    slightly larger than the item. This aims to leave smaller gaps in bins that
    are nearly full, potentially improving overall packing efficiency.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # We want to prioritize bins where the remaining capacity is just slightly
    # larger than the item. A good way to express this is by minimizing the
    # difference (bins_remain_cap - item), but only for bins that can actually
    # fit the item. For bins that cannot fit the item, we assign a very low priority.

    # Initialize priorities to a very low value (negative infinity) to signify
    # that these bins are not candidates if the item doesn't fit.
    priorities = np.full_like(bins_remain_cap, -np.inf)

    # Find bins that can accommodate the item
    can_fit_mask = bins_remain_cap >= item

    # For bins that can fit the item, calculate a priority score.
    # We want the remaining capacity to be as close as possible to 'item' but still
    # greater than or equal to it. This is equivalent to minimizing (bins_remain_cap - item).
    # However, for "Almost Full Fit", we want bins that are *almost* full, meaning
    # the remaining capacity is large enough but not excessively large.
    # A simple approach is to take the negative of the remaining capacity for
    # bins that can fit the item. This way, bins with *less* remaining capacity
    # (closer to 'item') will have a higher priority (less negative).

    # To further refine for "Almost Full Fit", we can also consider how "full" the bin is.
    # A bin that is *almost* full and can fit the item is desirable.
    # We can achieve this by prioritizing bins with larger remaining capacities *among those that can fit the item*.
    # Let's invert this. We want to select bins that are *almost* full.
    # So, if a bin can fit the item, its priority is inversely related to its remaining capacity.
    # A smaller remaining capacity (closer to 'item') is better for 'Almost Full Fit'.

    # Let's use a scoring where a *smaller* positive difference (remaining capacity - item)
    # is preferred. We'll use the negative of this difference as priority,
    # so a larger negative difference (meaning smaller positive difference) is better.
    # We add a small epsilon to avoid division by zero if we were to use reciprocals,
    # or to ensure distinct values.

    # For bins that can fit, calculate the difference. We want to penalize larger differences.
    # A bin with remaining capacity `C` and item `I`: difference is `C - I`.
    # We want small `C - I`. So, priority should be related to `-(C - I)`.
    # This means higher priority for smaller `C - I`.

    # Let's consider bins that can fit the item:
    eligible_bins_capacity = bins_remain_cap[can_fit_mask]

    # For these eligible bins, we want those with the smallest remaining capacity.
    # So, we can sort them or assign priorities based on their remaining capacity.
    # The smaller the `bins_remain_cap[i]`, the higher the priority for eligible bins.
    # Assign priority as negative remaining capacity.
    priorities[can_fit_mask] = -eligible_bins_capacity

    # This implementation gives higher priority to bins that are "almost full"
    # meaning they have the least remaining capacity among those that can fit the item.
    # This is a common interpretation of "Almost Full Fit" where you try to fill
    # bins as much as possible without overfilling, thus leaving less fragmented space.

    return priorities
```
