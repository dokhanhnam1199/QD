```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Tight Fit strategy.

    The "Tight Fit" strategy prioritizes bins that have a remaining capacity
    that is just enough to fit the current item. This aims to leave larger capacities
    in other bins for potentially larger future items. This is an refinement of
    "Almost Full Fit" by directly penalizing bins with much larger remaining capacity
    than needed.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
        Higher priority is given to bins with remaining capacity closer to the item size.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Calculate the difference between remaining capacity and item size for bins that can fit
    # We want to prioritize bins where this difference is small and non-negative.
    # A small difference means a "tight" fit.
    diff = bins_remain_cap - item

    # Mask for bins where the item can fit
    can_fit_mask = bins_remain_cap >= item

    # For bins that can fit the item, calculate priority.
    # We want to give higher priority to smaller positive differences.
    # A common way to achieve this is to use the inverse of the difference.
    # To avoid division by zero when diff is 0 (perfect fit), we add a small epsilon.
    # Bins with larger differences will have lower priority (1 / (large_diff + epsilon)).
    epsilon = 1e-9
    priorities[can_fit_mask] = 1.0 / (diff[can_fit_mask] + epsilon)

    # Bins that cannot fit the item will have a priority of 0, as initialized.
    return priorities
```
