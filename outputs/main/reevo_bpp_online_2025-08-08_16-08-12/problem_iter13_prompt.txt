{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Prior reflection]\nPrioritize exact fits. For near fits, scale inverse remaining capacity aggressively but stably. Differentiate fit categories, tune scores, and use bounded transformations to avoid unnecessary temperature scaling.\n\n[Code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Prioritizes bins for the online Bin Packing Problem, with enhanced strategies.\n\n    This heuristic categorizes bins into:\n    1. Exact Fits: Bins where the item perfectly fills the remaining capacity.\n    2. Near Fits: Bins where the item fits, and the remaining capacity after placement\n       is small (defined by a threshold). These are further prioritized using a\n       temperature-controlled softmax on the inverse of the remaining capacity\n       to balance exploitation (best near fit) and exploration (trying other near fits).\n    3. General Fits: Bins where the item fits, but the remaining capacity after\n       placement is not considered \"near\". These receive a low positive priority.\n    4. Unfittable: Bins where the item cannot fit. These receive negative infinity priority.\n\n    Args:\n        item: The size of the item to be packed.\n        bins_remain_cap: A numpy array containing the remaining capacity of each bin.\n\n    Returns:\n        A numpy array of the same size as bins_remain_cap, where each element\n        represents the priority score for placing the item in the corresponding bin.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # --- Configuration Parameters ---\n    # Priority for exact fits, set high to ensure they are always chosen if available.\n    EXACT_FIT_PRIORITY = 100.0\n    # Base score for near fits before applying softmax, ensuring they are preferred over general fits.\n    NEAR_FIT_BASE_SCORE = 50.0\n    # Scaling factor for softmax probabilities to map them into a desirable range.\n    NEAR_FIT_SCALE = 40.0\n    # Priority for bins that fit but are not considered \"near\". This ensures they are usable.\n    GENERAL_FIT_PRIORITY = 1.0\n    # Threshold to define what constitutes a \"near fit\". A smaller value is stricter.\n    # For example, if remaining capacity is less than 10% of the item size or a small absolute value.\n    # Let's use a relative threshold combined with an absolute minimum for robustness.\n    NEAR_FIT_THRESHOLD_RELATIVE = 0.15 # e.g., remaining capacity < 15% of item size\n    NEAR_FIT_THRESHOLD_ABSOLUTE = 5.0  # e.g., remaining capacity < 5.0 units\n\n    # Temperature for softmax to control exploration among near fits.\n    # Higher temperature -> more exploration (priorities more uniform).\n    # Lower temperature -> less exploration (priorities more skewed to best fits).\n    TEMPERATURE = 0.7  # Tunable parameter\n\n    epsilon_small = 1e-9 # Small value to prevent division by zero.\n\n    # --- Identify Bin Categories ---\n    can_fit_mask = bins_remain_cap >= item\n\n    if not np.any(can_fit_mask):\n        return priorities  # No bin can fit the item\n\n    # 1. Exact Fits\n    exact_fit_mask = can_fit_mask & (np.abs(bins_remain_cap - item) < epsilon_small)\n    priorities[exact_fit_mask] = EXACT_FIT_PRIORITY\n\n    # 2. Near Fits\n    # Bins that can fit, but are not exact fits.\n    general_fitting_mask = can_fit_mask & ~exact_fit_mask\n\n    if np.any(general_fitting_mask):\n        fitting_bin_indices = np.where(general_fitting_mask)[0]\n        remaining_capacities_after_placement = bins_remain_cap[fitting_bin_indices] - item\n\n        # Define near fit criteria: remaining capacity is small.\n        near_fit_criteria = (remaining_capacities_after_placement < NEAR_FIT_THRESHOLD_ABSOLUTE) | \\\n                            (remaining_capacities_after_placement < item * NEAR_FIT_THRESHOLD_RELATIVE)\n        \n        near_fit_indices_subset = fitting_bin_indices[near_fit_criteria]\n        non_near_fit_indices_subset = fitting_bin_indices[~near_fit_criteria]\n\n        # Process Near Fits\n        if len(near_fit_indices_subset) > 0:\n            near_fit_remaining_caps = remaining_capacities_after_placement[near_fit_criteria]\n\n            # Score for softmax: higher score for smaller remaining capacity.\n            # Using inverse capacity ensures smaller remaining space gets higher score.\n            near_fit_scores = 1.0 / (near_fit_remaining_caps + epsilon_small)\n\n            # Apply softmax for exploration among near fits.\n            if len(near_fit_scores) > 0:\n                # Shift scores for numerical stability before exponentiation.\n                max_score = np.max(near_fit_scores)\n                shifted_scores = near_fit_scores - max_score\n                \n                exp_scores = np.exp(shifted_scores / TEMPERATURE)\n                sum_exp_scores = np.sum(exp_scores)\n\n                if sum_exp_scores > 0:\n                    softmax_probabilities = exp_scores / sum_exp_scores\n                else:\n                    # Fallback to uniform distribution if all exp_scores are ~0 or NaN.\n                    softmax_probabilities = np.ones_like(near_fit_scores) / len(near_fit_scores)\n                \n                # Scale probabilities to a priority range below exact fits.\n                scaled_near_fit_priorities = NEAR_FIT_BASE_SCORE + softmax_probabilities * NEAR_FIT_SCALE\n                priorities[near_fit_indices_subset] = scaled_near_fit_priorities\n\n        # 3. General Fits\n        # Bins that fit but are not exact or near fits.\n        if len(non_near_fit_indices_subset) > 0:\n            priorities[non_near_fit_indices_subset] = GENERAL_FIT_PRIORITY\n            \n    return priorities\n\n[Improved code]\nPlease write a mutated function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}