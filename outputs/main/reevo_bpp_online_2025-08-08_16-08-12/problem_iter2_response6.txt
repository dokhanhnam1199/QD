```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using a balanced Epsilon-Greedy strategy.

    This version aims to balance the exploitation of the "best fit" strategy with
    exploration by giving a decaying exploration bonus to all valid bins.
    This encourages trying different bins, especially when multiple bins offer
    a similar "best fit".

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    num_bins = len(bins_remain_cap)
    priorities = np.zeros(num_bins)
    epsilon_exploration_factor = 0.2  # Controls the magnitude of the exploration bonus

    # Identify bins where the item can fit
    can_fit_mask = bins_remain_cap >= item

    # Calculate the "best fit" score for bins that can accommodate the item.
    # The score is inversely proportional to the remaining space after packing,
    # favoring bins that leave less residual capacity. Add epsilon for numerical stability.
    best_fit_scores = np.zeros(num_bins)
    epsilon = 1e-9
    potential_remaining_cap = bins_remain_cap - item
    best_fit_scores[can_fit_mask] = 1.0 / (potential_remaining_cap[can_fit_mask] + epsilon)

    # Exploration bonus: Add a small, decaying bonus to all bins that can fit.
    # This bonus is designed to be smaller than the best-fit score for clearly
    # "good" fits, but significant enough to encourage exploration of less obvious
    # fits. A simple approach is to use a fraction of the best-fit score of the
    # *best* bin, or a fixed small value. Here, we'll use a fraction of the
    # maximum possible "best fit" score (which occurs when remaining capacity is epsilon).
    # The epsilon_exploration_factor scales this bonus.
    exploration_bonus = np.zeros(num_bins)
    if np.any(can_fit_mask):
        # A baseline exploration bonus, perhaps related to the average or max fit
        # For simplicity, let's make it a fraction of a very good fit.
        # Consider the case where the item perfectly fills a bin, leading to a high score.
        # A simpler approach: a small constant exploration bonus.
        # Let's try a decaying bonus based on how "full" the bin would become.
        # The fuller the bin becomes (smaller remaining capacity), the lower the exploration bonus.
        # So, the bonus is proportional to the item size / bin capacity.
        # We normalize the item size by a typical bin capacity (assuming unit capacity if not specified)
        # or more generally, by the remaining capacity of the *best* fitting bin.

        # A more direct approach: give a bonus proportional to the inverse of the item size.
        # This favors trying smaller items in different bins.
        # Let's try a simple additive exploration bonus that is uniform for all valid bins.
        # The magnitude is controlled by epsilon_exploration_factor.
        exploration_bonus[can_fit_mask] = epsilon_exploration_factor * (item / (bins_remain_cap[can_fit_mask] + epsilon))


    # Combine best fit scores with exploration bonus
    priorities[can_fit_mask] = best_fit_scores[can_fit_mask] + exploration_bonus[can_fit_mask]

    # Ensure bins that cannot fit have zero priority
    priorities[~can_fit_mask] = 0

    return priorities
```
