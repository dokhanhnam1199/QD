```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using a strategy that prioritizes exact fits, then near fits, and incorporates exploration.

    This strategy prioritizes exact fits (leaving zero remaining capacity).
    Among bins that can accommodate the item but are not exact fits, it prioritizes
    those that leave the least remaining capacity (best-fit approach).
    To encourage exploration, a softmax function is applied to the priorities of
    near-fitting bins.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.full_like(bins_remain_cap, -np.inf)

    # Identify bins that can accommodate the item.
    can_fit_mask = bins_remain_cap >= item

    if not np.any(can_fit_mask):
        return priorities  # No bin can fit the item

    fitting_bins_remain_cap = bins_remain_cap[can_fit_mask]
    remaining_after_placement = fitting_bins_remain_cap - item

    # Handle exact fits
    exact_fit_mask_subset = (remaining_after_placement == 0)
    exact_fit_indices = np.where(can_fit_mask)[0][exact_fit_mask_subset]
    priorities[exact_fit_indices] = 100.0  # High priority for exact fits

    # Handle near fits
    near_fit_mask_subset = ~exact_fit_mask_subset
    if np.any(near_fit_mask_subset):
        near_fit_indices_subset = np.where(can_fit_mask)[0][near_fit_mask_subset]
        near_fit_remaining = remaining_after_placement[near_fit_mask_subset]

        # Base priority for near fits: prioritize smaller remaining capacity.
        # Using negative remaining capacity to make smaller remaining capacity have higher score.
        # Add a small epsilon to avoid issues with identical remaining capacities and for stability.
        near_fit_base_priorities = -near_fit_remaining

        # Apply softmax to the base priorities of near fits for exploration.
        # Softmax converts scores into probabilities, giving a chance to bins with slightly more remaining space.
        temperature = 1.0  # Tunable parameter for exploration
        
        # Shift priorities to avoid large negative exponents in exp
        shifted_near_fit_priorities = near_fit_base_priorities - np.max(near_fit_base_priorities)
        
        # Calculate softmax probabilities
        exp_priorities = np.exp(shifted_near_fit_priorities / temperature)
        
        # Normalize probabilities to sum to 1 across the near-fitting bins
        sum_exp_priorities = np.sum(exp_priorities)
        if sum_exp_priorities > 0:
            softmax_probabilities = exp_priorities / sum_exp_priorities
        else:
            # If all exponents are effectively zero or negative infinity, assign uniform probability
            softmax_probabilities = np.ones_like(exp_priorities) / len(exp_priorities)

        # Assign these probabilities (scaled to still be lower than exact fits) to the priority array
        # We can scale them down or add a constant to ensure they are less than the exact fit priority.
        # For simplicity, let's scale them by a factor less than 1, but larger than the penalty for non-exact fits.
        # The goal is that exact fits are still distinctly preferred, but exploration happens among near fits.
        # We can map the probabilities to a range like [50, 99] for example.
        scaled_near_fit_priorities = 50.0 + softmax_probabilities * 49.0 # Scale probabilities to a range below exact fits
        
        priorities[near_fit_indices_subset] = scaled_near_fit_priorities

    return priorities
```
