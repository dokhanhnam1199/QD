```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using a Best-Fit strategy with exploration.

    This heuristic prioritizes bins that have the smallest remaining capacity
    greater than or equal to the item's size. A small epsilon is added to the
    remaining capacity before calculating priority to encourage picking bins
    that are not *exactly* full, leaving a tiny bit of slack to avoid fragmentation.
    A small probability `epsilon` is used to explore other options.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    epsilon = 0.1  # Probability of choosing a random bin among suitable ones
    num_bins = len(bins_remain_cap)
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins that can fit the item
    suitable_bins_mask = bins_remain_cap >= item

    if np.any(suitable_bins_mask):
        # Calculate a "fit" score. We want to minimize `bins_remain_cap - item`.
        # To use this in a maximization context (higher priority is better),
        # we can use the negative of this difference, or 1/(difference + small_constant).
        # Using 1 / (difference + small_constant) penalizes larger differences more.
        # Adding a small epsilon `1e-6` to `bins_remain_cap` before calculating the difference
        # can slightly favor bins that are not completely full, reducing fragmentation.
        # The smaller `bins_remain_cap + epsilon - item` is, the higher the priority.
        
        # Calculate the "slack" for suitable bins.
        slack = bins_remain_cap[suitable_bins_mask] - item
        
        # We want to prioritize bins with minimum slack.
        # A good heuristic is `1 / (slack + a_small_value)`.
        # The smaller the slack, the higher the priority.
        # Adding `1e-6` to slack prevents division by zero if slack is exactly zero.
        priorities[suitable_bins_mask] = 1.0 / (slack + 1e-6)

        # Epsilon-greedy exploration: With probability epsilon, choose randomly among suitable bins.
        if np.random.rand() < epsilon:
            # Assign equal probability to all suitable bins
            priorities[suitable_bins_mask] = 1.0 / np.sum(suitable_bins_mask)
        else:
            # Exploit: The current priorities already favor the best fit.
            # We can optionally normalize priorities so they sum to 1 for suitable bins,
            # but it's not strictly necessary if we just pick the max.
            # For this function returning scores, leaving them as is is fine,
            # as higher score implies higher preference.
            pass
    else:
        # If no bin can fit the item, all priorities remain 0.
        # In a real online BPP solver, this would typically trigger the creation of a new bin.
        pass

    return priorities
```
