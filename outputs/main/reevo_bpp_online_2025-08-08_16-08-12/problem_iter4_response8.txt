```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Returns priority with which we want to add item to each bin using a refined
    Best Fit strategy that also considers the item's size relative to the bin's capacity.

    This heuristic prioritizes bins that can fit the item. Among those that fit,
    it assigns a higher priority to bins that will have the smallest remaining
    capacity after the item is placed (Best Fit). Additionally, it slightly favors
    bins that are not "too large" for the item, to prevent using large bins for small items,
    which can lead to fragmentation. The score is based on the inverse of the remaining capacity,
    giving a higher score to tighter fits. Bins that cannot fit the item receive a score of 0.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins that can accommodate the item
    can_fit_mask = bins_remain_cap >= item

    # Calculate the remaining capacity if the item is placed in a fitting bin
    remaining_after_placement = bins_remain_cap[can_fit_mask] - item

    # Calculate a score that prioritizes smaller remaining capacity (Best Fit).
    # The inverse of remaining capacity is used, with a small epsilon for numerical stability.
    # Smaller remaining capacity leads to a higher score.
    best_fit_scores = 1.0 / (remaining_after_placement + 1e-9)

    # Optionally, can add a factor that penalizes very large remaining capacities relative to the item.
    # For simplicity and focusing on the "tight fit" aspect, we primarily rely on the inverse remaining capacity.
    # A potential refinement could be `best_fit_scores * (1 - (bins_remain_cap[can_fit_mask] - item) / bins_remain_cap[can_fit_mask])`
    # but this might overcomplicate and could lead to issues if bin capacity is 0.
    # Sticking to the core Best Fit principle here.

    priorities[can_fit_mask] = best_fit_scores

    # Ensure that bins that cannot fit the item have a priority of 0, which is handled by initialization.

    return priorities
```
