```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Epsilon-Greedy.

    This heuristic prioritizes bins that have just enough space for the item (tight fit),
    with a small probability of choosing a random bin to encourage exploration.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    epsilon = 0.1  # Probability of choosing a random bin
    num_bins = len(bins_remain_cap)
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins that can fit the item
    suitable_bins_mask = bins_remain_cap >= item

    if np.any(suitable_bins_mask):
        # Calculate a "tightness" score for suitable bins
        # Lower value means tighter fit (less wasted space)
        tightness_scores = bins_remain_cap[suitable_bins_mask] - item
        
        # Assign a higher priority to bins with a tighter fit.
        # We can invert the tightness score to make higher values mean higher priority.
        # Adding a small constant to avoid division by zero if all fits are perfect.
        priorities[suitable_bins_mask] = 1.0 / (tightness_scores + 1e-6)

        # Apply epsilon-greedy strategy
        if np.random.rand() < epsilon:
            # Explore: Assign equal probability to all bins (including unsuitable ones)
            # This can sometimes be useful if the "best" fit isn't always optimal long-term.
            # However, for strict fitting, we might want to only explore among suitable bins.
            # For this implementation, we'll explore among *all* bins to allow for
            # the possibility of picking a slightly less optimal bin that might
            # enable better packing later.
            priorities = np.ones_like(priorities) / num_bins
        else:
            # Exploit: Select the bin with the highest priority score (tightest fit)
            # For non-suitable bins, priority remains 0, so they won't be picked by max.
            pass
    else:
        # If no bin can fit the item, all priorities remain 0.
        # In a real implementation, this would likely trigger creating a new bin.
        pass

    return priorities
```
