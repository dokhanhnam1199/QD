```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using a Best Fit strategy.

    The Best Fit strategy aims to place the item into the bin where it fits most snugly,
    leaving the least remaining capacity. This often leads to better overall packing.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
        A higher priority score indicates a better fit.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    # For bins where the item fits (remaining capacity >= item size)
    # we want to prioritize bins with the smallest remaining capacity after placement.
    # This is equivalent to prioritizing bins with remaining capacity just enough to fit the item.
    # The 'cost' of placing the item is the remaining capacity of the bin AFTER placing the item.
    # We want to MINIMIZE this cost. Since priority is usually interpreted as "more is better",
    # we can transform the cost. A simple transformation is to use the negative of the cost
    # or a large number minus the cost, ensuring that bins with lower costs (better fits)
    # get higher priority scores.

    # Calculate the remaining capacity if the item is placed in each bin
    potential_remaining_capacities = bins_remain_cap - item

    # Filter out bins where the item doesn't fit
    fits_mask = potential_remaining_capacities >= 0

    # For bins where the item fits, assign a priority based on how tightly it fits.
    # The ideal scenario is when potential_remaining_capacities is 0 (perfect fit).
    # Bins with smaller potential_remaining_capacities are better.
    # We can use the negative of the potential_remaining_capacities as a priority score.
    # This means a perfect fit (0 remaining capacity) will have a priority of 0,
    # while a tighter fit (e.g., -1 remaining capacity if it were allowed, but we filtered)
    # would have a higher positive priority if we used a different logic.
    # A more standard way for "best fit" to be directly translated to a highest priority
    # would be to consider the difference `bin_capacity - item_size`. The smaller this
    # difference for a valid bin, the better the fit.
    # So, `-(bin_capacity - item_size)` will give higher scores to better fits.

    # To ensure that bins where the item doesn't fit have a lower priority (or zero),
    # we can initialize priorities to a low value or zero and then update only for valid bins.
    
    # Calculate the "badness" of the fit: how much capacity is left over.
    # We want to minimize this.
    fit_differences = bins_remain_cap - item

    # Only consider bins where the item fits
    valid_fits = fit_differences[fits_mask]

    # Assign priorities. For a best fit heuristic, we want to assign a high score to the bin
    # that has the smallest remaining capacity after fitting the item.
    # The smaller `bins_remain_cap[i] - item` is (as long as it's >= 0), the better.
    # So, a simple priority can be `- (bins_remain_cap[i] - item)`.
    # However, this might lead to positive priorities for bins that are only slightly too small
    # if we didn't have the `fits_mask`.
    # A common way to implement "best fit" as a priority is to assign a score based on the inverse
    # of the leftover space. Or, a very high priority for the *least* leftover space.
    
    # Let's use a penalty approach: the "penalty" is the leftover capacity.
    # We want to minimize the penalty. So, higher priority means smaller penalty.
    # A simple transformation: `max_possible_leftover - actual_leftover`.
    # The maximum possible leftover could be considered the bin capacity, or simply the max
    # of valid leftovers.

    # Another approach is to assign a priority inversely proportional to the remaining capacity
    # after placing the item, but ensure it's only for valid placements.
    # For bins `i` where `bins_remain_cap[i] >= item`:
    # Priority is proportional to `1 / (bins_remain_cap[i] - item)` or `-(bins_remain_cap[i] - item)`
    # and these values should be positive for priority.
    # Let's map `bins_remain_cap[i] - item` to a priority score such that smaller difference means higher priority.
    # `priority = MAX_PRIORITY - (bins_remain_cap[i] - item)` could work if we know MAX_PRIORITY.
    # Alternatively, `priority = 1.0 / (1 + (bins_remain_cap[i] - item))` for bins that fit.

    # Let's try a direct score where higher is better:
    # For valid fits, the "score" is how much capacity is left. We want this to be minimal.
    # So, we can make the priority inversely related to the leftover space.
    # A simple way: give a large base score, and subtract the leftover space.
    # We need to handle the case where `bins_remain_cap[i] - item` is zero.
    # Let's aim for priorities like:
    # For bins where `bins_remain_cap[i] >= item`: priority = `C - (bins_remain_cap[i] - item)`
    # For bins where `bins_remain_cap[i] < item`: priority = 0 or a very small negative number.
    
    # A robust way for Best Fit is to prioritize bins with the smallest *positive* difference
    # between bin capacity and item size.
    
    # Calculate the remaining capacity for all bins, and mark invalid fits with a large negative value.
    # This way, `np.argmax` will select the bin with the smallest positive residual, or the largest
    # negative value if no bin fits.
    
    # A common pattern for "best fit" with `argmax` is to return `-(residual_capacity)` for valid fits,
    # and `-infinity` or a very small number for invalid fits.
    
    # `residual_capacity = bins_remain_cap[i] - item`
    # If `residual_capacity >= 0`, priority is `-residual_capacity`. This means a smaller positive
    # residual leads to a higher (less negative) priority. E.g., residual 0 -> priority 0, residual 1 -> priority -1.
    # If `residual_capacity < 0`, priority is `-np.inf` (or a very small number).
    
    # Let's assign a very low priority score to bins where the item doesn't fit.
    # For bins where it fits, the priority is the negative of the remaining capacity after packing.
    # This means the smallest non-negative remaining capacity will have the highest (least negative) priority.
    
    priorities = np.full_like(bins_remain_cap, -np.inf) # Initialize with very low priority
    
    can_fit_mask = bins_remain_cap >= item
    
    # Calculate remaining capacity for bins where item can fit
    remaining_after_fit = bins_remain_cap[can_fit_mask] - item
    
    # For bins that can fit the item, the priority is the negative of the leftover space.
    # The smaller the leftover space (closer to 0), the higher the priority score (closer to 0).
    priorities[can_fit_mask] = -remaining_after_fit
    
    return priorities
```
