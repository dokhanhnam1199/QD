```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Prioritizes bins for the online Bin Packing Problem, favoring exact fits
    and using a softmax approach based on the inverse of remaining capacity
    for other fitting bins to balance exploitation and exploration.

    This heuristic assigns the highest priority to bins where the item fits exactly.
    For bins that can fit the item but not exactly, it calculates a priority score
    based on the inverse of the remaining capacity after placement. This score
    is then passed through a softmax function with a temperature parameter,
    allowing for exploration. Higher inverse remaining capacity (i.e., smaller
    remaining capacity) leads to a higher score before softmax.

    Args:
        item: The size of the item to be packed.
        bins_remain_cap: A numpy array containing the remaining capacity of each bin.

    Returns:
        A numpy array of the same size as bins_remain_cap, where each element
        represents the priority score of placing the item in the corresponding bin.
        Bins that cannot fit the item will have a priority of -np.inf.
    """
    temperature = 0.5  # Tunable parameter for exploration. Lower = more greedy.

    priorities = np.full_like(bins_remain_cap, -np.inf)

    # Identify bins that can accommodate the item.
    can_fit_mask = bins_remain_cap >= item

    if not np.any(can_fit_mask):
        return priorities  # No bin can fit the item

    fitting_bins_remain_cap = bins_remain_cap[can_fit_mask]
    remaining_after_placement = fitting_bins_remain_cap - item

    # Assign a very high priority to exact fits
    exact_fit_mask_subset = (remaining_after_placement == 0)
    priorities[can_fit_mask][exact_fit_mask_subset] = 100.0

    # For bins that fit but are not exact fits, calculate scores for softmax
    non_exact_fit_indices_subset = np.where(~exact_fit_mask_subset)[0]

    if non_exact_fit_indices_subset.size > 0:
        non_exact_fitting_bins_remain_cap_subset = fitting_bins_remain_cap[~exact_fit_mask_subset]
        non_exact_remaining_after_placement = non_exact_fitting_bins_remain_cap_subset - item

        # Calculate scores for softmax: higher score for smaller remaining capacity (better fit)
        # Use inverse of remaining capacity. Add epsilon to avoid division by zero.
        fit_scores_for_softmax = 1.0 / (non_exact_remaining_after_placement + 1e-9)

        # Apply softmax for exploration.
        # Shift scores so the maximum is 0 for numerical stability with exp.
        if fit_scores_for_softmax.size > 0:
            shifted_fit_scores = fit_scores_for_softmax - np.max(fit_scores_for_softmax)
            soft_priorities = np.exp(shifted_fit_scores / temperature)

            # Scale these priorities to be less than the exact fit priority (100.0)
            # and ensure they are positive. Max value of soft_priorities is 1.0.
            scale_factor = 99.0
            priorities[can_fit_mask][~exact_fit_mask_subset] = soft_priorities * scale_factor

    return priorities
```
