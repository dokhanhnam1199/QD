```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Returns priority with which we want to add item to each bin, prioritizing Exact Fit, then Best Fit,
    with a small exploration component favoring bins with larger remaining capacity.

    This heuristic prioritizes bins that offer an exact fit for the item.
    If no exact fit is available, it then prioritizes bins that can accommodate the item
    with the smallest remaining capacity (Best Fit approach among the remaining options).
    As a secondary exploration, it slightly boosts bins that have a larger remaining capacity,
    aiming to keep more space available for potentially larger future items.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Returns:
        Array of same size as bins_remain_cap with priority score of each bin.
        Exact fits get the highest priority (e.g., 100). Bins that fit but not exactly
        get a priority based on the "tightness" of the fit, inversely proportional to
        the slack (remaining capacity - item size), with a slight bonus for larger remaining capacity.
        Bins that cannot fit get 0 priority.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    epsilon = 0.05  # Probability of exploration based on remaining capacity

    # Identify bins where the item can fit
    can_fit_mask = bins_remain_cap >= item
    fitting_bins_capacities = bins_remain_cap[can_fit_mask]
    fitting_indices = np.where(can_fit_mask)[0]

    if fitting_bins_capacities.size == 0:
        return priorities  # No bin can fit the item

    # Calculate slack for bins that can fit the item
    slacks = fitting_bins_capacities - item

    # Exact fit has the highest priority
    exact_fit_mask = slacks == 0
    exact_fit_indices = fitting_indices[exact_fit_mask]
    priorities[exact_fit_indices] = 100.0

    # For bins that are not an exact fit, assign priority based on the slack (Best Fit)
    # and introduce a small exploration bonus for larger remaining capacity.
    non_exact_fit_mask = slacks > 0
    non_exact_fit_indices = fitting_indices[non_exact_fit_mask]
    non_exact_slacks = slacks[non_exact_fit_mask]
    non_exact_capacities = fitting_bins_capacities[non_exact_fit_mask]

    if non_exact_fit_indices.size > 0:
        # Sort these bins by slack in ascending order.
        sorted_slack_indices = np.argsort(non_exact_slacks)

        # Assign base priorities from highest (99) to lowest based on sorted slack
        base_priorities = 99.0 - np.arange(non_exact_slacks.size)

        # Introduce a small exploration bonus for bins with larger remaining capacity.
        # This bonus is scaled by epsilon and the relative difference in capacity.
        # We normalize capacities to avoid issues with very large numbers and to
        # ensure the bonus is relative.
        min_cap = np.min(non_exact_capacities)
        max_cap = np.max(non_exact_capacities)
        
        exploration_bonus = np.zeros(non_exact_slacks.size)
        if max_cap > min_cap: # Avoid division by zero if all non-exact fits have the same capacity
            normalized_capacities = (non_exact_capacities - min_cap) / (max_cap - min_cap)
            # Small bonus for higher capacity, scaled by epsilon
            exploration_bonus = epsilon * normalized_capacities

        # Combine base priority and exploration bonus
        combined_priorities = base_priorities + exploration_bonus

        # Assign combined priorities
        priorities[non_exact_fit_indices[sorted_slack_indices]] = combined_priorities

    return priorities
```
