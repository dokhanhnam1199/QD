[Prior reflection]
Prioritize exact/tight fits for minimal slack. Explore diverse bins judiciously. Softmax for exploration balance. Fine-tune temperature for flexibility. Avoid complex penalties.

[Code]
def priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:

    """Returns priority with which we want to add item to each bin using a First Fit strategy with a twist.

    This heuristic prioritizes bins that can fit the item. Among those that fit,
    it assigns a higher priority to bins that will have less remaining capacity
    after the item is placed. This is a greedy approach aiming to fill bins
    as much as possible, encouraging denser packing.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins that can accommodate the item
    can_fit_mask = bins_remain_cap >= item

    # Calculate the remaining capacity if the item is placed in a fitting bin
    remaining_after_placement = bins_remain_cap[can_fit_mask] - item

    # Assign higher priority to bins that will have less remaining capacity
    # This is equivalent to prioritizing bins where the item fills a larger
    # proportion of the remaining space.
    # We invert the remaining capacity so that smaller remaining capacity gets higher priority.
    # Adding a small epsilon to avoid division by zero if remaining capacity is exactly 0,
    # although with this logic, that case would already have a high priority.
    priorities[can_fit_mask] = 1.0 / (remaining_after_placement + 1e-9)

    return priorities

[Improved code]
def priority_v2(item: float, bins_remain_cap: np.ndarray, temperature: float = 1.0) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This heuristic prioritizes bins that can fit the item. Among those that fit,
    it assigns a higher priority to bins that will have less remaining capacity
    after the item is placed (tight fit). It also introduces a gentle exploration
    mechanism using softmax to consider other fitting bins, preventing premature
    over-optimization of a few bins.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.
        temperature: Controls the randomness of the exploration. Higher values
                     lead to more exploration (flatter distribution), lower
                     values lead to more greedy choices (sharper distribution).

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins that can accommodate the item
    can_fit_mask = bins_remain_cap >= item

    # Calculate a "tightness" score for fitting bins.
    # Smaller remaining capacity after placement is better (tighter fit).
    # We add 1 to avoid division by zero and to ensure positive scores.
    # A small epsilon is added for numerical stability.
    tightness_scores = 1.0 / (bins_remain_cap[can_fit_mask] - item + 1e-9)

    # Apply softmax to introduce exploration among fitting bins.
    # The temperature parameter controls the sharpness of the distribution.
    # Higher temperature means more uniform probabilities (more exploration).
    # Lower temperature means probabilities are more concentrated on the best options.
    if np.sum(can_fit_mask) > 0:
        exp_scores = np.exp(tightness_scores / temperature)
        probabilities = exp_scores / np.sum(exp_scores)
        priorities[can_fit_mask] = probabilities
    else:
        # If no bin can fit the item, all priorities remain zero.
        pass

    return priorities
```
