```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Prioritizes bins using a combination of "Best Fit" (exploitation) and a
    penalty for bins that are too empty (exploration component).

    This heuristic aims to:
    1. Exploit: Prioritize bins that provide a "tight fit" for the current item.
       This is achieved by favoring bins where the remaining capacity after
       placing the item is minimized (closest to zero).
    2. Explore: Slightly penalize bins that have a large amount of remaining
       capacity even before placing the item. This encourages using bins that
       are already somewhat full, potentially leaving the emptier bins for
       future larger items.

    The priority is calculated as:
    - For bins that can fit the item:
      The score is derived from the remaining capacity after fitting.
      A tight fit (small `bins_remain_cap - item`) yields a higher score.
      The score is designed such that a tight fit gets a high positive value,
      and a loose fit gets a lower value.
    - For bins that cannot fit the item: A priority of negative infinity.

    A penalty is applied to bins that are "too empty" to encourage using
    bins that are already partially filled.

    Args:
        item: The size of the item to be packed.
        bins_remain_cap: A numpy array containing the remaining capacity of each bin.

    Returns:
        A numpy array of the same size as bins_remain_cap, where each element
        represents the priority score for placing the item in the corresponding bin.
    """
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Identify bins that have enough capacity to fit the item
    can_fit_mask = bins_remain_cap >= item

    # Calculate the remaining capacity after placing the item for bins that can fit.
    remaining_capacities_after_fit = bins_remain_cap[can_fit_mask] - item

    # Calculate a base "best fit" score. Higher score for smaller remaining capacity.
    # We use the negative of the remaining capacity. Smaller remaining capacity means
    # a larger negative number, which we want to be higher priority.
    # Example:
    # Bin A: remaining_cap = 10, item = 7 -> remaining_after_fit = 3. Score = -3.
    # Bin B: remaining_cap = 8, item = 7 -> remaining_after_fit = 1. Score = -1.
    # Bin B is a tighter fit and has a higher score.
    best_fit_scores = -remaining_capacities_after_fit

    # Introduce an exploration penalty for bins that are too empty.
    # This encourages using bins that are already somewhat occupied.
    # We can define "too empty" as having a remaining capacity significantly larger
    # than the item itself, or simply a very large absolute capacity.
    # A simple penalty: subtract a value proportional to the original remaining capacity.
    # This makes bins with large remaining capacity less attractive.
    # We only apply this penalty to bins that can fit the item.
    # The penalty should be smaller for bins that are already a tight fit.
    # Let's define a 'emptiness_penalty' that is higher for bins with higher initial capacity.
    # We can use a logarithmic scale or a simple linear scale, scaled to not overwhelm best_fit_scores.
    # A common approach is to penalize bins with lots of unused space.
    # Let's consider the "slack" or unused capacity if we were to fill the bin as much as possible.
    # However, for online BPP, we only care about the remaining capacity.
    # Let's penalize bins that have remaining_capacities_after_fit that are still large.
    # Or even simpler, penalize based on the original bin capacity if it's much larger than the item.
    # A simple approach: penalize the original `bins_remain_cap` itself.
    # The penalty should be subtracted from the `best_fit_scores`.

    # For bins that can fit:
    # Score = (tight_fit_score) - (emptiness_penalty)
    # tight_fit_score = -remaining_capacities_after_fit
    # emptiness_penalty could be related to bins_remain_cap[can_fit_mask]

    # Let's refine the scoring:
    # We want to prioritize bins that have `bins_remain_cap - item` small and positive.
    # The `priority_v1` did this well with `-remaining_capacities_after_fit`.
    # Now, let's add the exploration: penalize bins that are "too empty".
    # What if we define "too empty" as a bin whose remaining capacity is much larger than the item?
    # Or a bin that has a lot of unused capacity relative to the bin's total capacity (if we knew it)?
    # Since we only have `bins_remain_cap`, let's focus on that.
    # A bin is "too empty" if `bins_remain_cap` is large.
    # Let's subtract a portion of `bins_remain_cap` from the best-fit score.
    # The larger `bins_remain_cap`, the larger the subtraction (more penalty).
    # We need to be careful not to make the penalty too aggressive.
    # A scaling factor might be needed.

    # Let's consider a weighted sum:
    # priority = w1 * (best_fit_score) + w2 * (exploration_score)
    # where best_fit_score is high for tight fits, and exploration_score is low for empty bins.
    # Or simply:
    # priority = best_fit_score - penalty_for_emptiness

    # A potential formula:
    # priority = - (bins_remain_cap[i] - item) - alpha * bins_remain_cap[i]
    # where alpha is a small positive constant to control the penalty.
    # Let's try to combine these directly.
    # We want to maximize `- (bins_remain_cap[i] - item)` (tight fit)
    # and minimize `bins_remain_cap[i]` (avoid empty bins).
    # So we want to maximize `-(bins_remain_cap[i] - item) - alpha * bins_remain_cap[i]`

    alpha = 0.1  # Controls the penalty for empty bins. Adjust as needed.

    # Calculate the combined score for bins that can fit.
    # The first term promotes tight fits.
    # The second term penalizes bins that are initially large (empty).
    combined_scores = -remaining_capacities_after_fit - alpha * bins_remain_cap[can_fit_mask]

    priorities[can_fit_mask] = combined_scores

    # Ensure we don't have NaN or Inf from potential division by zero if alpha were in denominator etc.
    # Our current formula is safe.
    return priorities
```
