[Prior reflection]
Prioritize exact fits. For near fits, scale inverse remaining capacity aggressively but stably. Differentiate fit categories, tune scores, and use bounded transformations to avoid unnecessary temperature scaling.

[Code]
```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Prioritizes bins for the online Bin Packing Problem, with enhanced strategies.

    This heuristic categorizes bins into:
    1. Exact Fits: Bins where the item perfectly fills the remaining capacity.
    2. Near Fits: Bins where the item fits, and the remaining capacity after placement
       is small (defined by a threshold). These are further prioritized using a
       stable, scaled inverse of the remaining capacity to balance exploitation (best near fit)
       and exploration (trying other near fits).
    3. General Fits: Bins where the item fits, but the remaining capacity after
       placement is not considered "near". These receive a low positive priority.
    4. Unfittable: Bins where the item cannot fit. These receive negative infinity priority.

    Args:
        item: The size of the item to be packed.
        bins_remain_cap: A numpy array containing the remaining capacity of each bin.

    Returns:
        A numpy array of the same size as bins_remain_cap, where each element
        represents the priority score for placing the item in the corresponding bin.
    """
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # --- Configuration Parameters ---
    EXACT_FIT_PRIORITY = 100.0
    # Base score for near fits to be preferred over general fits.
    NEAR_FIT_BASE_SCORE = 50.0
    # Scaling factor for near fit scores to differentiate them.
    NEAR_FIT_SCALE = 40.0
    # Priority for bins that fit but are not considered "near".
    GENERAL_FIT_PRIORITY = 1.0
    # Threshold for "near fit": remaining capacity is less than this fraction of item size.
    NEAR_FIT_THRESHOLD_RELATIVE = 0.15
    # Absolute minimum remaining capacity to be considered a near fit.
    NEAR_FIT_THRESHOLD_ABSOLUTE = 5.0
    # Small constant for numerical stability, to avoid division by zero or log(0).
    EPSILON_SMALL = 1e-9
    # Bounding factor for the inverse remaining capacity to prevent extreme scores.
    MAX_INVERSE_CAPACITY_BOUND = 20.0 # Arbitrary bound, can be tuned.

    # --- Identify Bin Categories ---
    can_fit_mask = bins_remain_cap >= item

    # If no bin can fit the item, return all -inf priorities.
    if not np.any(can_fit_mask):
        return priorities

    # 1. Exact Fits
    # Use a small tolerance for floating point comparisons.
    exact_fit_mask = can_fit_mask & (np.abs(bins_remain_cap - item) < EPSILON_SMALL)
    priorities[exact_fit_mask] = EXACT_FIT_PRIORITY

    # Identify bins that can fit but are not exact fits.
    general_fitting_mask = can_fit_mask & ~exact_fit_mask

    if np.any(general_fitting_mask):
        fitting_bin_indices = np.where(general_fitting_mask)[0]
        remaining_capacities_after_placement = bins_remain_cap[fitting_bin_indices] - item

        # Define near fit criteria: remaining capacity is small relative to item size or absolutely.
        near_fit_criteria = (remaining_capacities_after_placement < NEAR_FIT_THRESHOLD_ABSOLUTE) | \
                            (remaining_capacities_after_placement < item * NEAR_FIT_THRESHOLD_RELATIVE)
        
        near_fit_indices_subset = fitting_bin_indices[near_fit_criteria]
        non_near_fit_indices_subset = fitting_bin_indices[~near_fit_criteria]

        # Process Near Fits
        if len(near_fit_indices_subset) > 0:
            near_fit_remaining_caps = remaining_capacities_after_placement[near_fit_criteria]

            # Score for near fits: inverse of remaining capacity, scaled and bounded.
            # Add EPSILON_SMALL for stability.
            inverse_caps = 1.0 / (near_fit_remaining_caps + EPSILON_SMALL)
            
            # Apply aggressive scaling and then bound to stabilize.
            # The scaling factor (e.g., 10) amplifies differences between near fits.
            scaled_inverse_caps = inverse_caps * 10.0 
            bounded_scaled_inverse_caps = np.minimum(scaled_inverse_caps, MAX_INVERSE_CAPACITY_BOUND)
            
            # Transform bounded scores to a range that can be added to base score.
            # A simple linear scaling can work, or a tanh for a smoother transformation.
            # Let's use a bounded linear scaling for simplicity and control.
            # We want smaller remaining capacity (larger inverse_cap) to have higher priority.
            # Map the range [0, MAX_INVERSE_CAPACITY_BOUND] to [0, NEAR_FIT_SCALE].
            transformed_scores = (bounded_scaled_inverse_caps / MAX_INVERSE_CAPACITY_BOUND) * NEAR_FIT_SCALE
            
            priorities[near_fit_indices_subset] = NEAR_FIT_BASE_SCORE + transformed_scores

        # 3. General Fits
        # Bins that fit but are not exact or near fits.
        if len(non_near_fit_indices_subset) > 0:
            priorities[non_near_fit_indices_subset] = GENERAL_FIT_PRIORITY
            
    return priorities
```
