```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Prioritizes bins for the online Bin Packing Problem using a refined strategy.
    This heuristic prioritizes exact fits, then uses a temperature-controlled
    softmax on the inverse of remaining capacity for near fits to encourage exploration
    while favoring bins with less remaining space.

    Args:
        item: The size of the item to be packed.
        bins_remain_cap: A numpy array containing the remaining capacity of each bin.

    Returns:
        A numpy array of the same size as bins_remain_cap, where each element
        represents the priority score for placing the item in the corresponding bin.
        Higher scores indicate higher priority.
    """
    temperature = 0.5  # Tunable parameter for exploration. Lower = more greedy.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Identify bins that can accommodate the item.
    can_fit_mask = bins_remain_cap >= item

    if not np.any(can_fit_mask):
        return priorities  # No bin can fit the item

    fitting_bins_indices = np.where(can_fit_mask)[0]
    fitting_bins_remain_cap = bins_remain_cap[fitting_bins_indices]
    remaining_after_placement = fitting_bins_remain_cap - item

    # Assign a very high priority for exact fits.
    exact_fit_mask_subset = (remaining_after_placement == 0)
    exact_fit_indices = fitting_bins_indices[exact_fit_mask_subset]
    priorities[exact_fit_indices] = 100.0

    # Handle near fits using a softmax on the inverse of remaining capacity.
    # This favors bins with less remaining capacity among the near fits.
    near_fit_mask_subset = ~exact_fit_mask_subset
    near_fit_indices_subset = fitting_bins_indices[near_fit_mask_subset]

    if np.any(near_fit_mask_subset):
        near_fit_remaining = remaining_after_placement[near_fit_mask_subset]

        # Calculate scores for near fits: higher score for smaller remaining capacity.
        # Use inverse of remaining capacity to achieve this. Add epsilon for stability.
        epsilon_small = 1e-6
        near_fit_scores_for_softmax = 1.0 / (near_fit_remaining + epsilon_small)

        # Apply softmax for exploration. Higher scores (smaller remaining capacity) get higher probabilities.
        # Ensure numerical stability for exp by shifting scores.
        if near_fit_scores_for_softmax.size > 0:
            max_score = np.max(near_fit_scores_for_softmax)
            shifted_scores = near_fit_scores_for_softmax - max_score
            
            # Avoid potential division by zero if all shifted_scores are -inf
            if np.all(np.isneginf(shifted_scores)):
                exp_scores = np.ones_like(shifted_scores)
            else:
                exp_scores = np.exp(shifted_scores / temperature)
            
            sum_exp_scores = np.sum(exp_scores)

            if sum_exp_scores > 0:
                softmax_probabilities = exp_scores / sum_exp_scores
            else:
                # Fallback to uniform if sum is zero (e.g., all exp_scores were 0)
                softmax_probabilities = np.ones_like(exp_scores) / len(exp_scores)

            # Scale these probabilities to a range that is lower than exact fits,
            # but reflects the relative preference. A range like [50, 99.9] would be suitable.
            # Higher softmax probability (from smaller remaining capacity) results in a higher score.
            scaled_near_fit_priorities = 50.0 + softmax_probabilities * 49.9

            priorities[near_fit_indices_subset] = scaled_near_fit_priorities

    # Ensure any bin that can fit but wasn't assigned a priority (e.g., if near_fit_mask_subset was empty)
    # gets a minimal positive priority. This scenario is less likely with the current logic
    # but good for robustness.
    default_low_priority = 1.0
    unassigned_fitting_bins = np.where(can_fit_mask & (priorities == -np.inf))[0]
    priorities[unassigned_fitting_bins] = default_low_priority

    return priorities
```
