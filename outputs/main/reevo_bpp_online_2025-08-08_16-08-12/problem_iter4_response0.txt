```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin, favoring 'Tight Fit'.

    This heuristic prioritizes bins that can accommodate the item and have a remaining
    capacity that is closest to the item's size. This is a refinement of the "Tight Fit"
    strategy by penalizing bins where the remaining capacity is significantly larger
    than the item size. The goal is to leave larger contiguous free spaces in other bins
    for potentially larger future items.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Returns:
        Array of same size as bins_remain_cap with priority score of each bin.
        Higher priority is given to bins where remaining_capacity - item is smallest
        and non-negative.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins that can accommodate the item
    can_fit_mask = bins_remain_cap >= item

    # For bins that can fit the item, calculate a score.
    # We want to minimize the difference (bins_remain_cap - item).
    # The smaller this difference, the higher the priority.
    # We use the inverse of this difference to achieve higher scores for smaller differences.
    # Add epsilon to avoid division by zero if the difference is exactly 0.
    # Also, we add a penalty proportional to how much larger the remaining capacity is than the item,
    # to further emphasize tighter fits over looser fits.
    epsilon = 1e-9
    difference = bins_remain_cap[can_fit_mask] - item

    # The score is primarily driven by the inverse of the difference (tightest fit).
    # We add a term that slightly penalizes larger differences. For example,
    # a bin with remaining capacity 5 for item 3 (diff=2) should be less preferred
    # than a bin with remaining capacity 3 for item 3 (diff=0).
    # The term `difference` itself penalizes larger differences when used in the denominator.
    # To make it more direct, we can use `1 / (difference + epsilon)` for "Tight Fit"
    # and potentially add a secondary term or use a different function for "Almost Full Fit".
    # For a refined "Tight Fit", we want to minimize `difference`.
    # Let's use a score that is high when `difference` is small and positive.
    # `1 / (difference + epsilon)` works for this.

    # To further refine towards 'tightest' fit and penalize larger gaps:
    # Consider a function that penalizes larger `difference` more.
    # For example, we can square the difference, or use `exp(-difference)`.
    # Let's stick with the inverse for now as it's a direct interpretation of prioritizing small positive differences.
    # If we want to penalize larger differences, making them *less* preferred than very tight fits:
    # `priorities[can_fit_mask] = 1.0 / (difference + epsilon)` naturally does this.
    # A bin with difference 1 gets priority 1/(1+eps), difference 2 gets 1/(2+eps).

    # A more aggressive approach to penalize larger gaps:
    # `priorities[can_fit_mask] = 1.0 / (difference**2 + epsilon)` - this penalizes larger differences more heavily.
    # Let's use the simple inverse for a direct "Tight Fit" as described in the reflection.
    priorities[can_fit_mask] = 1.0 / (difference + epsilon)

    return priorities
```
