```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using an Epsilon-Greedy strategy.

    The strategy aims to balance exploration (trying less optimal but potentially good bins)
    and exploitation (choosing the best available bin).

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    epsilon = 0.1  # Probability of exploration
    num_bins = len(bins_remain_cap)

    # Calculate the "greediness" of each bin: how well it fits the item.
    # We want bins that are a good fit but not so tight that they become unusable
    # for future items. A good fit leaves a small remainder.
    # If an item doesn't fit, its "greediness" is set to a very low value (e.g., -inf)
    # to effectively disqualify it.

    # Calculate potential remainders if the item fits
    potential_remainders = bins_remain_cap - item

    # Identify bins where the item can fit
    fitting_bins_mask = potential_remainders >= 0

    # For bins where the item fits, calculate a score. A good score is one
    # where the remainder is small but positive. We can invert the remainder
    # so that smaller remainders get higher scores. Adding a small constant
    # ensures that even a perfect fit (zero remainder) gets a positive score.
    # We use `np.inf` for bins that don't fit to ensure they are never selected by the greedy part.
    greediness_scores = np.full_like(bins_remain_cap, -np.inf)
    greediness_scores[fitting_bins_mask] = 1.0 / (potential_remainders[fitting_bins_mask] + 1e-9) # Adding epsilon for stability, small remainder is good

    # Normalize greediness scores to be between 0 and 1 for easier combination with epsilon
    max_greediness = np.max(greediness_scores[fitting_bins_mask] if np.any(fitting_bins_mask) else [0])
    if max_greediness > 0:
        normalized_greediness = greediness_scores / max_greediness
    else:
        normalized_greediness = np.zeros_like(greediness_scores) # All bins might be too small

    # Introduce exploration: with probability epsilon, pick a random bin among those that fit.
    # With probability (1 - epsilon), pick the bin with the highest greediness score.

    # Generate random scores for exploration
    exploration_scores = np.random.rand(num_bins)

    # Combine greediness and exploration
    priorities = np.where(np.random.rand(num_bins) < epsilon,
                          exploration_scores,
                          normalized_greediness)

    # Ensure that bins where the item doesn't fit have zero or negative priority
    # (though the -np.inf in greediness_scores already handles this for the greedy part)
    # The exploration part might pick a non-fitting bin if we're not careful.
    # So, we explicitly set priorities to a very low value for non-fitting bins
    # even during exploration to avoid invalid moves.
    priorities[~fitting_bins_mask] = -np.inf

    return priorities
```
