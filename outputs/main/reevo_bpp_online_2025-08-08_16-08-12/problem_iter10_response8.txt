```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Returns priority with which we want to add item to each bin, prioritizing
    minimal slack, penalizing exact fits, and exploring small positive remainders.

    This heuristic prioritizes bins that can fit the item. Among those that fit,
    it assigns a higher priority to bins that will have less remaining capacity
    after the item is placed (minimal slack). This encourages denser packing.
    A penalty is applied to bins that would become completely full, discouraging
    exact fits. To introduce an exploratory element, bins that result in a
    small, positive remainder (e.g., up to 5% of the item's size) are given a
    moderate boost to their priority. This encourages leaving a useful, but not
    excessive, amount of space.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Returns:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins that can accommodate the item
    can_fit_mask = bins_remain_cap >= item

    # If no bin can fit the item, return all zeros
    if not np.any(can_fit_mask):
        return priorities

    # Calculate the remaining capacity if the item is placed in a fitting bin
    remaining_after_placement = bins_remain_cap[can_fit_mask] - item

    # Base priority: prioritize bins with minimal slack.
    # Higher score for smaller remainders. Use negative to sort ascending.
    # Add a small epsilon to avoid ties with exact fits if we don't want to penalize them heavily
    base_priorities = -remaining_after_placement

    # Penalty for bins that would become exactly full.
    # Subtract a value to make exact fits less attractive than small positive remainders.
    # The magnitude of the penalty can be tuned.
    penalty_for_full = 0.1
    fully_filled_mask = (remaining_after_placement == 0)
    priorities[can_fit_mask] = base_priorities
    priorities[can_fit_mask][fully_filled_mask] -= penalty_for_full

    # Exploratory boost: favor bins that have a small positive remainder.
    # A small positive remainder is considered to be up to 5% of the item's size.
    exploratory_boost_threshold = 0.05 * item
    small_positive_remainder_mask = (remaining_after_placement > 0) & (remaining_after_placement <= exploratory_boost_threshold)
    exploratory_boost_value = 0.2  # Moderate boost value
    priorities[can_fit_mask][small_positive_remainder_mask] += exploratory_boost_value

    # Ensure all priorities are non-negative by shifting if necessary.
    # Find the minimum priority among valid choices and shift all priorities up.
    valid_priorities = priorities[can_fit_mask]
    if valid_priorities.size > 0:
        min_valid_priority = np.min(valid_priorities)
        if min_valid_priority < 0:
            priorities[can_fit_mask] -= min_valid_priority

    # Ensure non-fitting bins have the lowest possible priority (0 after shift)
    priorities[~can_fit_mask] = 0.0

    return priorities
```
