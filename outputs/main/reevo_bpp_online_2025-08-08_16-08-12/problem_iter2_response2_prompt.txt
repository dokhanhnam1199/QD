{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin using Inverse Distance strategy.\n\n    The Inverse Distance strategy prioritizes bins that are \"closer\" to fitting the item.\n    A higher priority is assigned to bins with less remaining capacity that can still\n    accommodate the item.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the \"distance\" to fitting the item.\n    # This is the remaining capacity minus the item size.\n    # A smaller positive distance means a better fit.\n    distances = bins_remain_cap - item\n\n    # Initialize priorities to a very low value (e.g., negative infinity)\n    # for bins that cannot fit the item.\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    # For bins that can fit the item (distances >= 0):\n    # Calculate inverse distance as priority.\n    # To avoid division by zero if a bin has exactly the remaining capacity,\n    # we add a small epsilon.\n    # The closer the remaining capacity is to the item size (smaller positive distance),\n    # the higher the priority.\n    fit_mask = distances >= 0\n    priorities[fit_mask] = 1.0 / (distances[fit_mask] + 1e-9)\n\n    return priorities\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin using a Best Fit strategy.\n\n    The Best Fit strategy aims to place the item into the bin where it fits most snugly,\n    leaving the least remaining capacity. This often leads to better overall packing.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        A higher priority score indicates a better fit.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # For bins where the item fits (remaining capacity >= item size)\n    # we want to prioritize bins with the smallest remaining capacity after placement.\n    # This is equivalent to prioritizing bins with remaining capacity just enough to fit the item.\n    # The 'cost' of placing the item is the remaining capacity of the bin AFTER placing the item.\n    # We want to MINIMIZE this cost. Since priority is usually interpreted as \"more is better\",\n    # we can transform the cost. A simple transformation is to use the negative of the cost\n    # or a large number minus the cost, ensuring that bins with lower costs (better fits)\n    # get higher priority scores.\n\n    # Calculate the remaining capacity if the item is placed in each bin\n    potential_remaining_capacities = bins_remain_cap - item\n\n    # Filter out bins where the item doesn't fit\n    fits_mask = potential_remaining_capacities >= 0\n\n    # For bins where the item fits, assign a priority based on how tightly it fits.\n    # The ideal scenario is when potential_remaining_capacities is 0 (perfect fit).\n    # Bins with smaller potential_remaining_capacities are better.\n    # We can use the negative of the potential_remaining_capacities as a priority score.\n    # This means a perfect fit (0 remaining capacity) will have a priority of 0,\n    # while a tighter fit (e.g., -1 remaining capacity if it were allowed, but we filtered)\n    # would have a higher positive priority if we used a different logic.\n    # A more standard way for \"best fit\" to be directly translated to a highest priority\n    # would be to consider the difference `bin_capacity - item_size`. The smaller this\n    # difference for a valid bin, the better the fit.\n    # So, `-(bin_capacity - item_size)` will give higher scores to better fits.\n\n    # To ensure that bins where the item doesn't fit have a lower priority (or zero),\n    # we can initialize priorities to a low value or zero and then update only for valid bins.\n    \n    # Calculate the \"badness\" of the fit: how much capacity is left over.\n    # We want to minimize this.\n    fit_differences = bins_remain_cap - item\n\n    # Only consider bins where the item fits\n    valid_fits = fit_differences[fits_mask]\n\n    # Assign priorities. For a best fit heuristic, we want to assign a high score to the bin\n    # that has the smallest remaining capacity after fitting the item.\n    # The smaller `bins_remain_cap[i] - item` is (as long as it's >= 0), the better.\n    # So, a simple priority can be `- (bins_remain_cap[i] - item)`.\n    # However, this might lead to positive priorities for bins that are only slightly too small\n    # if we didn't have the `fits_mask`.\n    # A common way to implement \"best fit\" as a priority is to assign a score based on the inverse\n    # of the leftover space. Or, a very high priority for the *least* leftover space.\n    \n    # Let's use a penalty approach: the \"penalty\" is the leftover capacity.\n    # We want to minimize the penalty. So, higher priority means smaller penalty.\n    # A simple transformation: `max_possible_leftover - actual_leftover`.\n    # The maximum possible leftover could be considered the bin capacity, or simply the max\n    # of valid leftovers.\n\n    # Another approach is to assign a priority inversely proportional to the remaining capacity\n    # after placing the item, but ensure it's only for valid placements.\n    # For bins `i` where `bins_remain_cap[i] >= item`:\n    # Priority is proportional to `1 / (bins_remain_cap[i] - item)` or `-(bins_remain_cap[i] - item)`\n    # and these values should be positive for priority.\n    # Let's map `bins_remain_cap[i] - item` to a priority score such that smaller difference means higher priority.\n    # `priority = MAX_PRIORITY - (bins_remain_cap[i] - item)` could work if we know MAX_PRIORITY.\n    # Alternatively, `priority = 1.0 / (1 + (bins_remain_cap[i] - item))` for bins that fit.\n\n    # Let's try a direct score where higher is better:\n    # For valid fits, the \"score\" is how much capacity is left. We want this to be minimal.\n    # So, we can make the priority inversely related to the leftover space.\n    # A simple way: give a large base score, and subtract the leftover space.\n    # We need to handle the case where `bins_remain_cap[i] - item` is zero.\n    # Let's aim for priorities like:\n    # For bins where `bins_remain_cap[i] >= item`: priority = `C - (bins_remain_cap[i] - item)`\n    # For bins where `bins_remain_cap[i] < item`: priority = 0 or a very small negative number.\n    \n    # A robust way for Best Fit is to prioritize bins with the smallest *positive* difference\n    # between bin capacity and item size.\n    \n    # Calculate the remaining capacity for all bins, and mark invalid fits with a large negative value.\n    # This way, `np.argmax` will select the bin with the smallest positive residual, or the largest\n    # negative value if no bin fits.\n    \n    # A common pattern for \"best fit\" with `argmax` is to return `-(residual_capacity)` for valid fits,\n    # and `-infinity` or a very small number for invalid fits.\n    \n    # `residual_capacity = bins_remain_cap[i] - item`\n    # If `residual_capacity >= 0`, priority is `-residual_capacity`. This means a smaller positive\n    # residual leads to a higher (less negative) priority. E.g., residual 0 -> priority 0, residual 1 -> priority -1.\n    # If `residual_capacity < 0`, priority is `-np.inf` (or a very small number).\n    \n    # Let's assign a very low priority score to bins where the item doesn't fit.\n    # For bins where it fits, the priority is the negative of the remaining capacity after packing.\n    # This means the smallest non-negative remaining capacity will have the highest (least negative) priority.\n    \n    priorities = np.full_like(bins_remain_cap, -np.inf) # Initialize with very low priority\n    \n    can_fit_mask = bins_remain_cap >= item\n    \n    # Calculate remaining capacity for bins where item can fit\n    remaining_after_fit = bins_remain_cap[can_fit_mask] - item\n    \n    # For bins that can fit the item, the priority is the negative of the leftover space.\n    # The smaller the leftover space (closer to 0), the higher the priority score (closer to 0).\n    priorities[can_fit_mask] = -remaining_after_fit\n    \n    return priorities\n\n[Reflection]\nPrioritize minimal positive residual capacity for best fit.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}