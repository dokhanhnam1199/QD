{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin using a Best-Fit strategy with exploration.\n\n    This heuristic prioritizes bins that have the smallest remaining capacity\n    greater than or equal to the item's size. A small epsilon is added to the\n    remaining capacity before calculating priority to encourage picking bins\n    that are not *exactly* full, leaving a tiny bit of slack to avoid fragmentation.\n    A small probability `epsilon` is used to explore other options.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    epsilon = 0.1  # Probability of choosing a random bin among suitable ones\n    num_bins = len(bins_remain_cap)\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Identify bins that can fit the item\n    suitable_bins_mask = bins_remain_cap >= item\n\n    if np.any(suitable_bins_mask):\n        # Calculate a \"fit\" score. We want to minimize `bins_remain_cap - item`.\n        # To use this in a maximization context (higher priority is better),\n        # we can use the negative of this difference, or 1/(difference + small_constant).\n        # Using 1 / (difference + small_constant) penalizes larger differences more.\n        # Adding a small epsilon `1e-6` to `bins_remain_cap` before calculating the difference\n        # can slightly favor bins that are not completely full, reducing fragmentation.\n        # The smaller `bins_remain_cap + epsilon - item` is, the higher the priority.\n        \n        # Calculate the \"slack\" for suitable bins.\n        slack = bins_remain_cap[suitable_bins_mask] - item\n        \n        # We want to prioritize bins with minimum slack.\n        # A good heuristic is `1 / (slack + a_small_value)`.\n        # The smaller the slack, the higher the priority.\n        # Adding `1e-6` to slack prevents division by zero if slack is exactly zero.\n        priorities[suitable_bins_mask] = 1.0 / (slack + 1e-6)\n\n        # Epsilon-greedy exploration: With probability epsilon, choose randomly among suitable bins.\n        if np.random.rand() < epsilon:\n            # Assign equal probability to all suitable bins\n            priorities[suitable_bins_mask] = 1.0 / np.sum(suitable_bins_mask)\n        else:\n            # Exploit: The current priorities already favor the best fit.\n            # We can optionally normalize priorities so they sum to 1 for suitable bins,\n            # but it's not strictly necessary if we just pick the max.\n            # For this function returning scores, leaving them as is is fine,\n            # as higher score implies higher preference.\n            pass\n    else:\n        # If no bin can fit the item, all priorities remain 0.\n        # In a real online BPP solver, this would typically trigger the creation of a new bin.\n        pass\n\n    return priorities\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using a Best Fit strategy.\n\n    The Best Fit strategy aims to place the item into the bin where it fits most snugly,\n    leaving the least remaining capacity. This heuristic prioritizes bins that have the\n    smallest non-negative residual capacity after placing the item.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        A higher priority score indicates a better fit.\n    \"\"\"\n    # Initialize priorities to a very low value for bins that cannot fit the item.\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    # Identify bins where the item can fit.\n    can_fit_mask = bins_remain_cap >= item\n\n    # For bins that can fit the item, calculate the residual capacity after placement.\n    # The residual capacity is `bins_remain_cap[i] - item`.\n    # We want to prioritize bins with the smallest *positive* residual.\n    # A smaller residual means a \"tighter\" fit.\n    # To ensure higher priority for tighter fits, we can use the negative of the residual.\n    # For example:\n    # If residual is 0 (perfect fit), priority is 0.\n    # If residual is 1, priority is -1.\n    # If residual is 5, priority is -5.\n    # This way, 0 is the highest priority, followed by -1, then -5, etc.\n    residual_capacities = bins_remain_cap[can_fit_mask] - item\n\n    # Assign priorities to the bins that can fit the item.\n    # The priority is the negative of the residual capacity.\n    priorities[can_fit_mask] = -residual_capacities\n\n    return priorities\n\n[Reflection]\nPrioritize exact fits and minimize positive residual capacity for better BPP heuristics.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}