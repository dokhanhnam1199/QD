```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using inverse distance strategy.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # We want to prioritize bins that are a "closer fit" for the item.
    # This means bins where the remaining capacity is just enough to fit the item,
    # or slightly larger.
    # A simple way to represent this is to take the difference between the
    # bin's remaining capacity and the item's size. We want this difference to be small and non-negative.

    # Calculate the difference between remaining capacity and item size.
    # If the item doesn't fit, the difference will be negative.
    differences = bins_remain_cap - item

    # We only want to consider bins where the item actually fits.
    # For bins where the item doesn't fit, we assign a very low priority (e.g., 0 or negative infinity).
    # For bins where the item fits, we want to prioritize those with the smallest non-negative difference.
    # The inverse distance strategy suggests giving higher priority to items that are "closer".
    # So, a smaller positive difference should result in a higher priority.

    # We can use the inverse of the difference, but we need to handle the case where the difference is zero
    # and avoid division by zero. Also, we want to ensure that negative differences (item doesn't fit)
    # get a very low priority.

    # Let's create priorities based on the differences:
    # - If an item doesn't fit (difference < 0), priority is 0.
    # - If an item fits perfectly (difference == 0), priority is very high (e.g., a large positive number).
    # - If an item fits with some space left (difference > 0), priority is inversely proportional to the difference.
    #   To avoid division by zero and to ensure smaller positive differences get higher priority, we can use
    #   1 / (difference + epsilon) where epsilon is a small constant.

    epsilon = 1e-6  # A small constant to avoid division by zero

    # Initialize priorities to a very low value (or 0) for bins that cannot fit the item.
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Find bins where the item fits
    can_fit_mask = bins_remain_cap >= item

    # For bins where the item fits:
    # Calculate the "closeness" of the fit. We want smaller positive differences to have higher priority.
    # A simple inverse distance can be 1 / (difference + epsilon).
    # For perfect fits (difference == 0), this will be 1/epsilon, which is large.
    # For small positive differences, it will be slightly smaller but still large.
    # For larger positive differences, it will be smaller.
    fitting_differences = differences[can_fit_mask]
    priorities[can_fit_mask] = 1.0 / (fitting_differences + epsilon)

    # Ensure that bins where the item doesn't fit have the lowest priority.
    # By initializing with zeros, we've already achieved this.

    return priorities
```
