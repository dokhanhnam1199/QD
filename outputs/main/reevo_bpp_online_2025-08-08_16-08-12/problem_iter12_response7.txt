```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This heuristic prioritizes bins that can accommodate the item. Among those
    that fit, it assigns a higher priority to bins that will have less remaining
    capacity after the item is placed, aiming for tighter packing. Exact fits
    (zero remaining capacity) are given a significantly higher priority than
    near fits. For near fits, a scaled softmax is applied to the inverse
    remaining capacity, where the scaling factor is a tunable hyperparameter
    (e.g., 10.0) to control the emphasis on tighter packing.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins that can accommodate the item
    can_fit_mask = bins_remain_cap >= item

    if not np.any(can_fit_mask):
        return priorities  # No bins can fit the item

    fitting_bins_remain_cap = bins_remain_cap[can_fit_mask]

    # Calculate the remaining capacity if the item is placed in a fitting bin
    remaining_after_placement = fitting_bins_remain_cap - item

    # Define a high priority for exact fits
    exact_fit_priority = 1.0
    # Define a scaling factor for near fits to emphasize tighter packing
    near_fit_scale_factor = 10.0

    # Calculate scores for bins that can fit the item
    scores = np.zeros_like(fitting_bins_remain_cap, dtype=float)

    # Identify exact fits
    exact_fit_mask = np.isclose(remaining_after_placement, 0.0)
    scores[exact_fit_mask] = exact_fit_priority

    # For near fits, use scaled softmax on the inverse remaining capacity
    near_fit_mask = ~exact_fit_mask
    if np.any(near_fit_mask):
        near_fit_remaining = remaining_after_placement[near_fit_mask]
        # Inverse remaining capacity, higher value for smaller remaining capacity.
        # Add a small epsilon to avoid division by zero.
        inverse_remaining = 1.0 / (near_fit_remaining + 1e-9)

        # Apply scaling and then softmax to amplify preference for tighter fits
        scaled_inverse = near_fit_scale_factor * inverse_remaining
        exp_scaled_inverse = np.exp(scaled_inverse)

        # Normalize the scores using softmax. This converts them into a probability-like
        # distribution, ensuring that bins with higher scaled inverse remaining capacity
        # (i.e., tighter fits) get proportionally higher scores.
        softmax_scores = exp_scaled_inverse / np.sum(exp_scaled_inverse)

        # Assign these softmax scores to the near-fitting bins
        scores[near_fit_mask] = softmax_scores

    # Distribute the calculated scores to the original priority array
    priorities[can_fit_mask] = scores

    return priorities
```
