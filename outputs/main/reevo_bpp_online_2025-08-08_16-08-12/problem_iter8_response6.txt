```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Prioritizes bins for the online Bin Packing Problem using a Best Fit strategy
    with a temperature-controlled exploration component.

    This heuristic prioritizes bins that can fit the item. Among fitting bins,
    it assigns a higher priority to those that leave less remaining capacity
    after the item is placed (Best Fit). To balance exploitation (tight fits)
    with exploration, it uses an exponential function of the negative remaining
    capacity, scaled by a temperature parameter. A higher temperature leads to
    smoother priority distributions, increasing the chance of selecting bins
    that are not the absolute best fit.

    Args:
        item: The size of the item to be packed.
        bins_remain_cap: A numpy array containing the remaining capacity of each bin.

    Returns:
        A numpy array of the same size as bins_remain_cap, where each element
        represents the priority score for placing the item in the corresponding bin.
        Bins that cannot fit the item will have a priority of 0.
    """
    # Temperature parameter to control the exploration/exploitation trade-off.
    # A higher temperature leads to flatter probabilities (more exploration),
    # while a lower temperature leads to sharper probabilities (more exploitation).
    # We aim for a balance, let's set temperature to a moderate value like 0.5 or 1.0.
    temperature = 0.75

    num_bins = len(bins_remain_cap)
    priorities = np.zeros(num_bins, dtype=float)

    # Identify bins that have enough capacity to fit the item.
    can_fit_mask = bins_remain_cap >= item

    # If no bins can fit the item, return all zeros.
    if not np.any(can_fit_mask):
        return priorities

    # Calculate the remaining capacity for bins that can fit the item.
    # Lower values here are better (tighter fits).
    remaining_capacities_after_fit = bins_remain_cap[can_fit_mask] - item

    # We want higher priority for bins with smaller remaining capacity.
    # A common way to achieve this with exploration is using an exponential function:
    # priority_score = exp(f(remaining_capacity))
    # where f should be decreasing with remaining_capacity.
    # A simple choice for f is -remaining_capacity / temperature.
    # This way, smaller remaining_capacity leads to a less negative exponent,
    # thus a higher exponential value (priority).
    # Using `remaining_capacities_after_fit` directly as the "cost".
    # The "value" of a bin is inversely related to this cost.
    # So, we use `exp(-cost / temperature)`.

    # Calculate the raw "fitness" score for fitting bins.
    # We add a small epsilon to the denominator in case remaining_capacities_after_fit is 0
    # to avoid division by zero in some formulations, though exp(-x) handles 0 fine.
    # Using -remaining_capacities_after_fit directly for the exponent argument is cleaner.
    
    # The score is higher for smaller `remaining_capacities_after_fit`.
    # Let's use `score = -remaining_capacities_after_fit`. Higher score is better.
    # For exploration, we can use `exp(score / temperature)`.
    # This will give higher priorities to tighter fits but also assign non-zero
    # priorities to bins with slightly more slack, governed by the temperature.
    
    fitness_scores = -remaining_capacities_after_fit / temperature
    priorities[can_fit_mask] = np.exp(fitness_scores)

    # Ensure that priorities for bins that cannot fit remain 0.
    # This is already handled by the initialization and mask.

    return priorities
```
