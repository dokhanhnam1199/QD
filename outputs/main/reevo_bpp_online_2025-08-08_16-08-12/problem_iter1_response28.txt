```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Epsilon-Greedy.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    epsilon = 0.1  # Exploration probability
    num_bins = len(bins_remain_cap)
    priorities = np.zeros(num_bins)

    # Greedy choice: Prioritize bins that can fit the item and have least remaining capacity (Best Fit)
    # Calculate "greediness" for each bin
    greedy_scores = np.zeros(num_bins)
    # A bin can fit if its remaining capacity is greater than or equal to the item size
    can_fit_mask = bins_remain_cap >= item
    
    # Calculate the difference between bin capacity and item size. Smaller difference is better (less wasted space).
    # Add a small epsilon to avoid division by zero if item is exactly the remaining capacity
    difference = bins_remain_cap - item + 1e-9
    
    # Calculate a "best fit" score: smaller difference means higher score.
    # We use the inverse of the difference. We also want to consider only bins that can fit.
    # Initialize with a very low score for bins that cannot fit.
    greedy_scores[can_fit_mask] = 1.0 / difference[can_fit_mask]
    greedy_scores[~can_fit_mask] = -np.inf  # Ensure bins that don't fit get a very low priority

    # Epsilon-Greedy strategy
    # With probability epsilon, explore (choose a random bin that can fit)
    # With probability 1-epsilon, exploit (choose the bin with the highest greedy score)
    
    indices_that_can_fit = np.where(can_fit_mask)[0]
    
    if len(indices_that_can_fit) > 0:
        if np.random.rand() < epsilon:
            # Explore: choose a random bin that can fit
            random_bin_index = np.random.choice(indices_that_can_fit)
            priorities[random_bin_index] = 1.0
        else:
            # Exploit: choose the bin with the highest greedy score
            best_bin_index = np.argmax(greedy_scores)
            priorities[best_bin_index] = 1.0
    else:
        # If no bin can fit the item, this strategy won't place it.
        # In a real online scenario, a new bin would be opened.
        # For this priority function, we return all zeros, indicating no suitable bin.
        pass 

    return priorities
```
