```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Prioritizes bins for the online Bin Packing Problem with refined strategies.

    This heuristic categorizes bins into:
    1. Exact Fits: Bins where the item perfectly fills the remaining capacity.
    2. Tight Fits: Bins where the item fits, and the remaining capacity after placement
       is small (defined by a threshold). These are prioritized using a scaled
       inverse of the remaining capacity to aggressively favor bins with little slack.
    3. Loose Fits: Bins where the item fits, but the remaining capacity after
       placement is not considered "tight". These receive a lower positive priority.
    4. Unfittable: Bins where the item cannot fit. These receive negative infinity priority.

    Args:
        item: The size of the item to be packed.
        bins_remain_cap: A numpy array containing the remaining capacity of each bin.

    Returns:
        A numpy array of the same size as bins_remain_cap, where each element
        represents the priority score for placing the item in the corresponding bin.
    """
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # --- Configuration Parameters ---
    # High priority for exact fits to ensure they are always chosen if available.
    EXACT_FIT_PRIORITY = 100.0
    # Base score for tight fits, ensuring they are preferred over loose fits.
    TIGHT_FIT_BASE_SCORE = 50.0
    # Scaling factor for tight fits to amplify the difference based on remaining capacity.
    TIGHT_FIT_SCALE = 40.0
    # Priority for bins that fit but are not considered "tight".
    LOOSE_FIT_PRIORITY = 1.0
    # Threshold to define what constitutes a "tight fit".
    # Using a relative threshold combined with an absolute minimum for robustness.
    TIGHT_FIT_THRESHOLD_RELATIVE = 0.10  # e.g., remaining capacity < 10% of item size
    TIGHT_FIT_THRESHOLD_ABSOLUTE = 3.0   # e.g., remaining capacity < 3.0 units

    epsilon_small = 1e-9 # Small value to prevent division by zero or near-zero.

    # --- Identify Bin Categories ---
    can_fit_mask = bins_remain_cap >= item

    if not np.any(can_fit_mask):
        return priorities  # No bin can fit the item

    # 1. Exact Fits
    # Use a small tolerance to account for potential floating-point inaccuracies.
    exact_fit_mask = can_fit_mask & (np.abs(bins_remain_cap - item) < epsilon_small)
    priorities[exact_fit_mask] = EXACT_FIT_PRIORITY

    # Identify bins that can fit but are not exact fits.
    general_fitting_mask = can_fit_mask & ~exact_fit_mask

    if np.any(general_fitting_mask):
        fitting_bin_indices = np.where(general_fitting_mask)[0]
        remaining_capacities_after_placement = bins_remain_cap[fitting_bin_indices] - item

        # 2. Tight Fits
        # Criteria for tight fit: remaining capacity is small relative to the item size,
        # or below a small absolute threshold.
        tight_fit_criteria = (remaining_capacities_after_placement < TIGHT_FIT_THRESHOLD_ABSOLUTE) | \
                             (remaining_capacities_after_placement < item * TIGHT_FIT_THRESHOLD_RELATIVE)
        
        tight_fit_indices_subset = fitting_bin_indices[tight_fit_criteria]
        loose_fit_indices_subset = fitting_bin_indices[~tight_fit_criteria]

        # Process Tight Fits: Prioritize more strongly those with less remaining capacity.
        if len(tight_fit_indices_subset) > 0:
            tight_fit_remaining_caps = remaining_capacities_after_placement[tight_fit_criteria]

            # Stable inverse scaling: higher score for smaller remaining capacity.
            # Add epsilon to avoid division by zero, and scale aggressively.
            tight_fit_scores = 1.0 / (tight_fit_remaining_caps + epsilon_small)
            
            # Scale scores to a desirable range. The scaling is more direct than softmax,
            # providing a clear preference based on the amount of remaining capacity.
            # Higher inverse capacity (smaller remaining space) leads to higher scores.
            scaled_tight_fit_priorities = TIGHT_FIT_BASE_SCORE + tight_fit_scores * TIGHT_FIT_SCALE
            priorities[tight_fit_indices_subset] = scaled_tight_fit_priorities

        # 3. Loose Fits
        # Bins that fit but are not tight fits.
        if len(loose_fit_indices_subset) > 0:
            priorities[loose_fit_indices_subset] = LOOSE_FIT_PRIORITY
            
    return priorities
```
