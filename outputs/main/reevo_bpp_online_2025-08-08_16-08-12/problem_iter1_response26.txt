```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Sigmoid Fit Score.

    The Sigmoid Fit Score strategy prioritizes bins based on how well an item fits.
    It uses a sigmoid function to map the remaining capacity relative to the item size
    to a priority score. Bins with remaining capacity slightly larger than the item
    size (meaning a tight fit) receive higher priority.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Avoid division by zero or negative capacities
    valid_bins_mask = bins_remain_cap >= item
    
    # Calculate the 'fit' for each valid bin. A smaller value indicates a tighter fit.
    # The "fit" is defined as the remaining capacity minus the item size.
    # We want to prioritize bins where (bins_remain_cap - item) is close to 0.
    fit_values = bins_remain_cap[valid_bins_mask] - item
    
    # Use a sigmoid-like function to transform the fit values into priorities.
    # The idea is to give higher priority to bins where the remaining capacity
    # is just enough for the item.
    # We can center the sigmoid around 0, so a fit_value of 0 (perfect fit) gets a high score.
    # The scaling factor (e.g., 1.0 or adjusted) controls the steepness of the sigmoid.
    # A positive steepness makes smaller fit values (tighter fits) get higher scores.
    
    # Normalize fit values to be within a reasonable range for the sigmoid,
    # or simply use the fit values directly if the sigmoid can handle it.
    # Here, we'll use the fit values directly and ensure the sigmoid maps
    # smaller (better) fits to higher scores.
    
    # Using a shifted and scaled sigmoid:
    # The goal is to have a higher score when (bin_capacity - item) is small.
    # If bin_capacity - item = 0 (perfect fit), we want a high score.
    # If bin_capacity - item > 0 (loose fit), we want a lower score.
    # If bin_capacity - item < 0 (no fit), we want a very low score (handled by valid_bins_mask).
    
    # Let's define a transformation `t(fit) = -k * fit`, where k > 0.
    # Then apply sigmoid: 1 / (1 + exp(-t(fit))) = 1 / (1 + exp(k * fit))
    # This function gives 0.5 at fit=0 and decreases as fit increases.
    # This is the opposite of what we want (higher priority for smaller fits).
    
    # Alternative transformation: `t(fit) = k * (item - bin_capacity)` which is `-k * fit`.
    # Let's re-think. We want high priority when `bin_capacity` is just above `item`.
    # This means `bin_capacity - item` should be small and positive.
    
    # Consider a function `f(x) = 1 / (1 + exp(-slope * (x - center)))`.
    # If x is the remaining capacity, and we want high priority when x is close to item:
    # Let's transform x into a measure of "how good is the fit".
    # Good fit = small `bins_remain_cap - item`
    
    # Let's try mapping `(bins_remain_cap - item)` to a score where small positive values are high.
    # Using the sigmoid function's property that `1/(1+e^-x)` increases with x.
    # We need to transform `bins_remain_cap - item` such that smaller values lead to larger sigmoid inputs.
    # Let the input to sigmoid be `- (bins_remain_cap - item) * steepness`.
    # The steepness controls how quickly the priority drops as the fit gets looser.
    
    steepness = 2.0  # Controls how sharp the transition is. Higher means sharper.
    
    # Calculate scores for valid bins.
    # `-(fit_values)` means tighter fits get larger (more positive) inputs to sigmoid.
    scores = 1.0 / (1.0 + np.exp(steepness * fit_values))
    
    # Initialize a full-sized array for priorities.
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    # Place the calculated scores into the correct positions.
    priorities[valid_bins_mask] = scores
    
    return priorities
```
