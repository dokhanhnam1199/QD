```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using a Best Fit strategy.

    The Best Fit strategy aims to place the item into the bin where it fits most snugly,
    leaving the least remaining capacity. This heuristic prioritizes bins that have the
    smallest non-negative residual capacity after placing the item.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
        A higher priority score indicates a better fit.
    """
    # Initialize priorities to a very low value for bins that cannot fit the item.
    priorities = np.full_like(bins_remain_cap, -np.inf)

    # Identify bins where the item can fit.
    can_fit_mask = bins_remain_cap >= item

    # For bins that can fit the item, calculate the residual capacity after placement.
    # The residual capacity is `bins_remain_cap[i] - item`.
    # We want to prioritize bins with the smallest *positive* residual.
    # A smaller residual means a "tighter" fit.
    # To ensure higher priority for tighter fits, we can use the negative of the residual.
    # For example:
    # If residual is 0 (perfect fit), priority is 0.
    # If residual is 1, priority is -1.
    # If residual is 5, priority is -5.
    # This way, 0 is the highest priority, followed by -1, then -5, etc.
    residual_capacities = bins_remain_cap[can_fit_mask] - item

    # Assign priorities to the bins that can fit the item.
    # The priority is the negative of the residual capacity.
    priorities[can_fit_mask] = -residual_capacities

    return priorities
```
