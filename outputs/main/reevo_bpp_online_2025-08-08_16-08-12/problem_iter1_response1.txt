```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Best Fit strategy.

    The Best Fit strategy aims to place the item in the bin that has the smallest
    remaining capacity but can still accommodate the item. This minimizes wasted
    space.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
        Bins that cannot fit the item will have a priority of 0.
        Bins that can fit the item will have a priority inversely proportional
        to their remaining capacity (smaller remaining capacity gets higher priority).
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Find bins that can accommodate the item
    can_fit_mask = bins_remain_cap >= item

    # For bins that can fit the item, calculate priority
    # Priority is higher for bins with less remaining capacity
    # This is achieved by taking the inverse of the remaining capacity.
    # To avoid division by zero if remaining capacity is exactly the item size,
    # we add a small epsilon or use a value that ensures larger remaining capacity
    # results in lower priority. A simple inverse (1/capacity) works well here
    # because we are looking for the *smallest* remaining capacity.
    fitting_bins_remain_cap = bins_remain_cap[can_fit_mask]

    # Assign priorities: smaller remaining capacity gets a higher priority
    # The priority is 1 / (remaining_capacity - item_size + 1)
    # Adding 1 to the denominator ensures that if remaining_capacity == item_size,
    # the priority is 1, and if remaining_capacity is slightly larger, it's still high.
    # A very large remaining capacity will result in a priority close to 0.
    priorities[can_fit_mask] = 1.0 / (fitting_bins_remain_cap - item + 1.0)

    return priorities
```
