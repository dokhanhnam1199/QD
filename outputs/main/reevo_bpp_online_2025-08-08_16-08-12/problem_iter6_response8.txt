```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Returns priority with which we want to add item to each bin, prioritizing
    minimal slack after placement while also slightly penalizing bins that
    would become exactly full. This version aims to balance the greedy approach
    of minimizing slack with a touch of exploration by slightly boosting bins
    that are not the absolute best fit but still good candidates.

    This heuristic prioritizes bins that can fit the item. Among those that fit,
    it assigns a higher priority to bins that will have less remaining capacity
    after the item is placed (minimal slack). This encourages denser packing.
    A slight penalty is applied to bins that would become completely full,
    encouraging leaving some space for potentially larger items. To introduce
    a mild exploratory element, bins that result in a slightly larger, but still
    good, remainder are given a small boost to avoid over-optimization on just
    the smallest slack.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Returns:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins that can accommodate the item
    can_fit_mask = bins_remain_cap >= item

    # If no bin can fit the item, return all zeros
    if not np.any(can_fit_mask):
        return priorities

    # Calculate the remaining capacity if the item is placed in a fitting bin
    remaining_after_placement = bins_remain_cap[can_fit_mask] - item

    # Base priority: prioritize bins with minimal slack.
    # Higher score for smaller remainders. Add epsilon for numerical stability.
    base_priorities = 1.0 / (remaining_after_placement + 1e-9)

    # Introduce a penalty for bins that would become exactly full.
    # Subtract a small value to slightly reduce their priority.
    penalty_for_full = 0.1
    fully_filled_mask = (remaining_after_placement == 0)
    priorities[can_fit_mask] = base_priorities
    priorities[can_fit_mask][fully_filled_mask] -= penalty_for_full

    # Add a small exploratory boost: slightly favor bins that have a small positive remainder,
    # but not necessarily the absolute minimum. This can be achieved by adding a small
    # positive value to the priority score for a range of remainders.
    # For example, we can add a small constant to priorities where the remainder is small but not zero.
    # We can define a threshold for "small positive remainder". Let's say up to 10% of bin capacity,
    # but this is problem-dependent. For a general heuristic, let's add a small constant to
    # all positive remainders (that are not exactly zero) as a slight encouragement.
    # We can make this boost decay as the remainder increases.
    # For simplicity here, let's add a constant boost to all non-exact fits.
    # This is a very simple form of exploration.
    exploratory_boost_value = 0.05
    not_fully_filled_mask = ~fully_filled_mask
    priorities[can_fit_mask][not_fully_filled_mask] += exploratory_boost_value

    # Ensure all priorities are non-negative.
    priorities = np.clip(priorities, 0, None)

    return priorities
```
