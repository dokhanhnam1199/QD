```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using a Best Fit strategy with explicit prioritization of exact fits.

    This heuristic prioritizes bins that can fit the item. Among those that fit,
    it first gives the highest priority to exact fits. For bins that are not
    exact fits but can accommodate the item, it assigns priority based on
    how much remaining capacity is left, favoring smaller remaining capacities.
    This strategy is a greedy approach aiming to fill bins as much as possible
    while also rewarding perfect fits.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.full_like(bins_remain_cap, -np.inf)

    # Identify bins that can accommodate the item.
    can_fit_mask = bins_remain_cap >= item

    if not np.any(can_fit_mask):
        return priorities  # No bin can fit the item

    # Calculate remaining capacity if item is placed
    fitting_bins_remain_cap = bins_remain_cap[can_fit_mask]
    remaining_after_placement = fitting_bins_remain_cap - item

    # Assign highest priority to exact fits
    exact_fit_mask_subset = (remaining_after_placement == 0)
    priorities[can_fit_mask][exact_fit_mask_subset] = 100.0  # High priority for exact fits

    # For bins that fit but are not exact fits, prioritize those with less remaining capacity.
    # A higher score means less remaining capacity after placement.
    non_exact_fit_indices_subset = np.where(~exact_fit_mask_subset)[0]

    if non_exact_fit_indices_subset.size > 0:
        non_exact_fitting_bins_remain_cap = fitting_bins_remain_cap[~exact_fit_mask_subset]
        non_exact_remaining_after_placement = non_exact_fitting_bins_remain_cap - item

        # Prioritize smaller remaining capacities. Use inverse for higher score.
        # Add a small epsilon to avoid division by zero if remaining capacity is very close to zero.
        fit_scores_for_non_exact = 1.0 / (non_exact_remaining_after_placement + 1e-9)

        # Scale these priorities to be lower than exact fits but still positive.
        # The maximum possible value of fit_scores_for_non_exact depends on the
        # minimum non-zero remaining capacity. We can normalize or use a fixed
        # scaling to ensure they are below the exact fit priority.
        # A simple approach is to scale by a factor that ensures they are less than 100.
        # For example, if the minimum remaining capacity for non-exact fits is `min_rem_non_exact`,
        # the max score is `1 / (min_rem_non_exact + epsilon)`.
        # We can scale this by `99.0 / max(fit_scores_for_non_exact)` to bound them
        # between 0 and 99.
        max_score_non_exact = np.max(fit_scores_for_non_exact)
        if max_score_non_exact > 0:
            scaled_priorities = (fit_scores_for_non_exact / max_score_non_exact) * 99.0
            priorities[can_fit_mask][~exact_fit_mask_subset] = scaled_priorities
        else: # This case implies all non-exact fits have remaining capacity close to 0, which shouldn't happen if they are not exact fits.
            priorities[can_fit_mask][~exact_fit_mask_subset] = 99.0 # Assign a high non-exact priority

    return priorities
```
