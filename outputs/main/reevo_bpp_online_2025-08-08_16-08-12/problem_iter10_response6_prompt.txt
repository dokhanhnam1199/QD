{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Returns priority with which we want to add item to each bin using a\n    First Fit strategy with an emphasis on exact fits and minimal slack,\n    and incorporates a softmax-like scaling for exploration.\n\n    This heuristic prioritizes bins that can fit the item. Among those that fit,\n    it assigns a higher priority to bins that result in an exact fit (zero remaining capacity)\n    and then to bins with minimal positive remaining capacity. A scaling factor (temperature)\n    is applied to the inverse of the slack to control exploration. Bins that cannot fit\n    the item are given a priority of zero.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    temperature = 1.0  # Tunable parameter for exploration\n\n    # Identify bins that can accommodate the item\n    can_fit_mask = bins_remain_cap >= item\n\n    # Calculate the slack (remaining capacity after placement) for fitting bins\n    slack = bins_remain_cap[can_fit_mask] - item\n\n    # Assign priorities:\n    # - Highest priority for exact fits (slack == 0)\n    # - High priority for minimal positive slack, inversely proportional to slack\n    #   scaled by temperature for exploration.\n    # - Zero priority for bins that cannot fit the item.\n\n    # Handle exact fits separately to give them maximum priority\n    exact_fit_mask = slack == 0\n    priorities[can_fit_mask][exact_fit_mask] = 1e6  # A very high value for exact fits\n\n    # Calculate priorities for bins with positive slack\n    positive_slack_mask = slack > 0\n    positive_slack_values = slack[positive_slack_mask]\n\n    # Inverse slack scaled by temperature. Higher priority for smaller slack.\n    # Add epsilon to avoid division by zero if slack is very close to zero but not exactly zero.\n    scaled_priorities = 1.0 / (positive_slack_values + 1e-9)\n    priorities[can_fit_mask][positive_slack_mask] = np.exp(scaled_priorities / temperature)\n\n\n    # Normalize priorities to be between 0 and 1 (optional, but good practice for some selection methods)\n    # If no bins can fit the item, max_priority will be 0, so division by zero is avoided.\n    max_priority = np.max(priorities)\n    if max_priority > 0:\n        priorities /= max_priority\n\n    return priorities\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Prioritizes bins for the online Bin Packing Problem using a Best Fit strategy\n    with a temperature-controlled exploration component.\n\n    This heuristic prioritizes bins that can fit the item. Among fitting bins,\n    it assigns a higher priority to those that leave less remaining capacity\n    after the item is placed (Best Fit). To balance exploitation (tight fits)\n    with exploration, it uses an exponential function of the negative remaining\n    capacity, scaled by a temperature parameter. A higher temperature leads to\n    smoother priority distributions, increasing the chance of selecting bins\n    that are not the absolute best fit.\n\n    Args:\n        item: The size of the item to be packed.\n        bins_remain_cap: A numpy array containing the remaining capacity of each bin.\n\n    Returns:\n        A numpy array of the same size as bins_remain_cap, where each element\n        represents the priority score for placing the item in the corresponding bin.\n        Bins that cannot fit the item will have a priority of 0.\n    \"\"\"\n    # Temperature parameter to control the exploration/exploitation trade-off.\n    # A higher temperature leads to flatter probabilities (more exploration),\n    # while a lower temperature leads to sharper probabilities (more exploitation).\n    # We aim for a balance, let's set temperature to a moderate value like 0.5 or 1.0.\n    temperature = 0.75\n\n    num_bins = len(bins_remain_cap)\n    priorities = np.zeros(num_bins, dtype=float)\n\n    # Identify bins that have enough capacity to fit the item.\n    can_fit_mask = bins_remain_cap >= item\n\n    # If no bins can fit the item, return all zeros.\n    if not np.any(can_fit_mask):\n        return priorities\n\n    # Calculate the remaining capacity for bins that can fit the item.\n    # Lower values here are better (tighter fits).\n    remaining_capacities_after_fit = bins_remain_cap[can_fit_mask] - item\n\n    # We want higher priority for bins with smaller remaining capacity.\n    # A common way to achieve this with exploration is using an exponential function:\n    # priority_score = exp(f(remaining_capacity))\n    # where f should be decreasing with remaining_capacity.\n    # A simple choice for f is -remaining_capacity / temperature.\n    # This way, smaller remaining_capacity leads to a less negative exponent,\n    # thus a higher exponential value (priority).\n    # Using `remaining_capacities_after_fit` directly as the \"cost\".\n    # The \"value\" of a bin is inversely related to this cost.\n    # So, we use `exp(-cost / temperature)`.\n\n    # Calculate the raw \"fitness\" score for fitting bins.\n    # We add a small epsilon to the denominator in case remaining_capacities_after_fit is 0\n    # to avoid division by zero in some formulations, though exp(-x) handles 0 fine.\n    # Using -remaining_capacities_after_fit directly for the exponent argument is cleaner.\n    \n    # The score is higher for smaller `remaining_capacities_after_fit`.\n    # Let's use `score = -remaining_capacities_after_fit`. Higher score is better.\n    # For exploration, we can use `exp(score / temperature)`.\n    # This will give higher priorities to tighter fits but also assign non-zero\n    # priorities to bins with slightly more slack, governed by the temperature.\n    \n    fitness_scores = -remaining_capacities_after_fit / temperature\n    priorities[can_fit_mask] = np.exp(fitness_scores)\n\n    # Ensure that priorities for bins that cannot fit remain 0.\n    # This is already handled by the initialization and mask.\n\n    return priorities\n\n[Reflection]\nPrioritize exact fits, use temperature for exploration, and favor minimal slack.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}