```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Prioritizes bins for the online Bin Packing Problem using a refined strategy.
    This heuristic prioritizes exact fits, then uses a temperature-controlled
    softmax on the inverse of remaining capacity for near fits to encourage exploration
    while favoring bins with less remaining space.

    Args:
        item: The size of the item to be packed.
        bins_remain_cap: A numpy array containing the remaining capacity of each bin.

    Returns:
        A numpy array of the same size as bins_remain_cap, where each element
        represents the priority score for placing the item in the corresponding bin.
        Higher scores indicate higher priority. Bins that cannot fit the item
        will have a priority of -np.inf.
    """
    temperature = 0.5  # Tunable parameter for exploration. Lower = more greedy.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Identify bins that can accommodate the item.
    can_fit_mask = bins_remain_cap >= item
    fitting_bins_indices = np.where(can_fit_mask)[0]

    if not np.any(can_fit_mask):
        return priorities  # No bin can fit the item

    fitting_bins_remain_cap = bins_remain_cap[fitting_bins_indices]
    remaining_after_placement = fitting_bins_remain_cap - item

    # Assign a very high priority for exact fits.
    exact_fit_mask_subset = (remaining_after_placement == 0)
    exact_fit_indices_in_fitting = np.where(exact_fit_mask_subset)[0]
    exact_fit_original_indices = fitting_bins_indices[exact_fit_indices_in_fitting]
    priorities[exact_fit_original_indices] = 100.0

    # Handle near fits using a softmax on the inverse of remaining capacity.
    # This favors bins with less remaining capacity among the near fits.
    near_fit_mask_subset = ~exact_fit_mask_subset
    near_fit_indices_in_fitting = np.where(near_fit_mask_subset)[0]

    if np.any(near_fit_mask_subset):
        near_fit_remaining = remaining_after_placement[near_fit_indices_in_fitting]

        # Calculate scores for near fits: higher score for smaller remaining capacity.
        # Use inverse of remaining capacity to achieve this. Add epsilon for stability.
        epsilon_small = 1e-9
        near_fit_scores_for_softmax = 1.0 / (near_fit_remaining + epsilon_small)

        # Apply softmax for exploration. Higher scores (smaller remaining capacity) get higher probabilities.
        # Ensure numerical stability for exp by shifting scores.
        if near_fit_scores_for_softmax.size > 0:
            # Shift scores so the maximum is 0 for numerical stability with exp.
            max_score = np.max(near_fit_scores_for_softmax)
            shifted_scores = near_fit_scores_for_softmax - max_score
            
            # Handle the case where all shifted_scores might be -inf (e.g., if all near_fit_scores_for_softmax were identical and very small)
            if np.all(np.isneginf(shifted_scores)):
                exp_scores = np.ones_like(shifted_scores)
            else:
                exp_scores = np.exp(shifted_scores / temperature)
            
            sum_exp_scores = np.sum(exp_scores)

            if sum_exp_scores > 0:
                softmax_probabilities = exp_scores / sum_exp_scores
            else:
                # Fallback to uniform if sum is zero (e.g., all exp_scores were 0)
                softmax_probabilities = np.ones_like(exp_scores) / len(exp_scores)

            # Scale these probabilities to a range that is lower than exact fits,
            # but reflects the relative preference. A range like [50, 99.9] would be suitable.
            # Higher softmax probability (from smaller remaining capacity) results in a higher score.
            # Scale to [50, 99.9] to ensure they are less than exact fits (100) and greater than default.
            scaled_near_fit_priorities = 50.0 + softmax_probabilities * 49.9
            
            near_fit_original_indices = fitting_bins_indices[near_fit_indices_in_fitting]
            priorities[near_fit_original_indices] = scaled_near_fit_priorities

    # Assign a minimal positive priority to any fitting bin that might not have received a score
    # (e.g., if there were fitting bins but no exact or near fits, which shouldn't happen with current logic,
    # but as a safeguard). This ensures they are considered over not-fitting bins.
    # The value 1.0 is arbitrary and very low compared to the others.
    default_low_priority = 1.0
    unassigned_fitting_bins_mask = can_fit_mask & (priorities == -np.inf)
    priorities[unassigned_fitting_bins_mask] = default_low_priority

    return priorities
```
