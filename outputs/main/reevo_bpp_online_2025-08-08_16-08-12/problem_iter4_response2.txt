```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Returns priority with which we want to add item to each bin, prioritizing
    minimal slack after placement while also slightly penalizing bins that
    would become exactly full to maintain flexibility.

    This heuristic prioritizes bins that can fit the item. Among those that fit,
    it assigns a higher priority to bins that will have less remaining capacity
    after the item is placed (minimal slack). This encourages denser packing.
    Additionally, it slightly penalizes bins that would become completely full
    to encourage leaving some space for potentially larger items that might
    arrive later, promoting a balance between filling bins and maintaining flexibility.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Returns:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins that can accommodate the item
    can_fit_mask = bins_remain_cap >= item

    # If no bin can fit the item, return all zeros
    if not np.any(can_fit_mask):
        return priorities

    # Calculate the remaining capacity if the item is placed in a fitting bin
    remaining_after_placement = bins_remain_cap[can_fit_mask] - item

    # Assign higher priority to bins that will have less remaining capacity (minimal slack)
    # We invert the remaining capacity so that smaller remaining capacity gets higher priority.
    # Add a small epsilon to avoid division by zero and to ensure that bins with zero remaining
    # capacity after placement are still prioritized highest among the minimal slack options.
    priorities[can_fit_mask] = 1.0 / (remaining_after_placement + 1e-9)

    # Introduce a slight penalty for bins that would become exactly full after placement.
    # This encourages keeping some space for potentially larger future items.
    # The penalty is a small constant subtracted from the priority.
    # We apply this penalty only to the bins that are *exactly* filled.
    fully_filled_mask = (remaining_after_placement == 0)
    priorities[can_fit_mask][fully_filled_mask] -= 0.1

    # Ensure all priorities are non-negative. If the penalty makes a priority negative,
    # it should be capped at 0, as a negative priority doesn't make logical sense in this context.
    priorities = np.clip(priorities, 0, None)

    return priorities
```
