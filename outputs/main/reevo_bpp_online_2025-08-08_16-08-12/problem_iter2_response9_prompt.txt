{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin using Exact Fit First strategy.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Exact Fit First prioritizes bins where the item fits exactly.\n    # We assign a high priority to bins where remaining capacity minus item size is 0.\n    # For other bins, the priority is lower.\n\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    # Find bins where the item fits exactly\n    exact_fit_mask = (bins_remain_cap - item) == 0\n    \n    # Assign a high priority to exact fit bins\n    priorities[exact_fit_mask] = 100  # A large value to indicate highest priority\n    \n    # For bins where the item fits but not exactly, assign a moderate priority.\n    # This can be the remaining capacity itself, so smaller remaining capacities get higher priority\n    # among non-exact fits, favoring fuller bins.\n    valid_fit_mask = bins_remain_cap >= item\n    priorities[valid_fit_mask & ~exact_fit_mask] = bins_remain_cap[valid_fit_mask & ~exact_fit_mask]\n\n    # Bins where the item doesn't fit get a priority of 0 (already initialized)\n    \n    return priorities\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin using an Epsilon-Greedy strategy.\n\n    The strategy aims to balance exploration (trying less optimal but potentially good bins)\n    and exploitation (choosing the best available bin).\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    epsilon = 0.1  # Probability of exploration\n    num_bins = len(bins_remain_cap)\n\n    # Calculate the \"greediness\" of each bin: how well it fits the item.\n    # We want bins that are a good fit but not so tight that they become unusable\n    # for future items. A good fit leaves a small remainder.\n    # If an item doesn't fit, its \"greediness\" is set to a very low value (e.g., -inf)\n    # to effectively disqualify it.\n\n    # Calculate potential remainders if the item fits\n    potential_remainders = bins_remain_cap - item\n\n    # Identify bins where the item can fit\n    fitting_bins_mask = potential_remainders >= 0\n\n    # For bins where the item fits, calculate a score. A good score is one\n    # where the remainder is small but positive. We can invert the remainder\n    # so that smaller remainders get higher scores. Adding a small constant\n    # ensures that even a perfect fit (zero remainder) gets a positive score.\n    # We use `np.inf` for bins that don't fit to ensure they are never selected by the greedy part.\n    greediness_scores = np.full_like(bins_remain_cap, -np.inf)\n    greediness_scores[fitting_bins_mask] = 1.0 / (potential_remainders[fitting_bins_mask] + 1e-9) # Adding epsilon for stability, small remainder is good\n\n    # Normalize greediness scores to be between 0 and 1 for easier combination with epsilon\n    max_greediness = np.max(greediness_scores[fitting_bins_mask] if np.any(fitting_bins_mask) else [0])\n    if max_greediness > 0:\n        normalized_greediness = greediness_scores / max_greediness\n    else:\n        normalized_greediness = np.zeros_like(greediness_scores) # All bins might be too small\n\n    # Introduce exploration: with probability epsilon, pick a random bin among those that fit.\n    # With probability (1 - epsilon), pick the bin with the highest greediness score.\n\n    # Generate random scores for exploration\n    exploration_scores = np.random.rand(num_bins)\n\n    # Combine greediness and exploration\n    priorities = np.where(np.random.rand(num_bins) < epsilon,\n                          exploration_scores,\n                          normalized_greediness)\n\n    # Ensure that bins where the item doesn't fit have zero or negative priority\n    # (though the -np.inf in greediness_scores already handles this for the greedy part)\n    # The exploration part might pick a non-fitting bin if we're not careful.\n    # So, we explicitly set priorities to a very low value for non-fitting bins\n    # even during exploration to avoid invalid moves.\n    priorities[~fitting_bins_mask] = -np.inf\n\n    return priorities\n\n[Reflection]\nBalance exploitation (good fit) with exploration (trying other bins).\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}