```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using a Best Fit Decreasing strategy with a twist.

    This heuristic prioritizes bins that can fit the item. Among those that fit,
    it assigns a higher priority to bins that will have less remaining capacity
    after the item is placed (minimal slack). This encourages denser packing.
    Additionally, it slightly penalizes bins that would become completely full
    to encourage leaving some space for potentially larger items that might
    arrive later, promoting a balance between filling bins and maintaining flexibility.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins that can accommodate the item
    can_fit_mask = bins_remain_cap >= item

    # Calculate the remaining capacity if the item is placed in a fitting bin
    remaining_after_placement = bins_remain_cap[can_fit_mask] - item

    # Assign higher priority to bins that will have less remaining capacity (minimal slack)
    # We invert the remaining capacity so that smaller remaining capacity gets higher priority.
    # Add a small epsilon to avoid division by zero.
    priorities[can_fit_mask] = 1.0 / (remaining_after_placement + 1e-9)

    # Introduce a slight penalty for bins that become completely full after placement.
    # This encourages keeping some space for potentially larger future items.
    # A small value (e.g., 0.1) is subtracted from the priority of bins that would become exactly full.
    fully_filled_mask = (remaining_after_placement == 0)
    priorities[can_fit_mask][fully_filled_mask] -= 0.1

    return priorities
```
