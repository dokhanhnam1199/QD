```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Prioritizes bins for the online Bin Packing Problem, with enhanced strategies.

    This heuristic categorizes bins into:
    1. Exact Fits: Bins where the item perfectly fills the remaining capacity. These get the highest priority.
    2. Near Fits: Bins where the item fits, and the remaining capacity after placement
       is small (defined by a threshold). These are further prioritized using a
       temperature-controlled softmax on the inverse of the remaining capacity
       to balance exploitation (best near fit) and exploration (trying other near fits).
       The inverse remaining capacity is scaled aggressively but stably.
    3. General Fits: Bins where the item fits, but the remaining capacity after
       placement is not considered "near". These receive a low positive priority,
       allowing them to be used when no better fits are available.
    4. Unfittable: Bins where the item cannot fit. These receive negative infinity priority.

    Args:
        item: The size of the item to be packed.
        bins_remain_cap: A numpy array containing the remaining capacity of each bin.

    Returns:
        A numpy array of the same size as bins_remain_cap, where each element
        represents the priority score for placing the item in the corresponding bin.
    """
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # --- Configuration Parameters ---
    # Priority for exact fits, set high to ensure they are always chosen if available.
    EXACT_FIT_PRIORITY = 100.0
    # Base score for near fits before applying softmax, ensuring they are preferred over general fits.
    NEAR_FIT_BASE_SCORE = 50.0
    # Scaling factor for softmax probabilities to map them into a desirable range.
    NEAR_FIT_SCALE = 40.0
    # Priority for bins that fit but are not considered "near". This ensures they are usable.
    GENERAL_FIT_PRIORITY = 1.0
    # Threshold to define what constitutes a "near fit". A smaller value is stricter.
    # A combination of relative and absolute thresholds provides robustness.
    NEAR_FIT_THRESHOLD_RELATIVE = 0.15  # Remaining capacity < 15% of item size
    NEAR_FIT_THRESHOLD_ABSOLUTE = 5.0   # Remaining capacity < 5.0 units

    # Temperature for softmax to control exploration among near fits.
    # Higher temperature -> more exploration (priorities more uniform).
    # Lower temperature -> less exploration (priorities more skewed to best fits).
    TEMPERATURE = 0.7  # Tunable parameter

    epsilon_small = 1e-9  # Small value to prevent division by zero and for stable comparisons.

    # --- Identify Bin Categories ---
    # Mask for bins that can potentially fit the item.
    can_fit_mask = bins_remain_cap >= item

    if not np.any(can_fit_mask):
        return priorities  # No bin can fit the item, return all -inf.

    # 1. Exact Fits: Prioritize bins where remaining capacity perfectly matches the item size.
    # Using a small epsilon for floating point comparisons.
    exact_fit_mask = can_fit_mask & (np.abs(bins_remain_cap - item) < epsilon_small)
    priorities[exact_fit_mask] = EXACT_FIT_PRIORITY

    # Identify bins that can fit but are not exact fits.
    general_fitting_mask = can_fit_mask & ~exact_fit_mask

    if np.any(general_fitting_mask):
        fitting_bin_indices = np.where(general_fitting_mask)[0]
        # Calculate remaining capacity for these bins after placing the item.
        remaining_capacities_after_placement = bins_remain_cap[fitting_bin_indices] - item

        # 2. Near Fits: Identify bins where the remaining capacity is small.
        # This is defined by either being less than an absolute threshold or
        # a relative threshold based on the item size.
        near_fit_criteria = (remaining_capacities_after_placement < NEAR_FIT_THRESHOLD_ABSOLUTE) | \
                            (remaining_capacities_after_placement < item * NEAR_FIT_THRESHOLD_RELATIVE)
        
        near_fit_indices_subset = fitting_bin_indices[near_fit_criteria]
        non_near_fit_indices_subset = fitting_bin_indices[~near_fit_criteria]

        # Process Near Fits: Apply a temperature-controlled softmax to prioritize better fits.
        if len(near_fit_indices_subset) > 0:
            near_fit_remaining_caps = remaining_capacities_after_placement[near_fit_criteria]

            # Score for softmax: aggressively scale inverse remaining capacity.
            # A small epsilon is added to prevent division by zero and ensure stability.
            # The larger the remaining capacity, the smaller this score.
            near_fit_scores = 1.0 / (near_fit_remaining_caps + epsilon_small)

            # Apply softmax for exploration among near fits.
            # Softmax converts scores into probabilities that sum to 1.
            # Shifting scores before exponentiation improves numerical stability.
            if len(near_fit_scores) > 0:
                max_score = np.max(near_fit_scores)
                shifted_scores = near_fit_scores - max_score
                
                exp_scores = np.exp(shifted_scores / TEMPERATURE)
                sum_exp_scores = np.sum(exp_scores)

                if sum_exp_scores > epsilon_small: # Avoid division by zero or near-zero
                    softmax_probabilities = exp_scores / sum_exp_scores
                else:
                    # Fallback to uniform distribution if all exp_scores are ~0 or NaN.
                    # This handles cases where temperature might be too low or scores are very small.
                    softmax_probabilities = np.ones_like(near_fit_scores) / len(near_fit_scores)
                
                # Map softmax probabilities to a priority range, combining base score and scaled probabilities.
                scaled_near_fit_priorities = NEAR_FIT_BASE_SCORE + softmax_probabilities * NEAR_FIT_SCALE
                priorities[near_fit_indices_subset] = scaled_near_fit_priorities

        # 3. General Fits: Assign a low positive priority to bins that fit but are not considered "near".
        # These bins will only be chosen if no exact or near fits are available.
        if len(non_near_fit_indices_subset) > 0:
            priorities[non_near_fit_indices_subset] = GENERAL_FIT_PRIORITY
            
    return priorities
```
