{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin using Inverse Distance strategy.\n\n    The Inverse Distance strategy prioritizes bins that are \"closer\" to fitting the item.\n    A higher priority is assigned to bins with less remaining capacity that can still\n    accommodate the item.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the \"distance\" to fitting the item.\n    # This is the remaining capacity minus the item size.\n    # A smaller positive distance means a better fit.\n    distances = bins_remain_cap - item\n\n    # Initialize priorities to a very low value (e.g., negative infinity)\n    # for bins that cannot fit the item.\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    # For bins that can fit the item (distances >= 0):\n    # Calculate inverse distance as priority.\n    # To avoid division by zero if a bin has exactly the remaining capacity,\n    # we add a small epsilon.\n    # The closer the remaining capacity is to the item size (smaller positive distance),\n    # the higher the priority.\n    fit_mask = distances >= 0\n    priorities[fit_mask] = 1.0 / (distances[fit_mask] + 1e-9)\n\n    return priorities\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin using Almost Full Fit.\n\n    The Almost Full Fit strategy prioritizes bins that have a remaining capacity\n    slightly larger than the item. This aims to leave smaller gaps in bins that\n    are nearly full, potentially improving overall packing efficiency.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # We want to prioritize bins where the remaining capacity is just slightly\n    # larger than the item. A good way to express this is by minimizing the\n    # difference (bins_remain_cap - item), but only for bins that can actually\n    # fit the item. For bins that cannot fit the item, we assign a very low priority.\n\n    # Initialize priorities to a very low value (negative infinity) to signify\n    # that these bins are not candidates if the item doesn't fit.\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    # Find bins that can accommodate the item\n    can_fit_mask = bins_remain_cap >= item\n\n    # For bins that can fit the item, calculate a priority score.\n    # We want the remaining capacity to be as close as possible to 'item' but still\n    # greater than or equal to it. This is equivalent to minimizing (bins_remain_cap - item).\n    # However, for \"Almost Full Fit\", we want bins that are *almost* full, meaning\n    # the remaining capacity is large enough but not excessively large.\n    # A simple approach is to take the negative of the remaining capacity for\n    # bins that can fit the item. This way, bins with *less* remaining capacity\n    # (closer to 'item') will have a higher priority (less negative).\n\n    # To further refine for \"Almost Full Fit\", we can also consider how \"full\" the bin is.\n    # A bin that is *almost* full and can fit the item is desirable.\n    # We can achieve this by prioritizing bins with larger remaining capacities *among those that can fit the item*.\n    # Let's invert this. We want to select bins that are *almost* full.\n    # So, if a bin can fit the item, its priority is inversely related to its remaining capacity.\n    # A smaller remaining capacity (closer to 'item') is better for 'Almost Full Fit'.\n\n    # Let's use a scoring where a *smaller* positive difference (remaining capacity - item)\n    # is preferred. We'll use the negative of this difference as priority,\n    # so a larger negative difference (meaning smaller positive difference) is better.\n    # We add a small epsilon to avoid division by zero if we were to use reciprocals,\n    # or to ensure distinct values.\n\n    # For bins that can fit, calculate the difference. We want to penalize larger differences.\n    # A bin with remaining capacity `C` and item `I`: difference is `C - I`.\n    # We want small `C - I`. So, priority should be related to `-(C - I)`.\n    # This means higher priority for smaller `C - I`.\n\n    # Let's consider bins that can fit the item:\n    eligible_bins_capacity = bins_remain_cap[can_fit_mask]\n\n    # For these eligible bins, we want those with the smallest remaining capacity.\n    # So, we can sort them or assign priorities based on their remaining capacity.\n    # The smaller the `bins_remain_cap[i]`, the higher the priority for eligible bins.\n    # Assign priority as negative remaining capacity.\n    priorities[can_fit_mask] = -eligible_bins_capacity\n\n    # This implementation gives higher priority to bins that are \"almost full\"\n    # meaning they have the least remaining capacity among those that can fit the item.\n    # This is a common interpretation of \"Almost Full Fit\" where you try to fill\n    # bins as much as possible without overfilling, thus leaving less fragmented space.\n\n    return priorities\n\n[Reflection]\nPrioritize bins with minimal remaining capacity that can still fit the item.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}