```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Returns priority with which we want to add item to each bin.
    This heuristic prioritizes bins that can fit the item. Among those that fit,
    it assigns a higher priority to bins that will have less remaining capacity
    after the item is placed. It uses a transformation that more aggressively
    penalizes larger remaining capacities, effectively emphasizing exact fits and
    bins that become nearly full.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins that can accommodate the item
    can_fit_mask = bins_remain_cap >= item

    if np.any(can_fit_mask):
        # Calculate the remaining capacity if the item is placed in a fitting bin
        remaining_after_placement = bins_remain_cap[can_fit_mask] - item

        # Transform remaining capacity to priority.
        # To emphasize exact fits and penalize larger remaining capacities more aggressively,
        # we can use a function that grows faster as remaining capacity approaches zero.
        # A function like `1 / (1 + slack^p)` where `p > 1` will achieve this.
        # For `p=2`, it means a slack of 0.1 is much more preferred than a slack of 0.2.
        # An exponential decay `exp(-k * slack)` also works, but the power function
        # offers a direct way to control the steepness of the penalty.
        # Let's use `1.0 / (1.0 + slack**2)` which provides a quadratic penalty for slack.

        # Set a small offset to avoid division by zero if remaining_after_placement is exactly 0.
        # However, `1.0 / (1.0 + 0**2)` is 1.0, which is fine.
        # If we wanted to ensure exact fits get a strictly higher score than any non-exact fit,
        # we could add a large constant to exact fits. But `1/(1+0)` already gives the max score.

        slack_squared = remaining_after_placement**2
        priorities[can_fit_mask] = 1.0 / (1.0 + slack_squared)

        # To make the preference for exact fits even stronger, or to ensure exact fits
        # are always strictly preferred over any other fit, we can add a small boost.
        # However, the current formulation where `slack=0` gives a priority of 1.0,
        # and any `slack > 0` gives a priority < 1.0, inherently prioritizes exact fits.
        # The quadratic penalty `slack**2` already makes smaller slacks much more favorable.

    return priorities
```
