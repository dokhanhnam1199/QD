```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using a refined Best-Fit strategy.

    This heuristic prioritizes bins that can fit the item. Among those that fit,
    it assigns higher priority to bins that result in less remaining capacity,
    thus encouraging tighter packing. It also introduces a small bonus for
    exact fits to ensure they are always preferred.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Initialize priorities to a very low value for bins that cannot fit the item.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Identify bins that have enough capacity to fit the item.
    can_fit_mask = bins_remain_cap >= item

    # For bins that can fit the item, calculate their priority.
    # The priority is the negative of the remaining capacity after placing the item.
    # This means bins with smaller remaining capacity (tighter fits) will have higher priorities.
    remaining_capacities_after_fit = bins_remain_cap[can_fit_mask] - item
    
    # Assign a base priority based on how tight the fit is.
    # A smaller remaining capacity (closer to 0) results in a higher priority (less negative).
    base_priorities = -remaining_capacities_after_fit

    # Introduce a bonus for exact fits. Exact fits have remaining_capacities_after_fit == 0.
    # Adding a positive constant (e.g., 1.0) to the priority of exact fits ensures
    # they are always preferred over near fits, even if the near fit is very close.
    exact_fit_bonus = np.zeros_like(base_priorities)
    exact_fit_bonus[remaining_capacities_after_fit == 0] = 1.0

    priorities[can_fit_mask] = base_priorities + exact_fit_bonus

    return priorities
```
