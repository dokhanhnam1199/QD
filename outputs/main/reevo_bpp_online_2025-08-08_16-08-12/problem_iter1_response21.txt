```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Best Fit.

    The Best Fit strategy aims to place the item in the bin that leaves the least
    remaining capacity after the item is placed, effectively minimizing wasted space
    in that specific bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
        Higher priority is given to bins where placing the item results in less
        remaining capacity (closer to zero, but still non-negative).
        Bins that cannot fit the item are given a priority of -1.
    """
    # Calculate potential remaining capacity for each bin if the item fits
    potential_remain_cap = bins_remain_cap - item

    # Initialize priorities array with a low value (e.g., -1) indicating not a good fit or impossible to fit
    priorities = np.full_like(bins_remain_cap, -1.0)

    # Identify bins where the item can actually fit
    can_fit_mask = potential_remain_cap >= 0

    # For bins where the item fits, the priority is the negative of the remaining capacity.
    # This means bins with smaller remaining capacity (after placing the item) get higher priority.
    # We use the negative because we want to MAXIMIZE the priority score, and smallest remaining
    # capacity is best fit. So, a smaller positive remaining capacity becomes a larger negative number.
    priorities[can_fit_mask] = -potential_remain_cap[can_fit_mask]

    return priorities
```
