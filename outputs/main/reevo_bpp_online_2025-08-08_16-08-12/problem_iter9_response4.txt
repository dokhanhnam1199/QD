```python
import numpy as np
import scipy.special

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Returns priority with which we want to add item to each bin.

    This heuristic prioritizes bins that can fit the item. Among those that fit,
    it assigns a higher priority to bins that will have less remaining capacity
    after the item is placed (exact fits are preferred). It then considers
    bins with slightly more slack. Softmax is used to convert these scores into
    probabilities, with a temperature parameter to control exploration.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    temperature = 1.0  # Tunable parameter for exploration

    # Identify bins that can accommodate the item
    can_fit_mask = bins_remain_cap >= item

    if np.any(can_fit_mask):
        # Calculate the remaining capacity if the item is placed in a fitting bin
        remaining_after_placement = bins_remain_cap[can_fit_mask] - item

        # Prioritize exact fits (remaining capacity is 0)
        # Then prioritize bins with minimal slack.
        # We want smaller remaining_after_placement to have higher priority.
        # Adding a small constant to avoid log(0) and to ensure positive values.
        # Scaling by a factor to make differences more pronounced before softmax.
        # An arbitrary scaling factor, could be tuned.
        scaled_slack_scores = -1.0 / (remaining_after_placement + 1e-9)

        # Apply softmax to convert scores to probabilities (priorities)
        # Higher scores (smaller slack) will get higher probabilities
        priorities[can_fit_mask] = scipy.special.softmax(scaled_slack_scores / temperature)

    return priorities
```
