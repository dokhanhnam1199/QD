```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Returns priority with which we want to add item to each bin.
    This heuristic prioritizes bins that can fit the item. Among those that fit,
    it assigns a higher priority to bins that will have less remaining capacity
    after the item is placed. This aims for denser packing by favoring bins
    that are nearly full. It uses an exponential decay function to assign
    priorities, emphasizing exact fits more strongly.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
        Bins that cannot fit the item will have a priority of 0.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins that can accommodate the item
    can_fit_mask = bins_remain_cap >= item

    if np.any(can_fit_mask):
        # Calculate the remaining capacity if the item is placed in a fitting bin
        remaining_after_placement = bins_remain_cap[can_fit_mask] - item

        # Transform remaining capacity to priority using an exponential decay function.
        # `np.exp(-k * slack)`: as slack decreases, the priority increases.
        # An exact fit (slack=0) will yield exp(0) = 1.
        # Larger slack values will result in smaller priorities.
        # The parameter `k` controls how quickly the priority drops with increasing slack.
        k = 1.5  # Tunable parameter to control the decay rate, higher k means stronger preference for exact fits.
        priorities[can_fit_mask] = np.exp(-k * remaining_after_placement)

    return priorities
```
