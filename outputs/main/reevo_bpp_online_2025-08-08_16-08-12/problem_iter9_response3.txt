```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Returns priority with which we want to add item to each bin using a
    prioritization strategy that favors exact fits and then minimal slack,
    with adaptive exploration.

    This heuristic prioritizes bins that can fit the item. Among those that fit,
    it assigns a higher priority to bins that will have less remaining capacity
    after the item is placed (minimal slack). It also incorporates an
    exploration factor based on the item size relative to the bin's remaining
    capacity, aiming to encourage denser packing but also allowing for
    exploration of less-filled bins if the item represents a significant
    portion of the remaining space.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins that can accommodate the item
    can_fit_mask = bins_remain_cap >= item

    if not np.any(can_fit_mask):
        return priorities  # No bin can fit the item

    fitting_bins_cap = bins_remain_cap[can_fit_mask]

    # Calculate remaining capacity after placement
    remaining_after_placement = fitting_bins_cap - item

    # Score for minimal slack: invert remaining capacity. Higher value for less remaining capacity.
    # Add a small epsilon to avoid division by zero.
    slack_score = 1.0 / (remaining_after_placement + 1e-9)

    # Score for exploration: favour items that 'fill' a good portion of the bin.
    # This can be seen as a measure of how "tight" the fit is.
    # We use a scaled difference, where larger values mean the item is a larger fraction
    # of the available space. A softer version of exact fit.
    # Add a small epsilon to the denominator to avoid division by zero if item is 0.
    exploration_score = item / (fitting_bins_cap + 1e-9)

    # Combine scores. We want to prioritize minimal slack (high slack_score)
    # and also encourage exploration of good fits (high exploration_score).
    # A simple additive combination, potentially weighted, can work.
    # Here, we'll combine them, giving slightly more weight to minimal slack
    # for dense packing, but the exploration score helps prevent premature
    # filling of bins with very large remaining capacities.

    # For demonstration, let's use a simple linear combination.
    # Weights can be tuned. For instance, 0.7 for minimal slack and 0.3 for exploration.
    combined_score = 0.7 * slack_score + 0.3 * exploration_score

    # Apply the combined scores to the priorities for the bins that can fit the item
    priorities[can_fit_mask] = combined_score

    return priorities
```
