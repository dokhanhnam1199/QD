```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Best Fit strategy.

    The Best Fit strategy prioritizes bins that have the smallest remaining capacity
    that is still sufficient to accommodate the item. This aims to minimize wasted space.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Initialize priorities to a very low value (e.g., negative infinity)
    # for bins that cannot fit the item.
    priorities = np.full_like(bins_remain_cap, -np.inf)

    # Find bins that can accommodate the item
    can_fit_mask = bins_remain_cap >= item

    # For bins that can fit, calculate the difference between remaining capacity and item size.
    # We want to select the bin where this difference is minimized (the "tightest fit").
    # Therefore, a smaller difference means a higher priority.
    # We can use the negative of this difference as the priority score.
    # Smaller (bins_remain_cap - item) will result in a larger (less negative) priority.

    # Calculate the difference for eligible bins
    differences = bins_remain_cap[can_fit_mask] - item

    # Assign priority as the negative of the difference.
    # The smaller the difference, the higher the priority.
    priorities[can_fit_mask] = -differences

    return priorities
```
