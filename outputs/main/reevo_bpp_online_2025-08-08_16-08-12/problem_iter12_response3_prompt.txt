{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin using a Best Fit strategy with explicit prioritization of exact fits.\n\n    This heuristic prioritizes bins that can fit the item. Among those that fit,\n    it first gives the highest priority to exact fits. For bins that are not\n    exact fits but can accommodate the item, it assigns priority based on\n    how much remaining capacity is left, favoring smaller remaining capacities.\n    This strategy is a greedy approach aiming to fill bins as much as possible\n    while also rewarding perfect fits.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    # Identify bins that can accommodate the item.\n    can_fit_mask = bins_remain_cap >= item\n\n    if not np.any(can_fit_mask):\n        return priorities  # No bin can fit the item\n\n    # Calculate remaining capacity if item is placed\n    fitting_bins_remain_cap = bins_remain_cap[can_fit_mask]\n    remaining_after_placement = fitting_bins_remain_cap - item\n\n    # Assign highest priority to exact fits\n    exact_fit_mask_subset = (remaining_after_placement == 0)\n    priorities[can_fit_mask][exact_fit_mask_subset] = 100.0  # High priority for exact fits\n\n    # For bins that fit but are not exact fits, prioritize those with less remaining capacity.\n    # A higher score means less remaining capacity after placement.\n    non_exact_fit_indices_subset = np.where(~exact_fit_mask_subset)[0]\n\n    if non_exact_fit_indices_subset.size > 0:\n        non_exact_fitting_bins_remain_cap = fitting_bins_remain_cap[~exact_fit_mask_subset]\n        non_exact_remaining_after_placement = non_exact_fitting_bins_remain_cap - item\n\n        # Prioritize smaller remaining capacities. Use inverse for higher score.\n        # Add a small epsilon to avoid division by zero if remaining capacity is very close to zero.\n        fit_scores_for_non_exact = 1.0 / (non_exact_remaining_after_placement + 1e-9)\n\n        # Scale these priorities to be lower than exact fits but still positive.\n        # The maximum possible value of fit_scores_for_non_exact depends on the\n        # minimum non-zero remaining capacity. We can normalize or use a fixed\n        # scaling to ensure they are below the exact fit priority.\n        # A simple approach is to scale by a factor that ensures they are less than 100.\n        # For example, if the minimum remaining capacity for non-exact fits is `min_rem_non_exact`,\n        # the max score is `1 / (min_rem_non_exact + epsilon)`.\n        # We can scale this by `99.0 / max(fit_scores_for_non_exact)` to bound them\n        # between 0 and 99.\n        max_score_non_exact = np.max(fit_scores_for_non_exact)\n        if max_score_non_exact > 0:\n            scaled_priorities = (fit_scores_for_non_exact / max_score_non_exact) * 99.0\n            priorities[can_fit_mask][~exact_fit_mask_subset] = scaled_priorities\n        else: # This case implies all non-exact fits have remaining capacity close to 0, which shouldn't happen if they are not exact fits.\n            priorities[can_fit_mask][~exact_fit_mask_subset] = 99.0 # Assign a high non-exact priority\n\n    return priorities\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    This heuristic prioritizes bins that can fit the item. Among those that fit,\n    it assigns a higher priority to bins that will have less remaining capacity\n    after the item is placed. This aims for denser packing by favoring bins\n    that are nearly full. It uses a transformation that emphasizes exact fits\n    and penalizes larger remaining capacities more severely than a simple inverse.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Identify bins that can accommodate the item\n    can_fit_mask = bins_remain_cap >= item\n\n    if np.any(can_fit_mask):\n        # Calculate the remaining capacity if the item is placed in a fitting bin\n        remaining_after_placement = bins_remain_cap[can_fit_mask] - item\n\n        # Transform remaining capacity to priority.\n        # We want smaller remaining_after_placement to have higher priority.\n        # Using `1.0 / (1.0 + slack)` gives a score between 0 and 1, where 1 is for exact fit.\n        # To more strongly emphasize exact fits and penalize larger slacks,\n        # we can use a transformation like `exp(-alpha * slack)` or `1 / (1 + slack^beta)`.\n        # Let's use a transformation that grows faster as slack decreases.\n        # A hyperbolic tangent or a power function could also work.\n        # For now, let's use a simple inverse with a power to make the preference for small slack stronger.\n        # For example, `1.0 / (1.0 + slack**2)` would give higher scores for smaller slacks.\n        # An alternative is `1.0 - (remaining_after_placement / max(bins_remain_cap))`.\n        # Let's use `1.0 / (1.0 + remaining_after_placement)` as it's intuitive and bounded.\n        # To make it more aggressive towards exact fits, we can scale the remaining capacity\n        # before applying the inverse.\n\n        # Example: Scale slack by a factor `k` before taking the inverse.\n        # `k = 2.0` or higher would make exact fits much more preferred.\n        k = 2.0  # Tunable parameter to control preference for exact fits\n        priorities[can_fit_mask] = 1.0 / (1.0 + k * remaining_after_placement)\n\n        # Alternative: Use an exponential decay, similar to softmax but without normalization.\n        # `priorities[can_fit_mask] = np.exp(-k * remaining_after_placement)`\n        # This can also work well and is often used. The `1/(1+x)` form is less prone to overflow\n        # if `k` is very large. Let's stick with the inverse form for now.\n\n    return priorities\n\n[Reflection]\nEmphasize exact fits, penalize larger remaining capacities more aggressively.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}