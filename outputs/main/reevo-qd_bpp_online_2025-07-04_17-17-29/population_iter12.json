[
  {
    "stdout_filepath": "problem_iter0_stdout0.txt",
    "code_path": "problem_iter0_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    ratios = item / bins_remain_cap\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities",
    "response_id": 0,
    "obj": 149.30195452732352,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 11.60964047443681,
    "mi": 94.04446327225541,
    "token_count": 47.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response1.txt_stdout.txt",
    "code_path": "problem_iter1_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # High priority to bins where item fits with smallest remaining space (First-Fit Decreasing principle)\n    # Avoid fragmentation: prioritize bins that have just enough space.\n    fit_mask = bins_remain_cap >= item\n    if np.any(fit_mask):\n        remaining_space = bins_remain_cap[fit_mask] - item\n        priorities[fit_mask] = -remaining_space  # Smaller remaining space => Higher priority\n\n        # Boost bins close to full after packing, but avoid bins that get too full (risk of not fitting subsequent smaller items)\n        nearly_full_mask = (remaining_space >= 0) & (remaining_space <= 0.2 * np.max(bins_remain_cap)) #tolerate a max 20% of the largest bin size as tolerance\n\n        if np.any(nearly_full_mask):\n            priorities[fit_mask][nearly_full_mask] += 1 # Small positive boost to encourage filling near-full bins, 1 could be tuned\n    else:\n        # If the item does not fit in any bin, assign a very low priority\n        priorities[:] = -np.inf\n\n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 6.0,
    "halstead": 120.92782504182705,
    "mi": 83.27920988727506,
    "token_count": 140.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response0.txt_stdout.txt",
    "code_path": "problem_iter2_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # High priority to bins where item fits with smallest remaining space (First-Fit Decreasing principle)\n    # Avoid fragmentation: prioritize bins that have just enough space.\n    fit_mask = bins_remain_cap >= item\n    if np.any(fit_mask):\n        remaining_space = bins_remain_cap[fit_mask] - item\n        priorities[fit_mask] = -remaining_space  # Smaller remaining space => Higher priority\n\n        # Boost bins close to full after packing, but avoid bins that get too full (risk of not fitting subsequent smaller items)\n        nearly_full_mask = (remaining_space >= 0) & (remaining_space <= 0.2 * np.max(bins_remain_cap)) #tolerate a max 20% of the largest bin size as tolerance\n\n        if np.any(nearly_full_mask):\n            priorities[fit_mask][nearly_full_mask] += 2  # Small positive boost to encourage filling near-full bins, tuned to 2\n\n        # Slightly penalize bins that become almost completely full. This encourages a bit of diversity.\n        almost_full_mask = (remaining_space > 0) & (remaining_space <= 0.05 * np.max(bins_remain_cap))\n        if np.any(almost_full_mask):\n            priorities[fit_mask][almost_full_mask] -= 0.5\n    else:\n        # If the item does not fit in any bin, assign a very low priority\n        priorities[:] = -np.inf\n\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 18.0,
    "cyclomatic_complexity": 4.0,
    "halstead": 225.71696739799185,
    "mi": 81.72538025527102,
    "token_count": 207.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response0.txt_stdout.txt",
    "code_path": "problem_iter3_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # High priority to bins where item fits with smallest remaining space (First-Fit Decreasing principle)\n    # Avoid fragmentation: prioritize bins that have just enough space.\n    fit_mask = bins_remain_cap >= item\n    if np.any(fit_mask):\n        remaining_space = bins_remain_cap[fit_mask] - item\n        priorities[fit_mask] = -remaining_space  # Smaller remaining space => Higher priority\n\n        # Boost bins close to full after packing, but avoid bins that get too full (risk of not fitting subsequent smaller items)\n        # The boost is now proportional to how \"full\" the bin becomes after packing.\n        nearly_full_mask = (remaining_space >= 0) & (remaining_space <= 0.3) #tolerate remaining space upto 0.3. Tuned\n        if np.any(nearly_full_mask):\n            fullness_ratio = (bins_remain_cap[fit_mask][nearly_full_mask] - remaining_space[nearly_full_mask]) / bins_remain_cap[fit_mask][nearly_full_mask] # Ratio of filled space to original capacity\n            priorities[fit_mask][nearly_full_mask] += 2 * fullness_ratio # Boost is now proportional to fullness, amplified. Tuned\n\n        # Penalize bins that become too full after packing\n        too_full_mask = remaining_space < 0.05 #tunable. if remaining space < 0.05, it becomes 'too full'\n        if np.any(too_full_mask & fit_mask): #make sure to only penalize bins where the item fits\n            priorities[fit_mask][too_full_mask & (remaining_space > -1e-6)] -= 5 # Penalize, but only if there's very minor overflow due to floating point issues. Tuned\n            priorities[fit_mask][too_full_mask & (remaining_space > -1e-6)] = np.clip(priorities[fit_mask][too_full_mask & (remaining_space > -1e-6)], -np.inf, 0) #Clip to avoid having positive prioirities from penalizing overflow, tuned\n    else:\n        # If the item does not fit in any bin, assign a very low priority\n        priorities[:] = -np.inf\n\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 4.0,
    "halstead": 121.01398665684616,
    "mi": 82.66599246476021,
    "token_count": 173.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response0.txt_stdout.txt",
    "code_path": "problem_iter4_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Prioritize fitting the item\n    fit_mask = bins_remain_cap >= item\n\n    if np.any(fit_mask):\n        remaining_space = bins_remain_cap[fit_mask] - item\n        priorities[fit_mask] = -remaining_space  # Smaller remaining space => Higher priority\n\n        # Encourage bins that will be nearly full after packing\n        nearly_full_mask = (remaining_space >= 0) & (remaining_space <= 0.2)  # Tighter nearly full range\n        if np.any(nearly_full_mask):\n            fullness_ratio = (bins_remain_cap[fit_mask][nearly_full_mask] - remaining_space[nearly_full_mask]) / bins_remain_cap[fit_mask][nearly_full_mask]\n            priorities[fit_mask][nearly_full_mask] += 3 * fullness_ratio  # Increased boost for nearly full bins, amplified, Tuned\n\n        # Penalize bins that will become too full after packing (risk of wasted space due to inability to fit smaller items)\n        too_full_mask = remaining_space < 0.03  # Reduced tolerance for \"too full\"\n        if np.any(too_full_mask & fit_mask):\n            priorities[fit_mask][too_full_mask & (remaining_space > -1e-6)] -= 7 # Increased penalty, tuned\n            priorities[fit_mask][too_full_mask & (remaining_space > -1e-6)] = np.clip(priorities[fit_mask][too_full_mask & (remaining_space > -1e-6)], -np.inf, 0) #Clip to avoid having positive prioirities from penalizing overflow, tuned\n\n        # Moderate penalty for bins with significantly larger remaining capacity after packing, to avoid them being filled too early\n        large_space_mask = remaining_space > 0.5 # If there is still a lot of space available, apply some penalty,tuned\n        if np.any(large_space_mask & fit_mask):\n            priorities[fit_mask][large_space_mask] -= 0.5 * (remaining_space[large_space_mask] - 0.5)  #Proportional penalty if there is too much space, tuned\n    else:\n        # If the item does not fit in any bin, assign a very low priority\n        priorities[:] = -np.inf\n\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 16.0,
    "cyclomatic_complexity": 6.0,
    "halstead": 210.99629561116632,
    "mi": 80.23064630803235,
    "token_count": 237.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response0.txt_stdout.txt",
    "code_path": "problem_iter5_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # High priority to bins where item fits with smallest remaining space (First-Fit Decreasing principle)\n    fit_mask = bins_remain_cap >= item\n    if np.any(fit_mask):\n        remaining_space = bins_remain_cap[fit_mask] - item\n        priorities[fit_mask] = -remaining_space  # Smaller remaining space => Higher priority\n\n        # Boost bins close to full after packing, but avoid bins that get too full (risk of not fitting subsequent smaller items)\n        nearly_full_mask = (remaining_space >= 0) & (remaining_space <= 0.2 * np.max(bins_remain_cap))\n\n        if np.any(nearly_full_mask):\n            priorities[fit_mask][nearly_full_mask] += 5 # Increased boost to encourage filling near-full bins\n\n        # Prioritize slightly larger bins less aggressively to leave room for smaller items\n        slightly_larger_mask = (remaining_space > 0.2 * np.max(bins_remain_cap)) & (remaining_space <= 0.5* np.max(bins_remain_cap))\n        if np.any(slightly_larger_mask):\n             priorities[fit_mask][slightly_larger_mask] *= 0.5 # Reduce priority\n\n    else:\n        # If the item does not fit in any bin, assign a very low priority (large negative number)\n        priorities[:] = -1e9\n\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 4.0,
    "halstead": 192.29419688230416,
    "mi": 80.16703465668749,
    "token_count": 194.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response0.txt_stdout.txt",
    "code_path": "problem_iter6_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # High priority to bins where item fits with smallest remaining space (First-Fit Decreasing principle)\n    # Avoid fragmentation: prioritize bins that have just enough space.\n    fit_mask = bins_remain_cap >= item\n    if np.any(fit_mask):\n        remaining_space = bins_remain_cap[fit_mask] - item\n        priorities[fit_mask] = -remaining_space  # Smaller remaining space => Higher priority\n\n        # Boost bins close to full after packing, but avoid bins that get too full (risk of not fitting subsequent smaller items)\n        max_cap = np.max(bins_remain_cap)\n        nearly_full_mask = (remaining_space >= 0) & (remaining_space <= 0.2 * max_cap)\n\n        if np.any(nearly_full_mask):\n            priorities[fit_mask][nearly_full_mask] += 2  # Small positive boost to encourage filling near-full bins, tuned to 2\n\n        # Slightly penalize bins that become almost completely full. This encourages a bit of diversity.\n        almost_full_mask = (remaining_space > 0) & (remaining_space <= 0.05 * max_cap)\n        if np.any(almost_full_mask):\n            priorities[fit_mask][almost_full_mask] -= 0.5\n\n        #Dynamically adjust the nearly full boost based on item size\n        if np.any(nearly_full_mask):\n            boost_factor = min(1.0, item / max_cap)  # Smaller items get a smaller boost\n            priorities[fit_mask][nearly_full_mask] += 2 * boost_factor\n\n        # Penalize bins that are too empty after placing the item to avoid spreading items thinly\n        too_empty_threshold = 0.8 * max_cap #if 80% of the bin is still empty after placing the item\n        too_empty_mask = (remaining_space >= 0) & (remaining_space >= too_empty_threshold)\n\n        if np.any(too_empty_mask):\n            priorities[fit_mask][too_empty_mask] -= 1 #Slightly penalize these bins\n\n    else:\n        # If the item does not fit in any bin, assign a very low priority\n        priorities[:] = -np.inf\n\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 23.0,
    "cyclomatic_complexity": 6.0,
    "halstead": 519.4015125670676,
    "mi": 75.32669185782825,
    "token_count": 324.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter7_response0.txt_stdout.txt",
    "code_path": "problem_iter7_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap) # Assuming all bins have same capacity, take max available as capacity\n\n    # Fit score: Higher when the item fits\n    fit_mask = bins_remain_cap >= item\n    if np.any(fit_mask):\n        remaining_space = bins_remain_cap[fit_mask] - item\n        priorities[fit_mask] = 1 / (remaining_space + 0.0001)  # Inverse of remaining space: smaller => Higher priority; adding small constant to avoid division by zero\n\n        # Nearly full bonus: slight preference for bins that become nearly full\n        nearly_full_mask = (remaining_space >= 0) & (remaining_space <= 0.2 * bin_capacity) # Up to 20% free space\n        priorities[fit_mask][nearly_full_mask] += 0.5 # Bonus\n\n        # Medium fill bonus: A bonus if we make the bin about half full\n        medium_full_mask = (bins_remain_cap[fit_mask] >= 0.4 * bin_capacity) & ((bins_remain_cap[fit_mask] - item) <= 0.6* bin_capacity)\n        priorities[fit_mask][medium_full_mask] += 0.25\n    else:\n        # Item does not fit: Assign a negative priority proportional to how much it overflows\n        overflow = item - bins_remain_cap\n        priorities = -overflow #Penalize more for bigger overflows\n\n\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 23.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 393.63917186284954,
    "mi": 77.1864360261436,
    "token_count": 253.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response1.txt_stdout.txt",
    "code_path": "problem_iter8_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # High priority to bins where item fits with smallest remaining space (First-Fit Decreasing principle)\n    # Avoid fragmentation: prioritize bins that have just enough space.\n    fit_mask = bins_remain_cap >= item\n    if np.any(fit_mask):\n        remaining_space = bins_remain_cap[fit_mask] - item\n        priorities[fit_mask] = -remaining_space  # Smaller remaining space => Higher priority\n\n        # Boost bins close to full after packing, but avoid bins that get too full (risk of not fitting subsequent smaller items)\n        # The boost is now proportional to how \"full\" the bin becomes after packing.\n        nearly_full_mask = (remaining_space >= 0) & (remaining_space <= 0.3) #tolerate remaining space upto 0.3. Tuned\n        if np.any(nearly_full_mask):\n            fullness_ratio = (bins_remain_cap[fit_mask][nearly_full_mask] - remaining_space[nearly_full_mask]) / bins_remain_cap[fit_mask][nearly_full_mask] # Ratio of filled space to original capacity\n            priorities[fit_mask][nearly_full_mask] += 2 * fullness_ratio # Boost is now proportional to fullness, amplified. Tuned\n\n        # Penalize bins that become too full after packing\n        too_full_mask = remaining_space < 0.05 #tunable. if remaining space < 0.05, it becomes 'too full'\n        if np.any(too_full_mask & fit_mask): #make sure to only penalize bins where the item fits\n            priorities[fit_mask][too_full_mask & (remaining_space > -1e-6)] -= 5 # Penalize, but only if there's very minor overflow due to floating point issues. Tuned\n            priorities[fit_mask][too_full_mask & (remaining_space > -1e-6)] = np.clip(priorities[fit_mask][too_full_mask & (remaining_space > -1e-6)], -np.inf, 0) #Clip to avoid having positive prioirities from penalizing overflow, tuned\n        \n        # Item Size Relationship Consideration:\n        # Prioritize bins that are a good multiple of the item size.\n        # This encourages packing items of similar size together.\n        size_ratio = item / bins_remain_cap[fit_mask]\n        multiple_score = -np.abs(size_ratio - np.round(size_ratio)) * 0.5 # Penalize bins where the item isn't a good multiple of the remaining capacity\n        priorities[fit_mask] += multiple_score\n\n\n    else:\n        # If the item does not fit in any bin, assign a very low priority\n        priorities[:] = -np.inf\n\n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 18.0,
    "cyclomatic_complexity": 5.0,
    "halstead": 227.8930302777963,
    "mi": 81.56170108723886,
    "token_count": 222.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response0.txt_stdout.txt",
    "code_path": "problem_iter9_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)  # Assuming all bins have the same capacity\n\n    # High priority to bins where item fits with smallest remaining space (First-Fit Decreasing principle)\n    fit_mask = bins_remain_cap >= item\n    if np.any(fit_mask):\n        remaining_space = bins_remain_cap[fit_mask] - item\n        priorities[fit_mask] = -remaining_space  # Smaller remaining space => Higher priority\n\n        # Boost bins close to full after packing, but avoid bins that get too full (risk of not fitting subsequent smaller items)\n        nearly_full_threshold_low = 0.1 * bin_capacity #adjust based on mean item size, 10%\n        nearly_full_threshold_high = 0.3 * bin_capacity #adjust based on item sizes 30%\n\n        nearly_full_mask = (remaining_space >= 0) & (remaining_space <= nearly_full_threshold_high)\n\n        if np.any(nearly_full_mask):\n            priorities[fit_mask][nearly_full_mask] += 2 # Small positive boost to encourage filling near-full bins, tune\n\n        #Slight penalization to bins that become too empty, to encourage usage\n        too_empty_mask = (bins_remain_cap[fit_mask] - item) > 0.6 * bin_capacity\n        if np.any(too_empty_mask):\n            priorities[fit_mask][too_empty_mask] -= 1 # Penalize bins that get too empty after placing the item\n    else:\n        # If the item does not fit in any bin, assign a very low priority\n        priorities[:] = -np.inf\n\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 21.0,
    "cyclomatic_complexity": 6.0,
    "halstead": 277.44167656471495,
    "mi": 79.87244391452012,
    "token_count": 247.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response0.txt_stdout.txt",
    "code_path": "problem_iter11_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # High priority to bins where item fits with smallest remaining space (First-Fit Decreasing principle)\n    # Avoid fragmentation: prioritize bins that have just enough space.\n    fit_mask = bins_remain_cap >= item\n    if np.any(fit_mask):\n        remaining_space = bins_remain_cap[fit_mask] - item\n        priorities[fit_mask] = -remaining_space  # Smaller remaining space => Higher priority\n\n        # Boost bins close to full after packing, but avoid bins that get too full (risk of not fitting subsequent smaller items)\n        max_cap = np.max(bins_remain_cap)\n        nearly_full_threshold = 0.2 * max_cap #tolerate a max 20% of the largest bin size as tolerance\n        nearly_full_mask = (remaining_space >= 0) & (remaining_space <= nearly_full_threshold)\n\n        if np.any(nearly_full_mask):\n            #Adjust the boost based on item size: larger items get larger boost\n            boost_factor = min(item, nearly_full_threshold)/ nearly_full_threshold\n            priorities[fit_mask][nearly_full_mask] += boost_factor # Small positive boost to encourage filling near-full bins, 1 could be tuned\n            \n        #Penalize bins where remaining space is too small relative to average remaining space\n        avg_remaining_space = np.mean(bins_remain_cap[fit_mask]) if np.any(fit_mask) else 0\n        too_small_space_threshold = 0.1 * max_cap #Bins with space below 10% of max_cap considered too small.\n        too_small_mask = (remaining_space > 0) & (remaining_space <= too_small_space_threshold)\n        if np.any(too_small_mask):\n             priorities[fit_mask][too_small_mask] -= 0.5 #Small negative factor, could be tuned\n\n    else:\n        # If the item does not fit in any bin, assign a very low priority\n        priorities[:] = -np.inf\n\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 19.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 265.0,
    "mi": 79.42835927053439,
    "token_count": 192.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response0.txt_stdout.txt",
    "code_path": "problem_iter12_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # High priority to bins where item fits with smallest remaining space (First-Fit Decreasing principle)\n    # Avoid fragmentation: prioritize bins that have just enough space.\n    fit_mask = bins_remain_cap >= item\n    if np.any(fit_mask):\n        remaining_space = bins_remain_cap[fit_mask] - item\n        priorities[fit_mask] = -remaining_space  # Smaller remaining space => Higher priority\n\n        # Boost bins close to full after packing, but avoid bins that get too full (risk of not fitting subsequent smaller items)\n        nearly_full_mask = (remaining_space >= 0) & (remaining_space <= 0.2 * np.max(bins_remain_cap)) #tolerate a max 20% of the largest bin size as tolerance\n\n        if np.any(nearly_full_mask):\n            priorities[fit_mask][nearly_full_mask] += 2  # Small positive boost to encourage filling near-full bins, tuned to 2\n\n        # Slightly penalize bins that become almost completely full. This encourages a bit of diversity.\n        almost_full_mask = (remaining_space > 0) & (remaining_space <= 0.05 * np.max(bins_remain_cap))\n        if np.any(almost_full_mask):\n            priorities[fit_mask][almost_full_mask] -= 0.5\n\n        # Introduce a bonus for bins that are already somewhat full, even if they aren't close to being completely full\n        # This helps to consolidate items into fewer bins\n        moderately_full_mask = (bins_remain_cap[fit_mask] < np.max(bins_remain_cap) * 0.75) & (bins_remain_cap[fit_mask] > np.max(bins_remain_cap) * 0.25)\n        if np.any(moderately_full_mask):\n            priorities[fit_mask][moderately_full_mask] += 0.75\n\n    else:\n        # If the item does not fit in any bin, assign a very low priority\n        priorities[:] = -np.inf\n\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 17.0,
    "cyclomatic_complexity": 5.0,
    "halstead": 153.80110650593844,
    "mi": 81.76199308105481,
    "token_count": 195.0,
    "exec_success": true
  }
]