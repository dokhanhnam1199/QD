[
  {
    "stdout_filepath": "problem_iter12_response0.txt_stdout.txt",
    "code_path": "problem_iter12_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Inverse distance weighting\n    distances = np.abs(bins_remain_cap - item)\n    priorities = 1.0 / (distances + 1e-9)\n\n    # Reward spacious bins\n    priorities[bins_remain_cap > item * 1.2] += 0.2\n\n    # Gently nudge near-full utilization\n    priorities[bins_remain_cap < item * 0.8] += 0.1\n\n    # Gently discourage almost empty bins\n    priorities[bins_remain_cap < item * 0.3] -= 0.02\n\n    # Ensure priorities are non-negative\n    priorities = np.maximum(priorities, 0.0)\n\n    return priorities",
    "response_id": 0,
    "obj": 4.228161148783416,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 165.05865002596164,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response1.txt_stdout.txt",
    "code_path": "problem_iter12_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Inverse distance weighting to remaining capacity\n    distances = np.abs(bins_remain_cap - item)\n    priorities = 1.0 / (distances + 1e-9)\n\n    # Reward spacious bins\n    priorities[bins_remain_cap > item * 1.2] += 0.3\n\n    # Reward moderate utilization\n    priorities[bins_remain_cap > item * 0.5] += 0.1\n\n    # Ensure priorities are non-negative\n    priorities = np.maximum(priorities, 0.0)\n    return priorities",
    "response_id": 1,
    "obj": 4.537295572397288,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 114.6940428629768,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response2.txt_stdout.txt",
    "code_path": "problem_iter12_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Relative capacity: how much of the bin is available for this item?\n    relative_capacity = bins_remain_cap / (bins_remain_cap + 1e-9)  # Avoid division by zero\n    priorities = 1.0 / (np.abs(relative_capacity - (item / bins_remain_cap)) + 1e-9)\n\n    # Reward higher utilization\n    priorities[bins_remain_cap > item * 1.2] += 0.2\n    priorities[bins_remain_cap > item * 0.8] += 0.1\n\n    # Gently penalize almost-full bins\n    priorities[bins_remain_cap < item * 0.5] -= 0.1\n\n    # Ensure priorities are non-negative\n    priorities = np.maximum(priorities, 0.0)\n    return priorities",
    "response_id": 2,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 211.51978731634918,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response3.txt_stdout.txt",
    "code_path": "problem_iter12_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Inverse distance to remaining capacity\n    distances = np.abs(bins_remain_cap - item)\n    priorities = 1.0 / (distances + 1e-9)\n\n    # Perfect fit bonus\n    perfect_fit_mask = np.isclose(bins_remain_cap, item)\n    priorities[perfect_fit_mask] += 1.0\n\n    # Spacious bin bonus\n    spacious_mask = bins_remain_cap > item * 1.5\n    priorities[spacious_mask] += 0.3\n\n    # Bonus for bins with enough space, but not too much\n    good_fit_mask = (bins_remain_cap >= item * 0.8) & (bins_remain_cap <= item * 2)\n    priorities[good_fit_mask] += 0.2\n\n    return priorities",
    "response_id": 3,
    "obj": 2.2138013562026373,
    "SLOC": 11.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 185.4406125843753,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response4.txt_stdout.txt",
    "code_path": "problem_iter12_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    distances = np.abs(bins_remain_cap - item)\n    priorities = 1.0 / (distances + 1e-9)  # Inverse distance\n\n    # Boost bins with ample remaining capacity\n    priorities[bins_remain_cap > item * 2] += 0.8\n    # Significant boost for perfect or near-perfect fits\n    priorities[np.abs(bins_remain_cap - item) < 1e-6] += 2.5\n\n    # Moderate boost for near-perfect fits (within 1% of bin capacity)\n    priorities[np.abs(bins_remain_cap - item) < item * 0.01] += 1.0\n\n    return priorities",
    "response_id": 4,
    "obj": 2.143996808934982,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 178.81353752812512,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response5.txt_stdout.txt",
    "code_path": "problem_iter12_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    distances = np.abs(bins_remain_cap - item)\n    priorities = 1.0 / (distances + 1e-9)  # Inverse distance\n\n    # Boost bins with ample remaining capacity (more than twice the item size)\n    priorities[bins_remain_cap > item * 2] += 0.8\n\n    # Further boost bins where item fits perfectly or nearly perfectly\n    priorities[np.abs(bins_remain_cap - item) < 1e-6] += 1.5\n\n    # Add a small constant to all bins to ensure no zero priorities and avoid overly strong preference\n    priorities += 0.03\n\n    return priorities",
    "response_id": 5,
    "obj": 2.143996808934982,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 133.78294855911892,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response6.txt_stdout.txt",
    "code_path": "problem_iter12_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Input validation\n    if np.any(bins_remain_cap < 0):\n        raise ValueError(\"Negative bin capacity encountered.\")\n\n    # Inverse distance to remaining capacity\n    distances = np.abs(bins_remain_cap - item)\n    priorities = 1.0 / (distances + 1e-9)\n\n    # Perfect fit bonus\n    perfect_fit_mask = np.isclose(bins_remain_cap, item)\n    priorities[perfect_fit_mask] += 2.0\n\n    # Near-perfect fit bonus\n    near_perfect_mask = np.abs(bins_remain_cap - item) < 0.05 * item\n    priorities[near_perfect_mask] += 1.0\n\n    # Spacious bin bonus\n    spacious_mask = bins_remain_cap > item * 1.5\n    priorities[spacious_mask] += 0.5\n\n    # Gentle penalty for almost-full bins\n    almost_full_mask = bins_remain_cap < item * 0.5\n    priorities[almost_full_mask] += 0.1\n\n    return priorities",
    "response_id": 6,
    "obj": 2.193857199840447,
    "SLOC": 15.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 211.51978731634918,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response7.txt_stdout.txt",
    "code_path": "problem_iter12_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Inverse distance weighting\n    distances = np.abs(bins_remain_cap - item)\n    priorities = 1.0 / (distances + 1e-9)\n\n    # Reward spacious bins\n    priorities[bins_remain_cap > item * 1.5] += 0.2\n\n    # Reward near-full utilization (gentle)\n    priorities[bins_remain_cap < item * 0.75] += 0.1\n\n    # Gently penalize almost full bins\n    priorities[bins_remain_cap < item * 0.25] -= 0.05\n\n    # Ensure priorities are non-negative\n    priorities = np.maximum(priorities, 0.0)\n\n    return priorities",
    "response_id": 7,
    "obj": 1.6952532907858,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 165.05865002596164,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response8.txt_stdout.txt",
    "code_path": "problem_iter12_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    distances = np.abs(bins_remain_cap - item)\n\n    # Base priority: inverse of distance to full capacity\n    priorities = 1.0 / (distances + 1e-9)\n\n    # Boost bins with ample remaining capacity (more than twice the item size)\n    priorities[bins_remain_cap > item * 2] += 0.7\n\n    # Further boost bins where item fits perfectly or nearly perfectly\n    perfect_fit = np.abs(bins_remain_cap - item) < 1e-6\n    priorities[perfect_fit] += 1.5\n\n    # Boost bins where item fits well proportionally\n    good_fit = (bins_remain_cap >= item * 0.7) & (bins_remain_cap <= item * 2.5)\n    priorities[good_fit] += 0.4\n\n    # Slightly penalize bins that are almost full\n    priorities[distances < item * 0.1] -= 0.3\n\n    # Penalize bins that are much larger than the item\n    priorities[bins_remain_cap > item * 5] -= 0.2\n\n    return priorities",
    "response_id": 8,
    "obj": 2.7822098125249393,
    "SLOC": 12.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 330.61943334694587,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response9.txt_stdout.txt",
    "code_path": "problem_iter12_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    distances = np.abs(bins_remain_cap - item)\n    \n    # Inverse distance weighting\n    priorities = 1.0 / (distances + 1e-9)\n\n    # Reward good fit (close to perfect)\n    priorities[distances < 0.1] += 0.5\n    \n    # Penalize waste (large remaining capacity after adding item)\n    priorities[bins_remain_cap > item * 2] -= 0.1\n    \n    # Ensure non-negative priorities\n    priorities = np.maximum(priorities, 0.0)\n    \n    return priorities",
    "response_id": 9,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 100.07820003461549,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter13_response0.txt_stdout.txt",
    "code_path": "problem_iter13_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Calculate the ratio of item size to remaining bin capacity\n    ratios = item / bins_remain_cap\n    # Assign a higher priority to bins where the item fits well (ratio close to 1)\n    # and avoid penalizing nearly full bins too strongly\n    priorities = 1.0 / (np.abs(ratios - 1.0) + 1e-9)\n    # Reward spacious bins\n    priorities[bins_remain_cap > item * 1.5] += 0.1\n    # Gentle reward for bins with moderate utilization\n    priorities[bins_remain_cap > item * 0.5] += 0.05\n\n    # Ensure priorities are non-negative\n    priorities = np.maximum(priorities, 0.0)\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 129.65784284662087,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter13_response1.txt_stdout.txt",
    "code_path": "problem_iter13_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Calculate the 'fit' score - how well the item fits into the remaining capacity.\n    fit_score = item / (bins_remain_cap + 1e-9)  # Avoid division by zero\n    priorities = fit_score\n\n    # Reward bins where the item fits well (close to perfect fit).\n    priorities[np.abs(fit_score - 1.0) < 0.1] += 0.3\n\n    # Reward spacious bins (more remaining capacity).\n    priorities += bins_remain_cap / np.max(bins_remain_cap) * 0.1\n\n    # Penalize almost full bins gently. Avoid strong penalties.\n    priorities[bins_remain_cap < item * 0.2] -= 0.05\n\n    # Ensure priorities are non-negative.\n    priorities = np.maximum(priorities, 0.0)\n\n    return priorities",
    "response_id": 1,
    "obj": 4.058635819704831,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 149.27754454988144,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter13_response2.txt_stdout.txt",
    "code_path": "problem_iter13_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Calculate the relative fit (how well the item fits in each bin)\n    fit = bins_remain_cap / item\n    fit[bins_remain_cap < item] = 0.0  # Penalize bins that are too small\n\n    # Base priority: Prefer bins with a good fit\n    priorities = fit\n\n    # Reward spacious bins (moderate utilization)\n    priorities[bins_remain_cap > item * 1.5] += 0.1\n\n    # Gently nudge towards filling bins that are already partially used\n    priorities[bins_remain_cap < item * 0.5] += 0.05\n\n    # Ensure priorities are non-negative\n    priorities = np.maximum(priorities, 0.0)\n\n    return priorities",
    "response_id": 2,
    "obj": 149.30195452732352,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 93.76537429460444,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter13_response3.txt_stdout.txt",
    "code_path": "problem_iter13_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Calculate how well the item fits into each bin\n    fit = bins_remain_cap / item\n    fit = np.clip(fit, 0.0, 3.0)  # Cap fit at 3.0 to avoid extreme values\n\n    # Reward good fits (close to 1.0)\n    priorities = np.exp(-((fit - 1.0) ** 2) / 0.2)\n\n    # Reward spacious bins (remaining capacity > item size)\n    priorities[bins_remain_cap > item] += 0.1\n\n    # Gently nudge towards moderate utilization (avoiding very full bins)\n    priorities[bins_remain_cap < item * 0.5] += 0.05\n\n    return priorities",
    "response_id": 3,
    "obj": 4.547267650578394,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 131.18329672565338,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter13_response4.txt_stdout.txt",
    "code_path": "problem_iter13_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Calculate the ratio of item size to remaining bin capacity\n    ratios = item / (bins_remain_cap + 1e-9)  # Avoid division by zero\n\n    # Reward bins where the item fits well (ratio close to 1)\n    priorities = np.exp(- (ratios - 1)**2 / 0.1)  # Gaussian-like reward\n\n    # Encourage using more spacious bins\n    priorities += 0.1 * (bins_remain_cap / np.max(bins_remain_cap))\n\n    # Slight encouragement for bins with moderate utilization\n    priorities[bins_remain_cap > item * 0.5] += 0.05\n\n    # Ensure priorities are non-negative\n    priorities = np.maximum(priorities, 0.0)\n    return priorities",
    "response_id": 4,
    "obj": 3.9988033506182825,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 164.51539013493823,
    "exec_success": true
  }
]