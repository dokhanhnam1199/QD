[
  {
    "stdout_filepath": "problem_iter24_response0.txt_stdout.txt",
    "code_path": "problem_iter24_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Fit: Inverse distance to ideal fit\n    fit_bins = bins_remain_cap >= item\n    if np.any(fit_bins):\n        priorities[fit_bins] = 1.0 / (bins_remain_cap[fit_bins] - item + 1e-9)\n\n    # Spaciousness: Reward bins with ample remaining capacity\n    spacious_bins = bins_remain_cap > item * 2.0\n    priorities[spacious_bins] += 0.7\n\n    # Near-full: Prioritize filling bins almost completely\n    near_full_bins = np.abs(bins_remain_cap - item) < item * 0.3\n    priorities[near_full_bins] += 1.2\n\n    # Small bonus to all bins, but significantly less than other factors\n    priorities += 0.05\n\n    return priorities",
    "response_id": 0,
    "obj": 4.13841244515357,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 167.17882283189007,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter24_response1.txt_stdout.txt",
    "code_path": "problem_iter24_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Inverse distance to remaining capacity (smooth weighting)\n    distances = np.abs(bins_remain_cap - item)\n    priorities = 1.0 / (distances + 1e-9)\n\n    # Bonus for spacious bins\n    priorities[bins_remain_cap > item * 2] += 0.1\n\n    # Bonus for near-full bins\n    priorities[bins_remain_cap < item * 0.5] += 0.1\n\n    return priorities",
    "response_id": 1,
    "obj": 3.3506182688472412,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 114.6940428629768,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter24_response2.txt_stdout.txt",
    "code_path": "problem_iter24_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    relative_cap = bins_remain_cap / np.max(bins_remain_cap)\n    priorities = 1.0 / (np.abs(relative_cap - (item / np.max(bins_remain_cap))) + 1e-9)\n    priorities[relative_cap > (item / np.max(bins_remain_cap)) * 1.2] += 0.1\n    priorities[relative_cap < (item / np.max(bins_remain_cap)) * 0.8] += 0.1\n    return priorities",
    "response_id": 2,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 185.4406125843753,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter24_response3.txt_stdout.txt",
    "code_path": "problem_iter24_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Fit: Inverse distance to ideal fit\n    fit_bins = bins_remain_cap >= item\n    if np.any(fit_bins):\n        priorities[fit_bins] = 1.0 / (bins_remain_cap[fit_bins] - item + 1e-9)\n\n    # Spaciousness: Reward bins with ample remaining capacity\n    spacious_bins = bins_remain_cap > item * 1.5\n    priorities[spacious_bins] += 0.4\n\n    # Nearly-full: Prioritize filling bins almost completely\n    nearly_full_bins = np.abs(bins_remain_cap - item) < item * 0.3\n    priorities[nearly_full_bins] += 0.8\n\n    # Small bonus to all bins to encourage use, but less than fit/nearly_full\n    priorities += 0.01\n\n    return priorities",
    "response_id": 3,
    "obj": 3.470283207020339,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 167.17882283189007,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter24_response4.txt_stdout.txt",
    "code_path": "problem_iter24_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Feasible Fit: Inverse distance to remaining capacity\n    fit_bins = bins_remain_cap >= item\n    if np.any(fit_bins):\n        priorities[fit_bins] = 1.0 / (bins_remain_cap[fit_bins] - item + 1e-9)\n\n    # Spaciousness: Reward bins with ample remaining capacity\n    spacious_bins = bins_remain_cap > item * 1.5\n    priorities[spacious_bins] += 0.5\n\n    # Near-full: Prioritize filling bins almost completely\n    near_full_bins = np.abs(bins_remain_cap - item) < item * 0.3\n    priorities[near_full_bins] += 1.0\n\n    # Small bonus to all bins to encourage use, but less than spacious/near-full\n    priorities += 0.01\n\n    return priorities",
    "response_id": 4,
    "obj": 3.470283207020339,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 165.05865002596164,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter24_response5.txt_stdout.txt",
    "code_path": "problem_iter24_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Fit: Inverse distance to remaining capacity\n    distances = np.abs(bins_remain_cap - item)\n    priorities = 1.0 / (distances + 1e-9)  # Avoid division by zero\n\n    # Utilization bonus: Encourage filling bins, but scaled by remaining capacity\n    for i in range(len(bins_remain_cap)):\n        if bins_remain_cap[i] > item:\n            priorities[i] += 0.02 * (bins_remain_cap[i] / item - 1)\n        \n    # Small gap bonus\n    if np.any(np.abs(bins_remain_cap - item) < item * 0.2):\n        priorities[np.abs(bins_remain_cap - item) < item * 0.2] += 0.05\n    \n\n    return priorities",
    "response_id": 5,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.99997024000004 seconds"
  },
  {
    "stdout_filepath": "problem_iter24_response6.txt_stdout.txt",
    "code_path": "problem_iter24_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Fit: Inverse distance to ideal fit\n    fit_bins = bins_remain_cap >= item\n    if np.any(fit_bins):\n        priorities[fit_bins] = 1.0 / (bins_remain_cap[fit_bins] - item + 1e-9)\n\n    # Spaciousness: Reward bins with moderate remaining capacity\n    spacious_bins = (bins_remain_cap > item) & (bins_remain_cap <= item * 2)\n    priorities[spacious_bins] += 0.3\n\n    # Near-full: Prioritize filling bins almost completely\n    near_full_bins = np.abs(bins_remain_cap - item) < item * 0.15\n    priorities[near_full_bins] += 1.0\n\n    # Small bonus to all bins to encourage use\n    priorities += 0.003\n\n    return priorities",
    "response_id": 6,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 201.90890672641936,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter24_response7.txt_stdout.txt",
    "code_path": "problem_iter24_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Fit: Prioritize bins where the item fits well\n    fit_bins = bins_remain_cap >= item\n    priorities[fit_bins] = 1.0 / (bins_remain_cap[fit_bins] - item + 1e-9)\n\n    # Spaciousness: Reward bins with ample remaining capacity\n    spacious_bins = bins_remain_cap > item * 1.2\n    priorities[spacious_bins] += 0.3\n\n    # Near-full: Prioritize bins that are nearly full\n    near_full_bins = np.abs(bins_remain_cap - item) < item * 0.5\n    priorities[near_full_bins] += 0.7\n\n    # Small bonus to all usable bins to encourage their use, diminishing over time\n    priorities[fit_bins] += 0.01\n\n    return priorities",
    "response_id": 7,
    "obj": 4.367770243318703,
    "SLOC": 10.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 167.17882283189007,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter24_response8.txt_stdout.txt",
    "code_path": "problem_iter24_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    # Prioritize feasible bins\n    fit_bins = bins_remain_cap >= item\n    if np.any(fit_bins):\n        priorities[fit_bins] = 1.0 / (bins_remain_cap[fit_bins] - item + 1e-9)  # Inverse remaining capacity\n\n    # Reward bins with a good fit (small gap)\n    priorities[np.abs(bins_remain_cap - item) < item * 0.3] += 0.5\n\n    # Encourage exploration with a small constant\n    priorities += 0.01\n\n    return priorities",
    "response_id": 8,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 116.69205856195879,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter24_response9.txt_stdout.txt",
    "code_path": "problem_iter24_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Calculate relative capacity\n    relative_capacity = bins_remain_cap / item\n\n    # Base priority: Inverse distance to ideal fill (1.0)\n    distances = np.abs(relative_capacity - 1.0)\n    priorities = 1.0 / (distances + 1e-9)\n\n    # Reward bins with moderate remaining capacity (between 0.8 and 1.2)\n    priorities[(relative_capacity >= 0.8) & (relative_capacity <= 1.2)] += 0.02\n\n    # Reward spacious bins (relative capacity > 1.5) - slightly less than v1\n    priorities[relative_capacity > 1.5] += 0.01\n\n    # Gently penalize almost-full bins (relative capacity < 0.5) - slightly stronger penalty\n    priorities[relative_capacity < 0.5] -= 0.01\n\n    # Ensure priorities are non-negative\n    priorities = np.maximum(priorities, 0.0)\n\n    return priorities",
    "response_id": 9,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 169.21582985307933,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter25_response0.txt_stdout.txt",
    "code_path": "problem_iter25_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Fit: Inverse distance to remaining capacity\n    distances = np.abs(bins_remain_cap - item)\n    priorities = 1.0 / (distances + 1e-9)\n\n    # Relative capacity: Reward near-full bins & spaciousness (tuned bonuses)\n    priorities[bins_remain_cap >= item * 1.5] += 0.1  # Spacious bins\n    priorities[bins_remain_cap <= item * 0.5] += 0.05 # Near-full bins\n\n    # Ensure non-negative priorities\n    priorities = np.maximum(priorities, 0.0)\n    return priorities",
    "response_id": 0,
    "obj": 2.752293577981665,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 116.69205856195879,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter25_response1.txt_stdout.txt",
    "code_path": "problem_iter25_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Fit: Inverse distance to remaining capacity\n    distances = np.abs(bins_remain_cap - item)\n    priorities = 1.0 / (distances + 1e-9)  # Avoid division by zero\n\n    # Relative Capacity: Reward bins where item fits well\n    fit_ratio = bins_remain_cap / item\n    priorities[fit_ratio > 0.5] += 0.1  # Moderate reward for good fit\n    priorities[fit_ratio < 2.0] += 0.05 # Reward bins that aren't excessively large for the item\n\n    # Spaciousness & Near-Full: Small bonuses\n    priorities[bins_remain_cap > item * 1.5] += 0.05  # Slightly reward spacious bins\n    priorities[bins_remain_cap < item * 0.5] += 0.03  # Slightly reward near-full bins\n\n    # Ensure priorities are non-negative\n    priorities = np.maximum(priorities, 0.0)\n\n    return priorities",
    "response_id": 1,
    "obj": 3.8990825688073536,
    "SLOC": 11.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 195.04195997053841,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter25_response2.txt_stdout.txt",
    "code_path": "problem_iter25_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    # Fit: Prioritize bins where the item fits\n    fit_mask = bins_remain_cap >= item\n    priorities[fit_mask] = 1.0 / (bins_remain_cap[fit_mask] - item + 1e-9)\n    \n    # Relative Capacity: Reward bins where the item uses a significant portion\n    # but avoid extremely small bins\n    relative_capacity = item / bins_remain_cap\n    relative_capacity = np.clip(relative_capacity, 0.05, 0.95)\n    priorities[fit_mask] += relative_capacity\n    \n    # Spaciousness: Small bonus for bins with ample space\n    priorities[bins_remain_cap > item * 1.5] += 0.05\n    \n    # Near-full bins: Small bonus for almost full bins\n    priorities[bins_remain_cap < item * 0.5] += 0.02\n    \n    return priorities",
    "response_id": 2,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 21, in priority_v2\n    # Ensure priorities are non-negative\nnumpy._core._exceptions._UFuncOutputCastingError: Cannot cast ufunc 'add' output from dtype('float64') to dtype('int64') with casting rule 'same_kind'\n10\n1\n165.05865002596164\n"
  },
  {
    "stdout_filepath": "problem_iter25_response3.txt_stdout.txt",
    "code_path": "problem_iter25_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Fit: Inverse distance to remaining capacity\n    distances = np.abs(bins_remain_cap - item)\n    priorities = 1.0 / (distances + 1e-9)\n\n    # Relative capacity: Reward spaciousness and near-full bins\n    priorities[bins_remain_cap > item * 1.2] += 0.1  # Gently reward spacious bins\n    priorities[bins_remain_cap < item * 0.8] += 0.15 # Gently reward near-full bins\n\n    # Ensure priorities are non-negative\n    priorities = np.maximum(priorities, 0.0)\n\n    return priorities",
    "response_id": 3,
    "obj": 4.038691663342641,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 116.69205856195879,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter25_response4.txt_stdout.txt",
    "code_path": "problem_iter25_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Fit: Inverse distance to remaining capacity\n    distances = np.abs(bins_remain_cap - item)\n    priorities = 1.0 / (distances + 1e-9)\n\n    # Relative Capacity: Reward near-full and spacious bins\n    priorities[bins_remain_cap >= item * 1.5] += 0.1  # Spacious\n    priorities[bins_remain_cap <= item * 0.5] += 0.05 # Near-full\n\n    # Ensure priorities are non-negative\n    priorities = np.maximum(priorities, 0.0)\n    return priorities",
    "response_id": 4,
    "obj": 2.752293577981665,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 116.69205856195879,
    "exec_success": true
  }
]