[
  {
    "stdout_filepath": "problem_iter22_response0.txt_stdout.txt",
    "code_path": "problem_iter22_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Fit: Inverse distance to ideal fit\n    fit_bins = bins_remain_cap >= item\n    if np.any(fit_bins):\n        priorities[fit_bins] = 1.0 / (bins_remain_cap[fit_bins] - item + 1e-9)\n\n    # Ample space: Reward spaciousness\n    ample_space = bins_remain_cap > item * 1.5\n    priorities[ample_space] += 0.5\n\n    # Near-full: Prioritize filling bins almost completely\n    near_full = np.abs(bins_remain_cap - item) < item * 0.2\n    priorities[near_full] += 1.0\n\n    # Small bonus to all bins to encourage use, but less than fit/near_full\n    priorities += 0.01\n\n    return priorities",
    "response_id": 0,
    "obj": 2.5927403270841647,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 165.05865002596164,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter22_response1.txt_stdout.txt",
    "code_path": "problem_iter22_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Inverse distance weighting to remaining capacity\n    distances = np.abs(bins_remain_cap - item)\n    priorities = 1.0 / (distances + 1e-9)\n\n    # Reward spacious bins (relative to item size)\n    priorities[bins_remain_cap > item * 2.0] += 0.3\n\n    # Reward near-full utilization (relative to item size)\n    priorities[bins_remain_cap < item * 0.5] += 0.2\n\n    # Reward bins where item fits well (not too small, not too large)\n    priorities[(bins_remain_cap >= item * 0.5) & (bins_remain_cap <= item * 1.5)] += 0.1\n\n    # Ensure priorities are non-negative\n    priorities = np.maximum(priorities, 0.0)\n\n    return priorities",
    "response_id": 1,
    "obj": 2.3733546071001155,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 220.81007680238335,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter22_response2.txt_stdout.txt",
    "code_path": "problem_iter22_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Fit: Inverse distance to ideal fit\n    fit_bins = bins_remain_cap >= item\n    if np.any(fit_bins):\n        priorities[fit_bins] = 1.0 / (bins_remain_cap[fit_bins] - item + 1e-9)\n\n    # Spaciousness: Reward bins with ample remaining capacity\n    spacious_bins = bins_remain_cap > item * 1.5\n    priorities[spacious_bins] += 0.4\n\n    # Near-full: Prioritize filling bins almost completely\n    near_full_bins = np.abs(bins_remain_cap - item) < item * 0.2\n    priorities[near_full_bins] += 0.9\n\n    # Small bonus to all bins to encourage use\n    priorities += 0.005\n\n    return priorities",
    "response_id": 2,
    "obj": 2.5927403270841647,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 167.17882283189007,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter22_response3.txt_stdout.txt",
    "code_path": "problem_iter22_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Prioritize feasible bins\n    fit_bins = bins_remain_cap >= item\n    if np.any(fit_bins):\n        priorities[fit_bins] = 1.0 / (bins_remain_cap[fit_bins] - item + 1e-9)  # Inverse remaining capacity\n\n    # Reward bins with ample remaining capacity\n    priorities[bins_remain_cap > item * 1.2] += 0.3\n\n    # Reward bins with a good fit (small gap)\n    priorities[np.abs(bins_remain_cap - item) < item * 0.3] += 0.4\n\n    # Encourage exploration with a small constant\n    priorities += 0.01\n\n    return priorities",
    "response_id": 3,
    "obj": 4.208216992421225,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 165.05865002596164,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter22_response4.txt_stdout.txt",
    "code_path": "problem_iter22_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Calculate relative capacity\n    relative_capacity = bins_remain_cap / item\n\n    # Base priority: Inverse distance to item size\n    distances = np.abs(relative_capacity - 1.0)\n    priorities = 1.0 / (distances + 1e-9)\n\n    # Reward spacious bins (relative capacity > 1.5)\n    priorities[relative_capacity > 1.5] += 0.015\n\n    # Reward near-full utilization (relative capacity between 0.5 and 1)\n    priorities[(relative_capacity >= 0.5) & (relative_capacity < 1.0)] += 0.01\n\n    # Gently penalize almost-full bins (relative capacity < 0.3)\n    priorities[relative_capacity < 0.3] -= 0.005\n\n    # Ensure priorities are non-negative\n    priorities = np.maximum(priorities, 0.0)\n    return priorities",
    "response_id": 4,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 167.17882283189007,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter22_response5.txt_stdout.txt",
    "code_path": "problem_iter22_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    # Prioritize bins where the item fits\n    fit_bins = bins_remain_cap >= item\n    if np.any(fit_bins):\n        remaining_after_add = bins_remain_cap[fit_bins] - item\n        priorities[fit_bins] = 1.0 / (remaining_after_add + 1e-9)  # Inverse remaining capacity\n\n    # Reward bins with ample remaining capacity (not too full)\n    priorities[bins_remain_cap > item * 1.2] += 0.5\n\n    # Reward bins where the item fits very well (small gap)\n    priorities[np.abs(bins_remain_cap - item) < item * 0.2] += 1.0\n\n    # Add a small constant to all bins to avoid zero priorities and encourage exploration\n    priorities += 0.001\n    return priorities",
    "response_id": 5,
    "obj": 4.068607897885915,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 165.05865002596164,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter22_response6.txt_stdout.txt",
    "code_path": "problem_iter22_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Inverse distance weighting - baseline\n    distances = np.abs(bins_remain_cap - item)\n    priorities = 1.0 / (distances + 1e-9)\n\n    # Reward bins with sufficient capacity (at least item size)\n    priorities[bins_remain_cap >= item] += 0.2\n\n    # Reward bins where item fits well (not too much wasted space)\n    priorities[(bins_remain_cap >= item * 0.5) & (bins_remain_cap < item * 1.5)] += 0.3\n\n    # Penalize almost full bins - avoid creating new bins unnecessarily.\n    priorities[bins_remain_cap < item * 0.2] -= 0.1\n\n    # Ensure priorities are non-negative\n    priorities = np.maximum(priorities, 0.0)\n\n    return priorities",
    "response_id": 6,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 197.4184681619259,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter22_response7.txt_stdout.txt",
    "code_path": "problem_iter22_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Fit: Inverse distance to ideal fit\n    fit_bins = bins_remain_cap >= item\n    priorities[fit_bins] = 1.0 / (bins_remain_cap[fit_bins] - item + 1e-9)\n\n    # Ample space: Reward spaciousness\n    ample_space = bins_remain_cap > item * 2.0  # Increased spaciousness threshold\n    priorities[ample_space] += 0.5\n\n    # Near-full: Prioritize filling bins almost completely\n    near_full = np.abs(bins_remain_cap - item) < item * 0.3  # Adjusted near-full threshold\n    priorities[near_full] += 1.2\n\n    # Small bonus to all bins to encourage use (reduced weight)\n    priorities += 0.001\n\n    return priorities",
    "response_id": 7,
    "obj": 4.13841244515357,
    "SLOC": 10.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 167.17882283189007,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter22_response8.txt_stdout.txt",
    "code_path": "problem_iter22_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Fit: Inverse distance to item size.\n    distances = np.abs(bins_remain_cap - item)\n    priorities = 1.0 / (distances + 1e-9)\n\n    # Gentle rewards for specific remaining capacity ranges.\n    # Reward bins with enough space, but not excessively large.\n    priorities[np.logical_and(bins_remain_cap >= item * 1.05, bins_remain_cap < item * 1.5)] += 0.05\n    # Reward bins that are nearly full.\n    priorities[np.logical_and(bins_remain_cap < item * 1.1, bins_remain_cap >= item * 0.9)] += 0.07\n\n    # Penalize bins that are too small\n    priorities[bins_remain_cap < item] = 0.0\n\n    # Ensure priorities are non-negative.\n    priorities = np.maximum(priorities, 0.0)\n    return priorities",
    "response_id": 8,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 192.56842503028858,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter22_response9.txt_stdout.txt",
    "code_path": "problem_iter22_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Fit: Inverse distance to ideal fit\n    fit_bins = bins_remain_cap >= item\n    priorities[fit_bins] = 1.0 / (bins_remain_cap[fit_bins] - item + 1e-9)\n\n    # Ample space: Reward spaciousness\n    ample_space = bins_remain_cap > item * 1.5\n    priorities[ample_space] += 0.5\n\n    # Near-full: Prioritize filling bins almost completely\n    near_full = np.abs(bins_remain_cap - item) < item * 0.3\n    priorities[near_full] += 1.0\n\n    # Small bonus to all bins to encourage use, but diminish over time\n    priorities += 0.001\n\n    return priorities",
    "response_id": 9,
    "obj": 3.470283207020339,
    "SLOC": 10.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 165.05865002596164,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter23_response0.txt_stdout.txt",
    "code_path": "problem_iter23_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Fit score: How well the item fits in the bin\n    fit_score = item / (bins_remain_cap + 1e-9)\n    priorities = 1.0 - fit_score  # Lower fit score means higher priority\n\n    # Relative capacity bonus: Reward bins with reasonable remaining capacity\n    # Encourage using spacious bins (but not excessively)\n    spacious_bonus = np.where(bins_remain_cap > item * 1.5, 0.1, 0.0)\n    # Gently reward near-full bins\n    near_full_bonus = np.where(bins_remain_cap < item * 0.5, 0.05, 0.0)\n\n    priorities += spacious_bonus + near_full_bonus\n\n    # Ensure priorities are non-negative\n    priorities = np.maximum(priorities, 0.0)\n    return priorities",
    "response_id": 0,
    "obj": 149.30195452732352,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 116.69205856195879,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter23_response1.txt_stdout.txt",
    "code_path": "problem_iter23_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Fit score: Prefer bins where the item fits well\n    fit_score = np.where(bins_remain_cap >= item, 1.0 / (bins_remain_cap - item + 1e-9), 0.0)\n    priorities = fit_score\n\n    # Relative capacity bonus: Reward bins that are neither too empty nor too full\n    remaining_ratio = bins_remain_cap / np.max(bins_remain_cap)\n    \n    # Give a small bonus to bins with remaining capacity between 0.25 and 0.75\n    bonus = np.where((remaining_ratio >= 0.25) & (remaining_ratio <= 0.75), 0.1, 0.0)\n    priorities += bonus\n\n    # Gentle reward for near-full bins, but only if they can still fit the item\n    near_full_bonus = np.where((bins_remain_cap < item * 0.1) & (bins_remain_cap >= item), 0.05, 0.0)\n    priorities += near_full_bonus\n    \n    return priorities",
    "response_id": 1,
    "obj": 4.038691663342641,
    "SLOC": 10.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 199.7052750908657,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter23_response2.txt_stdout.txt",
    "code_path": "problem_iter23_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Fit: Inverse distance to remaining capacity\n    distances = np.abs(bins_remain_cap - item)\n    priorities = 1.0 / (distances + 1e-9)  # Avoid division by zero\n\n    # Relative Capacity - Bonus for near-full and spacious bins\n    # Gentle rewards, conditional\n    priorities[bins_remain_cap >= item * 1.5] += 0.1  # Spacious bins\n    priorities[bins_remain_cap <= item * 0.5] += 0.1  # Near-full bins\n\n    # Ensure non-negative priorities\n    priorities = np.maximum(priorities, 0.0)\n    return priorities",
    "response_id": 2,
    "obj": 2.752293577981665,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 114.6940428629768,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter23_response3.txt_stdout.txt",
    "code_path": "problem_iter23_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Fit: Inverse distance to remaining capacity\n    distances = np.abs(bins_remain_cap - item)\n    priorities = 1.0 / (distances + 1e-9)  # Avoid division by zero\n\n    # Relative Capacity: Encourage utilization, but gently\n    for i in range(len(bins_remain_cap)):\n        if bins_remain_cap[i] > item * 1.5:\n            priorities[i] += 0.1  # Spacious bin bonus\n        elif bins_remain_cap[i] < item * 0.5:\n            priorities[i] += 0.05 # Near-full bonus (smaller reward)\n\n    # Ensure non-negativity\n    priorities = np.maximum(priorities, 0.0)\n\n    return priorities",
    "response_id": 3,
    "obj": 2.8021539688871298,
    "SLOC": 11.0,
    "cyclomatic_complexity": 4.0,
    "halstead": 120.40465370320703,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter23_response4.txt_stdout.txt",
    "code_path": "problem_iter23_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Fit score: how well the item fits in the bin\n    fit_score = item / (bins_remain_cap + 1e-9)\n    priorities = 1.0 - fit_score  # Higher score for better fit\n\n    # Relative capacity bonus: reward bins that are neither too full nor too empty\n    relative_cap = bins_remain_cap / (np.max(bins_remain_cap) + 1e-9)\n    bonus = np.exp(-((relative_cap - 0.5) ** 2) / 0.05)  # Gaussian centered at 0.5\n    priorities += 0.1 * bonus\n\n    # Small bonus for near-full bins (encourage closing bins)\n    priorities[bins_remain_cap < item * 0.2] += 0.05\n    \n    # Ensure priorities are non-negative\n    priorities = np.maximum(priorities, 0.0)\n    return priorities",
    "response_id": 4,
    "obj": 143.777423214998,
    "SLOC": 10.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 199.1772208002305,
    "exec_success": true
  }
]