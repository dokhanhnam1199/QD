[
  {
    "stdout_filepath": "problem_iter18_response0.txt_stdout.txt",
    "code_path": "problem_iter18_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    # Inverse distance weighting\n    distances = np.abs(bins_remain_cap - item)\n    priorities = 1.0 / (distances + 1e-9)\n\n    # Reward spacious bins\n    priorities[bins_remain_cap > item * 1.1] += 0.05\n\n    # Reward near-full utilization (gentle)\n    priorities[bins_remain_cap < item * 0.8] += 0.03\n\n    # Gently penalize almost-full bins\n    priorities[bins_remain_cap < item * 0.3] -= 0.01\n\n    # Ensure priorities are non-negative\n    priorities = np.maximum(priorities, 0.0)\n    return priorities",
    "response_id": 0,
    "obj": 4.01874750698045,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 165.05865002596164,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter18_response1.txt_stdout.txt",
    "code_path": "problem_iter18_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    distances = np.abs(bins_remain_cap - item)\n    priorities = 1.0 / (distances + 1e-9)  # Reward minimal wasted space\n\n    # Dynamically adjust weights based on item size relative to bin capacity\n    if item <= bins_remain_cap.mean() / 2:\n        # For smaller items, prioritize spacious bins\n        priorities[bins_remain_cap > item * 1.5] += 0.4\n    else:\n        # For larger items, prioritize tighter fits\n        priorities[bins_remain_cap < item * 0.5] += 0.3\n\n    priorities = np.maximum(priorities, 0.0)\n    return priorities",
    "response_id": 1,
    "obj": 1.9944156362185879,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 151.30376252379818,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter18_response2.txt_stdout.txt",
    "code_path": "problem_iter18_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    distances = np.abs(bins_remain_cap - item)\n    priorities = 1.0 / (distances + 1e-9)  # Reward bins where the item fits well\n\n    # Reward bins that are neither too full nor too empty\n    fit_range_lower = item * 0.7\n    fit_range_upper = item * 1.3\n    priorities[(bins_remain_cap >= fit_range_lower) & (bins_remain_cap <= fit_range_upper)] += 0.3\n\n    # Gently reward spacious bins\n    priorities[bins_remain_cap > item * 1.5] += 0.1\n\n    # Penalize bins that are almost full (avoid creating new bins unnecessarily)\n    priorities[bins_remain_cap < item * 0.3] -= 0.2\n\n    # Ensure non-negative priorities\n    priorities = np.maximum(priorities, 0.0)\n    return priorities",
    "response_id": 2,
    "obj": 3.5500598324691004,
    "SLOC": 11.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 220.81007680238335,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter18_response3.txt_stdout.txt",
    "code_path": "problem_iter18_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    distances = np.abs(bins_remain_cap - item)\n    priorities = 1.0 / (distances + 1e-9)  # Inverse distance\n\n    # Reward spacious bins\n    priorities[bins_remain_cap > item * 2] += 0.05\n\n    # Reward near-full utilization\n    priorities[bins_remain_cap < item * 0.5] += 0.05\n\n    # Ensure non-negative priorities\n    priorities = np.maximum(priorities, 0.0)\n    return priorities",
    "response_id": 3,
    "obj": 5.404866374152379,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 114.6940428629768,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter18_response4.txt_stdout.txt",
    "code_path": "problem_iter18_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Inverse distance to item size\n    distances = np.abs(bins_remain_cap - item)\n    priorities = 1.0 / (distances + 1e-9)\n\n    # Reward spaciousness (large remaining capacity)\n    priorities += 0.2 * (bins_remain_cap / (item + 1e-9))\n\n    # Reward near-full utilization (small remaining capacity)\n    priorities += 0.1 * (1.0 / (bins_remain_cap + 1e-9))\n\n    # Ensure priorities are non-negative\n    priorities = np.maximum(priorities, 0.0)\n    return priorities",
    "response_id": 4,
    "obj": 79.54726765057839,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 140.1816079436383,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter18_response5.txt_stdout.txt",
    "code_path": "problem_iter18_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    # Prioritize bins where the item fits\n    fit_bins = bins_remain_cap >= item\n    if np.any(fit_bins):\n        remaining_after_add = bins_remain_cap[fit_bins] - item\n        priorities[fit_bins] = 1.0 / (remaining_after_add + 1e-9)  # Inverse remaining capacity\n\n    # Reward bins with ample remaining capacity (not too full)\n    priorities[bins_remain_cap > item * 1.2] += 0.3\n\n    # Reward bins where the item fits very well (small gap)\n    priorities[np.abs(bins_remain_cap - item) < item * 0.2] += 0.7\n\n    # Add a small constant to all bins to avoid zero priorities and encourage exploration\n    priorities += 0.01\n\n    return priorities",
    "response_id": 5,
    "obj": 4.068607897885915,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 167.17882283189007,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter18_response6.txt_stdout.txt",
    "code_path": "problem_iter18_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    distances = np.abs(bins_remain_cap - item)\n    priorities = 1.0 / (distances + 1e-9)  # Prioritize tighter fits\n\n    # Reward spacious bins\n    priorities[bins_remain_cap > item * 1.2] += 0.2\n\n    # Reward near-full utilization\n    priorities[bins_remain_cap < item * 0.8] += 0.3\n\n    priorities = np.maximum(priorities, 0.0)\n    return priorities",
    "response_id": 6,
    "obj": 4.228161148783416,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 116.69205856195879,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter18_response7.txt_stdout.txt",
    "code_path": "problem_iter18_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    fit_bins = bins_remain_cap >= item\n    priorities[fit_bins] = 1.0 / (bins_remain_cap[fit_bins] - item + 1e-9)\n    ample_space = bins_remain_cap > item * 2.0\n    priorities[ample_space] += 0.5\n    near_perfect = np.abs(bins_remain_cap - item) < item * 0.1\n    priorities[near_perfect] += 1.0\n    priorities += 0.01\n    return priorities",
    "response_id": 7,
    "obj": 1.8149182289589196,
    "SLOC": 10.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 165.05865002596164,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter18_response8.txt_stdout.txt",
    "code_path": "problem_iter18_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Calculate relative fit: how close is the item size to the bin's remaining capacity?\n    relative_fit = np.abs(bins_remain_cap - item) / item\n    \n    # Invert relative fit to get a basic priority: smaller relative fit -> higher priority\n    priorities = 1.0 / (relative_fit + 1e-9)\n    \n    # Penalize bins that are extremely spacious or nearly empty\n    priorities[bins_remain_cap > item * 3.0] -= 0.5\n    priorities[bins_remain_cap < item * 0.5] -= 0.3\n    \n    # Boost priority for bins where item fits reasonably well\n    priorities[(bins_remain_cap >= item * 0.8) & (bins_remain_cap <= item * 1.2)] += 0.7\n\n    priorities = np.maximum(priorities, 0.0)\n    return priorities",
    "response_id": 8,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 237.80142289857002,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter18_response9.txt_stdout.txt",
    "code_path": "problem_iter18_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    distances = np.abs(bins_remain_cap - item)\n    priorities = 1.0 / (distances + 1e-9)  # Inverse distance\n\n    # Reward bins where the item fits well (not too tight, not too loose)\n    fit_reward = np.exp(-((bins_remain_cap - item) ** 2) / (item ** 2))\n    priorities += 0.4 * fit_reward\n\n    # Reward bins that are neither too full nor too empty\n    utilization = bins_remain_cap / 1.0  # Assuming bin capacity is 1.0\n    utilization_reward = np.exp(-((utilization - 0.5) ** 2) / 0.1)\n    priorities += 0.3 * utilization_reward\n\n    # Penalize almost full bins to avoid fragmentation\n    priorities[bins_remain_cap < item * 0.1] -= 0.5\n\n    priorities = np.maximum(priorities, 0.0)\n    return priorities",
    "response_id": 9,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 292.57485892279027,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter19_response0.txt_stdout.txt",
    "code_path": "problem_iter19_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    # Inverse distance to ideal fit\n    distances = np.abs(bins_remain_cap - item)\n    priorities = 1.0 / (distances + 1e-9)\n\n    # Weighted remaining capacity - favoring bins that aren't *too* empty or full\n    priorities += bins_remain_cap / (item + 1e-9)  # Scale by item size for normalization\n\n    # Gentle rewards for spaciousness and near-full bins\n    priorities[bins_remain_cap > item * 1.5] += 0.1\n    priorities[bins_remain_cap < item * 0.5] += 0.05\n\n    # Ensure priorities are non-negative\n    priorities = np.maximum(priorities, 0.0)\n    \n    return priorities",
    "response_id": 0,
    "obj": 86.38811328280813,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 162.84823041805248,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter19_response1.txt_stdout.txt",
    "code_path": "problem_iter19_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Fit: Inverse distance to ideal.\n    distances = np.abs(bins_remain_cap - item)\n    priorities = 1.0 / (distances + 1e-9)\n\n    # Weighted remaining capacity. Reward spaciousness and near-full bins.\n    # Gentle rewards, avoid extremes.\n    priorities[bins_remain_cap > item * 1.2] += 0.1  # Slightly reward spacious bins\n    priorities[bins_remain_cap < item * 0.8] += 0.15 # Slightly reward near-full bins\n\n    # Ensure priorities are non-negative\n    priorities = np.maximum(priorities, 0.0)\n\n    return priorities",
    "response_id": 1,
    "obj": 4.038691663342641,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 116.69205856195879,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter19_response2.txt_stdout.txt",
    "code_path": "problem_iter19_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Fit (inverse distance to ideal)\n    distances = np.abs(bins_remain_cap - item)\n    priorities = 1.0 / (distances + 1e-9)  # Avoid division by zero\n\n    # Weighted remaining capacity: Reward spaciousness & near-full bins\n    priorities[bins_remain_cap > item * 1.2] += 0.1  # Spacious bins\n    priorities[bins_remain_cap < item * 0.8] += 0.1  # Near-full bins\n\n    # Normalize priorities to prevent large values dominating\n    priorities = priorities / np.max(priorities) if np.max(priorities) > 0 else priorities\n\n    return priorities",
    "response_id": 2,
    "obj": 4.038691663342641,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 149.27754454988144,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter19_response3.txt_stdout.txt",
    "code_path": "problem_iter19_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    # Fit (Inverse distance to ideal)\n    distances = np.abs(bins_remain_cap - item)\n    priorities = 1.0 / (distances + 1e-9)  # Avoid division by zero\n    \n    # Weighted remaining capacity - encourage bins that aren't too empty or too full\n    priorities += bins_remain_cap / (item + 1e-9)\n    \n    # Gently reward spaciousness and near-full bins\n    priorities[bins_remain_cap > item * 1.5] += 0.1\n    priorities[bins_remain_cap < item * 0.5] += 0.1\n    \n    # Ensure priorities are non-negative\n    priorities = np.maximum(priorities, 0.0)\n    \n    return priorities",
    "response_id": 3,
    "obj": 86.38811328280813,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 160.5395382709427,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter19_response4.txt_stdout.txt",
    "code_path": "problem_iter19_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Fit (inverse distance to ideal)\n    distances = np.abs(bins_remain_cap - item)\n    priorities = 1.0 / (distances + 1e-9)\n\n    # Weighted remaining capacity - Reward spaciousness *and* near-full bins\n    # Gentle rewards to avoid extremes.\n    priorities[bins_remain_cap > item * 1.2] += 0.1  # Spacious\n    priorities[bins_remain_cap < item * 0.8] += 0.15 # Near-full\n\n    # Ensure priorities are non-negative\n    priorities = np.maximum(priorities, 0.0)\n\n    return priorities",
    "response_id": 4,
    "obj": 4.038691663342641,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 116.69205856195879,
    "exec_success": true
  }
]