[
  {
    "stdout_filepath": "problem_iter10_response0.txt_stdout.txt",
    "code_path": "problem_iter10_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Reward spacious bins\n    priorities += bins_remain_cap / (bins_remain_cap.max() + 1e-9)\n\n    # Reward near-perfect fits\n    priorities += np.exp(-((bins_remain_cap - item) / item)**2)\n\n    # Penalize bins that are too small\n    priorities[bins_remain_cap < item] = 0.0\n\n    return priorities",
    "response_id": 0,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 14, in priority_v2\n    distances = np.abs(bins_remain_cap - item)\nnumpy._core._exceptions._UFuncOutputCastingError: Cannot cast ufunc 'add' output from dtype('float64') to dtype('int64') with casting rule 'same_kind'\n6\n1\n108.41805003750011\n"
  },
  {
    "stdout_filepath": "problem_iter10_response1.txt_stdout.txt",
    "code_path": "problem_iter10_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    distances = np.abs(bins_remain_cap - item)\n    priorities = 1.0 / (distances + 1e-9)  # Inverse distance weighting\n\n    # Reward spacious bins (more than 1.5 times the item size)\n    priorities[bins_remain_cap > item * 1.5] += 0.15\n\n    # Reward near-full utilization (less than 0.5 times the item size remaining)\n    priorities[bins_remain_cap < item * 0.5] += 0.2\n\n    # Penalize bins where the item is much larger than remaining capacity.\n    priorities[bins_remain_cap < item * 0.2] -= 0.1\n\n    # Ensure priorities are non-negative\n    priorities = np.maximum(priorities, 0.0)\n\n    return priorities",
    "response_id": 1,
    "obj": 2.0043877143996833,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 162.84823041805248,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response2.txt_stdout.txt",
    "code_path": "problem_iter10_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    distances = np.abs(bins_remain_cap - item)\n    priorities = 1.0 / (distances + 1e-9)  # Inverse distance\n\n    # Boost bins with ample remaining capacity (more than twice the item size)\n    priorities[bins_remain_cap > item * 2] += 0.7\n\n    # Further boost bins where item fits perfectly or nearly perfectly\n    priorities[np.abs(bins_remain_cap - item) < 1e-6] += 1.2\n\n    # Add a small constant to all bins to ensure no zero priorities and avoid overly strong preference\n    priorities += 0.02\n\n    return priorities",
    "response_id": 2,
    "obj": 2.143996808934982,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 133.78294855911892,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response3.txt_stdout.txt",
    "code_path": "problem_iter10_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    distances = np.abs(bins_remain_cap - item)\n    \n    # Base priority: inverse of distance to full capacity\n    priorities = 1.0 / (distances + 1e-9)\n\n    # Boost bins with ample remaining capacity (more than twice the item size)\n    priorities[bins_remain_cap > item * 2] += 0.5\n\n    # Further boost bins where item fits perfectly or nearly perfectly\n    perfect_fit = np.abs(bins_remain_cap - item) < 1e-6\n    priorities[perfect_fit] += 1.0\n\n    # Boost bins where item fits well proportionally\n    good_fit = (bins_remain_cap >= item * 0.8) & (bins_remain_cap <= item * 2)\n    priorities[good_fit] += 0.3\n\n    # Slightly penalize bins that are almost full\n    priorities[distances < item * 0.1] -= 0.2\n\n    # Penalize bins that are much larger than the item\n    priorities[bins_remain_cap > item * 5] -= 0.1\n    \n    return priorities",
    "response_id": 3,
    "obj": 3.380534503390516,
    "SLOC": 12.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 325.70527509086565,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response4.txt_stdout.txt",
    "code_path": "problem_iter10_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    distances = np.abs(bins_remain_cap - item)\n    priorities = 1.0 / (distances + 1e-9)  # Inverse distance\n\n    # Boost bins with ample remaining capacity\n    priorities[bins_remain_cap > item * 2] += 0.7\n\n    # Significant boost for perfect or near-perfect fits\n    priorities[np.abs(bins_remain_cap - item) < 1e-6] += 2.0\n\n    return priorities",
    "response_id": 4,
    "obj": 2.143996808934982,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 114.6940428629768,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response5.txt_stdout.txt",
    "code_path": "problem_iter10_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Inverse distance weighting\n    distances = np.abs(bins_remain_cap - item)\n    priorities = 1.0 / (distances + 1e-9)\n\n    # Reward spacious bins\n    priorities[bins_remain_cap > item * 1.5] += 0.3\n\n    # Reward near-full utilization (gentle)\n    priorities[bins_remain_cap < item * 0.75] += 0.15\n\n    # Gently penalize almost full bins\n    priorities[bins_remain_cap < item * 0.25] -= 0.05\n\n    # Ensure priorities are non-negative\n    priorities = np.maximum(priorities, 0.0)\n\n    return priorities",
    "response_id": 5,
    "obj": 1.8348623853211101,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 165.05865002596164,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response6.txt_stdout.txt",
    "code_path": "problem_iter10_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    distances = np.abs(bins_remain_cap - item)\n    priorities = 1.0 / (distances + 1e-9)\n    return priorities",
    "response_id": 6,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 28.529325012980813,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response7.txt_stdout.txt",
    "code_path": "problem_iter10_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    distances = np.abs(bins_remain_cap - item)\n    priorities = 1.0 / (distances + 1e-9)  # Inverse distance\n\n    # Boost bins with ample remaining capacity\n    priorities[bins_remain_cap > item * 2] += 0.7\n\n    # Further boost bins where item fits perfectly or nearly perfectly\n    priorities[np.abs(bins_remain_cap - item) < 1e-6] += 1.2\n\n    # Add a small constant to all bins to avoid zero priorities\n    priorities += 0.02\n\n    return priorities",
    "response_id": 7,
    "obj": 2.143996808934982,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 133.78294855911892,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response8.txt_stdout.txt",
    "code_path": "problem_iter10_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    # Calculate relative capacity\n    relative_cap = bins_remain_cap / bins_remain_cap.max()\n    \n    # Reward bins with enough capacity\n    priorities[relative_cap >= item] = 1.0 / (item - bins_remain_cap[relative_cap >= item])\n    \n    # Reward spacious bins\n    priorities[relative_cap > 0.75] += 0.1\n    \n    # Reward near-full bins\n    priorities[relative_cap < 0.25] += 0.05\n    \n    # Ensure priorities are non-negative\n    priorities = np.maximum(priorities, 0.0)\n    \n    return priorities",
    "response_id": 8,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 20, in priority_v2\n    # Reward bins with ample remaining capacity\nnumpy._core._exceptions._UFuncOutputCastingError: Cannot cast ufunc 'add' output from dtype('float64') to dtype('int64') with casting rule 'same_kind'\n8\n1\n114.6940428629768\n"
  },
  {
    "stdout_filepath": "problem_iter10_response9.txt_stdout.txt",
    "code_path": "problem_iter10_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    distances = np.abs(bins_remain_cap - item)\n\n    # Base priority: Inverse distance with a small offset\n    priorities = 1.0 / (distances + 1e-9)\n\n    # Boost for near-perfect fits\n    priorities[distances < item * 0.05] += 2.0  # Higher boost than v1\n\n    # Reward bins with ample remaining capacity\n    priorities[bins_remain_cap > item * 2] += 0.75 # Higher boost than v1\n\n    # Penalize bins that are too small - set priority to a very low value\n    priorities[bins_remain_cap < item] = 1e-10\n\n    # Add a small reward for higher remaining capacity, even if not ample\n    priorities += bins_remain_cap / (item + 1e-6) * 0.25\n\n    return priorities",
    "response_id": 9,
    "obj": 82.54886318308735,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 195.04195997053841,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response0.txt_stdout.txt",
    "code_path": "problem_iter11_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Inverse distance weighting to remaining capacity\n    distances = np.abs(bins_remain_cap - item)\n    priorities = 1.0 / (distances + 1e-9)\n\n    # Reward perfect and near-perfect fits\n    priorities[np.abs(bins_remain_cap - item) < 1e-6] += 1.0\n    priorities[(bins_remain_cap - item) > 0] += 0.1\n\n    # Gently penalize almost-full bins\n    priorities[bins_remain_cap < item * 0.2] -= 0.05\n\n    # Ensure priorities are non-negative\n    priorities = np.maximum(priorities, 0.0)\n\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 162.84823041805248,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response1.txt_stdout.txt",
    "code_path": "problem_iter11_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    # Validate bin capacities\n    valid_bins = bins_remain_cap >= 0\n    if not np.all(valid_bins):\n        raise ValueError(\"Negative bin capacity encountered.\")\n\n    # Inverse distance to remaining capacity\n    distances = np.abs(bins_remain_cap - item)\n    priorities = 1.0 / (distances + 1e-9)\n\n    # Perfect fit bonus\n    perfect_fit_mask = np.isclose(bins_remain_cap, item)\n    priorities[perfect_fit_mask] += 1.0\n\n    # Near-perfect fit bonus\n    near_perfect_mask = np.abs(bins_remain_cap - item) < 0.1 * item\n    priorities[near_perfect_mask] += 0.5\n    \n    # Spacious bin bonus\n    spacious_mask = bins_remain_cap > item * 1.5\n    priorities[spacious_mask] += 0.2\n\n    # Gentle penalty for almost-full bins\n    almost_full_mask = bins_remain_cap < item * 0.5\n    priorities[almost_full_mask] += 0.1\n\n    return priorities",
    "response_id": 1,
    "obj": 1.6952532907858,
    "SLOC": 16.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 225.94568133670737,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response2.txt_stdout.txt",
    "code_path": "problem_iter11_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Inverse distance weighting to remaining capacity\n    distances = np.abs(bins_remain_cap - item)\n    priorities = 1.0 / (distances + 1e-9)\n\n    # Reward perfect and near-perfect fits\n    priorities[np.isclose(bins_remain_cap, item)] += 1.0\n    priorities[np.abs(bins_remain_cap - item) < 0.1] += 0.5\n\n    # Reward spacious bins\n    priorities[bins_remain_cap > item * 1.5] += 0.2\n\n    # Gently penalize almost-full bins\n    priorities[bins_remain_cap < item * 0.2] -= 0.1\n\n    # Ensure priorities are non-negative\n    priorities = np.maximum(priorities, 0.0)\n\n    return priorities",
    "response_id": 2,
    "obj": 1.6952532907858,
    "SLOC": 10.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 176.41891628622352,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response3.txt_stdout.txt",
    "code_path": "problem_iter11_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Validate bin capacities\n    if np.any(bins_remain_cap < 0):\n        raise ValueError(\"Bin capacities cannot be negative.\")\n\n    # Inverse distance weighting to remaining capacity\n    distances = np.abs(bins_remain_cap - item)\n    priorities = 1.0 / (distances + 1e-9)  # Avoid division by zero\n\n    # Strongly reward perfect and near-perfect fits\n    priorities[np.isclose(bins_remain_cap, item)] += 1.0\n    priorities[np.abs(bins_remain_cap - item) < 0.01] += 0.8\n\n    # Reward spacious bins\n    priorities[bins_remain_cap > item * 1.5] += 0.2\n\n    # Gently penalize almost-full bins\n    priorities[bins_remain_cap < item * 0.5] += 0.1\n\n    # Ensure priorities are non-negative\n    priorities = np.maximum(priorities, 0.0)\n\n    return priorities",
    "response_id": 3,
    "obj": 1.6952532907858,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 197.4184681619259,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response4.txt_stdout.txt",
    "code_path": "problem_iter11_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    # Validate bin capacities - crucial for robustness\n    if np.any(bins_remain_cap < 0):\n        raise ValueError(\"Negative bin capacity encountered!\")\n    \n    # Inverse distance to remaining capacity\n    distances = np.abs(bins_remain_cap - item)\n    priorities = 1.0 / (distances + 1e-9)\n    \n    # Strong reward for perfect and near-perfect fits\n    priorities[np.isclose(bins_remain_cap, item)] += 1.0\n    priorities[np.abs(bins_remain_cap - item) < 0.01] += 0.5\n\n    # Reward spacious bins\n    priorities[bins_remain_cap > item * 1.5] += 0.1\n    \n    # Gentle penalty for almost-full bins\n    priorities[bins_remain_cap < item * 0.5] -= 0.05\n\n    # Ensure priorities are non-negative\n    priorities = np.maximum(priorities, 0.0)\n    \n    return priorities",
    "response_id": 4,
    "obj": 2.8021539688871298,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 195.04195997053841,
    "exec_success": true
  }
]