[
  {
    "stdout_filepath": "problem_iter6_response0.txt_stdout.txt",
    "code_path": "problem_iter6_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if np.sum(valid_bins) == 0:\n        return priorities\n\n    distances = np.abs(bins_remain_cap[valid_bins] - item)\n    priorities[valid_bins] = 1.0 / (distances + 1e-6)\n    exact_fit_indices = np.where(bins_remain_cap == item)[0]\n    if len(exact_fit_indices) > 0:\n        priorities[exact_fit_indices] = 1e9  # Highest priority for exact fit\n\n    return priorities",
    "response_id": 0,
    "obj": 4.198244914240141,
    "SLOC": 11.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 84.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response1.txt_stdout.txt",
    "code_path": "problem_iter6_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    distances = np.abs(bins_remain_cap - item)\n    priorities = 1.0 / (distances + 1e-6)\n    \n    # Scale priorities to avoid extremely high values for very small distances\n    scaled_priorities = np.sqrt(priorities)\n\n    # Softmax to get probabilities for more stable selection\n    exp_priorities = np.exp(scaled_priorities)\n    probabilities = exp_priorities / np.sum(exp_priorities)\n\n    return probabilities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 41.51317942364757,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response2.txt_stdout.txt",
    "code_path": "problem_iter6_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    valid_bins = bins_remain_cap >= item\n    if np.sum(valid_bins) == 0:\n        return np.zeros_like(bins_remain_cap)\n\n    distances = np.abs(bins_remain_cap[valid_bins] - item)\n    \n    # Exponential decay based on distance, prioritizing closer fits\n    priorities = np.exp(-distances)\n\n    # Fragmentation penalty: penalize bins that will be very empty after adding the item\n    fragmentation_penalty = np.exp(-(bins_remain_cap[valid_bins] - item)) \n    priorities = priorities * fragmentation_penalty\n    \n    # Normalize to probabilities\n    probabilities = priorities / np.sum(priorities)\n\n    result = np.zeros_like(bins_remain_cap)\n    result[valid_bins] = probabilities\n    return result",
    "response_id": 2,
    "obj": 4.437574790586359,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 89.92418250750748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response3.txt_stdout.txt",
    "code_path": "problem_iter6_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the difference between the item size and the remaining capacity of each bin\n    diffs = bins_remain_cap - item\n\n    # Assign a priority of 0 to bins that cannot accommodate the item\n    priorities = np.zeros_like(bins_remain_cap)\n    feasible_bins = diffs >= 0\n    priorities[feasible_bins] = diffs[feasible_bins]\n\n    # Normalize priorities to create a probability distribution\n    probabilities = np.exp(priorities)\n    probabilities /= np.sum(probabilities)\n    \n    return probabilities",
    "response_id": 3,
    "obj": 149.30195452732352,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 28.529325012980813,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response4.txt_stdout.txt",
    "code_path": "problem_iter6_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Compatibility score: 1 if item fits, 0 otherwise\n    compatibility = (bins_remain_cap >= item).astype(float)\n\n    # Distance from item size to remaining capacity\n    distances = np.abs(bins_remain_cap - item)\n\n    # Normalize distances to be between 0 and 1\n    normalized_distances = distances / np.max(distances) if np.max(distances) > 0 else distances\n\n    # Combine compatibility and normalized distance\n    # Higher score for compatible bins with smaller distances\n    priorities = compatibility * np.exp(-normalized_distances)\n\n    # Normalize priorities to create a probability distribution\n    probabilities = priorities / np.sum(priorities) if np.sum(priorities) > 0 else priorities\n    return probabilities",
    "response_id": 4,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 95.90827503317318,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response5.txt_stdout.txt",
    "code_path": "problem_iter6_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    valid_bins = bins_remain_cap >= item\n    if np.sum(valid_bins) == 0:\n        return np.zeros_like(bins_remain_cap)\n\n    # Distance to full\n    distances = np.abs(bins_remain_cap[valid_bins] - item)\n    \n    # Ratio of item size to bin remaining capacity\n    ratios = item / bins_remain_cap[valid_bins]\n\n    # Combine distance and ratio.  Prioritize smaller ratios (better fit)\n    # and smaller distances (less wasted space).\n    priority_scores = np.exp(-distances - 2 * ratios)  # Adjust weighting as needed\n    \n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[valid_bins] = priority_scores\n    \n    probabilities = priorities / np.sum(priorities)\n    return probabilities",
    "response_id": 5,
    "obj": 4.487435181491823,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 97.70233280920246,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response6.txt_stdout.txt",
    "code_path": "problem_iter6_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    distances = np.abs(bins_remain_cap - item)\n    priorities = 1.0 / (distances + 1e-6)\n    return priorities",
    "response_id": 6,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 28.529325012980813,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response7.txt_stdout.txt",
    "code_path": "problem_iter6_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Calculate the distance between the item size and the remaining capacity of each bin.\n    distances = np.abs(bins_remain_cap - item)\n    # Assign priority scores based on the inverse of the distance.\n    # Add a small constant to avoid division by zero and stabilize the function\n    priorities = 1.0 / (distances + 1e-6)\n    # Boost bins that have significantly more remaining capacity than the item\n    priorities[bins_remain_cap > item * 2] += 0.5\n    return priorities",
    "response_id": 7,
    "obj": 2.143996808934982,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 70.32403072095333,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response8.txt_stdout.txt",
    "code_path": "problem_iter6_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Exact fit gets highest priority\n    exact_fit_indices = np.where(bins_remain_cap == item)[0]\n    priorities[exact_fit_indices] = 1000.0\n\n    # Calculate remaining bins' priorities\n    feasible_bins = bins_remain_cap > item\n    if np.any(feasible_bins):\n        distances = bins_remain_cap[feasible_bins] - item\n        priorities[feasible_bins] = 1.0 / (distances + 1e-6)  # Inverse distance\n\n    return priorities",
    "response_id": 8,
    "obj": 4.198244914240141,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 53.77443751081735,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response9.txt_stdout.txt",
    "code_path": "problem_iter6_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    valid_bins = bins_remain_cap >= item\n    if np.sum(valid_bins) == 0:\n        return np.zeros_like(bins_remain_cap)\n\n    distances = np.abs(bins_remain_cap[valid_bins] - item)\n    priorities = np.exp(-distances / item)  # Normalize distance by item size\n    probabilities = priorities / np.sum(priorities)\n\n    result = np.zeros_like(bins_remain_cap)\n    result[valid_bins] = probabilities\n    return result",
    "response_id": 9,
    "obj": 4.487435181491823,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 64.72503367497926,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter7_response0.txt_stdout.txt",
    "code_path": "problem_iter7_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    # Calculate absolute differences between item size and remaining capacity\n    distances = np.abs(bins_remain_cap - item)\n    \n    # Assign priority based on inverse distance, adding a small offset\n    priorities = 1.0 / (distances + 1e-9)\n\n    # Boost bins with ample remaining capacity (more than twice the item size)\n    priorities[bins_remain_cap > item * 2] += 0.3 \n\n    # Further boost bins where item fits perfectly or nearly perfectly\n    priorities[np.abs(bins_remain_cap - item) < 1e-6] += 0.7\n\n    return priorities",
    "response_id": 0,
    "obj": 2.3932987634623055,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 116.69205856195879,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter7_response1.txt_stdout.txt",
    "code_path": "problem_iter7_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    capacities = np.array(bins_remain_cap, dtype=float)\n    priorities = np.zeros_like(capacities)\n\n    # Validate capacities (handle potential negative or zero values)\n    capacities = np.maximum(capacities, 0.0)\n\n    # Calculate absolute difference between item size and remaining capacity\n    diffs = np.abs(capacities - item)\n\n    # Inverse distance to remaining capacity, with small offset for stability\n    priorities = 1.0 / (diffs + 1e-6)\n\n    # Smoothness: Boost bins with sufficient remaining capacity\n    priorities[capacities >= item * 1.5] += 0.2\n    priorities[capacities >= item * 2.0] += 0.3\n\n    # Further smoothing: Slight penalty for almost full bins\n    priorities[diffs < item * 0.1] -= 0.1\n\n    return priorities",
    "response_id": 1,
    "obj": 12.026326286398099,
    "SLOC": 10.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 162.84823041805248,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter7_response2.txt_stdout.txt",
    "code_path": "problem_iter7_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    # Calculate absolute differences between item size and bin remaining capacity\n    distances = np.abs(bins_remain_cap - item)\n    \n    # Inverse distance prioritization\n    priorities = 1.0 / (distances + 1e-9)  # Small offset for numerical stability\n\n    # Favor bins with significantly more remaining capacity\n    priorities[bins_remain_cap > item * 1.5] += 0.3 \n    \n    # Slightly penalize bins that are almost full\n    priorities[bins_remain_cap < item * 0.5] -= 0.1\n    \n    # Ensure priorities are non-negative\n    priorities = np.maximum(priorities, 0.0)\n    \n    return priorities",
    "response_id": 2,
    "obj": 1.8348623853211101,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 116.69205856195879,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter7_response3.txt_stdout.txt",
    "code_path": "problem_iter7_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    distances = np.abs(bins_remain_cap - item)\n    priorities = 1.0 / (distances + 1e-9)  # Smaller offset for stability\n    \n    # Smooth boost for better fits\n    priorities[bins_remain_cap >= item] += 0.2  # Reward bins that *can* fit\n    priorities[bins_remain_cap > item * 1.5] += 0.1 # slight boost for bins with ample space\n\n    return priorities",
    "response_id": 3,
    "obj": 2.8021539688871298,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 100.07820003461549,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter7_response4.txt_stdout.txt",
    "code_path": "problem_iter7_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Calculate the absolute difference between item size and bin remaining capacity\n    diffs = np.abs(bins_remain_cap - item)\n\n    # Calculate inverse distance to remaining capacity with a small offset\n    priorities = 1.0 / (diffs + 1e-6)\n\n    # Boost bins with significantly more capacity\n    priorities[bins_remain_cap > item * 1.5] += 0.3\n\n    # Penalize bins that are almost full (reduce fragmentation)\n    priorities[bins_remain_cap < item * 0.5] -= 0.2\n\n    # Ensure non-negative priorities\n    priorities = np.maximum(priorities, 0.0)\n    return priorities",
    "response_id": 4,
    "obj": 1.8348623853211101,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 116.69205856195879,
    "exec_success": true
  }
]