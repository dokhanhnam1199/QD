[
  {
    "stdout_filepath": "problem_iter4_response0.txt_stdout.txt",
    "code_path": "problem_iter4_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Exact fit gets highest priority\n    exact_fit = (bins_remain_cap == item)\n    priorities[exact_fit] = 1000.0\n    # Prioritize bins where the item fits, minimizing waste\n    fit = (bins_remain_cap >= item)\n    if np.any(fit):\n        waste = bins_remain_cap[fit] - item\n        # Inverse of waste: smaller waste = higher priority\n        priorities[fit] = 1.0 / (waste + 1e-6)\n\n    # Incorporate bin fullness awareness: prefer less full bins\n    # Normalize remaining capacity to a 0-1 scale\n    fullness = 1.0 - (bins_remain_cap / np.max(bins_remain_cap))\n    # Add a bonus for less full bins, scaled by a factor\n    priorities += 0.1 * fullness\n    \n    return priorities",
    "response_id": 0,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 26, in priority_v2\nnumpy._core._exceptions._UFuncOutputCastingError: Cannot cast ufunc 'add' output from dtype('float64') to dtype('int64') with casting rule 'same_kind'\n11\n2\n114.6940428629768\n"
  },
  {
    "stdout_filepath": "problem_iter4_response1.txt_stdout.txt",
    "code_path": "problem_iter4_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    valid_bins = bins_remain_cap >= item\n    if np.sum(valid_bins) == 0:\n        return np.zeros_like(bins_remain_cap)\n\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    # Exact fit gets highest priority\n    exact_fit_indices = np.where(bins_remain_cap == item)[0]\n    priorities[exact_fit_indices] = 1e9\n    \n    # Prioritize bins that are closer to being full, but only if not an exact fit.\n    remaining_capacity_ratio = bins_remain_cap[valid_bins] / item\n    priorities[valid_bins] = remaining_capacity_ratio\n    \n    return priorities",
    "response_id": 1,
    "obj": 35.41084962106105,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 36.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response2.txt_stdout.txt",
    "code_path": "problem_iter4_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Exact fit gets highest priority\n    exact_fit = (bins_remain_cap == item)\n    priorities[exact_fit] = 1000.0\n\n    # Prioritize bins where the item fits, minimizing waste\n    fit = (bins_remain_cap >= item)\n    if np.any(fit):\n        waste = bins_remain_cap[fit] - item\n        priorities[fit] = 1.0 / (waste + 1e-6)  # Inverse of waste\n\n    return priorities",
    "response_id": 2,
    "obj": 4.198244914240141,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 53.77443751081735,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response3.txt_stdout.txt",
    "code_path": "problem_iter4_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    distances = np.abs(bins_remain_cap - item)\n    priorities = 1.0 / (distances + 1e-6)\n    return priorities",
    "response_id": 3,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 28.529325012980813,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response4.txt_stdout.txt",
    "code_path": "problem_iter4_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    valid_bins = bins_remain_cap >= item\n    if np.sum(valid_bins) == 0:\n        return np.zeros_like(bins_remain_cap)\n\n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[valid_bins] = bins_remain_cap[valid_bins] / (item + 1e-6)\n    exact_fit_indices = np.where(bins_remain_cap == item)[0]\n    if len(exact_fit_indices) > 0:\n        priorities[exact_fit_indices] = 1e9\n\n    return priorities",
    "response_id": 4,
    "obj": 14.319904268049477,
    "SLOC": 10.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 66.60791492653966,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response5.txt_stdout.txt",
    "code_path": "problem_iter4_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Prioritize exact fits\n    exact_fit_indices = np.where(bins_remain_cap == item)[0]\n    priorities[exact_fit_indices] = 1000.0  # High priority for exact fits\n\n    # Prioritize tightest feasible fits\n    feasible_bins_indices = np.where(bins_remain_cap >= item)[0]\n    if len(feasible_bins_indices) > 0:\n        feasible_bins = bins_remain_cap[feasible_bins_indices]\n        distances = np.abs(feasible_bins - item)\n        priorities[feasible_bins_indices] = 1.0 / (distances + 1e-6)\n\n    return priorities",
    "response_id": 5,
    "obj": 4.198244914240141,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 70.32403072095333,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response6.txt_stdout.txt",
    "code_path": "problem_iter4_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    distances = np.abs(bins_remain_cap - item)\n    priorities = np.exp(-distances)  # Exponential decay based on distance\n    probabilities = priorities / np.sum(priorities)\n    return probabilities",
    "response_id": 6,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 24.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response7.txt_stdout.txt",
    "code_path": "problem_iter4_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_after_item = bins_remain_cap - item\n\n    # Only consider bins where the item fits\n    valid_bins = remaining_after_item >= 0\n\n    # Initialize priorities to 0\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # If no bins can fit the item, return the zeroed priorities\n    if not np.any(valid_bins):\n        return priorities\n\n    # Calculate the waste (remaining capacity after adding the item) for valid bins\n    waste = remaining_after_item[valid_bins]\n\n    # Calculate the priority as the inverse of the waste.  Add a small constant\n    # to avoid division by zero and to give a small, non-zero priority to bins with 0 waste\n    priorities[valid_bins] = 1.0 / (waste + 1e-6)\n\n    return priorities",
    "response_id": 7,
    "obj": 4.198244914240141,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 53.30296890880645,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response8.txt_stdout.txt",
    "code_path": "problem_iter4_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    distances = np.abs(bins_remain_cap - item)\n    priorities = 1.0 / (distances + 1e-6)\n    # Softmax to get probabilities for more stable selection\n    exp_priorities = np.exp(priorities)\n    probabilities = exp_priorities / np.sum(exp_priorities)\n    return probabilities",
    "response_id": 8,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 41.51317942364757,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response9.txt_stdout.txt",
    "code_path": "problem_iter4_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    # Prioritize exact fits\n    exact_fit_indices = np.where(bins_remain_cap == item)[0]\n    priorities[exact_fit_indices] = 1000.0\n    \n    # Prioritize tightest feasible fits\n    feasible_bins = bins_remain_cap[bins_remain_cap >= item]\n    if len(feasible_bins) > 0:\n        distances = np.abs(feasible_bins - item)\n        \n        # Avoid division by zero by adding a small value\n        priorities[np.where(bins_remain_cap >= item)[0]] = 1.0 / (distances + 1e-6)\n    \n    return priorities",
    "response_id": 9,
    "obj": 4.198244914240141,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 82.0447025077789,
    "exec_success": true
  }
]