[
  {
    "stdout_filepath": "problem_iter28_response0.txt_stdout.txt",
    "code_path": "problem_iter28_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    # Fit: Inverse distance to remaining capacity\n    fit_bins = bins_remain_cap >= item\n    if np.any(fit_bins):\n        priorities[fit_bins] = 1.0 / (bins_remain_cap[fit_bins] - item + 1e-9)\n\n    # Reward spacious bins\n    priorities[bins_remain_cap > item * 1.5] += 0.1\n\n    # Reward near-full bins\n    priorities[bins_remain_cap < item * 0.5] += 0.1\n\n    # Ensure priorities are non-negative\n    priorities = np.maximum(priorities, 0.0)\n    return priorities",
    "response_id": 0,
    "obj": 2.8021539688871298,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 131.76952268336282,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter28_response1.txt_stdout.txt",
    "code_path": "problem_iter28_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    # Fit: Inverse distance to remaining capacity\n    distances = np.abs(bins_remain_cap - item)\n    priorities = 1.0 / (distances + 1e-9)\n\n    # Reward spacious bins\n    priorities[bins_remain_cap > item * 2.0] += 0.1\n\n    # Reward near-full bins\n    priorities[bins_remain_cap < item * 0.5] += 0.1\n\n    # Ensure priorities are non-negative\n    priorities = np.maximum(priorities, 0.0)\n    return priorities",
    "response_id": 1,
    "obj": 3.3506182688472412,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 114.6940428629768,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter28_response2.txt_stdout.txt",
    "code_path": "problem_iter28_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Inverse distance weighting to remaining capacity\n    distances = np.abs(bins_remain_cap - item)\n    priorities = 1.0 / (distances + 1e-9)\n\n    # Reward spacious bins\n    priorities[bins_remain_cap > item * 1.75] += 0.15\n\n    # Reward near-full utilization (but not *too* full)\n    priorities[bins_remain_cap < item * 0.75] += 0.1\n\n    # Penalize bins that are almost exactly the size of the item\n    priorities[np.abs(bins_remain_cap - item) < item * 0.1] -= 0.05\n\n    # Ensure priorities are non-negative\n    priorities = np.maximum(priorities, 0.0)\n\n    return priorities",
    "response_id": 2,
    "obj": 1.9944156362185879,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 178.81353752812512,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter28_response3.txt_stdout.txt",
    "code_path": "problem_iter28_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    # Feasible bins only\n    feasible_bins = bins_remain_cap >= item\n    if not np.any(feasible_bins):\n        return priorities\n\n    # Inverse distance to remaining capacity\n    distances = bins_remain_cap[feasible_bins] - item\n    priorities[feasible_bins] = 1.0 / (distances + 1e-9)\n\n    # Slight preference for bins with more remaining capacity (avoiding very full bins)\n    priorities[feasible_bins] += bins_remain_cap[feasible_bins] / (bins_remain_cap[feasible_bins].max() + 1e-9) * 0.1\n\n    return priorities",
    "response_id": 3,
    "obj": 35.63023534104507,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 114.20025299224778,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter28_response4.txt_stdout.txt",
    "code_path": "problem_iter28_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Fit: Inverse distance to remaining capacity.\n    distances = np.abs(bins_remain_cap - item)\n    priorities = 1.0 / (distances + 1e-9)\n\n    # Relative Capacity: Smoothly reward near-full and spacious bins.\n    relative_capacity = bins_remain_cap / (np.max(bins_remain_cap) + 1e-9)  # Normalize to 0-1\n\n    # Gaussian-weighted preferences\n    priorities += 0.2 * np.exp(-((relative_capacity - 0.7)**2) / 0.01)  # Near full\n    priorities += 0.1 * np.exp(-((relative_capacity - 0.3)**2) / 0.05)  # Spacious\n\n    return priorities",
    "response_id": 4,
    "obj": 4.068607897885915,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 247.1753118485642,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter28_response5.txt_stdout.txt",
    "code_path": "problem_iter28_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Feasible Fit: Inverse distance to remaining capacity.\n    fit_bins = bins_remain_cap >= item\n    if np.any(fit_bins):\n        priorities[fit_bins] = 1.0 / (bins_remain_cap[fit_bins] - item + 1e-9)\n\n    # Spaciousness: Reward bins with ample remaining capacity.\n    spacious_bins = bins_remain_cap > item * 1.5\n    priorities[spacious_bins] += 0.8\n\n    # Near-full: Prioritize filling bins almost completely.\n    near_full_bins = np.abs(bins_remain_cap - item) < item * 0.3\n    priorities[near_full_bins] += 1.5\n\n    # Tight fit bonus:  Increase priority for bins where the item fits very snugly\n    tight_fit_bins = (bins_remain_cap >= item) & (bins_remain_cap < item * 1.1)\n    priorities[tight_fit_bins] += 0.5\n    \n\n    return priorities",
    "response_id": 5,
    "obj": 3.470283207020339,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 233.1830877661235,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter28_response6.txt_stdout.txt",
    "code_path": "problem_iter28_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    # Inverse distance weighting to remaining capacity\n    distances = np.abs(bins_remain_cap - item)\n    priorities = 1.0 / (distances + 1e-9)  # Add small value to avoid division by zero\n\n    # Reward spacious bins and near-full utilization\n    priorities[bins_remain_cap > item * 2.0] += 0.3  # Increased spaciousness reward\n    priorities[bins_remain_cap < item * 0.8] += 0.2  # Increased near-full reward\n\n    # Ensure priorities are non-negative\n    priorities = np.maximum(priorities, 0.0)\n    return priorities",
    "response_id": 6,
    "obj": 2.3932987634623055,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 116.69205856195879,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter28_response7.txt_stdout.txt",
    "code_path": "problem_iter28_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Inverse distance weighting to remaining capacity\n    distances = np.abs(bins_remain_cap - item)\n    priorities = 1.0 / (distances + 1e-9)\n\n    # Reward spacious bins and near-full utilization.  Tune these bonuses.\n    priorities[bins_remain_cap > item * 1.75] += 0.3  # More reward for spacious bins\n    priorities[bins_remain_cap < item * 0.25] += 0.2  # More reward for near-full\n    priorities[(bins_remain_cap >= item) & (bins_remain_cap < item * 1.25)] += 0.1 # Reward bins that can fit but are not too spacious\n\n    # Ensure priorities are non-negative\n    priorities = np.maximum(priorities, 0.0)\n    return priorities",
    "response_id": 7,
    "obj": 1.7949740725967291,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 201.90890672641936,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter28_response8.txt_stdout.txt",
    "code_path": "problem_iter28_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    # Fit: Inverse distance to remaining capacity\n    distances = np.abs(bins_remain_cap - item)\n    fit_bins = distances >= 0\n    priorities[fit_bins] = 1.0 / (distances[fit_bins] + 1e-9)\n\n    # Reward spacious bins\n    priorities[bins_remain_cap > item * 1.5] += 0.1\n\n    # Reward near-full bins\n    priorities[bins_remain_cap < item * 0.5] += 0.1\n\n    return priorities",
    "response_id": 8,
    "obj": 2.8021539688871298,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 133.78294855911892,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter28_response9.txt_stdout.txt",
    "code_path": "problem_iter28_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Best fit: Inverse distance to remaining capacity\n    distances = np.abs(bins_remain_cap - item)\n    priorities = 1.0 / (distances + 1e-9)\n\n    # Reward bins with enough capacity\n    priorities[bins_remain_cap >= item] += 0.1\n\n    # Reward spacious bins\n    priorities[bins_remain_cap > item * 1.5] += 0.2\n\n    return priorities",
    "response_id": 9,
    "obj": 1.6952532907858,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 100.07820003461549,
    "exec_success": true
  }
]