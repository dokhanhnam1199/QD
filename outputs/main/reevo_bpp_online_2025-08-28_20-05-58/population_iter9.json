[
  {
    "stdout_filepath": "problem_iter8_response0.txt_stdout.txt",
    "code_path": "problem_iter8_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if np.sum(valid_bins) == 0:\n        return priorities\n\n    distances = bins_remain_cap[valid_bins] - item\n    priorities[valid_bins] = distances  # Tighter fit is better\n\n    # Boost spacious bins\n    priorities[bins_remain_cap > item * 2] += 1.0\n\n    return priorities",
    "response_id": 0,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 22, in priority_v2\n    exact_fit_indices = np.where(bins_remain_cap == item)[0]\nnumpy._core._exceptions._UFuncOutputCastingError: Cannot cast ufunc 'add' output from dtype('float64') to dtype('int64') with casting rule 'same_kind'\n9\n2\n70.32403072095333\n"
  },
  {
    "stdout_filepath": "problem_iter8_response1.txt_stdout.txt",
    "code_path": "problem_iter8_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n\n    if np.sum(valid_bins) == 0:\n        return priorities\n\n    distances = bins_remain_cap[valid_bins] - item\n    priorities[valid_bins] = distances  # Prioritize bins that leave less space\n\n    exact_fit_indices = np.where(bins_remain_cap == item)[0]\n    if len(exact_fit_indices) > 0:\n        priorities[exact_fit_indices] = 1e9  # Highest priority for exact fit\n\n    return priorities",
    "response_id": 1,
    "obj": 86.58755484643,
    "SLOC": 11.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 49.82892142331044,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response2.txt_stdout.txt",
    "code_path": "problem_iter8_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    distances = np.abs(bins_remain_cap - item)\n    \n    # Base priority: Inverse distance with a small offset\n    priorities = 1.0 / (distances + 1e-9)\n\n    # Boost for near-perfect fits\n    priorities[distances < item * 0.05] += 1.0  # Significantly boost very close fits\n\n    # Reward bins with ample remaining capacity\n    priorities[bins_remain_cap > item * 2] += 0.5  # Moderate boost for ample space\n\n    # Ensure no bin has zero priority\n    priorities[bins_remain_cap < item] = 0.0\n    \n    return priorities",
    "response_id": 2,
    "obj": 1.9345831671320397,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 127.43782540330756,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response3.txt_stdout.txt",
    "code_path": "problem_iter8_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Calculate absolute differences between item size and remaining capacity\n    distances = np.abs(bins_remain_cap - item)\n\n    # Assign priority based on inverse distance, adding a small offset to avoid division by zero\n    priorities = 1.0 / (distances + 1e-9)\n\n    # Boost bins with ample remaining capacity (more than twice the item size)\n    priorities[bins_remain_cap > item * 2] += 0.5\n\n    # Further boost bins where item fits perfectly or nearly perfectly\n    priorities[np.abs(bins_remain_cap - item) < 1e-6] += 1.0\n\n    # Add a small constant to all bins to ensure no zero priorities\n    priorities += 0.01\n\n    return priorities",
    "response_id": 3,
    "obj": 2.143996808934982,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 131.76952268336282,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response4.txt_stdout.txt",
    "code_path": "problem_iter8_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Exact fit gets highest priority\n    exact_fit_indices = np.where(bins_remain_cap == item)[0]\n    priorities[exact_fit_indices] = 1000.0\n\n    # Calculate remaining bins' priorities\n    feasible_bins = bins_remain_cap > item\n    if np.any(feasible_bins):\n        distances = bins_remain_cap[feasible_bins] - item\n        priorities[feasible_bins] = 1.0 / (distances + 1e-6)  # Inverse distance\n\n        # Incorporate bin fullness - prefer more full bins\n        fullness = (bins_remain_cap[feasible_bins] / 1.0)  # Assuming bin capacity is 1.0\n        priorities[feasible_bins] *= fullness\n\n    return priorities",
    "response_id": 4,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 27, in priority_v2\nnumpy._core._exceptions._UFuncOutputCastingError: Cannot cast ufunc 'multiply' output from dtype('float64') to dtype('int64') with casting rule 'same_kind'\n11\n2\n84.0\n"
  },
  {
    "stdout_filepath": "problem_iter8_response5.txt_stdout.txt",
    "code_path": "problem_iter8_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Calculate absolute differences between item size and remaining capacity\n    distances = np.abs(bins_remain_cap - item)\n    # Assign priority based on inverse distance, adding a small offset\n    priorities = 1.0 / (distances + 1e-9)\n    # Boost bins with ample remaining capacity (more than twice the item size)\n    priorities[bins_remain_cap > item * 2] += 0.5\n    # Further boost bins where item fits perfectly or nearly perfectly\n    priorities[np.abs(bins_remain_cap - item) < 1e-6] += 1.0\n    return priorities",
    "response_id": 5,
    "obj": 2.143996808934982,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 114.6940428629768,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response6.txt_stdout.txt",
    "code_path": "problem_iter8_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    diffs = np.abs(bins_remain_cap - item)\n    priorities = 1.0 / (diffs + 1e-6)  # Inverse distance\n\n    # Boost bins with significantly more capacity\n    priorities[bins_remain_cap > item * 1.5] += 0.2\n\n    # Penalize bins that are almost full (reduce fragmentation)\n    priorities[bins_remain_cap < item * 0.5] -= 0.3\n\n    # Small boost for bins where item fits well (not too tight, not too loose)\n    priorities[(bins_remain_cap >= item * 0.8) & (bins_remain_cap <= item * 1.2)] += 0.1\n\n    priorities = np.maximum(priorities, 0.0)\n    return priorities",
    "response_id": 6,
    "obj": 2.572796170721974,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 222.9388339674094,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response7.txt_stdout.txt",
    "code_path": "problem_iter8_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    distances = np.abs(bins_remain_cap - item)\n    priorities = 1.0 / (distances + 1e-6)\n    \n    # Reward bins with larger remaining capacities\n    priorities += bins_remain_cap / (item + 1e-6)\n    \n    return priorities",
    "response_id": 7,
    "obj": 86.27842042281613,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 64.52932501298082,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response8.txt_stdout.txt",
    "code_path": "problem_iter8_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    distances = np.abs(bins_remain_cap - item)\n    priorities = 1.0 / (distances + 1e-9)\n\n    # Boost bins with ample remaining capacity (more than twice the item size)\n    priorities[bins_remain_cap > item * 2] += 0.4\n\n    # Further boost bins where item fits perfectly or nearly perfectly\n    perfect_fit = np.abs(bins_remain_cap - item) < 1e-6\n    priorities[perfect_fit] += 0.8\n\n    # Slightly penalize bins that are almost full\n    priorities[distances < item * 0.1] -= 0.1\n\n    return priorities",
    "response_id": 8,
    "obj": 2.5229357798165095,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 162.84823041805248,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response9.txt_stdout.txt",
    "code_path": "problem_iter8_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    distances = np.abs(bins_remain_cap - item)\n    priorities = 1.0 / (distances + 1e-6)\n    return priorities",
    "response_id": 9,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 28.529325012980813,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response0.txt_stdout.txt",
    "code_path": "problem_iter9_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Calculate the distance between the item size and the bin remaining capacity\n    distances = np.abs(bins_remain_cap - item)\n\n    # Inverse distance weighting: prioritize tighter fits\n    priorities = 1.0 / (distances + 1e-9)  # Add a small value to avoid division by zero\n\n    # Reward spacious bins (higher remaining capacity)\n    priorities += bins_remain_cap / (np.max(bins_remain_cap) + 1e-9)\n\n    # Reward near-full utilization, but not overly aggressive\n    priorities += (bins_remain_cap - item) / (np.max(bins_remain_cap) + 1e-9) * 0.5\n\n    # Ensure priorities are non-negative\n    priorities = np.maximum(priorities, 0.0)\n\n    return priorities",
    "response_id": 0,
    "obj": 84.98205025927405,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 142.62362713128297,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response1.txt_stdout.txt",
    "code_path": "problem_iter9_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    # Inverse distance weighting to remaining capacity\n    distances = np.abs(bins_remain_cap - item)\n    priorities = 1.0 / (distances + 1e-9)  # Add small value to avoid division by zero\n    \n    # Reward spacious bins and near-full utilization\n    priorities[bins_remain_cap > item * 1.5] += 0.2\n    priorities[bins_remain_cap < item * 0.5] += 0.1\n    \n    # Ensure priorities are non-negative\n    priorities = np.maximum(priorities, 0.0)\n    \n    return priorities",
    "response_id": 1,
    "obj": 1.6952532907858,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 116.69205856195879,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response2.txt_stdout.txt",
    "code_path": "problem_iter9_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Calculate the difference between item size and bin remaining capacity\n    distances = np.abs(bins_remain_cap - item)\n\n    # Inverse distance weighting: tighter fits get higher priority\n    priorities = 1.0 / (distances + 1e-9)  # Add a small value to avoid division by zero\n\n    # Reward spacious bins (more remaining capacity)\n    priorities += bins_remain_cap / (bins_remain_cap.max() + 1e-9)\n\n    # Reward near-full utilization (but not so close as to cause issues)\n    priorities += (bins_remain_cap - item) / (bins_remain_cap.max() + 1e-9) * 0.5\n\n    # Penalize bins that are too small for the item\n    priorities[bins_remain_cap < item] = 0.0\n\n    # Ensure priorities are non-negative\n    priorities = np.maximum(priorities, 0.0)\n\n    return priorities",
    "response_id": 2,
    "obj": 84.98205025927405,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 158.12342722003538,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response3.txt_stdout.txt",
    "code_path": "problem_iter9_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    # Calculate the difference between item size and bin remaining capacity\n    diffs = bins_remain_cap - item\n    \n    # Inverse distance weighting.  Add a small constant to avoid division by zero.\n    priorities = 1.0 / (np.abs(diffs) + 1e-9)\n\n    # Reward spacious bins (more than enough capacity)\n    priorities[bins_remain_cap > item * 1.5] += 0.2\n\n    # Reward near-full utilization (but not overfull!)\n    priorities[np.logical_and(bins_remain_cap >= item, bins_remain_cap < item * 1.2)] += 0.1\n\n    # Penalize bins that are almost too small.\n    priorities[bins_remain_cap < item * 0.5] -= 0.1\n\n    # Ensure priorities are non-negative\n    priorities = np.maximum(priorities, 0.0)\n\n    return priorities",
    "response_id": 3,
    "obj": 2.5129637016354254,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 178.81353752812512,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response4.txt_stdout.txt",
    "code_path": "problem_iter9_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Inverse distance weighting\n    distances = np.abs(bins_remain_cap - item)\n    priorities = 1.0 / (distances + 1e-9)\n\n    # Reward spacious bins & near-full utilization\n    priorities[bins_remain_cap > item * 1.5] += 0.2  # Increased reward for spacious bins\n    priorities[bins_remain_cap < item * 0.5] += 0.1  # Reward near-full utilization\n\n    # Penalize almost full bins (less aggressive)\n    # priorities[bins_remain_cap < item * 0.2] -= 0.05\n\n    # Ensure priorities are non-negative\n    priorities = np.maximum(priorities, 0.0)\n\n    return priorities",
    "response_id": 4,
    "obj": 1.6952532907858,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 116.69205856195879,
    "exec_success": true
  }
]