[
  {
    "stdout_filepath": "problem_iter14_response0.txt_stdout.txt",
    "code_path": "problem_iter14_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Inverse distance weighting\n    distances = np.abs(bins_remain_cap - item)\n    priorities = 1.0 / (distances + 1e-9)\n\n    # Reward spacious bins\n    priorities[bins_remain_cap > item * 1.5] += 0.15\n\n    # Reward near-full utilization (gentle)\n    priorities[bins_remain_cap < item * 0.8] += 0.1\n\n    # Gently penalize almost-full bins\n    priorities[bins_remain_cap < item * 0.3] -= 0.05\n\n    # Ensure priorities are non-negative\n    priorities = np.maximum(priorities, 0.0)\n\n    return priorities",
    "response_id": 0,
    "obj": 2.0043877143996833,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 165.05865002596164,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response1.txt_stdout.txt",
    "code_path": "problem_iter14_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    distances = np.abs(bins_remain_cap - item)\n    priorities = 1.0 / (distances + 1e-9)  # Inverse distance\n\n    # Boost bins with ample remaining capacity\n    priorities[bins_remain_cap > item * 1.5] += 0.5\n\n    # Further boost bins where item fits very well\n    priorities[np.abs(bins_remain_cap - item) < item * 0.1] += 1.0\n\n    # Add a small constant to all bins\n    priorities += 0.01\n\n    return priorities",
    "response_id": 1,
    "obj": 1.8847227762265748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 147.1612434150308,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response2.txt_stdout.txt",
    "code_path": "problem_iter14_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    distances = np.abs(bins_remain_cap - item)\n    priorities = 1.0 / (distances + 1e-9)\n\n    perfect_fit_mask = np.isclose(bins_remain_cap, item)\n    priorities[perfect_fit_mask] += 2.0\n\n    spacious_mask = bins_remain_cap > item * 1.5\n    priorities[spacious_mask] += 0.5\n\n    good_fit_mask = (bins_remain_cap >= item * 0.8) & (bins_remain_cap <= item * 2)\n    priorities[good_fit_mask] += 0.3\n\n    return priorities",
    "response_id": 2,
    "obj": 2.153968887116089,
    "SLOC": 11.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 185.4406125843753,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response3.txt_stdout.txt",
    "code_path": "problem_iter14_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Inverse distance weighting to remaining capacity, avoid division by zero\n    distances = np.abs(bins_remain_cap - item)\n    priorities = 1.0 / (distances + 1e-9)\n\n    # Reward spacious bins (relative to item size)\n    priorities[bins_remain_cap > item * 2] += 0.3\n\n    # Reward near-full utilization (relative to item size)\n    priorities[bins_remain_cap < item * 0.5] += 0.2\n\n    # Penalize bins that are just slightly larger than the item\n    priorities[(bins_remain_cap > item) & (bins_remain_cap < item * 1.2)] -= 0.1\n\n    # Ensure non-negative priorities\n    priorities = np.maximum(priorities, 0.0)\n\n    return priorities",
    "response_id": 3,
    "obj": 2.572796170721974,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 199.7052750908657,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response4.txt_stdout.txt",
    "code_path": "problem_iter14_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Fit score: Higher for tighter fits, but not *too* tight\n    fit_score = np.exp(-((bins_remain_cap - item) ** 2) / (2 * item**2))\n\n    # Spaciousness bonus: Reward bins with enough space, scaled by remaining capacity\n    spaciousness_bonus = np.where(bins_remain_cap > item, bins_remain_cap / item, 0.0) * 0.2\n\n    # Avoid almost full bins: Penalize bins that are nearly full\n    fullness_penalty = np.where(bins_remain_cap < item * 0.2, -0.5, 0.0)\n\n    # Combine scores\n    priorities = fit_score + spaciousness_bonus + fullness_penalty\n\n    return priorities",
    "response_id": 4,
    "obj": 7.778220981252493,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 183.39850002884629,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response5.txt_stdout.txt",
    "code_path": "problem_iter14_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    # Prioritize bins where the item fits\n    fit_bins = bins_remain_cap >= item\n    priorities[fit_bins] = 1.0 / (bins_remain_cap[fit_bins] - item + 1e-9)\n    return priorities",
    "response_id": 5,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 41.51317942364757,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response6.txt_stdout.txt",
    "code_path": "problem_iter14_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    distances = np.abs(bins_remain_cap - item)\n\n    # Base priority: inverse of distance to full capacity\n    priorities = 1.0 / (distances + 1e-9)\n\n    # Boost bins that are nearly full, but can still fit the item\n    priorities[(distances < item * 0.2) & (distances > 0)] += 1.0\n\n    # Boost bins with ample remaining capacity (more than twice the item size)\n    priorities[bins_remain_cap > item * 2] += 0.6\n\n    # Further boost bins where item fits perfectly or nearly perfectly\n    perfect_fit = np.abs(bins_remain_cap - item) < 1e-6\n    priorities[perfect_fit] += 1.2\n\n    # Boost bins where item fits well proportionally\n    good_fit = (bins_remain_cap >= item * 0.6) & (bins_remain_cap <= item * 2.5)\n    priorities[good_fit] += 0.3\n\n    # Penalize bins that are much larger than the item\n    priorities[bins_remain_cap > item * 5] -= 0.1\n\n    return priorities",
    "response_id": 6,
    "obj": 3.0115676106900726,
    "SLOC": 12.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 367.213038547228,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response7.txt_stdout.txt",
    "code_path": "problem_iter14_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    distances = np.abs(bins_remain_cap - item)\n    priorities = 1.0 / (distances + 1e-9)\n\n    priorities[bins_remain_cap > item * 1.5] += 0.3\n    priorities[bins_remain_cap < item * 0.5] += 0.2\n\n    priorities = np.maximum(priorities, 0.0)\n    return priorities",
    "response_id": 7,
    "obj": 1.8348623853211101,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 116.69205856195879,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response8.txt_stdout.txt",
    "code_path": "problem_iter14_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Calculate relative capacity (avoiding division by zero)\n    relative_capacity = bins_remain_cap / (bins_remain_cap + 1e-9)\n\n    # Smoothly reward bins where the item fits well\n    fit_score = np.exp(-((relative_capacity - (item / bins_remain_cap))**2) / 0.05)\n    priorities = fit_score\n\n    # Encourage utilization - reward bins that aren't too full or too empty\n    utilization_reward = np.exp(-((bins_remain_cap / 1.0) - (item + bins_remain_cap / 2.0))**2 / 0.2)\n    priorities += 0.2 * utilization_reward\n\n    # Gently penalize almost-full bins\n    priorities[bins_remain_cap < item * 0.2] -= 0.1\n\n    # Ensure priorities are non-negative\n    priorities = np.maximum(priorities, 0.0)\n\n    return priorities",
    "response_id": 8,
    "obj": 4.008775428799367,
    "SLOC": 10.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 275.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response9.txt_stdout.txt",
    "code_path": "problem_iter14_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Inverse distance weighting - core of the strategy\n    distances = np.abs(bins_remain_cap - item)\n    priorities = 1.0 / (distances + 1e-9)\n\n    # Reward bins with sufficient space for future items (spaciousness)\n    priorities[bins_remain_cap > item * 1.75] += 0.3\n\n    # Reward near-full utilization (gentle)\n    priorities[bins_remain_cap < item * 0.8] += 0.15\n\n    # Penalize almost full bins - avoid leaving tiny spaces\n    priorities[bins_remain_cap < item * 0.3] -= 0.1\n\n    # Penalize almost empty bins - avoid wasting bins\n    priorities[bins_remain_cap < item * 0.1] -= 0.2\n\n    # Ensure priorities are non-negative\n    priorities = np.maximum(priorities, 0.0)\n    return priorities",
    "response_id": 9,
    "obj": 2.2038292780215536,
    "SLOC": 10.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 211.51978731634918,
    "exec_success": true
  }
]