[
  {
    "stdout_filepath": "problem_iter2_response0.txt_stdout.txt",
    "code_path": "problem_iter2_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Exact fit gets highest priority\n    exact_fit_indices = np.where(bins_remain_cap == item)[0]\n    priorities[exact_fit_indices] = 1.0\n\n    # Second best, bins that can fit the item, prioritize based on less remaining capacity.\n    # This strategy attempts to fill bins more completely.\n    fit_indices = np.where(bins_remain_cap >= item)[0]\n    if len(fit_indices) > 0:\n        remaining_capacities = bins_remain_cap[fit_indices]\n        # Inverse of remaining capacity: smaller capacity = higher priority\n        priorities[fit_indices] = 1.0 / (remaining_capacities + 1e-6)\n\n    # Further refinement:  Introduce a diversity factor.  If many bins have similar\n    # remaining capacity, we want to spread items across them.\n    # This is a very simple attempt at bin diversity, prioritizing bins with more unique remaining capacity\n    # This could be improved with more sophisticated methods like calculating the number of bins\n    # within a certain capacity range.\n    \n    # Calculate the average remaining capacity.\n    avg_remaining_cap = np.mean(bins_remain_cap[bins_remain_cap >= item]) if np.any(bins_remain_cap >= item) else 0.0\n\n    # Bins with remaining capacity closest to the average get a slight boost.\n    if avg_remaining_cap > 0:\n      diffs = np.abs(bins_remain_cap[fit_indices] - avg_remaining_cap)\n      min_diff_index = np.argmin(diffs)\n      priorities[fit_indices[min_diff_index]] += 0.1\n      \n\n    return priorities",
    "response_id": 0,
    "obj": 4.487435181491823,
    "SLOC": 14.0,
    "cyclomatic_complexity": 4.0,
    "halstead": 125.09775004326937,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response1.txt_stdout.txt",
    "code_path": "problem_iter2_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Exact fit gets highest priority\n    exact_fit = (bins_remain_cap == item)\n    priorities[exact_fit] = 1000.0\n\n    # Prioritize bins where the item fits, minimizing waste\n    fit = (bins_remain_cap >= item)\n    if np.any(fit):\n        waste = bins_remain_cap[fit] - item\n        # Inverse of waste: smaller waste = higher priority\n        priorities[fit] = 1.0 / (waste + 1e-6)  # Add small constant to avoid division by zero\n\n    return priorities",
    "response_id": 1,
    "obj": 4.198244914240141,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 53.77443751081735,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response2.txt_stdout.txt",
    "code_path": "problem_iter2_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, using Inverse Distance (Proximity Fit) strategy.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Calculate the distance between the item size and the remaining capacity of each bin\n    distances = np.abs(bins_remain_cap - item)\n\n    # Avoid division by zero by adding a small constant to the distances\n    distances = np.where(distances == 0, 1e-6, distances)\n\n    # Calculate the inverse distance (proximity fit)\n    priorities = 1.0 / distances\n\n    # Also consider bins where the item fits exactly, give them a high priority boost\n    exact_fit_bins = np.where(distances < 1e-6)[0]\n    priorities[exact_fit_bins] += 10  # Add a significant boost for exact fits\n    \n    # Penalize bins that are almost full to encourage spreading items\n    almost_full_penalty = np.where(bins_remain_cap < item * 1.1)[0]\n    priorities[almost_full_penalty] -= 2\n    \n    return priorities",
    "response_id": 2,
    "obj": 5.215396888711603,
    "SLOC": 10.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 100.07820003461549,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response3.txt_stdout.txt",
    "code_path": "problem_iter2_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Prioritize bins where the item fits exactly\n    exact_fit = bins_remain_cap == item\n    priorities[exact_fit] = 1.0\n    # Then prioritize bins where the item fits and leaves little remaining space\n    fits = bins_remain_cap >= item\n    if np.any(fits):\n        priorities[fits] = np.maximum(priorities[fits], 1.0 - (bins_remain_cap[fits] - item) / item)\n    return priorities",
    "response_id": 3,
    "obj": 4.198244914240141,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 49.82892142331044,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response4.txt_stdout.txt",
    "code_path": "problem_iter2_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    distances = np.abs(bins_remain_cap - item)\n    priorities = 1.0 / (distances + 1e-6)\n    \n    # Softmax to get probabilities for more stable selection\n    exp_priorities = np.exp(priorities)\n    probabilities = exp_priorities / np.sum(exp_priorities)\n    \n    return probabilities",
    "response_id": 4,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 41.51317942364757,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response5.txt_stdout.txt",
    "code_path": "problem_iter2_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Avoid division by zero and negative capacities.\n    valid_bins = bins_remain_cap > 0\n    bins_remain_cap_valid = bins_remain_cap[valid_bins]\n\n    # Sigmoid Fit Score: Fit = 1 / (1 + exp(-k * (capacity - item)))\n    # We want to find a 'k' that balances exploration and exploitation.\n    # A larger k favors bins where the item fits tightly. A smaller k is more exploratory.\n    k = 7.0  # Adjusted k value. Empirically determined. Higher value, tighter fit preferred\n    fit_scores = 1 / (1 + np.exp(-k * (bins_remain_cap_valid - item)))\n\n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[valid_bins] = fit_scores\n\n    return priorities",
    "response_id": 5,
    "obj": 11.188671719186283,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 68.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response6.txt_stdout.txt",
    "code_path": "problem_iter2_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    distances = np.abs(bins_remain_cap - item)\n    priorities = np.where(distances == 0, 1e9, 1.0 / distances)  # Extremely high priority if exact fit\n    return priorities",
    "response_id": 6,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 27.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response7.txt_stdout.txt",
    "code_path": "problem_iter2_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    can_fit = bins_remain_cap >= item\n\n    if not np.any(can_fit):\n        return priorities\n\n    # Assign a base priority to bins that can fit\n    priorities[can_fit] = 1.0\n\n    # Introduce a small random perturbation to the priority\n    # This encourages exploration, but avoids excessive randomness\n    random_noise = np.random.rand(len(bins_remain_cap)) * 0.1  # Adjust the factor for exploration intensity\n    priorities[can_fit] += random_noise[can_fit]\n\n    return priorities",
    "response_id": 7,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 25, in priority_v2\nnumpy._core._exceptions._UFuncOutputCastingError: Cannot cast ufunc 'add' output from dtype('float64') to dtype('int64') with casting rule 'same_kind'\n9\n2\n38.053747805010275\n"
  },
  {
    "stdout_filepath": "problem_iter2_response8.txt_stdout.txt",
    "code_path": "problem_iter2_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    can_fit = bins_remain_cap >= item\n\n    if not np.any(can_fit):\n        return priorities\n\n    priorities[can_fit] = 1\n    np.random.shuffle(priorities[can_fit])\n    return priorities",
    "response_id": 8,
    "obj": 4.487435181491823,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 11.60964047443681,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response9.txt_stdout.txt",
    "code_path": "problem_iter2_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Avoid division by zero and negative capacities.\n    valid_bins = bins_remain_cap > 0\n    bins_remain_cap_valid = bins_remain_cap[valid_bins]\n\n    # Sigmoid Fit Score: Fit = 1 / (1 + exp(-k * (capacity - item)))\n    # We want to find a 'k' that balances exploration and exploitation.\n    # A larger k favors bins where the item fits tightly. A smaller k is more exploratory.\n    k = 7.5  # Adjusted k value. Empirically determined. Higher value, tighter fit preferred.\n    fit_scores = 1 / (1 + np.exp(-k * (bins_remain_cap_valid - item)))\n\n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[valid_bins] = fit_scores\n\n    return priorities",
    "response_id": 9,
    "obj": 9.992022337455131,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 68.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response0.txt_stdout.txt",
    "code_path": "problem_iter3_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item  # Only consider bins that can fit the item\n\n    if np.sum(valid_bins) == 0:\n        return priorities # No bins can fit the item, return zero priorities\n\n    distances = bins_remain_cap[valid_bins] - item\n    \n    # Exact fit gets highest priority\n    exact_fit_indices = np.where(distances == 0)[0]\n    if len(exact_fit_indices) > 0:\n        priorities[valid_bins] = 0.0\n        priorities[valid_bins][exact_fit_indices] = 1.0 + 1e6\n        return priorities\n    \n    # Prioritize tighter fits using inverse distance\n    priorities[valid_bins] = 1.0 / (distances + 1e-6)\n    \n    return priorities",
    "response_id": 0,
    "obj": 4.487435181491823,
    "SLOC": 13.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 98.09910819000817,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response1.txt_stdout.txt",
    "code_path": "problem_iter3_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item  # Only consider bins with enough capacity\n\n    if np.any(valid_bins):\n        distances = bins_remain_cap[valid_bins] - item\n        # Prioritize exact fits\n        exact_fit_indices = np.where(distances == 0)[0]\n        if len(exact_fit_indices) > 0:\n            priorities[valid_bins] = 1.0\n            priorities[np.where(valid_bins)[0][exact_fit_indices]] = 2.0  # Boost exact fits\n        else:\n            # Prioritize tightest fits (inverse distance)\n            priorities[valid_bins] = 1.0 / (distances + 1e-6)\n\n    return priorities",
    "response_id": 1,
    "obj": 4.198244914240141,
    "SLOC": 12.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 70.32403072095333,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response2.txt_stdout.txt",
    "code_path": "problem_iter3_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Prioritize exact fits\n    exact_fit_indices = np.where(bins_remain_cap == item)[0]\n    priorities[exact_fit_indices] = 1000.0  # High priority for exact fits\n\n    # Prioritize tightest feasible fits\n    feasible_bins = bins_remain_cap[bins_remain_cap >= item]\n    distances = np.abs(feasible_bins - item)\n    \n    if len(distances) > 0:\n        priorities[np.where(bins_remain_cap >= item)[0]] = 1.0 / (distances + 1e-6)\n    \n    return priorities",
    "response_id": 2,
    "obj": 4.198244914240141,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 82.0447025077789,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response3.txt_stdout.txt",
    "code_path": "problem_iter3_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item  # Only consider bins that can fit the item\n\n    if np.sum(valid_bins) == 0:\n        return priorities  # No bin can fit the item\n\n    distances = bins_remain_cap[valid_bins] - item\n    priorities[valid_bins] = 1.0 / (np.abs(distances) + 1e-6)\n\n    # Boost exact fits\n    exact_fit_indices = np.where(distances == 0)[0]\n    if len(exact_fit_indices) > 0:\n      priorities[valid_bins[exact_fit_indices]] += 10.0\n\n    return priorities",
    "response_id": 3,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 25, in priority_v2\nIndexError: boolean index did not match indexed array along axis 0; size of axis is 4993 but size of corresponding boolean axis is 1\n11\n3\n101.95026032264605\n"
  },
  {
    "stdout_filepath": "problem_iter3_response4.txt_stdout.txt",
    "code_path": "problem_iter3_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item  # Only consider bins that can fit the item\n\n    if np.any(valid_bins):\n        distances = bins_remain_cap[valid_bins] - item\n        priorities[valid_bins] = 1.0 / (distances + 1e-6)  # Inverse distance\n        # Add a bonus for exact fits\n        exact_fit_indices = np.where(distances == 0)[0]\n        if len(exact_fit_indices) > 0:\n            priorities[valid_bins[exact_fit_indices]] += 1.0  # Higher priority for exact fits\n\n    return priorities",
    "response_id": 4,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 20, in priority_v2\n    priorities[valid_bins[exact_fit_indices]] += 1.0  # Higher priority for exact fits\nIndexError: boolean index did not match indexed array along axis 0; size of axis is 4993 but size of corresponding boolean axis is 1\n10\n3\n84.0\n"
  }
]