[
  {
    "stdout_filepath": "problem_iter16_response0.txt_stdout.txt",
    "code_path": "problem_iter16_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Prioritize bins where the item fits\n    fit_bins = bins_remain_cap >= item\n    priorities[fit_bins] = 1.0 / (bins_remain_cap[fit_bins] - item + 1e-9)\n\n    # Boost bins with ample remaining capacity\n    ample_space = bins_remain_cap > item * 1.5\n    priorities[ample_space] += 0.5\n\n    # Reward near-perfect matches\n    near_perfect = np.abs(bins_remain_cap - item) < item * 0.1\n    priorities[near_perfect] += 1.0\n    \n    # Add a small constant to all bins to avoid zero priorities\n    priorities += 0.01\n\n    return priorities",
    "response_id": 0,
    "obj": 1.8847227762265748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 165.05865002596164,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter16_response1.txt_stdout.txt",
    "code_path": "problem_iter16_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    # Prioritize bins where the item fits\n    fit_bins = bins_remain_cap >= item\n    \n    # Calculate the remaining capacity after adding the item\n    remaining_after_add = bins_remain_cap[fit_bins] - item\n\n    # Inverse of the remaining capacity after adding the item\n    priorities[fit_bins] = 1.0 / (remaining_after_add + 1e-9)\n    \n    # Boost bins with ample remaining capacity\n    priorities[bins_remain_cap > item * 1.5] += 0.5\n    \n    # Further boost bins where item fits very well (small gap)\n    priorities[np.abs(bins_remain_cap - item) < item * 0.1] += 1.0\n    \n    # Add a small constant to all bins to avoid zero priorities\n    priorities += 0.01\n    \n    return priorities",
    "response_id": 1,
    "obj": 1.8847227762265748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 165.05865002596164,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter16_response2.txt_stdout.txt",
    "code_path": "problem_iter16_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Inverse distance weighting\n    distances = np.abs(bins_remain_cap - item)\n    priorities = 1.0 / (distances + 1e-9)\n\n    # Reward spacious bins\n    priorities[bins_remain_cap > item * 1.2] += 0.1\n\n    # Reward near-full utilization (gentle)\n    priorities[bins_remain_cap < item * 0.9] += 0.05\n\n    # Gently penalize almost-full bins\n    priorities[bins_remain_cap < item * 0.4] -= 0.02\n\n    # Ensure priorities are non-negative\n    priorities = np.maximum(priorities, 0.0)\n    return priorities",
    "response_id": 2,
    "obj": 4.038691663342641,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 165.05865002596164,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter16_response3.txt_stdout.txt",
    "code_path": "problem_iter16_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    distances = np.abs(bins_remain_cap - item)\n    priorities = 1.0 / (distances + 1e-9)\n\n    # Reward bins where the item fits well (not too tight, not too loose)\n    priorities[(bins_remain_cap >= item * 0.8) & (bins_remain_cap <= item * 1.2)] += 0.4\n\n    # Reward spacious bins, but less aggressively\n    priorities[bins_remain_cap > item * 1.5] += 0.2\n\n    # Penalize almost full bins - avoid creating new ones if possible\n    priorities[bins_remain_cap < item * 0.2] -= 0.3\n\n    # Ensure non-negative priorities\n    priorities = np.maximum(priorities, 0.0)\n    return priorities",
    "response_id": 3,
    "obj": 2.6525727961707357,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 220.81007680238335,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter16_response4.txt_stdout.txt",
    "code_path": "problem_iter16_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    distances = np.abs(bins_remain_cap - item)\n    priorities = 1.0 / (distances + 1e-9)  # Inverse distance\n\n    # Reward spacious bins\n    priorities[bins_remain_cap > item * 2] += 0.1\n\n    # Reward near-full utilization\n    priorities[bins_remain_cap < item * 0.5] += 0.1\n\n    # Ensure non-negative priorities\n    priorities = np.maximum(priorities, 0.0)\n    return priorities",
    "response_id": 4,
    "obj": 3.3506182688472412,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 114.6940428629768,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter16_response5.txt_stdout.txt",
    "code_path": "problem_iter16_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Fit score: Higher for tighter fits, using a Gaussian-like function\n    fit_score = np.exp(-((bins_remain_cap - item)**2) / (2 * item**2))\n    \n    # Spaciousness bonus: Reward bins with enough space, scaled by remaining capacity\n    spaciousness_bonus = np.where(bins_remain_cap > item, bins_remain_cap / (item + 1e-6), 0.0) * 0.1\n    \n    # Small bonus for bins with sufficient remaining capacity, but not overly spacious\n    sufficient_space_bonus = np.where((bins_remain_cap > item * 0.5) & (bins_remain_cap < item * 2), 0.1, 0.0)\n    \n    priorities = fit_score + spaciousness_bonus + sufficient_space_bonus\n    \n    return priorities",
    "response_id": 5,
    "obj": 5.404866374152379,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 245.34452978042594,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter16_response6.txt_stdout.txt",
    "code_path": "problem_iter16_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    distances = np.abs(bins_remain_cap - item)\n    priorities = 1.0 / (distances + 1e-9)\n\n    # Boost priority for bins where item fits well (not too tight, not too loose)\n    priorities[(bins_remain_cap >= item * 0.7) & (bins_remain_cap <= item * 1.3)] += 1.0\n\n    # Reduce priority for overly spacious bins\n    priorities[bins_remain_cap > item * 2.0] -= 0.5\n\n    priorities = np.maximum(priorities, 0.0)\n    return priorities",
    "response_id": 6,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 167.17882283189007,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter16_response7.txt_stdout.txt",
    "code_path": "problem_iter16_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Prioritize bins where item fits well (close to remaining capacity)\n    fit_score = np.exp(-((bins_remain_cap - item)**2) / (bins_remain_cap**2 + 1e-9))\n    priorities = fit_score\n    \n    # Reward bins that are medium full\n    medium_full_reward = np.exp(-((bins_remain_cap / 1.0) - (item + bins_remain_cap / 2.0))**2 / 0.2)\n    priorities += 0.2 * medium_full_reward\n\n    # Penalize almost-full bins\n    priorities[bins_remain_cap < item * 0.2] -= 0.1\n    \n    # Ensure priorities are non-negative\n    priorities = np.maximum(priorities, 0.0)\n    \n    return priorities",
    "response_id": 7,
    "obj": 3.9688871160749857,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 255.15831097164298,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter16_response8.txt_stdout.txt",
    "code_path": "problem_iter16_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    distances = np.abs(bins_remain_cap - item)\n    priorities = 1.0 / (distances + 1e-9)\n\n    # Reward spacious bins\n    priorities[bins_remain_cap > item * 1.5] += 0.3\n    # Reward near-full utilization\n    priorities[bins_remain_cap < item * 0.5] += 0.2\n\n    priorities = np.maximum(priorities, 0.0)\n    return priorities",
    "response_id": 8,
    "obj": 1.8348623853211101,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 116.69205856195879,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter16_response9.txt_stdout.txt",
    "code_path": "problem_iter16_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Inverse distance weighting\n    distances = np.abs(bins_remain_cap - item)\n    priorities = 1.0 / (distances + 1e-9)\n\n    # Reward spacious bins\n    priorities[bins_remain_cap > item * 1.5] += 0.2\n\n    # Reward near-full utilization (gentle)\n    priorities[bins_remain_cap < item * 0.8] += 0.1\n\n    # Gently penalize almost-full bins\n    priorities[bins_remain_cap < item * 0.2] -= 0.1\n\n    # Ensure priorities are non-negative\n    priorities = np.maximum(priorities, 0.0)\n\n    return priorities",
    "response_id": 9,
    "obj": 1.6952532907858,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 160.5395382709427,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter17_response0.txt_stdout.txt",
    "code_path": "problem_iter17_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Weighted remaining capacity and fit\n    fit_score = item / bins_remain_cap\n    fit_score = np.where(fit_score > 1, 1, fit_score)  # Cap fit score at 1\n    priorities = 0.6 * (1 - fit_score) + 0.4 * (bins_remain_cap / np.max(bins_remain_cap))\n\n    # Reward spaciousness and near-full bins gently\n    priorities[bins_remain_cap > item * 1.5] += 0.1\n    priorities[bins_remain_cap < item * 0.5] += 0.05\n    \n    return priorities",
    "response_id": 0,
    "obj": 149.30195452732352,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 181.11039140121426,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter17_response1.txt_stdout.txt",
    "code_path": "problem_iter17_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Weighted remaining capacity and fit\n    fit = item / bins_remain_cap\n    fit = np.clip(fit, 0.0, 1.0)  # Ensure fit is between 0 and 1\n    priorities = 0.6 * bins_remain_cap / (item + 1e-9) + 0.4 * fit\n\n    # Reward spaciousness and near-full bins gently\n    priorities[bins_remain_cap > item * 1.5] += 0.1\n    priorities[bins_remain_cap < item * 0.5] += 0.05\n\n    # Ensure priorities are non-negative\n    priorities = np.maximum(priorities, 0.0)\n    return priorities",
    "response_id": 1,
    "obj": 149.30195452732352,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 162.84823041805248,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter17_response2.txt_stdout.txt",
    "code_path": "problem_iter17_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Weighted remaining capacity and fit\n    fit = item / bins_remain_cap\n    fit = np.clip(fit, 0.0, 1.0)  # Ensure fit is between 0 and 1\n    priorities = 0.6 * bins_remain_cap / (item + 1e-9) + 0.4 * fit\n\n    # Reward spaciousness and near-full bins gently\n    priorities[bins_remain_cap > item * 1.5] += 0.1\n    priorities[bins_remain_cap < item * 0.5] += 0.05\n\n    return priorities",
    "response_id": 2,
    "obj": 149.30195452732352,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 162.84823041805248,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter17_response3.txt_stdout.txt",
    "code_path": "problem_iter17_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Weighted remaining capacity and fit\n    fit = item / bins_remain_cap\n    fit = np.clip(fit, 0.0, 1.0)  # Ensure fit is between 0 and 1\n    priorities = 0.6 * bins_remain_cap / (item + 1e-9) + 0.4 * fit\n\n    # Reward spaciousness and near-full bins gently\n    priorities[bins_remain_cap > item * 1.5] += 0.1\n    priorities[bins_remain_cap < item * 0.5] += 0.05\n\n    # Ensure priorities are non-negative\n    priorities = np.maximum(priorities, 0.0)\n\n    return priorities",
    "response_id": 3,
    "obj": 149.30195452732352,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 162.84823041805248,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter17_response4.txt_stdout.txt",
    "code_path": "problem_iter17_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Weighted remaining capacity and fit\n    fit = item / bins_remain_cap\n    fit = np.clip(fit, 0.0, 1.0)  # Ensure fit is between 0 and 1\n    priorities = 0.6 * bins_remain_cap / (item + 1e-9) + 0.4 * fit  # Weighting\n\n    # Reward spaciousness and near-full bins gently\n    priorities[bins_remain_cap > item * 1.5] += 0.1\n    priorities[bins_remain_cap < item * 0.5] += 0.05\n\n    # Ensure priorities are non-negative\n    priorities = np.maximum(priorities, 0.0)\n    return priorities",
    "response_id": 4,
    "obj": 149.30195452732352,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 162.84823041805248,
    "exec_success": true
  }
]