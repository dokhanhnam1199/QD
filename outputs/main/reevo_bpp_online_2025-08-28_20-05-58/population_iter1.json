[
  {
    "stdout_filepath": "problem_iter1_response0.txt_stdout.txt",
    "code_path": "problem_iter1_code0.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Prioritize bins where the item fits exactly\n    exact_fit = bins_remain_cap == item\n    priorities[exact_fit] = 1.0\n\n    # Then prioritize bins where the item fits and leaves little remaining space\n    fits = bins_remain_cap >= item\n    priorities[fits] = np.maximum(priorities[fits], 1.0 - (bins_remain_cap[fits] - item) / item) # Higher score if less remaining space\n\n    return priorities",
    "response_id": 0,
    "obj": 4.198244914240141,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 49.82892142331044,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response1.txt_stdout.txt",
    "code_path": "problem_iter1_code1.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Best Fit strategy.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return priorities  # No bin can fit the item\n\n    # Calculate the difference between the item size and the remaining capacity\n    waste = bins_remain_cap[valid_bins] - item\n    \n    # Prioritize bins with the smallest waste (Best Fit)\n    priorities[valid_bins] = 1.0 / (waste + 1e-9)  # Adding a small value to avoid division by zero\n\n    return priorities",
    "response_id": 1,
    "obj": 4.198244914240141,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 51.80615605397529,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response2.txt_stdout.txt",
    "code_path": "problem_iter1_code2.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Worst Fit.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    for i in range(len(bins_remain_cap)):\n        if bins_remain_cap[i] >= item:\n            priorities[i] = bins_remain_cap[i] - item  # The larger the remaining capacity after placing the item, the higher the priority\n    return priorities",
    "response_id": 2,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.999966359999235 seconds"
  },
  {
    "stdout_filepath": "problem_iter1_response3.txt_stdout.txt",
    "code_path": "problem_iter1_code3.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Almost Full Fit.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    for i in range(len(bins_remain_cap)):\n        if bins_remain_cap[i] >= item:\n            priorities[i] = bins_remain_cap[i] - item\n    return priorities",
    "response_id": 3,
    "obj": 149.30195452732352,
    "SLOC": 6.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 13.931568569324174,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response4.txt_stdout.txt",
    "code_path": "problem_iter1_code4.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Exact Fit First strategy.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Exact fit gets highest priority\n    exact_fit_indices = np.where(bins_remain_cap == item)[0]\n    priorities[exact_fit_indices] = 1.0\n\n    # Second best, bins that can fit the item, prioritize based on less remaining capacity.\n    # This strategy attempts to fill bins more completely.\n    fit_indices = np.where(bins_remain_cap >= item)[0]\n    if len(fit_indices) > 0:\n        remaining_capacities = bins_remain_cap[fit_indices]\n        # Inverse of remaining capacity: smaller capacity = higher priority\n        priorities[fit_indices] = 1.0 / (remaining_capacities + 1e-6)  # Add a small value to avoid division by zero\n\n    return priorities",
    "response_id": 4,
    "obj": 4.487435181491823,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 55.506595772116384,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response5.txt_stdout.txt",
    "code_path": "problem_iter1_code5.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Calculate the distance between the item size and the remaining capacity of each bin.\n    distances = np.abs(bins_remain_cap - item)\n\n    # Assign priority scores based on the inverse of the distance.\n    # Add a small constant to avoid division by zero and stabilize the function\n    priorities = 1.0 / (distances + 1e-6)\n\n    return priorities",
    "response_id": 5,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 28.529325012980813,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response6.txt_stdout.txt",
    "code_path": "problem_iter1_code6.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Sigmoid Fit Score.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Avoid division by zero and negative capacities.\n    valid_bins = bins_remain_cap > 0\n    bins_remain_cap_valid = bins_remain_cap[valid_bins]\n\n    # Sigmoid Fit Score:  Fit = 1 / (1 + exp(-k * (capacity - item)))\n    # We want to find a 'k' that balances exploration and exploitation.\n    # A larger k favors bins where the item fits tightly.  A smaller k is more exploratory.\n    k = 5.0  # Adjusted k value. Empirically determined. Higher value, tighter fit preferred\n\n    fit_scores = 1 / (1 + np.exp(-k * (bins_remain_cap_valid - item)))\n    \n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[valid_bins] = fit_scores\n\n    return priorities",
    "response_id": 6,
    "obj": 13.40247307538892,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 68.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response7.txt_stdout.txt",
    "code_path": "problem_iter1_code7.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Random Fit.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    # Find bins that can fit the item\n    feasible_bins = bins_remain_cap >= item\n\n    # If no bins can fit the item, return 0 priorities\n    if not np.any(feasible_bins):\n        return priorities\n    \n    # Assign priority based on a random subset of feasible bins.\n    num_feasible = np.sum(feasible_bins)\n    \n    # Select a random number of feasible bins (between 1 and all feasible bins)\n    num_to_consider = np.random.randint(1, num_feasible + 1)\n\n    # Randomly choose indices of feasible bins to assign priority to\n    random_indices = np.random.choice(np.where(feasible_bins)[0], size=num_to_consider, replace=False)\n\n    # Assign priority 1 to selected bins\n    priorities[random_indices] = 1\n    \n    return priorities",
    "response_id": 7,
    "obj": 4.946150777822112,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 24.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response8.txt_stdout.txt",
    "code_path": "problem_iter1_code8.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.1) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Epsilon-Greedy strategy.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        epsilon: Probability of exploration (choosing a random bin).\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Calculate 'greedy' priority: bins where the item fits\n    valid_bins = bins_remain_cap >= item\n    priorities[valid_bins] = bins_remain_cap[valid_bins] - item  # Lower remainder is better\n\n    # Epsilon-Greedy Exploration\n    if np.random.rand() < epsilon:\n        # Randomly assign priorities to all bins\n        priorities = np.random.rand(len(bins_remain_cap))\n    \n    return priorities",
    "response_id": 8,
    "obj": 138.4623055444755,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 27.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response9.txt_stdout.txt",
    "code_path": "problem_iter1_code9.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Softmax-Based Fit.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate fit score for each bin.  A higher fit score means the item\n    # fits better in the bin (less wasted space).\n    fit_scores = np.where(bins_remain_cap >= item, bins_remain_cap - item, 0)\n\n    # Normalize fit scores using softmax to get probabilities\n    exp_fit_scores = np.exp(fit_scores)\n    sum_exp_fit_scores = np.sum(exp_fit_scores)\n\n    if sum_exp_fit_scores == 0:\n        # Handle the case where the item doesn't fit in any bin to avoid division by zero\n        priorities = np.zeros_like(bins_remain_cap)\n    else:\n        probabilities = exp_fit_scores / sum_exp_fit_scores\n        priorities = probabilities\n\n    return priorities",
    "response_id": 9,
    "obj": 149.30195452732352,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 38.03910001730775,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response10.txt_stdout.txt",
    "code_path": "problem_iter1_code10.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, using First Fit Decreasing principles\n    but adapted for online packing and scoring.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # First Fit: Prefer bins where the item fits exactly\n    exact_fit = bins_remain_cap == item\n    priorities[exact_fit] = 1.0\n\n    # Second: Prefer bins where the item fits with minimal remaining space\n    remaining_space = bins_remain_cap - item\n    valid_bins = remaining_space >= 0\n    if np.any(valid_bins):\n        priorities[valid_bins] = 1.0 / (remaining_space[valid_bins] + 1e-6)  # Add a small value to prevent division by zero\n\n    # Third: Prioritize less utilized bins\n    priorities += (1 - bins_remain_cap / np.max(bins_remain_cap)) * 0.2\n\n    return priorities",
    "response_id": 10,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 38, in priority_v2\nnumpy._core._exceptions._UFuncOutputCastingError: Cannot cast ufunc 'add' output from dtype('float64') to dtype('int64') with casting rule 'same_kind'\n10\n2\n116.69205856195879\n"
  },
  {
    "stdout_filepath": "problem_iter1_response11.txt_stdout.txt",
    "code_path": "problem_iter1_code11.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Best Fit strategy: Prioritize bins where the item fits snugly (smallest leftover space).\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return priorities  # No bin can fit the item\n\n    leftover_space = bins_remain_cap[valid_bins] - item\n    priorities[valid_bins] = 1.0 / (leftover_space + 1e-6)  # Avoid division by zero, prioritize smaller leftover space\n\n    return priorities",
    "response_id": 11,
    "obj": 4.198244914240141,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 51.80615605397529,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response12.txt_stdout.txt",
    "code_path": "problem_iter1_code12.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, using Worst Fit.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    # Calculate the difference between bin capacity and item size\n    diffs = bins_remain_cap - item\n    \n    # Filter bins that can accommodate the item\n    valid_bins = diffs >= 0\n    \n    if np.any(valid_bins):\n        # Calculate the maximum remaining capacity after placing the item (Worst Fit)\n        max_remaining_cap = np.max(diffs[valid_bins])\n        \n        # Assign priority based on the maximum remaining capacity\n        for i in range(len(bins_remain_cap)):\n            if valid_bins[i]:\n                if diffs[i] == max_remaining_cap:\n                    priorities[i] = 1.0  # Highest priority\n                else:\n                    priorities[i] = 0.0 \n    \n    return priorities",
    "response_id": 12,
    "obj": 149.30195452732352,
    "SLOC": 13.0,
    "cyclomatic_complexity": 5.0,
    "halstead": 28.529325012980813,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response13.txt_stdout.txt",
    "code_path": "problem_iter1_code13.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Almost Full Fit.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    for i in range(len(bins_remain_cap)):\n        if bins_remain_cap[i] >= item:\n            priorities[i] = bins_remain_cap[i] - item  # Prioritize bins that leave the least amount of space\n    return priorities",
    "response_id": 13,
    "obj": 149.30195452732352,
    "SLOC": 6.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 13.931568569324174,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response14.txt_stdout.txt",
    "code_path": "problem_iter1_code14.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Using Exact Fit First strategy. Prioritize bins where the item fits exactly.\n    If no exact fit, prioritize bins with the smallest remaining capacity.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    exact_fit_indices = np.where(bins_remain_cap == item)[0]\n    if len(exact_fit_indices) > 0:\n        priorities[exact_fit_indices] = 1.0  # Highest priority for exact fits\n    else:\n        # If no exact fit, prioritize bins with the smallest remaining capacity\n        sorted_indices = np.argsort(bins_remain_cap)\n        for i, index in enumerate(sorted_indices):\n            if bins_remain_cap[index] >= item:\n                priorities[index] = 1.0 / (i + 1)  # Higher priority for smaller remaining capacities\n    return priorities",
    "response_id": 14,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 4.0,
    "halstead": 55.506595772116384,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response15.txt_stdout.txt",
    "code_path": "problem_iter1_code15.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Inverse Distance (Proximity Fit).\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if np.sum(valid_bins) == 0:\n        return priorities  # No bin can fit the item\n\n    # Calculate the remaining space after adding the item to each valid bin.\n    remaining_space = bins_remain_cap[valid_bins] - item\n\n    # Calculate the inverse distance (proximity fit) priority.\n    # Prioritize bins where the remaining space is as close as possible to 0\n    # without being negative (already handled by the valid_bins check).\n    priorities[valid_bins] = 1.0 / (remaining_space + 1e-6)  # Add a small epsilon to avoid division by zero\n\n    return priorities",
    "response_id": 15,
    "obj": 4.198244914240141,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 57.110323830864054,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response16.txt_stdout.txt",
    "code_path": "problem_iter1_code16.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Sigmoid Fit Score.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the fit score for each bin using a sigmoid function.\n    # Fit score is high when the item fits well into the remaining capacity.\n    # The sigmoid function ensures that the score is between 0 and 1.\n    # We use a scaling factor of 10 to adjust the sigmoid curve.\n    fit_scores = 1 / (1 + np.exp(-10 * (bins_remain_cap - item)))\n\n    # Prioritize bins with higher fit scores.\n    priorities = fit_scores\n\n    return priorities",
    "response_id": 16,
    "obj": 8.944954128440372,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 51.80615605397529,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response17.txt_stdout.txt",
    "code_path": "problem_iter1_code17.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Assign higher priority to bins where the item fits exactly\n    exact_fit = (bins_remain_cap == item)\n    priorities[exact_fit] = 1.0\n\n    # Assign higher priority to bins with smaller remaining capacity\n    # (Best-Fit decreasing heuristic influence)\n    priorities += (bins_remain_cap - item) / bins_remain_cap\n\n    # Add a small random noise to break ties\n    priorities += np.random.rand(len(bins_remain_cap)) * 0.001\n    \n    # Penalize bins that are almost full. This helps avoid creating new bins unnecessarily.\n    priorities[bins_remain_cap < item*1.2] -=0.5 \n\n    return priorities",
    "response_id": 17,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 29, in priority_v2\n    # Apply epsilon-greedy strategy\nnumpy._core._exceptions._UFuncOutputCastingError: Cannot cast ufunc 'add' output from dtype('float64') to dtype('int64') with casting rule 'same_kind'\n8\n1\n112.58797503894243\n"
  },
  {
    "stdout_filepath": "problem_iter1_response18.txt_stdout.txt",
    "code_path": "problem_iter1_code18.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.1) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Epsilon-Greedy.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        epsilon: Probability of choosing a random bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    # Calculate the 'greedy' priority: how much space remains after putting the item in\n    valid_bins = bins_remain_cap >= item\n    priorities[valid_bins] = bins_remain_cap[valid_bins] - item\n\n    # Apply epsilon-greedy strategy\n    if np.random.rand() < epsilon:\n        # Choose a bin randomly (from bins that can fit the item)\n        if np.any(valid_bins):\n            random_bin_index = np.random.choice(np.where(valid_bins)[0])\n            priorities = np.zeros_like(bins_remain_cap)\n            priorities[random_bin_index] = 1.0  # Assign highest priority to the random bin\n    else:\n        # Use the greedy priorities\n        pass\n        \n    return priorities",
    "response_id": 18,
    "obj": 138.26286398085364,
    "SLOC": 12.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 27.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response19.txt_stdout.txt",
    "code_path": "problem_iter1_code19.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Softmax-Based Fit.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    \n    # Calculate the fit score for each bin (how well the item fits in the bin)\n    fit_scores = np.where(bins_remain_cap >= item, bins_remain_cap - item, 0)\n    \n    # Apply Softmax to the fit scores to get the priorities\n    # Add a small constant to avoid division by zero\n    exp_scores = np.exp(fit_scores / 0.1)\n    \n    # Normalize the exponential scores to get probabilities (priorities)\n    priorities = exp_scores / np.sum(exp_scores)\n    \n    return priorities",
    "response_id": 19,
    "obj": 141.04507379337855,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 38.03910001730775,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response20.txt_stdout.txt",
    "code_path": "problem_iter1_code20.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, using First Fit Decreasing inspired heuristic.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Prioritize bins where the item fits exactly\n    exact_fit = (bins_remain_cap == item)\n    priorities[exact_fit] = 1000  # High priority for exact fit\n\n    # Then prioritize bins where the item fits and leaves the least amount of space\n    fit = (bins_remain_cap >= item)\n    if np.any(fit):\n        remaining_space = bins_remain_cap[fit] - item\n        priorities[fit] = 1.0 / (remaining_space + 1e-6)  # Avoid division by zero\n\n    return priorities",
    "response_id": 20,
    "obj": 4.198244914240141,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 53.77443751081735,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response21.txt_stdout.txt",
    "code_path": "problem_iter1_code21.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Best Fit strategy.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Calculate the difference between bin capacity and item size\n    diff = bins_remain_cap - item\n    # Assign priority based on the smallest remaining capacity after placing the item\n    # Higher priority for bins where the item fits and leaves the least amount of space\n    valid_bins = diff >= 0\n    if np.any(valid_bins):\n        priorities[valid_bins] = 1.0 / diff[valid_bins]  # Inverse of remaining space\n    return priorities",
    "response_id": 21,
    "obj": 5.275229357798175,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 28.529325012980813,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response22.txt_stdout.txt",
    "code_path": "problem_iter1_code22.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Worst Fit.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    for i in range(len(bins_remain_cap)):\n        if bins_remain_cap[i] >= item:\n            priorities[i] = bins_remain_cap[i] - item\n    return priorities",
    "response_id": 22,
    "obj": 149.30195452732352,
    "SLOC": 6.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 13.931568569324174,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response23.txt_stdout.txt",
    "code_path": "problem_iter1_code23.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Almost Full Fit strategy.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    # Calculate the \"almost full\" threshold.  We consider bins that are within\n    # item size of being full as high priority\n    threshold = item \n\n    # Prioritize bins where the item fits\n    feasible_bins = bins_remain_cap >= item\n    priorities[feasible_bins] = 1.0 \n\n    # Among feasible bins, prioritize those that are close to full\n    remaining_capacities = bins_remain_cap[feasible_bins]\n    bin_fullness = 1.0 - (remaining_capacities / bins_remain_cap[feasible_bins]) #Ratio of how much is filled in each bin\n    priorities[feasible_bins] += bin_fullness * 0.5\n\n    return priorities",
    "response_id": 23,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 35, in priority_v2\nnumpy._core._exceptions._UFuncOutputCastingError: Cannot cast ufunc 'add' output from dtype('float64') to dtype('int64') with casting rule 'same_kind'\n9\n1\n58.60335893412778\n"
  },
  {
    "stdout_filepath": "problem_iter1_response24.txt_stdout.txt",
    "code_path": "problem_iter1_code24.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Exact Fit First strategy.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    for i, cap in enumerate(bins_remain_cap):\n        if abs(cap - item) < 1e-6:  # Check for exact fit (using a small tolerance)\n            priorities[i] = 1.0\n        elif cap >= item:\n            priorities[i] = 0.5  # Give some priority to bins that can fit the item\n    return priorities",
    "response_id": 24,
    "obj": 4.198244914240141,
    "SLOC": 8.0,
    "cyclomatic_complexity": 4.0,
    "halstead": 25.26619429851844,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response25.txt_stdout.txt",
    "code_path": "problem_iter1_code25.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin,\n    using Inverse Distance (Proximity Fit) strategy.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Calculate the distance between the item size and the remaining capacity of each bin\n    distances = np.abs(bins_remain_cap - item)\n    \n    # Avoid division by zero by adding a small constant to the distances\n    distances = np.where(distances == 0, 1e-6, distances)\n    \n    # Calculate the inverse distance (proximity fit)\n    priorities = 1.0 / distances\n    \n    return priorities",
    "response_id": 25,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 27.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response26.txt_stdout.txt",
    "code_path": "problem_iter1_code26.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Sigmoid Fit Score.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the fit score for each bin. Fit score = remaining_capacity / item_size\n    fit_scores = bins_remain_cap / item\n\n    # Apply a sigmoid function to the fit scores to scale them between 0 and 1.\n    # The sigmoid function is defined as: sigmoid(x) = 1 / (1 + exp(-x))\n    # We use a scaling factor of 1.0 to control the steepness of the sigmoid curve.  This can be tuned.\n    scaled_fit_scores = 1.0 / (1.0 + np.exp(-1.0 * fit_scores))\n\n    # Prioritize bins with higher sigmoid-scaled fit scores.\n    priorities = scaled_fit_scores\n\n    return priorities",
    "response_id": 26,
    "obj": 149.27203829278022,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 48.43204266092217,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response27.txt_stdout.txt",
    "code_path": "problem_iter1_code27.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Random Fit.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Create a boolean array indicating which bins can fit the item\n    can_fit = bins_remain_cap >= item\n\n    # If no bins can fit the item, return zero priorities.\n    if not np.any(can_fit):\n        return priorities\n\n    # Assign priority 1 to bins that can fit the item.\n    priorities[can_fit] = 1\n\n    #Randomly shuffle the priorities within those that can fit. This is the \"random\" aspect of Random Fit\n    np.random.shuffle(priorities[can_fit])\n\n    return priorities",
    "response_id": 27,
    "obj": 4.487435181491823,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 11.60964047443681,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response28.txt_stdout.txt",
    "code_path": "problem_iter1_code28.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.1) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, using Epsilon-Greedy.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        epsilon: Probability of exploration.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    # Feasible bins only\n    feasible_bins = bins_remain_cap >= item\n    \n    if np.sum(feasible_bins) == 0:\n        return priorities  # No bin can accommodate the item\n    \n    # Greedy part: Best fit (highest remaining capacity)\n    best_bin_index = np.argmax(bins_remain_cap[feasible_bins])\n    greedy_priority = bins_remain_cap[feasible_bins][best_bin_index] \n\n    # Exploration part\n    if np.random.rand() < epsilon:\n        # Randomly choose a feasible bin\n        random_bin_index = np.random.choice(np.where(feasible_bins)[0])\n        priorities[random_bin_index] = greedy_priority * (1 + np.random.rand() * 0.5) \n    else:\n        # Exploitation: Assign highest priority to best fit bin\n        priorities[feasible_bins] = greedy_priority\n\n    return priorities",
    "response_id": 28,
    "obj": 14.499401675309146,
    "SLOC": 13.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 73.57433114250613,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response29.txt_stdout.txt",
    "code_path": "problem_iter1_code29.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Softmax-Based Fit.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the fit for each bin\n    fit = bins_remain_cap - item\n    fit[fit < 0] = -1e9  # Assign a very low value to bins that cannot fit the item\n\n    # Calculate softmax probabilities\n    exp_fit = np.exp(fit)\n    probabilities = exp_fit / np.sum(exp_fit)\n\n    return probabilities",
    "response_id": 29,
    "obj": 149.30195452732352,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 38.053747805010275,
    "exec_success": true
  }
]