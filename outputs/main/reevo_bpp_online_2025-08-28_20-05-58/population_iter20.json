[
  {
    "stdout_filepath": "problem_iter20_response0.txt_stdout.txt",
    "code_path": "problem_iter20_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    # Prioritize bins where the item fits\n    fit_bins = bins_remain_cap >= item\n    if np.any(fit_bins):\n        remaining_after_add = bins_remain_cap[fit_bins] - item\n        priorities[fit_bins] = 1.0 / (remaining_after_add + 1e-9)  # Inverse remaining capacity\n\n    # Reward bins with ample remaining capacity (not too full)\n    priorities[bins_remain_cap > item * 1.5] += 0.2\n\n    # Reward bins where the item fits very well (small gap)\n    priorities[np.abs(bins_remain_cap - item) < item * 0.3] += 0.8\n\n    # Add a small constant to all bins to avoid zero priorities and encourage exploration\n    priorities += 0.005\n\n    return priorities",
    "response_id": 0,
    "obj": 3.470283207020339,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 167.17882283189007,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response1.txt_stdout.txt",
    "code_path": "problem_iter20_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Inverse distance weighting to remaining capacity\n    distances = np.abs(bins_remain_cap - item)\n    priorities = 1.0 / (distances + 1e-9)  # Add small value to avoid division by zero\n\n    # Reward spacious bins and near-full utilization\n    priorities[bins_remain_cap > item * 1.75] += 0.15  # Increased spaciousness reward\n    priorities[bins_remain_cap < item * 0.25] += 0.2   # Increased near-full reward\n\n    # Ensure priorities are non-negative\n    priorities = np.maximum(priorities, 0.0)\n    return priorities",
    "response_id": 1,
    "obj": 2.0741922616673385,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 116.69205856195879,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response2.txt_stdout.txt",
    "code_path": "problem_iter20_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    distances = np.abs(bins_remain_cap - item)\n    priorities = 1.0 / (distances + 1e-9)  # Inverse distance weighting\n\n    # Reward spacious bins (more than 1.5x the item size)\n    priorities[bins_remain_cap > item * 1.5] += 0.3\n\n    # Reward near-full utilization (less than 0.5x the item size remaining)\n    priorities[bins_remain_cap < item * 0.5] += 0.2\n\n    # Ensure priorities are non-negative\n    priorities = np.maximum(priorities, 0.0)\n    return priorities",
    "response_id": 2,
    "obj": 1.8348623853211101,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 116.69205856195879,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response3.txt_stdout.txt",
    "code_path": "problem_iter20_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Inverse distance weighting\n    distances = np.abs(bins_remain_cap - item)\n    priorities = 1.0 / (distances + 1e-9)\n\n    # Reward spacious bins (moderate)\n    priorities[bins_remain_cap > item * 1.2] += 0.03\n\n    # Reward near-full utilization (gentle)\n    priorities[bins_remain_cap < item * 0.9] += 0.02\n\n    # Gently penalize almost-full bins\n    priorities[bins_remain_cap < item * 0.4] -= 0.005\n\n    # Ensure priorities are non-negative\n    priorities = np.maximum(priorities, 0.0)\n    return priorities",
    "response_id": 3,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 165.05865002596164,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response4.txt_stdout.txt",
    "code_path": "problem_iter20_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    distances = np.abs(bins_remain_cap - item)\n    priorities = 1.0 / (distances + 1e-9)  # Inverse distance\n\n    # Reward bins where the item fits well (smooth reward)\n    fit_reward = np.exp(-((bins_remain_cap - item) ** 2) / (item ** 2 + 1e-9))\n    priorities += 0.4 * fit_reward\n\n    # Reward bins with moderate utilization\n    utilization = bins_remain_cap / 1.0  # Assuming bin capacity is 1.0\n    utilization_reward = np.exp(-((utilization - 0.6) ** 2) / 0.05)  # Center around 0.6\n    priorities += 0.3 * utilization_reward\n\n    # Penalize bins that are almost full to prevent fragmentation\n    priorities[bins_remain_cap < item * 0.2] -= 0.6\n\n    priorities = np.maximum(priorities, 0.0)\n    return priorities",
    "response_id": 4,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 312.88626403364293,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response5.txt_stdout.txt",
    "code_path": "problem_iter20_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Fit: Inverse distance to ideal.\n    distances = np.abs(bins_remain_cap - item)\n    priorities = 1.0 / (distances + 1e-9)\n\n    # Weighted remaining capacity. Reward spaciousness and near-full bins.\n    # Gentle rewards, avoid extremes.\n    priorities[bins_remain_cap > item * 1.1] += 0.08  # Reward spacious bins\n    priorities[bins_remain_cap < item * 0.9] += 0.12  # Reward near-full bins\n\n    # Ensure priorities are non-negative\n    priorities = np.maximum(priorities, 0.0)\n    return priorities",
    "response_id": 5,
    "obj": 4.01874750698045,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 116.69205856195879,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response6.txt_stdout.txt",
    "code_path": "problem_iter20_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Calculate relative fit: how close is the item size to the bin's remaining capacity?\n    relative_fit = np.abs(bins_remain_cap - item) / item\n\n    # Invert relative fit to get a basic priority: smaller relative fit -> higher priority\n    priorities = 1.0 / (relative_fit + 1e-9)\n\n    # Penalize bins that are extremely spacious or nearly empty\n    priorities[bins_remain_cap > item * 3.0] -= 0.4\n    priorities[bins_remain_cap < item * 0.6] -= 0.2\n\n    # Boost priority for bins where item fits reasonably well\n    priorities[(bins_remain_cap >= item * 0.7) & (bins_remain_cap <= item * 1.3)] += 0.6\n\n    priorities = np.maximum(priorities, 0.0)\n    return priorities",
    "response_id": 6,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 237.80142289857002,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response7.txt_stdout.txt",
    "code_path": "problem_iter20_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Inverse distance to item size\n    distances = np.abs(bins_remain_cap - item)\n    priorities = 1.0 / (distances + 1e-9)\n\n    # Reward spaciousness (large remaining capacity, relative to item size)\n    priorities += 0.5 * (bins_remain_cap / (item + 1e-9))\n\n    # Reward near-full utilization (small remaining capacity) - more aggressive\n    priorities += 0.3 * (1.0 / (bins_remain_cap + 1e-9))\n\n    # Penalize bins that are too small\n    priorities[bins_remain_cap < item] = 0.0\n\n    # Ensure priorities are non-negative\n    priorities = np.maximum(priorities, 0.0)\n    return priorities",
    "response_id": 7,
    "obj": 84.41364180295174,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 155.58941141594505,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response8.txt_stdout.txt",
    "code_path": "problem_iter20_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Fit: Inverse distance to ideal\n    fit_bins = bins_remain_cap >= item\n    priorities[fit_bins] = 1.0 / (bins_remain_cap[fit_bins] - item + 1e-9)\n\n    # Ample space: Reward spaciousness\n    ample_space = bins_remain_cap > item * 1.5\n    priorities[ample_space] += 0.3\n\n    # Near-full: Prioritize filling bins almost completely\n    near_full = np.abs(bins_remain_cap - item) < item * 0.2\n    priorities[near_full] += 0.8\n\n    # Small bonus to all bins to encourage use\n    priorities += 0.005\n\n    return priorities",
    "response_id": 8,
    "obj": 2.602712405265271,
    "SLOC": 10.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 167.17882283189007,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response9.txt_stdout.txt",
    "code_path": "problem_iter20_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Prioritize bins where the item fits\n    fit_bins = bins_remain_cap >= item\n    if np.any(fit_bins):\n        priorities[fit_bins] = 1.0 / (bins_remain_cap[fit_bins] - item + 1e-9)  # Inverse remaining capacity\n\n    # Reward bins with ample remaining capacity (not too full)\n    priorities[bins_remain_cap > item * 1.5] += 0.5\n\n    # Reward bins with a good fit (small gap)\n    priorities[np.abs(bins_remain_cap - item) < item * 0.5] += 0.5\n\n    # Add a small constant to all bins to encourage exploration\n    priorities += 0.01\n\n    return priorities",
    "response_id": 9,
    "obj": 4.038691663342641,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 162.84823041805248,
    "exec_success": true
  }
]