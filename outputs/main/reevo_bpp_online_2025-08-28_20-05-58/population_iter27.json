[
  {
    "stdout_filepath": "problem_iter26_response0.txt_stdout.txt",
    "code_path": "problem_iter26_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Feasible Fit: Inverse distance to remaining capacity\n    fit_bins = bins_remain_cap >= item\n    if np.any(fit_bins):\n        priorities[fit_bins] = 1.0 / (bins_remain_cap[fit_bins] - item + 1e-9)\n\n    # Spaciousness: Reward bins with ample remaining capacity\n    spacious_bins = bins_remain_cap > item * 1.5\n    priorities[spacious_bins] += 0.6\n\n    # Near-full: Prioritize filling bins almost completely\n    near_full_bins = np.abs(bins_remain_cap - item) < item * 0.3\n    priorities[near_full_bins] += 1.2\n\n    # Small bonus to all bins to encourage use, but less than spacious/near-full\n    priorities += 0.01\n\n    return priorities",
    "response_id": 0,
    "obj": 3.470283207020339,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 167.17882283189007,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter26_response1.txt_stdout.txt",
    "code_path": "problem_iter26_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    # Fit: Inverse distance to remaining capacity\n    distances = np.abs(bins_remain_cap - item)\n    priorities = 1.0 / (distances + 1e-9)\n\n    # Relative capacity bonuses (tuned)\n    priorities[bins_remain_cap >= item * 1.2] += 0.08  # Spacious bins\n    priorities[bins_remain_cap <= item * 0.8] += 0.06  # Near-full bins\n\n    return priorities",
    "response_id": 1,
    "obj": 4.108496210610296,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 116.69205856195879,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter26_response2.txt_stdout.txt",
    "code_path": "problem_iter26_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Feasible Fit: Inverse distance to remaining capacity\n    fit_bins = bins_remain_cap >= item\n    if np.any(fit_bins):\n        priorities[fit_bins] = 1.0 / (bins_remain_cap[fit_bins] - item + 1e-9)\n\n    # Spaciousness: Reward bins with ample remaining capacity\n    spacious_bins = bins_remain_cap > item * 1.5\n    priorities[spacious_bins] += 0.8\n\n    # Near-full: Prioritize filling bins almost completely\n    near_full_bins = np.abs(bins_remain_cap - item) < item * 0.2\n    priorities[near_full_bins] += 1.2\n\n    return priorities",
    "response_id": 2,
    "obj": 2.5927403270841647,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 149.27754454988144,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter26_response3.txt_stdout.txt",
    "code_path": "problem_iter26_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Fit: Inverse distance to remaining capacity\n    distances = np.abs(bins_remain_cap - item)\n    priorities = 1.0 / (distances + 1e-9)\n\n    # Relative Capacity: Smoothly reward near-full and spacious bins\n    relative_capacity = bins_remain_cap / (np.max(bins_remain_cap) + 1e-9) # Normalize to 0-1\n    priorities += 0.2 * np.exp(-((relative_capacity - 0.8)**2) / 0.02) # Near full\n    priorities += 0.1 * np.exp(-((relative_capacity - 0.2)**2) / 0.05) # Spacious\n\n    return priorities",
    "response_id": 3,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 245.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter26_response4.txt_stdout.txt",
    "code_path": "problem_iter26_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Fit: Inverse distance to remaining capacity\n    distances = np.abs(bins_remain_cap - item)\n    priorities = 1.0 / (distances + 1e-9)\n\n    # Relative capacity: Reward near-full & spaciousness (tuned bonuses)\n    priorities[bins_remain_cap >= item * 1.2] += 0.08  # Spacious bins\n    priorities[bins_remain_cap <= item * 0.8] += 0.1  # Near-full bins\n\n    # Ensure non-negative priorities\n    priorities = np.maximum(priorities, 0.0)\n    return priorities",
    "response_id": 4,
    "obj": 4.108496210610296,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 116.69205856195879,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter26_response5.txt_stdout.txt",
    "code_path": "problem_iter26_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Fit: Inverse distance to remaining capacity\n    distances = np.abs(bins_remain_cap - item)\n    priorities = 1.0 / (distances + 1e-9)\n\n    # Reward spacious bins\n    priorities[bins_remain_cap > item * 1.5] += 0.2\n\n    # Reward near-full bins\n    priorities[bins_remain_cap < item * 0.5] += 0.3\n\n    # Ensure priorities are non-negative\n    priorities = np.maximum(priorities, 0.0)\n    return priorities",
    "response_id": 5,
    "obj": 1.6952532907858,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 116.69205856195879,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter26_response6.txt_stdout.txt",
    "code_path": "problem_iter26_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Feasible Fit: Inverse distance to remaining capacity\n    fit_bins = bins_remain_cap >= item\n    if np.any(fit_bins):\n        priorities[fit_bins] = 1.0 / (bins_remain_cap[fit_bins] - item + 1e-9)\n\n    # Spaciousness: Reward bins with ample remaining capacity\n    spacious_bins = bins_remain_cap > item * 1.5\n    priorities[spacious_bins] += 0.7\n\n    # Near-full: Prioritize filling bins almost completely\n    near_full_bins = np.abs(bins_remain_cap - item) < item * 0.3\n    priorities[near_full_bins] += 1.2\n\n    # Small bonus to all bins to encourage use, but less than spacious/near-full\n    priorities += 0.01\n\n    return priorities",
    "response_id": 6,
    "obj": 3.470283207020339,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 167.17882283189007,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter26_response7.txt_stdout.txt",
    "code_path": "problem_iter26_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Fit: Inverse distance to remaining capacity\n    distances = np.abs(bins_remain_cap - item)\n    priorities = 1.0 / (distances + 1e-9)\n\n    # Relative capacity bonuses (tuned)\n    priorities[bins_remain_cap >= item * 1.2] += 0.07  # Spacious bins\n    priorities[bins_remain_cap <= item * 0.8] += 0.03  # Near-full bins\n    priorities[bins_remain_cap > item * 0.5] += 0.01 # Slightly spacious\n\n    # Ensure non-negative priorities\n    priorities = np.maximum(priorities, 0.0)\n    return priorities",
    "response_id": 7,
    "obj": 4.0885520542481055,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 167.17882283189007,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter26_response8.txt_stdout.txt",
    "code_path": "problem_iter26_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Fit: Inverse distance to remaining capacity. Avoid division by zero.\n    fit_bins = bins_remain_cap >= item\n    if np.any(fit_bins):\n        distances = np.abs(bins_remain_cap[fit_bins] - item)\n        priorities[fit_bins] = 1.0 / (distances + 1e-9)\n\n    # Relative capacity bonuses (tuned weights)\n    priorities[bins_remain_cap >= item * 1.8] += 0.05  # More spacious\n    priorities[bins_remain_cap <= item * 0.4] += 0.1  # Near-full\n\n    # Small bonus to encourage use (reduced weight)\n    priorities += 0.001\n\n    return priorities",
    "response_id": 8,
    "obj": 5.035899481451935,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 149.27754454988144,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter26_response9.txt_stdout.txt",
    "code_path": "problem_iter26_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    # Inverse distance to remaining capacity (smooth weighting)\n    distances = np.abs(bins_remain_cap - item)\n    priorities = 1.0 / (distances + 1e-9)\n\n    # Bonus for spacious bins\n    priorities[bins_remain_cap > item * 1.5] += 0.05\n\n    # Bonus for near-full bins\n    priorities[bins_remain_cap < item * 0.75] += 0.05\n\n    return priorities",
    "response_id": 9,
    "obj": 4.168328679696844,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 114.6940428629768,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter27_response0.txt_stdout.txt",
    "code_path": "problem_iter27_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Feasibility check first\n    feasible_bins = bins_remain_cap >= item\n    priorities[feasible_bins] = 1.0 / (np.abs(bins_remain_cap[feasible_bins] - item) + 1e-9)\n\n    # Reward spaciousness and near-full bins\n    relative_capacity = bins_remain_cap / np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else bins_remain_cap\n    spacious_bonus = 0.1 * np.exp(-(relative_capacity - 0.8)**2 / 0.02)  # Peak at 80%\n    near_full_bonus = 0.1 * np.exp(-(relative_capacity - 0.2)**2 / 0.02)  # Peak at 20%\n    priorities[feasible_bins] += spacious_bonus[feasible_bins] + near_full_bonus[feasible_bins]\n\n    # Ensure priorities are non-negative\n    priorities = np.maximum(priorities, 0.0)\n    return priorities",
    "response_id": 0,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 20, in priority_v2\n    \nnumpy._core._exceptions._UFuncOutputCastingError: Cannot cast ufunc 'add' output from dtype('float64') to dtype('int64') with casting rule 'same_kind'\n10\n2\n268.8361000750002\n"
  },
  {
    "stdout_filepath": "problem_iter27_response1.txt_stdout.txt",
    "code_path": "problem_iter27_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Feasibility check: only consider bins where the item fits\n    feasible_bins = bins_remain_cap >= item\n    priorities[~feasible_bins] = -1  # Assign very low priority to infeasible bins\n\n    # Inverse distance weighting to remaining capacity for feasible bins only\n    distances = np.abs(bins_remain_cap[feasible_bins] - item)\n    priorities[feasible_bins] = 1.0 / (distances + 1e-9)\n\n    # Reward spaciousness and near-full utilization - small bonuses\n    priorities[bins_remain_cap > item * 1.5] += 0.1  # Spacious bins\n    priorities[bins_remain_cap < item * 0.5] += 0.05  # Near-full bins\n\n    # Ensure priorities are non-negative (or at least not significantly negative)\n    priorities = np.maximum(priorities, 0.0)\n\n    return priorities",
    "response_id": 1,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 22, in priority_v2\n    priorities[feasible_bins & (bins_remain_cap > item * 1.5)] += 0.1 \nnumpy._core._exceptions._UFuncOutputCastingError: Cannot cast ufunc 'add' output from dtype('float64') to dtype('int64') with casting rule 'same_kind'\n10\n1\n157.89111045234063\n"
  },
  {
    "stdout_filepath": "problem_iter27_response2.txt_stdout.txt",
    "code_path": "problem_iter27_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    # Feasibility check: only consider bins where the item fits\n    feasible_bins = bins_remain_cap >= item\n    priorities[~feasible_bins] = -1  # Assign a very low priority to infeasible bins\n\n    # Inverse distance weighting to remaining capacity for feasible bins\n    distances = np.abs(bins_remain_cap[feasible_bins] - item)\n    priorities[feasible_bins] = 1.0 / (distances + 1e-9)\n\n    # Reward spaciousness (relative to item size)\n    priorities[feasible_bins & (bins_remain_cap > item * 1.5)] += 0.1 \n\n    # Reward near-full bins (relative to item size)\n    priorities[feasible_bins & (bins_remain_cap < item * 0.5)] += 0.05\n\n    return priorities",
    "response_id": 2,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 22, in priority_v2\n    priorities = np.maximum(priorities, 0.0)\nnumpy._core._exceptions._UFuncOutputCastingError: Cannot cast ufunc 'add' output from dtype('float64') to dtype('int64') with casting rule 'same_kind'\n9\n1\n192.29419688230416\n"
  },
  {
    "stdout_filepath": "problem_iter27_response3.txt_stdout.txt",
    "code_path": "problem_iter27_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Feasibility check: only consider bins with enough capacity\n    feasible_bins = bins_remain_cap >= item\n    priorities[feasible_bins] = 1.0 / (np.abs(bins_remain_cap[feasible_bins] - item) + 1e-9)\n\n    # Reward spaciousness and near-full bins\n    relative_capacity = bins_remain_cap / (bins_remain_cap.max() + 1e-9) # Avoid div by zero if all bins are empty\n    priorities[relative_capacity > 0.6] += 0.1 * relative_capacity[relative_capacity > 0.6]\n    priorities[relative_capacity < 0.4] += 0.05 * relative_capacity[relative_capacity < 0.4]\n\n    # Ensure priorities are non-negative\n    priorities = np.maximum(priorities, 0.0)\n    return priorities",
    "response_id": 3,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 18, in priority_v2\n    distances = np.abs(bins_remain_cap[feasible_bins] - item)\nnumpy._core._exceptions._UFuncOutputCastingError: Cannot cast ufunc 'add' output from dtype('float64') to dtype('int64') with casting rule 'same_kind'\n9\n1\n199.7052750908657\n"
  },
  {
    "stdout_filepath": "problem_iter27_response4.txt_stdout.txt",
    "code_path": "problem_iter27_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    # Feasibility check: only consider bins that can fit the item\n    feasible_bins = bins_remain_cap >= item\n    priorities[~feasible_bins] = -1  # Assign a very low priority to infeasible bins\n\n    # Inverse distance weighting to remaining capacity for feasible bins\n    distances = np.abs(bins_remain_cap[feasible_bins] - item)\n    priorities[feasible_bins] = 1.0 / (distances + 1e-9)\n\n    # Reward spaciousness (relative to item size)\n    priorities[feasible_bins & (bins_remain_cap > item * 1.5)] += 0.1\n\n    # Reward near-full bins (relative to item size)\n    priorities[feasible_bins & (bins_remain_cap < item * 0.5)] += 0.15\n    \n    return priorities",
    "response_id": 4,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 22, in priority_v2\n    # Ensure priorities are non-negative\nnumpy._core._exceptions._UFuncOutputCastingError: Cannot cast ufunc 'add' output from dtype('float64') to dtype('int64') with casting rule 'same_kind'\n9\n1\n192.29419688230416\n"
  }
]