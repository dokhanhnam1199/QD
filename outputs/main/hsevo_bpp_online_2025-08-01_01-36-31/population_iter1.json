[
  {
    "stdout_filepath": "problem_iter1_response0.txt_stdout.txt",
    "code_path": "problem_iter1_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    This implementation uses a 'Best Fit' heuristic principle: it prioritizes\n    bins that can accommodate the item and leave the smallest amount of\n    remaining space. Bins that cannot fit the item are given a very low priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Higher scores indicate higher priority.\n    \"\"\"\n    # Initialize priorities for all bins to a very low value.\n    # This effectively disqualifies bins that cannot fit the item.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Create a boolean mask for bins where the item can actually fit.\n    can_fit_mask = bins_remain_cap >= item\n\n    # Calculate the remaining space if the item were placed in each bin.\n    # This calculation is done for all bins, but only relevant for those\n    # where the item fits.\n    remaining_space_after_placement = bins_remain_cap - item\n\n    # For bins where the item fits, assign a priority score.\n    # We want to minimize the `remaining_space_after_placement`.\n    # To convert this into a maximization problem for priority, we use\n    # the negative of the remaining space. A smaller positive remaining\n    # space will result in a larger (less negative) priority score.\n    # For example:\n    # - If remaining_space = 0, priority = 0 (perfect fit, highest priority).\n    # - If remaining_space = 5, priority = -5.\n    # - If remaining_space = 10, priority = -10.\n    priorities[can_fit_mask] = -remaining_space_after_placement[can_fit_mask]\n\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response1.txt_stdout.txt",
    "code_path": "problem_iter1_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Inspired by the principle of least action and the desire for energetic\n    efficiency in the universe's fabric (our bins), this heuristic\n    prioritizes containers (bins) that minimize the 'residual space-time'\n    (unused capacity) after an item (quantum of matter) is placed within them.\n\n    This strategy, akin to matter seeking its most stable and compact state,\n    aims to achieve the 'tightest fit'. It maximizes the utilization of\n    existing 'dimensions' (bin capacities), thereby limiting the necessity\n    to expand into new 'dimensions' (open new bins) and minimizing the overall\n    'cosmic energy' (total number of bins) required.\n\n    Bins where the item cannot physically fit are treated as 'forbidden regions',\n    assigned an infinitely low priority, signifying their complete\n    incompatibility with the incoming 'particle'.\n\n    Args:\n        item: Size of item to be added to the bin. This is our 'particle'.\n        bins_remain_cap: Array of capacities for each bin. These are our\n                         'local space-time curvatures'.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Higher scores indicate a more 'energetically favorable' placement.\n    \"\"\"\n\n    # Calculate the hypothetical remaining space in each bin if the item were placed.\n    # This is the 'residual energy field' that would be left behind.\n    potential_remaining_space = bins_remain_cap - item\n\n    # Initialize all priorities to a state of 'impossibility' or 'infinite resistance'.\n    # A bin that cannot accommodate the item should have an infinitely low priority.\n    priority_scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify the 'viable universes' (bins) where the item can physically fit.\n    # Only these are considered for a potential 'gravitational collapse' (placement).\n    can_fit_mask = potential_remaining_space >= 0\n\n    # For viable bins, the priority is derived from the negative of the remaining space.\n    # By maximizing this (less negative) value, we inherently select the bin that\n    # leaves the *smallest* positive remaining space. This represents the 'tightest'\n    # and most 'energetically efficient' fit, minimizing wasted space.\n    priority_scores[can_fit_mask] = -potential_remaining_space[can_fit_mask]\n\n    return priority_scores",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response2.txt_stdout.txt",
    "code_path": "problem_iter1_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    As Isaac Newton, I postulate that efficiency dictates we seek to fill our vessels\n    most completely, leaving the least possible void. This 'Best Fit' strategy ensures\n    that an item finds the container where it fits most snugly, thus conserving the\n    valuable resource of space and minimizing the proliferation of new, partially\n    filled containers. Bins unable to contain the item are, naturally, given no\n    consideration.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the space that would remain if the item were placed in each bin.\n    # This represents the 'excess capacity' or 'void' created.\n    potential_remaining_space = bins_remain_cap - item\n\n    # Initialize all bins with an exceedingly low priority, akin to a void of opportunity.\n    # Bins that cannot physically accommodate the item must receive this minimal score.\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    # Now, let us consider only those bins where the item may truly reside.\n    # A bin is suitable if its remaining capacity is greater than or equal to the item's size.\n    can_fit_mask = potential_remaining_space >= 0\n\n    # For these suitable bins, the principle of 'Best Fit' shall govern.\n    # We wish to minimize the 'potential_remaining_space' to achieve the most compact arrangement.\n    # By negating this value, a smaller positive remaining space yields a larger (less negative, or closer to zero)\n    # priority score, thereby selecting the 'snugger' fit. This is akin to a body seeking its lowest energy state.\n    priorities[can_fit_mask] = -potential_remaining_space[can_fit_mask]\n\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response3.txt_stdout.txt",
    "code_path": "problem_iter1_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add an item to each bin,\n    implementing a 'Best Fit' heuristic. This heuristic prioritizes bins\n    that will have the smallest remaining capacity after accommodating the item,\n    thereby maximizing bin utilization and minimizing wasted space. Bins that\n    cannot fit the item receive a very low priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score for each bin.\n        Higher scores indicate a more desirable bin for the current item.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Assign a very low (negative infinity) priority to bins that cannot\n    # accommodate the item, ensuring they are never chosen if a valid option exists.\n    IMPOSSIBLE_FIT_PRIORITY = -np.inf\n\n    for i, capacity in enumerate(bins_remain_cap):\n        if item <= capacity:\n            # For a 'Best Fit' strategy, we want to select the bin that results\n            # in the smallest remaining capacity after the item is placed.\n            # The remaining capacity would be (capacity - item).\n            # To maximize priority for smaller remainders, we take the negative\n            # of this difference. A perfect fit (capacity - item == 0) gets\n            # the highest priority of 0.0. Snug fits get scores close to 0.0.\n            priorities[i] = -(capacity - item)\n        else:\n            priorities[i] = IMPOSSIBLE_FIT_PRIORITY\n            \n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response4.txt_stdout.txt",
    "code_path": "problem_iter1_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add an item to each bin.\n    As a master of efficient packing and minimizing loss, I design this function\n    to favor bins that allow for the most 'snug' fit, thereby reducing\n    the empty space left over. This is akin to finding the perfect resonant\n    frequency for the item within a given receptacle.\n\n    Specifically, it implements a 'Best Fit' heuristic:\n    - Bins that cannot accommodate the item are given a virtually infinite negative priority (rejected outright).\n    - Among bins that can accommodate the item, priority is inversely proportional\n      to the remaining capacity after placing the item. An exact fit (zero remainder)\n      receives the highest possible score, ensuring it is chosen first.\n      Smaller positive remainders yield higher priority (less negative score),\n      while larger remainders yield lower priority (more negative score).\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of current remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Higher scores indicate a more desirable bin for the item.\n    \"\"\"\n    # Calculate the potential remaining capacity if the item were placed in each bin.\n    # A smaller positive remainder is better for a snug fit.\n    potential_remainder_after_placement = bins_remain_cap - item\n\n    # Initialize priorities. Bins that cannot fit the item must have an\n    # extraordinarily low priority, like an incompatible frequency that causes rejection.\n    # Use -np.inf so they are never chosen if a valid option exists.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify which bins can physically accommodate the item.\n    can_fit_mask = potential_remainder_after_placement >= 0\n\n    # For bins that can fit the item, assign a priority based on the snugness.\n    # We want to maximize the priority. Since 'snug' means minimizing the remainder,\n    # we take the negative of the remainder. This transforms 'minimizing positive'\n    # into 'maximizing negative (closest to zero)'.\n    # For example:\n    #   - Exact fit (remainder 0) gets a priority of 0. (Highest)\n    #   - Remainder 1 gets a priority of -1.\n    #   - Remainder 5 gets a priority of -5. (Lower)\n    priorities[can_fit_mask] = -potential_remainder_after_placement[can_fit_mask]\n\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response5.txt_stdout.txt",
    "code_path": "problem_iter1_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    As a seeker of the most harmonious and efficient configurations, much like the\n    celestial dance, this function implements the 'Best Fit' heuristic. It calculates\n    the remaining capacity after placing the item in each bin and prioritizes the\n    bin that would leave the least amount of space unused. A 'perfect fit' receives\n    the highest possible score amongst valid options.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Bins where the item does not fit receive a very low (negative infinity) priority.\n    \"\"\"\n    # Calculate the space that would remain in each bin if the item were placed there.\n    # A smaller positive value indicates a tighter, more \"best\" fit.\n    potential_remaining_space = bins_remain_cap - item\n\n    # Initialize all priorities to a very low value. This is our default for bins\n    # where the item cannot possibly fit, ensuring they are never chosen.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify which bins can actually accommodate the item.\n    # Only bins with a non-negative potential_remaining_space are candidates.\n    fitting_bins_mask = potential_remaining_space >= 0\n\n    # For the bins that can fit the item, assign a priority.\n    # To implement 'Best Fit', we want to select the bin that *minimizes*\n    # the remaining space. By assigning a score of -remaining_space,\n    # minimizing remaining_space becomes equivalent to maximizing -remaining_space.\n    # A perfect fit (0 remaining space) will thus have a score of 0,\n    # which is the highest possible priority for a fitting bin.\n    priorities[fitting_bins_mask] = -potential_remaining_space[fitting_bins_mask]\n\n    return priorities",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response6.txt_stdout.txt",
    "code_path": "problem_iter1_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This heuristic, born from the gravitational collapse principle, seeks to\n    maximize the 'density' of occupied space within each bin. It embodies\n    the 'Best Fit' strategy: items are drawn into bins that minimize the\n    remaining void, much like matter is drawn into the most efficient\n    gravitational wells.\n\n    The score reflects the negative of the remaining capacity after placing the item.\n    A perfect fit (zero remaining void) yields the highest finite score (0.0).\n    A tight fit (small positive void) yields a score close to zero.\n    A loose fit (large positive void) yields a more negative score.\n    Bins unable to accommodate the item are assigned an infinitely low priority,\n    akin to being beyond the event horizon \u2013 an item simply cannot exist there.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Calculate the 'void' that would remain in each bin after placing the item.\n    # This is analogous to the unoccupied space within a gravitational body.\n    potential_void = bins_remain_cap - item\n\n    # Initialize all priorities to negative infinity. This ensures that any bin\n    # that cannot physically contain the item is effectively removed from\n    # consideration, its 'event horizon' impassable.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify which bins are large enough to accept the item. These are the\n    # 'gravitational fields' capable of attracting our 'mass'.\n    can_fit_mask = bins_remain_cap >= item\n\n    # For the bins that can fit the item, we assign a priority score.\n    # The Best Fit strategy implies we want to minimize the 'potential_void'.\n    # By taking the negative of the void, a smaller positive void results\n    # in a larger (less negative, or closer to zero) priority score.\n    # A perfect fit (void=0) achieves the maximum finite score of 0.0.\n    priorities[can_fit_mask] = -potential_void[can_fit_mask]\n\n    return priorities",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response7.txt_stdout.txt",
    "code_path": "problem_iter1_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin,\n    using a Best-Fit-like strategy with amplified preference for tighter fits.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # First, calculate the \"energy cost\" of putting the item into each bin:\n    # the remaining capacity after the item is placed.\n    # We want to minimize this remaining 'empty space' or 'quantum void'.\n    potential_new_remain_cap = bins_remain_cap - item\n\n    # Initialize the priority scores. These will represent how 'desirable'\n    # a bin is for the incoming item.\n    priority_scores = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # A small 'quantum of tolerance' to avoid division by zero and\n    # give a very high but finite score to perfect fits.\n    # Think of it as the minimum 'fuzziness' in our measurement of zero.\n    epsilon = 1e-9\n\n    # Identify the bins that can actually *contain* the item.\n    # Bins where the item would cause the remaining capacity to drop below zero\n    # are physically impossible candidates in this classical realm.\n    can_fit = potential_new_remain_cap >= 0\n\n    # For the bins that *can* fit the item, we want to reward those that\n    # result in the least amount of wasted space. A very small remaining\n    # capacity (approaching zero) indicates a near-perfect 'quantization'\n    # of the bin's volume by the item.\n    # By taking the reciprocal (1 / remaining_space), we ensure that:\n    # 1. A perfectly filled bin (remaining_space \u2248 0) gets an extremely high score.\n    # 2. Bins with very little remaining space get high scores.\n    # 3. Scores drop off sharply as remaining space increases, strongly preferring\n    #    tighter fits. This isn't just about 'less space', but 'significantly less space'.\n    priority_scores[can_fit] = 1.0 / (potential_new_remain_cap[can_fit] + epsilon)\n\n    # For bins that cannot fit the item, they are \"forbidden states\".\n    # Assign them an infinitely low priority so they are never chosen,\n    # forcing the system to consider opening a new bin if no existing bin fits.\n    priority_scores[~can_fit] = -np.inf\n\n    return priority_scores",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response8.txt_stdout.txt",
    "code_path": "problem_iter1_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This heuristic is a \"Density-Weighted Best Fit\" approach.\n    It combines two key aspects inspired by the methodical pursuit of structure:\n    1.  **Best Fit Component**: Prioritizes bins that leave the smallest amount\n        of remaining space after the item is placed. This promotes dense packing\n        within individual bins. (Mimics Franklin's pursuit of precise fitting).\n    2.  **Current Occupancy Component**: Gives a bonus to bins that are already\n        more full. This encourages filling up existing bins completely before\n        opening new ones or leaving bins with only small, unusable capacities.\n        (Mimics Franklin's focus on consolidating observations to form a complete picture).\n\n    The score for a suitable bin is calculated as:\n    `-(remaining_space_after_fit) + alpha * (current_occupancy)`\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Bins that cannot fit the item will have a very low (negative infinity) score.\n    \"\"\"\n    # Assuming a universal standard capacity for all bins.\n    # In many Bin Packing Problem contexts, bin capacity is normalized to 1.0.\n    # If the problem implies a different fixed capacity (e.g., 100), this constant\n    # should be adjusted accordingly. This allows `current_occupancy` to be a\n    # meaningful measure of how 'full' a bin is relative to its total capacity.\n    total_bin_capacity = 1.0 \n\n    # Alpha is a tunable parameter that controls the weighting between\n    # the 'Best Fit' component and the 'Current Occupancy' component.\n    # - If alpha = 0, the heuristic reduces to a pure Best Fit.\n    # - A higher alpha (e.g., 0.5 to 1.0) gives more importance to\n    #   filling up existing, more occupied bins, even if it doesn't\n    #   produce the absolute 'tightest' fit.\n    alpha = 0.5  # Example value, can be optimized based on problem characteristics.\n\n    # 1. Determine which bins can actually fit the item.\n    can_fit = bins_remain_cap >= item\n\n    # 2. Calculate the remaining space if the item were placed in each bin.\n    #    (This is the 'waste' we want to minimize for Best Fit).\n    remaining_space_after_fit = bins_remain_cap - item\n\n    # 3. Calculate the current occupancy (how much space is already filled).\n    #    This measures how 'full' a bin is before placing the current item.\n    current_occupancy = total_bin_capacity - bins_remain_cap\n\n    # Initialize priority scores. Bins that cannot fit the item get an\n    # infinitely low score to ensure they are never chosen.\n    priority_scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Calculate scores only for bins that can fit the item.\n    # The Best Fit component (-remaining_space_after_fit) is maximized when\n    # remaining_space_after_fit is minimized (i.e., closest to 0).\n    # The Current Occupancy component (alpha * current_occupancy) is maximized\n    # when the bin is already more full.\n    priority_scores[can_fit] = -remaining_space_after_fit[can_fit] + alpha * current_occupancy[can_fit]\n\n    return priority_scores",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response9.txt_stdout.txt",
    "code_path": "problem_iter1_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin,\n    employing a 'Best Fit' heuristic.\n\n    This function prioritizes bins that, after placing the item, would have the\n    smallest remaining capacity. This strategy aims to fill bins as tightly\n    as possible, thereby preserving larger spaces in other bins for future\n    potentially larger items, and ultimately seeking to minimize the total\n    number of bins used.\n\n    Priority Mechanism:\n    - For bins where the item *can* fit: The priority score is calculated as the\n      negative of the remaining capacity after the item is placed. A smaller\n      remaining capacity (e.g., 0 for an exact fit) results in a higher\n      (closer to zero or positive) priority score.\n    - For bins where the item *cannot* fit: Their priority is set to 0. This\n      effectively disqualifies them, as any valid fit (resulting in a non-negative\n      remaining capacity, and thus a non-positive priority score) will always have\n      a priority greater than or equal to their priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with the priority score of each bin.\n        The bin with the highest score (closest to 0 or positive) will be selected.\n    \"\"\"\n    # Initialize all priorities to 0. Bins that cannot fit the item will retain this score.\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Create a boolean mask for bins where the item can fit\n    can_fit_mask = bins_remain_cap >= item\n\n    # Calculate the remaining capacity if the item were placed in the fitting bins\n    remaining_after_fit = bins_remain_cap[can_fit_mask] - item\n\n    # Apply the Best Fit logic: smaller remaining capacity implies higher priority.\n    # By taking the negative, an exact fit (remaining_after_fit = 0) gets a priority of 0,\n    # which is the highest possible. A tight fit (small positive remaining_after_fit)\n    # gets a priority close to 0 but negative. A loose fit gets a more negative priority.\n    priorities[can_fit_mask] = -remaining_after_fit\n\n    return priorities",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  }
]