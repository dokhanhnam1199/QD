{"system": "You are an expert in code review. Your task extract all threshold, weight or hardcode variable of the function make it become default parameters.", "user": "[code]\nimport numpy as np\n\ndef priority_v2(item: float,\n                bins_remain_cap: np.ndarray,\n                waste_penalty_factor: float = 0.9,\n                bin_fraction_penalty: float = 0.5,\n                item_size_weight: float = 2.1,\n                random_perturbation_scale: float = 0.07,\n                capacity_threshold: float = 0.1) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Employs a combination of heuristics:\n        1. Waste Minimization: Prioritizes bins where the remaining space after\n           packing the item is minimal.  A near-perfect fit is highly valued.\n        2. Capacity Threshold: Avoids bins with extremely small remaining\n           capacity to reduce fragmentation. Bins that cannot fit are penalized.\n           Bins with capacity below the threshold are also penalized to avoid fragmentation.\n        3. Bin Level Awareness : Considers the initial capacity of the bins for a more balanced distribution\n        4. Balancing Bin Utilization:  Slight preference for bins that are not\n           completely empty or completely full to maintain flexibility.\n        5. Random Perturbation: Introduces small randomness to avoid getting stuck\n           in local optima and explore slightly different packing arrangements.\n        6. Item size awareness : Larger Items should fill bins as much as possible\n        7. Threshold for waste. If waste is too high, then penalize it.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        waste_penalty_factor: Factor to adjust the impact of waste minimization.\n        bin_fraction_penalty: Factor to adjust the balancing of bin utilization.\n        item_size_weight: Weight of item size awareness.\n        random_perturbation_scale: Scale of random noise.\n        capacity_threshold: threshold to penalize bins with small capacity\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    original_capacity = np.max(bins_remain_cap)\n\n    # Waste Minimization & Capacity Threshold\n    waste = bins_remain_cap - item\n    too_small = waste < 0\n    priorities[too_small] = -np.inf  # Never put item in bins that are too small.\n    waste[too_small] = np.inf\n    \n    # Penalize bins that are below a certain threshold.\n    below_threshold = bins_remain_cap < capacity_threshold * original_capacity\n    priorities[below_threshold] -= 0.1  #Slight penalty\n\n    # Near-perfect fit bonus (minimize waste)\n    priorities += waste_penalty_factor * np.exp(-waste)  # Exponential decay for increasing waste.\n\n    # Bin utilization balancing - slightly prefers bins that aren't empty or full.  avoids extremities.  Parabolic preference\n    bin_fraction = bins_remain_cap / original_capacity\n    priorities += bin_fraction_penalty * -(bin_fraction - 0.5)**2  # Adds a parabolic preference curve.\n    \n    # Item Size Awareness.  Larger items fill bins up\n    priorities += item_size_weight * item/original_capacity\n    \n    # Waste threshold: Penalize bins that have too much waste after placing the item\n    waste_threshold = 0.8 * original_capacity  # Example: if waste is > 80% of capacity\n    too_much_waste = waste > waste_threshold\n    priorities[too_much_waste] -= 0.2  # Moderate penalty for excessive waste.\n    \n\n    # Random Perturbation (introduces some \"quantum\" fluctuation). Very small value for numerical stability\n    priorities += np.random.normal(0, random_perturbation_scale, size=bins_remain_cap.shape)\n\n    return priorities\n\nNow extract all threshold, weight or hardcode variable of the function make it become default parameters and give me a 'parameter_ranges' dictionary representation. Key of dict is name of variable. Value of key is a tuple in Python MUST include 2 float elements, first element is begin value, second element is end value corresponding with parameter.\n\n- Output code only and enclose your code with Python code block: ```python ... ```.\n- Output 'parameter_ranges' dictionary only and enclose your code with other Python code block: ```python ... ```."}