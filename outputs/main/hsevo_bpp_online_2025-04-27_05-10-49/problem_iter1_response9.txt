```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.
    Aims to balance bin usage and avoid fragmentation.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    # 1. Feasibility: Only consider bins where the item fits.
    feasible_bins = bins_remain_cap >= item

    if not np.any(feasible_bins):
        return priorities # All zeros, no feasible bin

    # 2. Remaining Capacity: Favor bins with more remaining capacity *relative to the item size*.
    #    This encourages filling bins that already have some space.  We use a scaled measure.
    relative_capacity = (bins_remain_cap - item) / np.max(bins_remain_cap)  # Scales between 0 and 1

    # 3. Avoid Overfilling: Penalize bins where the remaining capacity is just barely enough.
    #  This encourages finding bins with a *little* more space than necessary.
    #  We will penalize with values between 0 and 1, based on the buffer remaining.
    buffer = bins_remain_cap - item
    small_buffer_penalty = np.clip(1 - (buffer / item), a_min=0, a_max=1)  # 1 if buffer == 0, 0 if buffer >= item

    # Combine the factors:
    priorities[feasible_bins] = (relative_capacity[feasible_bins] * (1-small_buffer_penalty[feasible_bins]) ) #Scale Capacity by not choosing too little.

    return priorities
```
