import numpy as np

def priority_v2(item: float,
                bins_remain_cap: np.ndarray,
                waste_penalty_factor: float = 0.9830211305415382,
                bin_fraction_penalty: float = 0.05627241754135648,
                item_size_weight: float = 3.0351967328975498,
                random_perturbation_scale: float = 0.060355887121331754,
                capacity_threshold: float = 0.28264987815779136,
                below_threshold_penalty: float = 0.394800593132021,
                waste_threshold_fraction: float = 0.6803574095443536,
                excessive_waste_penalty: float = 0.4915006532686427) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.
    Employs a combination of heuristics:
        1. Waste Minimization: Prioritizes bins where the remaining space after
           packing the item is minimal.  A near-perfect fit is highly valued.
        2. Capacity Threshold: Avoids bins with extremely small remaining
           capacity to reduce fragmentation. Bins that cannot fit are penalized.
           Bins with capacity below the threshold are also penalized to avoid fragmentation.
        3. Bin Level Awareness : Considers the initial capacity of the bins for a more balanced distribution
        4. Balancing Bin Utilization:  Slight preference for bins that are not
           completely empty or completely full to maintain flexibility.
        5. Random Perturbation: Introduces small randomness to avoid getting stuck
           in local optima and explore slightly different packing arrangements.
        6. Item size awareness : Larger Items should fill bins as much as possible
        7. Threshold for waste. If waste is too high, then penalize it.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.
        waste_penalty_factor: Factor to adjust the impact of waste minimization.
        bin_fraction_penalty: Factor to adjust the balancing of bin utilization.
        item_size_weight: Weight of item size awareness.
        random_perturbation_scale: Scale of random noise.
        capacity_threshold: threshold to penalize bins with small capacity
    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    original_capacity = np.max(bins_remain_cap)

    # Waste Minimization & Capacity Threshold
    waste = bins_remain_cap - item
    too_small = waste < 0
    priorities[too_small] = -np.inf  # Never put item in bins that are too small.
    waste[too_small] = np.inf
    
    # Penalize bins that are below a certain threshold.
    below_threshold = bins_remain_cap < capacity_threshold * original_capacity
    priorities[below_threshold] -= below_threshold_penalty  #Slight penalty

    # Near-perfect fit bonus (minimize waste)
    priorities += waste_penalty_factor * np.exp(-waste)  # Exponential decay for increasing waste.

    # Bin utilization balancing - slightly prefers bins that aren't empty or full.  avoids extremities.  Parabolic preference
    bin_fraction = bins_remain_cap / original_capacity
    priorities += bin_fraction_penalty * -(bin_fraction - 0.5)**2  # Adds a parabolic preference curve.
    
    # Item Size Awareness.  Larger items fill bins up
    priorities += item_size_weight * item/original_capacity
    
    # Waste threshold: Penalize bins that have too much waste after placing the item
    waste_threshold = waste_threshold_fraction * original_capacity  # Example: if waste is > 80% of capacity
    too_much_waste = waste > waste_threshold
    priorities[too_much_waste] -= excessive_waste_penalty  # Moderate penalty for excessive waste.
    

    # Random Perturbation (introduces some "quantum" fluctuation). Very small value for numerical stability
    priorities += np.random.normal(0, random_perturbation_scale, size=bins_remain_cap.shape)

    return priorities
