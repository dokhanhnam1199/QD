```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.
    Employs a combination of factors: space utilization, waste minimization,
    and a touch of "quantum" fluctuation to encourage exploration.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    epsilon = 1e-9  # Small value to avoid division by zero and log of zero
    available_space = bins_remain_cap + epsilon #avoid div by zero

    # 1. Space Utilization: How much of the bin will be filled?
    utilization = item / available_space

    # 2. Waste Minimization: How much space will be wasted if we use this bin?
    waste = available_space - item
    normalized_waste = waste / available_space # normalized

    # 3. Encourage near-perfect fits
    near_perfect_fit = np.exp(-np.abs(waste)) # close to zero waste -> close to one

    # 4. Small Bins : small bins prioritized but not if near perfect waste
    small_bins_priority = 1.0 / (available_space + epsilon)


    #5. Quantum-inspired randomness: Explore different possibilities (temperature can be tuned)
    temperature = 0.1  # Tunes the level of "quantum fluctuation"
    random_fluctuation = np.random.normal(0, temperature, size=bins_remain_cap.shape) # add noise

    # Combine the factors, with tunable weights. This is where the magic happens!
    # Fine-tune these weights to get the best performance.
    priority = (
        1.0 * utilization
        -0.5 * normalized_waste
        + 1.0 * near_perfect_fit
        + 0.5 * small_bins_priority
        + 0.1 * random_fluctuation # added fluctuations

    )

    return priority
```
