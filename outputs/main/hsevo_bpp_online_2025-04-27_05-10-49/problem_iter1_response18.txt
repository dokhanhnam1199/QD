```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version prioritizes bins that can fit the item snugly,
    but also considers the overall remaining capacity of the bins.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    # Give a negative infinite priority to bins that cannot fit the item
    priorities[bins_remain_cap < item] = -np.inf
    
    # Calculate the wasted space if the item is placed in each bin
    wasted_space = bins_remain_cap - item
    
    # Calculate the ratio of item size to remaining capacity (snugness)
    snugness = item / bins_remain_cap

    # Give a higher priority to bins with smaller wasted space and higher snugness
    # Use a combination of factors to balance the two considerations. Experimentally determined.
    valid_bins = bins_remain_cap >= item
    priorities[valid_bins] = 2 * np.exp(-wasted_space[valid_bins]) + snugness[valid_bins]

    # Normalize the priorities so that the function always return meaningful results, and to prevent overflow
    priorities = (priorities - np.min(priorities)) / (np.max(priorities) - np.min(priorities) + 1e-9)

    return priorities
```
