```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Combines waste minimization, target utilization, and adaptive scaling."""
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    wasted_space = bins_remain_cap - item
    fit_mask = wasted_space >= 0

    if np.any(fit_mask):
        # Adaptive scaling based on item size and remaining capacity distribution.
        item_fraction = item / np.max(bins_remain_cap)
        scaling_factor = 1.0 + 2.0 * item_fraction # Increase scaling if item is a significant fraction of bin size
        priorities[fit_mask] = np.exp(-scaling_factor * wasted_space[fit_mask]**2 / (bins_remain_cap[fit_mask].mean() + 1e-9))

        desirable_remaining_space = 0.2 * np.max(bins_remain_cap)
        priority_values = np.exp(-((wasted_space[fit_mask] ) ** 2) / (2 * (desirable_remaining_space/2)** 2)) # Target utilization
        priorities[fit_mask] = 0.6*priorities[fit_mask]+ 0.4*priority_values #Combine with weight
        
        # Introduce a small bias to prefer bins with larger remaining capacity if waste is similar. Mitigates fragmentation.
        capacity_bias = 0.1 * bins_remain_cap[fit_mask] / np.max(bins_remain_cap)
        priorities[fit_mask] += capacity_bias

        # Small random perturbation for exploration
        priorities[fit_mask] += np.random.normal(0, 0.01, size=np.sum(fit_mask))

    priorities[~fit_mask] = -1e9 # Penalize infeasible bins severely
    return priorities
```
