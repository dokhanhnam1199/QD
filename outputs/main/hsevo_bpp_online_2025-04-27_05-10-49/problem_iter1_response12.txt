```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This function refines the priority calculation by considering both the
    remaining capacity and the potential waste if the item is placed in that bin.
    Bins that have a remaining capacity slightly larger than the item size
    are given higher priority to minimize fragmentation.  A term is added to strongly penalize bins where item doesn't fit.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Calculate wasted space if item is placed in the bin
    wasted_space = bins_remain_cap - item

    # Give higher priority to bins where item fits and waste is minimized
    # Use a Gaussian-like function to prioritize bins with minimal waste
    # with a peak at zero waste, and clip the negative values.
    fit_mask = wasted_space >= 0
    if np.any(fit_mask):  # only apply if the item fits any of the bins

        # This scaling factor can be tuned; larger values make it sharper
        # and less tolerable of larger bins.
        scaling_factor = 2.0
        priorities[fit_mask] = np.exp(-scaling_factor * wasted_space[fit_mask]**2 / bins_remain_cap[fit_mask].mean())
    
    #Severely penalize bins where the item doesn't fit by setting to a very low number.
    priorities[~fit_mask] = -1e9 # effectively sets to a very low priority so it is negligibly considered.

    return priorities
```
