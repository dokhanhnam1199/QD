```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Combines waste minimization, capacity threshold, item size & adaptive snugness."""

    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    original_capacity = np.max(bins_remain_cap)
    feasible_bins = bins_remain_cap >= item

    if not np.any(feasible_bins):
        return priorities

    waste = bins_remain_cap - item
    waste[waste < 0] = np.inf
    
    # Waste Minimization with exponential decay
    priorities += np.exp(-waste)

    # Snugness with item size awareness and adaptive scaling
    snugness = item / bins_remain_cap
    priorities += snugness * (item / original_capacity)  # scale snugness by item size

    # Bin utilization balancing - slightly prefers bins that aren't empty or full.
    bin_fraction = bins_remain_cap / original_capacity
    priorities += -(bin_fraction - 0.5)**2

    # Adaptive small buffer penalty.  Scale penalty by item size.
    buffer = bins_remain_cap - item
    small_buffer_penalty = np.clip(1 - (buffer / (item + 1e-9)), a_min=0, a_max=1) #Avoid division by zero
    priorities *= (1 - 0.5 * small_buffer_penalty)  # Reduce priority if buffer is small, adaptive scaling

    # Random Perturbation
    priorities += np.random.normal(0, 0.01, size=bins_remain_cap.shape)

    return priorities
```
