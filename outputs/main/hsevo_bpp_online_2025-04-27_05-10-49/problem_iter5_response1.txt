```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Combines waste minimization, target utilization, and item snugness with adaptive scaling."""
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    wasted_space = bins_remain_cap - item
    fit_mask = wasted_space >= 0

    if np.any(fit_mask):
        # Waste Minimization with adaptive scaling
        scaling_factor = 1.5  # Adjust for different item size distributions
        priorities[fit_mask] = np.exp(-scaling_factor * wasted_space[fit_mask]**2 / bins_remain_cap[fit_mask].mean())

        # Target Utilization (balance remaining space)
        desirable_remaining_space = 0.2 * np.max(bins_remain_cap)  # Can be tuned adaptively
        utilization_priority = np.exp(-((wasted_space[fit_mask] - desirable_remaining_space) ** 2) / (2 * (desirable_remaining_space/2)** 2))
        priorities[fit_mask] = 0.6*priorities[fit_mask]+ 0.4*utilization_priority # Adjust weights dynamically if needed

        # Snugness (item size relative to bin capacity), only if there is available space.
        snugness = item / bins_remain_cap[fit_mask]
        priorities[fit_mask] = 0.7*priorities[fit_mask] + 0.3*snugness

    priorities[~fit_mask] = -1e9 # Penalize infeasible bins

    return priorities
```
