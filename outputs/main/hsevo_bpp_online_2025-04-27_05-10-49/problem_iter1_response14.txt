```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Prioritizes bins with remaining capacity close to the item size, but also considers overall fullness
    to avoid creating many almost-empty bins.  Introduces a penalty for bins that would become too empty.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    bin_size = 1.0  # Assume bin size is 1.0; adjust if needed. Important to handle bins of different size
    priority = np.zeros_like(bins_remain_cap)

    # Give a high priority to bins that can fit the item
    can_fit = bins_remain_cap >= item
    priority[can_fit] = 1.0

    # Adjust priorities based on how well the item fits and the resulting fullness of the bin.
    # Use a function to tune this part carefully for best performance
    fit_score = (bins_remain_cap[can_fit] - item)
    # Closer to item size gets a larger reward
    fit_score_normalized = np.exp(-5 * (fit_score) ** 2)  # Larger penalty if not tightly packed
    # Penalize a small margin
    fit_score_normalized[bins_remain_cap[can_fit] - item < 0.001] = 0

    priority[can_fit] = fit_score_normalized

    # Penalize leaving bins very empty
    resulting_capacity = bins_remain_cap - item
    too_empty = resulting_capacity < 0.1*bin_size #if less than 10% of bin space left. You can use hyperparameter to tune
    priority[can_fit & too_empty] = -1.0 #big penalty if waste bin significantly. Can remove line to disable penalty
    priority[~can_fit] = -np.inf # do not use the ones that cant fit


    return priority
```
