```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Combines waste minimization, utilization balancing, item size, and adaptive randomness."""

    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    avg_cap = np.mean(bins_remain_cap)

    # Waste Minimization with Sigmoid
    waste = bins_remain_cap - item
    too_small = waste < 0
    priorities[too_small] = -np.inf
    waste[too_small] = np.inf
    sigmoid_scale = 5
    priorities += 1 / (1 + np.exp(sigmoid_scale * waste))

    # Bin Utilization Balancing with Adaptive Center
    bin_fraction = bins_remain_cap / np.max(bins_remain_cap)
    utilization_center = 0.5 + 0.2 * np.clip(item / avg_cap, 0, 1)
    priorities += -((bin_fraction - utilization_center) ** 2)

    # Item Size Consideration
    priorities += item / avg_cap

    # Adaptive Random Perturbation
    noise_scale = 0.01 + 0.05 * np.clip(item / avg_cap, 0, 1)
    priorities += np.random.normal(0, noise_scale, size=bins_remain_cap.shape)
    
    # Fragmentation Avoidance
    remaining_fraction = waste / np.max(bins_remain_cap)
    too_fragmented = (waste > 0) & (remaining_fraction < 0.1)
    priorities[too_fragmented] -= 0.5

    return priorities
```
