{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Employs a combination of heuristics:\n        1. Waste Minimization: Prioritizes bins where the remaining space after\n           packing the item is minimal.  A near-perfect fit is highly valued.\n        2. Capacity Threshold: Avoids bins with extremely small remaining\n           capacity to reduce fragmentation. Bins that cannot fit are penalized.\n        3. Balancing Bin Utilization:  Slight preference for bins that are not\n           completely empty or completely full to maintain flexibility.\n        4. Random Perturbation: Introduces small randomness to avoid getting stuck\n           in local optima and explore slightly different packing arrangements.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Waste Minimization & Capacity Threshold\n    waste = bins_remain_cap - item\n    too_small = waste < 0\n    priorities[too_small] = -np.inf  # Never put item in bins that are too small.\n    waste[too_small] = np.inf\n\n    # Near-perfect fit bonus (minimize waste)\n    priorities += np.exp(-waste)  # Exponential decay for increasing waste.\n\n    # Bin utilization balancing - slightly prefers bins that aren't empty or full.  avoids extremities.  Parabolic preference\n    bin_fraction = bins_remain_cap / np.max(bins_remain_cap)\n    priorities += -(bin_fraction - 0.5)**2  # Adds a parabolic preference curve.\n\n    # Random Perturbation (introduces some \"quantum\" fluctuation). Very small value for numerical stability\n    priorities += np.random.normal(0, 0.01, size=bins_remain_cap.shape)\n\n    return priorities\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This priority function incorporates several factors to improve bin packing:\n    1.  Remaining capacity: Bins with capacity closer to the item size are preferred (First Fit Decreasing-like).\n    2.  Number of items already in the bin:  Slight preference for bins with fewer items. Not directly tracked, so proxy with remaining capacity.\n    3. Penalize bins where the item won't fit.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Capacity considerations\n    capacity_diff = np.abs(bins_remain_cap - item)  # Difference between remaining capacity and item size\n    priorities = 1.0 / (1e-6 + capacity_diff) # Prefer bins with closer capacities\n\n    # 2. Small bias towards filling emptier bins. This is implicit from larger remaining capacity\n\n    # 3. Massive penalty for bins where the item won't fit.\n    infeasible_mask = item > bins_remain_cap\n    priorities[infeasible_mask] = -np.inf\n\n    # Some scaling and smoothing to make function better behaved (prevent numerical overflow)\n    priorities = np.nan_to_num(priorities, neginf=-np.inf)  #Handles bins with 0 remaining capacity cleanly when item >0.\n    return priorities\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This function refines the priority calculation by considering both the\n    remaining capacity and the potential waste if the item is placed in that bin.\n    Bins that have a remaining capacity slightly larger than the item size\n    are given higher priority to minimize fragmentation.  A term is added to strongly penalize bins where item doesn't fit.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Calculate wasted space if item is placed in the bin\n    wasted_space = bins_remain_cap - item\n\n    # Give higher priority to bins where item fits and waste is minimized\n    # Use a Gaussian-like function to prioritize bins with minimal waste\n    # with a peak at zero waste, and clip the negative values.\n    fit_mask = wasted_space >= 0\n    if np.any(fit_mask):  # only apply if the item fits any of the bins\n\n        # This scaling factor can be tuned; larger values make it sharper\n        # and less tolerable of larger bins.\n        scaling_factor = 2.0\n        priorities[fit_mask] = np.exp(-scaling_factor * wasted_space[fit_mask]**2 / bins_remain_cap[fit_mask].mean())\n    \n    #Severely penalize bins where the item doesn't fit by setting to a very low number.\n    priorities[~fit_mask] = -1e9 # effectively sets to a very low priority so it is negligibly considered.\n\n    return priorities\n\n[Heuristics 4th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This priority function incorporates several factors to improve bin packing:\n    1.  Remaining capacity: Bins with capacity closer to the item size are preferred (First Fit Decreasing-like).\n    2.  Number of items already in the bin:  Slight preference for bins with fewer items. Not directly tracked, so proxy with remaining capacity.\n    3. Penalize bins where the item won't fit.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Capacity considerations\n    capacity_diff = np.abs(bins_remain_cap - item)  # Difference between remaining capacity and item size\n    priorities = 1.0 / (1e-6 + capacity_diff) # Prefer bins with closer capacities\n\n    # 2. Small bias towards filling emptier bins. This is implicit from larger remaining capacity\n\n    # 3. Massive penalty for bins where the item won't fit.\n    infeasible_mask = item > bins_remain_cap\n    priorities[infeasible_mask] = -np.inf\n\n    # Some scaling and smoothing to make function better behaved (prevent numerical overflow)\n    priorities = np.nan_to_num(priorities, neginf=-np.inf)  #Handles bins with 0 remaining capacity cleanly when item >0.\n    return priorities\n\n[Heuristics 5th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins that can fit the item snugly,\n    but also considers the overall remaining capacity of the bins.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Give a negative infinite priority to bins that cannot fit the item\n    priorities[bins_remain_cap < item] = -np.inf\n    \n    # Calculate the wasted space if the item is placed in each bin\n    wasted_space = bins_remain_cap - item\n    \n    # Calculate the ratio of item size to remaining capacity (snugness)\n    snugness = item / bins_remain_cap\n\n    # Give a higher priority to bins with smaller wasted space and higher snugness\n    # Use a combination of factors to balance the two considerations. Experimentally determined.\n    valid_bins = bins_remain_cap >= item\n    priorities[valid_bins] = 2 * np.exp(-wasted_space[valid_bins]) + snugness[valid_bins]\n\n    # Normalize the priorities so that the function always return meaningful results, and to prevent overflow\n    priorities = (priorities - np.min(priorities)) / (np.max(priorities) - np.min(priorities) + 1e-9)\n\n    return priorities\n\n[Heuristics 6th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Employs a combination of factors: space utilization, waste minimization,\n    and a touch of \"quantum\" fluctuation to encourage exploration.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    epsilon = 1e-9  # Small value to avoid division by zero and log of zero\n    available_space = bins_remain_cap + epsilon #avoid div by zero\n\n    # 1. Space Utilization: How much of the bin will be filled?\n    utilization = item / available_space\n\n    # 2. Waste Minimization: How much space will be wasted if we use this bin?\n    waste = available_space - item\n    normalized_waste = waste / available_space # normalized\n\n    # 3. Encourage near-perfect fits\n    near_perfect_fit = np.exp(-np.abs(waste)) # close to zero waste -> close to one\n\n    # 4. Small Bins : small bins prioritized but not if near perfect waste\n    small_bins_priority = 1.0 / (available_space + epsilon)\n\n\n    #5. Quantum-inspired randomness: Explore different possibilities (temperature can be tuned)\n    temperature = 0.1  # Tunes the level of \"quantum fluctuation\"\n    random_fluctuation = np.random.normal(0, temperature, size=bins_remain_cap.shape) # add noise\n\n    # Combine the factors, with tunable weights. This is where the magic happens!\n    # Fine-tune these weights to get the best performance.\n    priority = (\n        1.0 * utilization\n        -0.5 * normalized_waste\n        + 1.0 * near_perfect_fit\n        + 0.5 * small_bins_priority\n        + 0.1 * random_fluctuation # added fluctuations\n\n    )\n\n    return priority\n\n[Heuristics 7th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Calculate waste if item is added to each bin\n    waste = bins_remain_cap - item\n    \n    # Give a high priority to bins where the item fits\n    # and a lower priority to bins where it doesn't.\n\n    fits = waste >= 0\n    \n    if np.any(fits): #prioritize the bins where the item fits\n      \n      #Prioritize smaller waste when the item fits\n      priorities[fits] = 1.0 / (waste[fits] + 1e-9)  # Adding a small constant to avoid division by zero.\n    \n    else: # if the item does not fit in any bin, put it in the bin with maximum remaining capacity.\n        priorities = bins_remain_cap/np.sum(bins_remain_cap + 1e-9)\n    \n\n    return priorities\n\n[Heuristics 8th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This priority function considers several factors:\n\n    1.  Remaining capacity: Bins with capacity closer to the item size are preferred.\n    2.  Waste avoidance: Bins with smaller remaining capacity after placing the item are preferred.\n    3.  Bin Utilization: Prefers filling bins that are already partially full\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Large negative values where item doesn't fit.\n    invalid_mask = item > bins_remain_cap\n    priorities[invalid_mask] = -np.inf  # Don't even consider it if impossible.\n\n    valid_mask = ~invalid_mask\n\n    if np.any(valid_mask):\n        # Capacity-based priority. Higher if bins_remain_cap and item close.\n\n        capacity_diff = np.abs(bins_remain_cap[valid_mask] - item)\n        capacity_priority = -capacity_diff  # Smaller diff == higher priority.\n        capacity_priority = capacity_priority / np.max(np.abs(capacity_priority)) #normalize\n\n        # Waste-based priority.  Lower waste = higher priority\n        waste = bins_remain_cap[valid_mask] - item\n        waste_priority = -waste # Lower waste is good\n        waste_priority = waste_priority / np.max(np.abs(waste_priority)) # normalize\n        # Bin utilization: favor bins that are already partially filled\n\n        utilization = 1 - bins_remain_cap[valid_mask]/np.max(bins_remain_cap) # assumption is max bins_remain_cap is capacity of all bins\n\n        priorities[valid_mask] =  0.5*capacity_priority + 0.3*waste_priority + 0.2*utilization  # Combine metrics\n\n\n    return priorities\n\n[Heuristics 9th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Ensure no division by zero or negative values (invalid bin capacities)\n    valid_bins = bins_remain_cap > 0\n    \n    if not np.any(valid_bins):\n        return np.full(bins_remain_cap.shape, -np.inf) #All bins are full or invalid.\n    \n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # First, prioritize bins that can actually fit the item.  Inertia favors those that fit\n    fit_mask = (bins_remain_cap >= item) & valid_bins\n    \n    # If there are bins that fit the item:\n    if np.any(fit_mask):\n        # Emphasize bins that are filled more fully by this addition.  A stronger pull.\n        fill_ratios = item / bins_remain_cap[fit_mask]\n        \n        #Refined Gravitational constant\n        gravitational_constant = 1.0\n        \n        # Higher score if we nearly fill the bin. This ensures better utilization.\n        priorities[fit_mask] = gravitational_constant * (1 - np.abs(1 - fill_ratios))\n\n        # Slightly incentivize using the fullest bin if several will work. This acts like attraction to fuller states, more compact packing\n        priorities[fit_mask] += 0.1 * bins_remain_cap[fit_mask] / bins_remain_cap[fit_mask].max()\n    \n    #If NO bins can fit: force select an empty bin\n    else:\n        # No bins can fit! Place in an empty bin, if one exists. Otherwise, ignore. This prevents wasted space.\n        empty_mask = (bins_remain_cap == bins_remain_cap.max()) & valid_bins #Largest, ie., most likely to be new\n        if np.any(empty_mask):\n            priorities[empty_mask] = 0.5  # small pull to initialize a new empty bin\n        else:\n            return np.full(bins_remain_cap.shape, -np.inf) # All bins are full, should theoretically not reach this given online BPP framework\n    \n    # Finally, prevent placing items in invalid bins:\n    priorities[~valid_bins] = -np.inf\n    \n    return priorities\n\n[Heuristics 10th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # First, identify bins that can actually hold the item.\n    valid_bins = bins_remain_cap >= item\n\n    if not np.any(valid_bins):\n        # No bin can hold the item. Prioritize bins with largest remaining capacity\n        # (this is a last resort; should rarely happen).\n        priorities = bins_remain_cap\n        return priorities\n\n    # For bins that *can* hold the item, apply a more sophisticated heuristic.\n\n    # 1. Waste minimization:\n    waste = bins_remain_cap - item\n    waste[~valid_bins] = np.inf  # Invalid bins have infinite waste.\n\n    # 2. Fractional occupancy\n    occupancy = item / bins_remain_cap\n    occupancy[~valid_bins] = 0 #assign 0 occupancy for bins unable to take the item\n    #3. Calculate priority: bins that have just enough to fit, are preferred\n\n    priorities = np.where(valid_bins, np.exp(-2 * np.abs(waste)/(item)), -np.inf)\n\n\n    # Add a small random component for tie-breaking (introduces exploration).\n    priorities += 0.001 * np.random.rand(len(bins_remain_cap))\n\n    return priorities\n\n[Heuristics 11th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Ensure no division by zero or negative values (invalid bin capacities)\n    valid_bins = bins_remain_cap > 0\n    \n    if not np.any(valid_bins):\n        return np.full(bins_remain_cap.shape, -np.inf) #All bins are full or invalid.\n    \n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # First, prioritize bins that can actually fit the item.  Inertia favors those that fit\n    fit_mask = (bins_remain_cap >= item) & valid_bins\n    \n    # If there are bins that fit the item:\n    if np.any(fit_mask):\n        # Emphasize bins that are filled more fully by this addition.  A stronger pull.\n        fill_ratios = item / bins_remain_cap[fit_mask]\n        \n        #Refined Gravitational constant\n        gravitational_constant = 1.0\n        \n        # Higher score if we nearly fill the bin. This ensures better utilization.\n        priorities[fit_mask] = gravitational_constant * (1 - np.abs(1 - fill_ratios))\n\n        # Slightly incentivize using the fullest bin if several will work. This acts like attraction to fuller states, more compact packing\n        priorities[fit_mask] += 0.1 * bins_remain_cap[fit_mask] / bins_remain_cap[fit_mask].max()\n    \n    #If NO bins can fit: force select an empty bin\n    else:\n        # No bins can fit! Place in an empty bin, if one exists. Otherwise, ignore. This prevents wasted space.\n        empty_mask = (bins_remain_cap == bins_remain_cap.max()) & valid_bins #Largest, ie., most likely to be new\n        if np.any(empty_mask):\n            priorities[empty_mask] = 0.5  # small pull to initialize a new empty bin\n        else:\n            return np.full(bins_remain_cap.shape, -np.inf) # All bins are full, should theoretically not reach this given online BPP framework\n    \n    # Finally, prevent placing items in invalid bins:\n    priorities[~valid_bins] = -np.inf\n    \n    return priorities\n\n[Heuristics 12th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Inspired by celestial mechanics and the elliptical orbits of planets,\n    we consider both the 'distance' (remaining capacity) and a 'velocity'\n    component based on how much capacity is left relative to the item size.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Give bins that can't fit a priority of negative infinity\n    infeasible = bins_remain_cap < item\n    priorities[infeasible] = -np.inf\n\n    # Encourage filling bins closer to full.\n    # The closer the item size is to the remaining capacity, the better\n    # 'Gravity' component: Inverse square law analogy - closer is better\n    gravity = (item / bins_remain_cap) ** 2  # Closer = stronger pull\n\n    # 'Velocity' component:  Rate of filling - aims for perfect fit.\n    velocity = np.exp(-np.abs(bins_remain_cap - item) / item) # Exponential decay of benefit\n\n    priorities[~infeasible] = gravity[~infeasible] * velocity[~infeasible] # Combination: Gravity pulling + speed aligning to target.\n    # Bonus: Small priority to nearly full bins\n    nearly_full = (bins_remain_cap > item) & (bins_remain_cap < item * 1.2)\n    priorities[nearly_full] += 0.5  # Gently nudges for packing\n\n    return priorities\n\n[Heuristics 13th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Inspired by celestial mechanics and the elliptical orbits of planets,\n    we consider both the 'distance' (remaining capacity) and a 'velocity'\n    component based on how much capacity is left relative to the item size.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Give bins that can't fit a priority of negative infinity\n    infeasible = bins_remain_cap < item\n    priorities[infeasible] = -np.inf\n\n    # Encourage filling bins closer to full.\n    # The closer the item size is to the remaining capacity, the better\n    # 'Gravity' component: Inverse square law analogy - closer is better\n    gravity = (item / bins_remain_cap) ** 2  # Closer = stronger pull\n\n    # 'Velocity' component:  Rate of filling - aims for perfect fit.\n    velocity = np.exp(-np.abs(bins_remain_cap - item) / item) # Exponential decay of benefit\n\n    priorities[~infeasible] = gravity[~infeasible] * velocity[~infeasible] # Combination: Gravity pulling + speed aligning to target.\n    # Bonus: Small priority to nearly full bins\n    nearly_full = (bins_remain_cap > item) & (bins_remain_cap < item * 1.2)\n    priorities[nearly_full] += 0.5  # Gently nudges for packing\n\n    return priorities\n\n[Heuristics 14th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Find bins that can accommodate the item\n    valid_bins = bins_remain_cap >= item\n    \n    if np.any(valid_bins):\n        # Calculate remaining space after placing the item in each valid bin\n        remaining_space = bins_remain_cap[valid_bins] - item\n        \n        # Give higher priority to bins where the remaining space is small,\n        # but not too small (avoiding extreme fragmentation). We use a Gaussian-like\n        # function centered around a desirable remaining space (e.g., 0.2 times bin capacity).\n        desirable_remaining_space = 0.2 * np.max(bins_remain_cap) #trying to target 20% of max capacity bin remain\n\n        priority_values = np.exp(-((remaining_space - desirable_remaining_space) ** 2) / (2 * (desirable_remaining_space/2)** 2))\n                                    #remaining_space - desirable_remaining_space squared. Devided by 2 times SD square(SD is half des remain cap), e to the power - result.\n\n        \n        priorities[valid_bins] = priority_values\n\n        #Add a small constant priority boost to bins that can fit item\n        priorities[valid_bins] += 0.1\n    else:\n        # If no bin can accommodate the item, penalize heavily so a new bin gets opened\n        priorities = np.full_like(bins_remain_cap, -1000) # extreme negative, ensure new bin opened.\n        \n    return priorities\n\n[Heuristics 15th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Initialize impossible locations to a very low priority.\n    infeasible = bins_remain_cap < item\n    priorities[infeasible] = -np.inf\n\n    # For feasible bins, prioritize based on remaining capacity.\n\n    # 1.  Higher priority for bins that accommodate item and leave minimal leftover space.\n\n    # 2.  Lower priority (but still better than infeasible) to locations where there is excessive space.\n\n    # 3. Incorporate a 'gravity' term to attract items to partially full bins, discouraging them from solely filling empty bins early on.\n\n    feasible = ~infeasible\n    if np.any(feasible):\n\n        residual_space = bins_remain_cap[feasible] - item\n\n        # Prioritize almost-full bins.  The exponent sharpens the peak.\n        priorities[feasible] += np.exp(-residual_space**2)\n\n        # Moderate gravity effect, scaled by item size so larger items are drawn more.\n        # The logarithm dampens excessive attraction to any single bin.\n        priorities[feasible] += item * np.log1p(bins_remain_cap[feasible])  / np.max(bins_remain_cap)\n\n        # Discourage large leftovers. Subtract penalty proportional to unused space, but less aggressively.\n        priorities[feasible] -= 0.1 * residual_space / np.max(bins_remain_cap)\n\n\n\n    return priorities\n\n[Heuristics 16th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Initialize impossible locations to a very low priority.\n    infeasible = bins_remain_cap < item\n    priorities[infeasible] = -np.inf\n\n    # For feasible bins, prioritize based on remaining capacity.\n\n    # 1.  Higher priority for bins that accommodate item and leave minimal leftover space.\n\n    # 2.  Lower priority (but still better than infeasible) to locations where there is excessive space.\n\n    # 3. Incorporate a 'gravity' term to attract items to partially full bins, discouraging them from solely filling empty bins early on.\n\n    feasible = ~infeasible\n    if np.any(feasible):\n\n        residual_space = bins_remain_cap[feasible] - item\n\n        # Prioritize almost-full bins.  The exponent sharpens the peak.\n        priorities[feasible] += np.exp(-residual_space**2)\n\n        # Moderate gravity effect, scaled by item size so larger items are drawn more.\n        # The logarithm dampens excessive attraction to any single bin.\n        priorities[feasible] += item * np.log1p(bins_remain_cap[feasible])  / np.max(bins_remain_cap)\n\n        # Discourage large leftovers. Subtract penalty proportional to unused space, but less aggressively.\n        priorities[feasible] -= 0.1 * residual_space / np.max(bins_remain_cap)\n\n\n\n    return priorities\n\n[Heuristics 17th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Aims to balance bin usage and avoid fragmentation.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # 1. Feasibility: Only consider bins where the item fits.\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        return priorities # All zeros, no feasible bin\n\n    # 2. Remaining Capacity: Favor bins with more remaining capacity *relative to the item size*.\n    #    This encourages filling bins that already have some space.  We use a scaled measure.\n    relative_capacity = (bins_remain_cap - item) / np.max(bins_remain_cap)  # Scales between 0 and 1\n\n    # 3. Avoid Overfilling: Penalize bins where the remaining capacity is just barely enough.\n    #  This encourages finding bins with a *little* more space than necessary.\n    #  We will penalize with values between 0 and 1, based on the buffer remaining.\n    buffer = bins_remain_cap - item\n    small_buffer_penalty = np.clip(1 - (buffer / item), a_min=0, a_max=1)  # 1 if buffer == 0, 0 if buffer >= item\n\n    # Combine the factors:\n    priorities[feasible_bins] = (relative_capacity[feasible_bins] * (1-small_buffer_penalty[feasible_bins]) ) #Scale Capacity by not choosing too little.\n\n    return priorities\n\n[Heuristics 18th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Aims to balance bin usage and avoid fragmentation.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # 1. Feasibility: Only consider bins where the item fits.\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        return priorities # All zeros, no feasible bin\n\n    # 2. Remaining Capacity: Favor bins with more remaining capacity *relative to the item size*.\n    #    This encourages filling bins that already have some space.  We use a scaled measure.\n    relative_capacity = (bins_remain_cap - item) / np.max(bins_remain_cap)  # Scales between 0 and 1\n\n    # 3. Avoid Overfilling: Penalize bins where the remaining capacity is just barely enough.\n    #  This encourages finding bins with a *little* more space than necessary.\n    #  We will penalize with values between 0 and 1, based on the buffer remaining.\n    buffer = bins_remain_cap - item\n    small_buffer_penalty = np.clip(1 - (buffer / item), a_min=0, a_max=1)  # 1 if buffer == 0, 0 if buffer >= item\n\n    # Combine the factors:\n    priorities[feasible_bins] = (relative_capacity[feasible_bins] * (1-small_buffer_penalty[feasible_bins]) ) #Scale Capacity by not choosing too little.\n\n    return priorities\n\n[Heuristics 19th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Aims to balance bin usage and avoid fragmentation.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # 1. Feasibility: Only consider bins where the item fits.\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        return priorities # All zeros, no feasible bin\n\n    # 2. Remaining Capacity: Favor bins with more remaining capacity *relative to the item size*.\n    #    This encourages filling bins that already have some space.  We use a scaled measure.\n    relative_capacity = (bins_remain_cap - item) / np.max(bins_remain_cap)  # Scales between 0 and 1\n\n    # 3. Avoid Overfilling: Penalize bins where the remaining capacity is just barely enough.\n    #  This encourages finding bins with a *little* more space than necessary.\n    #  We will penalize with values between 0 and 1, based on the buffer remaining.\n    buffer = bins_remain_cap - item\n    small_buffer_penalty = np.clip(1 - (buffer / item), a_min=0, a_max=1)  # 1 if buffer == 0, 0 if buffer >= item\n\n    # Combine the factors:\n    priorities[feasible_bins] = (relative_capacity[feasible_bins] * (1-small_buffer_penalty[feasible_bins]) ) #Scale Capacity by not choosing too little.\n\n    return priorities\n\n[Heuristics 20th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Aims to balance bin usage and avoid fragmentation.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # 1. Feasibility: Only consider bins where the item fits.\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        return priorities # All zeros, no feasible bin\n\n    # 2. Remaining Capacity: Favor bins with more remaining capacity *relative to the item size*.\n    #    This encourages filling bins that already have some space.  We use a scaled measure.\n    relative_capacity = (bins_remain_cap - item) / np.max(bins_remain_cap)  # Scales between 0 and 1\n\n    # 3. Avoid Overfilling: Penalize bins where the remaining capacity is just barely enough.\n    #  This encourages finding bins with a *little* more space than necessary.\n    #  We will penalize with values between 0 and 1, based on the buffer remaining.\n    buffer = bins_remain_cap - item\n    small_buffer_penalty = np.clip(1 - (buffer / item), a_min=0, a_max=1)  # 1 if buffer == 0, 0 if buffer >= item\n\n    # Combine the factors:\n    priorities[feasible_bins] = (relative_capacity[feasible_bins] * (1-small_buffer_penalty[feasible_bins]) ) #Scale Capacity by not choosing too little.\n\n    return priorities\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}