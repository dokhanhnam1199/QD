```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Combines waste minimization and utilization, with item-aware scaling."""
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    waste = bins_remain_cap - item
    fit_mask = waste >= 0

    if np.any(fit_mask):
        # Waste minimization with scaling.
        item_fraction = item / np.max(bins_remain_cap)
        scaling_factor = 1.0 + item_fraction
        priorities[fit_mask] = np.exp(-scaling_factor * waste[fit_mask] / (bins_remain_cap[fit_mask].mean() + 1e-9))

        # Utilization balancing.
        utilization_target = 0.7
        utilization_priority = np.exp(-((bins_remain_cap[fit_mask]/np.max(bins_remain_cap) - utilization_target) ** 2))
        priorities[fit_mask] = 0.7*priorities[fit_mask] + 0.3*utilization_priority

        # Bias towards larger capacity bins.
        capacity_bias = 0.1 * bins_remain_cap[fit_mask] / np.max(bins_remain_cap)
        priorities[fit_mask] += capacity_bias

        # Small random noise.
        priorities[fit_mask] += np.random.normal(0, 0.01, size=np.sum(fit_mask))

    priorities[~fit_mask] = -1e9
    return priorities
```
