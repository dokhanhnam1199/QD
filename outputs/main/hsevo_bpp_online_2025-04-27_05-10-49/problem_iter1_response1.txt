```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version considers a combination of factors:
    1. Remaining capacity: Favor bins that can fit the item comfortably.
    2. Waste minimization: Penalize bins that would result in significant unused space.
    3. Relative fullness: Give preference to bins that are already somewhat full.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    # Einstein's insightful modifications for optimization:
    # 1. "Spacetime Curvature" (Capacity-Dependent Attraction):  Bins with remaining capacity
    # closer to the item's size are more attractive, but not too close to avoid overfilling.
    # 2. "Cosmic Repulsion" (Waste Minimization): Bins with much larger remaining capacity
    # relative to the item size are penalized, as they would lead to significant waste.
    # 3. "Relativistic Momentum" (Fullness Bonus):  Bins that are already relatively full
    # are preferred to consolidate items.

    epsilon = 1e-6  # Small constant to avoid division by zero

    # Capacity factor (curved spacetime):
    capacity_factor = np.exp(-np.abs(bins_remain_cap - item) / (item + epsilon))

    # Waste minimization (cosmic repulsion):
    waste_factor = np.exp(-bins_remain_cap / (item + epsilon))

    # Fullness bonus (relativistic momentum):
    fullness_ratio = 1 - (bins_remain_cap / (np.max(bins_remain_cap) + epsilon))
    fullness_factor = np.sqrt(fullness_ratio)


    # Combine factors into a final priority score:
    priorities = capacity_factor * (1 - waste_factor) * (1 + fullness_factor)

    # Ensure no negative priorities, just in case
    priorities = np.maximum(0, priorities)

    return priorities
```
