```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.
    This version prioritizes bins that can fit the item closely without
    leaving too much wasted space, and also penalizes bins that are nearly full.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    for i, cap in enumerate(bins_remain_cap):
        if cap >= item:
            # Prioritize bins where the item fits, and remaining space isn't too large
            remaining_space = cap - item
            # Give higher priority to bins where the remaining space is small relative to item size. Prevents excessive fragmentation.
            # Penalize if the item will almost fill the bin
            space_ratio = remaining_space / item

            # Reward bins with space ratio between 0 and 1, and penalize outside that. Prevents big gaps or almost-full bins.
            if space_ratio > 1:
              priorities[i] = 0.1 / (space_ratio**2)
            else:
              priorities[i] = 1 / (1 + space_ratio)
        else:
            # If item doesn't fit, assign a very low priority
            priorities[i] = -1e9  # effectively exclude this bin

    return priorities
```
