```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.
    Employs a combination of enhanced heuristics:
        1. Waste Minimization with Sigmoid Scaling: Prioritizes bins where the
           remaining space after packing the item is minimal, with a sigmoid
           function to provide a more nuanced scaling of waste.  Very small waste
           gets a very high priority boost.
        2. Capacity Threshold with Adaptive Threshold: Dynamically adjusts the
           capacity threshold based on the item size to avoid excessive
           fragmentation.
        3. Bin Utilization Balancing with Exponential Preference:  Stronger
           preference for bins that are neither too empty nor too full,
           encouraging more balanced packing. Uses an exponential function
           to sharply prioritize bins near the ideal fill level.
        4. Item Size-Aware Random Perturbation: Introduces randomness scaled
           by the item size to encourage exploration that is proportional
           to the item being packed.
        5. Bin Diversity Incentive: Adds a bonus for using bins with different
           fill levels, promoting exploration of diverse packing configurations.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Waste Minimization & Capacity Threshold
    waste = bins_remain_cap - item
    too_small = waste < 0
    priorities[too_small] = -np.inf  # Never put item in bins that are too small.
    waste[too_small] = np.inf

    # Near-perfect fit bonus with sigmoid scaling
    # Sigmoid provides more nuanced scaling of waste, boosting near-perfect fits.
    waste_scaled = 1 / (1 + np.exp(10 * waste - 1))  # Sharper near-fit preference.

    priorities += waste_scaled

    # Bin utilization balancing with exponential preference
    bin_fraction = bins_remain_cap / np.max(bins_remain_cap)
    # Exponential curve to strongly prioritize bins near the ideal fill level.
    ideal_fill = 0.6  # Experiment with values like 0.5, 0.6, 0.7.

    # penalize values far from ideal_fill.
    priorities += np.exp(-5 * (bin_fraction - ideal_fill)**2)

    # Item Size-Aware Random Perturbation
    # Randomness scaled by item size for exploration proportional to item being packed.
    priorities += np.random.normal(0, 0.01 * item, size=bins_remain_cap.shape)

    # Bin Diversity Incentive
    # Encourages using bins with diverse fill levels
    fill_std = np.std(bins_remain_cap)
    priorities += 0.01 * fill_std  # Small bonus for diverse bin utilization

    return priorities
```
