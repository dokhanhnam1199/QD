[
  {
    "stdout_filepath": "problem_iter29_response0.txt_stdout.txt",
    "code_path": "problem_iter29_code0.py",
    "code": "import numpy as np\n\n_rng = np.random.default_rng()\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Inverse leftover with tightness factor, variance\u2011scaled jitter, tiny bias.\"\"\"\n    n = bins_remain_cap.size\n    if n == 0:\n        return np.empty(0, dtype=float)\n    eps = 1e-12\n    remaining = bins_remain_cap - item\n    feasible = remaining >= 0\n    priority = np.full(n, -np.inf, dtype=float)\n    if not np.any(feasible):\n        return priority\n    rem_feasible = remaining[feasible]\n    base = 1.0 / (rem_feasible + eps)\n    base *= item / (item + rem_feasible + eps)\n    var_rem = np.var(rem_feasible)\n    jitter_scale = item * 0.01 * (1.0 + np.sqrt(var_rem))\n    jitter = (_rng.random(rem_feasible.size) - 0.5) * jitter_scale\n    bias = -np.arange(n)[feasible] * 1e-6\n    priority[feasible] = base + jitter + bias\n    return priority",
    "response_id": 0,
    "tryHS": false,
    "obj": 3.470283207020339,
    "SLOC": 19.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter29_response1.txt_stdout.txt",
    "code_path": "problem_iter29_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Best\u2011fit score with tiny index bias, golden\u2011ratio jitter, and variance\u2011scaled random jitter.\"\"\"\n    # Convert input to NumPy array and compute remaining capacity after placing the item.\n    bins = np.asarray(bins_remain_cap, dtype=float)\n    n = bins.size\n    if n == 0:\n        return np.empty(0, dtype=float)\n    remaining = bins - item\n    feasible = remaining >= 0\n    scores = np.full(n, -np.inf, dtype=float)\n    if not feasible.any():\n        return scores\n    eps = 1e-12\n    idx = np.arange(n, dtype=float)\n    # Inverse leftover encourages tight packing (best\u2011fit).\n    inv_leftover = 1.0 / (remaining[feasible] + eps)\n    # Tiny index bias for deterministic tie\u2011breaking (prefer lower index).\n    bias = -idx[feasible] * 1e-9\n    # Deterministic golden\u2011ratio jitter adds slight perturbation.\n    phi = (1 + np.sqrt(5)) / 2\n    phi_jitter = ((phi * (idx[feasible] + 1) * item) % 1.0) * 1e-6 * item\n    # Random jitter scaled by the variance of remaining capacities.\n    std = np.std(remaining[feasible])\n    mean = np.mean(remaining[feasible]) + eps\n    coeff = std / mean\n    rng = np.random.default_rng()\n    rand_jitter = rng.random(feasible.sum()) * item * 0.005 * (1.0 + coeff)\n    scores[feasible] = inv_leftover + bias + phi_jitter + rand_jitter\n    return scores",
    "response_id": 1,
    "tryHS": false,
    "obj": 3.6398085360989234,
    "SLOC": 23.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter29_response2.txt_stdout.txt",
    "code_path": "problem_iter29_code2.py",
    "code": "import numpy as np\n\n_rng = np.random.default_rng()\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    n = bins_remain_cap.size\n    if n == 0:\n        return np.empty(0, dtype=float)\n    eps = 1e-12\n    remaining = bins_remain_cap - item\n    feasible = remaining >= 0\n    priority = np.full(n, -np.inf, dtype=float)\n    if not feasible.any():\n        return priority\n    rem_feas = remaining[feasible]\n    base = 1.0 / (rem_feas + eps)\n    load_balance = item / (item + rem_feas + eps)\n    var_rem = np.var(rem_feas)\n    jitter_scale = item * 0.005 * (1.0 + np.sqrt(var_rem))\n    jitter = (_rng.random)  # corrected: should be _rng.random(n)\n    jitter = (_rng.random(n) - 0.5) * jitter_scale\n    bias = -np.arange(n)[feasible] * 1e-6\n    priority[feasible] = base + load_balance + jitter[feasible] + bias\n    return priority",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.15835660151576,
    "SLOC": 20.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter29_response3.txt_stdout.txt",
    "code_path": "problem_iter29_code3.py",
    "code": "import numpy as np\n\n# Combine inverse\u2011leftover, tightness factor, variance\u2011scaled jitter, and tiny bias.\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, rng: np.random.Generator = np.random.default_rng()) -> np.ndarray:\n    \"\"\"Score bins by inverse leftover weighted by tightness, with variance\u2011scaled jitter and tiny index bias.\"\"\"\n    n = bins_remain_cap.size\n    if n == 0:\n        return np.empty(0, dtype=float)\n    remaining = bins_remain_cap - item\n    feasible = remaining >= 0\n    priority = np.full(n, -np.inf, dtype=float)\n    if not np.any(feasible):\n        return priority\n    eps = 1e-12\n    rem = remaining[feasible]\n    # Base: inverse leftover weighted by tightness (prefers tighter fit)\n    base = 1.0 / (rem + eps)\n    tight = item / (item + rem + eps)\n    base *= tight\n    # Jitter scaled by item size and variance of remaining capacities\n    var_rem = np.var(rem) if rem.size > 1 else 0.0\n    jitter_coeff = 0.005 * (1.0 + np.sqrt(var_rem))\n    jitter_scale = item * jitter_coeff\n    jitter = (rng.random(rem.shape) - 0.5) * jitter_scale\n    # Tiny index bias for deterministic tie\u2011breaks\n    idx_bias = np.arange(n)[feasible] * 1e-6\n    priority[feasible] = base + jitter + idx_bias\n    return priority",
    "response_id": 3,
    "tryHS": false,
    "obj": 2.9417630634224174,
    "SLOC": 21.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter29_response4.txt_stdout.txt",
    "code_path": "problem_iter29_code4.py",
    "code": "import numpy as np\n\n_rng = np.random.default_rng()\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Score bins: inverse leftover + variance\u2011scaled jitter + tiny index bias + deviation penalty.\"\"\"\n    n = bins_remain_cap.size\n    if n == 0:\n        return np.empty(0, dtype=float)\n    remaining = bins_remain_cap - item\n    feasible = remaining >= 0\n    priority = np.full(n, -np.inf, dtype=float)\n    if not feasible.any():\n        return priority\n    eps = 1e-12\n    base = 1.0 / (remaining[feasible] + eps)\n    bias = -np.arange(n)[feasible] * 1e-6\n    var_rem = np.var(remaining[feasible])\n    jitter_scale = item * 0.01 * (1.0 + np.sqrt(var_rem))\n    jitter = (_rng.random(remaining[feasible].size) - 0.5) * jitter_scale\n    var_penalty = -((remaining[feasible] - remaining[feasible].mean())**2) * 1e-6\n    priority[feasible] = base + bias + jitter + var_penalty\n    return priority",
    "response_id": 4,
    "tryHS": true,
    "obj": 2.8320702034304044,
    "SLOC": 18.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter29_response5.txt_stdout.txt",
    "code_path": "problem_iter29_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Score bins with inverse leftover, tightness, variance\u2011scaled jitter, and tiny bias.\"\"\"\n    bins = np.asarray(bins_remain_cap, dtype=float)\n    n = bins.size\n    if n == 0:\n        return np.empty(0, dtype=float)\n    remaining = bins - item\n    feasible = remaining >= 0\n    scores = np.full(n, -np.inf, dtype=float)\n    if not feasible.any():\n        return scores\n    eps = 1e-12\n    rem = remaining[feasible]\n    inv_leftover = 1.0 / (rem + eps)\n    tightness = item / (item + rem + eps)\n    idx = np.arange(n, dtype=float)[feasible]\n    phi = (1 + np.sqrt(5.0)) / 2.0\n    phi_jitter = ((phi * (idx + 1.0) * item) % 1.0) * 1e-6 * item\n    bias = -idx * 1e-6\n    mean = np.mean(rem)\n    std = np.std(rem)\n    coeff = std / (mean + eps)\n    jitter_weight = 0.01 * (1.0 + coeff)\n    rand_jitter = np.random.random(rem.shape) * jitter_weight * item\n    scores[feasible] = inv_leftover + tightness + phi_jitter + rand_jitter + bias\n    return scores",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.11846828879138,
    "SLOC": 25.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter29_response6.txt_stdout.txt",
    "code_path": "problem_iter29_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Inverse leftover + bias + deterministic jitter + variance\u2011scaled random jitter for online bin packing.\"\"\"\n    bins = np.asarray(bins_remain_cap, dtype=float)\n    n = bins.size\n    if n == 0:\n        return np.empty(0, dtype=float)\n    remaining = bins - item\n    feasible = remaining >= 0\n    score = np.full(n, -np.inf, dtype=float)\n    if not np.any(feasible):\n        return score\n    eps = 1e-9\n    idx = np.arange(n, dtype=float)\n    inv_leftover = 1.0 / (remaining[feasible] + eps)\n    bias_factor = 3.3289346372599506e-05\n    bias = -idx[feasible] * bias_factor\n    phi = (1 + np.sqrt(5)) / 2\n    phi_jitter = ((phi * (idx[feasible] + 1) * item) % 1.0) * 1e-6 * item\n    std = np.std(remaining[feasible])\n    mean = np.mean(remaining[feasible]) + eps\n    coeff = std / mean\n    rng = np.random.default_rng()\n    jitter_scale_factor = 0.001284745224474304\n    rand_jitter = rng.random(feasible.sum()) * item * jitter_scale_factor * (1.0 + coeff)\n    score[feasible] = inv_leftover + bias + phi_jitter + rand_jitter\n    return score",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.3777423214998095,
    "SLOC": 25.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter29_response7.txt_stdout.txt",
    "code_path": "problem_iter29_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Best\u2011fit score: inverse leftover, tightness, deterministic golden\u2011ratio jitter, tiny index bias, and variance\u2011scaled random jitter. Returns -inf for infeasible bins.\"\"\"\n    bins = np.asarray(bins_remain_cap, dtype=float)\n    n = bins.size\n    if n == 0:\n        return np.empty(0, dtype=float)\n    remaining = bins - item\n    feasible = remaining >= 0\n    scores = np.full(n, -np.inf, dtype=float)\n    if not np.any(feasible):\n        return scores\n    eps = 1e-12\n    idx = np.arange(n, dtype=float)\n    rem_feas = remaining[feasible]\n    inv_leftover = 1.0 / (rem_feas + eps)\n    tightness = item / (item + rem_feas + eps)\n    phi = (1 + np.sqrt(5.0)) / 2.0\n    phi_jitter = ((phi * (idx[feasible] + 1.0) * item) % 1.0) * 1e-6 * item\n    bias = -idx[feasible] * 1e-6\n    mean = np.mean(rem_feas)\n    std = np.std(rem_feas)\n    coeff = std / (mean + eps)\n    jitter_weight = 0.01 * (1.0 + coeff)\n    rng = np.random.default_rng()\n    rand_jitter = rng.random(rem_feas.shape) * jitter_weight * item\n    scores[feasible] = inv_leftover + tightness + phi_jitter + rand_jitter + bias\n    return scores",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 26.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter29_response8.txt_stdout.txt",
    "code_path": "problem_iter29_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, _rng=np.random.default_rng()) -> np.ndarray:\n    \"\"\"Score bins by inverse leftover weighted by fit factor, jitter scaled by remaining variance, and tiny index bias.\"\"\"\n    # Combine best\u2011fit, fit factor, variance\u2011scaled jitter, and index bias.\n    n = bins_remain_cap.size\n    if n == 0:\n        return np.empty(0, dtype=float)\n    eps = 1e-12\n    remaining = bins_remain_cap - item\n    feasible = remaining >= 0\n    priority = np.full(n, -np.inf, dtype=float)\n    if not feasible.any():\n        return priority\n    rem = remaining[feasible]\n    base = 1.0 / (rem + eps)\n    fit_factor = item / (item + rem + eps)\n    score = base * fit_factor\n    var_rem = np.var(rem) if rem.size > 1 else 0.0\n    jitter_scale = item * 0.01 * (1.0 + np.sqrt(var_rem))\n    jitter = (_rng.random(rem.shape) - 0.5) * jitter_scale\n    bias = -np.arange(n)[feasible] * 1e-6\n    priority[feasible] = score + jitter + bias\n    return priority",
    "response_id": 8,
    "tryHS": false,
    "obj": 3.5301156761069095,
    "SLOC": 20.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter29_response9.txt_stdout.txt",
    "code_path": "problem_iter29_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Score bins: inverse leftover + variance\u2011scaled deterministic jitter + tiny index bias + mild deviation penalty.\"\"\"\n    # Combine best\u2011fit, variance\u2011scaled jitter, tiny bias, and mild penalty for robust online BPP.\n    eps = 1e-12\n    bins = np.asarray(bins_remain_cap, dtype=float)\n    n = bins.size\n    if n == 0:\n        return np.empty(0, dtype=float)\n    remaining = bins - item\n    feasible = remaining >= 0\n    priority = np.full(n, -np.inf, dtype=float)\n    if not feasible.any():\n        return priority\n    base = 1.0 / (remaining[feasible] + eps)\n    bias = -np.arange(n)[feasible] * 1e-6\n    jitter_raw = (np.mod((np.arange(n) + 1) * 0.6180339887498949, 1.0) - 0.5)\n    var_rem = np.var(remaining[feasible])\n    jitter_scale = item * 0.01 * (1.0 + np.sqrt(var_rem))\n    jitter = jitter_raw[feasible] * jitter_scale\n    mean_rem = np.mean(remaining[feasible])\n    penalty = -((remaining[feasible] - mean_rem) ** 2) * 1e-6\n    priority[feasible] = base + bias + jitter + penalty\n    return priority",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.15835660151576,
    "SLOC": 21.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter30_response0.txt_stdout.txt",
    "code_path": "problem_iter30_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, _rng: np.random.Generator = np.random.default_rng()) -> np.ndarray:\n    \"\"\"Return priority scores for each bin based on inverse leftover capacity and size  scaled jitter.\n    Infeasible bins receive -inf. A tiny deterministic bias ensures reproducible tie\u2011breaks.\"\"\"\n    if bins_remain_cap.size == 0:\n        return np.empty(0, dtype=float)\n    remaining = bins_remain_cap - item\n    feasible = remaining >= 0\n    priority = np.full(bins_remain_cap.shape, -np.inf, dtype=float)\n    if not feasible.any():\n        return priority\n    eps = 1e-12\n    base = 1.0 / (remaining[feasible] + eps)\n    var_rem = np.var(remaining[feasible])\n    sigma = 0.02\n    jitter = sigma * item * (1.0 + np.sqrt(var_rem)) * _rng.standard_normal(base.shape)\n    bias = 1e-9 * (np.arange(bins_remain_cap.size)[feasible] / bins_remain_cap.size)\n    priority[feasible] = base + jitter + bias\n    return priority",
    "response_id": 0,
    "tryHS": false,
    "obj": 36.69724770642202,
    "SLOC": 16.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter31_response0.txt_stdout.txt",
    "code_path": "problem_iter31_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float,\n                bins_remain_cap: np.ndarray,\n                epsilon: float = 7.632689957364007e-10,\n                bias_factor: float = 4.278629044460249e-05,\n                jitter_factor: float = 0.0039639290775410965,\n                var_penalty_factor: float = 3.724712406944985e-05) -> np.ndarray:\n    \"\"\"Score bins: inverse leftover + variance\u2011scaled jitter + tiny index bias + deviation penalty.\"\"\"\n    n = bins_remain_cap.size\n    if n == 0:\n        return np.empty(0, dtype=float)",
    "response_id": 0,
    "tryHS": true,
    "obj": 4.487435181491823,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  }
]