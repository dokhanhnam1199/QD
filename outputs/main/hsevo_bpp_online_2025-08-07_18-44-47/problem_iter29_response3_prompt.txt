{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code only and do not add comments into the code. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n_item_avg = None\n_item_count = 0\n\n    \"\"\"Score bins by inverse leftover, tightness factor, variance\u2011scaled jitter, tiny index bias.\"\"\"\n    n = bins_remain_cap.size\n    if n == 0:\n        return np.empty(0, dtype=float)\n    remaining = bins_remain_cap - item\n    feasible = remaining >= 0\n    priority = np.full(n, -np.inf, dtype=float)\n    if not np.any(feasible):\n        return priority\n    # Update running average of seen items (light adaptivity)\n    global _item_avg, _item_count\n    if _item_avg is None:\n        _item_avg = item\n        _item_count = 1\n    else:\n        _item_count += 1\n        _item_avg += (item - _item_avg) / _item_count\n    eps = 1e-12\n    rem = remaining[feasible]\n    # Base: inverse leftover weighted by tightness (prefers tighter fit)\n    base = 1.0 / (rem + eps)\n    tight = item / (item + rem + eps)\n    base *= tight\n    # Jitter magnitude grows with variance of remaining capacities and item deviation from average\n    var_rem = np.var(rem) if rem.size > 1 else 0.0\n    jitter_coeff = 0.005 * (1.0 + np.sqrt(var_rem))\n    jitter_adj = 1.0 + abs(item - _item_avg) / (_item_avg + eps)\n    jitter_scale = item * jitter_coeff * jitter_adj\n    rng = np.random.default_rng()\n    jitter = (rng.random(rem.size) - 0.5) * jitter_scale\n    # Tiny index bias for deterministic tie\u2011breaks\n    idx_bias = np.arange(n)[feasible] * 1e-6\n    priority[feasible] = base + jitter + idx_bias\n    return priority\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n_rng = np.random.default_rng()\n\n    \"\"\"Inverse leftover priority with variance\u2011scaled jitter and tiny variance penalty.\"\"\"\n    n = bins_remain_cap.size\n    if n == 0:\n        return np.empty(0, dtype=float)\n    remaining = bins_remain_cap - item\n    feasible = remaining >= 0\n    priority = np.full(n, -np.inf, dtype=float)\n    if not np.any(feasible):\n        return priority\n    eps = 1e-12\n    base = 1.0 / (remaining[feasible] + eps)\n    bias = -np.arange(n)[feasible] * 1e-6\n    var_rem = np.var(remaining[feasible])\n    jitter_scale = item * 0.01 * (1.0 + np.sqrt(var_rem))\n    jitter = (_rng.random(remaining[feasible].size) - 0.5) * jitter_scale\n    var_penalty = -((remaining[feasible] - remaining[feasible].mean())**2) * 1e-6\n    priority[feasible] = base + bias + jitter + var_penalty\n    return priority\n\n### Analyze & experience\n- - **Heuristic\u202f1 (best) vs Heuristic\u202f20 (worst):**\u202fHeuristic\u202f1 uses a clean inverse\u2011leftover score, a variance\u2011scaled jitter, and a tiny index bias \u2013 minimal, robust, and stateless.\u202fHeuristic\u202f20 adds a mean\u2011deviation penalty, extra jitter logic, and a placeholder comment, increasing code complexity and introducing aggressive bias that can hurt packing quality.  \n- **Heuristic\u202f2 (2nd) vs Heuristic\u202f19 (2nd\u2011worst):**\u202fHeuristic\u202f2 is identical to Heuristic\u202f1 (simple, effective).\u202fHeuristic\u202f19 contains only a skeleton with many hyper\u2011parameters and no scoring logic after the early\u2011return, thus providing no useful decision information.  \n- **Heuristic\u202f1 vs Heuristic\u202f2:**\u202fBoth are identical copies; their scores, jitter, and bias are exactly the same, confirming the top\u2011rank stability of this pattern.  \n- **Heuristic\u202f3 vs Heuristic\u202f4:**\u202fHeuristic\u202f3 remains the simple baseline.\u202fHeuristic\u202f4 introduces a running item\u2011average, a tightness factor, and jitter that adapts to the deviation from the average. This adds statefulness and extra computation, which can improve adaptivity on some instances but also creates overhead and potential drift.  \n- **Heuristic\u202f19 vs Heuristic\u202f20:**\u202fHeuristic\u202f19 is an incomplete placeholder (no functional scoring).\u202fHeuristic\u202f20, though fully implemented, adds a mean\u2011distance penalty that can over\u2011penalize feasible bins, making it less reliable than the baseline.\n- \n- **Keywords:** feasibility, inverse\u2011leftover, size\u2011scaled jitter; **Advice:** filter infeasible bins, score\u202f=\u202f1/(remaining+\u03b5)+\u03c3\u00b7itemSize\u00b7N(0,1); **Avoid:** fixed RNG seed, deterministic index bias; **Explanation:** keeps decisions stochastic yet capacity\u2011aware.  \n- **Keywords:** vectorized, minimal state; **Advice:** compute scores with NumPy broadcasting, early\u2011return on empty input; **Avoid:** per\u2011call RNG, mutable globals; **Explanation:** ensures speed and reproducibility.  \n- **Keywords:** tie\u2011break, tiny bias; **Advice:** add a 1e\u20119 constant when scores tie; **Avoid:** large deterministic offsets, over\u2011parameterisation; **Explanation:** gives reproducible tie\u2011breaks without biasing selection.  \n- **Keywords:** safeguards, docs; **Advice:** guard division with \u03b5, type\u2011hint returns, concise docstring; **Avoid:** missing edge\u2011cases, vague comments; **Explanation:** prevents runtime errors and aids maintenance.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}