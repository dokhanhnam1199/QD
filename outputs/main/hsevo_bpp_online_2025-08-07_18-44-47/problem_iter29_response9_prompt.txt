{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code only and do not add comments into the code. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n_rng = np.random.default_rng()\n\n# Priority: inverse leftover + variance\u2011scaled jitter + tiny index bias\n    \"\"\"Score bins by inverse leftover, jitter scaled with remaining variance, and tiny index bias.\"\"\"\n    n = bins_remain_cap.size\n    if n == 0:\n        return np.empty(0, dtype=float)\n    eps = 1e-12\n    remaining = bins_remain_cap - item\n    feasible = remaining >= 0\n    priority = np.full(n, -np.inf, dtype=float)\n    if not feasible.any():\n        return priority\n    base = 1.0 / (remaining[feasible] + eps)\n    bias = -np.arange(n)[feasible] * 1e-6\n    var_rem = np.var(remaining[feasible])\n    jitter_scale = item * 0.01 * (1.0 + np.sqrt(var_rem))\n    jitter = (_rng.random(remaining.shape)[feasible] - 0.5) * jitter_scale\n    priority[feasible] = base + bias + jitter\n    return priority\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Best\u2011fit with variance\u2011scaled jitter and tiny index bias for tie\u2011breaking.\"\"\"\n    rng = np.random.default_rng()\n    eps = 1e-12\n    bins = np.asarray(bins_remain_cap, dtype=float)\n    n = bins.size\n    if n == 0:\n        return np.empty(0, dtype=float)\n\n    # remaining capacity after placing the item\n    remaining = bins - item\n    feasible = remaining >= 0\n    priority = np.full(n, -np.inf, dtype=float)\n    if not feasible.any():\n        return priority\n\n    # primary: inverse leftover (tighter fit gets higher score)\n    base = 1.0 / (remaining[feasible] + eps)\n\n    # deterministic tie\u2011breaker: tiny bias toward earlier bins\n    bias = -np.arange(n)[feasible] * 1e-6\n\n    # random jitter scaled by item size and variance of feasible leftovers\n    var_rem = np.var(remaining[feasible])\n    jitter_scale = item * 0.01 * (1.0 + np.sqrt(var_rem))\n    jitter = (rng.random(remaining.shape)[feasible] - 0.5) * jitter_scale\n\n    # mild penalty for bins far from the mean remaining capacity\n    mean_rem = np.mean(remaining[0] if False else remaining[feasible])  # placeholder for readability\n    penalty = -((remaining[feasible] - mean_rem) ** 2) * 1e-5\n\n    # combine all components\n    priority[feasible] = base + bias + jitter + penalty\n    return priority\n\n### Analyze & experience\n- - **Heuristic\u202f1 (best) vs Heuristic\u202f20 (worst):**\u202fHeuristic\u202f1 uses a clean inverse\u2011leftover score, a variance\u2011scaled jitter, and a tiny index bias \u2013 minimal, robust, and stateless.\u202fHeuristic\u202f20 adds a mean\u2011deviation penalty, extra jitter logic, and a placeholder comment, increasing code complexity and introducing aggressive bias that can hurt packing quality.  \n- **Heuristic\u202f2 (2nd) vs Heuristic\u202f19 (2nd\u2011worst):**\u202fHeuristic\u202f2 is identical to Heuristic\u202f1 (simple, effective).\u202fHeuristic\u202f19 contains only a skeleton with many hyper\u2011parameters and no scoring logic after the early\u2011return, thus providing no useful decision information.  \n- **Heuristic\u202f1 vs Heuristic\u202f2:**\u202fBoth are identical copies; their scores, jitter, and bias are exactly the same, confirming the top\u2011rank stability of this pattern.  \n- **Heuristic\u202f3 vs Heuristic\u202f4:**\u202fHeuristic\u202f3 remains the simple baseline.\u202fHeuristic\u202f4 introduces a running item\u2011average, a tightness factor, and jitter that adapts to the deviation from the average. This adds statefulness and extra computation, which can improve adaptivity on some instances but also creates overhead and potential drift.  \n- **Heuristic\u202f19 vs Heuristic\u202f20:**\u202fHeuristic\u202f19 is an incomplete placeholder (no functional scoring).\u202fHeuristic\u202f20, though fully implemented, adds a mean\u2011distance penalty that can over\u2011penalize feasible bins, making it less reliable than the baseline.\n- \n- **Keywords:** feasibility, inverse\u2011leftover, size\u2011scaled jitter; **Advice:** filter infeasible bins, score\u202f=\u202f1/(remaining+\u03b5)+\u03c3\u00b7itemSize\u00b7N(0,1); **Avoid:** fixed RNG seed, deterministic index bias; **Explanation:** keeps decisions stochastic yet capacity\u2011aware.  \n- **Keywords:** vectorized, minimal state; **Advice:** compute scores with NumPy broadcasting, early\u2011return on empty input; **Avoid:** per\u2011call RNG, mutable globals; **Explanation:** ensures speed and reproducibility.  \n- **Keywords:** tie\u2011break, tiny bias; **Advice:** add a 1e\u20119 constant when scores tie; **Avoid:** large deterministic offsets, over\u2011parameterisation; **Explanation:** gives reproducible tie\u2011breaks without biasing selection.  \n- **Keywords:** safeguards, docs; **Advice:** guard division with \u03b5, type\u2011hint returns, concise docstring; **Avoid:** missing edge\u2011cases, vague comments; **Explanation:** prevents runtime errors and aids maintenance.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}