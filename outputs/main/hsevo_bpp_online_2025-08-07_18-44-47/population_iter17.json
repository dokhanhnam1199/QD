[
  {
    "stdout_filepath": "problem_iter17_response0.txt_stdout.txt",
    "code_path": "problem_iter17_code0.py",
    "code": "import numpy as np\n\n_rng = np.random.default_rng(42)\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Priority: inverse leftover + index bias + deterministic golden ratio jitter + reproducible random jitter scaled by item size and remaining capacity.\"\"\"\n    n = bins_remain_cap.size\n    if n == 0:\n        return np.empty(0, dtype=float)\n    eps = 1e-9\n    remaining = bins_remain_cap - item\n    feasible = remaining >= 0\n    priority = np.full(n, -np.inf, dtype=float)\n    priority[feasible] = 1.0 / (remaining[feasible] + eps)\n    priority[feasible] -= np.arange(n, dtype=float)[feasible] * 1e-5\n    phi = 0.6180339887498949\n    jitter_det = np.mod(phi * (np.arange(n) + 1) * item, 1.0) * 0.01 * item\n    jitter_rand = _rng.random(n) * 0.01 * item * (remaining + eps) / (bins_remain_cap.max() + eps)\n    priority[feasible] += jitter_det[feasible] + jitter_rand[feasible]\n    return priority",
    "response_id": 0,
    "tryHS": false,
    "obj": 80.56441962504988,
    "SLOC": 15.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter17_response1.txt_stdout.txt",
    "code_path": "problem_iter17_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Score bins by inverse leftover, variance penalty, and jitter scaled to remaining.\n    \"\"\"\n    n = bins_remain_cap.size\n    if n == 0:\n        return np.empty(0, dtype=float)\n    remaining = bins_remain_cap - item\n    feasible = remaining >= 0\n    priority = np.full(n, -np.inf, dtype=float)\n    if not np.any(feasible):\n        return priority\n    # Inverse leftover prioritizes bins with smallest remaining\n    base = 1.0 / remaining[feasible]\n    # Variance penalty prefers bins whose remaining is near the mean\n    mean_rem = remaining[feasible].mean()\n    var_penalty = - (remaining[feasible] - mean_rem)**2 * 1e-3\n    # Random jitter scaled to remaining capacity for tie\u2011breaking\n    rng = np.random.default_rng()\n    jitter = rng.normal(loc=0.0, scale=remaining[feasible] * 0.01)\n    priority[feasible] = base + var_penalty + jitter\n    return priority",
    "response_id": 1,
    "tryHS": false,
    "obj": 81.93059433585961,
    "SLOC": 16.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter17_response2.txt_stdout.txt",
    "code_path": "problem_iter17_code2.py",
    "code": "import numpy as np\n\n# Module\u2011level RNG for reproducible pseudo\u2011random jitter\n_rng = np.random.default_rng(42)\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Inverse leftover priority with tiny index bias, small deterministic sinusoid,\n    and reproducible jitter.\n    \"\"\"\n    n = bins_remain_cap.size\n    if n == 0:\n        return np.empty(0, dtype=float)\n    eps = 1e-9\n    remaining = bins_remain_cap - item\n    feasible = remaining >= 0\n    priority = np.full(n, -np.inf, dtype=float)\n    if not np.any(feasible):\n        return priority\n    indices = np.arange(n)\n    base = 1.0 / (remaining[feasible] + eps)\n    bias = -indices[feasible] * 1e-5\n    jitter = _rng.random(n)[feasible] * 0.01 * item\n    det_jitter = (np.sin((item + indices[feasible]) * 7.0) + 1) * 0.5 * 1e-9 * item\n    priority[feasible] = base + bias + jitter + det_jitter\n    return priority",
    "response_id": 2,
    "tryHS": false,
    "obj": 3.131232548863192,
    "SLOC": 17.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter17_response3.txt_stdout.txt",
    "code_path": "problem_iter17_code3.py",
    "code": "import numpy as np\n\n_rng = np.random.default_rng(12345)\n_item_counter = 0\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Priority combining inverse leftover, deterministic jitter, and Gumbel noise with decaying temperature.\n    \"\"\"\n    bins = np.asarray(bins_remain_cap, dtype=float)\n    n = bins.size\n    if n == 0:\n        return np.empty(0, dtype=float)\n    global _item_counter\n    _item_counter += 1\n    remaining = bins - item\n    feasible = remaining >= 0\n    priority = np.full(n, -np.inf, dtype=float)\n    eps = 1e-9\n    primary = 1.0 / (remaining + eps)\n    idx = np.arange(n, dtype=float)\n    bias = -idx * 1e-6\n    phi = 0.6180339887498949\n    golden = ((phi * (idx + 1) * item) % 1.0) * 1e-6 * item\n    sin_j = (np.sin((item + idx) * 7.0) + 1) * 0.5 * 1e-9 * item\n    rand = _rng.random(n) * 0.01 * item\n    score = primary + bias + golden + sin_j + rand\n    temp = max(0.05, 0.5 * np.exp(-0.001 * _item_counter))\n    gumb = -np.log(-np.log(_rng.random(feasible.sum())))\n    score[feasible] += gumb / temp\n    priority[feasible] = score[feasible]\n    return priority",
    "response_id": 3,
    "tryHS": false,
    "obj": 35.71001196649383,
    "SLOC": 24.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter17_response4.txt_stdout.txt",
    "code_path": "problem_iter17_code4.py",
    "code": "import numpy as np\n\n_rng = np.random.default_rng(42)\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    n = bins_remain_cap.size\n    if n == 0:\n        return np.empty(0, dtype=float)\n    remaining = bins_remain_cap - item\n    feasible = remaining >= 0\n    priority = np.full(n, -np.inf, dtype=float)\n    if np.any(feasible):\n        eps = 1e-9\n        base = 1.0 / (remaining[feasible] + eps)\n        idx = np.arange(n)\n        bias = -idx[feasible] * 1e-5\n        phi = 0.6180339887498949\n        det_jitter = (np.mod(phi * (idx[feasible] + 1) * item, 1.0) - 0.5) * 1e-5 * item\n        sin_jitter = np.sin(item * idx[feasible] + 1.0) * 1e-9 * item\n        jitter_scale = 1e-5 * item\n        rng_jitter = _rng.standard_normal(feasible.sum()) * jitter_scale\n        priority[feasible] = base + bias + det_jitter + sin_jitter + rng_jitter\n    return priority",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 19.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter17_response5.txt_stdout.txt",
    "code_path": "problem_iter17_code5.py",
    "code": "import numpy as np\n\n# Combine inverse\u2011leftover, index bias, golden\u2011ratio deterministic jitter, and load\u2011scaled random jitter.\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Score bins for online BPP using inverse leftover, tiny index bias, deterministic golden\u2011ratio jitter, and random jitter scaled by bin load.\"\"\"\n    caps = np.asarray(bins_remain_cap, dtype=float)\n    n = caps.size\n    if n == 0:\n        return np.empty(0, dtype=float)\n    eps = 1e-12\n    remaining = caps - item\n    feasible = remaining >= 0\n    priority = np.full(n, -np.inf, dtype=float)\n    if not np.any(feasible):\n        return priority\n    idx = np.arange(n, dtype=float)\n    base = 0.0\n    base = 1.0 / (remaining[feasible] + eps)\n    bias = idx[feasible] * 1e-6\n    phi = 0.6180339887498949\n    det_jitter = np.mod(phi * (idx[feasible] + 1) * item, 1.0) * 0.01 * item\n    m = feasible.sum()\n    rng = np.random.default_rng()\n    load_scale = remaining[feasible] / (remaining[feasible].max() + eps)\n    rand_jitter = rng.random(m) * 0.005 * item * load_scale\n    priority[feasible] = base - bias + det_jitter + rand_jitter\n    return priority",
    "response_id": 5,
    "tryHS": false,
    "obj": 82.77822098125252,
    "SLOC": 23.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter17_response6.txt_stdout.txt",
    "code_path": "problem_iter17_code6.py",
    "code": "import numpy as np\n\n_rng = np.random.default_rng(42)\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Score bins using inverse leftover, index bias, sinusoidal jitter, and reproducible random noise.\"\"\"\n    n = bins_remain_cap.size\n    if n == 0:\n        return np.empty(0, dtype=float)\n    eps = 1e-9\n    remaining = bins_remain_cap - item\n    feasible = remaining >= 0\n    priority = np.full(n, -np.inf, dtype=float)\n    priority[feasible] = 1.0 / (remaining[feasible] + eps)\n    priority[feasible] -= np.arange(n)[feasible] * 1e-5\n    sin_jitter = np.sin((item + np.arange(n)) * 0.01)\n    priority[feasible] += sin_jitter[feasible] * 1e-7\n    priority[feasible] += _rng.random(n)[feasible] * 0.01 * item\n    return priority",
    "response_id": 6,
    "tryHS": false,
    "obj": 3.1013163143199183,
    "SLOC": 14.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter17_response7.txt_stdout.txt",
    "code_path": "problem_iter17_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Score bins using inverse\u2011leftover (primary), deterministic golden\u2011ratio + sinusoidal jitter,\n    per\u2011call random jitter, and a variance\u2011balancing penalty.\"\"\"\n    caps = np.asarray(bins_remain_cap, dtype=float)\n    n = caps.size\n    if n == 0:\n        return np.empty(0, dtype=float)\n    remaining = caps - item\n    feasible = remaining >= 0\n    priority = np.full(n, -np.inf, dtype=float)\n    if not np.any(feasible):\n        return priority\n    eps = 1e-12\n    inv_left = 1.0 / (remaining[feasible] + eps)\n    idx = np.arange(n, dtype=float)[feasible]\n    phi = 0.6180339887498949\n    jitter_det = ((phi * (idx + 1) * item) % 1.0) * 0.01 * item\n    sinus_jitter = np.sin(2 * np.pi * idx / n) * 1e-4 * item\n    rng = np.random.default_rng()\n    jitter_rand = rng.random(idx.shape) * 0.001 * item\n    mean_rem = remaining[feasible].mean()\n    var_penalty = 0.1 * ((remaining[feasible] - mean_rem) ** 2) / (caps.mean() + eps)\n    # combine all components\n    priority[feasible] = inv_left + jitter_det + sinus_jitter + jitter_rand - var_penalty\n    return priority",
    "response_id": 7,
    "tryHS": false,
    "obj": 40.86557638611886,
    "SLOC": 22.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter17_response8.txt_stdout.txt",
    "code_path": "problem_iter17_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, rng_seed: int = None) -> np.ndarray:\n    \"\"\"Heuristic using inverse leftover, index bias, golden\u2011ratio jitter, adaptive random jitter, deterministic tie\u2011breaker.\"\"\"\n    n = bins_remain_cap.size\n    if n == 0:\n        return np.empty(0, dtype=float)\n    remaining = bins_remain_cap - item\n    feasible = remaining >= 0\n    priority = np.full(n, -np.inf, dtype=float)\n    if not np.any(feasible):\n        return priority\n    eps = 1e-9\n    idx = np.arange(n)\n    priority[feasible] = 1.0 / (remaining[feasible] + eps)\n    priority[feasible] -= idx[feasible] * 1e-5\n    phi = 0.6180339887498949\n    golden_jitter = np.mod(idx * phi + item, 1.0) * 0.01\n    priority[feasible] += golden_jitter[feasible]\n    rng = np.random.default_rng(rng_seed)\n    max_cap = bins_remain_cap.max()\n    rand_vals = rng.random(n) * 0.01 * item * (remaining + eps) / (max_cap + eps)\n    priority[feasible] += rand_vals[feasible]\n    deterministic_jitter = ((idx * 31 + int(item * 1e6)) % 1000) * 1e-15\n    priority[feasible] += deterministic_jitter[feasible]\n    return priority",
    "response_id": 8,
    "tryHS": false,
    "obj": 78.48025528520144,
    "SLOC": 23.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter17_response9.txt_stdout.txt",
    "code_path": "problem_iter17_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Score bins for online bin packing: inverse leftover, tiny index bias, deterministic golden\u2011ratio jitter, random jitter scaled by remaining capacity, and mean\u2011centered load term for balanced utilization.\"\"\"\n    caps = np.asarray(bins_remain_cap, dtype=float)\n    n = caps.size\n    if n == 0:\n        return np.empty(0, dtype=float)\n    eps = 1e-9\n    remaining = caps - item\n    feasible = remaining >= 0\n    priority = np.full(n, -np.inf, dtype=float)\n    if not feasible.any():\n        return priority\n    idx = np.arange(n, dtype=float)\n    base = 1.0 / (remaining[feasible] + eps)\n    bias = idx[feasible] * 1e-6\n    phi = 0.6180339887498949\n    jitter_det = np.mod(phi * (idx[feasible] + 1) * item, 1.0) * 0.01 * item\n    rng = np.random.default_rng()\n    jitter_rand = rng.random(feasible.sum()) * 0.005 * remaining[feasible]\n    mean_center = (caps.mean() - caps[feasible]) * 0.001\n    priority[feasible] = base - bias + jitter_det + jitter_rand + mean_center\n    return priority",
    "response_id": 9,
    "tryHS": false,
    "obj": 82.03031511767054,
    "SLOC": 21.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  }
]