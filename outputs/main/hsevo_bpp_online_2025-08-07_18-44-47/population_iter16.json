[
  {
    "stdout_filepath": "problem_iter14_response0.txt_stdout.txt",
    "code_path": "problem_iter14_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines inverse leftover, index bias, random jitter, golden\u2011ratio and sinusoidal tie\u2011breakers for bin priority.\n    \"\"\"\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)\n    n = bins_remain_cap.size\n    if n == 0:\n        return np.empty(0, dtype=float)\n    eps = 1e-9\n    remaining = bins_remain_cap - item\n    feasible = remaining >= 0\n    priority = np.full(n, -np.inf, dtype=float)\n    idx = np.arange(n, dtype=float)\n    primary = 1.0 / (remaining + eps)\n    bias = -idx * 1e-6\n    rng = np.random.default_rng()\n    random_jitter = rng.random(n) * 0.01 * item\n    phi = 0.6180339887498949\n    golden_jitter = ((phi * (idx + 1) * item) % 1.0) * 1e-6 * item\n    sin_jitter = (np.sin((item + idx) * 7.0) + 1) * 0.5 * 1e-9 * item\n    priority[feasible] = primary[feasible] + bias[feasible] + random_jitter[feasible] + golden_jitter[feasible] + sin_jitter[feasible]\n    return priority",
    "response_id": 0,
    "tryHS": false,
    "obj": 3.131232548863192,
    "SLOC": 19.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response1.txt_stdout.txt",
    "code_path": "problem_iter14_code1.py",
    "code": "# Heuristic for online bin packing priorities: inverse leftover, index bias, adaptive jitter, deterministic tie\u2011breaker.\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, rng_seed: int = None,\n                epsilon: float = 1e-9, index_weight: float = 1e-5,\n                jitter_factor: float = 0.01, deterministic_factor: float = 1e-15) -> np.ndarray:\n    \"\"\"This heuristic uses the inverse leftover as the primary score, a small negative index bias, adaptive random jitter scaled by item size and leftover ratio, and a deterministic tiny tie\u2011breaker for stable ranking.\"\"\"\n    n = bins_remain_cap.size\n    if n == 0:\n        return np.empty(0, dtype=float)\n    remaining = bins_remain_cap - item\n    feasible = remaining >= 0\n    priority = np.full(n, -np.inf, dtype=float)\n    priority[feasible] = 1.0 / (remaining[feasible] + epsilon)\n    priority[feasible] -= np.arange(n)[feasible] * index_weight\n    rng = np.random.default_rng(rng_seed) if rng_seed is not None else np.random.default_rng()\n    if np.any(feasible):\n        max_cap = bins_remain_cap.max()\n        jitter_vals = rng.random(np.count_nonzero(feasible)) * jitter_factor * ((remaining[feasible] + epsilon) / (max_cap + epsilon))\n        priority[feasible] += jitter_vals\n    deterministic_jitter = ((np.arange(n) * 31 + int(item * 1e6)) % 1000) * deterministic_factor\n    priority[feasible] += deterministic_jitter[feasible]\n    return priority",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 19.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response2.txt_stdout.txt",
    "code_path": "problem_iter14_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Compute bin priorities using inverse leftover, index bias, deterministic golden\u2011ratio jitter and adaptive random jitter.\"\"\"\n    caps = np.asarray(bins_remain_cap, dtype=float)\n    n = caps.size\n    if n == 0:\n        return np.empty(0, dtype=float)\n    eps = 1e-9\n    remaining = caps - item\n    feasible = remaining >= 0\n    priority = np.full(n, -np.inf, dtype=float)\n    priority[feasible] = 1.0 / (remaining[feasible] + eps)\n    idx = np.arange(n, dtype=float)\n    priority[feasible] -= idx[feasible] * 1e-5\n    phi = 0.6180339887498949\n    jitter_det = np.mod(phi * (idx + 1) * item, 1.0) * 0.01 * item\n    priority[feasible] += jitter_det[feasible]\n    max_cap = caps.max()\n    rng = np.random.default_rng()\n    jitter_rand = rng.random(n) * 0.01 * item * (remaining + eps) / (max_cap + eps)\n    priority[feasible] += jitter_rand[feasible]\n    return priority",
    "response_id": 2,
    "tryHS": false,
    "obj": 80.64419625049861,
    "SLOC": 20.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response3.txt_stdout.txt",
    "code_path": "problem_iter14_code3.py",
    "code": "import numpy as np\n\n_rng = np.random.default_rng(42)\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    n = bins_remain_cap.size\n    if n == 0:\n        return np.empty(0, dtype=float)\n    eps = 1e-9\n    remaining = bins_remain_cap - item\n    feasible = remaining >= 0\n    priority = np.full(n, -np.inf, dtype=float)\n    if not np.any(feasible):\n        return priority\n    indices = np.arange(n)\n    base = 1.0 / (remaining[feasible] + eps)\n    bias = -indices[feasible] * 1e-5\n    jitter = _rng.random(n)[feasible] * 0.01 * item\n    det_jitter = (np.sin((item + indices[feasible]) * 7.0) + 1) * 0.5 * 1e-9 * item\n    priority[feasible] = base + bias + jitter + det_jitter\n    return priority",
    "response_id": 3,
    "tryHS": false,
    "obj": 3.131232548863192,
    "SLOC": 17.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response4.txt_stdout.txt",
    "code_path": "problem_iter14_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Inverse leftover with bias, deterministic and reproducible jitter.\"\"\"\n    n = bins_remain_cap.size\n    if n == 0:\n        return np.empty(0, dtype=float)\n    eps = 1e-9\n    remaining = bins_remain_cap - item\n    feasible = remaining >= 0\n    priority = np.full(n, -np.inf, dtype=float)\n    idx = np.arange(n)\n    base = 1.0 / (remaining[feasible] + eps)\n    bias_factor = 1e-5\n    bias = -idx[feasible] * bias_factor\n    phi = 0.6180339887498949\n    jitter_factor = 1e-5\n    det_jitter = (np.mod(phi * (idx[feasible] + 1) * item, 1.0) - 0.5) * jitter_factor * item\n    rnd_factor = 1e-5\n    rnd_jitter = (np.sin(item * 12.9898 + idx[feasible] * 78.233) * 43758.5453 % 1.0 - 0.5) * rnd_factor * item\n    priority[feasible] = base + bias + det_jitter + rnd_jitter\n    return priority",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 19.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response5.txt_stdout.txt",
    "code_path": "problem_iter14_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Score bins by inverse leftover, index bias, deterministic golden\u2011ratio jitter, and random noise.\"\"\"\n    caps = np.asarray(bins_remain_cap, dtype=float)\n    n = caps.size\n    if n == 0:\n        return np.empty(0, dtype=float)\n    eps = 1e-9\n    remaining = caps - item\n    feasible = remaining >= 0\n    priority = np.full(n, -np.inf, dtype=float)\n    if not np.any(feasible):\n        return priority\n    inv_leftover = 1.0 / (remaining[feasible] + eps)\n    idx = np.arange(n, dtype=float)\n    bias = idx[feasible] * 1e-6\n    phi = 0.6180339887498949\n    jitter_det = np.mod(phi * (idx[feasible] + 1) * item, 1.0) * 0.01 * item\n    jitter_rand = np.random.random(feasible.sum()) * 0.001 * item\n    priority[feasible] = inv_leftover - bias + jitter_det + jitter_rand\n    return priority",
    "response_id": 5,
    "tryHS": false,
    "obj": 3.370562425209409,
    "SLOC": 19.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response6.txt_stdout.txt",
    "code_path": "problem_iter14_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Inverse leftover, low-index bias, deterministic sinusoidal jitter, and item\u2011scaled pseudo\u2011random jitter.\"\"\"\n    n = bins_remain_cap.size\n    if n == 0:\n        return np.empty(0, dtype=float)\n    eps = 1e-9\n    remaining = bins_remain_cap - item\n    feasible = remaining >= 0\n    priority = np.full(n, -np.inf, dtype=float)\n    if not np.any(feasible):\n        return priority\n    indices = np.arange(n)\n    primary = 1.0 / (remaining[feasible] + eps)\n    bias = -indices[feasible] * 1e-6\n    det_jitter = ((np.sin((item + indices[feasible]) * 7.0) + 1) * 0.5) * 1e-9 * item\n    int_item = int(item * 1e6)\n    # compute deterministic pseudo\u2011random jitter\n    pseudo = ((int_item + 31 * indices[feasible] + 7) % 2147483647) / 2147483647.0\n    rand_jitter = pseudo * 0.01 * item\n    priority[feasible] = primary + bias + det_jitter + rand_jitter\n    return priority",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 19.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response7.txt_stdout.txt",
    "code_path": "problem_iter14_code7.py",
    "code": "import numpy as np\n\n_rng = np.random.default_rng()\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Score bins by inverse leftover, with deterministic and stochastic jitter.\"\"\"\n    # Inverse remaining capacity encourages tight packing; jitter breaks ties.\n    n = bins_remain_cap.size\n    if n == 0:\n        return np.empty(0, dtype=float)\n    eps = 1e-12\n    remaining = bins_remain_cap - item\n    feasible = remaining >= 0\n    priority = np.full(n, -np.inf, dtype=float)\n    if not np.any(feasible):\n        return priority\n    inv = 1.0 / (remaining[feasible] + eps)\n    idx = np.arange(n)[feasible]\n    det_jitter = ((idx * 31 + int(item * 1e6)) % 1000) * 1e-15\n    jitter = _rng.random(feasible.sum()) * 0.01 * item\n    priority[feasible] = inv + jitter + det_jitter\n    return priority",
    "response_id": 7,
    "tryHS": true,
    "obj": 3.1212604706820857,
    "SLOC": 16.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response8.txt_stdout.txt",
    "code_path": "problem_iter14_code8.py",
    "code": "import numpy as np\n\n_item_counter = 0\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Priority based on leftover capacity with Gumbel temperature decay, item-size jitter, and deterministic index tie\u2011breaker.\"\"\"\n    global _item_counter\n    _item_counter += 1\n    bins = np.asarray(bins_remain_cap, dtype=float)\n    n = bins.size\n    priority = np.full(n, -np.inf, dtype=float)\n    if n == 0:\n        return priority\n    remaining = bins - item\n    feasible = remaining >= 0\n    if not np.any(feasible):\n        return priority\n    eps = 1e-12\n    base_temp = 0.5\n    decay = 0.001\n    temp = max(0.05, base_temp * np.exp(-decay * _item_counter))\n    rng = np.random.default_rng()\n    gumbel = -np.log(-np.log(rng.random(feasible.sum())))\n    idx = np.arange(n)\n    jitter = rng.random(feasible.sum()) * 0.01 * item\n    priority[feasible] = -remaining[feasible] / temp + gumbel + jitter + idx[feasible] * 1e-12 - idx[feasible] * 1e-6\n    return priority",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 22.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response9.txt_stdout.txt",
    "code_path": "problem_iter14_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Score bins by inverse leftover, low-index bias, deterministic golden\u2011ratio jitter, and small random jitter.\"\"\"\n    caps = np.asarray(bins_remain_cap, dtype=float)\n    n = caps.size\n    if n == 0:\n        return np.empty(0, dtype=float)\n    eps = 1e-12\n    remaining = caps - item\n    feasible = remaining >= 0\n    priority = np.full(n, -np.inf, dtype=float)\n    if not np.any(feasible):\n        return priority\n    idx = np.arange(n, dtype=float)\n    base = 1.0 / (remaining[feasible] + eps)\n    bias = idx[feasible] * 1e-5\n    phi = 0.6180339887498949\n    jitter_det = np.mod(phi * (idx[feasible] + 1) * item, 1.0) * 0.01 * item\n    jitter_rand = np.random.random(feasible.sum()) * 0.001 * item\n    priority[feasible] = base - bias + jitter_det + jitter_rand\n    return priority",
    "response_id": 9,
    "tryHS": false,
    "obj": 3.430394894295981,
    "SLOC": 19.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter15_response0.txt_stdout.txt",
    "code_path": "problem_iter15_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    remaining = bins_remain_cap - item\n    feasible = remaining >= 0\n    priority = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    if np.any(feasible):\n        eps = 1e-12\n        base = 1.0 / (remaining[feasible] + eps)\n        rng = np.random.default_rng()\n        jitter_scale = 0.01 * item\n        jitter = rng.standard_normal(remaining[feasible].size) * jitter_scale\n        deterministic_term = remaining[feasible] * 1e-12\n        priority[feasible] = base + jitter + deterministic_term\n    return priority",
    "response_id": 0,
    "tryHS": false,
    "obj": 32.100119664938184,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter16_response0.txt_stdout.txt",
    "code_path": "problem_iter16_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float,\n                bins_remain_cap: np.ndarray,\n                eps: float = 8.555213927169448e-10,\n                det_jitter_mul: float = 5.024821511498017,\n                det_jitter_mod: float = 3413.441477351962,\n                det_jitter_scale: float = 3.84814226817756e-13,\n                jitter_scale: float = 0.00861802019669008,\n                item_scaling_factor: float = 6334655.964217664) -> np.ndarray:\n    \"\"\"Score bins by inverse leftover, with deterministic and stochastic jitter.\"\"\"\n    n = bins_remain_cap.size\n    if n == 0:\n        return np.empty(0, dtype=float)",
    "response_id": 0,
    "tryHS": true,
    "obj": 4.487435181491823,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  }
]