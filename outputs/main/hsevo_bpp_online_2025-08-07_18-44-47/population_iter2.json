[
  {
    "stdout_filepath": "problem_iter2_response0.txt_stdout.txt",
    "code_path": "problem_iter2_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    epsilon = 1e-9\n    leftover = bins_remain_cap - item\n    fit = bins_remain_cap >= item\n    base = np.where(fit, 1.0/(leftover+epsilon), -np.inf)\n    noise = np.random.rand(len(bins_remain_cap)) * 0.1 * item\n    priorities = base + noise\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.228161148783416,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response1.txt_stdout.txt",
    "code_path": "problem_iter2_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    EPSILON = 0.1\n    SMALL_EPS = 1e-6\n    RANDOM_NOISE = 0.01\n    feasible = bins_remain_cap >= item\n    residual = bins_remain_cap - item\n    deterministic = np.where(feasible, 1.0 / (residual + SMALL_EPS), -np.inf)\n    deterministic += np.where(feasible, np.random.rand(*bins_remain_cap.shape) * RANDOM_NOISE, 0)\n    random_scores = np.where(feasible, np.random.rand(*bins_remain_cap.shape), -np.inf)\n    return random_scores if np.random.rand() < EPSILON else deterministic",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.11846828879138,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response2.txt_stdout.txt",
    "code_path": "problem_iter2_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Score bins: inverse residual capacity with tiny random tie\u2011breaker; infeasible \u2192 -inf.\"\"\"\n    priors = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        return priors\n    residual = bins_remain_cap[feasible] - item\n    epsilon = 1e-9\n    base = 1.0 / (residual + epsilon)\n    rng = np.random.default_rng()\n    noise = rng.random(base.shape) * 1e-6\n    priors[feasible] = base + noise\n    return priors",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response3.txt_stdout.txt",
    "code_path": "problem_iter2_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Inverse leftover capacity with tiny random tie\u2011breakers; infeasible bins get -inf.\"\"\"\n    if bins_remain_cap.size == 0:\n        return np.empty_like(bins_remain_cap, dtype=float)\n    residual = bins_remain_cap - item\n    eps = 1e-6\n    noise = np.random.rand(bins_remain_cap.size) * 0.01 * item\n    return np.where(residual >= 0, 1.0 / (residual + eps) + noise, -np.inf)",
    "response_id": 3,
    "tryHS": false,
    "obj": 3.1013163143199183,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response4.txt_stdout.txt",
    "code_path": "problem_iter2_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Priority based on inverse leftover capacity plus small random noise to break ties; infeasible bins are -inf.\"\"\"\n    fit = bins_remain_cap >= item\n    if fit.any():\n        left = bins_remain_cap - item\n        epsilon = 1e-6\n        inv_left = 1.0/(left[fit] + epsilon)\n        noise = np.random.rand(np.count_nonzero(fit)) * 0.1 * item\n        priorities = np.full(bins_remain_cap.shape, -np.inf, dtype=float)\n        priorities[fit] = inv_left + noise\n    else:\n        priorities = np.full(bins_remain_cap.shape, -np.inf, dtype=float)\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 3.9888312724371757,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response5.txt_stdout.txt",
    "code_path": "problem_iter2_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Inverse\u2011leftover priority with tiny random tie\u2011breaker.\"\"\"\n    # Use inverse leftover priority; small random noise breaks ties\n    if bins_remain_cap.size == 0:\n        return bins_remain_cap\n    eps = 1e-12\n    fits = bins_remain_cap >= item\n    leftover = bins_remain_cap - item\n    inv = 1.0 / (leftover + eps)\n    tie = np.random.rand(len(bins_remain_cap)) * 1e-6 * item\n    priorities = np.where(fits, inv + tie, -np.inf)\n    return priorities",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response6.txt_stdout.txt",
    "code_path": "problem_iter2_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Inverse leftover score with tiny random jitter for tie-breaking.\"\"\"\n    eps = 1e-9\n    residual = bins_remain_cap - item\n    feasible = residual >= 0\n    score = np.where(feasible, 1.0 / (residual + eps), -np.inf)\n    jitter = np.random.random(bins_remain_cap.shape) * 1e-6\n    return score + jitter",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response7.txt_stdout.txt",
    "code_path": "problem_iter2_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Inverse leftover score with tiny random tie\u2011breaker; infeasible bins get -inf.\"\"\"\n    # Combine inverse-remaining-capacity scoring with stochastic tie\u2011breaking.\n    if bins_remain_cap.size == 0:\n        return np.array([], dtype=float)\n    eps = 1e-9\n    noise_factor = 1e-3\n    leftover = bins_remain_cap - item\n    feasible = leftover >= 0\n    base = np.where(feasible, 1.0 / (leftover + eps), -np.inf)\n    noise = np.random.rand(bins_remain_cap.shape[0]) * noise_factor * item\n    return np.where(feasible, base + noise, -np.inf)",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.27802153968888,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response8.txt_stdout.txt",
    "code_path": "problem_iter2_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.1) -> np.ndarray:\n    \"\"\"Score bins: high if item fits tightly, small random tie\u2011breaker.\"\"\"\n    caps = np.asarray(bins_remain_cap, dtype=float)\n    priorities = np.full_like(caps, -np.inf, dtype=float)\n    feasible = caps >= item\n    if not np.any(feasible):\n        return priorities\n    leftover = caps[feasible] - item\n    # deterministic: inverse leftover (tight fit) yields higher score\n    deterministic = 1.0 / (leftover + 1e-12)\n    # random perturbation for exploration/tie\u2011breaking\n    random_score = np.random.rand(np.count_nonzero(feasible))\n    priorities[feasible] = (1 - epsilon) * deterministic + epsilon * random_score\n    return priorities",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.178300757877951,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response9.txt_stdout.txt",
    "code_path": "problem_iter2_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines almost-full-fit priority (1/(remaining+eps)) with small random perturbation and bin-index tie-breaker for deterministic yet exploratory bin selection.\n    \"\"\"\n    n = bins_remain_cap.size\n    if n == 0:\n        return np.empty(0, dtype=float)\n    eps = 1e-9\n    remaining = bins_remain_cap - item\n    feasible = remaining >= 0\n    priority = np.full(n, -np.inf, dtype=float)\n    priority[feasible] = 1.0 / (remaining[feasible] + eps)\n    noise = np.random.rand(n) * 0.01 * item\n    tie_break = -np.arange(n) * 1e-5\n    priority[feasible] += noise[feasible] + tie_break[feasible]\n    return priority",
    "response_id": 9,
    "tryHS": false,
    "obj": 3.1611487834064667,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  }
]