```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Compute bin scores using inverse leftover, small index bias, sinusoidal and golden‑ratio jitters, and an adaptive random term scaled by item size and remaining‑capacity variance."""
    n = bins_remain_cap.size
    if n == 0:
        return np.empty(0, dtype=float)
    eps = 1e-9
    remaining = bins_remain_cap - item
    feasible = remaining >= 0
    priority = np.full(n, -np.inf, dtype=float)
    idx = np.arange(n, dtype=float)
    base = 1.0 / (remaining[feasible) + eps])
    bias = idx * 1e-5
    sin_jitter = np.sin((item + idx) * 0.01) * 1e-7
    phi = 0.6180339887498949
    phi_jitter = np.mod(phi * (idx + 1) * item, 1.0) * 0.01 * item
    std_rem = np.std(remaining) if n > 1 else 0.0
    mean_cap = np.mean(bins_remain_cap) + eps
    adaptive_weight = 0.01 * item * (std_rem / mean_cap)
    rng = np.random.default_rng()
    rand_jitter = rng.random(n) * adaptive_weight
    score = base - bias + sin_jitter + phi_jitter + rand_jitter
    priority[feasible] = score[feasible]
    return priority
```
