```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Priority based on inverse leftover, variance‑scaled jitter, deterministic golden‑ratio tie‑breaker, and CV‑scaled random jitter."""
    rng = np.random.default_rng()
    n = bins_remain_cap.size
    if n == 0:
        return np.empty(0, dtype=float)
    remaining = bins_remain_cap - item
    feasible = remaining >= 0
    priority = np.full(n, -np.inf, dtype=float)
    if not feasible.any():
        return priority
    eps = 1e-12
    base = 1.0 / (remaining[feasible] + eps)
    bias = -np.arange(n)[feasible] * 1e-6
    phi = (1 + np.sqrt(5)) / 2
    phi_jitter = ((phi * (np.arange(n)[feasible] + 1) * item) % 1.0) * 1e-7
    mean_rem = np.mean(remaining[feasible])
    std_rem = np.std(remaining[feasible])
    cv = std_rem / (mean_rem + eps)
    jitter_scale = item * 0.01 * (1.0 + cv)
    jitter = (rng.random(n)[feasible] - 0.5) * jitter_scale
    var_penalty = -((remaining[feasible] - mean_rem) ** 2) * 1e-5
    priority[feasible] = base + bias + phi_jitter + jitter + var_penalty
    return priority
```
