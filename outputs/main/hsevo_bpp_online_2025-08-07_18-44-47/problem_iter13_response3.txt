import numpy as np

_rng = np.random.default_rng(42)

def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    eps: float = 5.545128496291938e-09,
    bias_factor: float = 1.547663993268596e-05,
    jitter_factor: float = 0.008853640107317637,
    det_jitter_factor: float = 3.0398573708429095e-15,
    det_jitter_multiplier: int = 38.21897362913886,
    det_jitter_mod: int = 1777.6239429519217,
) -> np.ndarray:
    """Inverse leftover with index bias and reproducible jitter for online BPP.

    Parameters
    ----------
    item : float
        Size of the item to pack.
    bins_remain_cap : np.ndarray
        Remaining capacities of the bins.
    eps : float, optional
        Small epsilon to avoid division by zero.
    bias_factor : float, optional
        Weight for the index bias term.
    jitter_factor : float, optional
        Scaling factor for the random jitter term.
    det_jitter_factor : float, optional
        Scaling factor for the deterministic jitter term.
    det_jitter_multiplier : int, optional
        Multiplier used in the deterministic jitter calculation.
    det_jitter_mod : int, optional
        Modulus used in the deterministic jitter calculation.
    """
    n = bins_remain_cap.size
    if n == 0:
        return np.empty(0, dtype=float)

    remaining = bins_remain_cap - item
    feasible = remaining >= 0

    inv = 1.0 / (remaining + eps)
    bias = -np.arange(n) * bias_factor * bias_factor
    jitter = _rng.random(n) * jitter_factor * item
    det_jitter = ((np.arange(n) * det_jitter_multiplier + int(item * 1e6)) % det_jitter_mod) * det_jitter_factor

    priority = np.full(n, -np.inf, dtype=float)
    priority[feasible] = inv[feasible] + bias[feasible] + jitter[feasible] + det_jitter[feasible]
    return priority
