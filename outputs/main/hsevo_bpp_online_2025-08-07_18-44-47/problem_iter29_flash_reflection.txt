**Analysis:**  
- **Heuristic 1 (best) vs Heuristic 20 (worst):** Heuristic 1 uses a clean inverse‑leftover score, a variance‑scaled jitter, and a tiny index bias – minimal, robust, and stateless. Heuristic 20 adds a mean‑deviation penalty, extra jitter logic, and a placeholder comment, increasing code complexity and introducing aggressive bias that can hurt packing quality.  
- **Heuristic 2 (2nd) vs Heuristic 19 (2nd‑worst):** Heuristic 2 is identical to Heuristic 1 (simple, effective). Heuristic 19 contains only a skeleton with many hyper‑parameters and no scoring logic after the early‑return, thus providing no useful decision information.  
- **Heuristic 1 vs Heuristic 2:** Both are identical copies; their scores, jitter, and bias are exactly the same, confirming the top‑rank stability of this pattern.  
- **Heuristic 3 vs Heuristic 4:** Heuristic 3 remains the simple baseline. Heuristic 4 introduces a running item‑average, a tightness factor, and jitter that adapts to the deviation from the average. This adds statefulness and extra computation, which can improve adaptivity on some instances but also creates overhead and potential drift.  
- **Heuristic 19 vs Heuristic 20:** Heuristic 19 is an incomplete placeholder (no functional scoring). Heuristic 20, though fully implemented, adds a mean‑distance penalty that can over‑penalize feasible bins, making it less reliable than the baseline.  

**Experience:**  
Keep heuristics simple: prioritize inverse leftover, add modest variance‑scaled jitter, and use a tiny deterministic bias. Avoid heavy state, aggressive penalties, or over‑parameterisation that destabilise performance.