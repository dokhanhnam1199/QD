[
  {
    "stdout_filepath": "problem_iter8_response0.txt_stdout.txt",
    "code_path": "problem_iter8_code0.py",
    "code": "import numpy as np\n\n# deterministic scoring: inverse leftover + index bias + tiny jitter\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Score feasible bins by inverse leftover capacity, add index bias and deterministic jitter.\"\"\"\n    if bins_remain_cap.size == 0:\n        return np.empty_like(bins_remain_cap, dtype=float)\n    eps = 1e-12\n    priors = np.full(bins_remain_cap.shape, -np.inf, dtype=float)\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        return priors\n    residual = bins_remain_cap[feasible] - item\n    base = 1.0 / (residual + eps)\n    idx = np.nonzero(feasible)[0].astype(float)\n    tie_break = idx * 1e-12\n    jitter_scale = 1e-9 * item\n    jitter = ((np.sin((item + idx) * 7.0) + 1) * 0.5) * jitter_scale\n    priors[feasible] = base + tie_break + jitter\n    return priors",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 16.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response1.txt_stdout.txt",
    "code_path": "problem_iter8_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Score bins by inverse leftover, deterministic index bias, and reproducible jitter.\"\"\"\n    if bins_remain_cap.size == 0:\n        return np.empty_like(bins_remain_cap, dtype=float)\n    residual = bins_remain_cap - item\n    feasible = residual >= 0\n    eps = 1e-12\n    base = np.where(feasible, 1.0 / (residual + eps), -np.inf)\n    n = bins_remain_cap.size\n    idx_bias = np.arange(n, dtype=float) * 1e-12\n    seed = int(item * 1e6) & 0xffffffff\n    rng = np.random.default_rng(seed)\n    jitter = np.where(feasible, rng.random(n) * 1e-12 * item, 0.0)\n    return base + idx_bias + jitter",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response2.txt_stdout.txt",
    "code_path": "problem_iter8_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item, bins_remain_cap):\n    if bins_remain_cap.size == 0:\n        return np.empty_like(bins_remain_cap, dtype=float)\n    fits = bins_remain_cap >= item\n    leftover = bins_remain_cap - item\n    eps = 1e-12\n    inv = 1.0 / (leftover + eps)\n    tie = eps * item * np.arange(bins_remain_cap.shape[0])\n    return np.where(fits, inv + tie, -np.inf)",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response3.txt_stdout.txt",
    "code_path": "problem_iter8_code3.py",
    "code": "import numpy as np\n\n_rng = np.random.default_rng(42)\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Score bins: inverse leftover, deterministic index bias, and tiny jitter.\"\"\"\n    n = bins_remain_cap.size\n    if n == 0:\n        return np.empty(0, dtype=float)\n    eps = 1e-9\n    remaining = bins_remain_cap - item\n    feasible = remaining >= 0\n    priority = np.full(n, -np.inf, dtype=float)\n    # Inverse leftover capacity favors tighter fits\n    priority[feasible] = 1.0 / (remaining[feasible] + eps)\n    # Deterministic tie\u2011breaker: prefer lower indices\n    priority[feasible] += -np.arange(n)[feasible] * 1e-5\n    # Reproduc: tiny jitter scaled by item size for residual ties\n    jitter = _rng.random(n) * 0.01 * item\n    priority[feasible] += jitter[feasible]\n    return priority",
    "response_id": 3,
    "tryHS": false,
    "obj": 3.071400079776621,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response4.txt_stdout.txt",
    "code_path": "problem_iter8_code4.py",
    "code": "import numpy as np\n\n_rng = np.random.default_rng(123456789)\n\ndef priority_v2(item, bins_remain_cap):\n    n = bins_remain_cap.size\n    if n == 0:\n        return np.empty(0, dtype=float)\n    eps = 1e-12\n    feasible = bins_remain_cap >= item\n    priority = np.full(n, -np.inf, dtype=float)\n    if not np.any(feasible):\n        return priority\n    remaining_after = bins_remain_cap[feasible] - item\n    base = 1.0 / (remaining_after + eps)\n    tie = -np.arange(n)[feasible] * 1e-8\n    jitter = _rng.random(remaining_after.shape) * 1e-6 * item\n    priority[feasible] = base + tie + jitter\n    return priority",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response5.txt_stdout.txt",
    "code_path": "problem_iter8_code5.py",
    "code": "import numpy as np\n\n# deterministic RNG for reproducible jitter\n_rng = np.random.default_rng(42)\n\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Score feasible bins: inverse leftover, deterministic index bias, and jitter.\"\"\"\n    n = bins_remain_cap.size\n    if n == 0:\n        return np.empty(0, dtype=float)\n    eps = 1e-9\n    remaining = bins_remain_cap - item\n    feasible = remaining >= 0\n    priority = np.full(n, -np.inf, dtype=float)\n    # base score: favor bins with little leftover space\n    priority[feasible] = 1.0 / (remaining[feasible] + eps)\n    # tie\u2011break: slight negative bias for lower indices, plus a tiny positive offset\n    idx = np.arange(n)\n    priority[feasible] += -idx[feasible] * 1e-5 + idx[feasible] * 1e-12\n    # reproducible jitter proportional to item size\n    jitter = _rng.random(n) * 0.01 * item\n    priority[feasible] += jitter[feasible]\n    return priority",
    "response_id": 5,
    "tryHS": false,
    "obj": 3.071400079776621,
    "SLOC": 14.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response6.txt_stdout.txt",
    "code_path": "problem_iter8_code6.py",
    "code": "import numpy as np\n\n_rng = np.random.default_rng(42)\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Score bins by inverse leftover, tiny index bias, and deterministic jitter.\"\"\"\n    n = bins_remain_cap.size\n    if n == 0:\n        return np.empty(0, dtype=float)\n    eps = 1e-9\n    remaining = bins_remain_cap - item\n    feasible = remaining >= 0\n    priority = np.full(n, -np.inf, dtype=float)\n    inv = 1.0 / (remaining[feasible] + eps)\n    bias = -np.arange(n)[feasible] * 1e-5\n    jitter = _rng.random(n)[feasible] * 0.01 * item\n    priority[feasible] = inv + bias + jitter\n    return priority",
    "response_id": 6,
    "tryHS": false,
    "obj": 3.071400079776621,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response7.txt_stdout.txt",
    "code_path": "problem_iter8_code7.py",
    "code": "import numpy as np\n\n_rng = np.random.default_rng(42)\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Score bins by inverse leftover, tiny index bias, and deterministic jitter.\"\"\"\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)\n    n = bins_remain_cap.size\n    if n == 0:\n        return np.empty(0, dtype=float)\n    eps = 1e-9\n    remaining = bins_remain_cap - item\n    feasible = remaining >= 0\n    priority = np.full(n, -np.inf, dtype=float)\n    priority[feasible] = 1.0 / (remaining[feasible] + eps)\n    priority[feasible] += -np.arange(n)[feasible] * 1e-5\n    jitter = _rng.random(n) * 0.01 * item\n    priority[feasible] += jitter[feasible]\n    return priority",
    "response_id": 7,
    "tryHS": false,
    "obj": 3.071400079776621,
    "SLOC": 14.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response8.txt_stdout.txt",
    "code_path": "problem_iter8_code8.py",
    "code": "import numpy as np\n\n_rng = np.random.default_rng(42)\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Score bins: inverse leftover, low-index bias, deterministic jitter.\"\"\"\n    n = bins_remain_cap.size\n    if n == 0:\n        return np.empty(0, dtype=float)\n    eps = 1e-12\n    remaining = bins_remain_cap - item\n    feasible = remaining >= 0\n    priority = np.full(n, -np.inf, dtype=float)\n    base = 1.0 / (remaining + eps)\n    bias = np.arange(n) * 1e-6\n    jitter = _rng.random(n) * 0.01 * item\n    priority[feasible] = base[feasible] - bias[feasible] + jitter[feasible]\n    return priority",
    "response_id": 8,
    "tryHS": false,
    "obj": 3.081372157957728,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response9.txt_stdout.txt",
    "code_path": "problem_iter8_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Score feasible bins by inverse leftover capacity, deterministic tie\u2011breaker.\"\"\"\n    if bins_remain_cap.size == 0:\n        return np.empty_like(bins_remain_cap, dtype=float)\n    fits = bins_remain_cap >= item\n    leftover = bins_remain_cap - item\n    eps = 1e-12\n    inv = 1.0 / (leftover + eps)\n    idx = np.arange(bins_remain_cap.shape[0])\n    jitter = ((idx * 31 + int(item * 1e6)) % 1000) * 1e-15\n    tie = idx * 1e-12 + item * 1e-12 * idx + jitter\n    return np.where(fits, inv + tie, -np.inf)",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  }
]