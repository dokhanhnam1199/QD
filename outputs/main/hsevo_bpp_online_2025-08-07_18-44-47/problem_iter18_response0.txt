```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    rng = np.random.default_rng()
    n = bins_remain_cap.size
    if n == 0:
        return np.empty(0, dtype=float)
    remaining = bins_remain_cap - item
    feasible = remaining >= 0
    priority = np.full(n, -np.inf, dtype=float)
    inv_leftover = np.where(remaining > 0, 1.0 / remaining, np.finfo(float).max)
    total_remain = bins_remain_cap.sum()
    mean_remain = total_remain / n
    variance = np.where(total_remain > 0, ((bins_remain_cap - mean_remain)**2).sum() / n, 0.0)
    var_norm = np.where(mean_remain > 0, variance / (mean_remain**2), 0.0)
    forecast = np.where(mean_remain > 0, np.exp(-item / mean_remain), 0.0)
    w_inv = 1.0 / (item if item > 0 else 1.0)
    w_var = 1.0 / (mean_remain if mean_remain > 0 else 1.0)
    w_forecast = 1.0 / (total_remain if total_remain > 0 else 1.0)
    total_w = w_inv + w_var + w_forecast
    inv_weight = w_inv / total_w
    var_weight = w_var / total_w
    fore_weight = w_forecast / total_w
    score = inv_leftover * inv_weight + (1.0 - var_norm) * var_weight + forecast * fore_weight
    max_remain = bins_remain_cap.max() if n > 0 else 0
    jitter_scale = np.where(max_remain > 0, 1.0 - (remaining / max_remain), 0.0)
    jitter = rng.random(n) * jitter_scale * item * 0.1
    bin_indices = np.arange(n)
    hash_val = ((bin_indices * 9301 + 49297) % 233280) / 233280
    tie_breaker = rng.normal(size=n) * hash_val * 1e-3
    priority[feasible] = score[feasible] + jitter[feasible] + tie_breaker[feasible]
    return priority
```
