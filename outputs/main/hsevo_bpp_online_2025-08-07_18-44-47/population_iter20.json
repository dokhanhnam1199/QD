[
  {
    "stdout_filepath": "problem_iter20_response0.txt_stdout.txt",
    "code_path": "problem_iter20_code0.py",
    "code": "import numpy as np\n_rng = np.random.default_rng()\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combine inverse leftover with variance\u2011scaled jitter for adaptive bin selection.\"\"\"\n    eps = 1e-9\n    n = bins_remain_cap.size\n    if n == 0:\n        return np.empty(0, dtype=float)\n    remaining = bins_remain_cap - item\n    feasible = remaining >= 0\n    base_score = np.where(feasible, 1.0 / (remaining + eps), -np.inf)\n    mean_rem = bins_remain_cap.mean()\n    var_norm = np.var(bins_remain_cap) / (mean_rem**2 + eps)\n    w_det = 1.0 / (1.0 + var_norm)\n    w_rand = var_norm / (1.0 + var_norm)\n    max_rem = bins_remain_cap.max()\n    jitter_scale = np.where(max_rem > 0, 1.0 - remaining / max_rem, 0.0)\n    jitter_scale = np.clip(jitter_scale, 0.0, 1.0)\n    jitter = _rng.random(n) * item * jitter_scale\n    tie = _rng.random(n) * 1e-6\n    priority = base_score * w_det + jitter * w_rand + tie\n    return priority",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 19.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response1.txt_stdout.txt",
    "code_path": "problem_iter20_code1.py",
    "code": "import numpy as np\n\n_item_counter = 0\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Priority for online bin packing: inverse leftover with dynamic bias toward median load, plus adaptive random Gumbel perturbation and sinusoidal jitter.\n    \"\"\"\n    global _item_counter\n    _item_counter += 1\n    n = bins_remain_cap.size\n    if n == 0:\n        return np.empty(0, dtype=float)\n    remaining = bins_remain_cap - item\n    feasible = remaining >= 0\n    priority = np.full(n, -np.inf, dtype=float)\n    if not np.any(feasible):\n        return priority\n    eps = 1e-9\n    base = 1.0 / (remaining[feasible] + eps)\n    med = np.median(remaining[feasible])\n    bias = -((remaining[feasible] - med) ** 2) * 1e-9\n    indices = np.arange(n)\n    rng = np.random.default_rng()\n    sin_jitter = (np.sin((item + indices[feasible]) * 7.0) + 1) * 0.5 * 1e-9 * item\n    temp = max(0.05, 0.5 * np.exp(-0.001 * _item_counter))\n    rand_jitter = rng.random(feasible.sum()) * 0.01 * item / temp\n    gumbel = -np.log(-np.log(rng.random(feasible.sum())))\n    score = base + bias + sin_jitter + rand_jitter + gumbel / temp\n    priority[feasible] = score\n    return priority",
    "response_id": 1,
    "tryHS": false,
    "obj": 36.208615875548475,
    "SLOC": 24.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response2.txt_stdout.txt",
    "code_path": "problem_iter20_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Compute bin scores using inverse leftover, small index bias, sinusoidal and golden\u2011ratio jitters, and an adaptive random term scaled by item size and remaining\u2011capacity variance.\"\"\"\n    n = bins_remain_cap.size\n    if n == 0:\n        return np.empty(0, dtype=float)\n    eps = 1e-9\n    remaining = bins_remain_cap - item\n    feasible = remaining >= 0\n    priority = np.full(n, -np.inf, dtype=float)\n    idx = np.arange(n, dtype=float)\n    base = 1.0 / (remaining[feasible) + eps])\n    bias = idx * 1e-5\n    sin_jitter = np.sin((item + idx) * 0.01) * 1e-7\n    phi = 0.6180339887498949\n    phi_jitter = np.mod(phi * (idx + 1) * item, 1.0) * 0.01 * item\n    std_rem = np.std(remaining) if n > 1 else 0.0\n    mean_cap = np.mean(bins_remain_cap) + eps\n    adaptive_weight = 0.01 * item * (std_rem / mean_cap)\n    rng = np.random.default_rng()\n    rand_jitter = rng.random(n) * adaptive_weight\n    score = base - bias + sin_jitter + phi_jitter + rand_jitter\n    priority[feasible] = score[feasible]\n    return priority",
    "response_id": 2,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 9, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 13\n    base = 1.0 / (remaining[feasible) + eps])\n                                    ^\nSyntaxError: closing parenthesis ')' does not match opening parenthesis '['\nTraceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/SLOC.py\", line 7, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 13\n    base = 1.0 / (remaining[feasible) + eps])\n                                    ^\nSyntaxError: closing parenthesis ')' does not match opening parenthesis '['\nTraceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/cyclomatic_complexity.py\", line 7, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 13\n    base = 1.0 / (remaining[feasible) + eps])\n                                    ^\nSyntaxError: closing parenthesis ')' does not match opening parenthesis '['\n"
  },
  {
    "stdout_filepath": "problem_iter20_response3.txt_stdout.txt",
    "code_path": "problem_iter20_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Priority: inverse leftover + tiny index bias + deterministic jitter + variance penalty.\"\"\"\n    n = bins_remain_cap.size\n    if n == 0:\n        return np.empty(0, dtype=float)\n    remaining = bins_remain_cap - item\n    feasible = remaining >= 0\n    priority = np.full(n, -np.inf, dtype=float)\n    if not np.any(feasible):\n        return priority\n    base = 1.0 / remaining[feasible]\n    idx_bias = np.arange(n)[feasible] * 1e-6\n    std_rem = np.std(remaining[feasible])\n    jitter_scale = item * 0.001 * (1 + std_rem / 10)\n    jitter = np.sin(item + np.arange(n)[feasible]) * jitter_scale\n    mean_rem = remaining[feasible].mean()\n    var_penalty = - ((remaining[feasible] - mean_rem) ** 2) * 1e-4\n    priority[feasible] = base + idx_bias + jitter + var_penalty\n    return priority",
    "response_id": 3,
    "tryHS": false,
    "obj": 33.53609892301556,
    "SLOC": 18.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response4.txt_stdout.txt",
    "code_path": "problem_iter20_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    n = bins_remain_cap.size\n    if n == 0:\n        return np.empty(0, dtype=float)\n    remaining = bins_remain_cap - item\n    feasible = remaining >= 0\n    priority = np.full(n, -np.inf, dtype=float)\n    if not np.any(feasible):\n        return priority\n    idx = np.arange(n, dtype=float)\n    eps = 1e-12\n    base = 1.0 / (remaining[feasible] + eps)\n    bias = -idx[feasible] * 1e-6\n    phi = 0.6180339887498949\n    det_jitter = (np.mod(phi * (idx[feasible] + 1) * item, 1.0) - 0.5) * 1e-5 * item\n    load_scale = remaining[feasible] / (remaining[feasible].max() + eps)\n    rng = np.random.default_rng()\n    rand_jitter = rng.standard_normal(feasible.sum()) * (1e-5 * item) * load_scale\n    priority[feasible] = base + bias + det_jitter + rand_jitter\n    return priority",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 20.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response5.txt_stdout.txt",
    "code_path": "problem_iter20_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Priority: inverse leftover, tiny index bias, golden\u2011ratio jitter, adaptive random jitter.\"\"\"\n    bins = np.asarray(bins_remain_cap, dtype=float)\n    n = bins.size\n    if n == 0:\n        return np.empty(0, dtype=float)\n    remaining = bins - item\n    feasible = remaining >= 0\n    eps = 1e-9\n    idx = np.arange(n, dtype=float)\n    primary = np.full(n, -np.inf, dtype=float)\n    primary[feasible] = 1.0 / (remaining[feasible] + eps)\n    bias = -idx * 1e-6\n    phi = (1 + np.sqrt(5)) / 2\n    jitter = ((phi * (idx + 1) * item) % 1.0) * 1e-6 * item\n    if feasible.any():\n        std = np.std(remaining[feasible])\n        mean = np.mean(remaining[feasible])\n        coeff = std / (mean + eps)\n        random_weight = 0.01 * (1.0 + coeff)\n        rng = np.random.default_rng()\n        rand_jitter = rng.random(n) * random_weight * item\n    else:\n        rand_jitter = np.zeros(n, dtype=float)\n    score = primary + bias + jitter + rand_jitter\n    score[~feasible] = -np.inf\n    return score",
    "response_id": 5,
    "tryHS": false,
    "obj": 3.071400079776621,
    "SLOC": 26.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response6.txt_stdout.txt",
    "code_path": "problem_iter20_code6.py",
    "code": "import numpy as np\n_rng = np.random.default_rng(42)\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    n = bins_remain_cap.size\n    if n == 0:\n        return np.empty(0, dtype=float)\n    remaining = bins_remain_cap - item\n    feasible = remaining >= 0\n    priority = np.full(n, -np.inf, dtype=float)\n    if np.any(feasible):\n        eps = 1e-9\n        base = 1.0 / (remaining[feasible] + eps)\n        bias = -np.arange(n)[feasible] * 1e-5\n        phi = 0.6180339887498949\n        det_jitter = (np.mod(phi * (np.arange(n)[feasible] + 1) * item, 1.0) - 0.5) * 1e-5 * item\n        sin_jitter = np.sin(item * np.arange(n)[feasible] + 1.0) * 1e-9 * item\n        rng_jitter = _rng.standard_normal(feasible.sum()) * 1e-5 * item\n        priority[feasible] = base + bias + det_jitter + sin_jitter + rng_jitter\n    return priority",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 17.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response7.txt_stdout.txt",
    "code_path": "problem_iter20_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Score bins using inverse leftover, index bias, adaptive jitter, and load\u2011aware random perturbation.\"\"\"\n    n = bins_remain_cap.size\n    if n == 0:\n        return np.empty(0, dtype=float)\n    eps = 1e-12\n    remaining = bins_remain_cap - item\n    feasible = remaining >= 0\n    score = np.full(n, -np.inf, dtype=float)\n    inv_left = 1.0 / (remaining[feasible] + eps)\n    indices = np.arange(n, dtype=float)\n    idx_bias = indices * 1e-6\n    sin_jitter = np.sin((item + indices) * 0.01)\n    phi = (np.sqrt(5) - 1) / 2\n    phi_jitter = ((phi * (indices + 1) * item) % 1.0)\n    jitter_det = sin_jitter + phi_jitter\n    max_rem = bins_remain_cap.max()\n    load_factor = (remaining + eps) / (max_rem + eps)\n    rng = np.random.default_rng()\n    rand_vals = rng.random(n)\n    jitter_rand = rand_vals * 0.01 * item * load_factor\n    score[feasible] = inv_left - idx_bias[feasible] + jitter_det[feasible] * 0.01 + jitter_rand[feasible]\n    return score",
    "response_id": 7,
    "tryHS": false,
    "obj": 81.6613482249701,
    "SLOC": 22.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response8.txt_stdout.txt",
    "code_path": "problem_iter20_code8.py",
    "code": "import numpy as np\n\n# Adaptive priority for online bin packing: combines inverse leftover,\n# mean\u2011load bias, and variance\u2011scaled jitter for dynamic tie\u2011breaking.\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Adaptive inverse\u2011leftover scoring with load bias and variance\u2011scaled jitter.\"\"\"\n    n = bins_remain_cap.size\n    if n == 0:\n        return np.empty(0, dtype=float)\n    eps = 1e-12\n    remaining = bins_remain_cap - item\n    feasible = remaining >= 0\n    priority = np.full(n, -np.inf, dtype=float)\n    if not np.any(feasible):\n        return priority\n\n    # Base: inverse leftover capacity (smaller leftover \u2192 higher score)\n    inv_left = 1.0 / (remaining[feasible] + eps)\n\n    # Load bias: favour bins whose remaining capacity is close to the average\n    mean_rem = bins_remain_cap.mean()\n    dist = np.abs(bins_remain_cap[feasible] - mean_rem)\n    max_dist = dist.max() if dist.size else 1.0\n    load_bias = 1.0 - dist / (max_dist + eps)\n\n    # Adaptive jitter: magnitude proportional to variance of bin loads\n    var_rem = bins_remain_cap.var()\n    jitter_scale = np.sqrt(var_rem) / (bins_remain_cap.max() + eps)\n    rng = np.random.default_rng()\n    jitter = rng.random(inv_left.shape) * jitter_scale * item * 0.01\n\n    # Dynamic weight blending \u2013 more variance gives more jitter influence\n    w_jitter = var_rem / (var_rem + 1.0)\n    w_base = 1.0 - w_jitter\n    w_bias = 0.01\n\n    priority[feasible] = w_base * inv_left + w_bias * load_bias + w_jitter * jitter\n    return priority",
    "response_id": 8,
    "tryHS": false,
    "obj": 34.05464698843239,
    "SLOC": 24.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response9.txt_stdout.txt",
    "code_path": "problem_iter20_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Priority by inverse leftover, variance penalty, adaptive jitter, load centering, and tiny index bias.\"\"\"\n    n = bins_remain_cap.size\n    if n == 0:\n        return np.empty(0, dtype=float)\n    remaining = bins_remain_cap - item\n    feasible = remaining >= 0\n    priority = np.full(n, -np.inf, dtype=float)\n    if not feasible.any():\n        return priority\n    idx = np.arange(n, dtype=float)\n    base = 1.0 / (remaining[feasible] + 1e-12)\n    mean_rem = remaining[feasible].mean()\n    var_penalty = -((remaining[feasible] - mean_rem) ** 2) * 1e-3\n    rng = np.random.default_rng()\n    jitter = rng.normal(loc=0.0, scale=item * 0.01, size=feasible.sum())\n    mean_center = (bins_remain_cap.mean() - bins_remain_cap[feasible]) * 0.001\n    bias = idx[feasible] * 1e-6\n    priority[feasible] = base + var_penalty + jitter + mean_center + bias\n    return priority",
    "response_id": 9,
    "tryHS": false,
    "obj": 47.68647786198644,
    "SLOC": 19.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  }
]