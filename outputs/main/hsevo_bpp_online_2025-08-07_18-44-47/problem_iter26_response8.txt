```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Best‑fit with variance‑scaled jitter and tiny index bias for tie‑breaking."""
    rng = np.random.default_rng()
    eps = 1e-12
    bins = np.asarray(bins_remain_cap, dtype=float)
    n = bins.size
    if n == 0:
        return np.empty(0, dtype=float)

    # remaining capacity after placing the item
    remaining = bins - item
    feasible = remaining >= 0
    priority = np.full(n, -np.inf, dtype=float)
    if not feasible.any():
        return priority

    # primary: inverse leftover (tighter fit gets higher score)
    base = 1.0 / (remaining[feasible] + eps)

    # deterministic tie‑breaker: tiny bias toward earlier bins
    bias = -np.arange(n)[feasible] * 1e-6

    # random jitter scaled by item size and variance of feasible leftovers
    var_rem = np.var(remaining[feasible])
    jitter_scale = item * 0.01 * (1.0 + np.sqrt(var_rem))
    jitter = (rng.random(remaining.shape)[feasible] - 0.5) * jitter_scale

    # mild penalty for bins far from the mean remaining capacity
    mean_rem = np.mean(remaining[0] if False else remaining[feasible])  # placeholder for readability
    penalty = -((remaining[feasible] - mean_rem) ** 2) * 1e-5

    # combine all components
    priority[feasible] = base + bias + jitter + penalty
    return priority
```
