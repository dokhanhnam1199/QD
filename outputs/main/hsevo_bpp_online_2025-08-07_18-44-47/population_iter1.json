[
  {
    "stdout_filepath": "problem_iter1_response0.txt_stdout.txt",
    "code_path": "problem_iter1_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"First-Fit priority: earlier bins with sufficient space get higher score.\"\"\"\n    can_fit = bins_remain_cap >= item\n    idx = np.arange(bins_remain_cap.shape[0])\n    priorities = np.where(can_fit, bins_remain_cap.shape[0] - idx, 0.0)\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response1.txt_stdout.txt",
    "code_path": "problem_iter1_code1.py",
    "code": "import numpy as np\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    if bins_remain_cap.size == 0:\n        return bins_remain_cap\n    fits = bins_remain_cap >= item\n    leftovers = bins_remain_cap - item\n    priorities = np.where(fits, -leftovers, -np.inf)\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response2.txt_stdout.txt",
    "code_path": "problem_iter1_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority for each bin according to Worst Fit strategy.\"\"\"\n    feasible = bins_remain_cap >= item\n    priorities = np.where(feasible, bins_remain_cap, -np.inf)\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 149.30195452732352,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response3.txt_stdout.txt",
    "code_path": "problem_iter1_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    slack = bins_remain_cap - item\n    priorities = np.where(slack >= 0, -slack, -1e9)\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response4.txt_stdout.txt",
    "code_path": "problem_iter1_code4.py",
    "code": "import numpy as np\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.inf:\n    diff = bins_remain_cap - item\n    mask = diff >= 0\n    return np.where(mask, -diff, -np.inf)",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response5.txt_stdout.txt",
    "code_path": "problem_iter1_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    diff = bins_remain_cap - item\n    eps = 1e-9\n    return np.where(diff >= 0, 1.0 / (diff + eps), 0.0)",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response6.txt_stdout.txt",
    "code_path": "problem_iter1_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    diffs = bins_remain_cap - item\n    mask = diffs >= 0\n    scale = np.max(diffs[mask]) if np.any(mask) else 1.0\n    scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    scores[mask] = 1.0 / (1.0 + np.exp(diffs[mask] / scale))\n    return scores",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response7.txt_stdout.txt",
    "code_path": "problem_iter1_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    fit = bins_remain_cap >= item\n    left = bins_remain_cap - item\n    rand = np.random.rand(*bins_remain_cap.shape)\n    priorities = np.full(bins_remain_cap.shape, -np.inf, dtype=float)\n    priorities[fit] = -left[fit] + rand[fit] * 0.1 * item\n    return priorities",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response8.txt_stdout.txt",
    "code_path": "problem_iter1_code8.py",
    "code": "import numpy as np\nEPSILON = 0.1\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    feasible = bins_remain_cap >= item\n    deterministic = np.where(feasible, -(bins_remain_cap - item), -np.inf)\n    random_score = np.where(feasible, np.random.rand(*bins_remain_cap.shape), -np.inf)\n    if np.random.rand() < EPSILON:\n        return random_score\n    return deterministic",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.168328679696844,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response9.txt_stdout.txt",
    "code_path": "problem_iter1_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using a Softmax-Based Fit strategy.\"\"\"\n    leftover = bins_remain_cap - item\n    mask = leftover >= 0\n    scores = np.zeros_like(bins_remain_cap, dtype=float)\n    scores[mask] = -leftover[mask]\n    max_score = np.max(scores) if mask.any() else 0.0\n    exp_vals = np.exp(scores - max_score)\n    total = np.sum(exp_vals)\n    priorities = exp_vals / total if total > 0 else np.zeros_like(bins_remain_cap, dtype=float)\n    return priorities",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response10.txt_stdout.txt",
    "code_path": "problem_iter1_code10.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    n = bins_remain_cap.size\n    idx = np.arange(n, dtype=float)\n    fit = bins_remain_cap >= item\n    priorities = np.where(fit, n - 1 - idx, -np.inf)\n    return priorities",
    "response_id": 10,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response11.txt_stdout.txt",
    "code_path": "problem_iter1_code11.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    residual = bins_remain_cap - item\n    return np.where(residual >= 0, -residual, -np.inf)",
    "response_id": 11,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 3.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response12.txt_stdout.txt",
    "code_path": "problem_iter1_code12.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    valid = bins_remain_cap >= item\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    priorities[valid] = np.square(bins_remain_cap[valid])\n    return priorities",
    "response_id": 12,
    "tryHS": false,
    "obj": 149.30195452732352,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response13.txt_stdout.txt",
    "code_path": "problem_iter1_code13.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Almost Full Fit.\"\"\"\n    fits = bins_remain_cap >= item\n    epsilon = 1e-9\n    leftover = bins_remain_cap - item\n    priorities = np.where(fits, 1.0 / (leftover + epsilon), -np.inf)\n    return priorities",
    "response_id": 13,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response14.txt_stdout.txt",
    "code_path": "problem_iter1_code14.py",
    "code": "import numpy as np\n\ndef priority_v2(item, bins_remain_cap):\n    pri = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    exact_mask = bins_remain_cap == item\n    pri[exact_mask] = 1e6\n    fit_mask = bins_remain_cap > item\n    pri[fit_mask] = 1 - (bins_remain_cap[fit_mask] - item) / bins_remain_cap[fit_mask]\n    return pri",
    "response_id": 14,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response15.txt_stdout.txt",
    "code_path": "problem_iter1_code15.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Inverse distance (proximity fit) priority function.\"\"\"\n    eps = 1e-9\n    residual = bins_remain_cap - item\n    return np.where(residual >= 0, 1.0/(residual + eps), 0.0)",
    "response_id": 15,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response16.txt_stdout.txt",
    "code_path": "problem_iter1_code16.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    gamma = 10.0\n    priorities = np.full_like(bins_remain_cap, -1e9, dtype=np.float64)\n    fit_mask = bins_remain_cap >= item\n    if np.any(fit_mask):\n        res = bins_remain_cap[fit_mask] - item\n        ratio = res / bins_remain_cap[fit_mask]\n        priorities[fit_mask] = 1.0 / (1.0 + np.exp(gamma * ratio))\n    return priorities",
    "response_id": 16,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response17.txt_stdout.txt",
    "code_path": "problem_iter1_code17.py",
    "code": "import numpy as np\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priors = np.full(bins_remain_cap.shape, -np.inf, dtype=float)\n    eligible = bins_remain_cap >= item\n    if np.any(eligible):\n        rng = np.random.default_rng()\n        priors[eligible] = rng.random(np.count_nonzero(eligible))\n    return priors",
    "response_id": 17,
    "tryHS": false,
    "obj": 73.42441164738732,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response18.txt_stdout.txt",
    "code_path": "problem_iter1_code18.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\"\"\"\n    epsilon = 0.1\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    valid = bins_remain_cap >= item\n    if not np.any(valid):\n        return priorities\n    waste = bins_remain_cap[valid] - item\n    exploitation = -waste\n    random_score = np.random.rand(np.count_nonzero(valid))\n    priorities[valid] = (1 - epsilon) * exploitation + epsilon * random_score\n    return priorities",
    "response_id": 18,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response19.txt_stdout.txt",
    "code_path": "problem_iter1_code19.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    temperature = 0.05\n    residual = bins_remain_cap - item\n    mask = residual >= 0\n    scores = np.zeros_like(bins_remain_cap, dtype=np.float64)\n    scores[mask] = np.exp(-residual[mask] / temperature)\n    total = scores.sum()\n    if total > 0:\n        scores = scores / total\n    return scores",
    "response_id": 19,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response20.txt_stdout.txt",
    "code_path": "problem_iter1_code20.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"First Fit priority: prefers the earliest bin that can accommodate the item.\"\"\"\n    n = bins_remain_cap.shape[0]\n    idx = np.arange(n, dtype=float)\n    can_fit = bins_remain_cap >= item\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    priorities[can_fit] = -idx[can_fit]\n    return priorities",
    "response_id": 20,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response21.txt_stdout.txt",
    "code_path": "problem_iter1_code21.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.where(bins_remain_cap >= item, -(bins_remain_cap - item), -np.inf)\n    return priorities",
    "response_id": 21,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 3.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response22.txt_stdout.txt",
    "code_path": "problem_iter1_code22.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority for each bin using worst-fit: highest remaining capacity that can accommodate the item.\"\"\"\n    feasible = bins_remain_cap >= item\n    priority = np.where(feasible, bins_remain_cap, -np.inf)\n    jitter = np.random.rand(*bins_remain_cap.shape) * 1e-12\n    priority = np.where(feasible, priority + jitter, priority)\n    return priority",
    "response_id": 22,
    "tryHS": false,
    "obj": 149.30195452732352,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response23.txt_stdout.txt",
    "code_path": "problem_iter1_code23.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Almost Full Fit.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    epsilon = 1e-9\n    remaining = bins_remain_cap - item\n    feasible = remaining >= 0\n    priorities = np.where(feasible, 1.0/(remaining + epsilon), -np.inf)\n    return priorities",
    "response_id": 23,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response24.txt_stdout.txt",
    "code_path": "problem_iter1_code24.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, priority_strategy=\"ExactFitFirst\", bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Exact Fit First.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    feasible = bins_remain_cap >= item\n    leftovers = bins_remain_cap - item\n    priorities = np.where(feasible, -leftovers, -np.inf)\n    exact_fit = bins_remain_cap == item\n    if np.any(exact_fit):\n        priorities[exact_fit] = np.inf\n    return priorities",
    "response_id": 24,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 9, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 3\n    def priority_v2(item: float, priority_strategy=\"ExactFitFirst\", bins_remain_cap: np.ndarray) -> np.ndarray:\n                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: non-default argument follows default argument\nTraceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/SLOC.py\", line 7, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 3\n    def priority_v2(item: float, priority_strategy=\"ExactFitFirst\", bins_remain_cap: np.ndarray) -> np.ndarray:\n                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: non-default argument follows default argument\nTraceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/cyclomatic_complexity.py\", line 7, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 3\n    def priority_v2(item: float, priority_strategy=\"ExactFitFirst\", bins_remain_cap: np.ndarray) -> np.ndarray:\n                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: non-default argument follows default argument\n"
  },
  {
    "stdout_filepath": "problem_iter1_response25.txt_stdout.txt",
    "code_path": "problem_iter1_code25.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    eps = 1e-9\n    leftover = bins_remain_cap - item\n    fit = leftover >= 0\n    return np.where(fit, 1.0 / (leftover + eps), -np.inf)",
    "response_id": 25,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response26.txt_stdout.txt",
    "code_path": "problem_iter1_code26.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    low = bins_remain_cap - item\n    mask = low >= 0\n    priorities = np.zeros_like(bins_remain_cap)\n    eps = 0.01\n    k = 10.0\n    sub = eps - low[mask]\n    priorities[mask] = 1.0 / (1.0 + np.exp(-k * sub))\n    return priorities",
    "response_id": 26,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response27.txt_stdout.txt",
    "code_path": "problem_iter1_code27.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    mask = bins_remain_cap >= item\n    return np.where(mask, np.random.rand(len(bins_remain_cap)), -np.inf)",
    "response_id": 27,
    "tryHS": false,
    "obj": 72.9058635819705,
    "SLOC": 3.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response28.txt_stdout.txt",
    "code_path": "problem_iter1_code28.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Epsilon\u2011greedy priority for online bin packing.\"\"\"\n    epsilon = 0.12\n    base = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    feasible = bins_remain_cap >= item\n    base[feasible] = 1.0 / (bins_remain_cap[feasible] - item + 1e-12)\n    rand = np.random.rand(bins_remain_cap.shape[0])\n    priorities = (1 - epsilon) * base + epsilon * rand\n    return priorities",
    "response_id": 28,
    "tryHS": false,
    "obj": 4.01874750698045,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response29.txt_stdout.txt",
    "code_path": "problem_iter1_code29.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    margin = bins_remain_cap - item\n    mask = margin >= 0\n    priorities = np.where(mask, np.exp(-4.0 * margin), 0.0)\n    return priorities",
    "response_id": 29,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  }
]