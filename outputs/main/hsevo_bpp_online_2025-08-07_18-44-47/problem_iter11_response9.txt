```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Score bins by inverse leftover, index bias, and capacity‑scaled jitter."""
    n = bins_remain_cap.size
    if n == 0:
        return np.empty(0, dtype=float)
    eps = 1e-9
    # remaining capacity after placing the item
    remaining = bins_remain_cap - item
    feasible = remaining >= 0
    # base best‑fit score: tighter fit → higher priority
    priority = np.full(n, -np.inf, dtype=float)
    priority[feasible] = 1.0 / (remaining[feasible] + eps)
    # deterministic tie‑breaker: prefer lower index
    priority[feasible] -= np.arange(n)[feasible] * 1e-6
    # stochastic exploration: jitter scaled by residual capacity proportion
    if feasible.any():
        rng = np.random.default_rng()
        max_rem = bins_remain_cap.max()
        scale = (remaining[feasible] / (max_rem + eps)) * 0.01
        jitter = rng.random(feasible.sum()) * scale
        priority[feasible] += jitter
    return priority
```
