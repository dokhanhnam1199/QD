[
  {
    "stdout_filepath": "problem_iter11_response0.txt_stdout.txt",
    "code_path": "problem_iter11_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Score feasible bins using inverse leftover, index bias, and deterministic phi jitter.\"\"\"\n    n = bins_remain_cap.size\n    if n == 0:\n        return np.empty(0, dtype=float)\n    eps = 1e-9\n    remaining = bins_remain_cap - item\n    feasible = remaining >= 0\n    priority = np.full(n, -np.inf, dtype=float)\n    idx = np.arange(n)\n    base = 1.0 / (remaining[feasible] + eps)\n    bias = -idx[feasible] * 1e-5 + idx[feasible] * 1e-12\n    phi = 0.6180339887498949\n    jitter = (np.mod(phi * (idx[feasible] + 1) * item, 1.0) - 0.5) * 1e-5 * item\n    priority[feasible] = base + bias + jitter\n    return priority",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response1.txt_stdout.txt",
    "code_path": "problem_iter11_code1.py",
    "code": "import numpy as np\n_rng = np.random.default_rng(42)\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritize bins by inverse leftover, low-index bias, and reproducible jitter.\"\"\"\n    n = bins_remain_cap.size\n    if n == 0:\n        return np.empty(0, dtype=float)\n    eps = 1e-9\n    remaining = bins_remain_cap - item\n    feasible = remaining >= 0\n    priority = np.full(n, -np.inf, dtype=float)\n    if not np.any(feasible):\n        return priority\n    indices = np.arange(n)\n    priority[feasible] = 1.0 / (remaining[feasible] + eps)\n    priority[feasible] += -indices[feasible] * 1e-6\n    priority[feasible] += _rng.random(n)[feasible] * 0.01 * item\n    priority[feasible] += ((np.sin((item + indices[feasible]) * 7.0) + 1) * 0.5) * 1e-9 * item\n    return priority",
    "response_id": 1,
    "tryHS": false,
    "obj": 3.081372157957728,
    "SLOC": 16.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response2.txt_stdout.txt",
    "code_path": "problem_iter11_code2.py",
    "code": "# Priority heuristic combining inverse leftover, index bias, and adaptive jitter.\nimport numpy as np\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    epsilon: float = 1e-9,\n    index_weight: float = 1e-5,\n    jitter_factor: float = 0.01,\n    rng_seed: int = None,\n) -> np.ndarray:\n    \"\"\"Score bins by inverse leftover, index bias, and adaptive jitter.\"\"\"\n    n = bins_remain_cap.size\n    if n == 0:\n        return np.empty(0, dtype=float)\n    remaining = bins_remain_cap - item\n    feasible = remaining >= 0\n    priority = np.full(n, -np.inf, dtype=float)\n    priority[feasible] = 1.0 / (remaining[feasible] + epsilon)\n    priority[feasible] -= np.arange(n)[feasible] * index_weight\n    priority[feasible] += np.arange(n)[feasible] * 1e-12\n    rng = np.random.default_rng(rng_seed) if rng_seed is not None else np.random.default_rng()\n    if np.any(feasible):\n        max_cap = bins_remain_cap.max()\n        jitter_vals = rng.random(np.count_nonzero(feasible)) * jitter_factor * (\n            (remaining[feasible] + epsilon) / (max_cap + epsilon)\n        )\n        priority[feasible] += jitter_vals\n    return priority",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.038691663342641,
    "SLOC": 25.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response3.txt_stdout.txt",
    "code_path": "problem_iter11_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Score bins: inverse leftover, index bias, deterministic golden\u2011ratio jitter.\"\"\"\n    n = bins_remain_cap.size\n    if n == 0:\n        return np.empty(0, dtype=float)\n    eps = 1e-9\n    remaining = bins_remain_cap - item\n    feasible = remaining >= 0\n    priority = np.full(n, -np.inf, dtype=float)\n\n    # Base: favor bins that leave little free space\n    priority[feasible] = 1.0 / (remaining[feasible] + eps)\n\n    # Tie\u2011break: slight negative bias for lower indices,\n    # tiny positive offset to resolve exact ties\n    idx = np.arange(n, dtype=float)\n    bias = 1e-5\n    tiny = 1e-12\n    priority[feasible] -= idx[feasible] * bias\n    priority[feasible] += idx[feasible] * tiny\n\n    # Deterministic jitter using golden ratio (low\u2011discrepancy sequence)\n    phi = 0.6180339887498949\n    jitter_scale = 1e-9  # scaled by item size below\n    jitter = np.mod(phi * (idx + 1) * item, 1.0) * jitter_scale * item\n    priority[feasible] += jitter[feasible]\n\n    # Small random jitter for exploration (no fixed seed)\n    rnd = np.random.default_rng()\n    random_jitter = rnd.random(n) * 1e-8 * item\n    priority[feasible] += random_jitter[feasible]\n\n    return priority",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 22.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response4.txt_stdout.txt",
    "code_path": "problem_iter11_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Scores bins by inverse remaining capacity, low-index bias, and jitter.\n    \"\"\"\n    rng = np.random.default_rng(42)  # deterministic jitter for reproducibility\n    n = bins_remain_cap.size\n    if n == 0:\n        return np.empty(0, dtype=float)\n\n    eps = 1e-12\n    remaining = bins_remain_cap - item\n    feasible = remaining >= 0\n\n    priority = np.full(n, -np.inf, dtype=float)\n    if not np.any(feasible):\n        return priority\n\n    base = 1.0 / (remaining[feasible] + eps)          # inverse leftover\n    bias = np.arange(n)[feasible] * 1e-6                # low-index bias\n    jitter = rng.random(feasible.sum()) * 0.01 * item  # exploration jitter\n    idx_offset = np.arange(n)[feasible] * 1e-12        # tiny tie\u2011break\n\n    priority[feasible] = base - bias + jitter + idx_offset\n    return priority",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.068607897885915,
    "SLOC": 17.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response5.txt_stdout.txt",
    "code_path": "problem_iter11_code5.py",
    "code": "import numpy as np\n\n_rng = np.random.default_rng(42)\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Inverse leftover with index bias and reproducible jitter for online BPP.\"\"\"\n    n = bins_remain_cap.size\n    if n == 0:\n        return np.empty(0, dtype=float)\n    eps = 1e-9\n    remaining = bins_remain_cap - item\n    feasible = remaining >= 0\n    inv = 1.0 / (remaining + eps)\n    bias = -np.arange(n) * 1e-5\n    jitter = _rng.random(n) * 0.01 * item\n    det_jitter = ((np.arange(n) * 31 + int(item * 1e6)) % 1000) * 1e-15\n    priority = np.full(n, -np.inf, dtype=float)\n    priority[feasible] = inv[feasible] + bias[feasible] + jitter[feasible] + det_jitter[feasible]\n    return priority",
    "response_id": 5,
    "tryHS": false,
    "obj": 3.071400079776621,
    "SLOC": 14.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response6.txt_stdout.txt",
    "code_path": "problem_iter11_code6.py",
    "code": "import numpy as np\n\n_rng = np.float64(np.random.default_rng(42).random())\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray,\n                epsilon: float = 1e-9,\n                index_weight: float = 1e-5,\n                jitter_factor: float = 0.01,\n                seed: int = None) -> np.ndarray:\n    \"\"\"Score bins by inverse leftover, index bias, and deterministic jitter.\"\"\"\n    n = bins_remain_cap.size\n    if n == 0:\n        return np.empty(0, dtype=float)\n    remaining = bins_remain_cap - item\n    feasible = remaining >= 0\n    priority = np.full(n, -np.inf, dtype=float)\n    base = 1.0 / (remaining[feasible] + epsilon)\n    idx = np.arange(n)[feasible]\n    bias = -idx * index_weight\n    tiny = idx * 1e-12\n    rng = np.random.default_rng(seed) if seed is not None else _rng\n    jitter = rng.random(n)[feasible] * jitter_factor * item\n    priority[feasible] = base + bias + tiny + jitter\n    return priority",
    "response_id": 6,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 22, in priority_v2\n    # small random jitter for exploration\nAttributeError: 'numpy.float64' object has no attribute 'random'\n19\n3\n"
  },
  {
    "stdout_filepath": "problem_iter11_response7.txt_stdout.txt",
    "code_path": "problem_iter11_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Score bins by tight fit, low-index bias, deterministic golden\u2011ratio jitter, plus small random noise.\"\"\"\n    caps = np.asarray(bins_remain_cap, dtype=float)\n    n = caps.size\n    if n == 0:\n        return np.empty(0, dtype=float)\n    eps = 1e-9\n    remaining = caps - item\n    feasible = remaining >= 0\n    priority = np.full(n, -np.inf, dtype=float)\n    # core inverse leftover score\n    priority[feasible] = 1.0 / (remaining[feasible] + eps)\n    # bias toward lower\u2011index bins\n    idx = np.arange(n, dtype=float)\n    priority[feasible] -= idx[feasible] * 1e-5\n    # deterministic jitter using golden ratio\n    phi = 0.6180339887498949\n    jitter_det = np.mod(phi * (idx + 1) * item, 1.0) * 0.01 * item\n    priority[feasible] += jitter_det[feasible]\n    # small random jitter for exploration\n    jitter_rand = np.random.random(n) * 0.001 * item\n    priority[feasible] += jitter_rand[feasible]\n    return priority",
    "response_id": 7,
    "tryHS": false,
    "obj": 3.1611487834064667,
    "SLOC": 18.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response8.txt_stdout.txt",
    "code_path": "problem_iter11_code8.py",
    "code": "import numpy as np\n\n_phi = 0.6180339887498949\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Priority via inverse leftover, index bias, and deterministic golden\u2011ratio jitter.\"\"\"\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)\n    n = bins_remain_cap.size\n    if n == 0:\n        return np.empty(0, dtype=float)\n    eps = 1e-9\n    remaining = bins_remain_cap - item\n    feasible = remaining >= 0\n    priority = np.full(n, -np.inf, dtype=float)\n    idx = np.arange(n, dtype=float)\n    primary = 1.0 / (remaining + eps)\n    bias = -idx * 1e-5\n    jitter = ((_phi * (idx + 1) * item) % 1.0) * 1e-6 * item\n    priority[feasible] = primary[feasible] + bias[feasible] + jitter[feasible]\n    return priority",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response9.txt_stdout.txt",
    "code_path": "problem_iter11_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Score bins by inverse leftover, index bias, and capacity\u2011scaled jitter.\"\"\"\n    n = bins_remain_cap.size\n    if n == 0:\n        return np.empty(0, dtype=float)\n    eps = 1e-9\n    # remaining capacity after placing the item\n    remaining = bins_remain_cap - item\n    feasible = remaining >= 0\n    # base best\u2011fit score: tighter fit \u2192 higher priority\n    priority = np.full(n, -np.inf, dtype=float)\n    priority[feasible] = 1.0 / (remaining[feasible] + eps)\n    # deterministic tie\u2011breaker: prefer lower index\n    priority[feasible] -= np.arange(n)[feasible] * 1e-6\n    # stochastic exploration: jitter scaled by residual capacity proportion\n    if feasible.any():\n        rng = np.random.default_rng()\n        max_rem = bins_remain_cap.max()\n        scale = (remaining[feasible] / (max_rem + eps)) * 0.01\n        jitter = rng.random(feasible.sum()) * scale\n        priority[feasible] += jitter\n    return priority",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.038691663342641,
    "SLOC": 17.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  }
]