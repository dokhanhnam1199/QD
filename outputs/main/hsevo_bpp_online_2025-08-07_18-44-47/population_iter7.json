[
  {
    "stdout_filepath": "problem_iter5_response0.txt_stdout.txt",
    "code_path": "problem_iter5_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Score bins by inverse leftover capacity with tiny deterministic and random tie\u2011breakers; infeasible bins get -inf.\"\"\"\n    if bins_remain_cap.size == 0:\n        return np.empty(0, dtype=float)\n    EPSILON = 0.1          # chance to use pure random exploration\n    EPS = 1e-9             # avoid division by zero\n    RAND_SCALE = 1e-6      # small random jitter factor\n    feasible = bins_remain_cap >= item\n    leftover = bins_remain_cap - item\n    base = np.where(feasible, 1.0 / (leftover + EPS), -np.inf)\n    # deterministic tie\u2011break using bin index (ensures uniqueness)\n    tie_break = np.arange(bins_remain_cap.shape[0]) * 1e-12\n    # tiny random jitter proportional to item size\n    jitter = np.where(feasible, np.random.rand(bins_remain_cap.shape[0]), 0.0) * RAND_SCALE * item\n    deterministic = base + tie_break + jitter\n    random_score = np.where(feasible, np.random.rand(bins_remain_cap.shape[0]), -np.inf)\n    return random_score if np.random.rand() < EPSILON else deterministic",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.208216992421225,
    "SLOC": 14.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response1.txt_stdout.txt",
    "code_path": "problem_iter5_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Score feasible bins by inverse leftover capacity, tie\u2011break by bin index.\"\"\"\n    if bins_remain_cap.size == 0:\n        return np.empty_like(bins_remain_cap, dtype=float)\n    priors = np.full(bins_remain_cap.shape, -np.inf, dtype=float)\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        return priors\n    residual = bins_remain_cap[feasible] - item\n    epsilon = 1e-9\n    base = 1.0 / (residual + epsilon)\n    idx = np.nonzero(feasible)[0].astype(float)\n    tie_break = idx * 1e-12\n    priors[feasible] = base + tie_break\n    return priors",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 14.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response2.txt_stdout.txt",
    "code_path": "problem_iter5_code2.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Inverse leftover capacity priority with deterministic tie-breaker and optional noise.\n    \"\"\"\n    if bins_remain_cap.size == 0:\n        return np.empty_like(bins_remain_cap, dtype=float)\n    SMALL_EPS = 1e-12\n    EPSILON = 0.05\n    RANDOM_NOISE = 0.01\n    rng = np.random.default_rng()\n    feasible = bins_remain_cap >= item\n    residual = bins_remain_cap - item\n    deterministic = np.where(feasible, 1.0 / (residual + SMALL_EPS), -np.inf)\n    bin_indices = np.arange(bins_remain_cap.size)\n    deterministic += np.where(feasible, bin_indices * 1e-9, 0)\n    deterministic += np.where(feasible, rng.random(bins_remain_cap.shape) * RANDOM_NOISE, 0)\n    random_scores = np.where(feasible, rng.random(bins_remain_cap.shape), -np.inf)\n    return random_scores if rng.random() < EPSILON else deterministic",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.198244914240141,
    "SLOC": 15.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response3.txt_stdout.txt",
    "code_path": "problem_iter5_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, rng: np.random.Generator = None) -> np.ndarray:\n    \"\"\"Score bins by inverse leftover capacity, penalizing infeasibles, with tiny item\u2011scaled jitter.\"\"\"\n    if bins_remain_cap.size == 0:\n        return np.empty(0, dtype=float)\n    if rng is None:\n        rng = np.random.default_rng(0)\n    residual = bins_remain_cap - item\n    feasible = residual >= 0\n    eps = 1e-12\n    base = np.where(feasible, 1.0 / (residual + eps), -np.inf)\n    jitter = rng.random(bins_remain_cap.shape) * eps * item\n    bias = np.arange(bins_remain_cap.shape[0]) * eps * 0.1\n    return base + jitter + bias",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response4.txt_stdout.txt",
    "code_path": "problem_iter5_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Inverse leftover with deterministic index bias and tiny noise.\"\"\"\n    # Combination of inverse leftover, deterministic tie\u2011breaker, and tiny noise\n    if bins_remain_cap.size == 0:\n        return np.empty_like(bins_remain_cap, dtype=float)\n    residual = bins_remain_cap - item\n    eps = 1e-6\n    base = 1.0 / (residual + eps)\n    priors = np.where(residual >= 0, base, -np.inf)\n    priors += np.arange(bins_remain_cap.size) * 1e-5\n    rng = np.random.default_rng(int(item * 1e6) + 12345)\n    priors += rng.random(bins_remain_cap.size) * 1e-6 * item\n    return priors",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response5.txt_stdout.txt",
    "code_path": "problem_iter5_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Return priority per bin using inverse leftover capacity, penalizing infeasible bins, and deterministic tie\u2011break by bin index.\"\"\"\n    if bins_remain_cap.size == 0:\n        return bins_remain_cap\n    eps = 1e-12\n    fits = bins_remain_cap >= item\n    leftover = bins_remain_cap - item\n    inv = 1.0 / (leftover + eps)\n    idx = np.arange(bins_remain_cap.size)\n    tie_break = -idx * 1e-8 * item\n    return np.where(fits, inv + tie_break, -np.inf)",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response6.txt_stdout.txt",
    "code_path": "problem_iter5_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Score bins for online BPP: inverse leftover with deterministic tie\u2011breaker.\"\"\"\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)\n    if bins_remain_cap.size == 0:\n        return np.empty(0, dtype=float)\n    residual = bins_remain_cap - item\n    eps = 1e-9\n    feasible = residual >= 0\n    base_score = np.where(feasible, 1.0 / (residual + eps), -np.inf)\n    jitter = 1e-10 * item * np.arange(bins_remain_cap.size)\n    return base_score + jitter",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response7.txt_stdout.txt",
    "code_path": "problem_iter5_code7.py",
    "code": "import numpy as np\n\n# deterministic RNG for reproducible jitter\n_rng = np.random.default_rng(42)\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Score bins: inverse leftover, tiny index bias, and scaled random jitter.\"\"\"\n    n = bins_remain_cap.size\n    if n == 0:\n        return np.empty(0, dtype=float)\n    eps = 1e-9\n    remaining = bins_remain_cap - item\n    feasible = remaining >= 0\n    priority = np.full(n, -np.inf, dtype=float)\n    priority[feasible] = 1.0 / (remaining[feasible] + eps)\n    # deterministic tie\u2011breaker: prefer lower index\n    priority[feasible] += -np.arange(n)[feasible] * 1e-5\n    # tiny reproducible jitter proportional to item size\n    jitter = _rng.random(n) * 0.01 * item\n    priority[feasible] += jitter[feasible]\n    return priority",
    "response_id": 7,
    "tryHS": true,
    "obj": 3.071400079776621,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response8.txt_stdout.txt",
    "code_path": "problem_iter5_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priors = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        return priors\n    residual = bins_remain_cap[feasible] - item\n    epsilon = 1e-9\n    base = 1.0 / (residual + epsilon)\n    tie = (np.nonzero(feasible)[0].astype(float) + 1) * 1e-12\n    priors[feasible] = base + tie\n    return priors",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response9.txt_stdout.txt",
    "code_path": "problem_iter5_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Inverse leftover capacity with deterministic index tie\u2011breaker; infeasible bins get -inf.\"\"\"\n    if bins_remain_cap.size == 0:\n        return np.empty_like(bins_remain_cap, dtype=float)\n    fits = bins_remain_cap >= item\n    leftover = bins_remain_cap - item\n    eps = 1e-12\n    inv = 1.0 / (leftover + eps)\n    # deterministic tie\u2011breaker: tiny increasing offset per bin\n    tie = 1e-12 * item * np.arange(bins_remain_cap.shape[0])\n    priorities = np.where(fits, inv + tie, -np.inf)\n    return priorities",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response0.txt_stdout.txt",
    "code_path": "problem_iter6_code0.py",
    "code": "import numpy as np\n\n_rng = np.random.default_rng(123456789)\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Compute priority scores for bins in online bin packing.\n\n    Scores favor bins that become highly filled after placing `item` and leave little leftover.\n    Infeasible bins receive -inf. A deterministic tie\u2011breaker prefers lower indices, and a tiny\n    reproducible jitter proportional to `item` resolves remaining ties.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        Remaining capacities of each bin.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin.\n    \"\"\"\n    n = bins_remain_cap.size\n    if n == 0:\n        return np.empty(0, dtype=float)\n    eps = 1e-12\n    feasible = bins_remain_cap >= item\n    priority = np.full(n, -np.inf, dtype=float)\n    if not np.any(feasible):\n        return priority\n    remaining_after = bins_remain_cap[feasible] - item\n    used_after = 1.0 - bins_remain_cap[feasible] + item\n    base = used_after / (remaining_after + eps)\n    tie = -np.arange(n)[feasible] * 1e-8\n    jitter = _rng.random(remaining_after.shape) * 1e-6 * item\n    priority[feasible] = base + tie + jitter\n    return priority",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 16.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter7_response0.txt_stdout.txt",
    "code_path": "problem_iter7_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float,\n                bins_remain_cap: np.ndarray,\n                eps: float = 5.952074976279586e-07,\n                bias_factor: float = 0.0007605605067066339,\n                jitter_factor: float = 0.05477954667842493,\n                scaling_factor: float = 1.123540946870861) -> np.ndarray:\n    \"\"\"Score bins: inverse leftover, tiny index bias, and scaled random jitter.\"\"\"\n    n = bins_remain_cap.size\n    if n == 0:\n        return np.empty(0, dtype=float)",
    "response_id": 0,
    "tryHS": true,
    "obj": 4.487435181491823,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  }
]