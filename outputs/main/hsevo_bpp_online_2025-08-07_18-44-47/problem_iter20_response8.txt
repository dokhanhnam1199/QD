```python
import numpy as np

# Adaptive priority for online bin packing: combines inverse leftover,
# mean‑load bias, and variance‑scaled jitter for dynamic tie‑breaking.
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Adaptive inverse‑leftover scoring with load bias and variance‑scaled jitter."""
    n = bins_remain_cap.size
    if n == 0:
        return np.empty(0, dtype=float)
    eps = 1e-12
    remaining = bins_remain_cap - item
    feasible = remaining >= 0
    priority = np.full(n, -np.inf, dtype=float)
    if not np.any(feasible):
        return priority

    # Base: inverse leftover capacity (smaller leftover → higher score)
    inv_left = 1.0 / (remaining[feasible] + eps)

    # Load bias: favour bins whose remaining capacity is close to the average
    mean_rem = bins_remain_cap.mean()
    dist = np.abs(bins_remain_cap[feasible] - mean_rem)
    max_dist = dist.max() if dist.size else 1.0
    load_bias = 1.0 - dist / (max_dist + eps)

    # Adaptive jitter: magnitude proportional to variance of bin loads
    var_rem = bins_remain_cap.var()
    jitter_scale = np.sqrt(var_rem) / (bins_remain_cap.max() + eps)
    rng = np.random.default_rng()
    jitter = rng.random(inv_left.shape) * jitter_scale * item * 0.01

    # Dynamic weight blending – more variance gives more jitter influence
    w_jitter = var_rem / (var_rem + 1.0)
    w_base = 1.0 - w_jitter
    w_bias = 0.01

    priority[feasible] = w_base * inv_left + w_bias * load_bias + w_jitter * jitter
    return priority
```
