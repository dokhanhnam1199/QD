{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code only and do not add comments into the code. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Score bins by inverse leftover + tightness, adding variance\u2011scaled jitter,\n    golden\u2011ratio deterministic jitter, and tiny index bias. Infeasible bins get -inf.\n    \"\"\"\n    # Ensure array type and get bin count\n    bins = np.asarray(bins_remain_cap, dtype=float)\n    n = bins.size\n    if n == 0:\n        return np.empty(0, dtype=float)\n\n    # Remaining capacity after placing the item\n    remaining = bins - item\n    feasible = remaining >= 0\n    scores = np.full(n, -np.inf, dtype=float)\n    if not np.any(feasible):\n        return scores\n\n    eps = 1e-12\n    idx = np.arange(n, dtype=float)\n    rem_feas = remaining[feasible]\n\n    # Primary inverse\u2011leftover (best\u2011fit core)\n    inv_leftover = 1.0 / (rem_feas + eps)\n\n    # Secondary tightness term encourages higher fill\n    tightness = item / (item + rem_feas + eps)\n\n    # Deterministic golden\u2011ratio jitter (tiny perturbation)\n    phi = (1 + np.sqrt(5.0)) / 2.0\n    phi_jitter = ((phi * (idx[feasible] + 1.0) * item) % 1.0) * 1e-6 * item\n\n    # Tiny index bias to keep deterministic order on ties\n    bias = -idx[feasible] * 1e-6\n\n    # Random jitter scaled by coefficient of variation of remaining capacities\n    mean = np.mean(rem_feas)\n    std = np.std(rem_feas)\n    coeff = std / (mean + eps)\n    jitter_weight = 0.01 * (1.0 + coeff)\n    rng = np.random.default_rng()\n    rand_jitter = rng.random(rem_feas.shape) * jitter_weight * item\n\n    # Combine components\n    scores[feasible] = inv_leftover + tightness + phi_jitter + rand_jitter + bias\n    return scores\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n_rng = np.random.default_rng()\n\n    \"\"\"Score bins using inverse leftover, tightness, variance\u2011scaled jitter, and tiny tie\u2011breakers.\"\"\"\n    bins = np.asarray(bins_remain_cap, dtype=float)\n    n = bins.size\n    if n == 0:\n        return np.empty(0, dtype=float)\n    eps = 1e-9\n    remaining = bins - item\n    feasible = remaining >= 0\n    scores = np.full(n, -np.inf, dtype=float)\n    if not feasible.any():\n        return scores\n    rem_f = remaining[feasible]\n    idx = np.arange(n, dtype=float)\n    idx_f = idx[feasible]\n    inv_leftover = 1.0 / (rem_f + eps)\n    tightness = item / (item + rem_f + eps)\n    bias = -idx_f * 1e-6\n    phi = (1 + np.sqrt(5.0)) / 2.0\n    phi_jitter = ((phi * (idx_f + 1) * item) % 1.0) * 1e-6 * item\n    mean_rem = np.mean(rem_f)\n    std_rem = np.std(rem_f)\n    coeff = std_rem / (mean_rem + eps)\n    jitter = _rng.random(rem_f.shape) * item * (0.01 + coeff * 0.01)\n    scores[feasible] = inv_leftover + tightness + bias + phi_jitter + jitter\n    return scores\n\n### Analyze & experience\n- - **Heuristic\u202f1 (best) vs Heuristic\u202f20 (worst):**\u202fHeuristic\u202f1 uses a clean inverse\u2011leftover score, a variance\u2011scaled jitter, and a tiny index bias \u2013 minimal, robust, and stateless.\u202fHeuristic\u202f20 adds a mean\u2011deviation penalty, extra jitter logic, and a placeholder comment, increasing code complexity and introducing aggressive bias that can hurt packing quality.  \n- **Heuristic\u202f2 (2nd) vs Heuristic\u202f19 (2nd\u2011worst):**\u202fHeuristic\u202f2 is identical to Heuristic\u202f1 (simple, effective).\u202fHeuristic\u202f19 contains only a skeleton with many hyper\u2011parameters and no scoring logic after the early\u2011return, thus providing no useful decision information.  \n- **Heuristic\u202f1 vs Heuristic\u202f2:**\u202fBoth are identical copies; their scores, jitter, and bias are exactly the same, confirming the top\u2011rank stability of this pattern.  \n- **Heuristic\u202f3 vs Heuristic\u202f4:**\u202fHeuristic\u202f3 remains the simple baseline.\u202fHeuristic\u202f4 introduces a running item\u2011average, a tightness factor, and jitter that adapts to the deviation from the average. This adds statefulness and extra computation, which can improve adaptivity on some instances but also creates overhead and potential drift.  \n- **Heuristic\u202f19 vs Heuristic\u202f20:**\u202fHeuristic\u202f19 is an incomplete placeholder (no functional scoring).\u202fHeuristic\u202f20, though fully implemented, adds a mean\u2011distance penalty that can over\u2011penalize feasible bins, making it less reliable than the baseline.\n- \n- **Keywords:** feasibility, inverse\u2011leftover, size\u2011scaled jitter; **Advice:** filter infeasible bins, score\u202f=\u202f1/(remaining+\u03b5)+\u03c3\u00b7itemSize\u00b7N(0,1); **Avoid:** fixed RNG seed, deterministic index bias; **Explanation:** keeps decisions stochastic yet capacity\u2011aware.  \n- **Keywords:** vectorized, minimal state; **Advice:** compute scores with NumPy broadcasting, early\u2011return on empty input; **Avoid:** per\u2011call RNG, mutable globals; **Explanation:** ensures speed and reproducibility.  \n- **Keywords:** tie\u2011break, tiny bias; **Advice:** add a 1e\u20119 constant when scores tie; **Avoid:** large deterministic offsets, over\u2011parameterisation; **Explanation:** gives reproducible tie\u2011breaks without biasing selection.  \n- **Keywords:** safeguards, docs; **Advice:** guard division with \u03b5, type\u2011hint returns, concise docstring; **Avoid:** missing edge\u2011cases, vague comments; **Explanation:** prevents runtime errors and aids maintenance.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}