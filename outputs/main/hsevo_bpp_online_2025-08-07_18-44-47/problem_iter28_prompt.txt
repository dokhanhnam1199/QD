{"system": "You are an expert in code review. Your task extract all threshold, weight or hardcode variable of the function make it become default parameters.", "user": "[code]\nimport numpy as np\n\n_item_avg = None\n_item_count = 1\n_rng = np.random.default_rng()\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Inverse leftover with variance\u2011scaled jitter and adaptive item\u2011size bias for online bin packing.\"\"\"\n    n = bins_remain_cap.size\n    if n == 0:\n        return np.empty(0, dtype=float)\n    eps = 1e-12\n    remaining = bins_remain_cap - item\n    feasible = remaining >= 0\n    priority = np.full(n, -np.inf, dtype=float)\n    if not feasible.any():\n        return priority\n    global _item_avg, _item_count\n    if _item_avg is None:\n        _item_avg = item\n        _item_count = 1\n    else:\n        _item_count += 1\n        _item_avg += (item - _item_avg) / _item_count\n    dev_factor = abs(item - _item_avg) / (_item_avg + eps)\n    base = 1.0 / (remaining[feasible] + eps)\n    tight = item / (item + remaining[feasible] + eps)\n    score = 0.7 * base + 0.3 * tight\n    # variance\u2011scaled jitter\n    var_rem = np.var(remaining[feasible])\n    jitter_scale = item * 0.01 * (1.0 + np.sqrt(var_rem)) * (1.0 + dev_factor)\n    jitter = (_rng.random(feasible.sum()) - 0.5) * jitter_scale\n    bias = -np.arange(n)[feasible] * 1e-6\n    priority[feasible] = score + jitter + bias\n    return priority\n\nNow extract all threshold, weight or hardcode variable of the function make it become default parameters and give me a 'parameter_ranges' dictionary representation. Key of dict is name of variable. Value of key is a tuple in Python MUST include 2 float elements, first element is begin value, second element is end value corresponding with parameter.\n\n- Output code only and enclose your code with Python code block: ```python ... ```.\n- Output 'parameter_ranges' dictionary only and enclose your code with other Python code block: ```python ... ```."}