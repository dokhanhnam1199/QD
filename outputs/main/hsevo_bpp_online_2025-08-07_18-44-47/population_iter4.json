[
  {
    "stdout_filepath": "problem_iter2_response0.txt_stdout.txt",
    "code_path": "problem_iter2_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    epsilon = 1e-9\n    leftover = bins_remain_cap - item\n    fit = bins_remain_cap >= item\n    base = np.where(fit, 1.0/(leftover+epsilon), -np.inf)\n    noise = np.random.rand(len(bins_remain_cap)) * 0.1 * item\n    priorities = base + noise\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.228161148783416,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response1.txt_stdout.txt",
    "code_path": "problem_iter2_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    EPSILON = 0.1\n    SMALL_EPS = 1e-6\n    RANDOM_NOISE = 0.01\n    feasible = bins_remain_cap >= item\n    residual = bins_remain_cap - item\n    deterministic = np.where(feasible, 1.0 / (residual + SMALL_EPS), -np.inf)\n    deterministic += np.where(feasible, np.random.rand(*bins_remain_cap.shape) * RANDOM_NOISE, 0)\n    random_scores = np.where(feasible, np.random.rand(*bins_remain_cap.shape), -np.inf)\n    return random_scores if np.random.rand() < EPSILON else deterministic",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.11846828879138,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response2.txt_stdout.txt",
    "code_path": "problem_iter2_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Score bins: inverse residual capacity with tiny random tie\u2011breaker; infeasible \u2192 -inf.\"\"\"\n    priors = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        return priors\n    residual = bins_remain_cap[feasible] - item\n    epsilon = 1e-9\n    base = 1.0 / (residual + epsilon)\n    rng = np.random.default_rng()\n    noise = rng.random(base.shape) * 1e-6\n    priors[feasible] = base + noise\n    return priors",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response3.txt_stdout.txt",
    "code_path": "problem_iter2_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Inverse leftover capacity with tiny random tie\u2011breakers; infeasible bins get -inf.\"\"\"\n    if bins_remain_cap.size == 0:\n        return np.empty_like(bins_remain_cap, dtype=float)\n    residual = bins_remain_cap - item\n    eps = 1e-6\n    noise = np.random.rand(bins_remain_cap.size) * 0.01 * item\n    return np.where(residual >= 0, 1.0 / (residual + eps) + noise, -np.inf)",
    "response_id": 3,
    "tryHS": true,
    "obj": 3.1013163143199183,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response4.txt_stdout.txt",
    "code_path": "problem_iter2_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Priority based on inverse leftover capacity plus small random noise to break ties; infeasible bins are -inf.\"\"\"\n    fit = bins_remain_cap >= item\n    if fit.any():\n        left = bins_remain_cap - item\n        epsilon = 1e-6\n        inv_left = 1.0/(left[fit] + epsilon)\n        noise = np.random.rand(np.count_nonzero(fit)) * 0.1 * item\n        priorities = np.full(bins_remain_cap.shape, -np.inf, dtype=float)\n        priorities[fit] = inv_left + noise\n    else:\n        priorities = np.full(bins_remain_cap.shape, -np.inf, dtype=float)\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 3.9888312724371757,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response5.txt_stdout.txt",
    "code_path": "problem_iter2_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Inverse\u2011leftover priority with tiny random tie\u2011breaker.\"\"\"\n    # Use inverse leftover priority; small random noise breaks ties\n    if bins_remain_cap.size == 0:\n        return bins_remain_cap\n    eps = 1e-12\n    fits = bins_remain_cap >= item\n    leftover = bins_remain_cap - item\n    inv = 1.0 / (leftover + eps)\n    tie = np.random.rand(len(bins_remain_cap)) * 1e-6 * item\n    priorities = np.where(fits, inv + tie, -np.inf)\n    return priorities",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response6.txt_stdout.txt",
    "code_path": "problem_iter2_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Inverse leftover score with tiny random jitter for tie-breaking.\"\"\"\n    eps = 1e-9\n    residual = bins_remain_cap - item\n    feasible = residual >= 0\n    score = np.where(feasible, 1.0 / (residual + eps), -np.inf)\n    jitter = np.random.random(bins_remain_cap.shape) * 1e-6\n    return score + jitter",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response7.txt_stdout.txt",
    "code_path": "problem_iter2_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Inverse leftover score with tiny random tie\u2011breaker; infeasible bins get -inf.\"\"\"\n    # Combine inverse-remaining-capacity scoring with stochastic tie\u2011breaking.\n    if bins_remain_cap.size == 0:\n        return np.array([], dtype=float)\n    eps = 1e-9\n    noise_factor = 1e-3\n    leftover = bins_remain_cap - item\n    feasible = leftover >= 0\n    base = np.where(feasible, 1.0 / (leftover + eps), -np.inf)\n    noise = np.random.rand(bins_remain_cap.shape[0]) * noise_factor * item\n    return np.where(feasible, base + noise, -np.inf)",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.27802153968888,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response8.txt_stdout.txt",
    "code_path": "problem_iter2_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.1) -> np.ndarray:\n    \"\"\"Score bins: high if item fits tightly, small random tie\u2011breaker.\"\"\"\n    caps = np.asarray(bins_remain_cap, dtype=float)\n    priorities = np.full_like(caps, -np.inf, dtype=float)\n    feasible = caps >= item\n    if not np.any(feasible):\n        return priorities\n    leftover = caps[feasible] - item\n    # deterministic: inverse leftover (tight fit) yields higher score\n    deterministic = 1.0 / (leftover + 1e-12)\n    # random perturbation for exploration/tie\u2011breaking\n    random_score = np.random.rand(np.count_nonzero(feasible))\n    priorities[feasible] = (1 - epsilon) * deterministic + epsilon * random_score\n    return priorities",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.178300757877951,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response9.txt_stdout.txt",
    "code_path": "problem_iter2_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines almost-full-fit priority (1/(remaining+eps)) with small random perturbation and bin-index tie-breaker for deterministic yet exploratory bin selection.\n    \"\"\"\n    n = bins_remain_cap.size\n    if n == 0:\n        return np.empty(0, dtype=float)\n    eps = 1e-9\n    remaining = bins_remain_cap - item\n    feasible = remaining >= 0\n    priority = np.full(n, -np.inf, dtype=float)\n    priority[feasible] = 1.0 / (remaining[feasible] + eps)\n    noise = np.random.rand(n) * 0.01 * item\n    tie_break = -np.arange(n) * 1e-5\n    priority[feasible] += noise[feasible] + tie_break[feasible]\n    return priority",
    "response_id": 9,
    "tryHS": false,
    "obj": 3.1611487834064667,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response0.txt_stdout.txt",
    "code_path": "problem_iter3_code0.py",
    "code": "import numpy as np\n\ndef _compute_residual(item, caps):\n    return caps - item\n\ndef _feasibility_mask(residual):\n    return residual >= 0\n\ndef _base_score(residual):\n    return -residual\n\ndef _fill_score(caps):\n    return -caps\n\ndef _tie_breaker(indices, eps=1e-12):\n    return -eps * indices\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Deterministic best\u2011fit priority for online bin packing.\n\n    Higher scores correspond to bins that can accommodate the item,\n    leave the smallest residual capacity after placement, are already\n    more filled, and have smaller indices as a deterministic tie\u2011breaker.\n    \"\"\"\n    if bins_remain_cap.size == 0:\n        return np.empty_like(bins_remain_cap, dtype=float)\n    residual for clarity\n    residual = _compute_residual(item, bins_remain_cap)\n    feasible = _feasibility_mask(residual)\n    base = _base_score(residual)\n    fill = _fill_score(bins_remain_cap)\n    w1 = 1.0\n    w2 = 0.5\n    combined = w1 * base + w2 * fill\n    indices = np.arange(bins_remain_cap.size)\n    score = combined + _tie_breaker(indices)\n    return np.where(feasible, score, -np.inf)",
    "response_id": 0,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 9, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 27\n    residual for clarity\n             ^^^\nSyntaxError: invalid syntax\nTraceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/SLOC.py\", line 7, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 27\n    residual for clarity\n             ^^^\nSyntaxError: invalid syntax\nTraceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/cyclomatic_complexity.py\", line 7, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 27\n    residual for clarity\n             ^^^\nSyntaxError: invalid syntax\n"
  },
  {
    "stdout_filepath": "problem_iter4_response0.txt_stdout.txt",
    "code_path": "problem_iter4_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, eps: float = 3.4723251054610314e-05, noise_factor: float = 0.03679152813035629) -> np.ndarray:\n    \"\"\"Inverse leftover capacity with tiny random tie\u2011breakers; infeasible bins get -inf.\"\"\"\n    if bins_remain_cap.size == 0:\n        return np.empty_like(bins_remain_cap, dtype=float)",
    "response_id": 0,
    "tryHS": true,
    "obj": 4.487435181491823,
    "SLOC": 3.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  }
]