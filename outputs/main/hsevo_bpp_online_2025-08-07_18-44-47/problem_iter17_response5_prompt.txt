{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code only and do not add comments into the code. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Score bins by inverse leftover, low-index bias, deterministic golden\u2011ratio jitter, and small random jitter.\"\"\"\n    caps = np.asarray(bins_remain_cap, dtype=float)\n    n = caps.size\n    if n == 0:\n        return np.empty(0, dtype=float)\n    eps = 1e-12\n    remaining = caps - item\n    feasible = remaining >= 0\n    priority = np.full(n, -np.inf, dtype=float)\n    if not np.any(feasible):\n        return priority\n    idx = np.arange(n, dtype=float)\n    base = 1.0 / (remaining[feasible] + eps)\n    bias = idx[feasible] * 1e-5\n    phi = 0.6180339887498949\n    jitter_det = np.mod(phi * (idx[feasible] + 1) * item, 1.0) * 0.01 * item\n    jitter_rand = np.random.random(feasible.sum()) * 0.001 * item\n    priority[feasible] = base - bias + jitter_det + jitter_rand\n    return priority\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Inverse leftover, low-index bias, deterministic sinusoidal jitter, and item\u2011scaled pseudo\u2011random jitter.\"\"\"\n    n = bins_remain_cap.size\n    if n == 0:\n        return np.empty(0, dtype=float)\n    eps = 1e-9\n    remaining = bins_remain_cap - item\n    feasible = remaining >= 0\n    priority = np.full(n, -np.inf, dtype=float)\n    if not np.any(feasible):\n        return priority\n    indices = np.arange(n)\n    primary = 1.0 / (remaining[feasible] + eps)\n    bias = -indices[feasible] * 1e-6\n    det_jitter = ((np.sin((item + indices[feasible]) * 7.0) + 1) * 0.5) * 1e-9 * item\n    int_item = int(item * 1e6)\n    # compute deterministic pseudo\u2011random jitter\n    pseudo = ((int_item + 31 * indices[feasible] + 7) % 2147483647) / 2147483647.0\n    rand_jitter = pseudo * 0.01 * item\n    priority[feasible] = primary + bias + det_jitter + rand_jitter\n    return priority\n\n### Analyze & experience\n- Comparing the best (Heuristics\u202f1) vs the worst (Heuristics\u202f20), we see the best uses a module\u2011level seeded RNG for reproducible jitter, a tiny negative index bias, and simple inverse\u2011leftover scoring; the worst creates a fresh RNG each call, mixes deterministic golden\u2011ratio jitter with adaptive random jitter that depends on the current max capacity, and lacks a fixed seed, making its ordering noisy and non\u2011deterministic.  \nComparing the second best (Heuristics\u202f2) vs the second worst (Heuristics\u202f19), the pair mirrors the previous comparison \u2013 identical deterministic design versus a version that adds the same golden\u2011ratio jitter and adaptive random term, again sacrificing reproducibility and adding unnecessary scaling.  \nComparing the third best (Heuristics\u202f3) vs the third worst (Heuristics\u202f18), the third best adds a sinusoidal deterministic jitter of order\u202f1e\u20119 and keeps the same index bias; the third worst drops the index bias, uses a standard\u2011normal jitter (larger variance) and only a tiny deterministic term proportional to remaining capacity, reducing control over tie\u2011breaking.  \nComparing the fourth best (Heuristics\u202f4) vs the fourth worst (Heuristics\u202f17), the fourth best piles multiple deterministic components (golden\u2011ratio, sinusoidal) on top of a fresh random jitter each call; the fourth worst uses only a Gaussian jitter and a minuscule deterministic term, but lacks any index bias, making bin selection essentially random.  \nComparing the fifth best (Heuristics\u202f5) vs the fifth worst (Heuristics\u202f16), the fifth best combines a deterministic golden\u2011ratio jitter with a modest uniform random jitter, while the fifth worst is essentially a stub that returns an empty array after a size check \u2013 it never scores any bin.  \nComparing the sixth best (Heuristics\u202f6) vs the sixth worst (Heuristics\u202f15), the sixth best keeps a clean inverse\u2011leftover score, a modest index bias, deterministic golden\u2011ratio jitter and a simple uniform random jitter; the sixth worst introduces many hyper\u2011parameters (adaptive jitter based on leftover ratio, deterministic modular jitter, optional seed) that increase complexity without clear benefit.  \nComparing the seventh best (Heuristics\u202f7) vs the seventh worst (Heuristics\u202f14), the seventh best repeats the clean pattern of\u202f6; the seventh worst adds deterministic sinusoidal jitter and a pseudo\u2011random LCG\u2011style jitter, both of which are deterministic but introduce extra computation and tie\u2011break noise.  \nComparing the eighth best (Heuristics\u202f8) vs the eighth worst (Heuristics\u202f13), identical to the previous pair \u2013 the best stays minimal, the worst layers golden\u2011ratio, sinusoidal, and pseudo\u2011random jitter, making the score harder to predict.  \nComparing the ninth best (Heuristics\u202f9) vs the ninth worst (Heuristics\u202f12), both are deterministic (no RNG) and use inverse\u2011leftover, a negative index bias, golden\u2011ratio jitter and a sinusoidal \u201cpseudo\u2011random\u201d term; however the ninth worst repeats the same code but is placed lower, suggesting that the ranking penalizes the lack of any random component for robustness.  \nComparing the tenth best (Heuristics\u202f10) vs the tenth worst (Heuristics\u202f11), the tenth best employs deterministic sinusoidal jitter and a linear\u2011congruential pseudo\u2011random jitter, preserving reproducibility; the tenth worst adds a temperature\u2011scaled Gumbel term, a global item counter, and true random jitter, greatly increasing algorithmic complexity and making performance sensitive to parameter decay.  \nComparing adjacent ranks (1st vs\u202f2nd), they are identical, indicating the ranking likely reflects external benchmarking rather than code differences. (3rd vs\u202f4th) the third adds a tiny sinusoidal jitter while the fourth introduces multiple deterministic jitter sources and a fresh RNG, making it noisier. (Second worst vs\u202fworst) the second worst still uses the golden\u2011ratio jitter and adaptive random jitter, whereas the worst adds the same components but also a fresh RNG and scaling by max capacity, increasing stochasticity.  \nOverall: the highest\u2011ranked heuristics prioritize simplicity, deterministic tie\u2011breakers, a fixed seed for jitter, and a clear inverse\u2011leftover primary metric; lower\u2011ranked heuristics layer many jitter mechanisms, use per\u2011call RNGs, or omit essential feasibility handling, which leads to unpredictable ordering and higher computational overhead.\n- \n- **Keywords**: adaptive randomness, multi\u2011objective score, dynamic jitter, auto\u2011tuned hyper\u2011parameters.  \n- **Advice**: use a fresh RNG per call with jitter scaled to bin load, combine inverse\u2011leftover with utilization variance and future capacity forecasts, and employ learning\u2011based tie\u2011breakers instead of fixed index bias.  \n- **Avoid**: fixed RNG seeds, tiny deterministic jitter, simple low\u2011index bias, epsilon guards, and an overly minimal deterministic design.  \n- **Explanation**: richer exploration reduces systematic bias, improves bin utilization, and retains high performance while staying robust to empty or infeasible bins.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}