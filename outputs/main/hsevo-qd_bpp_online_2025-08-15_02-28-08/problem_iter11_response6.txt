```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Prioritizes exact fits, then bins with minimal scaled excess capacity.

    Combines the strength of exact fits with a tiered approach for close fits,
    using a scaled inverse of excess capacity for ranking.
    """
    epsilon = 1e-9
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins where the item can fit
    can_fit_mask = bins_remain_cap >= item

    if not np.any(can_fit_mask):
        return priorities

    # Calculate excess capacity for bins that can fit the item
    excess_capacity = bins_remain_cap[can_fit_mask] - item

    # --- Tier 1: Exact Fits ---
    # Assign a high priority (e.g., 2.0) to exact fits. This ensures they are always chosen if available.
    exact_fit_mask_local = (excess_capacity < epsilon)
    priorities[can_fit_mask][exact_fit_mask_local] = 2.0

    # --- Tier 2: Close Fits ---
    # For bins that don't fit exactly but can accommodate the item.
    close_fit_mask_local = ~exact_fit_mask_local
    
    if np.any(close_fit_mask_local):
        eligible_excess_capacity = excess_capacity[close_fit_mask_local]
        
        # Calculate a score based on the inverse of excess capacity.
        # This favors smaller excess capacities (tighter fits).
        # The score is scaled to be less than the exact fit priority (e.g., max score of 1.0).
        
        # Normalize the inverse excess capacity:
        # We want scores to be ordered by how close they are to an exact fit.
        # A simple approach is to map `1 / (excess_capacity + epsilon)` to a range [0, 1].
        # To do this, we can divide by the maximum value of `1 / (excess_capacity + epsilon)`.
        
        inverse_excess_capacities = 1.0 / (eligible_excess_capacity + epsilon)
        
        # Find the maximum inverse excess capacity among these close fits.
        # Add epsilon to max_inv_excess to avoid division by zero if all eligible_excess_capacity are large.
        max_inv_excess = np.max(inverse_excess_capacities)
        
        # Scale the scores for close fits to be in the range [0.1, 1.0].
        # The tightest close fit (max inverse_excess_capacity) gets 1.0.
        # Other fits scale down. We add a small base value (0.1) to ensure even the loosest
        # close fit has some priority if no exact fit exists.
        scaled_close_fit_scores = 0.1 + 0.9 * (inverse_excess_capacities / (max_inv_excess + epsilon))
        
        # Ensure scores are strictly less than exact fit priority
        scaled_close_fit_scores = np.minimum(scaled_close_fit_scores, 1.999)
        
        priorities[can_fit_mask][close_fit_mask_local] = scaled_close_fit_scores

    return priorities
```
