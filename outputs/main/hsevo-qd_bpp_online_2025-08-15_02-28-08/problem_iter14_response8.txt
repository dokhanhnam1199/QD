```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Prioritizes exact fits with a high score, followed by close fits using scaled inverse excess capacity.

    This heuristic combines the certainty of exact fits with a graded preference for bins
    that leave minimal residual space, ensuring clear prioritization tiers.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    can_fit_mask = bins_remain_cap >= item
    
    if np.any(can_fit_mask):
        available_bins_cap = bins_remain_cap[can_fit_mask]
        
        # Exact fit: highest priority
        exact_fit_mask = available_bins_cap == item
        if np.any(exact_fit_mask):
            priorities[can_fit_mask][exact_fit_mask] = 2.0  # High score for exact fit

        # Close fit: score based on inverse of normalized excess capacity
        non_exact_fit_mask = ~exact_fit_mask
        if np.any(non_exact_fit_mask):
            remaining_available_bins_cap = available_bins_cap[non_exact_fit_mask]
            excess_capacity = remaining_available_bins_cap - item
            
            # Normalize excess capacity for scoring
            min_excess = np.min(excess_capacity)
            max_excess = np.max(excess_capacity)
            
            if max_excess - min_excess > 1e-9:
                normalized_excess = (excess_capacity - min_excess) / (max_excess - min_excess)
            else:
                normalized_excess = np.zeros_like(excess_capacity) # All same excess, treat as 0 normalized

            # Score close fits: higher score for smaller normalized excess capacity
            # Scale scores to be less than exact fit priority (e.g., [0.1, 1.0])
            close_fit_priorities = 1.0 - (normalized_excess * 0.9) 
            
            priorities[can_fit_mask][non_exact_fit_mask] = close_fit_priorities

    return priorities
```
