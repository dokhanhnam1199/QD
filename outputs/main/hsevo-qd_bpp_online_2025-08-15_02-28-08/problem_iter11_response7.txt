```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Prioritizes bins: exact fits highest, then closest fits based on normalized inverse excess.

    Combines Exact Fit preference with a scaled Best Fit strategy.
    Exact fits receive the highest priority. Other fitting bins are prioritized
    based on the inverse of their normalized excess capacity after placement.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    can_fit_mask = bins_remain_cap >= item

    if np.any(can_fit_mask):
        fitting_bins_cap = bins_remain_cap[can_fit_mask]
        fitting_bins_indices = np.where(can_fit_mask)[0]

        # Highest priority for exact fits
        exact_fit_mask = fitting_bins_cap == item
        priorities[fitting_bins_indices[exact_fit_mask]] = 2.0

        # Medium priority for non-exact fits, based on how close they are
        non_exact_fitting_bins_cap = fitting_bins_cap[~exact_fit_mask]
        non_exact_fitting_bins_indices = fitting_bins_indices[~exact_fit_mask]

        if len(non_exact_fitting_bins_cap) > 0:
            space_after_placement = non_exact_fitting_bins_cap - item

            # Normalize differences to [0, 1] range for scoring
            min_diff = np.min(space_after_placement)
            max_diff = np.max(space_after_placement)

            if max_diff - min_diff > 1e-9:
                normalized_diff = (space_after_placement - min_diff) / (max_diff - min_diff)
            else:
                normalized_diff = np.zeros_like(space_after_placement) # All are same diff

            # Assign priorities: inverse relationship with normalized difference, scaled
            # Give higher priority to smaller differences (closer fits)
            # Scale to be less than exact fit priority (e.g., 0.1 to 1.1)
            priorities[non_exact_fitting_bins_indices] = 1.1 - normalized_diff

    return priorities
```
