```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    A mutated version of priority_v1 for the online Bin Packing Problem.

    This heuristic prioritizes bins that can exactly fit the item (zero remaining capacity after packing).
    Among bins that fit, it favors those with the minimal excess capacity (tightest fit).
    Bins with larger excess capacity are given lower scores, but still positive if they fit.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Returns:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    epsilon = 1e-9
    
    # Initialize priorities to zero (for bins where the item doesn't fit)
    priorities = np.zeros_like(bins_remain_cap)
    
    # Identify bins where the item can fit
    can_fit_mask = bins_remain_cap >= item
    
    # Calculate the difference between remaining capacity and item size for bins that can fit
    diff = bins_remain_cap[can_fit_mask] - item
    
    # Assign a very high priority to bins that provide an exact fit
    # These are bins where diff is zero or very close to zero.
    exact_fit_mask = diff < epsilon
    
    # For exact fits, assign the highest possible priority value.
    # We use a value significantly larger than any possible score from other bins.
    # The score for non-exact fits will be related to item / diff, which is bounded.
    # A very large constant or a value based on item size is appropriate.
    # Let's use a score that ensures it's greater than any other score.
    # The maximum finite score from the next step would be roughly (item + large_diff) / large_diff ~ 1,
    # or if diff is tiny, item / epsilon.
    # So, let's use something like item / epsilon * 2.
    # A simpler way is to assign a large number, but tying it to item size is better.
    # Let's assign a score proportional to item, effectively prioritizing exact fits for larger items.
    
    # The highest priority will be for bins with `diff` very close to 0.
    # We can assign a score of `item / epsilon` for these.
    # For other bins that fit, the score is `bins_remain_cap / diff`.
    # So, `(item + diff) / diff`
    
    # To ensure exact fits are always best, let's give them a score that's guaranteed to be higher.
    # For bins that fit, the score is item / (bins_remain_cap - item + epsilon) = item / (diff + epsilon)
    # For exact fits (diff approx 0), this score becomes very large.
    # Let's ensure a distinct separation.
    
    # For bins that fit:
    # If diff is effectively zero, assign a very high score.
    # Otherwise, assign a score inversely proportional to the difference.
    # A good score for non-exact fits is `item / (diff + epsilon)` which is equivalent to `bins_remain_cap / (diff + epsilon)`.
    
    # Let's combine these:
    # If diff < epsilon (exact fit): high score.
    # If diff >= epsilon (close or loose fit): score based on inverse difference.
    
    # Create a temporary array for the scores of bins that can fit
    fitting_bins_scores = np.zeros_like(diff)
    
    # Identify exact fits within the fitting bins
    exact_fit_in_fitting_mask = diff < epsilon
    
    # Assign a very high priority to exact fits. This ensures they are chosen first.
    # The exact score should be higher than any calculated score for non-exact fits.
    # The non-exact fit score is `bins_remain_cap / diff`. If diff is small but positive, this can be large.
    # To make exact fits superior, assign a score that's at least `max(bins_remain_cap / diff)` + a margin.
    # A simpler, robust approach: assign a score that depends on the item size, making exact fits for larger items
    # more "valuable".
    
    # Let's try this:
    # For exact fits: `item * (1 / epsilon)`
    # For other fits: `item / (diff + epsilon)` (This is the same as `bins_remain_cap / (diff + epsilon)`)
    # This makes exact fits have a very high score, proportional to the item size.
    
    # For bins that fit:
    # If `diff` is close to 0: `high_priority = item * 1e10` (or some large multiplier)
    # If `diff` > 0: `priority = item / (diff + epsilon)`
    
    # Let's assign the highest priority to exact fits.
    # The score for other bins is `bins_remain_cap / (diff + epsilon)`.
    # If `diff` is small, this value is large. If `diff` is large, this value is closer to 1.
    # We want exact fits to be strictly better.
    
    # Assign a very large number to exact fits to ensure they are always picked.
    # A value like 1e10 or even larger would work, but making it relative is better.
    # Let's use a value that's guaranteed to be larger than `bins_remain_cap / diff` for any `diff > epsilon`.
    # The maximum value of `bins_remain_cap` is not known.
    # If `diff` is very small (e.g., `epsilon`), score is `item / epsilon`.
    # So, `item / epsilon * 2` should be safe.
    
    # Calculate scores for all bins that can fit.
    # Score = `bins_remain_cap / (diff + epsilon)`
    # This inherently gives higher scores to tighter fits.
    
    # We want to explicitly boost exact fits.
    # If `diff < epsilon`: this is an exact fit. Give it a bonus.
    
    # Let's use a score that is proportional to `bins_remain_cap / diff` but with a large bonus for exact fits.
    # `score = bins_remain_cap / (diff + epsilon)`
    # If `diff < epsilon`, add a large bonus: `score += LargeBonus`
    
    # This can be implemented by modifying the `diff` for exact fits.
    # For exact fits, we want `diff` to be effectively 0.
    # For non-exact fits, `diff` is positive.
    
    # A common strategy is:
    # 1. Assign a very high fixed priority to exact fits.
    # 2. For other fits, assign a priority that decreases as `diff` increases.
    #    The `bins_remain_cap / (diff + epsilon)` is a good candidate.
    
    # Let's assign a base score for all fitting bins:
    # `base_scores = bins_remain_cap[can_fit_mask] / (diff + epsilon)`
    
    # Now, identify exact fits among those that can fit.
    exact_fits_indices = np.where(diff < epsilon)[0]
    
    # For these exact fits, assign a significantly higher score.
    # Let's make their score `item / epsilon * 2` to ensure it's higher than other potential scores.
    # The scores for non-exact fits are `bins_remain_cap / diff`.
    # If `diff` is `epsilon`, score is `bins_remain_cap / epsilon`.
    # So `item / epsilon * 2` is indeed a good choice for exact fits.
    
    # Calculate scores for all bins that can fit using the `bins_remain_cap / diff` logic
    fitting_bins_scores = bins_remain_cap[can_fit_mask] / (diff + epsilon)
    
    # Identify exact fits among these:
    exact_fit_indices_in_fitting = np.where(diff < epsilon)[0]
    
    # Boost the priority for exact fits.
    # Assign a score that is guaranteed to be higher than any calculated score.
    # A simple approach is to add a large value.
    # Let's assign a score of `item * 1e10` for exact fits.
    # For other fits, the score is `bins_remain_cap / diff`.
    # If `diff` is very small (e.g. `epsilon`), the score is `bins_remain_cap / epsilon`.
    # Since `bins_remain_cap >= item`, this is at least `item / epsilon`.
    # So `item * 1e10` is a safe high value.
    
    # For indices in `fitting_bins_scores` corresponding to exact fits:
    # The original `diff` for these was < epsilon.
    # `fitting_bins_scores[exact_fit_indices_in_fitting]` would be `bins_remain_cap[exact_fit_indices_in_fitting] / diff_values_for_exact_fits`.
    # If `diff` is tiny, this is large.
    
    # Let's re-calculate scores to ensure clarity and separation:
    scores_for_fitting = np.zeros_like(diff)
    
    # Bins with exact fit (diff is effectively 0)
    exact_fit_mask_for_fitting = diff < epsilon
    
    # Assign a very high priority to exact fits.
    # The score is `item * (1 / epsilon)` ensures it's prioritized.
    # Using `item * 1e10` for a large multiplier.
    scores_for_fitting[exact_fit_mask_for_fitting] = item * 1e10
    
    # Bins with a positive difference (item fits, but not exactly)
    non_exact_fit_mask_for_fitting = ~exact_fit_mask_for_fitting
    
    # For these, use a score inversely proportional to the difference.
    # `bins_remain_cap / diff` gives higher scores to smaller differences.
    # This is `(item + diff) / diff`.
    scores_for_fitting[non_exact_fit_mask_for_fitting] = bins_remain_cap[non_exact_fit_mask_for_fitting] / diff[non_exact_fit_mask_for_fitting]
    
    # Place these scores back into the main priorities array
    priorities[can_fit_mask] = scores_for_fitting
    
    return priorities
```
