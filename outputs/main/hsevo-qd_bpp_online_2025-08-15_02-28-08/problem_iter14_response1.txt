```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Assigns highest priority to exact fits, then uses scaled inverse excess capacity for close fits."""
    
    epsilon = 1e-9
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    can_fit_mask = bins_remain_cap >= item
    available_bins_remain_cap = bins_remain_cap[can_fit_mask]
    
    if not np.any(can_fit_mask):
        return priorities

    # Calculate the excess capacity after placing the item
    excess_capacity = available_bins_remain_cap - item
    
    # Identify exact fits
    exact_fit_mask = excess_capacity < epsilon
    
    # Assign a very high priority to exact fits
    # The score is designed to be significantly larger than any possible score for close fits.
    priorities[can_fit_mask][exact_fit_mask] = item * 1e10  # High score for exact fits
    
    # For bins that can fit but are not exact fits
    non_exact_fit_mask = ~exact_fit_mask
    if np.any(non_exact_fit_mask):
        non_exact_excess = excess_capacity[non_exact_fit_mask]
        
        # Calculate scores for close fits: inversely proportional to excess capacity.
        # This means tighter fits get higher scores among non-exact fits.
        # The score is `bins_remain_cap / excess_capacity` which is equivalent to `(item + excess_capacity) / excess_capacity`.
        # We use a small epsilon to avoid division by zero if excess_capacity is very close to zero.
        close_fit_scores = available_bins_remain_cap[non_exact_fit_mask] / (non_exact_excess + epsilon)
        
        # Map these scores back to the correct bins
        original_indices_of_non_exact_fits = np.where(can_fit_mask)[0][non_exact_fit_mask]
        priorities[original_indices_of_non_exact_fits] = close_fit_scores
        
    return priorities
```
