```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Prioritizes exact fits, then bins with minimal remaining capacity after packing, using scaled scores."""
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    can_fit_mask = bins_remain_cap >= item
    
    if np.any(can_fit_mask):
        available_bins_cap = bins_remain_cap[can_fit_mask]
        
        # Assign highest priority for exact fits
        exact_fit_mask = available_bins_cap == item
        if np.any(exact_fit_mask):
            priorities[can_fit_mask][exact_fit_mask] = 1.0
            
        # For bins that don't offer an exact fit, prioritize those with minimal remaining space
        non_exact_fit_mask = ~exact_fit_mask
        if np.any(non_exact_fit_mask):
            remaining_available_bins_cap = available_bins_cap[non_exact_fit_mask]
            space_after_placement = remaining_available_bins_cap - item
            
            # Scale the inverse of space_after_placement to a range below 1.0
            # Higher priority for smaller space_after_placement (tighter fit)
            # Normalize to [0.1, 0.9] range, ensuring it's less than exact fit priority (1.0)
            min_space = np.min(space_after_placement)
            max_space = np.max(space_after_placement)
            
            if max_space - min_space > 1e-9:
                normalized_inverse_space = 0.1 + 0.8 * (1.0 / (space_after_placement + 1e-9) - 1.0 / (max_space + 1e-9)) / (1.0 / (min_space + 1e-9) - 1.0 / (max_space + 1e-9))
            else:
                normalized_inverse_space = np.full_like(space_after_placement, 0.5) # Uniform if all same

            priorities[can_fit_mask][non_exact_fit_mask] = normalized_inverse_space
            
    return priorities
```
