```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Prioritizes exact fits, then bins with minimal excess capacity using a scaled inverse difference.

    This heuristic gives the highest priority to bins that exactly fit the item.
    For bins that don't fit exactly but can accommodate the item, it assigns
    priority based on the inverse of the excess capacity, scaled to emphasize
    tighter fits.
    """
    epsilon = 1e-9
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    # Identify bins where the item can fit
    can_fit_mask = bins_remain_cap >= item
    
    if not np.any(can_fit_mask):
        return priorities

    # Calculate excess capacity for bins that can fit the item
    excess_capacity = bins_remain_cap[can_fit_mask] - item

    # Assign highest priority (1.0) to exact fits
    exact_fit_mask_local = (excess_capacity < epsilon)
    priorities[can_fit_mask][exact_fit_mask_local] = 1.0

    # For bins that don't fit exactly, calculate priority based on inverse excess capacity
    close_fit_mask_local = ~exact_fit_mask_local
    
    if np.any(close_fit_mask_local):
        eligible_excess_capacity = excess_capacity[close_fit_mask_local]
        
        # Calculate a score proportional to 1 / (excess_capacity + epsilon).
        # This favors smaller excess capacities (tighter fits).
        # We normalize this score to be between 0 and 1 to avoid overwhelming exact fits.
        # A simple normalization: 1 / (1 + scaled_excess_capacity)
        # Where scaled_excess_capacity is normalized difference.
        
        # To ensure scores are distinct from exact fits and rank close fits,
        # let's use a score that starts below 1.0 and increases as excess capacity decreases.
        # A simple way is to map the inverse excess capacity to a range like [0.1, 0.9].
        # The inverse of excess capacity is `1 / (eligible_excess_capacity + epsilon)`.
        # To bound this, we can consider the maximum inverse excess capacity.
        
        # A robust way: Use the inverse of (normalized excess + 1) to get scores in (0, 1].
        # Let's normalize excess capacity relative to the item size itself,
        # but ensuring we handle cases where item is very small or zero gracefully if needed.
        
        # A simpler score: `1 / (excess_capacity + epsilon)`
        # Let's scale this to be less than 1.0.
        # A common approach is `1 / (1 + scaled_value)`.
        # Let's use `1 / (1 + normalized_excess_capacity)` where normalized is between 0 and some value.
        
        # Alternative: score = 0.5 + 0.45 * (1 / (normalized_excess_capacity + epsilon))
        # This maps normalized excess from 0 to some value into [0.5, ~0.95].
        
        # Let's use the remaining capacity itself, but inverted and scaled.
        # Score = remaining_cap / (remaining_cap - item + epsilon)
        # This is `(item + excess) / (excess + epsilon)`.
        # To keep it below 1, we can divide by a factor, e.g., `(item + excess) / (excess + epsilon) / (item/item + epsilon)`
        
        # A better approach is to normalize the excess capacity and then use its inverse.
        # Normalize excess capacity: consider a reasonable upper bound for excess_capacity.
        # If we assume item size is at most B (max bin capacity), then excess capacity is at most B.
        # Let's consider `excess_capacity / item` (if item > 0).
        
        # A simple and effective score for close fits: `1 / (excess_capacity + epsilon)`
        # We need to scale this to be less than 1.0.
        # Find the maximum inverse excess capacity among close fits.
        max_inv_excess = np.max(1.0 / (eligible_excess_capacity + epsilon))
        
        # Scale scores for close fits to be in the range [0.1, 0.9]
        # Score = 0.1 + 0.8 * (1.0 / (eligible_excess_capacity + epsilon)) / max_inv_excess
        # This ensures that the tightest fit gets ~0.9 and others scale down.
        scores_for_close_fits = 0.1 + 0.8 * (1.0 / (eligible_excess_capacity + epsilon)) / (max_inv_excess + epsilon)
        
        # Ensure scores are not exactly 1.0 (reserved for exact fits)
        scores_for_close_fits = np.minimum(scores_for_close_fits, 0.999)
        
        priorities[can_fit_mask][close_fit_mask_local] = scores_for_close_fits
        
    return priorities
```
