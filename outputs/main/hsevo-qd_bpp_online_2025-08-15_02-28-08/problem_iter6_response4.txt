```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using a refined strategy.

    This heuristic prioritizes bins that have enough remaining capacity for the item,
    and among those, it favors bins that will have the least remaining capacity after
    packing the item. This aims to "fill up" bins as much as possible.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Returns:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Calculate the remaining capacity after packing the item
    remaining_after_packing = bins_remain_cap - item

    # Create a boolean mask for bins that can fit the item
    can_fit_mask = remaining_after_packing >= 0

    # Initialize priorities to zero
    priorities = np.zeros_like(bins_remain_cap)

    # For bins that can fit the item, calculate priority
    # The priority is the inverse of the remaining capacity after packing.
    # Adding a small epsilon to avoid division by zero.
    epsilon = 1e-9
    priorities[can_fit_mask] = 1 / (remaining_after_packing[can_fit_mask] + epsilon)

    return priorities
```
