```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Prioritizes bins with minimal remaining capacity after item placement, with a bonus for exact fits.

    Combines the "Inverse Distance" idea (prioritizing smaller positive gaps)
    with an explicit boost for exact fits to reduce fragmentation.
    """
    # Calculate the remaining capacity if the item were placed in each bin.
    space_after_placement = bins_remain_cap - item

    # Initialize priorities. Bins that cannot fit the item will have a very low priority.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Identify bins where the item can fit.
    can_fit_mask = space_after_placement >= 0

    if np.any(can_fit_mask):
        fitting_bins_space_after = space_after_placement[can_fit_mask]

        # Calculate a base priority using inverse distance (proximity fit).
        # Smaller positive remaining space gets higher priority. Add epsilon for stability.
        epsilon = 1e-9
        base_priorities = 1.0 / (fitting_bins_space_after + epsilon)

        # Introduce a significant bonus for exact fits (remaining capacity is zero).
        # This helps to perfectly fill bins and reduce fragmentation.
        exact_fit_bonus = 10.0  # A tunable parameter to emphasize exact fits
        exact_fit_mask = (fitting_bins_space_after == 0)
        bonus_values = np.where(exact_fit_mask, exact_fit_bonus, 0)

        # Combine base priority with the bonus for exact fits.
        priorities[can_fit_mask] = base_priorities + bonus_values

    return priorities
```
