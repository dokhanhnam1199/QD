```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    epsilon = 1e-9
    
    # Identify bins where the item can fit
    can_fit_mask = bins_remain_cap >= item
    
    # Initialize priorities to a very low value for bins that cannot fit the item
    # Using -1 as a sentinel, any positive score will be preferred.
    priorities = np.full_like(bins_remain_cap, -1.0)
    
    # For bins where the item can fit:
    # Tier 1: Exact fit (remaining capacity == item size)
    # Assign a very high score for exact fits.
    exact_fit_mask = np.abs(bins_remain_cap - item) < epsilon
    priorities[exact_fit_mask] = 1e6  # High priority for exact fits

    # Tier 2: Near fits (remaining capacity is slightly larger than item size)
    # Prioritize bins with remaining capacity just enough to fit the item.
    # Calculate the difference for bins that can fit and are not exact fits.
    non_exact_fit_mask = can_fit_mask & ~exact_fit_mask
    
    if np.any(non_exact_fit_mask):
        diff_near_fit = bins_remain_cap[non_exact_fit_mask] - item
        
        # Scale the difference relative to the item size to handle different item scales.
        # This "normalized excess capacity" should be small for good fits.
        # We want to give higher scores when this normalized difference is smaller.
        # A good scoring function could be `1 / (normalized_diff + epsilon)`.
        # Let's use `1 / (diff / item + epsilon)` which is `item / (diff + epsilon)`
        
        # To make it more robust and avoid excessively large scores for very small diffs,
        # we can use a capped inverse or a logarithmic scale.
        # However, sticking to the advice of simple and directly tied to fit quality:
        # Prioritize smaller `diff_near_fit`.
        # Use `1 / (diff_near_fit + epsilon)` as in `priority_v1`.
        
        # Let's try to amplify the preference for *smaller* positive differences more than `priority_v1` using the ratio idea.
        # Score = `remaining_capacity / (remaining_capacity - item + epsilon)` which is `remaining_capacity / diff_near_fit`.
        # This score is high when `diff_near_fit` is small.
        
        # Apply this scoring to the non-exact fitting bins.
        priorities[non_exact_fit_mask] = bins_remain_cap[non_exact_fit_mask] / (diff_near_fit + epsilon)
        
        # Ensure exact fits remain at their high priority if this calculation overlaps (it shouldn't due to masks).
        priorities[exact_fit_mask] = 1e6
        
    return priorities

```
