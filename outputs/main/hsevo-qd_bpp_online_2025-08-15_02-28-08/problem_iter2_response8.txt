```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Prioritizes bins using an 'Exact Fit First' with 'Proximity Fit' fallback.

    Gives highest priority to exact fits, then to bins with minimal remaining
    capacity after placement, ensuring a tight fit.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    exact_fit_mask = np.isclose(bins_remain_cap, item)
    can_fit_mask = bins_remain_cap >= item

    if np.any(exact_fit_mask):
        priorities[exact_fit_mask] = 1.0
    
    available_bins_mask = can_fit_mask & ~exact_fit_mask
    
    if np.any(available_bins_mask):
        available_bins_remain_cap = bins_remain_cap[available_bins_mask]
        
        # Prioritize bins that leave least remaining space (Proximity Fit)
        # Add a small epsilon to avoid division by zero and ensure positive scores
        proximity_scores = 1.0 / (available_bins_remain_cap - item + 1e-9)
        
        # Normalize proximity scores to give relative ranking among available bins
        # Higher score means tighter fit
        normalized_proximity_scores = (proximity_scores - np.min(proximity_scores)) / (np.max(prox_scores) - np.min(prox_scores) + 1e-9)
        
        # Combine with exact fit priority, ensuring exact fits remain highest
        # We can scale normalized_proximity_scores to be less than 1.0
        priorities[available_bins_mask] = 0.5 + 0.5 * normalized_proximity_scores
        
    return priorities
```
