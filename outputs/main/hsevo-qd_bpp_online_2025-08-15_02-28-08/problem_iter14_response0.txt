```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Assigns priorities favoring exact fits, then tight fits using scaled inverse remaining capacity."""
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    # Mask for bins that can accommodate the item
    can_fit_mask = bins_remain_cap >= item
    
    # If no bins can fit, return all zeros
    if not np.any(can_fit_mask):
        return priorities

    eligible_bins_remain_cap = bins_remain_cap[can_fit_mask]

    # --- Exact Fit Strategy ---
    # Assign highest priority to exact fits
    exact_fit_mask_local = (eligible_bins_remain_cap == item)
    
    # --- Scaled Tight Fit Strategy ---
    # For bins that do not fit exactly, calculate a score based on how tight the fit is.
    # Prioritize bins with minimal excess capacity.
    close_fit_mask_local = ~exact_fit_mask_local
    
    # Calculate excess capacity for close fits
    excess_capacities = eligible_bins_remain_cap[close_fit_mask_local] - item
    
    # Assign the highest priority to exact fits
    if np.any(exact_fit_mask_local):
        priorities[can_fit_mask][exact_fit_mask_local] = 2.0
        
    # If there are close fits, calculate their priorities
    if np.any(close_fit_mask_local):
        # Normalize excess capacities to be between 0 and 1.
        # A smaller excess capacity should get a higher score.
        min_excess = 0.0
        max_excess = np.max(excess_capacities) # Max excess capacity among close fits

        # Avoid division by zero if all close fits have the same excess capacity
        if max_excess > min_excess:
            normalized_excess = (excess_capacities - min_excess) / (max_excess - min_excess)
        else:
            normalized_excess = np.zeros_like(excess_capacities) # All close fits have same excess
        
        # Calculate scores: higher score for smaller normalized excess capacity.
        # Scale scores to be between 0.1 and 1.0 to be less than exact fits but still distinct.
        close_fit_scores = 0.1 + 0.9 * (1.0 - normalized_excess) # Inverse relationship, scaled
        
        # Assign scores to the corresponding bins
        priorities[can_fit_mask][close_fit_mask_local] = close_fit_scores

    return priorities
```
