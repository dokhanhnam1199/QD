```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Prioritizes exact fits with a high score and ranks close fits by
    normalized inverse excess capacity, favoring tighter packing.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    can_fit_mask = bins_remain_cap >= item
    
    if np.any(can_fit_mask):
        available_bins_cap = bins_remain_cap[can_fit_mask]
        
        # Assign highest priority to exact fits
        exact_fit_mask = available_bins_cap == item
        priorities[can_fit_mask][exact_fit_mask] = 1.0
        
        # For bins that are not exact fits but can still fit the item
        non_exact_fit_mask = ~exact_fit_mask
        if np.any(non_exact_fit_mask):
            remaining_available_bins_cap = available_bins_cap[non_exact_fit_mask]
            
            # Calculate excess capacity after placing the item
            excess_capacity = remaining_available_bins_cap - item
            
            # Prioritize bins with less excess capacity (tighter fits)
            # Use normalized inverse of excess capacity for a monotonic score
            # Add epsilon to avoid division by zero
            inverted_excess = 1.0 / (excess_capacity + 1e-9)
            
            # Normalize these priorities to a range, e.g., [0.1, 0.9],
            # ensuring they are lower than exact fits but ordered
            min_inv = np.min(inverted_excess)
            max_inv = np.max(inverted_excess)
            
            if max_inv - min_inv > 1e-9:
                normalized_scores = 0.1 + 0.8 * (inverted_excess - min_inv) / (max_inv - min_inv)
            else:
                normalized_scores = np.full_like(inverted_excess, 0.5) # Uniform if all same excess
            
            priorities[can_fit_mask][non_exact_fit_mask] = normalized_scores
            
    return priorities
```
