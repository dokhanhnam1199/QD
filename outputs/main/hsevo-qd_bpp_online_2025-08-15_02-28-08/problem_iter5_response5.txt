```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Prioritizes bins with exact fits, then bins with minimum excess capacity.

    Combines exact fit preference with a scaled inverse of the excess capacity
    for non-exact fits, favoring tighter packing.
    """
    priorities = np.zeros_like(bins_remain_cap)
    
    # Identify bins that can fit the item
    eligible_bins_mask = bins_remain_cap >= item
    eligible_capacities = bins_remain_cap[eligible_bins_mask]
    
    if eligible_capacities.size > 0:
        # High priority for exact fits
        exact_fit_mask = np.isclose(bins_remain_cap, item)
        priorities[exact_fit_mask] = 1.0

        # For non-exact fits, prioritize bins with minimal remaining capacity
        # Calculate excess capacity for eligible bins
        excess_capacities = eligible_capacities - item
        
        # Avoid exact fits from being penalized in this step, if they were already prioritized
        non_exact_fit_eligible_mask = ~np.isclose(eligible_capacities, item)
        non_exact_eligible_capacities = eligible_capacities[non_exact_fit_eligible_mask]
        non_exact_excess_capacities = excess_capacities[non_exact_fit_eligible_mask]

        if non_exact_eligible_capacities.size > 0:
            # Normalize the inverse of excess capacity for non-exact fits
            # Scale to [0.1, 0.9] to be lower than exact fits (1.0)
            min_excess = np.min(non_exact_excess_capacities)
            # Add epsilon for stability and to avoid division by zero
            normalized_inverse_excess = 1.0 / (non_exact_excess_capacities - min_excess + 1e-9)
            
            # Scale these scores to a range below 1.0, e.g., [0.1, 0.9]
            # Find max score to normalize
            max_norm_inv_excess = np.max(normalized_inverse_excess)
            
            scaled_scores = 0.1 + 0.8 * (normalized_inverse_excess / max_norm_inv_excess)
            
            # Map these scaled scores back to the original bins array
            original_indices = np.where(eligible_bins_mask)[0]
            non_exact_original_indices = original_indices[non_exact_fit_eligible_mask]
            priorities[non_exact_original_indices] = scaled_scores

    return priorities
```
