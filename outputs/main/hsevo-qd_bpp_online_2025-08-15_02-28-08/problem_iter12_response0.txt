```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    epsilon = 1e-9
    
    # Initialize priorities to a very low value, so bins that don't fit have minimal priority
    # This avoids needing a separate mask for non-fitting bins if we use a sufficiently small number
    # or simply let the division by zero handle it if we were using 1/diff, but here it's diff in denominator.
    # Let's initialize to zero and handle non-fitting bins explicitly.
    priorities = np.zeros_like(bins_remain_cap)
    
    # Identify bins where the item can fit
    can_fit_mask = bins_remain_cap >= item
    
    # Calculate the difference for bins that can fit
    diff = bins_remain_cap[can_fit_mask] - item
    
    # Separate exact fits (difference is very close to zero)
    exact_fit_mask = diff < epsilon
    
    # Assign a very high priority to exact fits
    # We use a large constant to ensure these are always preferred over any other fit.
    # Adding a small value based on the inverse of epsilon to make them distinct.
    priorities[can_fit_mask][exact_fit_mask] = 1e9 + (1.0 / epsilon)
    
    # For bins that are not exact fits but can still accommodate the item
    non_exact_fit_mask = ~exact_fit_mask
    
    # For these bins, prioritize those with minimal excess capacity (smallest positive difference).
    # A score that is inversely proportional to the difference, scaled.
    # The scaling factor can be relative to the item size or a fixed large number.
    # Using `bins_remain_cap / (diff + epsilon)` from v1 is good but can be sensitive to large bins.
    # Let's try a score that emphasizes the *ratio* of unused space to used space, or simply `1/diff`.
    # To give it a more "tuned" feel, let's scale the inverse difference.
    # Score = C / (diff + epsilon), where C is a constant or related to item size.
    # A good scale would be to ensure these scores are less than the exact fit score.
    # Let's use `bins_remain_cap / (diff + epsilon)` as it balances remaining capacity and tightness.
    # However, to create a better distinction for v2, let's focus on the *excess* capacity more directly.
    # We want `diff` to be small. A score like `1 / (diff + epsilon)` is a good base.
    # To be better than v1, we should explicitly give a higher "tier" to exact fits.
    # For non-exact fits, we want to prioritize smaller `diff`.
    
    # Let's use a score that is proportional to the "tightness", and then add a penalty for being "too loose".
    # The previous v1 score `bins_remain_cap / (diff + epsilon)` is equivalent to `(item + diff) / (diff + epsilon)`.
    # This amplifies small diffs.
    
    # A slightly different approach: prioritize based on how much of the *remaining* capacity is used by the item.
    # `item / bins_remain_cap` for bins that fit. This ratio is close to 1 for tight fits.
    # Let's score by `item / (bins_remain_cap - item + epsilon)`. This is similar to `item / diff`.
    # This gives a high score for small `diff`.
    # If `bins_remain_cap = 6`, `item = 5`, `diff = 1`. Score = `5 / (1 + eps) = 5`.
    # If `bins_remain_cap = 10`, `item = 5`, `diff = 5`. Score = `5 / (5 + eps) = 1`.
    # If `bins_remain_cap = 5.1`, `item = 5`, `diff = 0.1`. Score = `5 / (0.1 + eps) = 50`.
    
    # This seems more direct in prioritizing small differences.
    # `score = item / (diff + epsilon)`
    
    # Let's combine this with the exact fit logic.
    # Exact fits: very high priority (1e9 + ...)
    # Non-exact fits: `item / (diff + epsilon)`
    
    # Ensure that the non-exact fit scores are lower than exact fit scores.
    # The maximum `diff` can be large, so `item / (diff + epsilon)` will be small.
    # The minimum `diff` (for non-exact fits) will be `epsilon`. So score is `item / (2*epsilon)`, which is large but less than `1e9`.
    
    # Apply this score to the non-exact fitting bins
    if np.any(can_fit_mask[can_fit_mask][non_exact_fit_mask]):
        priorities[can_fit_mask][non_exact_fit_mask] = item / (diff[non_exact_fit_mask] + epsilon)
    
    return priorities
```
