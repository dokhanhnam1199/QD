```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Exact Fit First with Proximity Fit.
    Prioritizes exact fits, then bins with least excess capacity.
    This aims for minimal waste by trying to fill bins perfectly or nearly perfectly.
    """
    priorities = np.zeros_like(bins_remain_cap)
    
    # Mask for bins that can exactly fit the item
    exact_fit_mask = (bins_remain_cap == item)
    
    # Mask for bins that can fit the item but not exactly
    close_fit_mask = (bins_remain_cap > item)
    
    # Prioritize exact fits with a high score (e.g., 1.0)
    if np.any(exact_fit_mask):
        priorities[exact_fit_mask] = 1.0
    
    # If no exact fits, prioritize bins with the least remaining capacity (closest fit)
    # among those that can fit the item.
    if np.any(close_fit_mask):
        valid_bins_cap = bins_remain_cap[close_fit_mask]
        
        # Calculate a score inversely proportional to the excess capacity
        # A small epsilon avoids division by zero.
        # The higher the score, the tighter the fit.
        excess_capacities = valid_bins_cap - item
        scores = 1.0 / (excess_capacities + 1e-9)
        
        # Normalize scores to be between 0 and 1 relative to the best close fit found.
        # This ensures that even without an exact fit, we have a relative measure of "closeness".
        if np.any(scores > 0):
            normalized_scores = scores / np.max(scores)
        else:
            normalized_scores = np.zeros_like(scores)

        # Assign these normalized scores to the corresponding bins.
        # If an exact fit was found, these scores will be lower than 1.0,
        # ensuring exact fits are still preferred.
        priorities[close_fit_mask] = normalized_scores
        
    return priorities
```
