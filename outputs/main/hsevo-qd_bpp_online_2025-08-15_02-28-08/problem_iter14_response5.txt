```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Prioritizes exact fits with a high score, then uses scaled inverse of excess capacity for close fits."""
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    can_fit_mask = bins_remain_cap >= item
    
    if not np.any(can_fit_mask):
        return priorities

    eligible_bins_remain_cap = bins_remain_cap[can_fit_mask]
    
    # Assign a very high priority to exact fits
    exact_fit_mask_local = (eligible_bins_remain_cap == item)
    priorities[can_fit_mask][exact_fit_mask_local] = 1e9  # High score for exact fits
    
    # For bins that can fit but are not an exact fit
    non_exact_fit_mask_local = ~exact_fit_mask_local
    if np.any(non_exact_fit_mask_local):
        non_exact_bins_remain_cap = eligible_bins_remain_cap[non_exact_fit_mask_local]
        
        # Calculate excess capacity for non-exact fits
        excess_capacities = non_exact_bins_remain_cap - item
        
        # Normalize excess capacities to a range where smaller excess gets higher score
        # We invert and normalize to get a [0, 1] score, where 1 is the tightest fit
        min_excess = 0.0
        max_excess = np.max(excess_capacities)

        if max_excess > min_excess:
            normalized_excess = (excess_capacities - min_excess) / (max_excess - min_excess)
        else:
            normalized_excess = np.zeros_like(excess_capacities) # All excess capacities are the same
        
        # We want smaller excess to have higher priority, so we use (1 - normalized_excess)
        # Scale these scores to be between 0.1 and 0.9, ensuring they are less than exact fit priority (1e9)
        # and still provide differentiation among non-exact fits.
        # Lower excess -> higher score in the [0.1, 0.9] range
        non_exact_priorities = 1.0 - normalized_excess
        
        min_target_p = 0.1
        max_target_p = 0.9
        
        if np.max(non_exact_priorities) - np.min(non_exact_priorities) > 1e-9:
             scaled_non_exact_priorities = min_target_p + (non_exact_priorities - np.min(non_exact_priorities)) * (max_target_p - min_target_p) / (np.max(non_exact_priorities) - np.min(non_exact_priorities))
        else:
             scaled_non_exact_priorities = np.full_like(non_exact_priorities, (min_target_p + max_target_p) / 2.0)
        
        priorities[can_fit_mask][non_exact_fit_mask_local] = scaled_non_exact_priorities
        
    return priorities
```
