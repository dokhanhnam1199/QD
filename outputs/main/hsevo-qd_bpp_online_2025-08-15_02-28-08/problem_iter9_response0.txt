```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Returns priority with which we want to add item to each bin using a refined strategy.

    This heuristic prioritizes bins that have remaining capacity very close to the item size,
    aiming for exact or near-exact fits to minimize wasted space. It achieves this by
    scoring bins based on the ratio of their remaining capacity to the "gap" (remaining_capacity - item).
    A smaller gap results in a higher score, strongly favoring tighter fits.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Returns:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    epsilon = 1e-9
    
    priorities = np.zeros_like(bins_remain_cap)
    
    # Identify bins where the item can fit
    can_fit_mask = bins_remain_cap >= item
    
    # For bins where the item fits, calculate a priority score.
    # The goal is to maximize the ratio: bins_remain_cap / (bins_remain_cap - item + epsilon).
    # This ratio is high when (bins_remain_cap - item) is small, effectively prioritizing
    # bins with remaining capacity closest to the item size.
    
    # Calculate the difference (gap) for bins that can fit the item
    diff = bins_remain_cap[can_fit_mask] - item
    
    # Calculate the scores. Use diff + epsilon to avoid division by zero.
    # Add epsilon to bins_remain_cap as well to prevent cases like 0/0 if an item of size 0 was allowed and a bin had 0 capacity.
    # However, for item > 0 and bins_remain_cap >= item, diff >= 0.
    # The core idea is to boost scores for small `diff`.
    priorities[can_fit_mask] = (bins_remain_cap[can_fit_mask] + epsilon) / (diff + epsilon)
    
    # The score can be interpreted as: how much of the current remaining capacity is "effectively used" by the item.
    # For a perfect fit (diff=0), score is ~1.
    # For a tight fit (small diff), score is large.
    # For a loose fit (large diff), score is closer to 1.
    # This formulation prioritizes tight fits very strongly.
    
    return priorities
```
