```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Returns priority with which we want to add item to each bin.
    This heuristic prioritizes bins that have just enough space for the item,
    minimizing wasted space, while also considering bins with larger remaining
    capacity as a secondary option to avoid fragmentation.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Returns:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Identify bins where the item can fit
    can_fit_mask = bins_remain_cap >= item
    
    # Calculate the "tightness" score for bins that can fit the item.
    # A tighter fit (smaller remaining capacity after packing) gets a higher score.
    # We add 1 to the denominator to ensure a minimum score and avoid division by zero
    # and also to give some positive score to bins where item perfectly fits.
    tightness_scores = np.where(can_fit_mask, 1 / (bins_remain_cap - item + 1), 0)

    # Calculate a "slack" score for bins that can fit the item.
    # This score is higher for bins with more remaining capacity, acting as a
    # fallback to prevent excessive fragmentation.
    # We add a small epsilon to the denominator to avoid division by zero for bins
    # with zero remaining capacity (though this should be caught by can_fit_mask).
    # We also scale this score to be less dominant than the tightness score.
    epsilon = 1e-9
    slack_scores = np.where(can_fit_mask, bins_remain_cap / (item + epsilon), 0)

    # Combine the scores. The primary goal is to find a tight fit.
    # The slack score acts as a secondary factor.
    # We can combine them by giving more weight to tightness.
    # The exact weighting might require tuning for specific problem instances,
    # but a simple additive combination with a dominant tightness score is a good start.
    priorities = tightness_scores + 0.1 * slack_scores # 0.1 is a tunable parameter

    # Ensure that bins where the item cannot fit have a priority of 0
    priorities = np.where(can_fit_mask, priorities, 0)

    return priorities
```
