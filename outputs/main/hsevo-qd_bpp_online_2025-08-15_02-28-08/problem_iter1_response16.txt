```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Sigmoid Fit Score.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    can_fit_mask = bins_remain_cap >= item
    priorities = np.zeros_like(bins_remain_cap)
    
    if np.any(can_fit_mask):
        available_caps = bins_remain_cap[can_fit_mask]
        
        # Sigmoid-like function: higher priority for bins that are "closer" to fitting the item
        # but not too close to waste significant space.
        # We want to favor bins where item fills a significant portion of remaining capacity
        # but leaves a reasonable amount.
        
        # Normalized remaining capacity relative to bin size if we were to fit the item
        # Higher value means more wasted space if item is put in this bin
        wasted_space_ratio = (available_caps - item) / available_caps
        
        # Apply sigmoid to map the ratio to a [0, 1] range, then invert it.
        # We want to penalize large wasted_space_ratio, so we use 1 - sigmoid(x).
        # A small positive constant 'k' is used to control the steepness of the sigmoid.
        k = 5.0 
        sigmoid_values = 1 / (1 + np.exp(-k * (wasted_space_ratio - 0.5)))
        
        # Invert the sigmoid: prioritize bins with lower wasted space ratio (closer fit)
        # but avoid extremely tight fits by not making the priority too close to 1.
        # A simple inversion (1 - sigmoid) might over-prioritize near-perfect fits.
        # Let's try to emphasize the middle ground.
        
        # A different approach: penalize bins that are too large and too small for the item
        # We want to find a bin that is "just right"
        
        # Let's define "goodness" of fit as how close the remaining capacity is to the item size.
        # Normalize this difference.
        
        # Score: inversely proportional to the difference between remaining capacity and item size.
        # But also, if remaining capacity is much larger than item size, it's not good.
        
        # Let's use the negative of the wasted space ratio as a base, which favors tighter fits.
        # Then apply a sigmoid-like transform that peaks when wasted_space_ratio is around 0.
        
        # For each bin that can fit the item, calculate a score.
        # Score = sigmoid( k * ( (available_caps - item) / AVAILABLE_CAP_SUM - 0.5) )
        # Where AVAILABLE_CAP_SUM is the sum of capacities of bins that can fit the item.
        # This might still be tricky.
        
        # Let's stick to a simple approach:
        # Prioritize bins where the remaining capacity is just enough or slightly more than the item.
        # A good heuristic: the inverse of the squared difference between remaining capacity and item size.
        # However, this doesn't account for the "too much space" problem.
        
        # Let's try a sigmoid centered around the ideal fit (remaining_cap = item).
        # The closer remaining_cap is to item, the higher the score.
        
        # Calculate a 'fit_quality' score for each bin that can fit the item.
        # We want to penalize bins where `available_caps` is much larger than `item`.
        # A possible metric: `item / available_caps`. This favors bins that are closer to being full if the item is added.
        # Values are between 0 and 1. Higher means better fit (less wasted space).
        fit_quality = item / available_caps
        
        # Apply a sigmoid to the fit_quality.
        # Higher fit_quality means the bin is "more full" if the item is added.
        # We want to map high fit_quality to high priority.
        # Sigmoid(k * (fit_quality - threshold))
        # Threshold can be around 0.5 for example, meaning we prefer bins where item takes up ~50% of remaining cap.
        # A steeper sigmoid will favor very close fits.
        
        k_sigmoid = 10.0
        threshold = 0.7 # Favor bins where item takes up more than 70% of remaining capacity
        
        scores_for_fitting_bins = 1 / (1 + np.exp(-k_sigmoid * (fit_quality - threshold)))
        
        priorities[can_fit_mask] = scores_for_fitting_bins
        
    return priorities
```
