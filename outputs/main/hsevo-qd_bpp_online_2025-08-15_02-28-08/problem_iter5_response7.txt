```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Exact Fit priority with a normalized Best Fit strategy.
    Gives highest priority to exact fits, then prioritizes bins with
    the smallest remaining capacity that can fit the item.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    # Identify bins that can fit the item
    can_fit_mask = bins_remain_cap >= item
    
    # If no bins can fit the item, return all zeros
    if not np.any(can_fit_mask):
        return priorities

    eligible_bins_remain_cap = bins_remain_cap[can_fit_mask]

    # --- Exact Fit Strategy ---
    # Prioritize bins that fit the item exactly with a high score
    exact_fit_mask_local = (eligible_bins_remain_cap == item)
    
    # --- Normalized Best Fit Strategy ---
    # For bins that do not fit exactly, calculate a score based on how close they are
    # to fitting the item. Prioritize those with minimal excess capacity.
    close_fit_mask_local = ~exact_fit_mask_local
    
    # Calculate excess capacity for close fits
    excess_capacities = eligible_bins_remain_cap[close_fit_mask_local] - item
    
    # Assign high priority to exact fits
    if np.any(exact_fit_mask_local):
        priorities[can_fit_mask][exact_fit_mask_local] = 1.0
        
    # If there are close fits, calculate their priorities
    if np.any(close_fit_mask_local):
        # Normalize excess capacities to be between 0 and 1
        # A smaller excess capacity should get a higher score.
        # We use 1 / (normalized_excess + epsilon) to give higher scores to smaller excesses.
        min_excess = 0.0
        max_excess = np.max(excess_capacities) # Max excess capacity among close fits

        # Avoid division by zero if all close fits have the same excess capacity
        if max_excess > min_excess:
            normalized_excess = (excess_capacities - min_excess) / (max_excess - min_excess)
        else:
            normalized_excess = np.zeros_like(excess_capacities) # All close fits have same excess
        
        # Calculate scores: higher score for smaller normalized excess capacity
        # Add a base score to differentiate from bins that don't fit (score 0)
        # and ensure scores are distinct from exact fits.
        close_fit_scores = 0.5 + 0.45 * (1.0 / (normalized_excess + 1e-9)) # Scale to [0.5, ~0.95]
        
        # Ensure scores are not greater than exact fit priority
        close_fit_scores = np.minimum(close_fit_scores, 0.99) 
        
        # Assign scores to the corresponding bins
        priorities[can_fit_mask][close_fit_mask_local] = close_fit_scores

    # Ensure exact fits have priority over close fits if they overlap in scoring range
    if np.any(exact_fit_mask_local) and np.any(close_fit_mask_local):
         priorities[can_fit_mask][exact_fit_mask_local] = 1.0 # Re-assert max priority for exact fits


    return priorities
```
