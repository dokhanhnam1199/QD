```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Prioritizes exact fits, then bins with minimal excess capacity.

    Combines exact fit preference with a normalized inverse of residual capacity.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    can_fit_mask = bins_remain_cap >= item

    if np.any(can_fit_mask):
        eligible_capacities = bins_remain_cap[can_fit_mask]
        
        # Highest priority for exact fits
        exact_fit_mask = eligible_capacities == item
        if np.any(exact_fit_mask):
            priorities[can_fit_mask][exact_fit_mask] = 1.0

        # For non-exact fits, prioritize bins with minimal excess capacity
        non_exact_fit_mask = ~exact_fit_mask
        if np.any(non_exact_fit_mask):
            remaining_eligible_capacities = eligible_capacities[non_exact_fit_mask]
            
            # Calculate the difference (excess capacity)
            diffs = remaining_eligible_capacities - item
            
            # Normalize differences: smaller difference -> higher score
            # Use inverse of (difference - min_difference) for better scaling
            min_diff = np.min(diffs)
            normalized_scores = 1.0 / (diffs - min_diff + 1e-9)

            # Scale scores to be less than exact fit priority (e.g., 0.5 to 0.99)
            min_norm = np.min(normalized_scores)
            max_norm = np.max(normalized_scores)
            
            if max_norm - min_norm > 1e-9:
                scaled_scores = 0.5 + 0.49 * (normalized_scores - min_norm) / (max_norm - min_norm)
            else:
                scaled_scores = np.full_like(normalized_scores, 0.75) # Mid-range if all same

            priorities[can_fit_mask][non_exact_fit_mask] = scaled_scores
            
    return priorities
```
