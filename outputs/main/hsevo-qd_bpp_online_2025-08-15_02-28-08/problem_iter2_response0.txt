```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Combines 'First Fit' with 'Exact Fit First' to prioritize bins.

    Prioritizes exact fits, then bins with minimal excess capacity,
    then bins that can fit the item, favoring tighter fits.
    """
    priorities = np.zeros_like(bins_remain_cap)
    
    can_fit_mask = bins_remain_cap >= item
    
    # Exact fit first: highest priority
    exact_fit_mask = bins_remain_cap == item
    priorities[exact_fit_mask] = 1.0
    
    # Bins that can fit but are not an exact fit
    potential_bins_mask = can_fit_mask & ~exact_fit_mask
    
    if np.any(potential_bins_mask):
        # Calculate remaining space after placing the item
        remaining_space = bins_remain_cap[potential_bins_mask] - item
        
        # Inverse of remaining space (smaller remaining space is better)
        # Add a small epsilon to avoid division by zero
        inverse_remaining_space = 1.0 / (remaining_space + 1e-9)
        
        # Normalize these scores to be in a range, e.g., [0, 0.9]
        # to keep exact fits clearly prioritized.
        min_isr = np.min(inverse_remaining_space)
        max_isr = np.max(inverse_remaining_space)
        
        normalized_scores = np.zeros_like(bins_remain_cap)
        if max_isr - min_isr > 1e-9:
            normalized_scores[potential_bins_mask] = 0.9 * (inverse_remaining_space - min_isr) / (max_isr - min_isr)
        else:
            normalized_scores[potential_bins_mask] = 0.45 # Middle value if all are same
            
        # Combine with the exact fit priority. Exact fits have 1.0.
        # The normalized scores are in [0, 0.9].
        priorities[potential_bins_mask] = normalized_scores
    
    # Bins that cannot fit remain with priority 0
    
    return priorities
```
