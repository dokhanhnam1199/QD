{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using a more sophisticated strategy.\n\n    This heuristic prioritizes bins that have just enough remaining capacity to fit the item,\n    while also considering bins that have significantly more capacity as a secondary factor.\n    It aims to reduce fragmentation by favoring tighter fits.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    epsilon = 1e-9\n    \n    # Calculate the difference between remaining capacity and item size\n    diff = bins_remain_cap - item\n    \n    # Initialize priorities to zero (for bins where the item doesn't fit)\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    # Identify bins where the item can fit\n    can_fit_mask = diff >= 0\n    \n    # For bins where the item fits, calculate a priority score.\n    # The primary goal is to find bins with a small positive difference (tightest fit).\n    # We use an inverse of (difference + epsilon) for tighter fits to give them higher scores.\n    # We also add a small bonus for bins with much larger remaining capacity to not\n    # completely discard them if no tight fit is available. This bonus is smaller.\n    \n    # Calculate inverse difference for tight fits: higher score for smaller positive difference\n    tight_fit_scores = 1 / (diff[can_fit_mask] + epsilon)\n    \n    # Calculate a secondary score for bins with more remaining capacity than the item size.\n    # This is a simpler inverse of remaining capacity, scaled down.\n    # We want to avoid division by zero for bins with zero remaining capacity if they exist (though item wouldn't fit)\n    # and to give some priority to larger bins if no tight fit is available.\n    # Using the original bins_remain_cap for this secondary scoring.\n    \n    # We can normalize the remaining capacities to get a sense of \"how much space\" is left relative to bin capacity.\n    # However, since we don't have the original bin capacity, we can use a heuristic.\n    # Let's simply use the remaining capacity itself, but scaled.\n    # A simpler approach without original bin capacity is to just use the inverse of difference for those that fit.\n    \n    # Let's refine the logic:\n    # Priority 1: Bins with smallest positive `diff` (tightest fit). This is `1 / (diff + epsilon)`.\n    # Priority 2: Bins with larger `diff`. These are less preferred than tight fits.\n    # A simple way to combine is to give a high score to tight fits and a moderate score to larger fits.\n    \n    # Let's use a piecewise approach for scoring:\n    # For bins that fit:\n    # If diff is very small (e.g., diff < threshold), assign a high priority (e.g., 100 + 1/diff).\n    # If diff is larger, assign a lower priority (e.g., 10 + 1/diff).\n    # This requires tuning `threshold`.\n    \n    # A more robust approach without arbitrary thresholds:\n    # We want to maximize `1/(diff + epsilon)` for tight fits and still assign some score to larger fits.\n    # Consider the ratio of remaining capacity to item size.\n    \n    # Let's try scoring based on inverse difference, and then add a penalty for \"too much\" space.\n    # Or, simply, prioritize bins where `bins_remain_cap` is \"close\" to `item`.\n    \n    # Let's use a score that is high for small positive differences and decreases as the difference grows.\n    # A Gaussian-like function centered around 0 (for `diff`) could work, but it's complex.\n    \n    # Simpler idea: prioritize bins that have *just enough* space.\n    # We can define \"just enough\" as being within a certain percentage of the item size.\n    # For example, if diff is between 0 and `item * tolerance`.\n    \n    # Let's revisit the inverse distance, but modify it to be more sensitive to small differences.\n    # A score that is high for small `diff` and then drops off.\n    # Consider `score = 1 / (diff^2 + epsilon)` or `score = exp(-k * diff)`\n    \n    # Let's try a score that emphasizes the \"tightness\" by squaring the inverse of the difference.\n    # This will amplify the priority for very tight fits.\n    \n    # Calculate the inverse of difference for bins that can fit the item\n    # For bins where it can fit, the priority is proportional to 1 / (difference + epsilon)\n    # We want to boost the priority for smaller differences more significantly.\n    # Let's use (1 / (diff + epsilon))^2 for a stronger emphasis on tightness.\n    \n    # This still might give a very small positive difference a disproportionately high score.\n    \n    # Alternative: Focus on the ratio of remaining capacity to item size.\n    # Bins with `bins_remain_cap / item` close to 1 are good.\n    # Ratio = bins_remain_cap / item. We want ratio ~ 1.\n    # Score could be proportional to `1 / abs(ratio - 1)`.\n    # However, this doesn't account for the absolute amount of space. A bin with 10 capacity\n    # and item 9 (ratio 1.11) is better than bin with 100 capacity and item 9 (ratio 1.01)\n    # if we only consider this ratio. We need to combine it.\n    \n    # Let's stick to the difference but prioritize small positive differences more strongly.\n    # A function like `f(x) = 1/(x+epsilon)` is already good.\n    # What if we add a small bonus for bins that have \"plenty\" of space, but significantly less than tight fits?\n    \n    # Let's try to make it more robust to scale by normalizing.\n    # If we knew the maximum bin capacity, we could normalize. Without it, it's hard.\n    \n    # Back to basics, `priority_v1` favors bins with largest remaining capacity among those that fit.\n    # `1 / (diff + epsilon)` favors bins with smallest `diff`. This is generally good.\n    \n    # How to improve:\n    # 1. Give stronger weight to *very* tight fits.\n    # 2. Ensure that bins that are *almost* full but still fit are prioritized over bins that are nearly empty but fit.\n    \n    # Let's try a compound score:\n    # Score1: Inverse difference (prioritizes tight fits)\n    # Score2: A small bonus for bins that are not too empty, scaled by how much they can fit.\n    \n    # For bins that can fit:\n    # `tight_fit_score = 1 / (diff + epsilon)`\n    \n    # Now, consider the \"emptiness\" of the bin if it fits.\n    # A bin that has `bins_remain_cap` close to `item` is good.\n    # A bin that has `bins_remain_cap` much larger than `item` is less ideal in terms of fragmentation.\n    \n    # Let's define a score that peaks at `diff = 0` (or slightly negative) and decreases.\n    # However, we only consider `diff >= 0`. So we want it to peak at `diff = 0`.\n    \n    # Consider a function that is `1/(diff + epsilon)` for tight fits, and maybe a constant or decaying function for larger fits.\n    \n    # Let's try a score that emphasizes \"just enough\" space more, and \"plenty\" of space less.\n    # If `diff` is small (e.g., < `item / 2`), give it a higher score.\n    # If `diff` is large (e.g., > `item / 2`), give it a lower score.\n    \n    # Let's normalize `diff` relative to the item size.\n    # `normalized_diff = diff / item` (if item > 0)\n    # We want `normalized_diff` close to 0.\n    \n    # Score = `1 / (normalized_diff + epsilon)` for `normalized_diff >= 0`\n    # This is equivalent to `item / (bins_remain_cap - item + epsilon)` which is similar to `priority_v1` but normalized.\n    \n    # Let's try to blend the inverse difference with a penalty for being too \"empty\".\n    # A bin that fits has `bins_remain_cap >= item`.\n    # If `bins_remain_cap` is much larger than `item`, it's \"too empty\".\n    \n    # Let's use a score based on how much of the remaining capacity is *used* by the item.\n    # If `bins_remain_cap` is very close to `item`, then `item / bins_remain_cap` is close to 1.\n    # If `bins_remain_cap` is much larger than `item`, then `item / bins_remain_cap` is close to 0.\n    \n    # So, we want to prioritize bins where `item / bins_remain_cap` is close to 1.\n    # Score = `1 / abs((item / bins_remain_cap) - 1 + epsilon)`\n    # This can be written as `bins_remain_cap / abs(bins_remain_cap - item + epsilon)`.\n    # This is effectively `bins_remain_cap / (diff + epsilon)` for bins that fit.\n    \n    # Let's test this:\n    # item = 5\n    # bins_remain_cap = [10, 6, 20, 5.1]\n    # diff = [5, 1, 15, 0.1]\n    #\n    # priority_v1:\n    # 1/(5+eps) = 0.2\n    # 1/(1+eps) = 1.0\n    # 1/(15+eps) = 0.066\n    # 1/(0.1+eps) = 9.09\n    # Max priority for 5.1 remaining.\n    #\n    # New approach: `bins_remain_cap / (diff + epsilon)`\n    # 10 / (5+eps) = 2.0\n    # 6 / (1+eps) = 6.0\n    # 20 / (15+eps) = 1.33\n    # 5.1 / (0.1+eps) = 51.0\n    # Max priority for 5.1 remaining. This seems to amplify the preference for tight fits.\n    \n    # Let's implement this: `bins_remain_cap / (diff + epsilon)` for bins that fit.\n    \n    priorities = np.zeros_like(bins_remain_cap)\n    \n    # Identify bins where the item can fit\n    can_fit_mask = bins_remain_cap >= item\n    \n    # For bins where the item fits, calculate the priority score\n    # Prioritize bins where the remaining capacity is closest to the item size.\n    # Score is `bins_remain_cap / (bins_remain_cap - item + epsilon)`\n    # This is equivalent to `bins_remain_cap / (diff + epsilon)`\n    \n    # Add a small epsilon to bins_remain_cap to avoid division by zero if item == bins_remain_cap == 0,\n    # although can_fit_mask should prevent this for item > 0.\n    \n    # Ensure item is not zero to avoid division by zero in potential alternative calculations.\n    # In this case, we are using bins_remain_cap which is always non-negative.\n    \n    # The division `bins_remain_cap / (bins_remain_cap - item + epsilon)` can be large if `bins_remain_cap - item` is small.\n    # This correctly prioritizes tight fits.\n    \n    # Let's make sure the score is well-behaved.\n    # If `bins_remain_cap` is large, and `item` is small, `diff` is large.\n    # `bins_remain_cap / (diff + epsilon)` will be `large / large` -> moderate score.\n    # If `bins_remain_cap` is just slightly larger than `item`, `diff` is small.\n    # `bins_remain_cap / (diff + epsilon)` will be `~item / small` -> high score.\n    \n    # This seems like a good candidate for `priority_v2`.\n    \n    # Avoid division by zero if item is 0, though problem statement implies item > 0.\n    # If item is 0, any bin can fit it with infinite priority if `diff=0`.\n    # For item > 0, `bins_remain_cap` must be >= `item`.\n    \n    # Let's consider `bins_remain_cap - item`. If this is 0, the item perfectly fills the bin.\n    # In that case, `bins_remain_cap / epsilon` would be very large. This is desired.\n    \n    # Calculate the score for bins where the item fits\n    # Score = remaining_capacity / (remaining_capacity - item + epsilon)\n    # This is equivalent to: (item + diff) / (diff + epsilon)\n    # This ratio is maximized when `diff` is minimized (closest to 0).\n    \n    priorities[can_fit_mask] = bins_remain_cap[can_fit_mask] / (diff[can_fit_mask] + epsilon)\n    \n    return priorities\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using a more sophisticated strategy.\n\n    This heuristic prioritizes bins that have just enough remaining capacity to fit the item,\n    while also considering bins that have significantly more capacity as a secondary factor.\n    It aims to reduce fragmentation by favoring tighter fits.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    epsilon = 1e-9\n    \n    # Calculate the difference between remaining capacity and item size\n    diff = bins_remain_cap - item\n    \n    # Initialize priorities to zero (for bins where the item doesn't fit)\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    # Identify bins where the item can fit\n    can_fit_mask = diff >= 0\n    \n    # For bins where the item fits, calculate a priority score.\n    # The primary goal is to find bins with a small positive difference (tightest fit).\n    # We use an inverse of (difference + epsilon) for tighter fits to give them higher scores.\n    # We also add a small bonus for bins with much larger remaining capacity to not\n    # completely discard them if no tight fit is available. This bonus is smaller.\n    \n    # Calculate inverse difference for tight fits: higher score for smaller positive difference\n    tight_fit_scores = 1 / (diff[can_fit_mask] + epsilon)\n    \n    # Calculate a secondary score for bins with more remaining capacity than the item size.\n    # This is a simpler inverse of remaining capacity, scaled down.\n    # We want to avoid division by zero for bins with zero remaining capacity if they exist (though item wouldn't fit)\n    # and to give some priority to larger bins if no tight fit is available.\n    # Using the original bins_remain_cap for this secondary scoring.\n    \n    # We can normalize the remaining capacities to get a sense of \"how much space\" is left relative to bin capacity.\n    # However, since we don't have the original bin capacity, we can use a heuristic.\n    # Let's simply use the remaining capacity itself, but scaled.\n    # A simpler approach without original bin capacity is to just use the inverse of difference for those that fit.\n    \n    # Let's refine the logic:\n    # Priority 1: Bins with smallest positive `diff` (tightest fit). This is `1 / (diff + epsilon)`.\n    # Priority 2: Bins with larger `diff`. These are less preferred than tight fits.\n    # A simple way to combine is to give a high score to tight fits and a moderate score to larger fits.\n    \n    # Let's use a piecewise approach for scoring:\n    # For bins that fit:\n    # If diff is very small (e.g., diff < threshold), assign a high priority (e.g., 100 + 1/diff).\n    # If diff is larger, assign a lower priority (e.g., 10 + 1/diff).\n    # This requires tuning `threshold`.\n    \n    # A more robust approach without arbitrary thresholds:\n    # We want to maximize `1/(diff + epsilon)` for tight fits and still assign some score to larger fits.\n    # Consider the ratio of remaining capacity to item size.\n    \n    # Let's try scoring based on inverse difference, and then add a penalty for \"too much\" space.\n    # Or, simply, prioritize bins where `bins_remain_cap` is \"close\" to `item`.\n    \n    # Let's use a score that is high for small positive differences and decreases as the difference grows.\n    # A Gaussian-like function centered around 0 (for `diff`) could work, but it's complex.\n    \n    # Simpler idea: prioritize bins that have *just enough* space.\n    # We can define \"just enough\" as being within a certain percentage of the item size.\n    # For example, if diff is between 0 and `item * tolerance`.\n    \n    # Let's revisit the inverse distance, but modify it to be more sensitive to small differences.\n    # A score that is high for small `diff` and then drops off.\n    # Consider `score = 1 / (diff^2 + epsilon)` or `score = exp(-k * diff)`\n    \n    # Let's try a score that emphasizes the \"tightness\" by squaring the inverse of the difference.\n    # This will amplify the priority for very tight fits.\n    \n    # Calculate the inverse of difference for bins that can fit the item\n    # For bins where it can fit, the priority is proportional to 1 / (difference + epsilon)\n    # We want to boost the priority for smaller differences more significantly.\n    # Let's use (1 / (diff + epsilon))^2 for a stronger emphasis on tightness.\n    \n    # This still might give a very small positive difference a disproportionately high score.\n    \n    # Alternative: Focus on the ratio of remaining capacity to item size.\n    # Bins with `bins_remain_cap / item` close to 1 are good.\n    # Ratio = bins_remain_cap / item. We want ratio ~ 1.\n    # Score could be proportional to `1 / abs(ratio - 1)`.\n    # However, this doesn't account for the absolute amount of space. A bin with 10 capacity\n    # and item 9 (ratio 1.11) is better than bin with 100 capacity and item 9 (ratio 1.01)\n    # if we only consider this ratio. We need to combine it.\n    \n    # Let's stick to the difference but prioritize small positive differences more strongly.\n    # A function like `f(x) = 1/(x+epsilon)` is already good.\n    # What if we add a small bonus for bins that have \"plenty\" of space, but significantly less than tight fits?\n    \n    # Let's try to make it more robust to scale by normalizing.\n    # If we knew the maximum bin capacity, we could normalize. Without it, it's hard.\n    \n    # Back to basics, `priority_v1` favors bins with largest remaining capacity among those that fit.\n    # `1 / (diff + epsilon)` favors bins with smallest `diff`. This is generally good.\n    \n    # How to improve:\n    # 1. Give stronger weight to *very* tight fits.\n    # 2. Ensure that bins that are *almost* full but still fit are prioritized over bins that are nearly empty but fit.\n    \n    # Let's try a compound score:\n    # Score1: Inverse difference (prioritizes tight fits)\n    # Score2: A small bonus for bins that are not too empty, scaled by how much they can fit.\n    \n    # For bins that can fit:\n    # `tight_fit_score = 1 / (diff + epsilon)`\n    \n    # Now, consider the \"emptiness\" of the bin if it fits.\n    # A bin that has `bins_remain_cap` close to `item` is good.\n    # A bin that has `bins_remain_cap` much larger than `item` is less ideal in terms of fragmentation.\n    \n    # Let's define a score that peaks at `diff = 0` (or slightly negative) and decreases.\n    # However, we only consider `diff >= 0`. So we want it to peak at `diff = 0`.\n    \n    # Consider a function that is `1/(diff + epsilon)` for tight fits, and maybe a constant or decaying function for larger fits.\n    \n    # Let's try a score that emphasizes \"just enough\" space more, and \"plenty\" of space less.\n    # If `diff` is small (e.g., < `item / 2`), give it a higher score.\n    # If `diff` is large (e.g., > `item / 2`), give it a lower score.\n    \n    # Let's normalize `diff` relative to the item size.\n    # `normalized_diff = diff / item` (if item > 0)\n    # We want `normalized_diff` close to 0.\n    \n    # Score = `1 / (normalized_diff + epsilon)` for `normalized_diff >= 0`\n    # This is equivalent to `item / (bins_remain_cap - item + epsilon)` which is similar to `priority_v1` but normalized.\n    \n    # Let's try to blend the inverse difference with a penalty for being too \"empty\".\n    # A bin that fits has `bins_remain_cap >= item`.\n    # If `bins_remain_cap` is much larger than `item`, it's \"too empty\".\n    \n    # Let's use a score based on how much of the remaining capacity is *used* by the item.\n    # If `bins_remain_cap` is very close to `item`, then `item / bins_remain_cap` is close to 1.\n    # If `bins_remain_cap` is much larger than `item`, then `item / bins_remain_cap` is close to 0.\n    \n    # So, we want to prioritize bins where `item / bins_remain_cap` is close to 1.\n    # Score = `1 / abs((item / bins_remain_cap) - 1 + epsilon)`\n    # This can be written as `bins_remain_cap / abs(bins_remain_cap - item + epsilon)`.\n    # This is effectively `bins_remain_cap / (diff + epsilon)` for bins that fit.\n    \n    # Let's test this:\n    # item = 5\n    # bins_remain_cap = [10, 6, 20, 5.1]\n    # diff = [5, 1, 15, 0.1]\n    #\n    # priority_v1:\n    # 1/(5+eps) = 0.2\n    # 1/(1+eps) = 1.0\n    # 1/(15+eps) = 0.066\n    # 1/(0.1+eps) = 9.09\n    # Max priority for 5.1 remaining.\n    #\n    # New approach: `bins_remain_cap / (diff + epsilon)`\n    # 10 / (5+eps) = 2.0\n    # 6 / (1+eps) = 6.0\n    # 20 / (15+eps) = 1.33\n    # 5.1 / (0.1+eps) = 51.0\n    # Max priority for 5.1 remaining. This seems to amplify the preference for tight fits.\n    \n    # Let's implement this: `bins_remain_cap / (diff + epsilon)` for bins that fit.\n    \n    priorities = np.zeros_like(bins_remain_cap)\n    \n    # Identify bins where the item can fit\n    can_fit_mask = bins_remain_cap >= item\n    \n    # For bins where the item fits, calculate the priority score\n    # Prioritize bins where the remaining capacity is closest to the item size.\n    # Score is `bins_remain_cap / (bins_remain_cap - item + epsilon)`\n    # This is equivalent to `bins_remain_cap / (diff + epsilon)`\n    \n    # Add a small epsilon to bins_remain_cap to avoid division by zero if item == bins_remain_cap == 0,\n    # although can_fit_mask should prevent this for item > 0.\n    \n    # Ensure item is not zero to avoid division by zero in potential alternative calculations.\n    # In this case, we are using bins_remain_cap which is always non-negative.\n    \n    # The division `bins_remain_cap / (bins_remain_cap - item + epsilon)` can be large if `bins_remain_cap - item` is small.\n    # This correctly prioritizes tight fits.\n    \n    # Let's make sure the score is well-behaved.\n    # If `bins_remain_cap` is large, and `item` is small, `diff` is large.\n    # `bins_remain_cap / (diff + epsilon)` will be `large / large` -> moderate score.\n    # If `bins_remain_cap` is just slightly larger than `item`, `diff` is small.\n    # `bins_remain_cap / (diff + epsilon)` will be `~item / small` -> high score.\n    \n    # This seems like a good candidate for `priority_v2`.\n    \n    # Avoid division by zero if item is 0, though problem statement implies item > 0.\n    # If item is 0, any bin can fit it with infinite priority if `diff=0`.\n    # For item > 0, `bins_remain_cap` must be >= `item`.\n    \n    # Let's consider `bins_remain_cap - item`. If this is 0, the item perfectly fills the bin.\n    # In that case, `bins_remain_cap / epsilon` would be very large. This is desired.\n    \n    # Calculate the score for bins where the item fits\n    # Score = remaining_capacity / (remaining_capacity - item + epsilon)\n    # This is equivalent to: (item + diff) / (diff + epsilon)\n    # This ratio is maximized when `diff` is minimized (closest to 0).\n    \n    priorities[can_fit_mask] = bins_remain_cap[can_fit_mask] / (diff[can_fit_mask] + epsilon)\n    \n    return priorities\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines Exact Fit First with a normalized Best Fit strategy.\n    Prioritizes exact fits, then bins with the least excess capacity\n    relative to the minimum possible excess.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Mask for bins that can fit the item\n    can_fit_mask = bins_remain_cap >= item\n    eligible_bins_cap = bins_remain_cap[can_fit_mask]\n    \n    if eligible_bins_cap.size == 0:\n        return priorities\n\n    # Mask for exact fits\n    exact_fit_mask = (eligible_bins_cap == item)\n    \n    if np.any(exact_fit_mask):\n        # Assign highest priority (1.0) to exact fits\n        priorities[can_fit_mask][exact_fit_mask] = 1.0\n        \n        # For non-exact fits, assign a lower priority band (0.0 to 0.9)\n        non_exact_fit_mask = can_fit_mask.copy()\n        non_exact_fit_mask[can_fit_mask][exact_fit_mask] = False\n        \n        if np.any(non_exact_fit_mask):\n            non_exact_bins_cap = bins_remain_cap[non_exact_fit_mask]\n            # Calculate excess capacity for non-exact fits\n            excess_capacities = non_exact_bins_cap - item\n            \n            # Find the minimum excess capacity among non-exact fits\n            min_excess_capacity = np.min(excess_capacities)\n            \n            # Calculate normalized scores: higher score for smaller excess capacity relative to min\n            # Add epsilon to avoid division by zero and to ensure scores are not infinite\n            normalized_scores = 1.0 / (excess_capacities - min_excess_capacity + 1e-9)\n            \n            # Scale these scores to a lower range (e.g., 0.0 to 0.9)\n            max_normalized_score = np.max(normalized_scores)\n            if max_normalized_score > 0:\n                scaled_scores = 0.9 * (normalized_scores / max_normalized_score)\n            else:\n                scaled_scores = np.zeros_like(normalized_scores) # Should not happen if there are non-exact fits\n\n            priorities[non_exact_fit_mask] = scaled_scores\n            \n    else:\n        # If no exact fit, all fitting bins are non-exact fits\n        # Calculate excess capacity for all eligible bins\n        excess_capacities = eligible_bins_cap - item\n        \n        # Find the minimum excess capacity\n        min_excess_capacity = np.min(excess_capacities)\n        \n        # Calculate normalized scores: higher score for smaller excess capacity relative to min\n        normalized_scores = 1.0 / (excess_capacities - min_excess_capacity + 1e-9)\n        \n        # Scale these scores to a range (e.g., 0.0 to 1.0)\n        max_normalized_score = np.max(normalized_scores)\n        if max_normalized_score > 0:\n            scaled_scores = normalized_scores / max_normalized_score\n        else:\n            scaled_scores = np.zeros_like(normalized_scores) # Should not happen\n\n        priorities[can_fit_mask] = scaled_scores\n\n    return priorities\n\n[Heuristics 4th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Implements a Random Fit strategy for the online Bin Packing Problem.\n    Prioritizes bins that can fit the item. A higher priority is given\n    to bins with less remaining capacity that can still fit the item,\n    encouraging tighter packing.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Returns:\n        Array of priority scores for each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    can_fit_mask = bins_remain_cap >= item\n    \n    if np.any(can_fit_mask):\n        available_bins_cap = bins_remain_cap[can_fit_mask]\n        \n        # Assign priority based on how full the bin would become\n        # Smaller remaining capacity (i.e., larger fraction filled) gets higher priority\n        # We invert the remaining capacity to make smaller values larger priorities\n        inverted_cap = 1.0 / (available_bins_cap + 1e-9) # Add epsilon to avoid division by zero\n        \n        # Normalize priorities to be between 0 and 1\n        min_p = np.min(inverted_cap)\n        max_p = np.max(inverted_cap)\n        \n        if max_p - min_p > 1e-9:\n            normalized_priorities = (inverted_cap - min_p) / (max_p - min_p)\n        else:\n            normalized_priorities = np.ones_like(inverted_cap) * 0.5 # Uniform priority if all capacities are the same\n        \n        priorities[can_fit_mask] = normalized_priorities\n    \n    return priorities\n\n[Heuristics 5th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Implements a Random Fit strategy for the online Bin Packing Problem.\n    Prioritizes bins that can fit the item. A higher priority is given\n    to bins with less remaining capacity that can still fit the item,\n    encouraging tighter packing.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Returns:\n        Array of priority scores for each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    can_fit_mask = bins_remain_cap >= item\n    \n    if np.any(can_fit_mask):\n        available_bins_cap = bins_remain_cap[can_fit_mask]\n        \n        # Assign priority based on how full the bin would become\n        # Smaller remaining capacity (i.e., larger fraction filled) gets higher priority\n        # We invert the remaining capacity to make smaller values larger priorities\n        inverted_cap = 1.0 / (available_bins_cap + 1e-9) # Add epsilon to avoid division by zero\n        \n        # Normalize priorities to be between 0 and 1\n        min_p = np.min(inverted_cap)\n        max_p = np.max(inverted_cap)\n        \n        if max_p - min_p > 1e-9:\n            normalized_priorities = (inverted_cap - min_p) / (max_p - min_p)\n        else:\n            normalized_priorities = np.ones_like(inverted_cap) * 0.5 # Uniform priority if all capacities are the same\n        \n        priorities[can_fit_mask] = normalized_priorities\n    \n    return priorities\n\n[Heuristics 6th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Almost Full Fit strategy.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    available_bins_mask = bins_remain_cap >= item\n    \n    if np.any(available_bins_mask):\n        available_bins_remain_cap = bins_remain_cap[available_bins_mask]\n        \n        sorted_indices = np.argsort(available_bins_remain_cap)\n        \n        priorities[available_bins_mask] = 1.0 / (available_bins_remain_cap - item + 1e-9)\n        \n        priorities[available_bins_mask] = np.argsort(np.argsort(priorities[available_bins_mask]))\n    \n    return priorities\n\n[Heuristics 7th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Implements a Random Fit strategy for the online Bin Packing Problem.\n    Prioritizes bins that can fit the item. A higher priority is given\n    to bins with less remaining capacity that can still fit the item,\n    encouraging tighter packing.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Returns:\n        Array of priority scores for each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    can_fit_mask = bins_remain_cap >= item\n    \n    if np.any(can_fit_mask):\n        available_bins_cap = bins_remain_cap[can_fit_mask]\n        \n        # Assign priority based on how full the bin would become\n        # Smaller remaining capacity (i.e., larger fraction filled) gets higher priority\n        # We invert the remaining capacity to make smaller values larger priorities\n        inverted_cap = 1.0 / (available_bins_cap + 1e-9) # Add epsilon to avoid division by zero\n        \n        # Normalize priorities to be between 0 and 1\n        min_p = np.min(inverted_cap)\n        max_p = np.max(inverted_cap)\n        \n        if max_p - min_p > 1e-9:\n            normalized_priorities = (inverted_cap - min_p) / (max_p - min_p)\n        else:\n            normalized_priorities = np.ones_like(inverted_cap) * 0.5 # Uniform priority if all capacities are the same\n        \n        priorities[can_fit_mask] = normalized_priorities\n    \n    return priorities\n\n[Heuristics 8th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines Exact Fit First with a normalized Best Fit strategy.\n    Prioritizes exact fits, then bins with the least excess capacity\n    relative to the minimum possible excess.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Mask for bins that can fit the item\n    can_fit_mask = bins_remain_cap >= item\n    eligible_bins_cap = bins_remain_cap[can_fit_mask]\n    \n    if eligible_bins_cap.size == 0:\n        return priorities\n\n    # Mask for exact fits\n    exact_fit_mask = (eligible_bins_cap == item)\n    \n    if np.any(exact_fit_mask):\n        # Assign highest priority (1.0) to exact fits\n        priorities[can_fit_mask][exact_fit_mask] = 1.0\n        \n        # For non-exact fits, assign a lower priority band (0.0 to 0.9)\n        non_exact_fit_mask = can_fit_mask.copy()\n        non_exact_fit_mask[can_fit_mask][exact_fit_mask] = False\n        \n        if np.any(non_exact_fit_mask):\n            non_exact_bins_cap = bins_remain_cap[non_exact_fit_mask]\n            # Calculate excess capacity for non-exact fits\n            excess_capacities = non_exact_bins_cap - item\n            \n            # Find the minimum excess capacity among non-exact fits\n            min_excess_capacity = np.min(excess_capacities)\n            \n            # Calculate normalized scores: higher score for smaller excess capacity relative to min\n            # Add epsilon to avoid division by zero and to ensure scores are not infinite\n            normalized_scores = 1.0 / (excess_capacities - min_excess_capacity + 1e-9)\n            \n            # Scale these scores to a lower range (e.g., 0.0 to 0.9)\n            max_normalized_score = np.max(normalized_scores)\n            if max_normalized_score > 0:\n                scaled_scores = 0.9 * (normalized_scores / max_normalized_score)\n            else:\n                scaled_scores = np.zeros_like(normalized_scores) # Should not happen if there are non-exact fits\n\n            priorities[non_exact_fit_mask] = scaled_scores\n            \n    else:\n        # If no exact fit, all fitting bins are non-exact fits\n        # Calculate excess capacity for all eligible bins\n        excess_capacities = eligible_bins_cap - item\n        \n        # Find the minimum excess capacity\n        min_excess_capacity = np.min(excess_capacities)\n        \n        # Calculate normalized scores: higher score for smaller excess capacity relative to min\n        normalized_scores = 1.0 / (excess_capacities - min_excess_capacity + 1e-9)\n        \n        # Scale these scores to a range (e.g., 0.0 to 1.0)\n        max_normalized_score = np.max(normalized_scores)\n        if max_normalized_score > 0:\n            scaled_scores = normalized_scores / max_normalized_score\n        else:\n            scaled_scores = np.zeros_like(normalized_scores) # Should not happen\n\n        priorities[can_fit_mask] = scaled_scores\n\n    return priorities\n\n[Heuristics 9th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using First Fit strategy.\n\n    In First Fit, the item is placed in the first bin that has enough remaining capacity.\n    This heuristic prioritizes bins that can accommodate the item and gives higher\n    priority to bins that have just enough capacity to avoid fragmentation.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Assign a high priority to bins that can fit the item\n    can_fit_mask = bins_remain_cap >= item\n    priorities[can_fit_mask] = 1.0\n\n    # Among those that can fit, prioritize bins that have just enough capacity.\n    # This is a greedy approach to minimize wasted space in the selected bin.\n    # We can use the inverse of the remaining capacity minus the item size as a measure\n    # of how \"tight\" the fit is. Smaller difference means higher priority.\n    tight_fit_scores = np.where(can_fit_mask, bins_remain_cap - item, np.inf)\n    \n    # Normalize the tight fit scores to avoid overly large or small values.\n    # Add a small epsilon to avoid division by zero if all differences are the same.\n    min_tight_fit = np.min(tight_fit_scores[tight_fit_scores != np.inf]) if np.any(tight_fit_scores != np.inf) else 0\n    max_tight_fit = np.max(tight_fit_scores[tight_fit_scores != np.inf]) if np.any(tight_fit_scores != np.inf) else 1\n    \n    if max_tight_fit - min_tight_fit > 1e-9: # Avoid division by zero if all are the same\n        normalized_tight_fit = (tight_fit_scores - min_tight_fit) / (max_tight_fit - min_tight_fit)\n    else:\n        normalized_tight_fit = np.zeros_like(tight_fit_scores)\n    \n    # Invert to give higher priority to smaller differences (tighter fits)\n    inverted_normalized_tight_fit = 1.0 - normalized_tight_fit\n    \n    # Combine the \"can fit\" priority with the \"tight fit\" priority.\n    # We want to boost bins that fit and then order them by tightness.\n    # The \"+ 0.1\" ensures that bins that can fit are always prioritized over those that cannot,\n    # even if their tight fit score is very high (which shouldn't happen if they can't fit).\n    priorities = np.where(can_fit_mask, 1.0 + inverted_normalized_tight_fit * 0.1, 0)\n    \n    # Ensure that bins that cannot fit have a priority of 0\n    priorities[~can_fit_mask] = 0\n\n    return priorities\n\n[Heuristics 10th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Exact Fit First heuristic for online Bin Packing Problem.\n    Prioritizes bins that can fit the item exactly. Among those,\n    prioritizes bins with less remaining capacity to minimize wasted space.\n    If no bin fits exactly, it prioritizes bins with the least remaining capacity\n    that can still fit the item.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    exact_fit_bins_mask = (bins_remain_cap == item)\n    close_fit_bins_mask = (bins_remain_cap > item)\n\n    if np.any(exact_fit_bins_mask):\n        # Prioritize exact fits with highest priority (1)\n        priorities[exact_fit_bins_mask] = 1.0\n        # Among exact fits, a subtle bias towards less remaining capacity could be added if needed\n        # For exact fit, remaining capacity is zero, so no further differentiation needed here.\n    elif np.any(close_fit_bins_mask):\n        # If no exact fit, prioritize bins that fit with least remaining capacity\n        valid_bins_cap = bins_remain_cap[close_fit_bins_mask]\n        # Calculate a score inversely proportional to the excess capacity (bins_remain_cap - item)\n        # Adding a small epsilon to the denominator to avoid division by zero if item==0 or bins_remain_cap==item (already handled)\n        excess_capacities = valid_bins_cap - item\n        scores = 1.0 / (excess_capacities + 1e-9)\n\n        # Normalize scores to be between 0 and 1 for bins that can fit the item\n        # The highest score (least excess capacity) will be close to 1\n        max_score = np.max(scores)\n        if max_score > 0:\n            normalized_scores = scores / max_score\n        else:\n            normalized_scores = np.zeros_like(scores) # Should not happen with close_fit_bins_mask\n\n        # Assign these normalized scores to the corresponding bins\n        priorities[close_fit_bins_mask] = normalized_scores\n\n    return priorities\n\n[Heuristics 11th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines Exact Fit First with Inverse Distance for robust bin packing.\n\n    Prioritizes exact fits, then falls back to the closest fit to minimize waste.\n    This hybrid approach balances ideal packing with practical close fits.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    epsilon = 1e-9\n\n    # Calculate exact fit priority: highest for bins where remaining capacity equals item size.\n    exact_fit_mask = np.abs(bins_remain_cap - item) < epsilon\n    priorities[exact_fit_mask] = 1.0\n\n    # Calculate inverse distance priority for bins that can fit the item and are not exact fits.\n    can_fit_mask = bins_remain_cap >= item\n    non_exact_fit_mask = can_fit_mask & ~exact_fit_mask\n\n    if np.any(non_exact_fit_mask):\n        space_after_placement = bins_remain_cap[non_exact_fit_mask] - item\n        # Prioritize bins with smaller positive difference (less wasted space).\n        # Use a scaled inverse to ensure these priorities are lower than exact fits.\n        inverse_distance_scores = 1.0 / (space_after_placement + epsilon)\n        \n        # Normalize these scores to a range lower than 1.0, e.g., [0.5, 0.99]\n        # This ensures exact fits are still preferred.\n        min_norm = 0.5\n        max_norm = 0.99\n        \n        # Scale scores to [0, 1] based on their distribution, then shift to [0.5, 0.99]\n        if inverse_distance_scores.size > 1:\n            normalized_scores = (inverse_distance_scores - np.min(inverse_distance_scores)) / (np.max(inverse_distance_scores) - np.min(inverse_distance_scores) + epsilon)\n            scaled_scores = min_norm + normalized_scores * (max_norm - min_norm)\n        else:\n            # If only one bin, assign the midpoint of the secondary range\n            scaled_scores = (min_norm + max_norm) / 2.0\n\n        priorities[non_exact_fit_mask] = scaled_scores\n        \n    # Bins that cannot fit the item retain their default priority of 0.\n\n    return priorities\n\n[Heuristics 12th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines Exact Fit First with Inverse Distance for robust bin packing.\n\n    Prioritizes exact fits, then falls back to the closest fit to minimize waste.\n    This hybrid approach balances ideal packing with practical close fits.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    epsilon = 1e-9\n\n    # Calculate exact fit priority: highest for bins where remaining capacity equals item size.\n    exact_fit_mask = np.abs(bins_remain_cap - item) < epsilon\n    priorities[exact_fit_mask] = 1.0\n\n    # Calculate inverse distance priority for bins that can fit the item and are not exact fits.\n    can_fit_mask = bins_remain_cap >= item\n    non_exact_fit_mask = can_fit_mask & ~exact_fit_mask\n\n    if np.any(non_exact_fit_mask):\n        space_after_placement = bins_remain_cap[non_exact_fit_mask] - item\n        # Prioritize bins with smaller positive difference (less wasted space).\n        # Use a scaled inverse to ensure these priorities are lower than exact fits.\n        inverse_distance_scores = 1.0 / (space_after_placement + epsilon)\n        \n        # Normalize these scores to a range lower than 1.0, e.g., [0.5, 0.99]\n        # This ensures exact fits are still preferred.\n        min_norm = 0.5\n        max_norm = 0.99\n        \n        # Scale scores to [0, 1] based on their distribution, then shift to [0.5, 0.99]\n        if inverse_distance_scores.size > 1:\n            normalized_scores = (inverse_distance_scores - np.min(inverse_distance_scores)) / (np.max(inverse_distance_scores) - np.min(inverse_distance_scores) + epsilon)\n            scaled_scores = min_norm + normalized_scores * (max_norm - min_norm)\n        else:\n            # If only one bin, assign the midpoint of the secondary range\n            scaled_scores = (min_norm + max_norm) / 2.0\n\n        priorities[non_exact_fit_mask] = scaled_scores\n        \n    # Bins that cannot fit the item retain their default priority of 0.\n\n    return priorities\n\n[Heuristics 13th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    for i in range(len(bins_remain_cap)):\n        if bins_remain_cap[i] >= item:\n            priorities[i] = 1.0 / (bins_remain_cap[i] - item + 1e-9)\n        else:\n            priorities[i] = 0.0\n    return priorities\n\n[Heuristics 14th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines Exact Fit First with Inverse Distance for robust bin packing.\n\n    Prioritizes exact fits, then falls back to the closest fit to minimize waste.\n    This hybrid approach balances ideal packing with practical close fits.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    epsilon = 1e-9\n\n    # Calculate exact fit priority: highest for bins where remaining capacity equals item size.\n    exact_fit_mask = np.abs(bins_remain_cap - item) < epsilon\n    priorities[exact_fit_mask] = 1.0\n\n    # Calculate inverse distance priority for bins that can fit the item and are not exact fits.\n    can_fit_mask = bins_remain_cap >= item\n    non_exact_fit_mask = can_fit_mask & ~exact_fit_mask\n\n    if np.any(non_exact_fit_mask):\n        space_after_placement = bins_remain_cap[non_exact_fit_mask] - item\n        # Prioritize bins with smaller positive difference (less wasted space).\n        # Use a scaled inverse to ensure these priorities are lower than exact fits.\n        inverse_distance_scores = 1.0 / (space_after_placement + epsilon)\n        \n        # Normalize these scores to a range lower than 1.0, e.g., [0.5, 0.99]\n        # This ensures exact fits are still preferred.\n        min_norm = 0.5\n        max_norm = 0.99\n        \n        # Scale scores to [0, 1] based on their distribution, then shift to [0.5, 0.99]\n        if inverse_distance_scores.size > 1:\n            normalized_scores = (inverse_distance_scores - np.min(inverse_distance_scores)) / (np.max(inverse_distance_scores) - np.min(inverse_distance_scores) + epsilon)\n            scaled_scores = min_norm + normalized_scores * (max_norm - min_norm)\n        else:\n            # If only one bin, assign the midpoint of the secondary range\n            scaled_scores = (min_norm + max_norm) / 2.0\n\n        priorities[non_exact_fit_mask] = scaled_scores\n        \n    # Bins that cannot fit the item retain their default priority of 0.\n\n    return priorities\n\n[Heuristics 15th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins by favoring exact fits, then closest fits, using a smooth scoring.\n\n    Combines Exact Fit First and Inverse Distance strategies:\n    1. High priority for bins where remaining_capacity == item.\n    2. Medium priority for bins where remaining_capacity > item, inversely\n       proportional to the difference (remaining_capacity - item).\n    3. Zero priority for bins where remaining_capacity < item.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    can_fit_mask = bins_remain_cap >= item\n\n    fitting_bins_cap = bins_remain_cap[can_fit_mask]\n    fitting_bins_indices = np.where(can_fit_mask)[0]\n\n    if len(fitting_bins_cap) > 0:\n        # Prioritize exact fits with a high score\n        exact_fit_mask = fitting_bins_cap == item\n        priorities[fitting_bins_indices[exact_fit_mask]] = 2.0  # Highest priority\n\n        # For bins that are not exact fits, calculate priority based on how close they are\n        non_exact_fitting_bins_cap = fitting_bins_cap[~exact_fit_mask]\n        non_exact_fitting_bins_indices = fitting_bins_indices[~exact_fit_mask]\n\n        if len(non_exact_fitting_bins_cap) > 0:\n            # Calculate the difference (space after placing the item)\n            space_after_placement = non_exact_fitting_bins_cap - item\n\n            # Normalize these differences to a [0, 1] range for scoring.\n            # Smaller difference means higher priority.\n            min_diff = np.min(space_after_placement)\n            max_diff = np.max(space_after_placement)\n\n            if max_diff - min_diff > 1e-9: # Avoid division by zero if all differences are the same\n                normalized_diff = (space_after_placement - min_diff) / (max_diff - min_diff)\n            else:\n                normalized_diff = np.zeros_like(space_after_placement)\n            \n            # Assign priorities: inverse relationship with normalized difference, scaled down.\n            # This gives medium priority, lower than exact fits.\n            # Add a small offset to ensure it's greater than 0 for fitting bins.\n            priorities[non_exact_fitting_bins_indices] = 1.0 - normalized_diff + 0.1\n\n    return priorities\n\n[Heuristics 16th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins by favoring exact fits, then closest fits, using a smooth scoring.\n\n    Combines Exact Fit First and Inverse Distance strategies:\n    1. High priority for bins where remaining_capacity == item.\n    2. Medium priority for bins where remaining_capacity > item, inversely\n       proportional to the difference (remaining_capacity - item).\n    3. Zero priority for bins where remaining_capacity < item.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    can_fit_mask = bins_remain_cap >= item\n\n    fitting_bins_cap = bins_remain_cap[can_fit_mask]\n    fitting_bins_indices = np.where(can_fit_mask)[0]\n\n    if len(fitting_bins_cap) > 0:\n        # Prioritize exact fits with a high score\n        exact_fit_mask = fitting_bins_cap == item\n        priorities[fitting_bins_indices[exact_fit_mask]] = 2.0  # Highest priority\n\n        # For bins that are not exact fits, calculate priority based on how close they are\n        non_exact_fitting_bins_cap = fitting_bins_cap[~exact_fit_mask]\n        non_exact_fitting_bins_indices = fitting_bins_indices[~exact_fit_mask]\n\n        if len(non_exact_fitting_bins_cap) > 0:\n            # Calculate the difference (space after placing the item)\n            space_after_placement = non_exact_fitting_bins_cap - item\n\n            # Normalize these differences to a [0, 1] range for scoring.\n            # Smaller difference means higher priority.\n            min_diff = np.min(space_after_placement)\n            max_diff = np.max(space_after_placement)\n\n            if max_diff - min_diff > 1e-9: # Avoid division by zero if all differences are the same\n                normalized_diff = (space_after_placement - min_diff) / (max_diff - min_diff)\n            else:\n                normalized_diff = np.zeros_like(space_after_placement)\n            \n            # Assign priorities: inverse relationship with normalized difference, scaled down.\n            # This gives medium priority, lower than exact fits.\n            # Add a small offset to ensure it's greater than 0 for fitting bins.\n            priorities[non_exact_fitting_bins_indices] = 1.0 - normalized_diff + 0.1\n\n    return priorities\n\n[Heuristics 17th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines Exact Fit priority with a normalized Best Fit strategy.\n    Gives highest priority to exact fits, then prioritizes bins with\n    the smallest remaining capacity that can fit the item.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Identify bins that can fit the item\n    can_fit_mask = bins_remain_cap >= item\n    \n    # If no bins can fit the item, return all zeros\n    if not np.any(can_fit_mask):\n        return priorities\n\n    eligible_bins_remain_cap = bins_remain_cap[can_fit_mask]\n\n    # --- Exact Fit Strategy ---\n    # Prioritize bins that fit the item exactly with a high score\n    exact_fit_mask_local = (eligible_bins_remain_cap == item)\n    \n    # --- Normalized Best Fit Strategy ---\n    # For bins that do not fit exactly, calculate a score based on how close they are\n    # to fitting the item. Prioritize those with minimal excess capacity.\n    close_fit_mask_local = ~exact_fit_mask_local\n    \n    # Calculate excess capacity for close fits\n    excess_capacities = eligible_bins_remain_cap[close_fit_mask_local] - item\n    \n    # Assign high priority to exact fits\n    if np.any(exact_fit_mask_local):\n        priorities[can_fit_mask][exact_fit_mask_local] = 1.0\n        \n    # If there are close fits, calculate their priorities\n    if np.any(close_fit_mask_local):\n        # Normalize excess capacities to be between 0 and 1\n        # A smaller excess capacity should get a higher score.\n        # We use 1 / (normalized_excess + epsilon) to give higher scores to smaller excesses.\n        min_excess = 0.0\n        max_excess = np.max(excess_capacities) # Max excess capacity among close fits\n\n        # Avoid division by zero if all close fits have the same excess capacity\n        if max_excess > min_excess:\n            normalized_excess = (excess_capacities - min_excess) / (max_excess - min_excess)\n        else:\n            normalized_excess = np.zeros_like(excess_capacities) # All close fits have same excess\n        \n        # Calculate scores: higher score for smaller normalized excess capacity\n        # Add a base score to differentiate from bins that don't fit (score 0)\n        # and ensure scores are distinct from exact fits.\n        close_fit_scores = 0.5 + 0.45 * (1.0 / (normalized_excess + 1e-9)) # Scale to [0.5, ~0.95]\n        \n        # Ensure scores are not greater than exact fit priority\n        close_fit_scores = np.minimum(close_fit_scores, 0.99) \n        \n        # Assign scores to the corresponding bins\n        priorities[can_fit_mask][close_fit_mask_local] = close_fit_scores\n\n    # Ensure exact fits have priority over close fits if they overlap in scoring range\n    if np.any(exact_fit_mask_local) and np.any(close_fit_mask_local):\n         priorities[can_fit_mask][exact_fit_mask_local] = 1.0 # Re-assert max priority for exact fits\n\n\n    return priorities\n\n[Heuristics 18th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines Exact Fit priority with a normalized Best Fit strategy.\n    Gives highest priority to exact fits, then prioritizes bins with\n    the smallest remaining capacity that can fit the item.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Identify bins that can fit the item\n    can_fit_mask = bins_remain_cap >= item\n    \n    # If no bins can fit the item, return all zeros\n    if not np.any(can_fit_mask):\n        return priorities\n\n    eligible_bins_remain_cap = bins_remain_cap[can_fit_mask]\n\n    # --- Exact Fit Strategy ---\n    # Prioritize bins that fit the item exactly with a high score\n    exact_fit_mask_local = (eligible_bins_remain_cap == item)\n    \n    # --- Normalized Best Fit Strategy ---\n    # For bins that do not fit exactly, calculate a score based on how close they are\n    # to fitting the item. Prioritize those with minimal excess capacity.\n    close_fit_mask_local = ~exact_fit_mask_local\n    \n    # Calculate excess capacity for close fits\n    excess_capacities = eligible_bins_remain_cap[close_fit_mask_local] - item\n    \n    # Assign high priority to exact fits\n    if np.any(exact_fit_mask_local):\n        priorities[can_fit_mask][exact_fit_mask_local] = 1.0\n        \n    # If there are close fits, calculate their priorities\n    if np.any(close_fit_mask_local):\n        # Normalize excess capacities to be between 0 and 1\n        # A smaller excess capacity should get a higher score.\n        # We use 1 / (normalized_excess + epsilon) to give higher scores to smaller excesses.\n        min_excess = 0.0\n        max_excess = np.max(excess_capacities) # Max excess capacity among close fits\n\n        # Avoid division by zero if all close fits have the same excess capacity\n        if max_excess > min_excess:\n            normalized_excess = (excess_capacities - min_excess) / (max_excess - min_excess)\n        else:\n            normalized_excess = np.zeros_like(excess_capacities) # All close fits have same excess\n        \n        # Calculate scores: higher score for smaller normalized excess capacity\n        # Add a base score to differentiate from bins that don't fit (score 0)\n        # and ensure scores are distinct from exact fits.\n        close_fit_scores = 0.5 + 0.45 * (1.0 / (normalized_excess + 1e-9)) # Scale to [0.5, ~0.95]\n        \n        # Ensure scores are not greater than exact fit priority\n        close_fit_scores = np.minimum(close_fit_scores, 0.99) \n        \n        # Assign scores to the corresponding bins\n        priorities[can_fit_mask][close_fit_mask_local] = close_fit_scores\n\n    # Ensure exact fits have priority over close fits if they overlap in scoring range\n    if np.any(exact_fit_mask_local) and np.any(close_fit_mask_local):\n         priorities[can_fit_mask][exact_fit_mask_local] = 1.0 # Re-assert max priority for exact fits\n\n\n    return priorities\n\n[Heuristics 19th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines Exact Fit priority with a normalized Best Fit strategy.\n    Gives highest priority to exact fits, then prioritizes bins with\n    the smallest remaining capacity that can fit the item.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Identify bins that can fit the item\n    can_fit_mask = bins_remain_cap >= item\n    \n    # If no bins can fit the item, return all zeros\n    if not np.any(can_fit_mask):\n        return priorities\n\n    eligible_bins_remain_cap = bins_remain_cap[can_fit_mask]\n\n    # --- Exact Fit Strategy ---\n    # Prioritize bins that fit the item exactly with a high score\n    exact_fit_mask_local = (eligible_bins_remain_cap == item)\n    \n    # --- Normalized Best Fit Strategy ---\n    # For bins that do not fit exactly, calculate a score based on how close they are\n    # to fitting the item. Prioritize those with minimal excess capacity.\n    close_fit_mask_local = ~exact_fit_mask_local\n    \n    # Calculate excess capacity for close fits\n    excess_capacities = eligible_bins_remain_cap[close_fit_mask_local] - item\n    \n    # Assign high priority to exact fits\n    if np.any(exact_fit_mask_local):\n        priorities[can_fit_mask][exact_fit_mask_local] = 1.0\n        \n    # If there are close fits, calculate their priorities\n    if np.any(close_fit_mask_local):\n        # Normalize excess capacities to be between 0 and 1\n        # A smaller excess capacity should get a higher score.\n        # We use 1 / (normalized_excess + epsilon) to give higher scores to smaller excesses.\n        min_excess = 0.0\n        max_excess = np.max(excess_capacities) # Max excess capacity among close fits\n\n        # Avoid division by zero if all close fits have the same excess capacity\n        if max_excess > min_excess:\n            normalized_excess = (excess_capacities - min_excess) / (max_excess - min_excess)\n        else:\n            normalized_excess = np.zeros_like(excess_capacities) # All close fits have same excess\n        \n        # Calculate scores: higher score for smaller normalized excess capacity\n        # Add a base score to differentiate from bins that don't fit (score 0)\n        # and ensure scores are distinct from exact fits.\n        close_fit_scores = 0.5 + 0.45 * (1.0 / (normalized_excess + 1e-9)) # Scale to [0.5, ~0.95]\n        \n        # Ensure scores are not greater than exact fit priority\n        close_fit_scores = np.minimum(close_fit_scores, 0.99) \n        \n        # Assign scores to the corresponding bins\n        priorities[can_fit_mask][close_fit_mask_local] = close_fit_scores\n\n    # Ensure exact fits have priority over close fits if they overlap in scoring range\n    if np.any(exact_fit_mask_local) and np.any(close_fit_mask_local):\n         priorities[can_fit_mask][exact_fit_mask_local] = 1.0 # Re-assert max priority for exact fits\n\n\n    return priorities\n\n[Heuristics 20th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins that offer an exact fit or the smallest remaining capacity after placement.\n\n    Combines 'Exact Fit First' and 'Inverse Distance' strategies for a robust approach.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    can_fit_mask = bins_remain_cap >= item\n\n    if np.any(can_fit_mask):\n        available_bins_remain_cap = bins_remain_cap[can_fit_mask]\n\n        # Strategy 1: Exact Fit (Highest Priority)\n        exact_fit_mask = available_bins_remain_cap == item\n        if np.any(exact_fit_mask):\n            priorities[can_fit_mask][exact_fit_mask] = 1.0\n            # If there are exact fits, we only consider them for ranking (effectively)\n            # but to allow other bins to have non-zero priority if needed, we proceed.\n            # However, for simplicity and clear hierarchy, we could return here if only exact fits are desired as the sole choice.\n            # For a more nuanced approach, we allow other bins to compete if they are \"close\".\n\n        # Strategy 2: Proximity Fit (Inverse of remaining capacity after placement)\n        # Assigns higher priority to bins that leave less space after placing the item.\n        # Avoids division by zero by adding a small epsilon.\n        space_after_placement = available_bins_remain_cap - item\n        \n        # We want to prioritize bins with smaller space_after_placement.\n        # Using 1 / (space_after_placement + epsilon) favors smaller positive differences.\n        # For bins where space_after_placement is 0 (exact fit), this will be 1/epsilon (very high).\n        # To avoid extremely high values for exact fits that might dominate too much,\n        # and to ensure proximity fits are ranked meaningfully, we can cap or scale.\n        # A simple approach is to ensure exact fits get priority 1.0 and then rank others.\n\n        # Let's refine: assign 1.0 to exact fits, and then rank the rest based on inverse remaining capacity.\n        \n        non_exact_fit_mask = ~exact_fit_mask\n        if np.any(non_exact_fit_mask):\n            non_exact_available_caps = available_bins_remain_cap[non_exact_fit_mask]\n            non_exact_space_after_placement = non_exact_available_caps - item\n\n            # Calculate inverse of remaining capacity (higher score for smaller remaining capacity)\n            # Add epsilon to avoid division by zero. The smaller the remaining capacity, the higher the score.\n            proximity_scores = 1.0 / (non_exact_space_after_placement + 1e-9)\n\n            # Normalize these scores to be between 0 and (1 - epsilon) to not overlap with exact fits\n            # if we wanted a strict hierarchy.\n            # For a combined heuristic, we can normalize them relative to each other.\n            if len(proximity_scores) > 0:\n                min_prox_score = np.min(proximity_scores)\n                max_prox_score = np.max(proximity_scores)\n                \n                # Normalize scores to a range that doesn't conflict with exact fit priority (e.g., 0 to 0.99)\n                # or simply use their relative ranking.\n                # Using ranks is often more robust than raw values.\n                \n                # Rank the non-exact fits based on their proximity score (higher score = better rank)\n                # argsort returns indices that would sort the array.\n                # We want higher proximity_scores to have higher ranks.\n                sorted_indices_for_non_exact = np.argsort(proximity_scores)\n                \n                # Assign ranks: the bin with the highest proximity_score gets the highest rank (close to 1).\n                # The indices obtained from argsort are ascending for smaller values.\n                # So, if proximity_scores are [10, 5, 20], argsort gives [1, 0, 2].\n                # We want ranks [0.33, 0.66, 1.0] or similar.\n                # Let's assign ranks such that smaller space_after_placement gets higher priority.\n                \n                # Sort the actual non-exact remaining capacities to get a clear order for prioritization.\n                sorted_non_exact_space_after = non_exact_space_after_placement[sorted_indices_for_non_exact]\n                \n                # Now assign priorities based on these sorted capacities.\n                # The bin with the smallest space_after_placement gets the highest priority (excluding exact fits).\n                # We can assign priorities from 0.0 up to something less than 1.0 (e.g., 0.99).\n                # Let's normalize the ranks to a range like [0.1, 0.9].\n                \n                if len(sorted_non_exact_space_after) > 1:\n                    rank_values = np.linspace(0.1, 0.9, len(sorted_non_exact_space_after))\n                    # The smallest remaining space should get the highest rank (0.9).\n                    # The current sorted_non_exact_space_after is ascending, so the last element is the largest.\n                    # We want to assign highest priority to the smallest values.\n                    assigned_priorities_for_non_exact = rank_values[::-1] # Reverse to give highest to smallest\n                else:\n                    assigned_priorities_for_non_exact = np.array([0.5]) # Default priority for single non-exact fit\n\n                # Map these assigned priorities back to the original indices of the available_bins_array.\n                # `sorted_indices_for_non_exact` are indices within `non_exact_available_caps`\n                # We need to map these back to `can_fit_mask` indices.\n                \n                # Get the original indices within `can_fit_mask` that correspond to non_exact_fit_mask\n                original_indices_of_non_exact_fits = np.where(can_fit_mask)[0][non_exact_fit_mask]\n                \n                # Update priorities for these bins\n                priorities[original_indices_of_non_exact_fits] = assigned_priorities_for_non_exact\n\n    return priorities\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}