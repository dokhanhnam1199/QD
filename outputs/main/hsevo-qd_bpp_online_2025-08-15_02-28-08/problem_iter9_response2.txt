```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Calculates priority scores for bins to pack an item, favoring tighter fits and
    considering the relative space available.

    This heuristic prioritizes bins where the remaining capacity is just enough
    to fit the item. It uses a score that is high when remaining_capacity is close
    to item size, and decreases as the remaining capacity increases beyond the item size.
    This aims to minimize wasted space in bins.

    Args:
        item: The size of the item to be packed.
        bins_remain_cap: A numpy array representing the remaining capacity of each bin.

    Returns:
        A numpy array of priority scores, with higher scores indicating a preferred bin.
    """
    epsilon = 1e-9
    
    priorities = np.zeros_like(bins_remain_cap)
    
    # Identify bins where the item can fit.
    can_fit_mask = bins_remain_cap >= item
    
    # For bins where the item fits, calculate a priority score.
    # The score is designed to be high when bins_remain_cap is slightly larger than item.
    # This is achieved by using the ratio: bins_remain_cap / (bins_remain_cap - item + epsilon)
    # This ratio is equivalent to (item + diff) / (diff + epsilon), where diff = bins_remain_cap - item.
    # This ratio is maximized when diff is minimal (i.e., closest fit).
    
    # Ensure that we don't divide by zero or get extreme values if bins_remain_cap is very small
    # but still fits the item. The `epsilon` helps here.
    # For bins that fit, the score is calculated.
    
    # Calculate the difference for bins that can fit.
    diff_fit = bins_remain_cap[can_fit_mask] - item
    
    # Calculate the priority score. We use the inverse of the normalized difference.
    # Specifically, we want to prioritize bins where diff_fit is small and positive.
    # A score like 1 / (diff_fit + epsilon) heavily favors tight fits.
    # To make it more robust and give some preference to larger bins if no tight fit exists,
    # but still prioritize tight fits:
    # We can use a score that emphasizes the "filling ratio" when it's close to 1.
    # The score `bins_remain_cap[can_fit_mask] / (diff_fit + epsilon)` is equivalent to
    # `(item + diff_fit) / (diff_fit + epsilon)`. This score is high when diff_fit is small.
    
    # Consider a score that penalizes bins that are too empty (large remaining capacity).
    # A simple way is to use the inverse of remaining capacity for bins that are "overkill".
    # But we need to combine it with the tight-fit preference.
    
    # Let's refine the score for tight fits:
    # We want a score that is high for small positive `diff_fit`.
    # The function `1 / (diff_fit + epsilon)` achieves this.
    # Let's amplify the preference for very tight fits by squaring this term: `(1 / (diff_fit + epsilon))^2`
    # Or, let's use the ratio `bins_remain_cap[can_fit_mask] / (diff_fit + epsilon)` which naturally
    # gives higher scores to bins with less excess capacity.
    
    # Let's use the score: `bins_remain_cap[can_fit_mask] / (bins_remain_cap[can_fit_mask] - item + epsilon)`
    # This is `remaining_capacity / excess_capacity`.
    # For a tight fit (e.g., remaining=6, item=5, excess=1), score = 6/1 = 6.
    # For a loose fit (e.g., remaining=10, item=5, excess=5), score = 10/5 = 2.
    # This clearly prioritizes the tight fit.
    
    priorities[can_fit_mask] = bins_remain_cap[can_fit_mask] / (bins_remain_cap[can_fit_mask] - item + epsilon)
    
    return priorities
```
