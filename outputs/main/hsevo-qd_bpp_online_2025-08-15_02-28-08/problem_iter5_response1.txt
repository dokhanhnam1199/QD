```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Prioritizes exact fits, then bins with minimal excess capacity using normalized inverse differences."""
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    # Identify bins that can fit the item
    can_fit_mask = bins_remain_cap >= item
    eligible_bins_indices = np.where(can_fit_mask)[0]
    
    if len(eligible_bins_indices) == 0:
        return priorities

    eligible_capacities = bins_remain_cap[eligible_bins_indices]
    
    # Calculate excess capacity for eligible bins
    excess_capacity = eligible_capacities - item
    
    # --- Strategy: Exact Fit First ---
    # Assign highest priority to bins that are an exact fit.
    exact_fit_mask = (excess_capacity == 0)
    exact_fit_indices = eligible_bins_indices[exact_fit_mask]
    if len(exact_fit_indices) > 0:
        priorities[exact_fit_indices] = 2.0 # Highest priority score
        
    # --- Strategy: Best Fit (Minimal Excess Capacity) ---
    # For bins that are not an exact fit, prioritize those with the least excess capacity.
    # Use a normalized inverse of the excess capacity to give higher scores to tighter fits.
    non_exact_fit_indices = eligible_bins_indices[~exact_fit_mask]
    
    if len(non_exact_fit_indices) > 0:
        non_exact_excess_capacity = excess_capacity[~exact_fit_mask]
        
        # Normalize differences: smaller difference means higher priority.
        # We use (1.0 - normalized_difference) to map smaller excess to higher score.
        min_excess = np.min(non_exact_excess_capacity)
        max_excess = np.max(non_exact_excess_capacity)
        
        if max_excess - min_excess > 1e-9: # Avoid division by zero if all are the same
            normalized_excess = (non_exact_excess_capacity - min_excess) / (max_excess - min_excess)
            # Higher score for smaller normalized excess
            best_fit_scores = 1.0 - normalized_excess 
        else:
            best_fit_scores = np.ones_like(non_exact_excess_capacity) # All are equally good if range is zero

        # Scale scores to a range lower than exact fit (e.g., [0.1, 1.0])
        # Add a base score and scale to ensure they are distinct from exact fit but ordered.
        scaled_best_fit_scores = 0.1 + best_fit_scores * 0.9
        
        priorities[non_exact_fit_indices] = scaled_best_fit_scores
    
    # Ensure bins that don't fit at all have zero priority
    priorities[~can_fit_mask] = 0.0
    
    return priorities
```
