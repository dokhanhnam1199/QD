```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Prioritizes exact fits with a high score, then uses scaled inverse
    remaining capacity for close fits, ensuring a clear hierarchy.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    epsilon = 1e-9

    # Mask for bins where the item can fit
    can_fit_mask = bins_remain_cap >= item

    if not np.any(can_fit_mask):
        return priorities # Return all zeros if item doesn't fit anywhere

    # Calculate remaining capacity if item is placed in eligible bins
    eligible_bins_remain_cap = bins_remain_cap[can_fit_mask]
    remaining_after_packing = eligible_bins_remain_cap - item

    # Priority for exact fits (remaining_after_packing is close to zero)
    exact_fit_mask_local = np.abs(remaining_after_packing) < epsilon
    priorities[can_fit_mask][exact_fit_mask_local] = 2.0

    # Priority for close fits (non-exact fits)
    non_exact_fit_mask_local = ~exact_fit_mask_local
    if np.any(non_exact_fit_mask_local):
        close_fit_remaining = remaining_after_packing[non_exact_fit_mask_local]

        # Scale inverse of remaining capacity to [0.1, 1.0] for close fits
        # Lower remaining capacity (tighter fit) gets higher priority
        min_excess = 0.0
        max_excess = np.max(close_fit_remaining)

        if max_excess > min_excess:
            # Higher score for smaller excess capacity
            normalized_close_fit_scores = 1.0 - (close_fit_remaining - min_excess) / (max_excess - min_excess)
        else:
            normalized_close_fit_scores = np.ones_like(close_fit_remaining) # All same excess, assign max score

        # Scale to [0.1, 1.0]
        min_target = 0.1
        max_target = 1.0
        
        # Check if there's a range to scale
        if np.max(normalized_close_fit_scores) - np.min(normalized_close_fit_scores) > epsilon:
            scaled_close_fit_priorities = min_target + (normalized_close_fit_scores - np.min(normalized_close_fit_scores)) * (max_target - min_target) / (np.max(normalized_close_fit_scores) - np.min(normalized_close_fit_scores))
        else:
            scaled_close_fit_priorities = np.full_like(normalized_close_fit_scores, (min_target + max_target) / 2.0) # If all are same, use midpoint

        priorities[can_fit_mask][non_exact_fit_mask_local] = scaled_close_fit_priorities

    return priorities
```
