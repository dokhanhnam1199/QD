```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Prioritizes exact fits and then uses a scaled inverse of normalized excess capacity
    for other bins, ensuring tight fits get the highest scores.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    epsilon = 1e-9

    # Identify bins that can accommodate the item
    can_fit_mask = bins_remain_cap >= item
    eligible_bins_indices = np.where(can_fit_mask)[0]

    if len(eligible_bins_indices) == 0:
        return priorities

    eligible_capacities = bins_remain_cap[eligible_bins_indices]
    excess_capacity = eligible_capacities - item

    # --- Strategy: Exact Fit First ---
    # Assign the highest priority score to bins that are an exact fit.
    exact_fit_mask = (excess_capacity < epsilon)
    exact_fit_indices = eligible_bins_indices[exact_fit_mask]
    if len(exact_fit_indices) > 0:
        priorities[exact_fit_indices] = 2.0

    # --- Strategy: Best Fit (Minimal Excess Capacity) ---
    # For bins that are not an exact fit, prioritize those with the least excess capacity.
    non_exact_fit_indices = eligible_bins_indices[~exact_fit_mask]
    
    if len(non_exact_fit_indices) > 0:
        non_exact_excess = excess_capacity[~exact_fit_mask]
        
        # Normalize differences to rank bins based on how close their excess capacity is to zero.
        # The score is inversely proportional to the normalized excess capacity.
        # A small positive excess capacity should yield a high score, close to 1.0.
        min_excess = np.min(non_exact_excess)
        max_excess = np.max(non_exact_excess)
        
        if max_excess - min_excess > epsilon:
            # Scale excess capacity to [0, 1]
            normalized_excess = (non_exact_excess - min_excess) / (max_excess - min_excess)
            # Invert and shift to get scores in [0, 1), higher for smaller excess.
            # We use 1.0 - normalized_excess as the base score.
            scaled_scores = 0.9 * (1.0 - normalized_excess)
        else:
            # If all non-exact fits have the same excess capacity, assign a medium score.
            scaled_scores = np.full_like(non_exact_excess, 0.45) # Mid-range score

        # Assign scores to non-exact fits, ensuring they are lower than exact fits.
        priorities[non_exact_fit_indices] = scaled_scores

    return priorities
```
