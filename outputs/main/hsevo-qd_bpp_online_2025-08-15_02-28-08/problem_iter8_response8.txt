```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Hybrid heuristic: Exact Fit First combined with scaled Inverse Difference.
    Prioritizes exact fits, then best fits to minimize wasted space.
    """
    priorities = np.zeros_like(bins_remain_cap)
    epsilon = 1e-9

    # Mask for bins that can fit the item
    can_fit_mask = bins_remain_cap >= item

    # Mask for exact fits
    exact_fit_mask = np.abs(bins_remain_cap - item) < epsilon

    # Assign highest priority to exact fits
    priorities[exact_fit_mask] = 1.0

    # Mask for bins that can fit but are not exact fits (close fits)
    close_fit_mask = can_fit_mask & ~exact_fit_mask

    if np.any(close_fit_mask):
        # Calculate difference for close fits
        space_after_placement = bins_remain_cap[close_fit_mask] - item
        
        # Score close fits based on inverse difference (smaller difference = higher score)
        # Scores are scaled to be between 0.1 and 0.9 to ensure exact fits are always preferred
        scores = 1.0 / (space_after_placement + epsilon)
        
        # Normalize scores to [0, 1] range
        if scores.size > 1:
            normalized_scores = (scores - np.min(scores)) / (np.max(scores) - np.min(scores) + epsilon)
        else:
            normalized_scores = np.ones_like(scores) # If only one close fit bin, give it a max score within the range

        # Scale normalized scores to the range [0.1, 0.9]
        scaled_scores = 0.1 + normalized_scores * 0.8
        
        priorities[close_fit_mask] = scaled_scores

    return priorities
```
