```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Prioritizes exact fits, then bins with minimal excess capacity, using vectorized operations."""
    
    epsilon = 1e-9
    priorities = np.zeros_like(bins_remain_cap)
    
    # Identify bins where the item can fit
    can_fit_mask = bins_remain_cap >= item
    
    # Get remaining capacities and indices for bins that can fit the item
    fitting_bins_cap = bins_remain_cap[can_fit_mask]
    fitting_bins_indices = np.where(can_fit_mask)[0]
    
    if len(fitting_bins_cap) > 0:
        # Calculate the difference (excess capacity) for bins that fit
        diff = fitting_bins_cap - item
        
        # Prioritize exact fits with the highest score (e.g., 1.0)
        exact_fit_mask = diff < epsilon
        priorities[fitting_bins_indices[exact_fit_mask]] = 1.0
        
        # For bins that are not exact fits, assign a priority based on inverse excess capacity
        # This means smaller excess capacity gets higher priority.
        # We scale it to be less than 1.0 to ensure exact fits are always preferred.
        non_exact_fitting_bins_cap = fitting_bins_cap[~exact_fit_mask]
        non_exact_fitting_indices = fitting_bins_indices[~exact_fit_mask]
        non_exact_diff = diff[~exact_fit_mask]
        
        if len(non_exact_fitting_cap) > 0:
            # Score: remaining_capacity / (remaining_capacity - item + epsilon)
            # This is equivalent to (item + diff) / (diff + epsilon)
            # This ratio is maximized when diff is minimized.
            # We scale this to a range [0, 0.99] to ensure it's always less than the exact fit priority.
            
            # Calculate the raw score, which is high for small positive differences
            raw_scores = non_exact_fitting_cap / (non_exact_diff + epsilon)
            
            # Normalize scores to be within [0, 0.99]
            min_score = 0.0
            max_score = 0.99
            
            # Avoid division by zero if all raw_scores are the same
            score_range = np.max(raw_scores) - np.min(raw_scores)
            if score_range < epsilon:
                normalized_scores = np.full_like(raw_scores, (min_score + max_score) / 2.0)
            else:
                normalized_scores = min_score + (raw_scores - np.min(raw_scores)) / score_range * (max_score - min_score)
            
            priorities[non_exact_fitting_indices] = normalized_scores
            
    return priorities
```
