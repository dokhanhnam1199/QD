```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best Fit with a normalized Exact Fit strategy.
    Prioritizes exact fits and then uses inverse excess capacity for close fits.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    can_fit_mask = bins_remain_cap >= item

    if not np.any(can_fit_mask):
        return priorities

    eligible_bins_remain_cap = bins_remain_cap[can_fit_mask]

    # Assign highest priority to exact fits
    exact_fit_mask_local = (eligible_bins_remain_cap == item)
    if np.any(exact_fit_mask_local):
        priorities[can_fit_mask][exact_fit_mask_local] = 1.0

    # For non-exact fits, prioritize based on minimal excess capacity
    close_fit_mask_local = ~exact_fit_mask_local
    if np.any(close_fit_mask_local):
        excess_capacities = eligible_bins_remain_cap[close_fit_mask_local] - item
        
        # Normalize excess capacities to differentiate close fits
        # Smaller excess should have higher priority (closer to 1.0)
        min_excess = 0.0
        max_excess = np.max(excess_capacities)

        if max_excess > min_excess:
            normalized_excess = (excess_capacities - min_excess) / (max_excess - min_excess)
        else:
            normalized_excess = np.zeros_like(excess_capacities)

        # Assign priorities between 0.1 and 0.9, inverted for smaller excess
        # Add a small base to distinguish from 0 priority and ensure separation from exact fits
        close_fit_scores = 0.1 + 0.8 * (1.0 - normalized_excess)
        priorities[can_fit_mask][close_fit_mask_local] = close_fit_scores

    # Ensure exact fits (score 1.0) are strictly prioritized over close fits
    if np.any(exact_fit_mask_local):
        priorities[can_fit_mask][exact_fit_mask_local] = np.maximum(priorities[can_fit_mask][exact_fit_mask_local], 1.0)

    return priorities
```
