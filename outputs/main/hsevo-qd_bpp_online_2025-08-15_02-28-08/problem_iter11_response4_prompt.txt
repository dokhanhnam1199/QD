{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code only and do not add comments into the code. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin using Almost Full Fit strategy.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    available_bins_mask = bins_remain_cap >= item\n    \n    if np.any(available_bins_mask):\n        available_bins_remain_cap = bins_remain_cap[available_bins_mask]\n        \n        sorted_indices = np.argsort(available_bins_remain_cap)\n        \n        priorities[available_bins_mask] = 1.0 / (available_bins_remain_cap - item + 1e-9)\n        \n        priorities[available_bins_mask] = np.argsort(np.argsort(priorities[available_bins_mask]))\n    \n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Prioritizes exact fits, then bins with minimal excess capacity using a scaled inverse difference.\n\n    This heuristic gives the highest priority to bins that exactly fit the item.\n    For bins that don't fit exactly but can accommodate the item, it assigns\n    priority based on the inverse of the excess capacity, scaled to emphasize\n    tighter fits.\n    \"\"\"\n    epsilon = 1e-9\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Identify bins where the item can fit\n    can_fit_mask = bins_remain_cap >= item\n    \n    if not np.any(can_fit_mask):\n        return priorities\n\n    # Calculate excess capacity for bins that can fit the item\n    excess_capacity = bins_remain_cap[can_fit_mask] - item\n\n    # Assign highest priority (1.0) to exact fits\n    exact_fit_mask_local = (excess_capacity < epsilon)\n    priorities[can_fit_mask][exact_fit_mask_local] = 1.0\n\n    # For bins that don't fit exactly, calculate priority based on inverse excess capacity\n    close_fit_mask_local = ~exact_fit_mask_local\n    \n    if np.any(close_fit_mask_local):\n        eligible_excess_capacity = excess_capacity[close_fit_mask_local]\n        \n        # Calculate a score proportional to 1 / (excess_capacity + epsilon).\n        # This favors smaller excess capacities (tighter fits).\n        # We normalize this score to be between 0 and 1 to avoid overwhelming exact fits.\n        # A simple normalization: 1 / (1 + scaled_excess_capacity)\n        # Where scaled_excess_capacity is normalized difference.\n        \n        # To ensure scores are distinct from exact fits and rank close fits,\n        # let's use a score that starts below 1.0 and increases as excess capacity decreases.\n        # A simple way is to map the inverse excess capacity to a range like [0.1, 0.9].\n        # The inverse of excess capacity is `1 / (eligible_excess_capacity + epsilon)`.\n        # To bound this, we can consider the maximum inverse excess capacity.\n        \n        # A robust way: Use the inverse of (normalized excess + 1) to get scores in (0, 1].\n        # Let's normalize excess capacity relative to the item size itself,\n        # but ensuring we handle cases where item is very small or zero gracefully if needed.\n        \n        # A simpler score: `1 / (excess_capacity + epsilon)`\n        # Let's scale this to be less than 1.0.\n        # A common approach is `1 / (1 + scaled_value)`.\n        # Let's use `1 / (1 + normalized_excess_capacity)` where normalized is between 0 and some value.\n        \n        # Alternative: score = 0.5 + 0.45 * (1 / (normalized_excess_capacity + epsilon))\n        # This maps normalized excess from 0 to some value into [0.5, ~0.95].\n        \n        # Let's use the remaining capacity itself, but inverted and scaled.\n        # Score = remaining_cap / (remaining_cap - item + epsilon)\n        # This is `(item + excess) / (excess + epsilon)`.\n        # To keep it below 1, we can divide by a factor, e.g., `(item + excess) / (excess + epsilon) / (item/item + epsilon)`\n        \n        # A better approach is to normalize the excess capacity and then use its inverse.\n        # Normalize excess capacity: consider a reasonable upper bound for excess_capacity.\n        # If we assume item size is at most B (max bin capacity), then excess capacity is at most B.\n        # Let's consider `excess_capacity / item` (if item > 0).\n        \n        # A simple and effective score for close fits: `1 / (excess_capacity + epsilon)`\n        # We need to scale this to be less than 1.0.\n        # Find the maximum inverse excess capacity among close fits.\n        max_inv_excess = np.max(1.0 / (eligible_excess_capacity + epsilon))\n        \n        # Scale scores for close fits to be in the range [0.1, 0.9]\n        # Score = 0.1 + 0.8 * (1.0 / (eligible_excess_capacity + epsilon)) / max_inv_excess\n        # This ensures that the tightest fit gets ~0.9 and others scale down.\n        scores_for_close_fits = 0.1 + 0.8 * (1.0 / (eligible_excess_capacity + epsilon)) / (max_inv_excess + epsilon)\n        \n        # Ensure scores are not exactly 1.0 (reserved for exact fits)\n        scores_for_close_fits = np.minimum(scores_for_close_fits, 0.999)\n        \n        priorities[can_fit_mask][close_fit_mask_local] = scores_for_close_fits\n        \n    return priorities\n\n### Analyze & experience\n- Comparing Heuristic 1 (Best) and Heuristic 5 (also the same as 1): Both use `bins_remain_cap / (diff + epsilon)` to prioritize tight fits, favoring bins where `bins_remain_cap` is close to `item`.\n\nComparing Heuristic 2 and Heuristic 4: Both are identical to Heuristic 1, essentially repeating the same logic. The extensive commented-out exploration in Heuristic 2 doesn't translate to a distinct improvement or change in the final implemented logic compared to Heuristic 1.\n\nComparing Heuristic 3 and Heuristic 12/13/14: Heuristic 3 uses `bins_remain_cap / (diff + epsilon)`, similar to Heuristic 1. Heuristics 12, 13, and 14 introduce a tiered approach: highest priority for exact fits (score 2.0), and medium priority for non-exact fits based on normalized differences (scaled to be less than 2.0, e.g., `1.0 - normalized_diff + 0.1`). This tiered approach is more sophisticated than a single scoring function.\n\nComparing Heuristic 6 and Heuristic 7: Heuristic 6 uses a two-tier system: 1.0 for exact fits, and then normalized scores (0.0-0.9) for non-exact fits based on inverse of excess capacity relative to the minimum excess. Heuristic 7 is similar but assigns 2.0 to exact fits and scales non-exact fits to [0.1, 1.0]. The normalization in Heuristic 7 might be more robust if the range of excess capacities is large.\n\nComparing Heuristic 10/11 and Heuristic 16/17/19: Heuristics 10, 11 use a fixed priority of 1.0 for exact fits and scale non-exact fits to a range [0.5, 0.99] based on inverse normalized excess. Heuristics 16, 17, 19 also give 1.0 to exact fits but scale non-exact fits to a range like [0.1, 0.9] using inverse excess capacity relative to the maximum inverse excess capacity. The scaling in 16/17/19 seems more nuanced for ranking close fits.\n\nComparing Heuristic 8 and Heuristic 9: Heuristic 8 sorts available bins by remaining capacity and then assigns ranks based on sorted priorities (which appears to be a form of inverse remaining capacity). Heuristic 9 directly uses the inverse of available capacity (not excess capacity) and normalizes it. Heuristic 8's approach of ranking based on sorted values might be more stable.\n\nComparing Heuristic 15/18 and Heuristic 20: Heuristic 15/18 prioritizes exact fits with 1.0 and scales non-exact fits to [0, 0.9] using normalized inverse of space after placement. Heuristic 20 also prioritizes exact fits with 1.0 but scales non-exact fits to [0.5, 0.99] using inverse of normalized excess capacity. The latter scaling and explicit re-assertion of exact fit priority seem slightly more robust.\n\nOverall: More sophisticated heuristics implement a multi-tiered strategy (exact fit, then best fit based on normalized excess/inverse excess) with carefully chosen scaling factors to differentiate priorities. Simple inverse or ratio-based scoring is less effective than tiered approaches.\n- \nHere's a refined approach to self-reflection for designing better heuristics:\n\n*   **Keywords:** Exact Fit, Minimal Excess Capacity, Scaled Difference, Vectorization.\n*   **Advice:** Explicitly separate exact fits with maximum priority. For close fits, score based on a scaled measure of excess capacity, ensuring these scores are always lower than exact fit scores. Leverage vectorized operations for efficiency.\n*   **Avoid:** Complex non-linear transformations on capacity differences, convoluted array manipulations, and overly aggressive normalization that can obscure relative performance.\n*   **Explanation:** This approach clearly prioritizes perfect solutions while providing a predictable and tunable mechanism for selecting the \"best\" imperfect fit, all within an efficient computational framework.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}