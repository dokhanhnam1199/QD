```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Prioritizes exact fits, then bins with minimal excess capacity.
    Leverages vectorized operations for efficiency and robustness.
    """
    priorities = np.zeros_like(bins_remain_cap)
    
    # Mask for bins that can fit the item
    can_fit_mask = bins_remain_cap >= item
    eligible_bins_cap = bins_remain_cap[can_fit_mask]
    
    if np.any(can_fit_mask):
        # Calculate the difference (excess capacity) for eligible bins
        excess_capacities = eligible_bins_cap - item
        
        # Prioritize exact fits with the highest score
        exact_fit_mask = (excess_capacities == 0)
        if np.any(exact_fit_mask):
            priorities[can_fit_mask][exact_fit_mask] = 2.0 
        
        # For non-exact fits, prioritize those with the smallest excess capacity
        # Use inverse of (excess_capacity - min_excess_capacity + epsilon)
        # This gives higher scores to bins closer to the best possible fit (minimum excess)
        non_exact_fit_mask = ~exact_fit_mask
        if np.any(non_exact_fit_mask):
            non_exact_eligible_caps = eligible_bins_cap[non_exact_fit_mask]
            non_exact_excess = non_exact_eligible_caps - item
            
            min_excess = np.min(non_exact_excess)
            
            # Calculate scores: higher for smaller (non_exact_excess - min_excess)
            # Add a base score to distinguish from exact fits and ensure positivity
            scores = 1.0 + (1.0 / (non_exact_excess - min_excess + 1e-9))
            
            # Normalize scores to a range below exact fits (e.g., 0.1 to 1.1)
            max_score = np.max(scores)
            min_score = np.min(scores)
            if max_score > min_score:
                normalized_scores = 0.9 * (scores - min_score) / (max_score - min_score) + 0.1
            else:
                normalized_scores = np.full_like(scores, 0.5) # All same, center it

            priorities[can_fit_mask][non_exact_fit_mask] = normalized_scores

    return priorities
```
