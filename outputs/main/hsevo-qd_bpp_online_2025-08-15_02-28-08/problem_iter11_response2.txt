```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Prioritizes exact fits with highest score, then best fits by scaled inverse excess capacity.
    Favors bins that are close to exact fit without being exact.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    epsilon = 1e-9

    # Identify bins that can fit the item
    can_fit_mask = bins_remain_cap >= item

    # Separate bins into exact fits and non-exact fits that can accommodate the item
    exact_fit_mask = can_fit_mask & (np.abs(bins_remain_cap - item) < epsilon)
    non_exact_fit_mask = can_fit_mask & ~exact_fit_mask

    # Assign the highest priority to exact fits
    priorities[exact_fit_mask] = 2.0

    # For bins that can fit but are not exact fits, calculate a secondary priority
    if np.any(non_exact_fit_mask):
        fitting_bins_non_exact_caps = bins_remain_cap[non_exact_fit_mask]
        space_after_placement = fitting_bins_non_exact_caps - item

        # Calculate scores for non-exact fits: favor smaller space_after_placement
        # Normalize these scores to a range [0, 1] where smaller difference gets higher score
        min_diff = np.min(space_after_placement)
        max_diff = np.max(space_after_placement)

        if max_diff - min_diff > epsilon:
            normalized_diff = (space_after_placement - min_diff) / (max_diff - min_diff)
        else:
            normalized_diff = np.zeros_like(space_after_placement)

        # Assign secondary priorities in a range lower than exact fits (e.g., [1.0, 1.9])
        # A higher score for smaller normalized difference
        secondary_priorities = 1.9 - normalized_diff * 0.9
        
        # Apply these secondary priorities to the corresponding bins
        priorities[non_exact_fit_mask] = secondary_priorities

    return priorities
```
