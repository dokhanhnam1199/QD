```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Combines Exact Fit with a normalized Best Fit strategy.

    Prioritizes exact fits with a high score, then uses a scaled inverse
    of the excess capacity for other fitting bins, prioritizing tighter fits.
    """
    priorities = np.zeros_like(bins_remain_cap)
    can_fit_mask = bins_remain_cap >= item

    fitting_bins_cap = bins_remain_cap[can_fit_mask]
    fitting_bins_indices = np.where(can_fit_mask)[0]

    if len(fitting_bins_cap) > 0:
        # Assign highest priority to exact fits
        exact_fit_mask = fitting_bins_cap == item
        priorities[fitting_bins_indices[exact_fit_mask]] = 2.0

        # For non-exact fits, prioritize based on minimal remaining space
        non_exact_fitting_bins_cap = fitting_bins_cap[~exact_fit_mask]
        non_exact_fitting_bins_indices = fitting_bins_indices[~exact_fit_mask]

        if len(non_exact_fitting_bins_cap) > 0:
            space_after_placement = non_exact_fitting_bins_cap - item

            # Normalize differences to a [0, 1] range (smaller diff = higher priority)
            min_diff = np.min(space_after_placement)
            max_diff = np.max(space_after_placement)

            if max_diff - min_diff > 1e-9:
                normalized_diff = (space_after_placement - min_diff) / (max_diff - min_diff)
            else:
                normalized_diff = np.zeros_like(space_after_placement)
            
            # Assign priority: 1.0 - normalized_diff gives higher scores to smaller differences.
            # Add 0.1 to ensure these scores are distinct from 0 and lower than exact fits (2.0).
            priorities[non_exact_fitting_bins_indices] = 1.0 - normalized_diff + 0.1
            
    return priorities
```
