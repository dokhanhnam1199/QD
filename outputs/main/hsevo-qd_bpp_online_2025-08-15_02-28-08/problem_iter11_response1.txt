```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Prioritizes exact fits, then favors bins with minimal excess capacity, scaled.

    This heuristic assigns the highest priority to bins with an exact fit and
    uses a scaled inverse of excess capacity for non-exact fits, ensuring a
    clear hierarchy and distinguishable scores.
    """
    priorities = np.zeros_like(bins_remain_cap)
    epsilon = 1e-9

    # Highest priority for exact fits (score = 2.0)
    exact_fit_mask = np.abs(bins_remain_cap - item) < epsilon
    priorities[exact_fit_mask] = 2.0

    # For bins that can fit but are not exact fits
    can_fit_mask = bins_remain_cap >= item
    non_exact_fit_mask = can_fit_mask & ~exact_fit_mask

    if np.any(non_exact_fit_mask):
        excess_capacity = bins_remain_cap[non_exact_fit_mask] - item

        # Use inverse of excess capacity, scaled to [0.5, 1.5]
        # This favors smaller excess capacities, providing medium-high priority
        min_secondary_priority = 0.5
        max_secondary_priority = 1.5

        # Calculate inverse scores for non-exact fits
        inverse_scores = 1.0 / (excess_capacity + epsilon)

        # Normalize these inverse scores to [0, 1]
        if inverse_scores.size > 1:
            normalized_inverse_scores = (inverse_scores - np.min(inverse_scores)) / (np.max(inverse_scores) - np.min(inverse_scores) + epsilon)
        else:
            normalized_inverse_scores = np.ones_like(inverse_scores)

        # Scale normalized scores to the desired secondary priority range
        scaled_secondary_scores = min_secondary_priority + normalized_inverse_scores * (max_secondary_priority - min_secondary_priority)
        
        priorities[non_exact_fit_mask] = scaled_secondary_scores

    return priorities
```
