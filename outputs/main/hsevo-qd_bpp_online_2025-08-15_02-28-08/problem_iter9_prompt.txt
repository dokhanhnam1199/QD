{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code only and do not add comments into the code. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\nCurrent heuristics:\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin using a more sophisticated strategy.\n\n    This heuristic prioritizes bins that have just enough remaining capacity to fit the item,\n    while also considering bins that have significantly more capacity as a secondary factor.\n    It aims to reduce fragmentation by favoring tighter fits.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    epsilon = 1e-9\n    \n    # Calculate the difference between remaining capacity and item size\n    diff = bins_remain_cap - item\n    \n    # Initialize priorities to zero (for bins where the item doesn't fit)\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    # Identify bins where the item can fit\n    can_fit_mask = diff >= 0\n    \n    # For bins where the item fits, calculate a priority score.\n    # The primary goal is to find bins with a small positive difference (tightest fit).\n    # We use an inverse of (difference + epsilon) for tighter fits to give them higher scores.\n    # We also add a small bonus for bins with much larger remaining capacity to not\n    # completely discard them if no tight fit is available. This bonus is smaller.\n    \n    # Calculate inverse difference for tight fits: higher score for smaller positive difference\n    tight_fit_scores = 1 / (diff[can_fit_mask] + epsilon)\n    \n    # Calculate a secondary score for bins with more remaining capacity than the item size.\n    # This is a simpler inverse of remaining capacity, scaled down.\n    # We want to avoid division by zero for bins with zero remaining capacity if they exist (though item wouldn't fit)\n    # and to give some priority to larger bins if no tight fit is available.\n    # Using the original bins_remain_cap for this secondary scoring.\n    \n    # We can normalize the remaining capacities to get a sense of \"how much space\" is left relative to bin capacity.\n    # However, since we don't have the original bin capacity, we can use a heuristic.\n    # Let's simply use the remaining capacity itself, but scaled.\n    # A simpler approach without original bin capacity is to just use the inverse of difference for those that fit.\n    \n    # Let's refine the logic:\n    # Priority 1: Bins with smallest positive `diff` (tightest fit). This is `1 / (diff + epsilon)`.\n    # Priority 2: Bins with larger `diff`. These are less preferred than tight fits.\n    # A simple way to combine is to give a high score to tight fits and a moderate score to larger fits.\n    \n    # Let's use a piecewise approach for scoring:\n    # For bins that fit:\n    # If diff is very small (e.g., diff < threshold), assign a high priority (e.g., 100 + 1/diff).\n    # If diff is larger, assign a lower priority (e.g., 10 + 1/diff).\n    # This requires tuning `threshold`.\n    \n    # A more robust approach without arbitrary thresholds:\n    # We want to maximize `1/(diff + epsilon)` for tight fits and still assign some score to larger fits.\n    # Consider the ratio of remaining capacity to item size.\n    \n    # Let's try scoring based on inverse difference, and then add a penalty for \"too much\" space.\n    # Or, simply, prioritize bins where `bins_remain_cap` is \"close\" to `item`.\n    \n    # Let's use a score that is high for small positive differences and decreases as the difference grows.\n    # A Gaussian-like function centered around 0 (for `diff`) could work, but it's complex.\n    \n    # Simpler idea: prioritize bins that have *just enough* space.\n    # We can define \"just enough\" as being within a certain percentage of the item size.\n    # For example, if diff is between 0 and `item * tolerance`.\n    \n    # Let's revisit the inverse distance, but modify it to be more sensitive to small differences.\n    # A score that is high for small `diff` and then drops off.\n    # Consider `score = 1 / (diff^2 + epsilon)` or `score = exp(-k * diff)`\n    \n    # Let's try a score that emphasizes the \"tightness\" by squaring the inverse of the difference.\n    # This will amplify the priority for very tight fits.\n    \n    # Calculate the inverse of difference for bins that can fit the item\n    # For bins where it can fit, the priority is proportional to 1 / (difference + epsilon)\n    # We want to boost the priority for smaller differences more significantly.\n    # Let's use (1 / (diff + epsilon))^2 for a stronger emphasis on tightness.\n    \n    # This still might give a very small positive difference a disproportionately high score.\n    \n    # Alternative: Focus on the ratio of remaining capacity to item size.\n    # Bins with `bins_remain_cap / item` close to 1 are good.\n    # Ratio = bins_remain_cap / item. We want ratio ~ 1.\n    # Score could be proportional to `1 / abs(ratio - 1)`.\n    # However, this doesn't account for the absolute amount of space. A bin with 10 capacity\n    # and item 9 (ratio 1.11) is better than bin with 100 capacity and item 9 (ratio 1.01)\n    # if we only consider this ratio. We need to combine it.\n    \n    # Let's stick to the difference but prioritize small positive differences more strongly.\n    # A function like `f(x) = 1/(x+epsilon)` is already good.\n    # What if we add a small bonus for bins that have \"plenty\" of space, but significantly less than tight fits?\n    \n    # Let's try to make it more robust to scale by normalizing.\n    # If we knew the maximum bin capacity, we could normalize. Without it, it's hard.\n    \n    # Back to basics, `priority_v1` favors bins with largest remaining capacity among those that fit.\n    # `1 / (diff + epsilon)` favors bins with smallest `diff`. This is generally good.\n    \n    # How to improve:\n    # 1. Give stronger weight to *very* tight fits.\n    # 2. Ensure that bins that are *almost* full but still fit are prioritized over bins that are nearly empty but fit.\n    \n    # Let's try a compound score:\n    # Score1: Inverse difference (prioritizes tight fits)\n    # Score2: A small bonus for bins that are not too empty, scaled by how much they can fit.\n    \n    # For bins that can fit:\n    # `tight_fit_score = 1 / (diff + epsilon)`\n    \n    # Now, consider the \"emptiness\" of the bin if it fits.\n    # A bin that has `bins_remain_cap` close to `item` is good.\n    # A bin that has `bins_remain_cap` much larger than `item` is less ideal in terms of fragmentation.\n    \n    # Let's define a score that peaks at `diff = 0` (or slightly negative) and decreases.\n    # However, we only consider `diff >= 0`. So we want it to peak at `diff = 0`.\n    \n    # Consider a function that is `1/(diff + epsilon)` for tight fits, and maybe a constant or decaying function for larger fits.\n    \n    # Let's try a score that emphasizes \"just enough\" space more, and \"plenty\" of space less.\n    # If `diff` is small (e.g., < `item / 2`), give it a higher score.\n    # If `diff` is large (e.g., > `item / 2`), give it a lower score.\n    \n    # Let's normalize `diff` relative to the item size.\n    # `normalized_diff = diff / item` (if item > 0)\n    # We want `normalized_diff` close to 0.\n    \n    # Score = `1 / (normalized_diff + epsilon)` for `normalized_diff >= 0`\n    # This is equivalent to `item / (bins_remain_cap - item + epsilon)` which is similar to `priority_v1` but normalized.\n    \n    # Let's try to blend the inverse difference with a penalty for being too \"empty\".\n    # A bin that fits has `bins_remain_cap >= item`.\n    # If `bins_remain_cap` is much larger than `item`, it's \"too empty\".\n    \n    # Let's use a score based on how much of the remaining capacity is *used* by the item.\n    # If `bins_remain_cap` is very close to `item`, then `item / bins_remain_cap` is close to 1.\n    # If `bins_remain_cap` is much larger than `item`, then `item / bins_remain_cap` is close to 0.\n    \n    # So, we want to prioritize bins where `item / bins_remain_cap` is close to 1.\n    # Score = `1 / abs((item / bins_remain_cap) - 1 + epsilon)`\n    # This can be written as `bins_remain_cap / abs(bins_remain_cap - item + epsilon)`.\n    # This is effectively `bins_remain_cap / (diff + epsilon)` for bins that fit.\n    \n    # Let's test this:\n    # item = 5\n    # bins_remain_cap = [10, 6, 20, 5.1]\n    # diff = [5, 1, 15, 0.1]\n    #\n    # priority_v1:\n    # 1/(5+eps) = 0.2\n    # 1/(1+eps) = 1.0\n    # 1/(15+eps) = 0.066\n    # 1/(0.1+eps) = 9.09\n    # Max priority for 5.1 remaining.\n    #\n    # New approach: `bins_remain_cap / (diff + epsilon)`\n    # 10 / (5+eps) = 2.0\n    # 6 / (1+eps) = 6.0\n    # 20 / (15+eps) = 1.33\n    # 5.1 / (0.1+eps) = 51.0\n    # Max priority for 5.1 remaining. This seems to amplify the preference for tight fits.\n    \n    # Let's implement this: `bins_remain_cap / (diff + epsilon)` for bins that fit.\n    \n    priorities = np.zeros_like(bins_remain_cap)\n    \n    # Identify bins where the item can fit\n    can_fit_mask = bins_remain_cap >= item\n    \n    # For bins where the item fits, calculate the priority score\n    # Prioritize bins where the remaining capacity is closest to the item size.\n    # Score is `bins_remain_cap / (bins_remain_cap - item + epsilon)`\n    # This is equivalent to `bins_remain_cap / (diff + epsilon)`\n    \n    # Add a small epsilon to bins_remain_cap to avoid division by zero if item == bins_remain_cap == 0,\n    # although can_fit_mask should prevent this for item > 0.\n    \n    # Ensure item is not zero to avoid division by zero in potential alternative calculations.\n    # In this case, we are using bins_remain_cap which is always non-negative.\n    \n    # The division `bins_remain_cap / (bins_remain_cap - item + epsilon)` can be large if `bins_remain_cap - item` is small.\n    # This correctly prioritizes tight fits.\n    \n    # Let's make sure the score is well-behaved.\n    # If `bins_remain_cap` is large, and `item` is small, `diff` is large.\n    # `bins_remain_cap / (diff + epsilon)` will be `large / large` -> moderate score.\n    # If `bins_remain_cap` is just slightly larger than `item`, `diff` is small.\n    # `bins_remain_cap / (diff + epsilon)` will be `~item / small` -> high score.\n    \n    # This seems like a good candidate for `priority_v2`.\n    \n    # Avoid division by zero if item is 0, though problem statement implies item > 0.\n    # If item is 0, any bin can fit it with infinite priority if `diff=0`.\n    # For item > 0, `bins_remain_cap` must be >= `item`.\n    \n    # Let's consider `bins_remain_cap - item`. If this is 0, the item perfectly fills the bin.\n    # In that case, `bins_remain_cap / epsilon` would be very large. This is desired.\n    \n    # Calculate the score for bins where the item fits\n    # Score = remaining_capacity / (remaining_capacity - item + epsilon)\n    # This is equivalent to: (item + diff) / (diff + epsilon)\n    # This ratio is maximized when `diff` is minimized (closest to 0).\n    \n    priorities[can_fit_mask] = bins_remain_cap[can_fit_mask] / (diff[can_fit_mask] + epsilon)\n    \n    return priorities\n\nNow, think outside the box write a mutated function `priority_v2` better than current version.\nYou can use some hints below:\n- \nHere's a refined approach to self-reflection for designing better heuristics:\n\n*   **Keywords:** Interpretability, Vectorization, Hybridization, Simplicity.\n*   **Advice:** Focus on direct, well-scaled scoring functions that clearly represent the heuristic's objective. Combine exact matches with robust \"close fit\" metrics, normalizing differences appropriately. Leverage vectorized operations extensively.\n*   **Avoid:** Overly complex, non-linear scoring functions that demand extensive tuning. Unnecessary array manipulations or obscure code that hinders clarity.\n*   **Explanation:** Prioritizing interpretable scores and vectorization ensures efficiency and maintainability, while a hybrid approach offers robustness by balancing exact solutions with practical approximations, directly informing heuristic design for better performance and adaptability.\n\nOutput code only and enclose your code with Python code block: ```python ... ```.\nI'm going to tip $999K for a better solution!"}