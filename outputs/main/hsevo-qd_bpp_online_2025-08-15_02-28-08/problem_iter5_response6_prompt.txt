{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code only and do not add comments into the code. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin using Inverse Distance (Proximity Fit).\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the difference between the remaining capacity and the item size\n    # This is the remaining space *after* placing the item.\n    space_after_placement = bins_remain_cap - item\n\n    # We want bins where the remaining capacity is just enough or slightly more than the item.\n    # A smaller positive difference is preferred.\n    # Bins with negative difference (item doesn't fit) should have very low priority.\n    # Inverse distance: smaller difference -> higher priority.\n    # Add a small epsilon to avoid division by zero if space_after_placement is exactly zero.\n    epsilon = 1e-9\n    priorities = 1 / (space_after_placement + epsilon)\n\n    # Set priority to a very low value for bins where the item does not fit\n    priorities[space_after_placement < 0] = -np.inf\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Combines Exact Fit preference with a Best Fit fallback.\n    Prioritizes bins that exactly fit the item, then bins with minimal excess capacity.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    can_fit_mask = bins_remain_cap >= item\n\n    if np.any(can_fit_mask):\n        available_bins_cap = bins_remain_cap[can_fit_mask]\n        \n        # Calculate the exact fit score (highest priority)\n        exact_fit_mask = available_bins_cap == item\n        if np.any(exact_fit_mask):\n            priorities[can_fit_mask][exact_fit_mask] = 1.0\n            \n        # Calculate the best fit score for remaining bins (secondary priority)\n        non_exact_fit_mask = ~exact_fit_mask\n        if np.any(non_exact_fit_mask):\n            remaining_available_bins_cap = available_bins_cap[non_exact_fit_mask]\n            \n            # Prioritize bins with the least remaining capacity after placing the item\n            # Higher priority for smaller remaining space (closer fit)\n            # We invert (remaining_capacity - item) to make smaller values higher priorities\n            space_after_placement = remaining_available_bins_cap - item\n            \n            # Avoid division by zero and normalize to avoid extreme values\n            inverted_space = 1.0 / (space_after_placement + 1e-9) \n            \n            min_inv_space = np.min(inverted_space)\n            max_inv_space = np.max(inverted_space)\n            \n            if max_inv_space - min_inv_space > 1e-9:\n                normalized_priorities = (inverted_space - min_inv_space) / (max_inv_space - min_inv_space)\n            else:\n                normalized_priorities = np.ones_like(inverted_space) * 0.5 # Uniform if all same\n\n            # Add a small base priority to non-exact fits so they are considered after exact fits\n            # but only if they have higher priority than non-fitting bins (which is always 0)\n            priorities[can_fit_mask][non_exact_fit_mask] = normalized_priorities * 0.9\n            \n    return priorities\n\n### Analyze & experience\n- *   **Comparing Heuristic 1 (Priority v2) vs. Heuristic 2 (Priority v2):**\n    *   Heuristic 1 attempts to normalize the \"tightness\" of the fit by calculating `(bins_remain_cap - item)`, finding min/max differences, and then normalizing. It then inverts this normalized score to give higher priority to tighter fits. It also adds a small boost (+ 0.1) to these scores to differentiate them from bins that cannot fit.\n    *   Heuristic 2 calculates `diffs = eligible_capacities - item`, finds the `min_diff`, and then assigns priority as `1.0 / (diffs - min_diff + 1e-9)`. This also aims to prioritize tighter fits by giving higher scores to smaller differences relative to the minimum difference.\n    *   **Observation:** Both heuristics aim to prioritize bins with less excess capacity. Heuristic 1's normalization is more complex, potentially more stable across different scales of differences, but might be overkill. Heuristic 2 is simpler and directly emphasizes the bins closest to the minimum excess.\n\n*   **Comparing Heuristic 3 (Exact Fit First) vs. Heuristic 4 (Priority v2):**\n    *   Heuristic 3 explicitly prioritizes bins that *exactly* fit (`bins_remain_cap == item`) with a score of `1.0`. If no exact fit exists, it falls back to prioritizing bins with the least remaining capacity that *can* fit, using an inverse of the excess capacity, normalized.\n    *   Heuristic 4 is identical to Heuristic 2, focusing solely on inverse difference from minimum excess capacity for all fitting bins, without an explicit \"exact fit\" priority level.\n    *   **Observation:** Heuristic 3 provides a distinct, higher priority for exact fits, which is a common and effective strategy in bin packing. Heuristic 4 treats exact fits the same as other close fits, potentially overlooking the benefit of perfect utilization.\n\n*   **Comparing Heuristic 5 (Inverse Distance) vs. Heuristic 8 (Loop-based Inverse Distance):**\n    *   Heuristic 5 calculates `space_after_placement = bins_remain_cap - item`, assigns `1 / (space_after_placement + epsilon)` for fitting bins, and `-np.inf` for non-fitting bins. This directly favors bins with minimal positive `space_after_placement`.\n    *   Heuristic 8 uses a loop to iterate through bins, achieving the same logic: `1.0 / (bins_remain_cap[i] - item + 1e-9)` for fitting bins, `0.0` otherwise.\n    *   **Observation:** Heuristic 5 is more concise and leverages NumPy's vectorized operations, making it more efficient and Pythonic than the explicit loop in Heuristic 8. Both implement the same core \"inverse distance\" or \"best fit\" logic.\n\n*   **Comparing Heuristic 9 (Exact Fit + Scaled Inverse Distance) vs. Heuristic 14 (Exact Fit + Scaled Inverse Difference):**\n    *   Heuristic 9 assigns `1.0` for exact fits. For non-exact fits, it calculates `inverse_distance_scores = 1.0 / (space_after_placement + epsilon)`, normalizes these scores to a range of `[0.5, 0.99]`, ensuring they are lower than exact fits.\n    *   Heuristic 14 assigns `2.0` for exact fits (even higher priority). For non-exact fits, it calculates `space_after_placement`, normalizes it (`1.0 - normalized_diff`), and adds `0.1`, resulting in scores between `0.1` and `1.1` (before considering the `2.0` for exact fits). The scaling is different: Heuristic 9 scales the inverse of the difference, while Heuristic 14 scales the normalized difference itself (then inverts).\n    *   **Observation:** Both combine exact fits with a \"best fit\" approach. Heuristic 14's use of `2.0` for exact fits creates a clearer hierarchy. Its normalization `1.0 - normalized_diff + 0.1` aims to prioritize smaller differences. Heuristic 9's approach of scaling inverse distance to `[0.5, 0.99]` is also a reasonable way to create a distinct priority band for close fits.\n\n*   **Comparing Heuristic 16/17/18 (Sigmoid Fit Score) vs. Heuristic 19 (Exact Fit + Best Fit):**\n    *   Heuristics 16-18 use a sigmoid function applied to `item / available_caps` with a threshold (`0.7`) and steepness (`10.0`). This aims to favor bins where the item takes up a significant portion of the remaining capacity, but not necessarily the absolute tightest fit. It penalizes bins that are too large.\n    *   Heuristic 19 prioritizes exact fits (`1.0`), then uses normalized inverse of space after placement for non-exact fits, scaled to `[0, 0.9]`. This focuses on minimal excess space for non-exact fits.\n    *   **Observation:** The sigmoid approach (16-18) is more complex and might be trying to find a balance point, not just the absolute closest fit. The prioritization based on `item / available_caps` is an interesting way to avoid bins that are *too* large. Heuristic 19 is a more direct combination of exact and best fit.\n\n*   **Comparing Heuristic 2 (Inverse Distance) vs. Heuristic 8 (Loop-based Inverse Distance):**\n    *   Heuristic 2: `priorities[eligible_bins] = 1.0 / (diffs - min_diff + 1e-9)`\n    *   Heuristic 8: `priorities[i] = 1.0 / (bins_remain_cap[i] - item + 1e-9)`\n    *   **Observation:** Heuristic 2 is superior because it normalizes the inverse distance relative to the minimum difference. This prevents bins with extremely large capacities (but still fitting) from getting disproportionately high scores simply because their raw difference `(capacity - item)` is large, even if it's closer to the minimum difference than others. Heuristic 8's scores can be highly skewed by large capacities.\n\n*   **Comparing Heuristic 1 (Normalized Tight Fit) vs. Heuristic 2 (Inverse Difference from Min Diff):**\n    *   Heuristic 1 attempts to normalize the `(capacity - item)` difference to a `[0, 1]` range and then applies `1.0 - normalized_tight_fit`. It also adds `0.1` and a base `1.0` for fitting bins.\n    *   Heuristic 2 uses `1.0 / (diffs - min_diff + 1e-9)`.\n    *   **Observation:** Heuristic 2 is simpler and more direct in prioritizing the *smallest* differences relative to the minimum difference. Heuristic 1's normalization is more involved and the additive `0.1` seems less principled than a multiplicative scaling or direct inverse.\n\n*   **Overall:** Heuristics that explicitly prioritize exact fits (like 3, 9, 14, 19, 20) generally perform better because perfect utilization is a strong objective. Among those that focus on \"best fit\" (minimal excess capacity), prioritizing the inverse of the *difference from the minimum difference* (like Heuristic 2, 4) is more robust than simply taking the inverse of the difference (like Heuristic 8). Vectorized operations (like 1, 2, 5) are preferred over loops (like 8). Complex sigmoid functions (16-18) are less interpretable and may not offer clear advantages over simpler \"best fit\" or \"exact fit\" strategies without empirical validation.\n- \nHere's a redefined \"Current self-reflection\" for designing better heuristics, focusing on actionable improvements:\n\n*   **Keywords:** Robustness, Simplicity, Efficiency, Interpretability.\n*   **Advice:** Develop scoring functions that are robust to capacity variations (e.g., by normalizing differences) and prioritize simple, interpretable metrics. Leverage vectorization for computational efficiency.\n*   **Avoid:** Overly complex, non-linear scoring functions requiring extensive tuning and obscure array manipulations.\n*   **Explanation:** Focusing on robust, simple metrics and efficient implementation leads to more reliable, maintainable, and adaptable heuristics, crucial for dynamic optimization problems.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}