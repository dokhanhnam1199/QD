```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Combines Exact Fit First and inverse difference for tight fits.

    Prioritizes bins that exactly fit the item. For other fitting bins, it
    assigns priority based on the inverse of the remaining capacity after
    placement, favoring tighter fits.
    """
    priorities = np.zeros_like(bins_remain_cap)
    can_fit_mask = bins_remain_cap >= item

    fitting_bins_indices = np.where(can_fit_mask)[0]

    if len(fitting_bins_indices) > 0:
        fitting_bins_cap = bins_remain_cap[fitting_bins_indices]

        # High priority for exact fits (Score 1.0)
        exact_fit_mask = fitting_bins_cap == item
        priorities[fitting_bins_indices[exact_fit_mask]] = 1.0

        # For non-exact fits, prioritize based on inverse difference (closer fits get higher score)
        non_exact_fitting_indices = fitting_bins_indices[~exact_fit_mask]
        non_exact_fitting_cap = fitting_bins_cap[~exact_fit_mask]

        if len(non_exact_fitting_indices) > 0:
            space_after_placement = non_exact_fitting_cap - item
            # Use inverse of space_after_placement for priority, scaled to be less than 1.0
            # Add epsilon to avoid division by zero and ensure positive scores.
            # Smaller space_after_placement means higher priority.
            scores = 1.0 / (space_after_placement + 1e-9)

            # Normalize scores to be between 0 and 0.99 to ensure exact fits are always preferred
            min_score = np.min(scores)
            max_score = np.max(scores)

            if max_score - min_score > 1e-9:
                normalized_scores = 0.99 * (scores - min_score) / (max_score - min_score)
            else:
                normalized_scores = np.zeros_like(scores)
            
            priorities[non_exact_fitting_indices] = normalized_scores

    return priorities
```
