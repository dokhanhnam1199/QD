```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Exact Fit First and Proximity Fit.
    Prioritizes exact fits, then bins with minimal excess capacity.
    This aims to reduce fragmentation while maximizing bin utilization.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    # Mask for bins that can fit the item
    can_fit_mask = bins_remain_cap >= item
    
    # Mask for exact fits
    exact_fit_mask = (bins_remain_cap == item)
    
    # Assign highest priority to exact fits
    priorities[exact_fit_mask] = 1.0
    
    # Consider bins that can fit but are not exact fits
    close_fit_mask = can_fit_mask & ~exact_fit_mask
    
    if np.any(close_fit_mask):
        # For bins that can fit but not exactly, calculate priority based on "tightness"
        # Lower remaining capacity after placing the item (i.e., smaller difference) gets higher priority.
        # We use 1 / (remaining_capacity - item + epsilon) to favor bins that are closer to exact fit.
        valid_bins_cap = bins_remain_cap[close_fit_mask]
        
        # Calculate scores inversely proportional to the excess capacity (bins_remain_cap - item)
        # Adding a small epsilon to avoid division by zero
        scores = 1.0 / (valid_bins_cap - item + 1e-9)
        
        # Normalize scores for these bins to be between 0 and 1
        # The bin with the least excess capacity (highest score) will be close to 1.
        max_score = np.max(scores)
        if max_score > 0:
            normalized_scores = scores / max_score
        else:
            normalized_scores = np.zeros_like(scores) # Should not occur if close_fit_mask is True
        
        # Assign these normalized scores to the corresponding bins
        priorities[close_fit_mask] = normalized_scores

    return priorities
```
