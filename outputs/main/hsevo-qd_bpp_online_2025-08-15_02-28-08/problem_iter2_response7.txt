```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines "Exact Fit First" and "Proximity Fit" for effective online BPP.

    Prioritizes exact matches, then bins with minimal remaining space after packing.
    This heuristic aims for maximal bin utilization by preferring tight fits.
    """
    priorities = np.zeros_like(bins_remain_cap)
    
    # 1. Exact Fit: Highest priority for bins where item perfectly fills remaining capacity.
    exact_fit_mask = np.isclose(bins_remain_cap, item)
    priorities[exact_fit_mask] = 1.0

    # 2. Proximity Fit: For bins that can fit the item but not exactly.
    #    Prioritize bins where the remaining capacity is just slightly larger than the item.
    #    This minimizes wasted space. We use inverse of (remaining_cap - item + epsilon)
    #    to give higher scores to smaller positive differences.
    can_fit_mask = bins_remain_cap > item
    
    # Calculate priorities only for bins that can fit and are not exact fits
    eligible_bins_mask = can_fit_mask & ~exact_fit_mask
    
    if np.any(eligible_bins_mask):
        eligible_bins_remain_cap = bins_remain_cap[eligible_bins_mask]
        
        # Calculate a score that favors smaller positive differences (remaining_cap - item)
        # Add a small epsilon to avoid division by zero and to ensure scores are finite.
        # A smaller positive difference results in a higher score.
        proximity_scores = 1.0 / (eligible_bins_remain_cap - item + 1e-9)
        
        # Normalize these scores to be in a range below the exact fit priority (e.g., 0 to 0.99)
        # Find min and max of these scores to normalize them to [0, 0.99]
        min_score = np.min(proximity_scores)
        max_score = np.max(proximity_scores)
        
        if max_score > min_score: # Avoid division by zero if all scores are the same
            normalized_proximity_scores = 0.99 * (proximity_scores - min_score) / (max_score - min_score)
        else:
            normalized_proximity_scores = np.full_like(proximity_scores, 0.5) # Assign a neutral score if all are same

        priorities[eligible_bins_mask] = normalized_proximity_scores

    return priorities
```
