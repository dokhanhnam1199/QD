```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Exact Fit with a normalized Best Fit (smallest excess capacity).
    Prioritizes exact fits, then bins with the least remaining capacity
    that can accommodate the item.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Mask for bins that can fit the item
    can_fit_mask = bins_remain_cap >= item

    if not np.any(can_fit_mask):
        return priorities

    eligible_bins_cap = bins_remain_cap[can_fit_mask]
    eligible_indices = np.where(can_fit_mask)[0]

    # --- Exact Fit Strategy ---
    # Assign highest priority to exact fits
    exact_fit_mask_local = (eligible_bins_cap == item)
    exact_fit_indices = eligible_indices[exact_fit_mask_local]
    priorities[exact_fit_indices] = 1.0

    # --- Normalized Best Fit Strategy for remaining bins ---
    # Identify bins that are not exact fits but can still fit the item
    close_fit_mask_local = (eligible_bins_cap > item)
    close_fit_indices = eligible_indices[close_fit_mask_local]

    if close_fit_indices.size > 0:
        close_bins_cap = bins_remain_cap[close_fit_indices]
        # Calculate excess capacity for these bins
        excess_capacities = close_bins_cap - item

        # Normalize excess capacities: smaller excess means higher score
        # We use 1 / (excess_capacity + epsilon) to prioritize smaller excesses
        # and add a small base to differentiate from exact fits.
        # Scale scores to be less than 1.0 to maintain exact fit priority.
        min_excess = np.min(excess_capacities)
        max_excess = np.max(excess_capacities)

        # Avoid division by zero and ensure scores are well-behaved
        if max_excess > min_excess:
            normalized_excess = (excess_capacities - min_excess) / (max_excess - min_excess)
            # Score is inversely proportional to normalized excess, scaled to be below 1.0
            close_fit_scores = 0.9 * (1.0 / (normalized_excess + 1e-9))
            # Further scale to ensure they are distinct and below exact fit priority
            max_close_fit_score = np.max(close_fit_scores)
            if max_close_fit_score > 0:
                close_fit_scores = 0.9 * (close_fit_scores / max_close_fit_score)
        else:
            # If all close fits have the same excess, assign a mid-range priority
            close_fit_scores = np.full_like(excess_capacities, 0.5)

        # Ensure no score exceeds exact fit priority (1.0)
        close_fit_scores = np.minimum(close_fit_scores, 0.99)

        priorities[close_fit_indices] = close_fit_scores

    return priorities
```
