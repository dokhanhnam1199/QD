```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Prioritizes bins: exact fits highest, then closest fits based on normalized inverse excess.

    Combines an explicit high score for exact fits with a scaled Best Fit strategy
    for non-exact fits, prioritizing bins with minimal remaining capacity after placement.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    can_fit_mask = bins_remain_cap >= item

    if np.any(can_fit_mask):
        fitting_bins_cap = bins_remain_cap[can_fit_mask]
        fitting_bins_indices = np.where(can_fit_mask)[0]

        # Highest priority for exact fits (clear separation)
        exact_fit_mask = fitting_bins_cap == item
        priorities[fitting_bins_indices[exact_fit_mask]] = 2.0

        # Medium priority for non-exact fits, based on how close they are
        non_exact_fitting_bins_cap = fitting_bins_cap[~exact_fit_mask]
        non_exact_fitting_bins_indices = fitting_bins_indices[~exact_fit_mask]

        if len(non_exact_fitting_bins_cap) > 0:
            # Calculate space remaining after placement for non-exact fits
            space_after_placement = non_exact_fitting_bins_cap - item

            # Normalize differences to [0, 1] range for scoring.
            # Smaller space_after_placement should get higher priority.
            min_diff = np.min(space_after_placement)
            max_diff = np.max(space_after_placement)

            if max_diff - min_diff > 1e-9:
                normalized_diff = (space_after_placement - min_diff) / (max_diff - min_diff)
            else:
                normalized_diff = np.zeros_like(space_after_placement) # All same diff

            # Assign priorities: inverse relationship with normalized difference, scaled
            # Higher priority for smaller differences (closer fits).
            # Scale to be less than exact fit priority (e.g., 0.1 to 1.0 range, but capped below 2.0).
            # Using 1.0 - normalized_diff makes smaller diffs have higher scores.
            # Adding a base of 0.1 ensures even the worst close fit has some priority.
            priorities[non_exact_fitting_bins_indices] = 0.1 + 0.9 * (1.0 - normalized_diff)

    return priorities
```
