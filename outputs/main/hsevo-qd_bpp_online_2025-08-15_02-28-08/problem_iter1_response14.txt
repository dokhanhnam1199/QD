```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Exact Fit First heuristic for online Bin Packing Problem.
    Prioritizes bins that can fit the item exactly. Among those,
    prioritizes bins with less remaining capacity to minimize wasted space.
    If no bin fits exactly, it prioritizes bins with the least remaining capacity
    that can still fit the item.
    """
    priorities = np.zeros_like(bins_remain_cap)
    exact_fit_bins_mask = (bins_remain_cap == item)
    close_fit_bins_mask = (bins_remain_cap > item)

    if np.any(exact_fit_bins_mask):
        # Prioritize exact fits with highest priority (1)
        priorities[exact_fit_bins_mask] = 1.0
        # Among exact fits, a subtle bias towards less remaining capacity could be added if needed
        # For exact fit, remaining capacity is zero, so no further differentiation needed here.
    elif np.any(close_fit_bins_mask):
        # If no exact fit, prioritize bins that fit with least remaining capacity
        valid_bins_cap = bins_remain_cap[close_fit_bins_mask]
        # Calculate a score inversely proportional to the excess capacity (bins_remain_cap - item)
        # Adding a small epsilon to the denominator to avoid division by zero if item==0 or bins_remain_cap==item (already handled)
        excess_capacities = valid_bins_cap - item
        scores = 1.0 / (excess_capacities + 1e-9)

        # Normalize scores to be between 0 and 1 for bins that can fit the item
        # The highest score (least excess capacity) will be close to 1
        max_score = np.max(scores)
        if max_score > 0:
            normalized_scores = scores / max_score
        else:
            normalized_scores = np.zeros_like(scores) # Should not happen with close_fit_bins_mask

        # Assign these normalized scores to the corresponding bins
        priorities[close_fit_bins_mask] = normalized_scores

    return priorities
```
