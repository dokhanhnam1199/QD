```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Combines Exact Fit and Best Fit (smallest remaining capacity).

    Prioritizes exact fits and then ranks other fitting bins by inverse
    excess capacity relative to the minimum excess capacity.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    eligible_bins_mask = bins_remain_cap >= item

    if np.any(eligible_bins_mask):
        eligible_capacities = bins_remain_cap[eligible_bins_mask]
        diffs = eligible_capacities - item

        # Exact fit: highest priority
        exact_fit_mask = diffs == 0
        if np.any(exact_fit_mask):
            priorities[eligible_bins_mask][exact_fit_mask] = 1.0
            # If exact fits exist, we can choose to give them the highest possible priority
            # and let others compete for lower ranks. For this combined approach,
            # we assign 1.0 and let the next logic handle non-exact fits.

        # Best fit (for non-exact fits): prioritize bins with minimal excess capacity
        non_exact_fit_mask = ~exact_fit_mask
        if np.any(non_exact_fit_mask):
            non_exact_diffs = diffs[non_exact_fit_mask]

            # Normalize differences: higher score for smaller differences relative to the minimum
            # Add a small epsilon to avoid division by zero for the minimum difference itself
            # and to ensure non-zero scores for bins with same minimum difference.
            min_non_exact_diff = np.min(non_exact_diffs)
            normalized_inverse_diff = 1.0 / (non_exact_diffs - min_non_exact_diff + 1e-9)

            # Scale these scores to be less than the exact fit priority (e.g., 0 to 0.99)
            # This ensures exact fits are always preferred if they exist.
            # If no exact fits, these scores will be used directly.
            
            # We can use a simple scaling that ensures smaller diffs get higher scores within this band.
            # If there's only one non-exact fit, give it a medium priority.
            if len(normalized_inverse_diff) > 1:
                # Normalize the scores to be in a range, e.g., [0.1, 0.9]
                # The highest score will be for the smallest difference
                min_score = np.min(normalized_inverse_diff)
                max_score = np.max(normalized_inverse_diff)
                
                # Avoid division by zero if all differences are the same
                if max_score - min_score < 1e-9:
                    scaled_scores = np.full_like(normalized_inverse_diff, 0.5)
                else:
                    scaled_scores = 0.1 + 0.8 * (normalized_inverse_diff - min_score) / (max_score - min_score)
            else:
                scaled_scores = np.array([0.5]) # Default for a single non-exact fit

            # Assign these scaled scores to the corresponding eligible bins
            priorities[eligible_bins_mask][non_exact_fit_mask] = scaled_scores

    return priorities
```
