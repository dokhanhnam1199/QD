```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Returns priority with which we want to add item to each bin using a refined strategy.

    This heuristic prioritizes bins that offer an exact fit or a very close fit.
    For bins with excess capacity, it scores them based on the normalized "waste"
    (excess capacity relative to the item size), favoring less waste.
    It aims to reduce fragmentation by strongly preferring bins where the item
    fills most of the remaining space.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Returns:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    epsilon = 1e-9
    
    # Initialize priorities to zero.
    priorities = np.zeros_like(bins_remain_cap)
    
    # Identify bins where the item can fit.
    can_fit_mask = bins_remain_cap >= item
    
    # Calculate the difference (excess capacity) for bins that can fit the item.
    diff = bins_remain_cap[can_fit_mask] - item
    
    # Calculate scores for bins where the item fits.
    # The primary goal is to heavily favor exact fits (diff = 0).
    # For near fits, we want a score that decreases as diff increases.
    # A simple and effective way is to use the ratio of remaining capacity to the excess capacity.
    # Score = (item + diff) / (diff + epsilon)
    # This score is high when diff is small, and approaches 1 as diff becomes large.
    # This amplifies the preference for tight fits significantly.
    
    # To add a slight improvement and interpretability:
    # 1. Exact fit (diff == 0): Assign a very high, distinct score (e.g., infinity or a large constant)
    # 2. Close fit (small positive diff): Score based on inverse of diff, amplified.
    # 3. Larger excess capacity (larger diff): Score based on inverse of normalized diff.
    
    # Let's combine these ideas:
    # For bins that fit:
    # Calculate the excess capacity.
    excess_capacity = bins_remain_cap[can_fit_mask] - item
    
    # Create a score that is high for exact fits and decreases as excess capacity grows.
    # A score like 1 / (excess_capacity + epsilon) is good but might not differentiate
    # between "very close" and "moderately close" enough.
    
    # Let's use a score that is proportional to `bins_remain_cap / (excess_capacity + epsilon)`.
    # This is equivalent to `(item + excess_capacity) / (excess_capacity + epsilon)`.
    # This metric is maximized when excess_capacity is minimized.
    # Example:
    # item = 10
    # bins_remain_cap = [10, 11, 15, 20]
    # diff = [0, 1, 5, 10]
    #
    # Score:
    # diff=0: 10 / (0 + eps) -> very high
    # diff=1: 11 / (1 + eps) -> ~11
    # diff=5: 15 / (5 + eps) -> ~3
    # diff=10: 20 / (10 + eps) -> ~2
    # This correctly prioritizes the exact fit, then the closest fit.
    
    scores = bins_remain_cap[can_fit_mask] / (excess_capacity + epsilon)
    
    priorities[can_fit_mask] = scores
    
    return priorities

```
