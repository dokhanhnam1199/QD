```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics function for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.
    This version combines several factors to determine how promising it is to select an edge.
    It also sparsifies the matrix by setting unpromising elements to zero.

    Args:
        distance_matrix (np.ndarray): Distance matrix (shape: n by n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n by 2).
        demands (np.ndarray): Vector of customer demands (shape: n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n by n).
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

    # Calculate savings matrix (Clark-Wright Savings Heuristic)
    savings_matrix = np.zeros_like(distance_matrix, dtype=float)
    for i in range(1, n):
        for j in range(i + 1, n):
            savings_matrix[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]
            savings_matrix[j, i] = savings_matrix[i, j]

    # Combine distance, savings, and demand factors
    for i in range(n):
        for j in range(n):
            if i != j:
                # Distance factor (shorter distances are more promising)
                distance_factor = 1 / distance_matrix[i, j]

                # Savings factor (higher savings are more promising)
                savings_factor = savings_matrix[i, j]

                # Demand factor (avoid edges that would lead to exceeding capacity early)
                demand_factor = 1.0  # Initialize to 1.0
                if i != 0 and j != 0:  # Only consider demand for customer nodes
                    # Heuristic: Penalize edges if the sum of demands is close to exceeding the capacity
                    demand_factor = max(0.0, 1.0 - (demands[i] + demands[j]) / (2*capacity)  )


                # Combine the factors
                heuristics_matrix[i, j] = distance_factor * savings_factor * demand_factor

    # Sparsify the matrix (set unpromising elements to zero)
    threshold = np.percentile(heuristics_matrix[heuristics_matrix > 0], 20)  # Keep top 80%
    heuristics_matrix[heuristics_matrix < threshold] = 0

    return heuristics_matrix
```
