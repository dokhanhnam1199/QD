```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristic function for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.

    Args:
        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).
        demands (np.ndarray): Customer demands (shape: n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).
    """

    n = distance_matrix.shape[0]

    # Initialize the heuristic matrix with zeros
    heuristic_matrix = np.zeros((n, n))

    # Parameters to control the influence of different factors
    alpha = 1.0   # Importance of distance
    beta = 0.5    # Importance of demand
    gamma = 0.2   # Importance of angle relative to depot
    delta = 0.1   # Importance of closeness to capacity limit

    for i in range(n):
        for j in range(n):
            if i != j:  # Avoid self-loops

                # Factor 1: Inverse of distance (shorter distances are preferred)
                distance_factor = 1 / (distance_matrix[i, j] + 1e-6)  # Adding a small constant to avoid division by zero

                # Factor 2: Demand consideration (penalize edges that lead to exceeding capacity quickly)
                demand_penalty = 1.0
                if i != 0 and j != 0:  # Don't penalize edges connecting to/from depot
                    demand_penalty = np.exp(-beta * (demands[i] + demands[j]) / capacity) #Exponential decay as demands increases

                # Factor 3: Angle relative to the depot (prefer angles closer to straight lines from the depot)
                if i == 0:
                    angle = 0  # No angle for depot leaving edges
                else:
                    # Calculate angle between the line from depot to i and the line from i to j
                    depot_x, depot_y = coordinates[0]
                    i_x, i_y = coordinates[i]
                    j_x, j_y = coordinates[j]

                    angle1 = np.arctan2(i_y - depot_y, i_x - depot_x)
                    angle2 = np.arctan2(j_y - i_y, j_x - i_x)

                    angle_diff = np.abs(angle1 - angle2)
                    angle_factor = np.exp(-gamma * angle_diff) # penalizes larger angle diffrences

                # Factor 4: Closeness to capacity limit (incentivize filling up vehicles)
                capacity_utilization = 0.0
                if i != 0 and j != 0:
                    capacity_utilization = np.abs((demands[i] + demands[j])/capacity -1 )
                closeness_to_capacity = np.exp(-delta*capacity_utilization)
                

                # Combine the factors
                heuristic_matrix[i, j] = distance_factor**alpha * demand_penalty * angle_factor * closeness_to_capacity

    #Sparsify the matrix: setting lower percentile links to zero
    threshold = np.percentile(heuristic_matrix[heuristic_matrix > 0], 20)  # keep only the top 80% edges.
    heuristic_matrix[heuristic_matrix < threshold] = 0
  
    return heuristic_matrix
```
