```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics function for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.

    Args:
        distance_matrix: Distance matrix between nodes (shape: n by n).
        coordinates: Euclidean coordinates of nodes (shape: n by 2).
        demands: Vector of customer demands (shape: n).
        capacity: Vehicle capacity.

    Returns:
        A matrix of the same shape as distance_matrix, where each element indicates how promising
        it is to include the corresponding edge in a solution.
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix)

    # Calculate a savings matrix.  Savings (i,j) = dist(depot, i) + dist(depot, j) - dist(i, j).  Edges with high savings are desirable.
    savings_matrix = np.zeros_like(distance_matrix)
    for i in range(1, n):
        for j in range(i + 1, n):
            savings_matrix[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]
            savings_matrix[j, i] = savings_matrix[i, j]


    # Penalize edges that connect nodes with high demand to each other.
    demand_penalty = np.outer(demands, demands)
    demand_penalty = demand_penalty / np.max(demand_penalty) if np.max(demand_penalty) > 0 else demand_penalty  # Normalize to [0, 1]
    demand_penalty = 1 - demand_penalty  # Invert so that high values indicate low penalty
    # Scale it down
    demand_penalty = 0.5 + 0.5 * demand_penalty
    
    # Give preference to edges that are closer to the depot.
    depot_proximity = np.zeros_like(distance_matrix)
    for i in range(1, n):
        for j in range(1, n):
                depot_proximity[i,j] = (distance_matrix[0,i] + distance_matrix[0,j])
    
    max_depot_prox = np.max(depot_proximity)
    if (max_depot_prox > 0):
        depot_proximity = max_depot_prox / depot_proximity
    else:
        depot_proximity = np.ones_like(depot_proximity)


    # Combine factors.
    heuristic_matrix = (savings_matrix * demand_penalty) * depot_proximity / (distance_matrix + 1e-6)


    #Sparsify the matrix. Remove very long edges to encourage local search around nearby customers
    distance_threshold = np.percentile(distance_matrix[distance_matrix > 0], 75) #Consider only edges shorter than the 75th percentile.

    heuristic_matrix[distance_matrix > distance_threshold] = 0  # Set to zero for edges that are too long.
    np.fill_diagonal(heuristic_matrix, 0)


    return heuristic_matrix
```
