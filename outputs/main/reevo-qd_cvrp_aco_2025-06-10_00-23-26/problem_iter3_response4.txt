```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    A heuristics function for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.
    This version prioritizes edges based on savings, demand, and proximity to the depot, then sparsifies the result.

    Args:
        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n by n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n by 2).
        demands (np.ndarray): Customer demands (shape: n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n by n).
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros((n, n))

    # Calculate savings for each edge
    savings_matrix = np.zeros((n, n))
    for i in range(1, n):
        for j in range(i + 1, n):
            savings_matrix[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]
            savings_matrix[j, i] = savings_matrix[i, j]  # Savings is symmetric

    # Combine distance and savings. Shorter distance, more savings -> more promising
    for i in range(n):
        for j in range(n):
            if i != j:
                heuristics_matrix[i, j] = savings_matrix[i, j] / (distance_matrix[i, j] + 1e-6) # avoid division by zero

    # Penalize edges connecting nodes with high demands, but less penalty if either is close to depot.
    demand_penalty = np.zeros((n, n))
    for i in range(1, n):
        for j in range(1, n):
            if i != j:
                # Penalize based on combined demand, reduced by proximity to depot
                penalty = (demands[i] + demands[j]) / (2 * capacity)
                depot_proximity_factor = min(1.0, (distance_matrix[0, i] + distance_matrix[0, j]) / (2 * np.mean(distance_matrix[0, 1:]))) # scale depot distance
                demand_penalty[i, j] = penalty * (1-0.5 * depot_proximity_factor) # Reduce penalty if close to depot

    heuristics_matrix = heuristics_matrix - demand_penalty

    # Encourage connection to the depot, with added distance normalization
    depot_boost = np.zeros((n, n))
    for i in range(1, n):
        depot_boost[0, i] = 1.0 / (distance_matrix[0, i] + 1e-6)  # Inverse distance
        depot_boost[i, 0] = 1.0 / (distance_matrix[i, 0] + 1e-6)

    heuristics_matrix = heuristics_matrix + depot_boost

    # Sparsify the matrix. Zero out unpromising edges to encourage stochastic sampling
    threshold = np.percentile(heuristics_matrix[heuristics_matrix > 0], 40) # Keep top 60%
    heuristics_matrix[heuristics_matrix < threshold] = 0

    return heuristics_matrix
```
