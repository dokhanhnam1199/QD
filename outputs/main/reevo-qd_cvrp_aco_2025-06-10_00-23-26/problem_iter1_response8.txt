```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics function for Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.

    Args:
        distance_matrix (np.ndarray): Distance matrix (shape: n by n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n by 2).
        demands (np.ndarray): Vector of customer demands (shape: n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution
                  (same shape as distance_matrix).
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # Parameters to tune (found experimentally)
    alpha = 1.0  # Importance of distance
    beta = 0.5   # Importance of demand considerations (higher is better)
    gamma = 0.2  # Importance of closeness to depot
    delta = 0.1  # Importance of node popularity (not useful here, can set to zero)
    epsilon = 0.01 # Add to avoid divide by zero
    sparsify_threshold = 0.1

    # Calculate closeness to depot (normalized)
    depot_distances = distance_matrix[0, :] / np.max(distance_matrix[0, :])
    depot_distances = 1 - depot_distances # Closer to depot means better

    #Node Popularity (Initialize to 1)
    node_popularity = np.ones(n)

    for i in range(n):
        for j in range(n):
            if i == j:
                heuristic_matrix[i, j] = 0  # No self-loops
                continue

            #Distance Factor (closer is better, penalized)
            distance_factor = (1 / (distance_matrix[i, j] + epsilon)) ** alpha

            #Demand consideration (try to connect small demands and avoid big jumps)
            demand_factor = np.exp(-beta * np.abs(demands[i] + demands[j]) / capacity)

            # Depot Proximity Factor (closer to depot after visiting these two nodes, higher score)
            depot_proximity_factor = (depot_distances[i] + depot_distances[j]) ** gamma

            # Node Popularity: encourage nodes to be visited more frequently
            # (currently not in use).
            popularity_factor = (node_popularity[i] * node_popularity[j]) ** delta
            
            heuristic_matrix[i, j] = distance_factor * demand_factor * depot_proximity_factor * popularity_factor

    #Sparsify heuristic_matrix: remove less-promising links
    threshold = np.quantile(heuristic_matrix[heuristic_matrix > 0], sparsify_threshold) #only consider values above zero

    heuristic_matrix[heuristic_matrix < threshold] = 0 #set unpromising entries to zero

    return heuristic_matrix
```
