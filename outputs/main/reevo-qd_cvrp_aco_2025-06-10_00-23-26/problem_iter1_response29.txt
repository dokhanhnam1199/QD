```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristic function for CVRP based on distance, demand, and angle.

    Args:
        distance_matrix: Distance between nodes.
        coordinates: Euclidean coordinates of nodes.
        demands: Demand of each node.
        capacity: Vehicle capacity.

    Returns:
        A matrix of heuristic values for each edge.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Parameters to control the influence of different factors.
    distance_factor = 1.0
    demand_factor = 1.0
    angle_factor = 1.0
    capacity_factor = 1.0

    # Sparsity parameter: higher value means more sparsity
    sparsity_threshold = 0.5 

    for i in range(n):
        for j in range(n):
            if i == j:
                heuristic_matrix[i, j] = 0  # No self-loops
                continue

            # Distance component: Shorter distances are preferred.
            distance_component = distance_factor / (distance_matrix[i, j] + 1e-6)

            # Demand component: Penalize edges that lead to capacity violations early on.
            # Heavier penalties are given when connecting from the depot.
            demand_component = 1.0
            if i == 0:
                demand_component = demand_factor * np.exp(-demands[j] / capacity) 
            else:
                demand_component = demand_factor  # Slight advantage to local connections

            # Angle component: Encourages smoother routes (less sharp turns).
            angle_component = 1.0
            if i != 0:
                # Calculate angle between the edge (i->j) and a hypothetical edge (j->depot).
                # Use dot product to get cosine of the angle
                vector_ij = coordinates[j] - coordinates[i]
                vector_j0 = coordinates[0] - coordinates[j]
                
                norm_ij = np.linalg.norm(vector_ij)
                norm_j0 = np.linalg.norm(vector_j0)
                
                if norm_ij > 0 and norm_j0 > 0:  # avoid division by zero and undefined angles
                    cos_angle = np.dot(vector_ij, vector_j0) / (norm_ij * norm_j0)
                    # Convert cosine to an angle in [0, pi]
                    angle = np.arccos(np.clip(cos_angle, -1.0, 1.0)) # Clip cos_angle due to numerical instability
                    
                    angle_component = angle_factor * (1 - angle / np.pi) # Smaller angle gives higher heuristic

            # Capacity consideration (avoid paths which will exceed capacity)
            capacity_component = 1.0
            if demands[j] > capacity:
              capacity_component = 0.0
            else:
                capacity_component = capacity_factor

            # Combine the components.
            heuristic_matrix[i, j] = distance_component * demand_component * angle_component * capacity_component

    # Sparsify the matrix by setting elements below a threshold to zero.
    threshold = np.quantile(heuristic_matrix[heuristic_matrix > 0], sparsity_threshold)  # Exclude zeros for quantile calculation
    heuristic_matrix[heuristic_matrix < threshold] = 0

    return heuristic_matrix
```
