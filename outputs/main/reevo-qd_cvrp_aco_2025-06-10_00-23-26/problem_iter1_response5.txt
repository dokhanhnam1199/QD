```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    A heuristics function for solving Capacitated Vehicle Routing Problem (CVRP)
    via stochastic solution sampling.

    Args:
        distance_matrix: A numpy array of shape (n, n) representing the distance
                         matrix between nodes.
        coordinates: A numpy array of shape (n, 2) representing the Euclidean
                     coordinates of the nodes.
        demands: A numpy array of shape (n,) representing the demand of each node.
        capacity: An integer representing the vehicle capacity.

    Returns:
        A numpy array of shape (n, n) representing the prior indicators of how
        promising it is to include each edge in a solution.
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Parameters for tuning the heuristic
    alpha = 1.0  # Weight for distance
    beta = 0.5  # Weight for demand
    gamma = 0.2  # Weight for angle to depot

    # Calculate angle to depot for each node
    depot_coords = coordinates[0]
    angles = np.zeros(n)
    for i in range(1, n):  # Exclude depot itself
        vec = coordinates[i] - depot_coords
        angles[i] = np.arctan2(vec[1], vec[0])

    # Normalize demands
    normalized_demands = demands / np.max(demands)

    for i in range(n):
        for j in range(n):
            if i != j:
                # Heuristic based on distance, demand, and angle to depot
                distance_factor = alpha / (distance_matrix[i, j] + 1e-6)  # Avoid division by zero
                demand_factor = (1 - beta * (normalized_demands[i] + normalized_demands[j])) if i != 0 and j != 0 else 1.0
                angle_factor = 1 - gamma * abs(angles[i] - angles[j]) / np.pi if i !=0 and j != 0 else 1.0  # Penalize large angle difference

                heuristic_matrix[i, j] = distance_factor * demand_factor * angle_factor

    # Sparsify the matrix (optional) - keeps only top k edges for each node
    k = int(np.sqrt(n))  # Adjust k as needed - k determines the sparseness
    for i in range(n):
        row = heuristic_matrix[i, :]
        indices = np.argsort(row)[-k:]  # Indices of top k elements
        mask = np.zeros(n, dtype=bool)
        mask[indices] = True
        heuristic_matrix[i, ~mask] = 0

    return heuristic_matrix
```
