```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics for Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.

    Combines distance, demand, and angular considerations to estimate edge desirability.
    Sparsifies the matrix by setting unpromising elements to zero.

    Args:
        distance_matrix (np.ndarray): Distance matrix (n x n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (n x 2).
        demands (np.ndarray): Customer demands (n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of edge desirability (n x n).
    """

    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros((n, n))

    # Parameters (tune these for better performance)
    distance_weight = 1.0
    demand_weight = 0.5
    angle_weight = 0.2
    capacity_threshold = 0.8  # Only connect to nodes whose demand, plus depot demand doesn't greatly exceed capacity

    # Depot demand is 0.

    for i in range(n):
        for j in range(n):
            if i == j:
                heuristics_matrix[i, j] = 0  # No self-loops
                continue

            # Distance factor
            distance_factor = distance_matrix[i, j]

            # Demand factor (penalize edges to nodes with high demand, but don't eliminate it all together unless capacity is greatly exceeded).

            # First filter out cases where the demand is almost enough to fill capacity
            if (demands[i] + demands[j] > 1.5 * capacity) or (i == 0 and demands[j] > capacity) or (j == 0 and demands[i] > capacity):
                heuristics_matrix[i,j] = 0
                continue

            demand_factor = demands[j] # use demand[j] rather than demands[i] + demands[j]

            # Angle factor (encourage more direct routes, i.e. minimize sharp turns)
            if i == 0:
                 angle_factor = 1  #No angle if it is the depot.
            else:
                # Calculate angle between edge (i, j) and a reference direction (e.g., horizontal axis)
                dx = coordinates[j, 0] - coordinates[i, 0]
                dy = coordinates[j, 1] - coordinates[i, 1]
                angle = np.arctan2(dy, dx) # returns value between [-PI, PI]

                angle_factor = np.cos(angle) + 1 # shift it to [0, 2] to always be positive. This encourages going along straight lines.



            # Combine factors (penalize distances more than demands and angles. Angle factor should mostly serve to break ties).
            heuristics_matrix[i, j] = (
                distance_weight / (distance_factor + 1e-6) + # avoid dividing by zero.
                demand_weight / (demand_factor + 1e-6) + # avoid dividing by zero.
                angle_weight * angle_factor
            )


    # Sparsify the matrix (optional, but can improve performance by reducing the search space)
    # You can adjust the threshold to control the sparsity level. E.g. only select top 20% of edges.
    threshold = np.percentile(heuristics_matrix[heuristics_matrix > 0], 20) # only consider edges > 0 since we skip self loops.
    heuristics_matrix[heuristics_matrix < threshold] = 0

    return heuristics_matrix
```
