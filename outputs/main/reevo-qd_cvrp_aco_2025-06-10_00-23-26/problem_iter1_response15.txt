```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristic function for CVRP using a combination of factors and sparsification.

    Args:
        distance_matrix (np.ndarray): Distance matrix (n x n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (n x 2).
        demands (np.ndarray): Customer demands (n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Edge promisingness indicators (n x n).
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # Parameters (can be tuned)
    distance_weight = 0.5
    demand_weight = 0.3
    angle_weight = 0.2
    sparsity_threshold = 0.1  #tune this. Increase to have sparser matrix. Range[0,1]

    for i in range(n):
        for j in range(n):
            if i != j:
                # Distance factor (normalized)
                distance_factor = 1 / (distance_matrix[i, j] + 1e-6)

                # Demand factor (consider demands of both nodes)
                demand_factor = 1 / (demands[i] + demands[j] + 1e-6) #Lower demand sum is better
                if i == 0 or j == 0:
                  demand_factor = 1.0  #Depot has no constraints to prioritize short links


                # Angle factor (angle between edges i->j and j->depot) - promotes going to depot
                if i != 0 and j !=0: #angle only makes sense not from depot to node, and from node to depot.
                    depot_x, depot_y = coordinates[0]
                    x_i, y_i = coordinates[i]
                    x_j, y_j = coordinates[j]

                    # Vectors from j to i and from j to depot
                    vector_ji = np.array([x_i - x_j, y_i - y_j])
                    vector_j_depot = np.array([depot_x - x_j, depot_y - y_j])

                    # Calculate the cosine of the angle
                    dot_product = np.dot(vector_ji, vector_j_depot)
                    magnitudes = np.linalg.norm(vector_ji) * np.linalg.norm(vector_j_depot)

                    if magnitudes > 0:
                        cos_angle = dot_product / magnitudes
                        angle_factor = (1 + cos_angle) / 2  # Normalize to [0, 1] - want to favor angles close to 0. close to parallel

                    else:
                        angle_factor = 0.5 # Avoid division by zero, provide a meaningful value when nodes overlap
                else:
                  angle_factor = 1.0 # doesn't matter

                # Combine factors
                heuristic_matrix[i, j] = (
                    distance_weight * distance_factor
                    + demand_weight * demand_factor
                    + angle_weight * angle_factor
                )

    # Normalize the heuristic matrix
    max_val = np.max(heuristic_matrix)
    if max_val > 0:
        heuristic_matrix /= max_val

    # Sparsify the matrix
    threshold = np.quantile(heuristic_matrix[heuristic_matrix > 0], sparsity_threshold)
    heuristic_matrix[heuristic_matrix < threshold] = 0

    return heuristic_matrix
```
