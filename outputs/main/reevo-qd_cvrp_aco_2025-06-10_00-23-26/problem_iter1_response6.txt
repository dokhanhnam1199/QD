```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristic function for solving the Capacitated Vehicle Routing Problem (CVRP)
    via stochastic solution sampling.

    This version combines distance, demand, and geometric proximity to estimate
    the promise of each edge.  It also sparsifies the result.

    Args:
        distance_matrix (np.ndarray): Distance matrix (n x n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (n x 2).
        demands (np.ndarray): Vector of customer demands (n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Edge promise indicators (n x n).
    """
    n = distance_matrix.shape[0]
    promise = np.zeros_like(distance_matrix, dtype=float)

    # Heuristic 1: Inverse distance
    promise = 1 / (distance_matrix + 1e-6)  # Add a small value to avoid division by zero

    # Heuristic 2: Demand factor - penalize edges connecting high-demand nodes
    demand_factor = np.outer(demands, demands)
    promise /= (demand_factor + 1e-6)

    # Heuristic 3: Angle Penalty - encourage edges that don't create sharp turns
    for i in range(n):
        for j in range(n):
            if i != j:
                angle_sum = 0.0
                for k in range(n):
                    if k != i and k != j:
                        # Cosine rule to calculate angle i-k-j
                        a = distance_matrix[i, k]
                        b = distance_matrix[j, k]
                        c = distance_matrix[i, j]
                        cos_angle = (a**2 + b**2 - c**2) / (2 * a * b + 1e-6)
                        cos_angle = np.clip(cos_angle, -1, 1) #Ensure value is within [-1,1]
                        angle = np.arccos(cos_angle)
                        angle_sum += angle

                promise[i, j] /= (angle_sum + 1)  # Penalize sharp turns by dividing with a higher values. Add 1 to ensure no division by zero

    # Heuristic 4: Capacity awareness - encourage edges that connect nodes with demands below capacity.
    capacity_scaling = np.zeros((n,n))
    for i in range(n):
        for j in range(n):
             if demands[i] + demands[j] > capacity and i != 0 and j !=0: # except depot
                 capacity_scaling[i,j] = 0.1 # small weight
             else:
                 capacity_scaling[i,j] = 1
    promise = promise * capacity_scaling

    # Sparsify:  Zero out edges with low promise (Keep top k edges for each node)
    sparsity_level = 10  # Number of edges to keep for each node
    for i in range(n):
        row = promise[i, :]
        indices = np.argsort(row)[::-1]  # Sort in descending order of promise
        keep_indices = indices[:sparsity_level]
        mask = np.ones(n, dtype=bool)
        mask[keep_indices] = False
        promise[i, mask] = 0.0 # Setting low promise edges to 0 for sparsification
    
    # Return the edge indicators
    return promise
```
