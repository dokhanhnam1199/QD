```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    A heuristic function for solving the Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.

    This version combines distance, demand, and angle information to create a heuristic.
    It also sparsifies the matrix by setting unpromising edges to zero.

    Args:
        distance_matrix: A distance matrix (shape: n by n).
        coordinates: Euclidean coordinates of nodes (shape: n by 2).
        demands: A vector of customer demands (shape: n).
        capacity: The capacity of the vehicle.

    Returns:
        A matrix of the same shape as distance_matrix, indicating how promising it is to include each edge in a solution.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Parameters to tune
    distance_weight = 1.0
    demand_weight = 1.0
    angle_weight = 0.5
    sparsification_threshold = 2.0  # Adjust this based on problem scale

    for i in range(n):
        for j in range(n):
            if i != j:
                # Distance factor (Encourage shorter edges)
                distance_factor = 1 / (distance_matrix[i, j] + 1e-6)  # Adding a small constant to avoid division by zero

                # Demand factor (Penalize edges connecting nodes with high demands if either node has very high demand)
                demand_factor = 1.0
                if demands[i] > capacity * 0.6 or demands[j] > capacity * 0.6:
                    demand_factor = 0.1  # Big reduction for very high demand node

                else:
                  demand_factor = 1/(np.sqrt(demands[i] + demands[j]) + 1e-6)



                # Angle factor (Avoid sharp turns -- penalize based on angle at node j using cosine rule)
                angle_factor = 1.0
                if i != 0: #No angle penalties when leaving depot
                  # Find a third point k != i,j to calculate angle at j: consider depot
                  k = 0
                  dist_ij = distance_matrix[i, j]
                  dist_jk = distance_matrix[j, k]
                  dist_ki = distance_matrix[k, i]

                  # law of cosines
                  cos_angle = (dist_ij**2 + dist_jk**2 - dist_ki**2) / (2 * dist_ij * dist_jk + 1e-6) # Add small constant to avoid dividing by zero.

                  angle_factor = max(0.0, cos_angle) # Prefer sharper turning angle which corresponds to cos angle close to 1. Closer to zero if obtuse, so take maximum zero.


                # Combine factors
                heuristic_matrix[i, j] = (distance_weight * distance_factor +
                                           demand_weight * demand_factor +
                                           angle_weight * angle_factor)

    # Sparsification (Set unpromising edges to zero)
    mean_heuristic = np.mean(heuristic_matrix)
    heuristic_matrix[heuristic_matrix < mean_heuristic / sparsification_threshold] = 0

    return heuristic_matrix
```
