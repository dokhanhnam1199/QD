import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray, exact_fit_priority: float = 0.7309257871819509, graded_fit_weight: float = 1.1796345870122984, epsilon: float = 6.827610247517786e-07) -> np.ndarray:
    """Prioritizes exact fits, then bins with least remaining capacity using a graded scale.

    Combines the explicit prioritization of exact fits with a graded penalty for
    non-exact fits based on the difference, aiming for a balanced Best Fit approach.

    Args:
        item: The size of the item to be placed.
        bins_remain_cap: A numpy array representing the remaining capacity of each bin.
        exact_fit_priority: The priority score assigned to bins that are an exact fit.
        graded_fit_weight: A weight to scale the priority of graded fits.
        epsilon: A small value to prevent division by zero.

    Returns:
        A numpy array of priority scores for each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    # Bins where the item can fit exactly
    exact_fit_mask = np.isclose(bins_remain_cap, item)
    priorities[exact_fit_mask] = exact_fit_priority  # Highest priority for exact fits

    # Bins where the item can fit but not exactly
    fit_mask = bins_remain_cap > item
    
    # Calculate priority for bins that can fit but not exactly.
    # Prioritize bins with smaller remaining capacity (tighter fit).
    # A higher score indicates a better (tighter) fit.
    # The score is inversely proportional to the remaining capacity after fitting.
    # Add epsilon to avoid division by zero.
    difference = bins_remain_cap[fit_mask] - item
    priorities[fit_mask] = graded_fit_weight / (difference + epsilon)

    # Ensure exact fits still have the highest priority if they also satisfy fit_mask
    priorities[exact_fit_mask] = np.maximum(priorities[exact_fit_mask], exact_fit_priority)
    
    return priorities
