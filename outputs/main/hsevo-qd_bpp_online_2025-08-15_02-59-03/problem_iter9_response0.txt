```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Returns priority with which we want to add item to each bin using a refined Best Fit strategy
    that prioritizes bins with less remaining capacity (closer to fitting the item perfectly),
    but also penalizes bins that are too small, making it robust.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    # Identify bins that can actually fit the item
    suitable_bins_mask = bins_remain_cap >= item
    
    if not np.any(suitable_bins_mask):
        # If no bin can fit the item, return all zeros (or handle error appropriately)
        return priorities

    # Calculate the "tightness" of the fit for suitable bins
    # Smaller remaining capacity after fitting means a tighter, potentially better fit.
    remaining_capacities_after_fit = bins_remain_cap[suitable_bins_mask] - item
    
    # Avoid division by zero if remaining capacity is exactly 0.
    # A very small epsilon can be used to prevent division by zero.
    epsilon = 1e-9
    tightness_scores = 1.0 / (remaining_capacities_after_fit + epsilon)

    # Normalize tightness scores to a range (e.g., 0 to 1) or use them directly.
    # For simplicity, we can directly use the inverse of remaining capacity as a proxy for priority.
    # Higher value means tighter fit, thus higher priority.

    # Assign these scores to the corresponding suitable bins
    priorities[suitable_bins_mask] = tightness_scores
    
    # Optional: Add a small penalty for bins that are very large,
    # encouraging filling up bins rather than opening too many large ones.
    # For example, penalize bins with remaining capacity much larger than the item.
    # This can be a secondary factor. For this version, we focus on the primary goal of tight fit.

    # The current approach assigns higher priority to bins that result in less remaining capacity
    # after placing the item, which is the core of Best Fit.
    
    # To ensure robustness, we could consider a secondary criterion if multiple bins have the same tightness.
    # For example, prefer bins that were previously less full (more initial remaining capacity),
    # which might be useful if we have a mix of items. However, for pure BPP, the tightest fit is usually optimal.
    
    # For this "mutated" version, we stick to refining the Best Fit by directly using
    # the inverse of remaining capacity as the priority score.
    
    return priorities
```
