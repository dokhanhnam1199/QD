{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin using a modified Best Fit strategy.\n    This version prioritizes bins that have just enough space for the item, and among those,\n    prefers bins that will have the least remaining capacity after packing.\n    It also introduces a slight preference for bins that have been used less (i.e., higher remaining capacity)\n    if no \"perfect fit\" is found, to encourage better space utilization over time.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    suitable_bins_mask = bins_remain_cap >= item\n\n    if not np.any(suitable_bins_mask):\n        return priorities\n\n    suitable_bins_caps = bins_remain_cap[suitable_bins_mask]\n    remaining_capacities_after_packing = suitable_bins_caps - item\n\n    # Identify bins that are a \"perfect fit\" or very close\n    # A small tolerance is introduced to capture bins that are \"almost\" a perfect fit\n    tolerance = 1e-6\n    perfect_fit_mask = np.abs(remaining_capacities_after_packing) < tolerance\n\n    if np.any(perfect_fit_mask):\n        # Among perfect fits, prefer those with the absolute minimum remaining capacity (which is close to zero)\n        # This is essentially Best Fit for perfect fits.\n        min_remaining_cap_among_perfect = np.min(remaining_capacities_after_packing[perfect_fit_mask])\n        best_fit_perfect_mask = (suitable_bins_caps - item == min_remaining_cap_among_perfect)\n\n        # Map back to original indices\n        original_indices_perfect = np.where(suitable_bins_mask)[0][best_fit_perfect_mask]\n        priorities[original_indices_perfect] = 2.0 # Highest priority\n\n    else:\n        # If no perfect fit, fall back to a modified Best Fit strategy.\n        # Prioritize bins that leave the least remaining capacity, but not too much.\n        # We'll give a higher score to bins that have a small remaining capacity after packing,\n        # but not so small that it's completely unusable for future small items.\n        # The score is inversely related to the remaining capacity after packing.\n        # To avoid extreme values, we use a scaled inverse.\n        min_remaining_cap_overall = np.min(remaining_capacities_after_packing)\n        \n        # Assign scores based on how close the remaining capacity is to the minimum\n        # Higher score for bins that are closer to the minimum remaining capacity\n        scores_for_suitable = 1.0 / (1.0 + remaining_capacities_after_packing - min_remaining_cap_overall)\n        \n        # Normalize scores to be between 0 and 1\n        max_score = np.max(scores_for_suitable)\n        min_score = np.min(scores_for_suitable)\n        if max_score > min_score:\n            normalized_scores = (scores_for_suitable - min_score) / (max_score - min_score)\n        else:\n            normalized_scores = np.ones_like(scores_for_suitable) * 0.5 # Assign a neutral score if all are equal\n\n        # Map back to original indices\n        original_indices_suitable = np.where(suitable_bins_mask)[0]\n        priorities[original_indices_suitable] = normalized_scores\n        \n        # Ensure perfect fits (if any were missed by tolerance) still get top priority\n        if np.any(np.abs(remaining_capacities_after_packing) < tolerance):\n            min_remaining_cap_close_to_zero = np.min(remaining_capacities_after_packing[np.abs(remaining_capacities_after_packing) < tolerance])\n            best_fit_close_mask = (suitable_bins_caps - item == min_remaining_cap_close_to_zero)\n            original_indices_close = np.where(suitable_bins_mask)[0][best_fit_close_mask]\n            priorities[original_indices_close] = np.maximum(priorities[original_indices_close], 1.5) # Boost priority\n\n    return priorities\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin using a modified Best Fit strategy.\n    This version prioritizes bins that have just enough space for the item, and among those,\n    prefers bins that will have the least remaining capacity after packing.\n    It also introduces a slight preference for bins that have been used less (i.e., higher remaining capacity)\n    if no \"perfect fit\" is found, to encourage better space utilization over time.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    suitable_bins_mask = bins_remain_cap >= item\n\n    if not np.any(suitable_bins_mask):\n        return priorities\n\n    suitable_bins_caps = bins_remain_cap[suitable_bins_mask]\n    remaining_capacities_after_packing = suitable_bins_caps - item\n\n    # Identify bins that are a \"perfect fit\" or very close\n    # A small tolerance is introduced to capture bins that are \"almost\" a perfect fit\n    tolerance = 1e-6\n    perfect_fit_mask = np.abs(remaining_capacities_after_packing) < tolerance\n\n    if np.any(perfect_fit_mask):\n        # Among perfect fits, prefer those with the absolute minimum remaining capacity (which is close to zero)\n        # This is essentially Best Fit for perfect fits.\n        min_remaining_cap_among_perfect = np.min(remaining_capacities_after_packing[perfect_fit_mask])\n        best_fit_perfect_mask = (suitable_bins_caps - item == min_remaining_cap_among_perfect)\n\n        # Map back to original indices\n        original_indices_perfect = np.where(suitable_bins_mask)[0][best_fit_perfect_mask]\n        priorities[original_indices_perfect] = 2.0 # Highest priority\n\n    else:\n        # If no perfect fit, fall back to a modified Best Fit strategy.\n        # Prioritize bins that leave the least remaining capacity, but not too much.\n        # We'll give a higher score to bins that have a small remaining capacity after packing,\n        # but not so small that it's completely unusable for future small items.\n        # The score is inversely related to the remaining capacity after packing.\n        # To avoid extreme values, we use a scaled inverse.\n        min_remaining_cap_overall = np.min(remaining_capacities_after_packing)\n        \n        # Assign scores based on how close the remaining capacity is to the minimum\n        # Higher score for bins that are closer to the minimum remaining capacity\n        scores_for_suitable = 1.0 / (1.0 + remaining_capacities_after_packing - min_remaining_cap_overall)\n        \n        # Normalize scores to be between 0 and 1\n        max_score = np.max(scores_for_suitable)\n        min_score = np.min(scores_for_suitable)\n        if max_score > min_score:\n            normalized_scores = (scores_for_suitable - min_score) / (max_score - min_score)\n        else:\n            normalized_scores = np.ones_like(scores_for_suitable) * 0.5 # Assign a neutral score if all are equal\n\n        # Map back to original indices\n        original_indices_suitable = np.where(suitable_bins_mask)[0]\n        priorities[original_indices_suitable] = normalized_scores\n        \n        # Ensure perfect fits (if any were missed by tolerance) still get top priority\n        if np.any(np.abs(remaining_capacities_after_packing) < tolerance):\n            min_remaining_cap_close_to_zero = np.min(remaining_capacities_after_packing[np.abs(remaining_capacities_after_packing) < tolerance])\n            best_fit_close_mask = (suitable_bins_caps - item == min_remaining_cap_close_to_zero)\n            original_indices_close = np.where(suitable_bins_mask)[0][best_fit_close_mask]\n            priorities[original_indices_close] = np.maximum(priorities[original_indices_close], 1.5) # Boost priority\n\n    return priorities\n\n[Heuristics 3rd]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i in range(len(bins_remain_cap)):\n        if bins_remain_cap[i] >= item:\n            remaining_capacity = bins_remain_cap[i]\n            if remaining_capacity - item == 0:\n                priorities[i] = 1.0 / (remaining_capacity - item + 1e-9)\n            else:\n                priorities[i] = 1.0 / (remaining_capacity - item)\n    return priorities\n\n[Heuristics 4th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Best Fit strategy.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    suitable_bins_mask = bins_remain_cap >= item\n    if np.any(suitable_bins_mask):\n        remaining_capacities = bins_remain_cap[suitable_bins_mask] - item\n        min_remaining_capacity = np.min(remaining_capacities)\n        best_fit_mask = (bins_remain_cap >= item) & (bins_remain_cap - item == min_remaining_capacity)\n        priorities[best_fit_mask] = 1.0\n    return priorities\n\n[Heuristics 5th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    for i, capacity in enumerate(bins_remain_cap):\n        if capacity >= item:\n            priorities[i] = capacity - item\n        else:\n            priorities[i] = -np.inf\n    \n    min_diff = np.min(priorities[priorities != -np.inf]) if np.any(priorities != -np.inf) else np.inf\n    \n    priorities[priorities != -np.inf] = min_diff - priorities[priorities != -np.inf]\n    \n    return priorities\n\n[Heuristics 6th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines Exact Fit First and Best Fit.\n    Prioritizes exact fits, then bins with minimal remaining capacity,\n    using a penalty for bins that cannot fit the item.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Identify bins that can fit the item\n    fit_mask = bins_remain_cap >= item\n\n    # Exact fit: highest priority\n    exact_fit_mask = (bins_remain_cap == item) & fit_mask\n    priorities[exact_fit_mask] = 1.0\n\n    # Best fit for remaining bins (those that fit but not exactly)\n    non_exact_fit_mask = fit_mask & ~exact_fit_mask\n    if np.any(non_exact_fit_mask):\n        fitting_capacities = bins_remain_cap[non_exact_fit_mask]\n        gaps = fitting_capacities - item\n        min_gap = np.min(gaps)\n        \n        # Assign priorities based on the gap, higher for smaller gaps.\n        # Add a small offset to distinguish from exact fits and ensure positive.\n        best_fit_priorities = 0.9 - (gaps - min_gap) / (np.max(gaps) - min_gap + 1e-9)\n        \n        # Apply these priorities only to the bins that are non-exact fits\n        priorities[non_exact_fit_mask] = best_fit_priorities\n\n    # Penalize bins that cannot fit the item\n    no_fit_mask = ~fit_mask\n    priorities[no_fit_mask] = -1.0 # Effectively exclude them from selection\n\n    return priorities\n\n[Heuristics 7th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin using a modified Best Fit strategy\n    that also considers the initial size of the bin.\n    Bins that are almost full but can still accommodate the item are prioritized slightly higher\n    than bins that have a lot of remaining space, to encourage tighter packing.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Mask for bins that can accommodate the item\n    suitable_bins_mask = bins_remain_cap >= item\n\n    if not np.any(suitable_bins_mask):\n        return priorities  # No bin can fit the item\n\n    # Calculate remaining capacities for suitable bins\n    remaining_capacities_after_fit = bins_remain_cap[suitable_bins_mask] - item\n\n    # Find the minimum remaining capacity among suitable bins (this is the Best Fit criterion)\n    min_remaining_capacity = np.min(remaining_capacities_after_fit)\n\n    # Identify bins that achieve the minimum remaining capacity\n    best_fit_bins_mask = suitable_bins_mask.copy()\n    best_fit_bins_mask[suitable_bins_mask] = (remaining_capacities_after_fit == min_remaining_capacity)\n\n    # Assign a base priority of 1.0 to best-fit bins\n    priorities[best_fit_bins_mask] = 1.0\n\n    # Introduce a secondary consideration: prefer bins that are already \"closer\" to full.\n    # This is to avoid leaving many small gaps in bins that are mostly empty.\n    # We can achieve this by giving a slight boost to bins that have less remaining capacity *before* the item is added,\n    # among those that can fit the item.\n\n    # Get remaining capacities of all suitable bins\n    suitable_bins_remaining_cap = bins_remain_cap[suitable_bins_mask]\n\n    # Calculate a \"fill ratio\" - how full the bin is before adding the item. Higher is better.\n    # Add a small epsilon to avoid division by zero if a bin had 0 initial capacity (though unlikely in BPP)\n    epsilon = 1e-9\n    initial_bin_capacity_for_suitable_bins = suitable_bins_remaining_cap + item\n    fill_ratios = (initial_bin_capacity_for_suitable_bins - suitable_bins_remaining_cap) / (initial_bin_capacity_for_suitable_bins + epsilon)\n\n    # Scale these fill ratios to create a secondary priority boost.\n    # We want to slightly prefer fuller bins. A simple scaling could be based on the maximum fill ratio.\n    # A small additive boost is generally safer than multiplicative to avoid huge numbers.\n    # Let's try a small positive boost for bins that are \"more filled\" than the average.\n    \n    # Calculate a threshold based on the mean fill ratio of suitable bins\n    mean_fill_ratio = np.mean(fill_ratios)\n    \n    # Apply a smaller boost to bins that are more filled than the average,\n    # but only if they are not already a \"best fit\" bin (to avoid double counting the primary priority).\n    # The boost should be less than the primary priority (1.0).\n    secondary_boost_amount = 0.1\n\n    # For bins that are suitable but *not* best-fit, and are more filled than average, give a small boost.\n    non_best_fit_suitable_mask = suitable_bins_mask.copy()\n    non_best_fit_suitable_mask[suitable_bins_mask] = ~best_fit_bins_mask[suitable_bins_mask]\n    \n    combined_mask_for_boost = non_best_fit_suitable_mask & suitable_bins_mask\n    \n    if np.any(combined_mask_for_boost):\n        # Filter fill ratios for these bins\n        fill_ratios_for_boost = fill_ratios[np.isin(np.where(suitable_bins_mask)[0], np.where(combined_mask_for_boost)[0])]\n        \n        # Apply boost to those with fill ratio > mean fill ratio\n        boost_condition_mask = fill_ratios_for_boost > mean_fill_ratio\n        \n        if np.any(boost_condition_mask):\n            # Get the indices in the original bins_remain_cap array\n            indices_to_boost = np.where(suitable_bins_mask)[0][np.isin(np.where(suitable_bins_mask)[0], np.where(combined_mask_for_boost)[0])][boost_condition_mask]\n            priorities[indices_to_boost] += secondary_boost_amount\n\n    # Ensure best-fit bins still have the highest priority (1.0)\n    # If a best-fit bin also qualified for the secondary boost, its priority will be 1.0 + 0.1,\n    # which might be undesireable if we want best-fit to be strictly highest.\n    # Let's refine this: Best Fit gets 1.0. Other suitable bins get a smaller priority\n    # based on how \"full\" they are.\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    suitable_bins_mask = bins_remain_cap >= item\n\n    if not np.any(suitable_bins_mask):\n        return priorities\n\n    remaining_capacities_after_fit = bins_remain_cap[suitable_bins_mask] - item\n    min_remaining_capacity = np.min(remaining_capacities_after_fit)\n\n    # Assign priority based on how close they are to best-fit, and then by fill ratio.\n    # The highest priority will be for best-fit bins.\n    # For non-best-fit bins, priority will be lower and based on their fill level.\n\n    # Calculate a \"closeness\" to best-fit metric for all suitable bins.\n    # Lower remaining capacity after fit is better (closer to best-fit).\n    # We can normalize this.\n    \n    # Normalize remaining capacities to a [0, 1] range, where 0 is best.\n    # Avoid division by zero if all suitable bins have the same remaining capacity.\n    if np.all(remaining_capacities_after_fit == min_remaining_capacity):\n        closeness_to_best_fit = np.zeros_like(remaining_capacities_after_fit)\n    else:\n        max_remaining_capacity_after_fit = np.max(remaining_capacities_after_fit)\n        closeness_to_best_fit = (remaining_capacities_after_fit - min_remaining_capacity) / (max_remaining_capacity_after_fit - min_remaining_capacity + epsilon)\n\n    # Now, use fill ratio for secondary sorting among bins with similar \"closeness to best-fit\".\n    # Or, combine them. A simple way is to prioritize Best Fit (closeness = 0) with a high score,\n    # and then use fill ratio for others.\n\n    # Let's assign priorities:\n    # Best-fit bins get a high priority (e.g., 1.0)\n    # Other suitable bins get a priority based on their fill ratio, scaled down.\n    \n    # Priority for best-fit bins\n    best_fit_bins_mask_final = suitable_bins_mask.copy()\n    best_fit_bins_mask_final[suitable_bins_mask] = (remaining_capacities_after_fit == min_remaining_capacity)\n    priorities[best_fit_bins_mask_final] = 1.0\n    \n    # Priority for non-best-fit suitable bins\n    non_best_fit_suitable_mask_final = suitable_bins_mask.copy()\n    non_best_fit_suitable_mask_final[suitable_bins_mask] = ~best_fit_bins_mask_final[suitable_bins_mask]\n    \n    # Calculate fill ratios for these bins again\n    suitable_bins_remaining_cap_non_bf = bins_remain_cap[non_best_fit_suitable_mask_final]\n    initial_bin_capacity_for_suitable_bins_non_bf = suitable_bins_remaining_cap_non_bf + item\n    fill_ratios_non_bf = (initial_bin_capacity_for_suitable_bins_non_bf - suitable_bins_remaining_cap_non_bf) / (initial_bin_capacity_for_suitable_bins_non_bf + epsilon)\n\n    # Scale these fill ratios to a lower range, e.g., [0.1, 0.5]\n    # This ensures they are less prioritized than best-fit bins (1.0).\n    if np.any(non_best_fit_suitable_mask_final):\n        if np.all(fill_ratios_non_bf == fill_ratios_non_bf[0]): # Handle case where all fill ratios are same\n             scaled_priorities = 0.3 # Assign a mid-range priority\n        else:\n            min_fill_ratio = np.min(fill_ratios_non_bf)\n            max_fill_ratio = np.max(fill_ratios_non_bf)\n            # Scale fill ratios from [min_fill_ratio, max_fill_ratio] to [0.1, 0.5]\n            scaled_priorities = 0.1 + 0.4 * (fill_ratios_non_bf - min_fill_ratio) / (max_fill_ratio - min_fill_ratio + epsilon)\n        \n        priorities[non_best_fit_suitable_mask_final] = scaled_priorities\n\n    return priorities\n\n[Heuristics 8th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin using a\n    modified Best Fit strategy that also considers the \"tightness\" of the fit\n    and the potential for future packing.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=np.float64)\n    suitable_bins_mask = bins_remain_cap >= item\n\n    if not np.any(suitable_bins_mask):\n        return priorities\n\n    suitable_bins_remain_cap = bins_remain_cap[suitable_bins_mask]\n    \n    # Calculate the remaining capacity after placing the item\n    remaining_after_fit = suitable_bins_remain_cap - item\n    \n    # Heuristic 1: Prioritize bins where the item fits snugly (minimizing waste in this bin)\n    # We use a value that is inversely proportional to the remaining capacity after fitting.\n    # Add a small epsilon to avoid division by zero if remaining_after_fit is 0.\n    snug_fit_scores = 1.0 / (remaining_after_fit + 1e-9)\n\n    # Heuristic 2: Prioritize bins that will have more remaining capacity AFTER the item is placed.\n    # This can be useful if we anticipate packing larger items later and want to reserve\n    # larger bins, or if we want to keep bins with moderate remaining capacity.\n    # Let's give a slight bonus to bins that will have a medium amount of remaining capacity.\n    # A simple way is to give a higher score to bins whose remaining capacity is closer to the median.\n    # Or, a simpler approach: prioritize bins that leave a \"good amount\" of space, but not too much.\n    # Let's try to penalize bins that become nearly empty or still very large.\n    # We can use a Gaussian-like function centered around a 'desirable' remaining capacity.\n    # For simplicity here, let's consider leaving a moderate amount of space as good.\n    # We can map remaining_after_fit to a score where middle values are higher.\n    # A simple approach: score = 1 - (x - target)^2 / range^2.\n    # Let's assume a target remaining capacity is around half of the bin's original capacity,\n    # but this is complex as we don't know original capacity.\n    # A simpler heuristic: prioritize bins that leave a moderate amount of space,\n    # e.g., not too close to 0 and not too close to the original capacity.\n    # Let's consider bins that leave remaining capacity between 10% and 50% of the *item size* as moderately good.\n    # This is a bit ad-hoc but aims to keep bins that are neither too full nor too empty for the current item.\n    moderate_space_scores = np.zeros_like(suitable_bins_remain_cap)\n    lower_bound = item * 0.1\n    upper_bound = item * 0.5\n    \n    valid_moderate_mask = (remaining_after_fit >= lower_bound) & (remaining_after_fit <= upper_bound)\n    moderate_space_scores[valid_moderate_mask] = 1.0\n    \n    # Combine scores: A weighted sum or a simple addition might work.\n    # Let's try a weighted sum. The snug fit is often the primary goal in BPP.\n    # We can add the moderate space score as a secondary factor.\n    combined_scores = snug_fit_scores + 0.2 * moderate_space_scores # Weighting snug fit more\n\n    # Normalize scores to be between 0 and 1 (optional, but good for consistent priority interpretation)\n    if np.max(combined_scores) > 0:\n        normalized_scores = combined_scores / np.max(combined_scores)\n    else:\n        normalized_scores = combined_scores\n\n    # Assign priorities to the original array\n    priorities[suitable_bins_mask] = normalized_scores\n\n    return priorities\n\n[Heuristics 9th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin using a\n    modified Best Fit strategy that also considers the \"tightness\" of the fit\n    and the potential for future packing.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=np.float64)\n    suitable_bins_mask = bins_remain_cap >= item\n\n    if not np.any(suitable_bins_mask):\n        return priorities\n\n    suitable_bins_remain_cap = bins_remain_cap[suitable_bins_mask]\n    \n    # Calculate the remaining capacity after placing the item\n    remaining_after_fit = suitable_bins_remain_cap - item\n    \n    # Heuristic 1: Prioritize bins where the item fits snugly (minimizing waste in this bin)\n    # We use a value that is inversely proportional to the remaining capacity after fitting.\n    # Add a small epsilon to avoid division by zero if remaining_after_fit is 0.\n    snug_fit_scores = 1.0 / (remaining_after_fit + 1e-9)\n\n    # Heuristic 2: Prioritize bins that will have more remaining capacity AFTER the item is placed.\n    # This can be useful if we anticipate packing larger items later and want to reserve\n    # larger bins, or if we want to keep bins with moderate remaining capacity.\n    # Let's give a slight bonus to bins that will have a medium amount of remaining capacity.\n    # A simple way is to give a higher score to bins whose remaining capacity is closer to the median.\n    # Or, a simpler approach: prioritize bins that leave a \"good amount\" of space, but not too much.\n    # Let's try to penalize bins that become nearly empty or still very large.\n    # We can use a Gaussian-like function centered around a 'desirable' remaining capacity.\n    # For simplicity here, let's consider leaving a moderate amount of space as good.\n    # We can map remaining_after_fit to a score where middle values are higher.\n    # A simple approach: score = 1 - (x - target)^2 / range^2.\n    # Let's assume a target remaining capacity is around half of the bin's original capacity,\n    # but this is complex as we don't know original capacity.\n    # A simpler heuristic: prioritize bins that leave a moderate amount of space,\n    # e.g., not too close to 0 and not too close to the original capacity.\n    # Let's consider bins that leave remaining capacity between 10% and 50% of the *item size* as moderately good.\n    # This is a bit ad-hoc but aims to keep bins that are neither too full nor too empty for the current item.\n    moderate_space_scores = np.zeros_like(suitable_bins_remain_cap)\n    lower_bound = item * 0.1\n    upper_bound = item * 0.5\n    \n    valid_moderate_mask = (remaining_after_fit >= lower_bound) & (remaining_after_fit <= upper_bound)\n    moderate_space_scores[valid_moderate_mask] = 1.0\n    \n    # Combine scores: A weighted sum or a simple addition might work.\n    # Let's try a weighted sum. The snug fit is often the primary goal in BPP.\n    # We can add the moderate space score as a secondary factor.\n    combined_scores = snug_fit_scores + 0.2 * moderate_space_scores # Weighting snug fit more\n\n    # Normalize scores to be between 0 and 1 (optional, but good for consistent priority interpretation)\n    if np.max(combined_scores) > 0:\n        normalized_scores = combined_scores / np.max(combined_scores)\n    else:\n        normalized_scores = combined_scores\n\n    # Assign priorities to the original array\n    priorities[suitable_bins_mask] = normalized_scores\n\n    return priorities\n\n[Heuristics 10th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    The First Fit strategy prioritizes bins that have just enough capacity\n    to fit the item, aiming to leave larger remaining capacities in other bins\n    for potentially larger future items.\n    A higher priority score indicates a better fit.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    # Bins where the item can fit\n    fit_mask = bins_remain_cap >= item\n    \n    # Calculate the difference between remaining capacity and item size for fitting bins\n    # A smaller difference means a \"tighter\" fit, which is preferred by First Fit.\n    # We use the inverse of the difference to make it a maximization problem.\n    # Add a small epsilon to avoid division by zero for exact fits.\n    priorities[fit_mask] = 1.0 / (bins_remain_cap[fit_mask] - item + 1e-9)\n    \n    # Bins where the item does not fit get a priority of 0\n    # This is already handled by np.zeros_like, but explicitly for clarity in logic\n    priorities[~fit_mask] = 0.0\n\n    return priorities\n\n[Heuristics 11th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    possible_bins = bins_remain_cap >= item\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    available_capacities = bins_remain_cap[possible_bins]\n    \n    if available_capacities.size > 0:\n        \n        fitted_capacities = available_capacities - item\n        \n        \n        scaled_capacities = fitted_capacities / np.max(available_capacities)\n        \n        \n        priorities[possible_bins] = 1 / (1 + np.exp(-5 * (scaled_capacities - 0.5)))\n        \n        \n        if np.any(fitted_capacities == 0):\n            priorities[possible_bins][fitted_capacities == 0] = 1.0\n            \n    return priorities\n\n[Heuristics 12th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on tight fit, favoring exact fits then closest fits.\n\n    Combines exact fit (priority 1.0) with a tight fit metric using sigmoid\n    on the inverse of remaining capacity relative to item size.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    epsilon = 1e-9\n\n    # Identify bins where the item can fit\n    can_fit_mask = bins_remain_cap >= item\n    fitting_bins_remain_cap = bins_remain_cap[can_fit_mask]\n\n    # If there are no bins that can fit the item, return all zeros\n    if fitting_bins_remain_cap.size == 0:\n        return priorities\n\n    # Prioritize exact fits with the highest score\n    exact_fit_mask_for_fitting = np.abs(fitting_bins_remain_cap - item) < epsilon\n    priorities[can_fit_mask][exact_fit_mask_for_fitting] = 1.0\n\n    # For bins that can fit but are not exact fits, use a sigmoid score\n    # that favors bins with less remaining capacity (tighter fit).\n    # The metric is `item / remaining_capacity`. Closer to 1 is better.\n    # We use `sigmoid(k * (item / remaining_capacity - 1))`\n    # k controls the steepness. We choose a moderate k.\n    # We need to apply this only to bins that are not exact fits.\n    non_exact_fit_mask_for_fitting = ~exact_fit_mask_for_fitting\n\n    if np.any(non_exact_fit_mask_for_fitting):\n        non_exact_fitting_capacities = fitting_bins_remain_cap[non_exact_fit_mask_for_fitting]\n        \n        # Calculate the tightness ratio: item size / remaining capacity.\n        # A higher ratio indicates a tighter fit.\n        tightness_ratio = item / (non_exact_fitting_capacities + epsilon)\n\n        # Sigmoid function to map the tightness ratio to a priority score between 0 and 1.\n        # The formula `1 / (1 + exp(-k * (ratio - 1)))` peaks around ratio=1.\n        # A k=5.0 makes the sigmoid relatively steep, favoring capacities closer to item size.\n        k = 5.0\n        sigmoid_priorities = 1 / (1 + np.exp(-k * (tightness_ratio - 1)))\n        \n        # Assign these priorities to the corresponding original bins\n        priorities[can_fit_mask][non_exact_fit_mask_for_fitting] = sigmoid_priorities\n\n    return priorities\n\n[Heuristics 13th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\n[Heuristics 14th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    possible_bins = bins_remain_cap >= item\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    available_capacities = bins_remain_cap[possible_bins]\n    \n    if available_capacities.size > 0:\n        \n        fitted_capacities = available_capacities - item\n        \n        \n        scaled_capacities = fitted_capacities / np.max(available_capacities)\n        \n        \n        priorities[possible_bins] = 1 / (1 + np.exp(-5 * (scaled_capacities - 0.5)))\n        \n        \n        if np.any(fitted_capacities == 0):\n            priorities[possible_bins][fitted_capacities == 0] = 1.0\n            \n    return priorities\n\n[Heuristics 15th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using First Fit strategy.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    for i, capacity in enumerate(bins_remain_cap):\n        if capacity >= item:\n            priorities[i] = 1.0  # Give priority to bins that can fit the item\n        else:\n            priorities[i] = 0.0  # No priority for bins that cannot fit the item\n    \n    # In First Fit, we iterate through bins in order and pick the first one that fits.\n    # To simulate this priority, we want to give higher priority to earlier bins if they fit.\n    # We can achieve this by making the priority score dependent on the bin's index.\n    # A simple way is to add a small decreasing value based on the index.\n    # However, the standard First Fit doesn't explicitly use priority scores in this way;\n    # it's more of a sequential search. For the purpose of this function signature,\n    # we'll just mark bins that can fit. If multiple can fit, the selection logic\n    # outside this function would need to pick the first one.\n    #\n    # A true \"priority\" that mimics FF selection might be complex within this\n    # function signature if it's meant to return scores to be maxed.\n    # If the intention is for this function to directly return which bin to pick,\n    # a different approach would be needed.\n    #\n    # Given the structure, the simplest interpretation that *hints* at FF is\n    # to give a higher score to the *first* available bin.\n    \n    first_available_index = -1\n    for i, capacity in enumerate(bins_remain_cap):\n        if capacity >= item:\n            first_available_index = i\n            break\n            \n    if first_available_index != -1:\n        priorities[first_available_index] = 1.0 + (len(bins_remain_cap) - 1 - first_available_index) * 0.001 # Slightly higher priority for earlier bins\n        \n    return priorities\n\n[Heuristics 16th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin using a hybrid strategy:\n    Prioritize bins that are a \"tight fit\" (minimizing waste), but also consider\n    bins that have a moderate amount of remaining capacity to potentially accommodate\n    future larger items or to avoid creating many small, unusable spaces.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    suitable_bins_mask = bins_remain_cap >= item\n\n    if not np.any(suitable_bins_mask):\n        return priorities\n\n    suitable_bins_capacities = bins_remain_cap[suitable_bins_mask]\n\n    # Strategy 1: Tight fit (Best Fit)\n    # Calculate remaining capacity if item is placed\n    remaining_after_fit = suitable_bins_capacities - item\n    min_remaining = np.min(remaining_after_fit)\n    tight_fit_mask_local = (suitable_bins_capacities - item) == min_remaining\n\n    # Strategy 2: Moderate capacity (to potentially fit larger items later)\n    # This is a bit heuristic, let's consider bins that have capacity\n    # roughly between the item size and the bin capacity, avoiding extreme\n    # both very full and very empty bins for this secondary score.\n    # We can normalize remaining capacities and assign a score.\n    # Let's define a \"good enough\" fit as having remaining capacity that is\n    # not too small (but not necessarily the absolute smallest) and not too large.\n    # A simple approach is to give higher priority to bins with remaining capacity\n    # that is closer to the item size, but not exactly the tightest fit.\n\n    # Calculate a \"wastefulness\" score for each suitable bin. Lower is better.\n    # We want to minimize (bin_capacity - item).\n    waste_score = suitable_bins_capacities - item\n\n    # Normalize waste score to be between 0 and 1 (where 0 is best).\n    # Avoid division by zero if all suitable bins have exactly item size capacity.\n    if np.max(waste_score) > 0:\n        normalized_waste_score = waste_score / np.max(waste_score)\n    else:\n        normalized_waste_score = np.zeros_like(waste_score)\n\n    # Create a composite score: prioritize tight fits, but give some boost\n    # to bins that are not excessively empty.\n    # We can use a function that gives higher values to smaller waste.\n    # For example, 1 / (1 + waste_score) or exp(-waste_score).\n    # Let's try a simpler approach: a weighted sum.\n    # High score for tightest fits, moderate score for other suitable bins.\n\n    # Assign a base score to all suitable bins.\n    base_priority = 0.1 # Small baseline for being suitable\n\n    # Boost the tightest fits.\n    priorities[suitable_bins_mask][tight_fit_mask_local] = 1.0\n\n    # For other suitable bins, assign a priority based on how much space is left.\n    # We want to prefer bins that leave less space, but not *too* little (which is the tight fit).\n    # A score that increases as remaining capacity decreases, but capped.\n    # Let's assign a score that is inversely proportional to the remaining capacity AFTER packing.\n    # We'll scale this to avoid overpowering the 'best fit' score.\n    other_suitable_indices = np.where(suitable_bins_mask)[0][~tight_fit_mask_local]\n    if other_suitable_indices.size > 0:\n        other_capacities = bins_remain_cap[other_suitable_indices] - item\n        # Assign priority based on inverse of remaining capacity (smaller remaining is better)\n        # Add a small epsilon to avoid division by zero if a bin is perfectly filled\n        inverse_capacity_score = 1.0 / (other_capacities + 1e-6)\n        # Normalize this score so it doesn't dominate the '1.0' from tight fit\n        max_inverse_score = np.max(inverse_capacity_score)\n        if max_inverse_score > 0:\n            normalized_inverse_score = inverse_capacity_score / max_inverse_score\n        else:\n            normalized_inverse_score = np.zeros_like(inverse_capacity_score)\n\n        # Combine baseline, tight fit boost, and moderate fit score.\n        # The tightest fit gets 1.0. Other suitable bins get a score based on inverse capacity.\n        # We need to ensure that the 'best fit' priority (1.0) is respected.\n        # If a bin is the tightest fit, its priority is 1.0.\n        # For others, it's a scaled inverse capacity.\n\n        # Recalculate priorities for 'other' suitable bins\n        priorities[other_suitable_indices] = 0.5 * normalized_inverse_score # Scale it down to be less than 1.0\n\n    # Ensure that the best fits truly have the highest priority and that other suitable bins\n    # have a priority higher than 0 but lower than the best fit.\n    # If any bin was marked as a tight fit, its priority is 1.0.\n    # Other suitable bins get their calculated score, which should be < 1.0.\n    # If a bin is suitable but not a tight fit, and not in 'other_suitable_indices' (which shouldn't happen if logic is correct),\n    # it will remain 0.\n    # The logic above correctly assigns 1.0 to tight fits and <1.0 to other suitable bins.\n\n    return priorities\n\n[Heuristics 17th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    possible_bins = bins_remain_cap >= item\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    available_capacities = bins_remain_cap[possible_bins]\n    \n    if available_capacities.size > 0:\n        \n        fitted_capacities = available_capacities - item\n        \n        \n        scaled_capacities = fitted_capacities / np.max(available_capacities)\n        \n        \n        priorities[possible_bins] = 1 / (1 + np.exp(-5 * (scaled_capacities - 0.5)))\n        \n        \n        if np.any(fitted_capacities == 0):\n            priorities[possible_bins][fitted_capacities == 0] = 1.0\n            \n    return priorities\n\n[Heuristics 18th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on tight fit, favoring exact fits then closest fits.\n\n    Combines exact fit (priority 1.0) with a tight fit metric using sigmoid\n    on the inverse of remaining capacity relative to item size.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    epsilon = 1e-9\n\n    # Identify bins where the item can fit\n    can_fit_mask = bins_remain_cap >= item\n    fitting_bins_remain_cap = bins_remain_cap[can_fit_mask]\n\n    # If there are no bins that can fit the item, return all zeros\n    if fitting_bins_remain_cap.size == 0:\n        return priorities\n\n    # Prioritize exact fits with the highest score\n    exact_fit_mask_for_fitting = np.abs(fitting_bins_remain_cap - item) < epsilon\n    priorities[can_fit_mask][exact_fit_mask_for_fitting] = 1.0\n\n    # For bins that can fit but are not exact fits, use a sigmoid score\n    # that favors bins with less remaining capacity (tighter fit).\n    # The metric is `item / remaining_capacity`. Closer to 1 is better.\n    # We use `sigmoid(k * (item / remaining_capacity - 1))`\n    # k controls the steepness. We choose a moderate k.\n    # We need to apply this only to bins that are not exact fits.\n    non_exact_fit_mask_for_fitting = ~exact_fit_mask_for_fitting\n\n    if np.any(non_exact_fit_mask_for_fitting):\n        non_exact_fitting_capacities = fitting_bins_remain_cap[non_exact_fit_mask_for_fitting]\n        \n        # Calculate the tightness ratio: item size / remaining capacity.\n        # A higher ratio indicates a tighter fit.\n        tightness_ratio = item / (non_exact_fitting_capacities + epsilon)\n\n        # Sigmoid function to map the tightness ratio to a priority score between 0 and 1.\n        # The formula `1 / (1 + exp(-k * (ratio - 1)))` peaks around ratio=1.\n        # A k=5.0 makes the sigmoid relatively steep, favoring capacities closer to item size.\n        k = 5.0\n        sigmoid_priorities = 1 / (1 + np.exp(-k * (tightness_ratio - 1)))\n        \n        # Assign these priorities to the corresponding original bins\n        priorities[can_fit_mask][non_exact_fit_mask_for_fitting] = sigmoid_priorities\n\n    return priorities\n\n[Heuristics 19th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using First Fit strategy.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    for i, capacity in enumerate(bins_remain_cap):\n        if capacity >= item:\n            priorities[i] = 1.0  # Give priority to bins that can fit the item\n        else:\n            priorities[i] = 0.0  # No priority for bins that cannot fit the item\n    \n    # In First Fit, we iterate through bins in order and pick the first one that fits.\n    # To simulate this priority, we want to give higher priority to earlier bins if they fit.\n    # We can achieve this by making the priority score dependent on the bin's index.\n    # A simple way is to add a small decreasing value based on the index.\n    # However, the standard First Fit doesn't explicitly use priority scores in this way;\n    # it's more of a sequential search. For the purpose of this function signature,\n    # we'll just mark bins that can fit. If multiple can fit, the selection logic\n    # outside this function would need to pick the first one.\n    #\n    # A true \"priority\" that mimics FF selection might be complex within this\n    # function signature if it's meant to return scores to be maxed.\n    # If the intention is for this function to directly return which bin to pick,\n    # a different approach would be needed.\n    #\n    # Given the structure, the simplest interpretation that *hints* at FF is\n    # to give a higher score to the *first* available bin.\n    \n    first_available_index = -1\n    for i, capacity in enumerate(bins_remain_cap):\n        if capacity >= item:\n            first_available_index = i\n            break\n            \n    if first_available_index != -1:\n        priorities[first_available_index] = 1.0 + (len(bins_remain_cap) - 1 - first_available_index) * 0.001 # Slightly higher priority for earlier bins\n        \n    return priorities\n\n[Heuristics 20th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using First Fit strategy.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    for i, capacity in enumerate(bins_remain_cap):\n        if capacity >= item:\n            priorities[i] = 1.0  # Give priority to bins that can fit the item\n        else:\n            priorities[i] = 0.0  # No priority for bins that cannot fit the item\n    \n    # In First Fit, we iterate through bins in order and pick the first one that fits.\n    # To simulate this priority, we want to give higher priority to earlier bins if they fit.\n    # We can achieve this by making the priority score dependent on the bin's index.\n    # A simple way is to add a small decreasing value based on the index.\n    # However, the standard First Fit doesn't explicitly use priority scores in this way;\n    # it's more of a sequential search. For the purpose of this function signature,\n    # we'll just mark bins that can fit. If multiple can fit, the selection logic\n    # outside this function would need to pick the first one.\n    #\n    # A true \"priority\" that mimics FF selection might be complex within this\n    # function signature if it's meant to return scores to be maxed.\n    # If the intention is for this function to directly return which bin to pick,\n    # a different approach would be needed.\n    #\n    # Given the structure, the simplest interpretation that *hints* at FF is\n    # to give a higher score to the *first* available bin.\n    \n    first_available_index = -1\n    for i, capacity in enumerate(bins_remain_cap):\n        if capacity >= item:\n            first_available_index = i\n            break\n            \n    if first_available_index != -1:\n        priorities[first_available_index] = 1.0 + (len(bins_remain_cap) - 1 - first_available_index) * 0.001 # Slightly higher priority for earlier bins\n        \n    return priorities\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}