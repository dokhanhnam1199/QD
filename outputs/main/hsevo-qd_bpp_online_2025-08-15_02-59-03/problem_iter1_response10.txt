```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using First Fit strategy."""
    priorities = np.zeros_like(bins_remain_cap)
    for i, capacity in enumerate(bins_remain_cap):
        if capacity >= item:
            priorities[i] = 1.0  # Give priority to bins that can fit the item
        else:
            priorities[i] = 0.0  # No priority for bins that cannot fit the item
    
    # In First Fit, we iterate through bins in order and pick the first one that fits.
    # To simulate this priority, we want to give higher priority to earlier bins if they fit.
    # We can achieve this by making the priority score dependent on the bin's index.
    # A simple way is to add a small decreasing value based on the index.
    # However, the standard First Fit doesn't explicitly use priority scores in this way;
    # it's more of a sequential search. For the purpose of this function signature,
    # we'll just mark bins that can fit. If multiple can fit, the selection logic
    # outside this function would need to pick the first one.
    #
    # A true "priority" that mimics FF selection might be complex within this
    # function signature if it's meant to return scores to be maxed.
    # If the intention is for this function to directly return which bin to pick,
    # a different approach would be needed.
    #
    # Given the structure, the simplest interpretation that *hints* at FF is
    # to give a higher score to the *first* available bin.
    
    first_available_index = -1
    for i, capacity in enumerate(bins_remain_cap):
        if capacity >= item:
            first_available_index = i
            break
            
    if first_available_index != -1:
        priorities[first_available_index] = 1.0 + (len(bins_remain_cap) - 1 - first_available_index) * 0.001 # Slightly higher priority for earlier bins
        
    return priorities
```
