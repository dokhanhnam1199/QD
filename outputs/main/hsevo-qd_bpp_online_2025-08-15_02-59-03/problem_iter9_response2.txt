```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Returns priority with which we want to add item to each bin.
    This version prioritizes bins that can fit the item, favoring those
    that leave the least remaining capacity (Best Fit) and then
    breaking ties by favoring bins that are less full (less remaining capacity).
    """
    priorities = np.zeros_like(bins_remain_cap)
    
    # Mask for bins that can fit the item
    can_fit_mask = bins_remain_cap >= item
    
    if not np.any(can_fit_mask):
        return priorities  # No bin can fit the item

    # Calculate remaining capacity after placing the item in suitable bins
    remaining_capacities_after_fit = bins_remain_cap[can_fit_mask] - item
    
    # Find the minimum remaining capacity among suitable bins (Best Fit criterion)
    min_remaining_capacity = np.min(remaining_capacities_after_fit)
    
    # Identify bins that achieve the Best Fit
    best_fit_mask_indices = np.where(can_fit_mask & (bins_remain_cap - item == min_remaining_capacity))[0]
    
    # For these best-fit bins, we want to assign a higher priority.
    # Among these best-fit bins, we can add a secondary criterion.
    # A common heuristic is to prefer bins that are *more* full (less remaining capacity)
    # to leave larger empty spaces in other bins. However, the prompt suggests
    # favoring bins that are "less full" as a tie-breaker, which means more remaining capacity.
    # Let's follow the prompt's tie-breaking hint: favor bins with *more* remaining capacity
    # among those that achieve the best fit.

    if len(best_fit_mask_indices) > 0:
        best_fit_bins_remain_cap = bins_remain_cap[best_fit_mask_indices]
        
        # Find the maximum remaining capacity among the best-fit bins
        max_remaining_capacity_among_best_fit = np.max(best_fit_bins_remain_cap)
        
        # Identify bins that achieve best fit AND have the maximum remaining capacity among them
        tie_breaker_mask_indices = np.where(
            (bins_remain_cap >= item) &
            (bins_remain_cap - item == min_remaining_capacity) &
            (bins_remain_cap == max_remaining_capacity_among_best_fit)
        )[0]
        
        # Assign priority 1 to these bins
        priorities[tie_breaker_mask_indices] = 1.0

    return priorities
```
