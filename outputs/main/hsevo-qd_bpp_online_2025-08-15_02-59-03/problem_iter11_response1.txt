```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Prioritizes bins with an exact fit, then bins with the smallest remaining
    capacity (Best Fit), and finally provides a graded preference for bins
    that are close to an exact fit, promoting efficient packing.
    """
    priorities = np.zeros_like(bins_remain_cap)
    suitable_bins_mask = bins_remain_cap >= item

    if not np.any(suitable_bins_mask):
        return priorities

    suitable_bins_caps = bins_remain_cap[suitable_bins_mask]
    remaining_capacities_after_packing = suitable_bins_caps - item

    tolerance = 1e-6
    perfect_fit_mask = np.abs(remaining_capacities_after_packing) < tolerance

    if np.any(perfect_fit_mask):
        # Highest priority for perfect fits
        min_remaining_cap_among_perfect = np.min(remaining_capacities_after_packing[perfect_fit_mask])
        best_fit_perfect_mask = (suitable_bins_caps - item == min_remaining_cap_among_perfect)
        original_indices_perfect = np.where(suitable_bins_mask)[0][best_fit_perfect_mask]
        priorities[original_indices_perfect] = 2.0 

    # Intermediate priority for bins that are "almost" perfect fits
    almost_perfect_mask = (remaining_capacities_after_packing > tolerance) & (remaining_capacities_after_packing < 0.2) # Example threshold
    if np.any(almost_perfect_mask):
        remaining_caps_almost_perfect = remaining_capacities_after_packing[almost_perfect_mask]
        # Score based on how close to perfect, higher score for closer fits
        scores_almost_perfect = 1.0 / (1.0 + remaining_caps_almost_perfect)
        
        max_score_ap = np.max(scores_almost_perfect)
        min_score_ap = np.min(scores_almost_perfect)
        if max_score_ap > min_score_ap:
            normalized_scores_ap = 0.8 + 0.8 * (scores_almost_perfect - min_score_ap) / (max_score_ap - min_score_ap)
        else:
            normalized_scores_ap = np.ones_like(scores_almost_perfect) * 0.8

        original_indices_almost_perfect = np.where(suitable_bins_mask)[0][almost_perfect_mask]
        priorities[original_indices_almost_perfect] = np.maximum(priorities[original_indices_almost_perfect], normalized_scores_ap)

    # Lower priority for other suitable bins (Best Fit)
    other_suitable_mask = suitable_bins_mask.copy()
    other_suitable_mask[np.where(suitable_bins_mask)[0][perfect_fit_mask]] = False
    other_suitable_mask[np.where(suitable_bins_mask)[0][almost_perfect_mask]] = False
    
    if np.any(other_suitable_mask):
        other_suitable_caps = bins_remain_cap[other_suitable_mask]
        remaining_caps_others = other_suitable_caps - item
        
        min_remaining_cap_overall = np.min(remaining_capacities_after_packing[~perfect_fit_mask]) # Consider all non-perfect fits
        
        scores_others = 1.0 / (1.0 + remaining_caps_others - min_remaining_cap_overall)
        
        max_score_o = np.max(scores_others)
        min_score_o = np.min(scores_others)
        if max_score_o > min_score_o:
            normalized_scores_o = 0.2 + 0.6 * (scores_others - min_score_o) / (max_score_o - min_score_o)
        else:
            normalized_scores_o = np.ones_like(scores_others) * 0.4

        original_indices_others = np.where(other_suitable_mask)[0]
        priorities[original_indices_others] = np.maximum(priorities[original_indices_others], normalized_scores_o)

    return priorities
```
