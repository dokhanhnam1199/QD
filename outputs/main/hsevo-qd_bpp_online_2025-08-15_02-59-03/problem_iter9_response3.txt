```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Returns priority with which we want to add item to each bin.
    This version prioritizes bins that are nearly full after packing (Best Fit),
    but also considers bins that have just enough space (First Fit-like) as a tie-breaker.
    It also penalizes bins that would leave a very small remaining capacity,
    unless it's the only option.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    suitable_bins_mask = bins_remain_cap >= item

    if not np.any(suitable_bins_mask):
        return priorities

    # Calculate potential remaining capacities for suitable bins
    potential_remaining_caps = bins_remain_cap[suitable_bins_mask] - item

    # Penalty for leaving a very small remaining capacity (e.g., less than 10% of bin capacity)
    # We assume a bin capacity of 1.0 for this penalty calculation.
    # This penalty is applied only if there are other options that don't create this small gap.
    small_gap_penalty = np.zeros_like(bins_remain_cap, dtype=float)
    small_gap_threshold = 0.10 # Assume bin capacity is 1.0 for this threshold
    # Identify bins that would result in a small remaining capacity
    would_create_small_gap_mask = suitable_bins_mask & (bins_remain_cap - item < small_gap_threshold)

    # If there are bins that DO NOT create a small gap, apply penalty to those that do
    if np.any(~would_create_small_gap_mask[suitable_bins_mask]):
        small_gap_penalty[would_create_small_gap_mask] = -1.0 # Apply a penalty

    # Primary strategy: Best Fit (minimize remaining capacity)
    min_remaining_capacity = np.min(potential_remaining_caps)
    best_fit_mask = suitable_bins_mask & (bins_remain_cap - item == min_remaining_capacity)
    priorities[best_fit_mask] += 2.0  # Higher priority for best fit

    # Secondary strategy: Slight preference for bins that are "just enough" if no clear best fit
    # or if multiple bins have the same minimal remaining capacity.
    # This aims to keep larger gaps in other bins if possible.
    # We'll give a small bonus to bins that are close to the item size, but not necessarily the absolute best fit.
    # We define "close" as being within a small tolerance of the item size.
    tolerance = 0.01 # Small tolerance
    just_enough_mask = suitable_bins_mask & (np.abs((bins_remain_cap - item) - min_remaining_capacity) > tolerance) & (bins_remain_cap - item > 0)
    priorities[just_enough_mask] += 0.5 # Small bonus for bins that are not the absolute best fit but still good

    # Combine priorities and penalties
    final_priorities = priorities + small_gap_penalty

    # Ensure that if only "bad" options exist (all create small gaps), we don't penalize them too much
    # If all suitable bins would create a small gap, remove the penalty from them.
    if np.all(would_create_small_gap_mask[suitable_bins_mask]):
        final_priorities[would_create_small_gap_mask] = priorities[would_create_small_gap_mask]

    # Normalize priorities to be between 0 and 1 for consistency, but keep relative order
    # This is optional, but can help in some contexts. The primary goal is relative ordering.
    valid_priorities = final_priorities[suitable_bins_mask]
    if len(valid_priorities) > 0:
        min_p = np.min(valid_priorities)
        max_p = np.max(valid_priorities)
        if max_p - min_p > 1e-6: # Avoid division by zero
            final_priorities[suitable_bins_mask] = (valid_priorities - min_p) / (max_p - min_p)
        else: # All valid priorities are the same
            final_priorities[suitable_bins_mask] = 0.5 # Assign a neutral score

    # Ensure no negative priorities for valid bins unless it's a severe penalty scenario
    # Here, we want to prioritize *any* suitable bin over no bin.
    final_priorities[suitable_bins_mask] = np.maximum(final_priorities[suitable_bins_mask], 0)


    return final_priorities
```
