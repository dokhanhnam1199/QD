```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Returns priority with which we want to add item to each bin using a modified Best Fit strategy
    that favors bins with less remaining capacity, but also considers the "fit" more directly.
    It prioritizes bins that are a "tight fit" (minimizing leftover space)
    while also providing a slight preference for bins that are less full overall,
    aiming to distribute items more evenly if multiple tight fits exist.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    suitable_bins_mask = bins_remain_cap >= item

    if not np.any(suitable_bins_mask):
        return priorities

    # Calculate the remaining capacity after placing the item in suitable bins
    remaining_after_fit = bins_remain_cap[suitable_bins_mask] - item

    # Find the minimum remaining capacity (best fit)
    min_remaining_capacity = np.min(remaining_after_fit)

    # Identify bins that are a "tight fit" (i.e., result in the minimum remaining capacity)
    tight_fit_mask = suitable_bins_mask & (bins_remain_cap - item == min_remaining_capacity)

    # For bins that are a tight fit, assign a higher priority based on how much capacity is left *before* fitting.
    # This subtly prefers bins that had *just enough* space, rather than bins that had a lot of space but still fit.
    # We invert the remaining capacity to give higher scores to bins with less remaining capacity (closer to 'item').
    # Adding a small epsilon to avoid division by zero if a bin had exactly 'item' capacity.
    priorities[tight_fit_mask] = 1.0 / (bins_remain_cap[tight_fit_mask] - item + 1e-9)

    # For bins that are not a tight fit, but are still suitable, assign a lower priority.
    # This priority is inversely proportional to the remaining capacity after placing the item.
    # This provides a soft preference for bins that have more space left, encouraging spread.
    # This part acts as a tie-breaker or a fallback for non-perfect fits.
    non_tight_fit_mask = suitable_bins_mask & ~tight_fit_mask
    if np.any(non_tight_fit_mask):
        remaining_after_fit_non_tight = bins_remain_cap[non_tight_fit_mask] - item
        # Assign priority based on inverse remaining capacity, normalized to prevent overly large values
        # Add a small constant to the denominator to avoid division by zero and to ensure a baseline priority
        priorities[non_tight_fit_mask] = 0.1 / (remaining_after_fit_non_tight + 1.0) # Lower priority than tight fits


    # Normalize priorities for tight fits to be generally higher than non-tight fits
    if np.any(tight_fit_mask):
        max_tight_fit_priority = np.max(priorities[tight_fit_mask])
        if max_tight_fit_priority > 0:
            priorities[tight_fit_mask] /= max_tight_fit_priority

    return priorities
```
