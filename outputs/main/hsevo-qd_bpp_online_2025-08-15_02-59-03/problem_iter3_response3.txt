```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Returns priority with which we want to add item to each bin using a modified Best Fit strategy.
    This version prioritizes bins that are a 'tight fit' but also considers bins with
    sufficient remaining capacity to reduce fragmentation. It also penalizes bins
    that would become almost empty after packing.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    suitable_bins_mask = bins_remain_cap >= item

    if not np.any(suitable_bins_mask):
        return priorities

    # Calculate remaining capacity after packing the item
    potential_remaining_caps = bins_remain_cap[suitable_bins_mask] - item

    # Define a threshold for "almost empty" bins
    # This is heuristic, can be tuned. For now, let's say less than 10% of bin capacity (assuming max bin capacity is 1.0)
    almost_empty_threshold = 0.1

    # Assign higher priority to bins that are a good fit (minimal remaining capacity)
    # but avoid bins that become too empty.
    # We want to minimize (bins_remain_cap - item) but not if it leads to a very small remaining capacity.
    # We can use the inverse of the remaining capacity for prioritization,
    # but cap it to avoid extreme values and penalize very small remainders.

    # Calculate a score based on how "tight" the fit is, but avoid extreme penalization
    # Lower values of (potential_remaining_caps) are better fits.
    # We want to maximize priority, so we can use a function that gives higher values for smaller positive remaining capacities.
    # A simple approach is 1 / (1 + remaining_capacity) which maps [0, inf) to (0, 1].
    # However, we want to *avoid* bins that become almost empty.

    # Let's prioritize bins that have a "good" fit, meaning remaining capacity is small but not near zero.
    # We can assign a score inversely proportional to the remaining capacity, but with a penalty for very small remainders.
    # A possible scoring function: (bins_remain_cap[suitable_bins_mask] - item) ** 2
    # This gives higher scores to bins that are closer to fitting the item perfectly.
    # However, we want to *avoid* bins that become almost empty.
    # So, let's give a higher score to bins that have a reasonable amount of remaining capacity after packing,
    # favoring those that are "just enough" to fit the item.

    # A common heuristic is to favor bins that have the *least* remaining capacity after packing.
    # This is the Best Fit strategy. We want to improve on this.
    # Let's consider the *gap* created: bins_remain_cap[suitable_bins_mask] - item.
    # We want to minimize this gap.

    # Alternative: Prioritize bins that leave a moderate amount of space.
    # This might lead to more flexible bins for future items.
    # However, the primary goal of BPP is to minimize the number of bins, so tight fits are generally preferred.

    # Let's refine the "tight fit" idea. We want the smallest non-negative (bins_remain_cap - item).
    # Consider the reciprocal of the remaining capacity after packing.
    # We can use `1 / (1 + potential_remaining_caps)` which gives values between 0 and 1.
    # Higher values mean smaller remaining capacity (better fit).
    # However, this can give very high scores to very small positive remaining capacities.

    # Let's try a score that rewards small positive remaining capacities, but penalizes very small ones.
    # A quadratic approach can work: (remaining_capacity)^2. Smaller is better.
    # We want to maximize priority, so we can use `- (remaining_capacity)^2`.
    # Or, we can use `1 / (1 + remaining_capacity^2)`.

    # Let's try to balance Best Fit with avoiding excessive fragmentation.
    # We want small remaining capacities, but not extremely small ones.
    # Consider the negative of the remaining capacity, this ranks better fits higher.
    # We can introduce a penalty if the remaining capacity is too small.

    # Calculate remaining capacities for suitable bins
    current_suitable_bins_remain_cap = bins_remain_cap[suitable_bins_mask]
    remaining_after_packing = current_suitable_bins_remain_cap - item

    # Prioritize bins with minimal remaining capacity, but with a penalty for bins that become "too empty".
    # We want to maximize the priority score.
    # A score could be: `-(remaining_after_packing)^2`
    # This makes smaller `remaining_after_packing` have higher scores (closer to 0).
    # But we need to penalize if `remaining_after_packing` is very close to 0.

    # Let's assign a score based on how close the remaining capacity is to the item size.
    # The closer `bins_remain_cap[i]` is to `item`, the higher the priority.
    # This is effectively Best Fit.

    # To improve: Consider how *much* capacity is left after fitting.
    # If `bins_remain_cap[i] - item` is small, it's a good fit.
    # If `bins_remain_cap[i] - item` is large, it might leave a useful bin for future larger items.
    # This hints at a trade-off.

    # Let's try a score that favors smaller positive remainders, but with a slight preference for
    # bins that don't become *extremely* tight, to leave some room.
    # Consider the reciprocal of the gap: `1 / (gap + epsilon)` where `epsilon` prevents division by zero.
    # However, this amplifies small gaps significantly.

    # Let's try to create a score that is high for small, positive `remaining_after_packing`.
    # We can use `1 / (1 + remaining_after_packing)` for this.
    # This maps [0, inf) to (0, 1]. Smaller remaining capacity -> higher priority.
    # Now, let's add a penalty if the remaining capacity is *too* small (e.g., less than 5% of bin capacity).
    # A bin becoming very empty after packing means we might have wasted a lot of space.

    # Calculate scores for suitable bins.
    # We want to maximize the score.
    # Lower `remaining_after_packing` is better for minimizing bins.
    # Let's use the inverse of the gap: `1.0 / (1.0 + remaining_after_packing)`
    # This gives higher scores to bins with smaller remaining capacities.
    scores = 1.0 / (1.0 + remaining_after_packing)

    # Now, introduce a penalty for bins that become "too empty".
    # If `remaining_after_packing` is very small (close to zero), this is good for tight fitting.
    # But if the original `current_suitable_bins_remain_cap` was large, and after packing it's still large,
    # this might be a "wasteful" bin to pack into if a tighter fit exists.

    # A strategy could be to favor bins that have a remaining capacity that is "just enough" or slightly more.
    # Let's define "just enough" as the smallest positive remainder.

    # Consider the relative remaining capacity: `remaining_after_packing / bins_remain_cap[suitable_bins_mask]`
    # We want this ratio to be small. So, `1 - ratio` or `-ratio`.

    # Let's go back to prioritizing bins that have the least remaining capacity after packing.
    # This is the core of Best Fit.
    # To improve: Can we make the score more sensitive to very small gaps?
    # Or penalize gaps that are still quite large?

    # Let's use a Gaussian-like function centered around a small positive remainder.
    # Or, simply, assign higher priority to smaller positive remainders.
    # We want to maximize the priority.
    # `priority = -remaining_after_packing` would prioritize the tightest fits.

    # Let's try a score that emphasizes the "tightest fit" but gives a small bonus
    # for bins that have a bit more room, to prevent immediate over-fragmentation of bins.
    # This is a balance.

    # Let's consider the gap: `gap = bins_remain_cap[suitable_bins_mask] - item`
    # We want to minimize `gap`.
    # If we want to prioritize smaller gaps, we can use `1 / (gap + epsilon)`.

    # A more nuanced approach:
    # The Best Fit heuristic aims to minimize `bins_remain_cap - item`.
    # Let's consider the score as `-(bins_remain_cap - item)` for suitable bins.
    # Higher score means smaller `bins_remain_cap - item`.
    # This is essentially what `priority_v1` does by assigning 1.0 to the minimum.

    # To improve:
    # What if we give a bonus to bins that are *almost* full, but still fit the item?
    # This would reduce the number of bins used if we can pack a large item into a nearly full bin.
    # What if we penalize bins that are currently very empty, even if they fit the item?
    # This might lead to more evenly filled bins.

    # Let's try a priority function that is higher for bins that have a small remaining capacity after packing,
    # and penalizes bins that become "too empty" relative to their original capacity.

    # Calculate the gap:
    gap = current_suitable_bins_remain_cap - item

    # Calculate a score based on the gap. We want to prioritize smaller gaps.
    # Using the inverse of the gap can be good. `1.0 / (gap + 1e-6)`
    # This assigns higher scores to smaller gaps.

    # Let's try to make the priority a function of the gap.
    # Higher priority for smaller gaps.
    # We can use `np.exp(-gap)` or `1 / (1 + gap)`.
    # `1 / (1 + gap)` maps [0, inf) to (0, 1].
    priority_scores_for_suitable = 1.0 / (1.0 + gap)

    # Now, let's consider penalizing bins that become "too empty".
    # A bin is "too empty" if `gap` is very small relative to its original capacity.
    # Let's consider a threshold for "too empty".
    # If `gap < 0.1 * current_suitable_bins_remain_cap`, it might be considered too empty.
    # We want to *decrease* the priority score in such cases.
    # A simple penalty could be multiplying by a factor less than 1.

    # Let's define a penalty factor.
    # If `gap` is small relative to original capacity, apply a penalty.
    # Penalty factor: `penalty = np.where(gap < 0.1 * current_suitable_bins_remain_cap, 0.5, 1.0)`
    # This is too simplistic.

    # Let's rethink the objective. Minimize the number of bins.
    # Best Fit is a good strategy. The improvement could come from how we *select* among best fits,
    # or by introducing a secondary criterion.

    # What if we assign priority based on the "tightness" of the fit, but with a slight preference
    # for bins that leave a small, but not negligible, amount of space?
    # This could help in packing smaller items later.

    # Consider the gap `g = bins_remain_cap[i] - item`.
    # We want to minimize `g`.
    # A score that is high for small positive `g` values.
    # `score = 1 / (1 + g)`

    # Let's try to penalize situations where a bin becomes *almost exactly* filled.
    # This might be too specific.

    # A balanced approach:
    # Prioritize tight fits.
    # If multiple bins offer the same tightest fit, perhaps choose the one that leaves a bit more space?
    # This could be a tie-breaker.

    # Let's try a simple modification to the Best Fit score.
    # Instead of just `1` for the minimum gap, let's make the score inversely proportional to the gap.
    # `score = 1 / (gap + epsilon)`

    # Let's assign priorities based on the inverse of the remaining capacity after packing.
    # Higher values for bins that will have less remaining capacity.
    # `priorities_for_suitable = 1.0 / (1.0 + remaining_after_packing)`
    # This means smaller remaining capacity gets higher priority.

    # To add robustness and potentially improve packing:
    # If there are multiple bins that are "best fit" (i.e., have the minimum remaining capacity),
    # let's break ties by preferring bins that have a bit more remaining capacity among those best fits.
    # This is a "Best Fit Less" or "Worst Fit among Best Fits" approach for tie-breaking.

    # Calculate remaining capacities for suitable bins
    current_suitable_bins_remain_cap = bins_remain_cap[suitable_bins_mask]
    remaining_after_packing = current_suitable_bins_remain_cap - item

    # Find the minimum remaining capacity among suitable bins
    min_remaining_capacity = np.min(remaining_after_packing)

    # Identify all bins that achieve this minimum remaining capacity
    best_fit_mask_for_suitable = np.isclose(remaining_after_packing, min_remaining_capacity)

    # Calculate priorities: Initialize all to 0
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Assign high priority to bins that are best fits
    priorities[suitable_bins_mask][best_fit_mask_for_suitable] = 1.0

    # Tie-breaking: Among the best fit bins, prefer those with slightly more original capacity.
    # This means if `remaining_after_packing` is the same, a larger `current_suitable_bins_remain_cap`
    # is preferred in the tie-breaking.
    # This is counter-intuitive to Best Fit. Best Fit aims to minimize the remaining gap.

    # Let's reconsider the goal: "better than current version".
    # `priority_v1` is pure Best Fit. It assigns a score of 1.0 to *all* bins that achieve the minimum gap.
    # A "better" heuristic could:
    # 1. Differentiate among the "best fit" bins.
    # 2. Introduce a secondary objective or penalty.

    # Idea: Prioritize bins that are closest to fitting the item without exceeding it.
    # If multiple bins have the same minimal difference, we can differentiate.
    # Let's assign a score that is inversely proportional to the remaining capacity.
    # `score = 1.0 / (1.0 + (bins_remain_cap[i] - item))`

    # Let's create a score that favors tighter fits, but gives a slight preference to bins that
    # don't become "too empty".
    # The definition of "too empty" is context-dependent.

    # Let's try this:
    # 1. Identify all suitable bins.
    # 2. For each suitable bin, calculate the remaining capacity after packing.
    # 3. Assign a priority score that is higher for smaller remaining capacities.
    # 4. Add a small penalty for bins that become "very empty" after packing, meaning
    #    the original capacity was large and the remaining capacity is still large.

    # Calculate remaining capacities for suitable bins
    current_suitable_bins_remain_cap = bins_remain_cap[suitable_bins_mask]
    remaining_after_packing = current_suitable_bins_remain_cap - item

    # Let's create a score that prioritizes smaller `remaining_after_packing`.
    # `score = 1.0 / (1.0 + remaining_after_packing)`
    # This gives higher scores to bins that have less remaining space.

    # Now, to introduce a subtle improvement:
    # If `remaining_after_packing` is very small (e.g., < 0.05), this is a very tight fit.
    # If `remaining_after_packing` is still relatively large (e.g., > 0.5 * original_capacity),
    # this might not be the best bin if a tighter fit exists.

    # Let's define a priority based on how "full" the bin becomes.
    # `fill_ratio = item / bins_remain_cap[suitable_bins_mask]`
    # We want to maximize this ratio, but ensure `bins_remain_cap[suitable_bins_mask] >= item`.
    # So, `fill_ratio` is within `[0, 1]`.
    # If `bins_remain_cap[i] == item`, `fill_ratio = 1`. This is the ideal.
    # If `bins_remain_cap[i] > item`, `fill_ratio < 1`.

    # Let's use the inverse of the remaining capacity: `1 / (remaining_after_packing + epsilon)`
    # This prioritizes smaller remaining capacities.

    # To differentiate among the "best fits":
    # If `remaining_after_packing` are `[0.1, 0.1, 0.2]`, the first two are best fits.
    # We want to select one of the `0.1` ones.
    # Among `0.1` and `0.1`, which one to pick?
    # A common tie-breaker in Best Fit variants is to pick the bin with the largest capacity among those that are best fits.
    # This is "Best Fit Decreasing" style logic applied to tie-breaking.
    # However, we are packing *online*, so item size is fixed.

    # Let's try a score that is higher for smaller gaps, but we want to break ties by preferring
    # bins that leave a bit more space among the tightest fits. This means we are looking for
    # the `min(gap)` and among those `min(gap)`, pick the one with the largest `bins_remain_cap`.

    # Revised approach:
    # 1. For suitable bins, calculate `gap = bins_remain_cap[i] - item`.
    # 2. We want to find the minimum `gap`.
    # 3. If there are multiple bins with the minimum `gap`, choose the one with the largest `bins_remain_cap`.

    # Let's construct a priority score that reflects this.
    # We want to maximize the priority.
    # A score could be `-(gap)`. This prioritizes smaller gaps.
    # To break ties using `bins_remain_cap` (larger is better), we can add a scaled version of it:
    # `score = -(gap) + alpha * bins_remain_cap[suitable_bins_mask]`
    # Where `alpha` is a small positive constant to ensure `gap` is the primary criterion.
    # The `-(gap)` part means smaller gap is better.
    # The `+ alpha * bins_remain_cap` part means among same gaps, larger original capacity is better.

    # Let's set `alpha` to a small value, e.g., `1e-4`.
    # The `bins_remain_cap` values are typically between 0 and 1 (normalized).

    gap = current_suitable_bins_remain_cap - item
    alpha = 1e-4  # Small constant for tie-breaking

    # Calculate scores: Prioritize smaller gaps, then larger original capacities.
    # We want to maximize the score.
    scores = -gap + alpha * current_suitable_bins_remain_cap

    # Now, place these scores into the full `priorities` array.
    priorities[suitable_bins_mask] = scores

    return priorities
```
