```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Exact Fit with a refined Best Fit, prioritizing snug fits
    and then bins that minimize remaining capacity, ensuring clarity.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=np.float64)
    suitable_bins_mask = bins_remain_cap >= item

    if not np.any(suitable_bins_mask):
        return priorities

    suitable_bins_caps = bins_remain_cap[suitable_bins_mask]
    remaining_capacities_after_packing = suitable_bins_caps - item

    # Assign highest priority to exact fits (tolerance for floating point issues)
    tolerance = 1e-9
    exact_fit_mask = np.abs(remaining_capacities_after_packing) < tolerance
    
    if np.any(exact_fit_mask):
        priorities[suitable_bins_mask][exact_fit_mask] = 1.0

    # For non-exact fits, prioritize based on Best Fit principle:
    # minimize remaining capacity after packing.
    # Use a score that is inversely proportional to the remaining capacity.
    # Add a small epsilon to avoid division by zero if remaining_after_fit is 0 (though covered by exact fit).
    non_exact_fit_mask = ~exact_fit_mask
    
    if np.any(non_exact_fit_mask):
        non_exact_remain_caps = remaining_capacities_after_packing[non_exact_fit_mask]
        
        # Higher score for smaller remaining capacity after packing
        # Use a scaled inverse to keep scores in a reasonable range and prioritize tighter fits.
        # We scale by the minimum remaining capacity among these non-exact fits.
        min_remaining_among_non_exact = np.min(non_exact_remain_caps)
        scaled_scores = 1.0 / (1.0 + (non_exact_remain_caps - min_remaining_among_non_exact))

        # Normalize scores for non-exact fits to be between 0 and 0.9
        # This ensures exact fits (score 1.0) are always preferred.
        max_score = np.max(scaled_scores)
        min_score = np.min(scaled_scores)
        if max_score > min_score:
            normalized_scores = 0.9 * (scaled_scores - min_score) / (max_score - min_score)
        else:
            normalized_scores = np.full_like(scaled_scores, 0.45) # Neutral score if all are equal

        # Assign these scores to the appropriate bins
        priorities[suitable_bins_mask][non_exact_fit_mask] = normalized_scores

    return priorities
```
