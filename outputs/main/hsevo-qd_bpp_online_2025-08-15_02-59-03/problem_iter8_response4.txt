```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Prioritizes bins by favoring exact fits, then tightest fits, with a penalty for unsuitable bins.

    Combines the clarity of exact fits (priority 1.0) with a scaled tight-fit
    metric, ensuring all fitting bins have a higher priority than non-fitting ones.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    epsilon = 1e-9

    # Identify bins where the item can fit
    can_fit_mask = bins_remain_cap >= item

    if not np.any(can_fit_mask):
        # No bins can fit the item, return all zeros
        return priorities

    fitting_bins_remain_cap = bins_remain_cap[can_fit_mask]

    # Prioritize exact fits with the highest score
    exact_fit_mask_for_fitting = np.abs(fitting_bins_remain_cap - item) < epsilon
    priorities[can_fit_mask][exact_fit_mask_for_fitting] = 1.0

    # For bins that can fit but are not exact fits, use a score based on inverse difference
    # This favors bins that are closer to the item size (tightest fit)
    non_exact_fit_mask_for_fitting = ~exact_fit_mask_for_fitting

    if np.any(non_exact_fit_mask_for_fitting):
        non_exact_fitting_capacities = fitting_bins_remain_cap[non_exact_fit_mask_for_fitting]

        # Calculate a tightness score: higher for smaller remaining capacity
        # Use inverse of the difference: 1 / (capacity - item)
        # Add epsilon to avoid division by zero
        tightness_scores = 1.0 / (non_exact_fitting_capacities - item + epsilon)

        # Normalize these scores to be between 0 and <1.0 to maintain
        # exact fits as the absolute highest priority.
        # We can use a simple scaling by the maximum non-exact score,
        # or a more controlled scaling if needed.
        # For simplicity and to ensure non-exact scores are strictly less than 1.0,
        # we can scale them relative to the exact fit priority.
        max_tightness_score = np.max(tightness_scores)
        
        # Scale scores so the maximum is less than 1.0. A multiplier of 0.99 works.
        scaled_tightness_scores = 0.99 * (tightness_scores / max_tightness_score)

        priorities[can_fit_mask][non_exact_fit_mask_for_fitting] = scaled_tightness_scores

    # Bins that cannot fit the item already have a priority of 0.0, which is the lowest.
    return priorities
```
