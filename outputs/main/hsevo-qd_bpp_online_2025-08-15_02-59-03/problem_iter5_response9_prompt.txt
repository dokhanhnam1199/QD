{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code only and do not add comments into the code. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Returns priority with which we want to add item to each bin using a modified Best Fit strategy\n    that also considers the initial size of the bin.\n    Bins that are almost full but can still accommodate the item are prioritized slightly higher\n    than bins that have a lot of remaining space, to encourage tighter packing.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Mask for bins that can accommodate the item\n    suitable_bins_mask = bins_remain_cap >= item\n\n    if not np.any(suitable_bins_mask):\n        return priorities  # No bin can fit the item\n\n    # Calculate remaining capacities for suitable bins\n    remaining_capacities_after_fit = bins_remain_cap[suitable_bins_mask] - item\n\n    # Find the minimum remaining capacity among suitable bins (this is the Best Fit criterion)\n    min_remaining_capacity = np.min(remaining_capacities_after_fit)\n\n    # Identify bins that achieve the minimum remaining capacity\n    best_fit_bins_mask = suitable_bins_mask.copy()\n    best_fit_bins_mask[suitable_bins_mask] = (remaining_capacities_after_fit == min_remaining_capacity)\n\n    # Assign a base priority of 1.0 to best-fit bins\n    priorities[best_fit_bins_mask] = 1.0\n\n    # Introduce a secondary consideration: prefer bins that are already \"closer\" to full.\n    # This is to avoid leaving many small gaps in bins that are mostly empty.\n    # We can achieve this by giving a slight boost to bins that have less remaining capacity *before* the item is added,\n    # among those that can fit the item.\n\n    # Get remaining capacities of all suitable bins\n    suitable_bins_remaining_cap = bins_remain_cap[suitable_bins_mask]\n\n    # Calculate a \"fill ratio\" - how full the bin is before adding the item. Higher is better.\n    # Add a small epsilon to avoid division by zero if a bin had 0 initial capacity (though unlikely in BPP)\n    epsilon = 1e-9\n    initial_bin_capacity_for_suitable_bins = suitable_bins_remaining_cap + item\n    fill_ratios = (initial_bin_capacity_for_suitable_bins - suitable_bins_remaining_cap) / (initial_bin_capacity_for_suitable_bins + epsilon)\n\n    # Scale these fill ratios to create a secondary priority boost.\n    # We want to slightly prefer fuller bins. A simple scaling could be based on the maximum fill ratio.\n    # A small additive boost is generally safer than multiplicative to avoid huge numbers.\n    # Let's try a small positive boost for bins that are \"more filled\" than the average.\n    \n    # Calculate a threshold based on the mean fill ratio of suitable bins\n    mean_fill_ratio = np.mean(fill_ratios)\n    \n    # Apply a smaller boost to bins that are more filled than the average,\n    # but only if they are not already a \"best fit\" bin (to avoid double counting the primary priority).\n    # The boost should be less than the primary priority (1.0).\n    secondary_boost_amount = 0.1\n\n    # For bins that are suitable but *not* best-fit, and are more filled than average, give a small boost.\n    non_best_fit_suitable_mask = suitable_bins_mask.copy()\n    non_best_fit_suitable_mask[suitable_bins_mask] = ~best_fit_bins_mask[suitable_bins_mask]\n    \n    combined_mask_for_boost = non_best_fit_suitable_mask & suitable_bins_mask\n    \n    if np.any(combined_mask_for_boost):\n        # Filter fill ratios for these bins\n        fill_ratios_for_boost = fill_ratios[np.isin(np.where(suitable_bins_mask)[0], np.where(combined_mask_for_boost)[0])]\n        \n        # Apply boost to those with fill ratio > mean fill ratio\n        boost_condition_mask = fill_ratios_for_boost > mean_fill_ratio\n        \n        if np.any(boost_condition_mask):\n            # Get the indices in the original bins_remain_cap array\n            indices_to_boost = np.where(suitable_bins_mask)[0][np.isin(np.where(suitable_bins_mask)[0], np.where(combined_mask_for_boost)[0])][boost_condition_mask]\n            priorities[indices_to_boost] += secondary_boost_amount\n\n    # Ensure best-fit bins still have the highest priority (1.0)\n    # If a best-fit bin also qualified for the secondary boost, its priority will be 1.0 + 0.1,\n    # which might be undesireable if we want best-fit to be strictly highest.\n    # Let's refine this: Best Fit gets 1.0. Other suitable bins get a smaller priority\n    # based on how \"full\" they are.\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    suitable_bins_mask = bins_remain_cap >= item\n\n    if not np.any(suitable_bins_mask):\n        return priorities\n\n    remaining_capacities_after_fit = bins_remain_cap[suitable_bins_mask] - item\n    min_remaining_capacity = np.min(remaining_capacities_after_fit)\n\n    # Assign priority based on how close they are to best-fit, and then by fill ratio.\n    # The highest priority will be for best-fit bins.\n    # For non-best-fit bins, priority will be lower and based on their fill level.\n\n    # Calculate a \"closeness\" to best-fit metric for all suitable bins.\n    # Lower remaining capacity after fit is better (closer to best-fit).\n    # We can normalize this.\n    \n    # Normalize remaining capacities to a [0, 1] range, where 0 is best.\n    # Avoid division by zero if all suitable bins have the same remaining capacity.\n    if np.all(remaining_capacities_after_fit == min_remaining_capacity):\n        closeness_to_best_fit = np.zeros_like(remaining_capacities_after_fit)\n    else:\n        max_remaining_capacity_after_fit = np.max(remaining_capacities_after_fit)\n        closeness_to_best_fit = (remaining_capacities_after_fit - min_remaining_capacity) / (max_remaining_capacity_after_fit - min_remaining_capacity + epsilon)\n\n    # Now, use fill ratio for secondary sorting among bins with similar \"closeness to best-fit\".\n    # Or, combine them. A simple way is to prioritize Best Fit (closeness = 0) with a high score,\n    # and then use fill ratio for others.\n\n    # Let's assign priorities:\n    # Best-fit bins get a high priority (e.g., 1.0)\n    # Other suitable bins get a priority based on their fill ratio, scaled down.\n    \n    # Priority for best-fit bins\n    best_fit_bins_mask_final = suitable_bins_mask.copy()\n    best_fit_bins_mask_final[suitable_bins_mask] = (remaining_capacities_after_fit == min_remaining_capacity)\n    priorities[best_fit_bins_mask_final] = 1.0\n    \n    # Priority for non-best-fit suitable bins\n    non_best_fit_suitable_mask_final = suitable_bins_mask.copy()\n    non_best_fit_suitable_mask_final[suitable_bins_mask] = ~best_fit_bins_mask_final[suitable_bins_mask]\n    \n    # Calculate fill ratios for these bins again\n    suitable_bins_remaining_cap_non_bf = bins_remain_cap[non_best_fit_suitable_mask_final]\n    initial_bin_capacity_for_suitable_bins_non_bf = suitable_bins_remaining_cap_non_bf + item\n    fill_ratios_non_bf = (initial_bin_capacity_for_suitable_bins_non_bf - suitable_bins_remaining_cap_non_bf) / (initial_bin_capacity_for_suitable_bins_non_bf + epsilon)\n\n    # Scale these fill ratios to a lower range, e.g., [0.1, 0.5]\n    # This ensures they are less prioritized than best-fit bins (1.0).\n    if np.any(non_best_fit_suitable_mask_final):\n        if np.all(fill_ratios_non_bf == fill_ratios_non_bf[0]): # Handle case where all fill ratios are same\n             scaled_priorities = 0.3 # Assign a mid-range priority\n        else:\n            min_fill_ratio = np.min(fill_ratios_non_bf)\n            max_fill_ratio = np.max(fill_ratios_non_bf)\n            # Scale fill ratios from [min_fill_ratio, max_fill_ratio] to [0.1, 0.5]\n            scaled_priorities = 0.1 + 0.4 * (fill_ratios_non_bf - min_fill_ratio) / (max_fill_ratio - min_fill_ratio + epsilon)\n        \n        priorities[non_best_fit_suitable_mask_final] = scaled_priorities\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin using First Fit strategy.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    for i, capacity in enumerate(bins_remain_cap):\n        if capacity >= item:\n            priorities[i] = 1.0  # Give priority to bins that can fit the item\n        else:\n            priorities[i] = 0.0  # No priority for bins that cannot fit the item\n    \n    # In First Fit, we iterate through bins in order and pick the first one that fits.\n    # To simulate this priority, we want to give higher priority to earlier bins if they fit.\n    # We can achieve this by making the priority score dependent on the bin's index.\n    # A simple way is to add a small decreasing value based on the index.\n    # However, the standard First Fit doesn't explicitly use priority scores in this way;\n    # it's more of a sequential search. For the purpose of this function signature,\n    # we'll just mark bins that can fit. If multiple can fit, the selection logic\n    # outside this function would need to pick the first one.\n    #\n    # A true \"priority\" that mimics FF selection might be complex within this\n    # function signature if it's meant to return scores to be maxed.\n    # If the intention is for this function to directly return which bin to pick,\n    # a different approach would be needed.\n    #\n    # Given the structure, the simplest interpretation that *hints* at FF is\n    # to give a higher score to the *first* available bin.\n    \n    first_available_index = -1\n    for i, capacity in enumerate(bins_remain_cap):\n        if capacity >= item:\n            first_available_index = i\n            break\n            \n    if first_available_index != -1:\n        priorities[first_available_index] = 1.0 + (len(bins_remain_cap) - 1 - first_available_index) * 0.001 # Slightly higher priority for earlier bins\n        \n    return priorities\n\n### Analyze & experience\n- *   **Heuristic 1 vs. Heuristic 2:** These two heuristics are identical. The ranking suggests a subtle difference might have been intended, but as provided, they perform the same.\n*   **Heuristic 1 & 2 vs. Heuristic 3:** Heuristics 1 and 2 offer a more nuanced priority system. They specifically target \"perfect fits\" with the highest priority (2.0) and then use a scaled inverse of remaining capacity for other suitable bins. Heuristic 3 simply uses the inverse of remaining capacity, which might lead to very large scores for near-perfect fits and doesn't explicitly prioritize exact fits.\n*   **Heuristic 1 & 2 vs. Heuristic 4:** Heuristic 4 implements a pure Best Fit strategy, assigning a priority of 1.0 only to the bin(s) with the minimum remaining capacity. Heuristics 1 and 2 are more sophisticated by introducing a higher priority for exact fits and a graded priority for other bins, making them potentially better.\n*   **Heuristic 1 & 2 vs. Heuristic 5:** Heuristic 5 calculates `capacity - item` as a base priority and then transforms it. The transformation `min_diff - priorities[priorities != -np.inf]` effectively prioritizes bins with the *smallest* `capacity - item`, which is the Best Fit criterion. However, it lacks the explicit handling of exact fits that Heuristics 1 and 2 have.\n*   **Heuristic 1 & 2 vs. Heuristic 6:** Heuristic 6 explicitly prioritizes exact fits (1.0) and then uses a normalized score for other best-fit bins (0.9 minus a scaled gap). This is very similar in spirit to Heuristics 1 and 2, but Heuristics 1 and 2 use a higher peak priority (2.0 vs. 1.0 for exact fit) and a slightly different scaling for non-exact fits. The initial ranking suggests 1 and 2 are slightly better.\n*   **Heuristic 7 vs. Heuristics 1 & 2:** Heuristic 7 attempts to combine Best Fit with a secondary consideration for bin \"fill ratio.\" However, its implementation is more complex and its secondary criterion might not always be beneficial. Heuristics 1 and 2's direct focus on exact fit and then best fit for remaining capacity seems more robust.\n*   **Heuristic 8 & 9 vs. Heuristics 1 & 2:** Heuristics 8 and 9 introduce a second heuristic focusing on moderate remaining space, adding it as a scaled component to the snug fit score. While this aims for better overall utilization, the specific definition of \"moderate\" (10%-50% of item size) is quite arbitrary and might not generalize well. Heuristics 1 and 2's focused approach on exact/best fit is likely more stable.\n*   **Heuristic 10 vs. Heuristics 1 & 2:** Heuristic 10 implements a First Fit strategy, prioritizing bins with the smallest positive remaining capacity (`1.0 / (difference + epsilon)`). This is a distinct strategy from Best Fit and doesn't explicitly handle exact fits as a special case. Heuristics 1 and 2 are generally more sophisticated.\n*   **Heuristic 11, 14, 17 vs. Heuristics 1 & 2:** These heuristics use a sigmoid function on a scaled remaining capacity. The sigmoid `1 / (1 + exp(-5 * (scaled_capacities - 0.5)))` attempts to give higher priority to bins with remaining capacity closer to the middle of the scale (0.5). They also give a priority of 1.0 to exact fits. While these are interesting, the sigmoid's specific shape and the scaling (`fitted_capacities / np.max(available_capacities)`) might be less direct than Heuristics 1 and 2's explicit Best Fit logic. Heuristics 1 and 2 are ranked higher, suggesting their approach is favored.\n*   **Heuristic 12 & 18 vs. Heuristics 1 & 2:** These heuristics also combine exact fits (1.0) with a sigmoid for other bins, using `item / remaining_capacity`. This is similar to 11/14/17 but uses a different metric for tightness. Again, Heuristics 1 and 2 are ranked above them, indicating a preference for their specific implementation.\n*   **Heuristic 13 vs. Others:** Heuristic 13 simply returns all zeros, making it the worst possible heuristic as it never selects a bin.\n*   **Heuristic 15, 19, 20 vs. Heuristics 1 & 2:** These heuristics attempt to implement First Fit (FF). They give priority to bins that can fit the item and then try to boost the priority of earlier bins. However, FF is inherently a greedy, sequential selection, not typically implemented by assigning numerical priorities to all bins and then picking the max. The approach of assigning a slightly higher score based on index is a weak simulation and less effective than true Best Fit variants like 1 and 2.\n*   **Comparing Worst:** Heuristic 13 (all zeros) is clearly the worst. Heuristics 15/19/20 (FF simulation) are also poor because they don't capture the core FF selection mechanism effectively through priorities alone. Heuristic 3, while simpler than 1/2, is a valid but less refined Best Fit.\n\n**Overall Comparison:** Heuristics 1 and 2 (being identical and ranked highest) represent a refined Best Fit strategy that explicitly prioritizes exact fits. They offer a balanced approach by giving the highest score to perfect matches and a graded score to other suitable bins based on minimizing remaining capacity. The heuristics ranked lower introduce more complex (and sometimes arbitrary) secondary criteria, use different mathematical functions (sigmoid), or attempt to simulate other strategies (FF) in a way that's less effective for priority-based selection.\n- \nHere's a redefined approach to self-reflection for designing better heuristics:\n\n*   **Keywords:** Objective alignment, iterative refinement, empirical validation, robust design.\n*   **Advice:** Focus on how your heuristic *directly* optimizes the primary objective. If a secondary criterion is needed, ensure it's a logical extension or a robust tie-breaker, not an arbitrary addition. Validate performance against diverse problem instances.\n*   **Avoid:** Relying on \"mimicking\" existing heuristics without understanding their underlying logic. Over-engineering with complex, unproven transformations or prioritizing easily quantifiable but less impactful metrics.\n*   **Explanation:** True self-reflection in heuristic design means dissecting *why* a strategy works, ensuring alignment with the core problem, and building robustness through testing, not just imitation or complexity.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}