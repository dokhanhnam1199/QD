```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Returns priority with which we want to add item to each bin using a modified Best Fit strategy.
    This version prioritizes bins that result in less remaining capacity after packing,
    while also considering bins that are a "tight fit" without being excessively so,
    aiming to leave larger capacity bins for potentially larger future items.
    """
    priorities = np.zeros_like(bins_remain_cap)
    suitable_bins_mask = bins_remain_cap >= item

    if not np.any(suitable_bins_mask):
        return priorities

    suitable_bins_remain_cap = bins_remain_cap[suitable_bins_mask]
    
    # Calculate the remaining capacity if the item is placed in each suitable bin
    remaining_capacities_after_packing = suitable_bins_remain_cap - item

    # Heuristic: Prioritize bins that leave a small, but not zero, remaining capacity.
    # This is a "gentle" best fit. We want to fill bins but not make them too small for future items.
    # We can penalize bins that would be exactly filled or have very little space left.
    # Let's assign a priority score based on the inverse of remaining capacity,
    # but with a small epsilon to avoid division by zero and to penalize bins with very little space left.

    # A small value to avoid division by zero and to give a slight preference to not-perfect fits
    epsilon = 1e-6 

    # Calculate a score that favors bins with a moderate amount of remaining capacity.
    # High score for moderate remaining capacity, lower score for very small or very large remaining capacity.
    # A Gaussian-like shape or an inverted parabola centered around a "good" residual capacity could work.
    # For simplicity, let's try an approach that favors bins with remaining capacity that is small but not zero.

    # Option 1: Prioritize bins with the smallest remaining capacity (similar to Best Fit, but we'll modify the score)
    # The issue with pure Best Fit is that it can leave very small unusable gaps.
    
    # Option 2: Prioritize bins that leave a "reasonable" amount of space.
    # A simple approach is to give higher priority to bins where remaining_capacities_after_packing is small,
    # but not extremely small (e.g., greater than a small threshold).

    # Let's try a score that is inversely proportional to the remaining capacity after packing,
    # but add a small constant to the denominator to avoid division by zero and to temper the preference for exact fits.
    # We can also add a small bonus for bins that are not "too full" (i.e., still have substantial capacity left).
    
    # Let's create a score that is higher for smaller remaining capacities, but with a penalty for very small remaining capacities.
    # For instance, we can use something like 1 / (remaining_capacity + epsilon) but this still strongly favors the smallest.

    # A better approach might be to assign priorities based on how "tight" the fit is,
    # but with a bias towards not completely filling the bin.
    # Let's consider the difference `bins_remain_cap[suitable_bins_mask] - item`.
    # We want this difference to be small, but not zero.

    # Let's define a score that is high when the remaining capacity is small but positive.
    # We can use a function like `1.0 / (remaining_capacities_after_packing + epsilon)`
    # but this still over-penalizes slight overfilling.

    # A more robust approach could be to assign a score based on the *relative* remaining capacity.
    # For example, a score that is high when `remaining_capacities_after_packing` is small.
    # Let's try a score that increases as `remaining_capacities_after_packing` decreases,
    # but tapers off for very small values.

    # Let's consider a score that penalizes bins that have very little space left after packing.
    # For example, a score that is inversely proportional to `remaining_capacities_after_packing`
    # but with a floor or a transformation that prevents extreme values.

    # Let's try a score that is higher for smaller `remaining_capacities_after_packing`,
    # but we want to avoid perfectly filled bins if possible.
    # We can use a function that penalizes small positive values less severely than zero.

    # Let's try a score that is higher for smaller `remaining_capacities_after_packing`,
    # but with a diminishing return for very small remainders.
    # A possible function could be `1.0 / (remaining_capacities_after_packing + C)` where C is a small constant.
    # Or we can use `remaining_capacities_after_packing ** alpha` where alpha is negative.

    # Let's assign a score based on how close the remaining capacity is to zero, but not negative.
    # Higher score for smaller positive remaining capacity.

    # A simple heuristic: score = 1 / (remaining_capacity_after_packing + epsilon)
    # This is essentially Best Fit.

    # Let's introduce a penalty for bins that are "too full" after packing.
    # A bin that has `remaining_capacities_after_packing` close to zero might be problematic for future small items.
    # So, we want to favor a "medium-small" remaining capacity.

    # Consider a function that is concave for positive values, peaking at some small positive value.
    # Example: `x * exp(-k*x)` or `sqrt(x)` (but we want inverse relationship).
    # So, maybe `1 / (x + small_constant)` is a good starting point.

    # Let's modify Best Fit by adding a small bonus for bins that don't get completely filled,
    # and a penalty for bins that are very close to being full.

    # Let's try to assign priorities based on the magnitude of the remaining capacity.
    # We want the remaining capacity to be small but not zero.
    # So, `remaining_capacities_after_packing` should be small.

    # Let's try a score that is higher for smaller `remaining_capacities_after_packing`.
    # We can use `np.exp(-k * remaining_capacities_after_packing)` for some `k > 0`.
    # This would give higher scores to smaller remaining capacities.

    # To avoid zero remaining capacity, we can shift the input or use `max(epsilon, remaining_capacity)`.
    # `np.exp(-k * np.maximum(epsilon, remaining_capacities_after_packing))`

    # Let's choose a value for k. A larger k means a stronger preference for tighter fits.
    # Let's try k = 1.0 as a starting point.
    k = 1.0
    scores = np.exp(-k * remaining_capacities_after_packing)

    # Now, we need to map these scores back to the original bins_remain_cap array.
    # The `suitable_bins_mask` tells us which original bins these scores correspond to.
    
    # The original `priorities` array is all zeros. We only want to set priorities for suitable bins.
    priorities[suitable_bins_mask] = scores
    
    # Normalize priorities so that the maximum priority is 1.0 (optional, but can be useful)
    if np.any(priorities > 0):
        max_priority = np.max(priorities)
        priorities = priorities / max_priority
        
    return priorities
```
