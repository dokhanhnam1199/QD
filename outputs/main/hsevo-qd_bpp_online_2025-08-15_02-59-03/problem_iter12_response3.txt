```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Returns priority with which we want to add item to each bin using a modified
    Best Fit strategy that favors bins with less remaining capacity after packing,
    but also considers the overall number of bins used.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    suitable_bins_mask = bins_remain_cap >= item

    if not np.any(suitable_bins_mask):
        return priorities

    suitable_bins_capacities = bins_remain_cap[suitable_bins_mask]
    remaining_capacities_after_packing = suitable_bins_capacities - item

    # Prioritize bins that will have minimal remaining capacity after packing (Best Fit)
    min_remaining = np.min(remaining_capacities_after_packing)
    best_fit_candidates_mask = (suitable_bins_capacities - item) == min_remaining

    # For bins that are best fits, assign a higher priority.
    # Among best fits, we could potentially add a secondary criterion,
    # for now, a uniform high priority is assigned.
    priorities[suitable_bins_mask][best_fit_candidates_mask] = 1.0

    # Introduce a slight preference for bins that are closer to being full (less capacity remaining).
    # This is to encourage tighter packing and potentially reduce the number of bins used overall.
    # We can achieve this by giving a small bonus to bins with less remaining capacity *before* packing.
    # This is a way to break ties in favor of "better" bins.
    # Normalize the remaining capacities to avoid scale issues and make the bonus relative.
    normalized_suitable_bins_capacities = (suitable_bins_capacities - item) / np.max(suitable_bins_capacities - item + 1e-9) # Add epsilon to avoid division by zero

    # A small bonus can be added for bins that are closer to being full (less capacity initially).
    # This will push the priority slightly higher for bins that are already quite full.
    # We use (1 - normalized_suitable_bins_capacities) as a proxy for "how full" the bin is after packing.
    # A small multiplier ensures this doesn't overpower the primary Best Fit criterion.
    bonus_multiplier = 0.1
    priorities[suitable_bins_mask] += bonus_multiplier * (1 - normalized_suitable_bins_capacities)


    # Ensure priorities are non-negative and capped at a reasonable value if needed.
    # For this heuristic, we've set the max to 1.0 + bonus, so clamping is useful.
    priorities = np.clip(priorities, 0, None)


    return priorities
```
