import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.000560524131707042) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    The First Fit strategy prioritizes bins that have just enough capacity
    to fit the item, aiming to leave larger remaining capacities in other bins
    for potentially larger future items.
    A higher priority score indicates a better fit.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.
        epsilon: A small value to avoid division by zero for exact fits.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap)
    
    # Bins where the item can fit
    fit_mask = bins_remain_cap >= item
    
    # Calculate the difference between remaining capacity and item size for fitting bins
    # A smaller difference means a "tighter" fit, which is preferred by First Fit.
    # We use the inverse of the difference to make it a maximization problem.
    # Add a small epsilon to avoid division by zero for exact fits.
    priorities[fit_mask] = 1.0 / (bins_remain_cap[fit_mask] - item + epsilon)
    
    # Bins where the item does not fit get a priority of 0
    # This is already handled by np.zeros_like, but explicitly for clarity in logic
    priorities[~fit_mask] = 0.0

    return priorities
