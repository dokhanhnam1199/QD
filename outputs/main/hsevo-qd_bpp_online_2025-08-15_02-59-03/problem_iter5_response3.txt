```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines the exact-fit prioritization of Heuristic 1/2 with the smooth scaling of Heuristic 11/14/17.
    Prioritizes exact fits, then uses a sigmoid on scaled remaining capacity for others.
    """
    priorities = np.zeros_like(bins_remain_cap)
    suitable_bins_mask = bins_remain_cap >= item

    if not np.any(suitable_bins_mask):
        return priorities

    suitable_bins_caps = bins_remain_cap[suitable_bins_mask]
    remaining_capacities_after_packing = suitable_bins_caps - item

    # Define a tolerance for "exact" fits
    tolerance = 1e-9

    # Highest priority for exact fits
    exact_fit_mask = np.abs(remaining_capacities_after_packing) < tolerance
    exact_fit_indices_relative = np.where(exact_fit_mask)[0]
    if exact_fit_indices_relative.size > 0:
        original_indices_exact = np.where(suitable_bins_mask)[0][exact_fit_indices_relative]
        priorities[original_indices_exact] = 1.0

    # For other suitable bins, use a sigmoid on the scaled remaining capacity
    non_exact_fit_mask = ~exact_fit_mask
    if np.any(non_exact_fit_mask):
        non_exact_bins_caps = suitable_bins_caps[non_exact_fit_mask]
        remaining_after_non_exact = non_exact_bins_caps - item

        # Scale remaining capacities to be between 0 and 1 for sigmoid input
        # Avoid division by zero if all remaining capacities are the same (and not zero)
        max_remaining = np.max(remaining_after_non_exact)
        min_remaining = np.min(remaining_after_non_exact)

        if max_remaining == min_remaining:
            scaled_remaining = np.ones_like(remaining_after_non_exact) * 0.5 # Neutral if all same
        else:
            scaled_remaining = (remaining_after_non_exact - min_remaining) / (max_remaining - min_remaining)

        # Apply sigmoid: prioritizes bins with remaining capacity closer to the average fit
        # The -0.5 shifts the sigmoid center, *5 controls steepness
        sigmoid_scores = 1 / (1 + np.exp(-5 * (scaled_remaining - 0.5)))

        original_indices_non_exact = np.where(suitable_bins_mask)[0][non_exact_fit_mask]
        
        # Assign these sigmoid scores, ensuring they don't override exact fit priority
        priorities[original_indices_non_exact] = np.maximum(priorities[original_indices_non_exact], sigmoid_scores * 0.9) # Slightly lower than exact fit

    return priorities
```
