```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Exact Fit with Best Fit and a penalty for bins that leave
    too much residual capacity, aiming for a more balanced packing strategy.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    # Identify bins that can fit the item
    suitable_bins_mask = bins_remain_cap >= item
    suitable_bins_indices = np.where(suitable_bins_mask)[0]
    
    if not suitable_bins_indices.size:
        return priorities
        
    # Calculate remaining capacity after placing the item
    remaining_after_packing = bins_remain_cap[suitable_bins_mask] - item
    
    # --- Strategy 1: Exact Fit (Highest Priority) ---
    # Prioritize bins where the item perfectly fills the remaining capacity
    exact_fit_mask_local = (remaining_after_packing == 0)
    exact_fit_indices = suitable_bins_indices[exact_fit_mask_local]
    if exact_fit_indices.size > 0:
        priorities[exact_fit_indices] = 1.0 
    
    # --- Strategy 2: Best Fit (Next Highest Priority) ---
    # Among bins that don't provide an exact fit, prioritize those that leave the least residual capacity
    non_exact_fit_suitable_indices = suitable_bins_indices[~exact_fit_mask_local]
    
    if non_exact_fit_suitable_indices.size > 0:
        non_exact_remaining_after = remaining_after_packing[~exact_fit_mask_local]
        
        # Find the minimum remaining capacity among non-exact fits
        min_remaining_non_exact = np.min(non_exact_remaining_after)
        best_fit_mask_local = (non_exact_remaining_after == min_remaining_non_exact)
        best_fit_indices = non_exact_fit_suitable_indices[best_fit_mask_local]
        
        # Assign a high priority (but less than exact fit)
        priorities[best_fit_indices] = 0.9 
        
        # --- Strategy 3: Penalty for "too empty" bins (Lower Priority) ---
        # For bins that are suitable but not an exact or best fit, assign a priority
        # that decreases as the remaining capacity increases. This discourages leaving
        # very large gaps. We can use an inverse relationship with a scaled remaining capacity.
        
        other_suitable_indices = non_exact_fit_suitable_indices[~best_fit_mask_local]
        
        if other_suitable_indices.size > 0:
            other_remaining_after = remaining_after_packing[~best_fit_mask_local]
            
            # Scale remaining capacities to a [0, 1] range for prioritization.
            # Higher remaining capacity should result in lower priority.
            min_res = np.min(other_remaining_after)
            max_res = np.max(other_remaining_after)
            
            if max_res > min_res:
                # Normalize to [0, 1], then invert and scale down to avoid overlap with Best Fit
                # A simple inverse score: 1 / (1 + scaled_remaining_capacity)
                # We want smaller remaining capacity to have higher priority here.
                scaled_remaining = (other_remaining_after - min_res) / (max_res - min_res)
                
                # Assign priority from 0.1 to 0.5, higher for smaller remaining capacity
                priorities[other_suitable_indices] = 0.1 + 0.4 * (1.0 - scaled_remaining)
            else:
                # All remaining bins have the same capacity, assign a middle priority
                priorities[other_suitable_indices] = 0.3
                
    return priorities
```
