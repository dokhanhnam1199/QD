```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Prioritizes bins that perfectly fit the item, then favors bins with the least remaining capacity.
    This combines the explicit exact-fit prioritization with the core Best Fit strategy.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    # Identify bins that can fit the item
    possible_bins_mask = bins_remain_cap >= item
    possible_bins_caps = bins_remain_cap[possible_bins_mask]
    
    if possible_bins_caps.size > 0:
        # Calculate the difference for possible bins
        fitted_diffs = possible_bins_caps - item
        
        # Assign highest priority to exact fits (difference is 0)
        exact_fit_mask = fitted_diffs == 0
        priorities[possible_bins_mask][exact_fit_mask] = 2.0 
        
        # For non-exact fits, use the inverse of the difference scaled by a small epsilon
        # to prioritize bins with smaller remaining capacity (Best Fit).
        # Add a small base score to non-exact fits so they are lower than exact fits.
        non_exact_fit_mask = ~exact_fit_mask
        
        if np.any(non_exact_fit_mask):
            # To avoid division by zero and ensure smaller differences get higher scores
            # Scale differences so that the smallest difference gets the highest score.
            # A common approach is to use 1 / (difference + epsilon) or similar.
            # We want the smallest positive difference to have the highest priority among non-exact fits.
            # Let's scale by the maximum difference to keep values in a reasonable range.
            
            non_exact_diffs = fitted_diffs[non_exact_fit_mask]
            
            # To ensure these are ranked below exact fits, let's use a scaling factor.
            # The goal is to rank bins with smaller `capacity - item` higher.
            # If max_diff is large, 1/(max_diff - diff) will be small for large diffs.
            # We want to invert this: larger diffs get lower scores.
            # Consider using a score that is inversely proportional to the remaining capacity.
            # Example: `1.0 / (diff + epsilon)` where epsilon is small.
            # To make it rank below 2.0 (exact fit), we can subtract this from a constant.
            
            # A robust way is to rank them: higher score for smaller difference.
            # Let's use max_diff - diff, so smaller differences give higher scores.
            max_diff = np.max(non_exact_diffs)
            priorities[possible_bins_mask][non_exact_fit_mask] = 1.0 + (max_diff - non_exact_diffs) / (max_diff + 1e-9)

    return priorities
```
