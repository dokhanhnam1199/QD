```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Prioritizes bins using a combination of best-fit and exact-fit strategies.
    Favors bins with minimal remaining capacity after packing, with a bonus for exact fits.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    # Identify bins that can accommodate the item
    fit_mask = bins_remain_cap >= item
    
    # Calculate the remaining capacity for fitting bins
    remaining_capacities = bins_remain_cap[fit_mask] - item
    
    # Assign high priority to exact fits (remaining capacity is zero)
    exact_fit_indices_in_subset = np.where(remaining_capacities == 0)[0]
    
    # For other fitting bins, prioritize those with smaller remaining capacity (best-fit)
    # Use inverse of remaining capacity + a small epsilon for numerical stability
    # Adding 1 to remaining_capacities ensures that exact fits get a higher base priority
    # than bins with a small positive gap.
    best_fit_priorities = 1.0 / (remaining_capacities + 1)
    
    # Combine priorities: exact fits get priority 1.0, others get their calculated best-fit priority
    priorities[fit_mask] = best_fit_priorities
    
    # Override with highest priority for exact fits
    # We use a value slightly greater than 1 to ensure exact fits are always preferred over best fits.
    if len(exact_fit_indices_in_subset) > 0:
        priorities[fit_mask][exact_fit_indices_in_subset] = 1.0 + 1e-9 
        
    return priorities
```
