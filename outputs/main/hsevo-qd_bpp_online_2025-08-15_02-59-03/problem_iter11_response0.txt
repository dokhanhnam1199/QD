```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Combines exact fit priority with a graded Best Fit approach, prioritizing tighter fits.

    This heuristic prioritizes exact fits with a high score and then uses an inverse
    of the remaining capacity after fitting for non-exact fits, favoring tighter fits.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    # Mask for bins where the item fits exactly
    exact_fit_mask = np.isclose(bins_remain_cap, item)
    priorities[exact_fit_mask] = 2.0  # Highest priority for exact fits

    # Mask for bins where the item fits, but not exactly
    fit_mask = (bins_remain_cap > item) & ~exact_fit_mask
    
    # Calculate priority for bins that fit but not exactly.
    # Score is inversely proportional to the remaining capacity after fitting (tighter fit = higher score).
    # Add epsilon to avoid division by zero for cases close to exact fit.
    difference = bins_remain_cap[fit_mask] - item
    priorities[fit_mask] = 1.0 / (difference + 1e-9)

    # Ensure exact fits retain their highest priority if they also meet the general fit condition
    priorities[exact_fit_mask] = np.maximum(priorities[exact_fit_mask], 2.0)
    
    return priorities
```
