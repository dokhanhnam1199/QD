```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Returns priority with which we want to add item to each bin.
    This version prioritizes bins that result in less remaining capacity after packing,
    favoring a tighter fit. If multiple bins offer the same minimal remaining capacity,
    it then prioritizes bins that were already more full (i.e., had less remaining capacity initially)
    as a secondary factor.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    suitable_bins_mask = bins_remain_cap >= item

    if not np.any(suitable_bins_mask):
        return priorities

    # Calculate the remaining capacity if the item is placed in each suitable bin
    potential_remaining_caps = bins_remain_cap[suitable_bins_mask] - item

    # Find the minimum remaining capacity among suitable bins
    min_potential_remaining_cap = np.min(potential_remaining_caps)

    # Identify bins that achieve this minimum remaining capacity
    best_fit_bins_mask = suitable_bins_mask & (bins_remain_cap - item == min_potential_remaining_cap)

    # For bins that achieve the best fit, assign a higher priority
    # Use the inverse of the original remaining capacity as a secondary sorting key
    # This prioritizes bins that were already more full (less remaining capacity initially)
    priorities[best_fit_bins_mask] = 1.0 / (bins_remain_cap[best_fit_bins_mask] + 1e-9) # Add epsilon to avoid division by zero

    # Normalize priorities to ensure they are within a reasonable range and can be compared
    if np.any(priorities > 0):
        priorities = priorities / np.max(priorities)

    return priorities
```
