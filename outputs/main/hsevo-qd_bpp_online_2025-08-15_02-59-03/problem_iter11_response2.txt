```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Prioritizes bins by combining a strong preference for exact fits with a
    scaled preference for bins that leave minimal remaining capacity among suitable options.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    suitable_bins_mask = bins_remain_cap >= item

    if not np.any(suitable_bins_mask):
        return priorities

    suitable_bins_remain_cap = bins_remain_cap[suitable_bins_mask]
    remaining_after_packing = suitable_bins_remain_cap - item

    # Strong priority for exact fits (Best Fit Perfect)
    exact_fit_mask = remaining_after_packing == 0
    priorities[suitable_bins_mask][exact_fit_mask] = 2.0

    # Scaled priority for other suitable bins (Best Fit Graded)
    # Prioritize bins that leave the least remaining capacity among non-exact fits.
    # Scale these to be less than the perfect fit priority.
    non_exact_suitable_mask = suitable_bins_mask & ~exact_fit_mask
    if np.any(non_exact_suitable_mask):
        non_exact_remaining = remaining_after_packing[~exact_fit_mask]

        if non_exact_remaining.size > 0:
            min_rem = np.min(non_exact_remaining)
            max_rem = np.max(non_exact_remaining)

            # Scale remaining capacities to a range below 2.0, prioritizing smaller remaining capacity.
            # Map the smallest remaining capacity to a high value (e.g., 1.5)
            # and the largest to a lower value (e.g., 0.5).
            if max_rem == min_rem:
                scaled_priorities = np.full_like(non_exact_remaining, 1.5)
            else:
                scaled_priorities = 1.5 - 1.0 * (non_exact_remaining - min_rem) / (max_rem - min_rem)

            priorities[suitable_bins_mask][~exact_fit_mask] = scaled_priorities

    return priorities
```
