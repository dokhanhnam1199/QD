```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines exact fit prioritization with a scaled inverse of remaining capacity.
    Prioritizes bins that perfectly fit the item. For other bins, it prioritizes
    those with less remaining capacity, using an inverse relationship.
    This aims to fill bins as tightly as possible, preferring exact fits.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    # Find bins that can fit the item
    can_fit_mask = bins_remain_cap >= item
    
    # Calculate remaining capacity for bins that can fit
    remaining_caps_for_fit = bins_remain_cap[can_fit_mask]
    
    # Calculate the difference for bins that can fit
    diffs = remaining_caps_for_fit - item
    
    # Assign priorities:
    # Highest priority for exact fits (difference is 0)
    # For non-exact fits, use inverse of difference (smaller difference = higher priority)
    # Add a small epsilon to avoid division by zero if exact fit logic fails
    
    # Calculate base priorities for bins that can fit
    base_priorities = np.zeros_like(remaining_caps_for_fit, dtype=float)
    
    # Prioritize exact fits
    exact_fit_mask = (diffs == 0)
    base_priorities[exact_fit_mask] = 2.0  # High priority for exact fits
    
    # Prioritize bins with smallest remaining capacity among non-exact fits
    non_exact_fit_mask = ~exact_fit_mask
    if np.any(non_exact_fit_mask):
        # Use inverse of difference, scale it to avoid extremely large numbers
        # Add epsilon for numerical stability and to differentiate from exact fits
        priorities_for_non_exact = 1.0 / (diffs[non_exact_fit_mask] + 1e-9)
        # Scale these priorities to be less than the exact fit priority
        # A simple scaling could be to divide by the max of these non-exact priorities
        max_non_exact_priority = np.max(priorities_for_non_exact)
        if max_non_exact_priority > 0:
            scaled_priorities = 1.0 + 0.5 * (priorities_for_non_exact / max_non_exact_priority)
            base_priorities[non_exact_fit_mask] = scaled_priorities
        else: # If all remaining are exact fits, this branch won't be hit but for completeness
             base_priorities[non_exact_fit_mask] = 1.0

    # Assign these calculated priorities back to the original priorities array
    priorities[can_fit_mask] = base_priorities
    
    return priorities
```
