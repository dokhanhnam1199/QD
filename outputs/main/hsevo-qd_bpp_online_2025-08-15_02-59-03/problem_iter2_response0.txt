```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best Fit (minimizing remaining capacity) with an Exact Fit bonus.
    Prioritizes bins with the smallest positive residual capacity,
    and gives an additional boost to bins with an exact fit.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    # Identify bins where the item can fit
    fit_mask = bins_remain_cap >= item
    
    # Calculate residual capacity for fitting bins
    residual_capacities = bins_remain_cap[fit_mask] - item
    
    # Handle exact fits separately for a bonus
    exact_fit_mask = residual_capacities == 0
    
    # For bins with an exact fit, assign a high priority
    priorities[fit_mask][exact_fit_mask] = 1.0
    
    # For bins with a residual capacity (not exact fit), assign priority based on the inverse of residual capacity
    # This favors bins with smaller residuals (Best Fit)
    non_exact_fit_mask = ~exact_fit_mask
    if np.any(fit_mask[fit_mask] & non_exact_fit_mask):
        non_exact_residuals = residual_capacities[non_exact_fit_mask]
        # Use a small epsilon to avoid division by zero for very close fits
        priorities[fit_mask][non_exact_fit_mask] = 1.0 / (non_exact_residuals + 1e-9)
        
        # Normalize the non-exact fit priorities so they don't overshadow exact fits
        max_non_exact_priority = np.max(priorities[fit_mask][non_exact_fit_mask])
        if max_non_exact_priority > 0:
            priorities[fit_mask][non_exact_fit_mask] /= max_non_exact_priority
        
    # Bins where the item does not fit have a priority of 0, which is the default.
    
    return priorities
```
