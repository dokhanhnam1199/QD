{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code only and do not add comments into the code. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Returns priority with which we want to add item to each bin using a modified Best Fit strategy.\n    This version prioritizes bins that have just enough space for the item, and among those,\n    prefers bins that will have the least remaining capacity after packing.\n    It also introduces a slight preference for bins that have been used less (i.e., higher remaining capacity)\n    if no \"perfect fit\" is found, to encourage better space utilization over time.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    suitable_bins_mask = bins_remain_cap >= item\n\n    if not np.any(suitable_bins_mask):\n        return priorities\n\n    suitable_bins_caps = bins_remain_cap[suitable_bins_mask]\n    remaining_capacities_after_packing = suitable_bins_caps - item\n\n    # Identify bins that are a \"perfect fit\" or very close\n    # A small tolerance is introduced to capture bins that are \"almost\" a perfect fit\n    tolerance = 1e-6\n    perfect_fit_mask = np.abs(remaining_capacities_after_packing) < tolerance\n\n    if np.any(perfect_fit_mask):\n        # Among perfect fits, prefer those with the absolute minimum remaining capacity (which is close to zero)\n        # This is essentially Best Fit for perfect fits.\n        min_remaining_cap_among_perfect = np.min(remaining_capacities_after_packing[perfect_fit_mask])\n        best_fit_perfect_mask = (suitable_bins_caps - item == min_remaining_cap_among_perfect)\n\n        # Map back to original indices\n        original_indices_perfect = np.where(suitable_bins_mask)[0][best_fit_perfect_mask]\n        priorities[original_indices_perfect] = 2.0 # Highest priority\n\n    else:\n        # If no perfect fit, fall back to a modified Best Fit strategy.\n        # Prioritize bins that leave the least remaining capacity, but not too much.\n        # We'll give a higher score to bins that have a small remaining capacity after packing,\n        # but not so small that it's completely unusable for future small items.\n        # The score is inversely related to the remaining capacity after packing.\n        # To avoid extreme values, we use a scaled inverse.\n        min_remaining_cap_overall = np.min(remaining_capacities_after_packing)\n        \n        # Assign scores based on how close the remaining capacity is to the minimum\n        # Higher score for bins that are closer to the minimum remaining capacity\n        scores_for_suitable = 1.0 / (1.0 + remaining_capacities_after_packing - min_remaining_cap_overall)\n        \n        # Normalize scores to be between 0 and 1\n        max_score = np.max(scores_for_suitable)\n        min_score = np.min(scores_for_suitable)\n        if max_score > min_score:\n            normalized_scores = (scores_for_suitable - min_score) / (max_score - min_score)\n        else:\n            normalized_scores = np.ones_like(scores_for_suitable) * 0.5 # Assign a neutral score if all are equal\n\n        # Map back to original indices\n        original_indices_suitable = np.where(suitable_bins_mask)[0]\n        priorities[original_indices_suitable] = normalized_scores\n        \n        # Ensure perfect fits (if any were missed by tolerance) still get top priority\n        if np.any(np.abs(remaining_capacities_after_packing) < tolerance):\n            min_remaining_cap_close_to_zero = np.min(remaining_capacities_after_packing[np.abs(remaining_capacities_after_packing) < tolerance])\n            best_fit_close_mask = (suitable_bins_caps - item == min_remaining_cap_close_to_zero)\n            original_indices_close = np.where(suitable_bins_mask)[0][best_fit_close_mask]\n            priorities[original_indices_close] = np.maximum(priorities[original_indices_close], 1.5) # Boost priority\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    The First Fit strategy prioritizes bins that have just enough capacity\n    to fit the item, aiming to leave larger remaining capacities in other bins\n    for potentially larger future items.\n    A higher priority score indicates a better fit.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    # Bins where the item can fit\n    fit_mask = bins_remain_cap >= item\n    \n    # Calculate the difference between remaining capacity and item size for fitting bins\n    # A smaller difference means a \"tighter\" fit, which is preferred by First Fit.\n    # We use the inverse of the difference to make it a maximization problem.\n    # Add a small epsilon to avoid division by zero for exact fits.\n    priorities[fit_mask] = 1.0 / (bins_remain_cap[fit_mask] - item + 1e-9)\n    \n    # Bins where the item does not fit get a priority of 0\n    # This is already handled by np.zeros_like, but explicitly for clarity in logic\n    priorities[~fit_mask] = 0.0\n\n    return priorities\n\n### Analyze & experience\n- Comparing Heuristic 1 (Exact fit + graded Best Fit) vs. Heuristic 10 (Basic inverse of remaining capacity without handling exact fits or suitability): Heuristic 1 is superior due to its explicit handling of exact fits and its more nuanced scoring for non-exact fits, leading to more predictable and often better packing.\n\nComparing Heuristic 1 vs. Heuristic 12 (Simple inverse of remaining capacity for fitting bins): Heuristic 1's explicit high priority for exact fits (score 2.0) and graded scoring for non-exact fits (1.0 / diff) provides a more robust \"Best Fit\" approach than Heuristic 12's simple inverse, which might not distinguish between exact fits and other close fits as effectively.\n\nComparing Heuristic 2 (Modified Best Fit with perfect fit prioritization) vs. Heuristic 11 (Balanced Fit, prioritizing moderate remaining capacity): Heuristic 2's explicit prioritization of perfect fits (score 2.0) and then a graded \"least remaining capacity\" for others is a clear hierarchy. Heuristic 11's approach of peaking at a moderate remaining capacity (using `r * exp(-k*r)`) is a different strategy that might perform better in some scenarios by avoiding overly full bins, but lacks the clear initial preference for exact fits that Heuristic 2 provides.\n\nComparing Heuristic 18/19 (Exact fit + scaled Best Fit) vs. Heuristic 1 (Exact fit + graded Best Fit): Heuristics 18/19 use a scaled inverse of the difference for non-exact fits, normalized to a range below the exact fit priority. Heuristic 1 uses a simpler inverse. Heuristics 18/19 offer a more controlled prioritization for non-exact fits, ensuring they are clearly secondary to exact fits.\n\nComparing Heuristic 16 (First Fit simulation) vs. Heuristic 20 (First Fit simulation with minor index bias): Both are attempts to mimic First Fit (FF). Heuristic 16 and 20 assign a high priority to the *first* bin that fits. The minor bias in Heuristic 20 is an artificial way to favor earlier bins, which is inherent in FF's sequential nature. However, a true FF implementation typically involves sequential iteration, not just scoring. These are less sophisticated than \"Best Fit\" variations.\n\nOverall: Heuristics that explicitly prioritize exact fits and then use a graded approach for \"Best Fit\" (like 1, 18, 19) or combine exact fits with a well-defined secondary strategy (like 2, 9) tend to be better. Simple \"Best Fit\" (12, 13) or variations that aim for moderate fill (11, 14, 15) are also reasonable. Heuristics simulating First Fit (16, 20) or basic inverse scoring without refinement (10) are generally less robust.\n- \nHere's a redefinition of self-reflection for designing better heuristics:\n\n*   **Keywords:** Objective-driven, measurable improvement, adaptive strategies, principled design.\n*   **Advice:** Focus on *why* a strategy works. Does it directly address a quantifiable objective (e.g., minimizing waste)? Explore how to *adapt* to different problem characteristics, rather than just mimicking existing ones.\n*   **Avoid:** Overly complex, arbitrary mathematical functions (like `r * exp(-k*r)`) without a clear theoretical or empirical justification for their specific form. Avoid \"simulating\" known heuristics if a more direct, objective-driven approach is possible.\n*   **Explanation:** The goal is to build heuristics that are understood through their objective alignment and demonstrable performance improvements, not through the intricacy of their mathematical formulation or a blind imitation of prior methods.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}