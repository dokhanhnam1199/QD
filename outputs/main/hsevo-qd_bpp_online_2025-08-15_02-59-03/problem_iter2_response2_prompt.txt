{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code only and do not add comments into the code. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Calculates priorities for placing an item into bins using a Softmax-Based Fit strategy.\n\n    The priority is higher for bins that have a remaining capacity greater than or equal to the item's size,\n    and among those, bins that have less remaining capacity (tighter fit) are preferred.\n    A small penalty is added to bins that cannot accommodate the item to ensure they receive a non-zero\n    but still lower priority.\n\n    Args:\n        item: The size of the item to be packed.\n        bins_remain_cap: A numpy array representing the remaining capacity of each bin.\n\n    Returns:\n        A numpy array of the same size as bins_remain_cap, where each element represents\n        the priority score for placing the item into the corresponding bin.\n    \"\"\"\n    suitable_bins_mask = bins_remain_cap >= item\n    unsuitable_bins_mask = ~suitable_bins_mask\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    if np.any(suitable_bins_mask):\n        suitable_capacities = bins_remain_cap[suitable_bins_mask]\n        \n        inverted_capacities = 1.0 / (suitable_capacities - item + 1e-9)\n        \n        max_inverted_capacity = np.max(inverted_capacities)\n        \n        normalized_priorities = inverted_capacities / max_inverted_capacity\n        \n        priorities[suitable_bins_mask] = normalized_priorities\n\n    if np.any(unsuitable_bins_mask):\n        priorities[unsuitable_bins_mask] = 1e-6\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    possible_bins = bins_remain_cap >= item\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    available_capacities = bins_remain_cap[possible_bins]\n    \n    if available_capacities.size > 0:\n        \n        fitted_capacities = available_capacities - item\n        \n        \n        scaled_capacities = fitted_capacities / np.max(available_capacities)\n        \n        \n        priorities[possible_bins] = 1 / (1 + np.exp(-5 * (scaled_capacities - 0.5)))\n        \n        \n        if np.any(fitted_capacities == 0):\n            priorities[possible_bins][fitted_capacities == 0] = 1.0\n            \n    return priorities\n\n### Analyze & experience\n- *   **Comparing (1st) vs (2nd/4th/9th):** Heuristic 1st implements a strategy where it prioritizes bins with the smallest positive difference between remaining capacity and item size (closest fit). It achieves this by calculating `capacity - item`, finding the minimum positive difference, and then transforming priorities. Heuristics 2nd, 4th, and 9th calculate priority as `1.0 / (remaining_capacity - item + epsilon)`, which also favors tighter fits. However, 1st's explicit handling of the minimum positive difference and transformation is slightly more robust in creating distinct priorities. The use of `-np.inf` for unsuitable bins in 1st is a clear way to exclude them.\n\n*   **Comparing (2nd/4th/9th) vs (11th/12th/13th/14th):** Heuristics 11th through 14th use `1.0 / (bins_remain_cap[fit_mask] - item + 1e-9)`, which is identical to 2nd, 4th, and 9th. The docstrings in 11th-14th mention \"First Fit strategy,\" but the code itself implements a \"Best Fit\" or \"Tight Fit\" by prioritizing the smallest positive gap. This discrepancy makes them functionally similar to the Best Fit-like heuristics.\n\n*   **Comparing (3rd) vs (8th):** Heuristic 3rd implements a \"Softmax-Based Fit\" where it normalizes priorities for suitable bins based on `1.0 / (suitable_capacities - item + 1e-9)` divided by the max of these values. It also assigns a small penalty to unsuitable bins. Heuristic 8th attempts a \"Sigmoid Fit Score\" using `1 / (1 + np.exp(-k * (item / (fitting_bins_remain_cap + epsilon) - 1)))`, aiming to prioritize tighter fits. Heuristic 3rd's approach of normalizing by the maximum suitable priority is a more direct way to achieve relative prioritization among suitable bins, while 8th's sigmoid function might be more complex to tune and interpret. The explicit handling of unsuitable bins in 3rd (assigning `1e-6`) is also clearer than the implicit handling in 8th (where the sigmoid might not perform as intended for non-fitting bins if not masked).\n\n*   **Comparing (5th/7th) vs (6th):** Heuristics 5th and 7th are identical and implement a \"Best Fit\" strategy by setting priority to 1.0 for bins that achieve the minimum `remaining_capacity - item` among suitable bins. Heuristic 6th implements an \"Exact Fit First\" strategy: it gives priority 1.0 to exact fits and then falls back to Best Fit if no exact fit exists. Heuristic 6th is more sophisticated as it explicitly handles the \"exact fit\" condition, which is often a desirable outcome, before resorting to a \"best fit.\"\n\n*   **Comparing (15th/16th) vs others:** Heuristics 15th and 16th are identical and use a sigmoid function `1 / (1 + np.exp(-5 * (scaled_capacities - 0.5)))` on scaled differences, with a special case for exact fits (`priorities = 1.0`). The scaling is done by dividing `fitted_capacities` by `np.max(available_capacities)`. This approach is less intuitive for prioritization compared to direct gap minimization or inverse gap. The peak of the sigmoid is at `scaled_capacities = 0.5`, meaning bins where the remaining capacity is half of the maximum available capacity among suitable bins would get the highest score, which isn't a standard \"fit\" heuristic. The explicit setting of 1.0 for exact fits is good, but the general sigmoid logic is less clear.\n\n*   **Comparing (17th/20th) vs (18th/19th):** Heuristics 17th and 20th (identical) attempt to mimic \"First Fit\" by marking the *first* bin that fits with a slightly higher priority. Heuristics 18th and 19th (identical) return all zeros, making them the worst as they provide no prioritization. The approach in 17th/20th is a reasonable interpretation of how to represent \"First Fit\" within a priority score framework, although it's not a direct implementation of the sequential search.\n\n*   **Overall:** The best heuristics (1st, 5th, 6th, 7th, 11th-14th, 3rd, 8th) focus on \"tightest fit\" or \"best fit,\" prioritizing bins where the remaining capacity is just enough or slightly more than the item. Heuristic 6th is superior for explicitly handling exact fits first. Heuristics 17th/20th attempt to capture \"First Fit\" logic, which is a different strategy. Heuristics 15th/16th have a less standard sigmoid application. Heuristics 18th/19th are completely non-functional. The slight variations in implementing \"tightest fit\" (e.g., inverse of gap vs. negative gap, normalization) lead to minor ranking differences.\n- \nHere's a redefined approach to self-reflection for designing better heuristics:\n\n*   **Keywords:** Objective Alignment, Robustness, Simplicity, Empirical Validation.\n*   **Advice:** Focus on how your heuristic directly addresses the *specific objective* (e.g., minimizing wasted space, maximizing item packing). Build in mechanisms to gracefully handle boundary conditions and data irregularities.\n*   **Avoid:** Over-engineering with complex, unjustified mathematical transformations or blindly copying existing heuristics without understanding their underlying rationale in your context.\n*   **Explanation:** True self-reflection means ensuring your heuristic's design choices are *purposeful*, testable, and contribute directly to solving the problem, rather than adding unnecessary complexity or relying on unverified assumptions.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}