```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Returns priority with which we want to add item to each bin.
    This heuristic aims to improve upon Best Fit by considering the 'tightness'
    of the fit and penalizing bins that would become too empty after packing.
    """
    priorities = np.zeros_like(bins_remain_cap)
    suitable_bins_mask = bins_remain_cap >= item

    if not np.any(suitable_bins_mask):
        return priorities

    suitable_bins_remain_cap = bins_remain_cap[suitable_bins_mask]
    
    # Calculate remaining capacity after placing the item
    remaining_after_placement = suitable_bins_remain_cap - item

    # Priority 1: Prefer bins that result in the smallest remaining capacity (Best Fit)
    # This is the core Best Fit logic
    min_remaining = np.min(remaining_after_placement)
    best_fit_mask_indices = np.where(remaining_after_placement == min_remaining)[0]
    
    # Assign a base priority to best-fit bins
    priorities[suitable_bins_mask][best_fit_mask_indices] = 1.0

    # Priority 2: Among best-fit bins, prefer those that are not "too empty" after packing.
    # We define "too empty" as having a remaining capacity greater than some threshold,
    # or a significant portion of the bin's original capacity remaining.
    # Let's use a simple rule: if a bin is still more than half full *after* packing,
    # we give it a slight boost. This avoids leaving bins with a lot of wasted space.
    
    # Find the indices within the *suitable* bins that meet the second criterion
    # We look at bins that are currently best fit
    current_best_fit_remain_cap = suitable_bins_remain_cap[best_fit_mask_indices]
    
    # Get original capacities for these best-fit bins (this requires accessing original bins_remain_cap)
    # To do this properly, we need the indices of the suitable bins themselves.
    suitable_bin_indices = np.where(suitable_bins_mask)[0]
    original_suitable_bins_cap = bins_remain_cap[suitable_bin_indices]
    
    # Now get original capacities for the *currently best-fit* bins
    original_best_fit_cap = original_suitable_bins_cap[best_fit_mask_indices]
    
    # Calculate remaining capacity after placement for these best-fit bins
    remaining_after_placement_best_fit = current_best_fit_remain_cap - item
    
    # Apply the "not too empty" boost: if remaining capacity is more than half of original bin capacity
    # Or, more simply, if the remaining capacity is not excessively large compared to the item itself.
    # A simple way is to penalize bins that become very empty.
    # Let's define a penalty: bins that after packing have a remaining capacity > 0.75 * original_capacity
    # are considered less desirable than those with remaining capacity <= 0.75 * original_capacity
    
    # To avoid over-complication with arbitrary thresholds, let's refine the "tightness" idea.
    # Best Fit is about minimizing `original_capacity - item`.
    # We can add a secondary criterion that prefers bins where `remaining_after_placement`
    # is closer to zero, but not so close that it's a perfect fit (which might be rare).
    # Or, we can penalize bins that leave *a lot* of space.
    
    # Let's try a simpler approach: Maximize the *utilization* of the bin *after* packing.
    # Utilization = (original_capacity - remaining_after_placement) / original_capacity
    # Higher utilization is better.
    
    # For bins that are already best fit, we can boost those with higher post-packing utilization.
    
    post_packing_utilization = (original_best_fit_cap - remaining_after_placement) / original_best_fit_cap
    
    # Find the maximum utilization among the best-fit bins
    max_utilization = np.max(post_packing_utilization)
    
    # Boost bins that achieve this maximum utilization among best-fit bins
    high_utilization_best_fit_mask_indices = np.where(post_packing_utilization == max_utilization)[0]
    
    # Add a small bonus to these bins
    priorities[suitable_bins_mask][best_fit_mask_indices[high_utilization_best_fit_mask_indices]] += 0.1

    # Normalize priorities to avoid extremely large values if needed, but for simple selection,
    # the relative order is what matters.
    
    return priorities

```
