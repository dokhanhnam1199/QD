```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Exact Fit First with a scaled penalty for unsuitable bins.
    Prioritizes exact fits, then bins with minimal remaining capacity,
    and penalizes bins that cannot fit the item.
    """
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Identify bins that can fit the item
    fit_mask = bins_remain_cap >= item

    # Prioritize exact fits with the highest score
    exact_fit_mask = fit_mask & (bins_remain_cap == item)
    priorities[exact_fit_mask] = 2.0

    # For bins that can fit but are not exact fits, assign priorities based on Best Fit
    # Higher priority for smaller remaining capacity (tighter fit)
    non_exact_fit_mask = fit_mask & ~exact_fit_mask
    if np.any(non_exact_fit_mask):
        fitting_capacities = bins_remain_cap[non_exact_fit_mask]
        gaps = fitting_capacities - item
        
        # Scale priorities: 1.0 for the tightest fit, decreasing for larger gaps.
        # Add a small base score (e.g., 0.5) to ensure they are less prioritized than exact fits,
        # but still prioritized over unsuitable bins.
        min_gap = np.min(gaps)
        max_gap = np.max(gaps)
        
        # Normalize gaps to be between 0 and 1, then invert for priority (smaller gap = higher priority)
        # The formula `1 - (gap - min_gap) / (max_gap - min_gap + epsilon)` gives priority of 1 for min_gap
        # and close to 0 for max_gap. We scale this and add a base.
        epsilon = 1e-9
        normalized_priority = (max_gap - gaps) / (max_gap - min_gap + epsilon)
        priorities[non_exact_fit_mask] = 0.5 + 0.5 * normalized_priority # Scale to 0.5 - 1.0

    # Bins that cannot fit the item already have -np.inf, effectively making them least preferred.
    
    return priorities
```
