```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Returns priority with which we want to add item to each bin using a modified Best Fit strategy
    that also considers the initial size of the bin.
    Bins that are almost full but can still accommodate the item are prioritized slightly higher
    than bins that have a lot of remaining space, to encourage tighter packing.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    # Mask for bins that can accommodate the item
    suitable_bins_mask = bins_remain_cap >= item

    if not np.any(suitable_bins_mask):
        return priorities  # No bin can fit the item

    # Calculate remaining capacities for suitable bins
    remaining_capacities_after_fit = bins_remain_cap[suitable_bins_mask] - item

    # Find the minimum remaining capacity among suitable bins (this is the Best Fit criterion)
    min_remaining_capacity = np.min(remaining_capacities_after_fit)

    # Identify bins that achieve the minimum remaining capacity
    best_fit_bins_mask = suitable_bins_mask.copy()
    best_fit_bins_mask[suitable_bins_mask] = (remaining_capacities_after_fit == min_remaining_capacity)

    # Assign a base priority of 1.0 to best-fit bins
    priorities[best_fit_bins_mask] = 1.0

    # Introduce a secondary consideration: prefer bins that are already "closer" to full.
    # This is to avoid leaving many small gaps in bins that are mostly empty.
    # We can achieve this by giving a slight boost to bins that have less remaining capacity *before* the item is added,
    # among those that can fit the item.

    # Get remaining capacities of all suitable bins
    suitable_bins_remaining_cap = bins_remain_cap[suitable_bins_mask]

    # Calculate a "fill ratio" - how full the bin is before adding the item. Higher is better.
    # Add a small epsilon to avoid division by zero if a bin had 0 initial capacity (though unlikely in BPP)
    epsilon = 1e-9
    initial_bin_capacity_for_suitable_bins = suitable_bins_remaining_cap + item
    fill_ratios = (initial_bin_capacity_for_suitable_bins - suitable_bins_remaining_cap) / (initial_bin_capacity_for_suitable_bins + epsilon)

    # Scale these fill ratios to create a secondary priority boost.
    # We want to slightly prefer fuller bins. A simple scaling could be based on the maximum fill ratio.
    # A small additive boost is generally safer than multiplicative to avoid huge numbers.
    # Let's try a small positive boost for bins that are "more filled" than the average.
    
    # Calculate a threshold based on the mean fill ratio of suitable bins
    mean_fill_ratio = np.mean(fill_ratios)
    
    # Apply a smaller boost to bins that are more filled than the average,
    # but only if they are not already a "best fit" bin (to avoid double counting the primary priority).
    # The boost should be less than the primary priority (1.0).
    secondary_boost_amount = 0.1

    # For bins that are suitable but *not* best-fit, and are more filled than average, give a small boost.
    non_best_fit_suitable_mask = suitable_bins_mask.copy()
    non_best_fit_suitable_mask[suitable_bins_mask] = ~best_fit_bins_mask[suitable_bins_mask]
    
    combined_mask_for_boost = non_best_fit_suitable_mask & suitable_bins_mask
    
    if np.any(combined_mask_for_boost):
        # Filter fill ratios for these bins
        fill_ratios_for_boost = fill_ratios[np.isin(np.where(suitable_bins_mask)[0], np.where(combined_mask_for_boost)[0])]
        
        # Apply boost to those with fill ratio > mean fill ratio
        boost_condition_mask = fill_ratios_for_boost > mean_fill_ratio
        
        if np.any(boost_condition_mask):
            # Get the indices in the original bins_remain_cap array
            indices_to_boost = np.where(suitable_bins_mask)[0][np.isin(np.where(suitable_bins_mask)[0], np.where(combined_mask_for_boost)[0])][boost_condition_mask]
            priorities[indices_to_boost] += secondary_boost_amount

    # Ensure best-fit bins still have the highest priority (1.0)
    # If a best-fit bin also qualified for the secondary boost, its priority will be 1.0 + 0.1,
    # which might be undesireable if we want best-fit to be strictly highest.
    # Let's refine this: Best Fit gets 1.0. Other suitable bins get a smaller priority
    # based on how "full" they are.

    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    suitable_bins_mask = bins_remain_cap >= item

    if not np.any(suitable_bins_mask):
        return priorities

    remaining_capacities_after_fit = bins_remain_cap[suitable_bins_mask] - item
    min_remaining_capacity = np.min(remaining_capacities_after_fit)

    # Assign priority based on how close they are to best-fit, and then by fill ratio.
    # The highest priority will be for best-fit bins.
    # For non-best-fit bins, priority will be lower and based on their fill level.

    # Calculate a "closeness" to best-fit metric for all suitable bins.
    # Lower remaining capacity after fit is better (closer to best-fit).
    # We can normalize this.
    
    # Normalize remaining capacities to a [0, 1] range, where 0 is best.
    # Avoid division by zero if all suitable bins have the same remaining capacity.
    if np.all(remaining_capacities_after_fit == min_remaining_capacity):
        closeness_to_best_fit = np.zeros_like(remaining_capacities_after_fit)
    else:
        max_remaining_capacity_after_fit = np.max(remaining_capacities_after_fit)
        closeness_to_best_fit = (remaining_capacities_after_fit - min_remaining_capacity) / (max_remaining_capacity_after_fit - min_remaining_capacity + epsilon)

    # Now, use fill ratio for secondary sorting among bins with similar "closeness to best-fit".
    # Or, combine them. A simple way is to prioritize Best Fit (closeness = 0) with a high score,
    # and then use fill ratio for others.

    # Let's assign priorities:
    # Best-fit bins get a high priority (e.g., 1.0)
    # Other suitable bins get a priority based on their fill ratio, scaled down.
    
    # Priority for best-fit bins
    best_fit_bins_mask_final = suitable_bins_mask.copy()
    best_fit_bins_mask_final[suitable_bins_mask] = (remaining_capacities_after_fit == min_remaining_capacity)
    priorities[best_fit_bins_mask_final] = 1.0
    
    # Priority for non-best-fit suitable bins
    non_best_fit_suitable_mask_final = suitable_bins_mask.copy()
    non_best_fit_suitable_mask_final[suitable_bins_mask] = ~best_fit_bins_mask_final[suitable_bins_mask]
    
    # Calculate fill ratios for these bins again
    suitable_bins_remaining_cap_non_bf = bins_remain_cap[non_best_fit_suitable_mask_final]
    initial_bin_capacity_for_suitable_bins_non_bf = suitable_bins_remaining_cap_non_bf + item
    fill_ratios_non_bf = (initial_bin_capacity_for_suitable_bins_non_bf - suitable_bins_remaining_cap_non_bf) / (initial_bin_capacity_for_suitable_bins_non_bf + epsilon)

    # Scale these fill ratios to a lower range, e.g., [0.1, 0.5]
    # This ensures they are less prioritized than best-fit bins (1.0).
    if np.any(non_best_fit_suitable_mask_final):
        if np.all(fill_ratios_non_bf == fill_ratios_non_bf[0]): # Handle case where all fill ratios are same
             scaled_priorities = 0.3 # Assign a mid-range priority
        else:
            min_fill_ratio = np.min(fill_ratios_non_bf)
            max_fill_ratio = np.max(fill_ratios_non_bf)
            # Scale fill ratios from [min_fill_ratio, max_fill_ratio] to [0.1, 0.5]
            scaled_priorities = 0.1 + 0.4 * (fill_ratios_non_bf - min_fill_ratio) / (max_fill_ratio - min_fill_ratio + epsilon)
        
        priorities[non_best_fit_suitable_mask_final] = scaled_priorities

    return priorities
```
