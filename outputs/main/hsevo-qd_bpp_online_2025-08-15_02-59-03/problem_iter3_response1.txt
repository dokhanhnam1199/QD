```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Returns priority with which we want to add item to each bin using a hybrid strategy:
    Prioritize bins that are a "tight fit" (minimizing waste), but also consider
    bins that have a moderate amount of remaining capacity to potentially accommodate
    future larger items or to avoid creating many small, unusable spaces.
    """
    priorities = np.zeros_like(bins_remain_cap)
    suitable_bins_mask = bins_remain_cap >= item

    if not np.any(suitable_bins_mask):
        return priorities

    suitable_bins_capacities = bins_remain_cap[suitable_bins_mask]

    # Strategy 1: Tight fit (Best Fit)
    # Calculate remaining capacity if item is placed
    remaining_after_fit = suitable_bins_capacities - item
    min_remaining = np.min(remaining_after_fit)
    tight_fit_mask_local = (suitable_bins_capacities - item) == min_remaining

    # Strategy 2: Moderate capacity (to potentially fit larger items later)
    # This is a bit heuristic, let's consider bins that have capacity
    # roughly between the item size and the bin capacity, avoiding extreme
    # both very full and very empty bins for this secondary score.
    # We can normalize remaining capacities and assign a score.
    # Let's define a "good enough" fit as having remaining capacity that is
    # not too small (but not necessarily the absolute smallest) and not too large.
    # A simple approach is to give higher priority to bins with remaining capacity
    # that is closer to the item size, but not exactly the tightest fit.

    # Calculate a "wastefulness" score for each suitable bin. Lower is better.
    # We want to minimize (bin_capacity - item).
    waste_score = suitable_bins_capacities - item

    # Normalize waste score to be between 0 and 1 (where 0 is best).
    # Avoid division by zero if all suitable bins have exactly item size capacity.
    if np.max(waste_score) > 0:
        normalized_waste_score = waste_score / np.max(waste_score)
    else:
        normalized_waste_score = np.zeros_like(waste_score)

    # Create a composite score: prioritize tight fits, but give some boost
    # to bins that are not excessively empty.
    # We can use a function that gives higher values to smaller waste.
    # For example, 1 / (1 + waste_score) or exp(-waste_score).
    # Let's try a simpler approach: a weighted sum.
    # High score for tightest fits, moderate score for other suitable bins.

    # Assign a base score to all suitable bins.
    base_priority = 0.1 # Small baseline for being suitable

    # Boost the tightest fits.
    priorities[suitable_bins_mask][tight_fit_mask_local] = 1.0

    # For other suitable bins, assign a priority based on how much space is left.
    # We want to prefer bins that leave less space, but not *too* little (which is the tight fit).
    # A score that increases as remaining capacity decreases, but capped.
    # Let's assign a score that is inversely proportional to the remaining capacity AFTER packing.
    # We'll scale this to avoid overpowering the 'best fit' score.
    other_suitable_indices = np.where(suitable_bins_mask)[0][~tight_fit_mask_local]
    if other_suitable_indices.size > 0:
        other_capacities = bins_remain_cap[other_suitable_indices] - item
        # Assign priority based on inverse of remaining capacity (smaller remaining is better)
        # Add a small epsilon to avoid division by zero if a bin is perfectly filled
        inverse_capacity_score = 1.0 / (other_capacities + 1e-6)
        # Normalize this score so it doesn't dominate the '1.0' from tight fit
        max_inverse_score = np.max(inverse_capacity_score)
        if max_inverse_score > 0:
            normalized_inverse_score = inverse_capacity_score / max_inverse_score
        else:
            normalized_inverse_score = np.zeros_like(inverse_capacity_score)

        # Combine baseline, tight fit boost, and moderate fit score.
        # The tightest fit gets 1.0. Other suitable bins get a score based on inverse capacity.
        # We need to ensure that the 'best fit' priority (1.0) is respected.
        # If a bin is the tightest fit, its priority is 1.0.
        # For others, it's a scaled inverse capacity.

        # Recalculate priorities for 'other' suitable bins
        priorities[other_suitable_indices] = 0.5 * normalized_inverse_score # Scale it down to be less than 1.0

    # Ensure that the best fits truly have the highest priority and that other suitable bins
    # have a priority higher than 0 but lower than the best fit.
    # If any bin was marked as a tight fit, its priority is 1.0.
    # Other suitable bins get their calculated score, which should be < 1.0.
    # If a bin is suitable but not a tight fit, and not in 'other_suitable_indices' (which shouldn't happen if logic is correct),
    # it will remain 0.
    # The logic above correctly assigns 1.0 to tight fits and <1.0 to other suitable bins.

    return priorities
```
