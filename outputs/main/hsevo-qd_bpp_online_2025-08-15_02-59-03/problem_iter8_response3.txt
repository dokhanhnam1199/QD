```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Combines Exact Fit preference with a scaled Best Fit for remaining bins.

    This heuristic prioritizes bins that perfectly fit the item, then selects
    the bin with the least remaining capacity among those that can fit the item.
    This balances the need for exact fits with the general principle of Best Fit.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # 1. Prioritize Exact Fits: Assign a very high priority to bins where the item fits exactly.
    exact_fit_mask = np.isclose(bins_remain_cap, item)
    priorities[exact_fit_mask] = 1.0 # Highest possible priority

    # 2. Best Fit for remaining bins: For bins that can fit the item but not exactly,
    #    assign priority based on how tightly they fit (smaller remaining capacity is better).
    #    We want to penalize bins that cannot fit the item.
    can_fit_mask = bins_remain_cap > item # Can fit, but not exactly
    
    # To ensure exact fits have absolute priority, we scale the Best Fit priorities.
    # We can use the inverse of the remaining capacity, adding a small epsilon for stability.
    # A small remaining capacity (good fit) results in a high priority.
    # We scale this by a factor less than 1.0 to ensure it's always lower than exact fit priority.
    best_fit_scaling_factor = 0.9 # Ensures exact fits are always preferred.
    epsilon = 1e-9

    if np.any(can_fit_mask):
        fitting_bins_remain_cap = bins_remain_cap[can_fit_mask]
        remaining_after_fit = fitting_bins_remain_cap - item
        
        # Calculate best fit scores: higher score for smaller remaining capacity.
        # Using inverse: 1 / (remaining_capacity + epsilon)
        best_fit_scores = 1.0 / (remaining_after_fit + epsilon)
        
        # Normalize/scale these scores to be less than the exact fit priority.
        # We can normalize them to a range, e.g., [0, 0.9].
        # First, find the max possible score to normalize relative to.
        # The theoretical max score is when remaining_after_fit is close to 0.
        # Let's simply scale the raw scores to be below 1.0.
        # A simple scaling: divide by a value larger than the maximum possible best_fit_score.
        # If items are up to 1.0, and bin capacity is 1.0, smallest remaining could be ~0.
        # Max score could be very large.
        
        # Alternative: Use the difference directly and scale it.
        # We want to prioritize bins with smaller `remaining_after_fit`.
        # Let `diff = remaining_after_fit`.
        # We want to map small `diff` to high priority, large `diff` to low priority.
        # A common way is `1 / (diff + epsilon)`.
        # To ensure they are less than exact_fit priority (1.0):
        # We can subtract the max possible difference from the current difference and invert.
        # Or, simply use a sigmoid function.

        # Let's use the sigmoid approach from Heuristic 15/17 as the secondary criterion.
        # Sigmoid: 1 / (1 + exp(-k * (ratio - 1)))
        # Here, ratio is item / remaining_cap. We want ratio close to 1.
        # Let's use the `item / (fitting_bins_remain_cap + epsilon)` as the ratio.
        # This prioritizes bins where the item fills a large portion of the remaining space.
        k_sigmoid = 5.0 # Steepness for sigmoid
        
        # Calculate the priority for the "can fit" bins using the sigmoid score
        sigmoid_scores = 1 / (1 + np.exp(-k_sigmoid * (item / (fitting_bins_remain_cap + epsilon) - 1)))
        
        # Ensure these sigmoid scores are always less than the exact fit priority (1.0)
        # by scaling them down.
        priorities[can_fit_mask] = sigmoid_scores * best_fit_scaling_factor

    return priorities
```
