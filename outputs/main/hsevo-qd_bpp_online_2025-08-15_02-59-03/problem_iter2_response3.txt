```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines 'Exact Fit First' and 'Best Fit'.
    Prioritizes exact fits, then closest fits among remaining bins.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    # Identify bins where the item fits
    fit_mask = bins_remain_cap >= item
    
    # Calculate remaining capacities for fitting bins
    fitting_bins_remain_cap = bins_remain_cap[fit_mask]
    
    # Calculate differences for fitting bins
    differences = fitting_bins_remain_cap - item
    
    # Highest priority for exact fits
    exact_fit_mask = np.isclose(differences, 0)
    priorities[fit_mask][exact_fit_mask] = 1.0
    
    # For bins that are not exact fits, assign priority based on 'best fit' (smallest positive difference)
    non_exact_fit_mask = fit_mask.copy()
    non_exact_fit_mask[fit_mask] = ~exact_fit_mask
    
    if np.any(non_exact_fit_mask):
        non_exact_fitting_bins_remain_cap = bins_remain_cap[non_exact_fit_mask]
        non_exact_differences = non_exact_fitting_bins_remain_cap - item
        
        # Assign priority inversely proportional to the difference (closer fit = higher priority)
        # Add a small epsilon to avoid division by zero for near-exact fits and to ensure non-zero priorities
        priorities[non_exact_fit_mask] = 1.0 / (non_exact_differences + 1e-9)
        
        # Normalize priorities for non-exact fits so they don't overshadow exact fits
        # We want exact fits to have a clear priority of 1.0.
        # The priorities for non-exact fits should be less than 1.0.
        # Scaling by the max non-exact priority ensures they are all <= 1.0 and preserves relative order.
        max_non_exact_priority = np.max(priorities[non_exact_fit_mask])
        if max_non_exact_priority > 0:
            priorities[non_exact_fit_mask] /= max_non_exact_priority

    return priorities
```
