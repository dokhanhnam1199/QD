```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Returns priority with which we want to add item to each bin.
    This heuristic prioritizes bins that can fit the item and, among those,
    favors bins that would leave the least remaining capacity after packing (Best Fit).
    Additionally, it assigns a higher priority to bins that are "closer" to being full,
    as this might encourage packing smaller items into less utilized bins first,
    potentially leaving larger capacities for larger items later.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    suitable_bins_mask = bins_remain_cap >= item

    if np.any(suitable_bins_mask):
        # Calculate the remaining capacity for suitable bins after packing the item
        remaining_capacities_after_packing = bins_remain_cap[suitable_bins_mask] - item

        # Find the minimum remaining capacity (Best Fit criterion)
        min_remaining_capacity = np.min(remaining_capacities_after_packing)

        # Create a mask for bins that achieve the best fit
        best_fit_mask = suitable_bins_mask & (bins_remain_cap - item == min_remaining_capacity)

        # Assign a base priority to bins that are a best fit
        priorities[best_fit_mask] = 1.0

        # Introduce a secondary priority: favor bins that are less empty (closer to full)
        # This can be done by inverting the remaining capacity (before packing) or using the original capacity.
        # Let's use the original remaining capacity, higher values mean more available space.
        # We want to prioritize bins that have *less* remaining capacity, so we can invert this.
        # However, simply inverting might lead to negative priorities if we normalize.
        # A better approach is to use a value that increases as capacity decreases.
        # Let's consider bins that are *not* the absolute best fit, but still suitable.
        # For these bins, we can assign a priority based on how "tight" the fit is,
        # or how much remaining capacity they have.
        # Let's refine: For bins that are not the absolute best fit, assign a score
        # proportional to how much *less* remaining capacity they have compared to
        # the largest available capacity among suitable bins. This encourages using
        # bins that are already somewhat full.

        suitable_bins_original_capacities = bins_remain_cap[suitable_bins_mask]
        max_suitable_capacity = np.max(suitable_bins_original_capacities)

        # For bins that are suitable but not the best fit:
        # Assign a priority inversely proportional to their remaining capacity.
        # Higher priority for bins with less remaining capacity.
        # We can scale this to avoid overlapping with the '1.0' priority of best-fit bins.
        # A simple approach is to assign a priority value between 0 and 1,
        # where 0.5 might be a good intermediate value.
        # The priority should be higher for smaller remaining_capacities_after_packing.
        # Let's map remaining_capacities_after_packing to a value from 0 to 0.5.
        # Higher priority for smaller remaining_capacities_after_packing.

        non_best_fit_suitable_mask = suitable_bins_mask & ~best_fit_mask

        if np.any(non_best_fit_suitable_mask):
            non_best_fit_remaining_caps_after = bins_remain_cap[non_best_fit_suitable_mask] - item
            # Normalize these remaining capacities to be between 0 and 0.5
            # A simple linear scaling:
            # If there's only one non-best-fit bin, it gets 0.5.
            # If there are multiple, map the smallest remaining capacity to 0.5 and largest to 0.
            min_non_best_fit_rem_cap = np.min(non_best_fit_remaining_caps_after)
            max_non_best_fit_rem_cap = np.max(non_best_fit_remaining_caps_after)

            if max_non_best_fit_rem_cap == min_non_best_fit_rem_cap:
                # All non-best-fit bins have the same remaining capacity
                priorities[non_best_fit_suitable_mask] = 0.5
            else:
                # Scale remaining capacities to the range [0, 0.5)
                scaled_priorities = 0.5 * (1 - (non_best_fit_remaining_caps_after - min_non_best_fit_rem_cap) / (max_non_best_fit_rem_cap - min_non_best_fit_rem_cap))
                priorities[non_best_fit_suitable_mask] = scaled_priorities

    return priorities
```
