```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Returns priority with which we want to add item to each bin.
    This heuristic prioritizes bins that are a "tight fit" (minimize leftover space)
    but also considers bins with more remaining capacity as a secondary factor to
    avoid prematurely filling bins with very little space left, thus promoting
    better overall packing density and potentially fewer bins.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    # Mask for bins that can accommodate the item
    suitable_bins_mask = bins_remain_cap >= item
    
    if not np.any(suitable_bins_mask):
        return priorities  # No bin can fit the item

    # Calculate leftover capacity for suitable bins
    leftover_capacities = bins_remain_cap[suitable_bins_mask] - item
    
    # Primary objective: Minimize leftover capacity (Best Fit aspect)
    min_leftover = np.min(leftover_capacities)
    
    # Create a primary priority score based on how close to the minimum leftover capacity
    # Bins with leftover_capacity == min_leftover get a high score.
    # Normalize by the maximum possible leftover to scale scores.
    # If all suitable bins have the same leftover, this will result in zeros.
    # To handle this, we add a small epsilon to the denominator or ensure it's not zero.
    max_possible_leftover = np.max(bins_remain_cap[suitable_bins_mask]) - item if np.max(bins_remain_cap[suitable_bins_mask]) > item else 0
    if max_possible_leftover == 0: max_possible_leftover = 1e-9 # Avoid division by zero if all bins are perfectly filled
    
    primary_scores = np.zeros_like(bins_remain_cap, dtype=float)
    primary_scores[suitable_bins_mask] = 1.0 - (leftover_capacities - min_leftover) / max_possible_leftover

    # Secondary objective: Maximize remaining capacity among bins with minimal leftover
    # This is a tie-breaker. If multiple bins have the same minimal leftover,
    # we prefer the one that has more remaining capacity *before* packing the item.
    # This can help in spreading items more evenly and potentially leaving larger gaps
    # for future larger items.
    
    # Find the maximum remaining capacity among the bins that have the minimum leftover
    min_leftover_bins_mask = suitable_bins_mask & (bins_remain_cap - item == min_leftover)
    
    if np.any(min_leftover_bins_mask):
        max_remaining_among_min_leftover = np.max(bins_remain_cap[min_leftover_bins_mask])
        
        # Assign a high score to bins that are both best fit AND have the most remaining capacity among best fits
        secondary_scores = np.zeros_like(bins_remain_cap, dtype=float)
        secondary_scores[min_leftover_bins_mask] = (bins_remain_cap[min_leftover_bins_mask] == max_remaining_among_min_leftover).astype(float)
        
        # Combine primary and secondary scores.
        # The primary score encourages best fit.
        # The secondary score acts as a strong tie-breaker for best fit bins.
        # We can weight them. Here, the secondary score is a strong boost.
        priorities = primary_scores + secondary_scores * 0.5 # Give secondary a significant weight but not overriding primary completely
    else:
        # If for some reason min_leftover_bins_mask is empty (should not happen if suitable_bins_mask is not empty),
        # just use primary scores.
        priorities = primary_scores

    # Ensure that only suitable bins get a non-zero priority
    priorities[~suitable_bins_mask] = 0.0

    # Normalize priorities so the maximum is 1.0 (optional but good practice for some solvers)
    if np.max(priorities) > 0:
        priorities /= np.max(priorities)
        
    return priorities
```
