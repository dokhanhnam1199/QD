```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Prioritizes exact fits, then bins with least remaining capacity, with a slight bias for earlier bins."""
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    # Exact fit: Highest priority
    exact_fit_mask = np.isclose(bins_remain_cap, item)
    priorities[exact_fit_mask] = 2.0

    # Bins where the item can fit but not exactly
    fit_mask = bins_remain_cap > item
    
    # Prioritize bins with smaller remaining capacity (tighter fit) among those that fit
    # This part is similar to the "better code"
    difference = bins_remain_cap[fit_mask] - item
    # Add a small score inversely proportional to the difference
    priorities[fit_mask] = 1.0 / (difference + 1e-9)

    # Introduce a slight preference for earlier bins among equally fitting bins
    # This mimics a subtle First Fit tendency without overriding Best Fit completely.
    # We add a small value based on the index, but only if the bin has a non-zero priority already.
    # This bias is very small to ensure Best Fit remains dominant.
    # The value is effectively added to the existing priority score.
    # np.where is used to apply this only to bins that can fit the item.
    # The addition ensures that tighter fits still generally score higher,
    # but among bins with identical tightness scores, earlier ones get a nudge.
    indices = np.arange(len(bins_remain_cap))
    bias_values = (len(bins_remain_cap) - 1 - indices) * 0.0001 # Small bias for earlier bins
    
    # Apply bias only to bins that can fit the item
    priorities[fit_mask] += bias_values[fit_mask]
    
    # Ensure exact fits still have the highest priority
    priorities[exact_fit_mask] = np.maximum(priorities[exact_fit_mask], 2.0)
    
    # Ensure bins that cannot fit have zero priority
    priorities[~fit_mask & ~exact_fit_mask] = 0.0

    return priorities
```
