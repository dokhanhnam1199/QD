```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Exact Fit First and Best Fit.
    Prioritizes exact fits, then bins with minimal remaining capacity,
    using a penalty for bins that cannot fit the item.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins that can fit the item
    fit_mask = bins_remain_cap >= item

    # Exact fit: highest priority
    exact_fit_mask = (bins_remain_cap == item) & fit_mask
    priorities[exact_fit_mask] = 1.0

    # Best fit for remaining bins (those that fit but not exactly)
    non_exact_fit_mask = fit_mask & ~exact_fit_mask
    if np.any(non_exact_fit_mask):
        fitting_capacities = bins_remain_cap[non_exact_fit_mask]
        gaps = fitting_capacities - item
        min_gap = np.min(gaps)
        
        # Assign priorities based on the gap, higher for smaller gaps.
        # Add a small offset to distinguish from exact fits and ensure positive.
        best_fit_priorities = 0.9 - (gaps - min_gap) / (np.max(gaps) - min_gap + 1e-9)
        
        # Apply these priorities only to the bins that are non-exact fits
        priorities[non_exact_fit_mask] = best_fit_priorities

    # Penalize bins that cannot fit the item
    no_fit_mask = ~fit_mask
    priorities[no_fit_mask] = -1.0 # Effectively exclude them from selection

    return priorities
```
