```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best Fit with a penalty for bins that are too empty,
    prioritizing tighter fits and slightly penalizing very large remaining capacities.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    # Mask for bins that can accommodate the item
    suitable_bins_mask = bins_remain_cap >= item

    if not np.any(suitable_bins_mask):
        return priorities

    # Calculate remaining capacities for suitable bins after fitting the item
    remaining_capacities_after_fit = bins_remain_cap[suitable_bins_mask] - item

    # Find the minimum remaining capacity (Best Fit criterion)
    min_remaining_capacity = np.min(remaining_capacities_after_fit)

    # Identify bins that achieve the minimum remaining capacity (exact best fits)
    is_best_fit = (remaining_capacities_after_fit == min_remaining_capacity)

    # Calculate a score for suitable bins:
    # - High priority for exact best fits.
    # - For other bins, prioritize those with less remaining capacity (tighter fit).
    # - Add a penalty for bins that are very "empty" (large remaining capacity after fit),
    #   to discourage leaving large, unusable gaps.

    # Base score for all suitable bins, prioritizing smaller remaining capacity (tighter fit)
    # Use inverse of remaining capacity, scaled to avoid division by zero and large numbers.
    # Adding epsilon for numerical stability.
    epsilon = 1e-9
    # Avoid division by zero if max_rem_cap equals min_rem_cap for non-best fit bins
    if np.all(remaining_capacities_after_fit[~is_best_fit] == remaining_capacities_after_fit[~is_best_fit][0]):
        scaled_tightness = np.zeros_like(remaining_capacities_after_fit[~is_best_fit])
    else:
        max_rem_cap_for_others = np.max(remaining_capacities_after_fit[~is_best_fit])
        min_rem_cap_for_others = np.min(remaining_capacities_after_fit[~is_best_fit])
        # Normalize remaining capacity to [0, 1], where 0 is best (smallest remaining capacity)
        scaled_tightness = (remaining_capacities_after_fit[~is_best_fit] - min_rem_cap_for_others) / (max_rem_cap_for_others - min_rem_cap_for_others + epsilon)
    
    # Apply a penalty for large remaining capacities (e.g., remaining capacity > 50% of item size)
    # This penalty should be less severe than the gain from being a best fit.
    # Let's define "large" remaining capacity relative to the item size itself for a more stable penalty.
    # We want to penalize bins that have a lot of leftover space *after* packing.
    # A simple approach: reduce priority if remaining_capacity_after_fit is large.
    # Consider a threshold, e.g., if remaining_capacity_after_fit > item * 0.5
    penalty_factor = 0.5 # Penalty magnitude
    
    penalties = np.zeros_like(remaining_capacities_after_fit)
    large_capacity_mask = remaining_capacities_after_fit > (item * 0.5)
    if np.any(large_capacity_mask):
        # Scale penalty based on how much it exceeds the threshold
        excess_capacity = remaining_capacities_after_fit[large_capacity_mask] - (item * 0.5)
        max_excess = np.max(excess_capacity)
        
        # Scale penalty to a small negative value, e.g., [-0.3, 0]
        if max_excess > epsilon:
            scaled_penalty = -penalty_factor * (excess_capacity / (max_excess + epsilon))
            penalties[large_capacity_mask] = scaled_penalty
        else: # All excess capacities are near zero
            penalties[large_capacity_mask] = -penalty_factor * 0.1 # Small penalty

    # Combine scores:
    # Exact best fits get the highest priority (e.g., 1.0)
    # Other suitable bins get a score based on scaled tightness, minus penalty.
    
    # Assign priorities to exact best fit bins
    priorities[suitable_bins_mask][is_best_fit] = 1.0

    # Assign priorities to other suitable bins
    non_best_fit_indices_in_suitable = np.where(~is_best_fit)[0]
    
    if len(non_best_fit_indices_in_suitable) > 0:
        # Calculate base priority for non-best-fit bins based on tightness
        # Use a scale that is less than the best-fit priority (e.g., [0.1, 0.9])
        base_priority_non_bf = 0.1 + 0.8 * (1 - scaled_tightness) # Inverted scaled tightness
        
        # Apply penalties
        applied_penalties = penalties[~is_best_fit]
        final_priorities_non_bf = base_priority_non_bf + applied_penalties
        
        # Ensure priorities are within a reasonable range and don't exceed best fit
        final_priorities_non_bf = np.clip(final_priorities_non_bf, 0.0, 0.95) # Keep below best fit
        
        priorities[suitable_bins_mask][~is_best_fit] = final_priorities_non_bf

    return priorities
```
