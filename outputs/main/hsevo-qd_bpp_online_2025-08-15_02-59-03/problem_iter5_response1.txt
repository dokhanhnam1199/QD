```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Combines exact fit prioritization with a refined Best Fit approach for remaining capacity.

    This heuristic prioritizes exact fits and then favors bins that minimize remaining
    space, using a scaled inverse to avoid extreme values, similar to the best-performing
    strategies.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    suitable_bins_mask = bins_remain_cap >= item

    if not np.any(suitable_bins_mask):
        return priorities

    suitable_bins_caps = bins_remain_cap[suitable_bins_mask]
    remaining_capacities_after_packing = suitable_bins_caps - item

    # Prioritize exact fits with a high score
    tolerance = 1e-6
    exact_fit_mask = np.abs(remaining_capacities_after_packing) < tolerance

    if np.any(exact_fit_mask):
        # Among exact fits, pick the one with least remaining capacity (already zero)
        # Assign highest priority to these
        original_indices_exact = np.where(suitable_bins_mask)[0][exact_fit_mask]
        priorities[original_indices_exact] = 2.0
        
        # If there are exact fits, we primarily focus on them.
        # For any remaining suitable bins that are *not* exact fits, give them a lower
        # but still significant priority based on how 'best-fit' they are.
        non_exact_mask_for_suitable = ~exact_fit_mask
        if np.any(non_exact_mask_for_suitable):
            non_exact_suitable_caps = suitable_bins_caps[non_exact_mask_for_suitable]
            non_exact_remaining_after = non_exact_suitable_caps - item
            
            # Score based on minimizing remaining capacity after packing.
            # Use a scaled inverse to avoid extreme values and favor tighter fits.
            min_remaining_non_exact = np.min(non_exact_remaining_after)
            scores_non_exact = 1.0 / (1.0 + non_exact_remaining_after - min_remaining_non_exact)
            
            # Normalize scores for these non-exact fits
            max_score_non_exact = np.max(scores_non_exact)
            min_score_non_exact = np.min(scores_non_exact)
            if max_score_non_exact > min_score_non_exact:
                normalized_scores_non_exact = (scores_non_exact - min_score_non_exact) / (max_score_non_exact - min_score_non_exact)
            else:
                normalized_scores_non_exact = np.ones_like(scores_non_exact) * 0.5

            # Assign a priority lower than exact fits but higher than default (e.g., 1.0 to 1.9)
            priorities[suitable_bins_mask][non_exact_mask_for_suitable] = 1.0 + normalized_scores_non_exact * 0.9

    else:
        # If no exact fits, fall back to a refined Best Fit strategy for all suitable bins.
        # Prioritize bins that leave the least remaining capacity after packing.
        # Score is inversely related to the remaining capacity, scaled to avoid extremes.
        min_remaining_overall = np.min(remaining_capacities_after_packing)
        
        # Higher score for bins closer to the minimum remaining capacity.
        scores_all_suitable = 1.0 / (1.0 + remaining_capacities_after_packing - min_remaining_overall)
        
        # Normalize scores to be between 0 and 1
        max_score_all_suitable = np.max(scores_all_suitable)
        min_score_all_suitable = np.min(scores_all_suitable)
        if max_score_all_suitable > min_score_all_suitable:
            normalized_scores_all_suitable = (scores_all_suitable - min_score_all_suitable) / (max_score_all_suitable - min_score_all_suitable)
        else:
            normalized_scores_all_suitable = np.ones_like(scores_all_suitable) * 0.5 # Neutral score if all are equal

        # Assign priorities between 1.0 and 1.9, reflecting a strong Best Fit preference.
        priorities[suitable_bins_mask] = 1.0 + normalized_scores_all_suitable * 0.9

    return priorities
```
