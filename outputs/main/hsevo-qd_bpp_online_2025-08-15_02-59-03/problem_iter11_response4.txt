```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Combines exact fit prioritization with a graded Best Fit strategy.

    Prioritizes exact fits and then bins with the least remaining capacity after fitting,
    using a graded scale for non-exact fits to encourage tighter packing.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    # Mask for bins where the item can fit
    fit_mask = bins_remain_cap >= item
    
    # If no bins can fit the item, return all zeros.
    if not np.any(fit_mask):
        return priorities

    # Prioritize exact fits with the highest score
    exact_fit_mask = np.isclose(bins_remain_cap[fit_mask], item)
    priorities[fit_mask][exact_fit_mask] = 2.0  # Highest priority

    # For bins that fit but not exactly, calculate remaining capacity after fitting
    non_exact_fit_mask = fit_mask.copy()
    non_exact_fit_mask[fit_mask] = ~exact_fit_mask
    
    if np.any(non_exact_fit_mask):
        remaining_capacities_for_non_exact = bins_remain_cap[non_exact_fit_mask]
        # Calculate the remaining capacity after placing the item
        difference = remaining_capacities_for_non_exact - item
        
        # Assign priority based on the inverse of the difference (smaller difference = higher priority)
        # Add a small epsilon to avoid division by zero for cases where difference is 0 (though unlikely here)
        # Scale these priorities to be less than the exact fit priority (e.g., up to 1.0)
        # A simple inverse is used as a graded approach for best fit.
        scores = 1.0 / (difference + 1e-9)
        
        # Normalize scores to be less than the exact fit priority (2.0)
        # We map the minimum difference to a score close to 1.0 and larger differences to lower scores.
        # A simple way is to scale the inverse of the difference.
        max_possible_diff = np.max(bins_remain_cap[fit_mask] - item) if np.any(fit_mask) else 1.0
        normalized_scores = 1.0 - (difference / (max_possible_diff + 1e-9)) # Tighter fit gets higher score, capped at 1.0

        # Assign these calculated priorities to the non-exact fit bins.
        priorities[non_exact_fit_mask] = normalized_scores
    
    # Ensure exact fits still have the highest priority if they were also considered in non-exact calculation (unlikely due to mask logic)
    # This step ensures that if any exact fit also satisfied the non-exact condition, it retains its highest priority.
    priorities[fit_mask][np.isclose(bins_remain_cap[fit_mask], item)] = np.maximum(priorities[fit_mask][np.isclose(bins_remain_cap[fit_mask], item)], 2.0)
    
    return priorities
```
