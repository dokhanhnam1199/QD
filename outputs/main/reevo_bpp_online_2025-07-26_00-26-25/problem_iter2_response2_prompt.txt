{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This implementation considers both the remaining capacity and the number of times a bin has approached full capacity.\n    We prioritize bins that have more remaining capacity and less wastage if the item is added.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity if the item is added to each bin\n    projected_remain_cap = bins_remain_cap - item\n    \n    # Avoid negative capacitated bins by setting their priority to a very low value\n    priority_scores = np.where(projected_remain_cap >= 0, projected_remain_cap, -np.inf)\n    \n    # To reduce wastage, we give a higher priority to bins with zero wastage\n    priority_scores[projected_remain_cap == 0] += 1\n    \n    # To consider bins that have almost reached capacity, we might lower their preference\n    # This step is optional and can be adjusted behavior depending on specific needs\n    # Here we slightly penalize bins that could reach capacity after placing this item\n    priority_scores -= (bins_remain_cap < 2 * item) * 1\n    \n    # Encourage first-fit style by slightly giving preference to bins with higher original capacity\n    # However, only do this if remaining capacity is tolerably high, to avoid large unused spaces\n    priority_scores += 0.1 * np.where(projected_remain_cap > item, bins_remain_cap, 0)\n    \n    return priority_scores\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This implementation prioritizes bins that have the least remaining capacity that can still fit the item.\n    It avoids fragmenting bins by preferring to fill bins more densely.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remain_cap_after_add = bins_remain_cap - item\n    # Set negative infinity to those bins that cannot fit the item\n    priority_scores = np.where(remain_cap_after_add >= 0, remain_cap_after_add, -np.inf)\n    # We want to maximize the filled space, thus we invert the remaining capacity\n    priority_scores = -priority_scores\n    # Add a small penalty to bins that already have zero capacity left (i.e., are full)\n    priority_scores[bins_remain_cap == 0] += 1e9\n    return priority_scores\n\n[Reflection]\nPrioritize bins with least remaining capacity post-item addition and avoid severe fragmentation by inverting scores. Penalize fully filled bins heavily.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}