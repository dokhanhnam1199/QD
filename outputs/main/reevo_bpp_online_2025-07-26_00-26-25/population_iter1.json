[
  {
    "stdout_filepath": "problem_iter1_response0.txt_stdout.txt",
    "code_path": "problem_iter1_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This implementation considers both the remaining capacity and the number of\n    bins used using a weighted score. Bins that are closer to being full get higher\n    priority, but the priority is slightly reduced for bins that have less remaining\n    capacity than the item to prevent unused bin scenarios.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Linear decreasing priority based on remaining capacity\n    # Use a max function to avoid negative priorities and ensure feasibility\n    priority = np.maximum(0, bins_remain_cap - item) / item\n    \n    # Give a clear preference to bins that can fit the item at all\n    can_fit_item_mask = bins_remain_cap >= item\n    priority[np.where(~can_fit_item_mask)] -= 2\n    \n    # Encourage the second smallest gaps (fill bigger empty spots\u5c3d\u65e9 to encourage less fragmentation)\n    # Less penalty for bins pediatric returning subtle fragments after an insertion\n    if np.any(can_fit_item_mask):\n        priority_after_check = bins_remain_cap - item\n        highest_remaining_capacities = np.partition(priority_after_check[can_fit_item_mask], 1)[:2]\n        low = highest_remaining_capacities[0] if len(highest_remaining_capacities) > 1 else 0\n        low_idx = np.where(np.isclose(priority_after_check, low))[0]\n        if len(low_idx) == 1:\n            priority[low_idx[0]] += 1  # boost solitare other fragment accent withok followers much step-water pour toplant\u0131\n    \n    return priority",
    "response_id": 0,
    "obj": 145.26326286398086,
    "SLOC": 12.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response1.txt_stdout.txt",
    "code_path": "problem_iter1_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This implementation considers both the remaining capacity and the number of\n    bins used using a weighted score. Bins that are closer to being full get higher\n    priority, but the priority is slightly reduced for bins that have less remaining\n    capacity than the item to prevent unused bin scenarios.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Linear decreasing priority based on remaining capacity\n    # Use a max function to avoid negative priorities and ensure feasibility\n    priority = np.maximum(0, bins_remain_cap - item) / item\n    \n    # Give a clear preference to bins that can fit the item at all\n    can_fit_item_mask = bins_remain_cap >= item\n    priority[np.where(~can_fit_item_mask)] -= 2\n    \n    # Encourage the second smallest gaps (fill bigger empty spots\u5c3d\u65e9 to encourage less fragmentation)\n    # Less penalty for bins pediatric returning subtle fragments after an insertion\n    if np.any(can_fit_item_mask):\n        priority_after_check = bins_remain_cap - item\n        highest_remaining_capacities = np.partition(priority_after_check[can_fit_item_mask], 1)[:2]\n        low = highest_remaining_capacities[0] if len(highest_remaining_capacities) > 1 else 0\n        low_idx = np.where(np.isclose(priority_after_check, low))[0]\n        if len(low_idx) == 1:\n            priority[low_idx[0]] += 1  # boost solitare other fragment accent withok followers much step-water pour toplant\u0131\n    \n    return priority",
    "response_id": 1,
    "obj": 145.26326286398086,
    "SLOC": 12.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response2.txt_stdout.txt",
    "code_path": "problem_iter1_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This implementation considers both the remaining capacity and the number of\n    bins used using a weighted score. Bins that are closer to being full get higher\n    priority, but the priority is slightly reduced for bins that have less remaining\n    capacity than the item to prevent unused bin scenarios.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Linear decreasing priority based on remaining capacity\n    # Use a max function to avoid negative priorities and ensure feasibility\n    priority = np.maximum(0, bins_remain_cap - item) / item\n    \n    # Give a clear preference to bins that can fit the item at all\n    can_fit_item_mask = bins_remain_cap >= item\n    priority[np.where(~can_fit_item_mask)] -= 2\n    \n    # Encourage the second smallest gaps (fill bigger empty spots\u5c3d\u65e9 to encourage less fragmentation)\n    # Less penalty for bins pediatric returning subtle fragments after an insertion\n    if np.any(can_fit_item_mask):\n        priority_after_check = bins_remain_cap - item\n        highest_remaining_capacities = np.partition(priority_after_check[can_fit_item_mask], 1)[:2]\n        low = highest_remaining_capacities[0] if len(highest_remaining_capacities) > 1 else 0\n        low_index = np.where(bin_remain_cap - item == low)[0]\n        priority[low_index] += 0.5\n\n    return priority",
    "response_id": 2,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 32, in priority_v2\n    low_index = np.where(np.isclose(priority_after_check, low))[0][0]\nNameError: name 'bin_remain_cap' is not defined. Did you mean: 'bins_remain_cap'?\n12\n4\n"
  },
  {
    "stdout_filepath": "problem_iter1_response3.txt_stdout.txt",
    "code_path": "problem_iter1_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This implementation considers both the remaining capacity and the number of\n    bins used using a weighted score. Bins that are closer to being full get higher\n    priority, but the priority is slightly reduced for bins that have less remaining\n    capacity than the item to prevent unused bin scenarios.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Linear decreasing priority based on remaining capacity\n    # Use a max function to avoid negative priorities and ensure feasibility\n    priority = np.maximum(0, bins_remain_cap - item) / item\n    \n    # Give a clear preference to bins that can fit the item at all\n    can_fit_item_mask = bins_remain_cap >= item\n    priority[np.where(~can_fit_item_mask)] -= 2\n    \n    # Encourage the second smallest gaps (fill bigger empty spots\u5c3d\u65e9 to encourage less fragmentation)\n    # Less penalty for bins pediatric returning subtle fragments after an insertion\n    if np.any(can_fit_item_mask):\n        priority_after_check = bins_remain_cap - item\n        highest_remaining_capacities = np.partition(priority_after_check[can_fit_item_mask], 1)[:2]\n        low = highest_remaining_capacities[0] if len(highest_remaining_capacities) > 1 else 0\n        low_index = np.where(np.isclose(priority_after_check, low))[0][0]\n        priority[np.where(can_fit_item_mask)[0][low_index]] += 1  # a minor preference downgrade to smallest two\n\n    return priority",
    "response_id": 3,
    "obj": 51.90466693258875,
    "SLOC": 12.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response4.txt_stdout.txt",
    "code_path": "problem_iter1_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This implementation considers both the remaining capacity and the number of\n    bins used logic to make a decision, emphasizing partially filled bins to avoid\n    potential small fragmentations.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Penalize bins that cannot fit the item with a very low score\n    can_fit = (bins_remain_cap >= item).astype(float)\n    \n    # Prioritize bins with less remaining capacity (first-fit decreasing approach)\n    capacity_weight = (bins_remain_cap / np.max(bins_remain_cap)) if np.max(bins_remain_cap) > 0 else np.ones_like(bins_remain_cap)\n    \n    # Decrement priority for each bin that already has items by count of filled bins\n    filled_bins_discount = np.where(bins_remain_cap != np.ones_like(bins_remain_cap), 0.1, 0.0)\n    \n    # Give preference to bins that have smaller unused space after placing the item to reduce fragmentation\n    subsequent_fragmentation = (bins_remain_cap - item) / np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else np.zeros_like(bins_remain_cap)\n    \n    priority_scores = can_fit * (capacity_weight * 0.5 - filled_bins_discount + subsequent_fragmentation * 0.5)\n    \n    return priority_scores",
    "response_id": 4,
    "obj": 149.30195452732352,
    "SLOC": 12.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response5.txt_stdout.txt",
    "code_path": "problem_iter1_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This implementation considers both the remaining capacity and the number of times a bin has approached full capacity.\n    We prioritize bins that have more remaining capacity and less wastage if the item is added.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity if the item is added to each bin\n    projected_remain_cap = bins_remain_cap - item\n    \n    # Avoid negative capacitated bins by setting their priority to a very low value\n    priority_scores = np.where(projected_remain_cap >= 0, projected_remain_cap, -np.inf)\n    \n    # To reduce wastage, we give a higher priority to bins with zero wastage\n    priority_scores[projected_remain_cap == 0] += 1\n    \n    # To consider bins that have almost reached capacity, we might lower their preference\n    # This step is optional and can be adjusted behavior depending on specific needs\n    # Here we slightly penalize bins that could reach capacity after placing this item\n    priority_scores -= (bins_remain_cap < 2 * item) * 1\n    \n    # Encourage first-fit style by slightly giving preference to bins with higher original capacity\n    # However, only do this if remaining capacity is tolerably high, to avoid large unused spaces\n    priority_scores += 0.1 * np.where(projected_remain_cap > item, bins_remain_cap, 0)\n    \n    return priority_scores",
    "response_id": 5,
    "obj": 149.30195452732352,
    "SLOC": 12.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response6.txt_stdout.txt",
    "code_path": "problem_iter1_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This implementation considers both the remaining capacity and the number of\n    bins used less frequently to encourage a balanced bin fill.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate normalized remaining capacity\n    remaining_capacity = bins_remain_cap - item\n    normalized_capacity = remaining_capacity / bins_remain_cap\n    \n    # If the item cannot fit in the bin, set its score to a negative number\n    score = np.where(remaining_capacity >= 0, normalized_capacity, -1.0)\n    \n    # Penalize bins with less capacity remaining, but encouraged by less frequent usage\n    # Here, we assume we have a heuristic perspective of usage frequency encoded in bin_usage_frequency\n    # For the sake of this example, bin_usage_frequency is simulated as an inverse calculation\n    # that starts filling most likely empty or less used bins first\n    bin_usage_frequency_sampled_penalty = np.reciprocal(bins_remain_cap + 1.0) * -1.0\n    \n    # Combine scores\n    combined_score = score + bin_usage_frequency_sampled_penalty\n    \n    return combined_score",
    "response_id": 6,
    "obj": 149.30195452732352,
    "SLOC": 12.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response7.txt_stdout.txt",
    "code_path": "problem_iter1_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This implementation prioritizes bins that have the least remaining capacity that can still fit the item.\n    It helps to maintain bins as full as possible which could theoretically lead to fewer bins being used.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity that can still fit the item\n    viable_caps = bins_remain_cap - item\n    # Set negative scores for bins which can't fit the item\n    scores = np.where(viable_caps >= 0, viable_caps, -np.inf)\n    # Invert the scores so that bins that can fit the item and have less remaining space get higher priority\n    return np.max(viable_caps) - scores",
    "response_id": 7,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response8.txt_stdout.txt",
    "code_path": "problem_iter1_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Prioritize bins where adding the item will leave the least room left (FMS - First Fit Decreasing modified)\n    return -(bins_remain_cap - item)**2",
    "response_id": 8,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response9.txt_stdout.txt",
    "code_path": "problem_iter1_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This implementation considers both the remaining capacity and the number of\n    bins used strategically. The priority is high if there is enough remaining\n    capacity to add the item and if it would help keep the bins balanced.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priority scores\n    priority_scores = np.zeros_like(bins_remain_cap)\n\n    # Calculate how well each bin allows packing of the current item\n    feasibility = bins_remain_cap >= item\n\n    # Calculate imbalance cost for packing into each bin\n    # Packing into less full bins can often lead to better results\n    mean_remaining_capacity = np.mean(bins_remain_cap)\n    imbalance_cost = np.abs(bins_remain_cap - mean_remaining_capacity)\n\n    # Heuristic priority: feasible bins get high positive score boosted by inverse of imbalance\n    priority_scores[feasibility] = (bins_remain_cap / (max(bins_remain_cap) - item + 1)) * (1 / (imbalance_cost + 1))\n\n    return priority_scores",
    "response_id": 9,
    "obj": 7.189868368568024,
    "SLOC": 12.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response10.txt_stdout.txt",
    "code_path": "problem_iter1_code10.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This implementation considers both the remaining capacity and the number of\n    bins used penalties to encourage efficient packing while distributing load.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Penalize bins that are already fairly full\n    fullness_penalty = 1 - (bins_remain_cap / bins_remain_cap.max())\n\n    # Penalize bins that are above a certain threshold to distribute load\n    max_bins = 10  # Assume this is a reasonable limit for number of bins to start distributing the load\n    load_penalty = (np.sum(bins_remain_cap < bins_remain_cap.max() * 0.1) >= max_bins)\n\n    # Calculate a priority score: want to balance so that load is distributed but bins are maximally utilized\n    priority_scores = (bins_remain_cap - item - fullness_penalty * item) * (1 - load_penalty)\n\n    return priority_scores",
    "response_id": 10,
    "obj": 149.30195452732352,
    "SLOC": 12.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response11.txt_stdout.txt",
    "code_path": "problem_iter1_code11.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This implementation considers both the remaining capacity and the number of\n    bins used/unused to make a more balanced and efficient packing decision.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Penalize bins with very low remaining capacity as they are less likely to fit subsequent items\n    low_capacity_penalty = 1.0 / (bins_remain_cap + 1e-6) # avoiding division by zero\n    # Penalize empty bins as they could lead to an imbalance where fewer bins end up being more full\n    bin_usage_penalty = 1 + (bins_remain_cap == 0).astype(float)\n    # Prioritize bins that have enough capacity to fit the current item and smallest remaining capacity to avoid fragmentation\n    raw_priorities = (bins_remain_cap - item >= 0) / (low_capacity_penalty * bin_usage_penalty)\n    # Avoid negativezf raisesryptography specific error handler. Here's an example of how to handle network-related errors in cryptography by catching `OSError` and `socket.timeout` exceptions, which are common when network issues affect cryptographic operations relying on network calls:",
    "response_id": 11,
    "obj": 4.487435181491823,
    "SLOC": 12.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response12.txt_stdout.txt",
    "code_path": "problem_iter1_code12.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Avoid division by zero, where item size is larger than the remaining capacity of some bins\n    safe_bins_remain_cap = bins_remain_cap + 1e-9\n    \n    # Heuristic: Prioritize bins that can still fit the item and have remaining capacity closest to the item size\n    # Use a combination of item fit and sequential index to break ties (favoring earlier bins when capacities are similar)\n    priority_scores = -(np.abs(safe_bins_remain_cap - item)) + 1e-7 * np.arange(len(bins_remain_cap))\n    \n    # Set priority score for bins that cannot fit the item to -inf so they are never chosen\n    priority_scores[bins_remain_cap < item] = -np.inf\n    \n    return priority_scores",
    "response_id": 12,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response13.txt_stdout.txt",
    "code_path": "problem_iter1_code13.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This implementation considers both the remaining capacity and the number of\n    bins used according to the First-Fit-Decreasing (FFD) strategy adapted to online.\n    The priority is higher if the item fits in the bin and the remaining capacity is close to zero.\n    \n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priority scores to zero\n    priority_scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    \n    # Check which bins can fit the item\n    possible_bins = bins_remain_cap >= item\n    \n    # Calculate priority for each possible bin\n    priority_scores[possible_bins] = 1 / (bins_remain_cap[possible_bins] - item + 1e-5)  # Adding a small value to avoid division by zero\n    \n    return priority_scores",
    "response_id": 13,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response14.txt_stdout.txt",
    "code_path": "problem_iter1_code14.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This implementation considers both the remaining capacity and the number of\n    bins used using a weighted score. Bins that are closer to being full get higher\n    priority, but the priority is slightly reduced for bins that have less remaining\n    capacity than the item to prevent unused bin scenarios.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Linear decreasing priority based on remaining capacity\n    # Use a max function to avoid negative priorities and ensure feasibility\n    priority = np.maximum(0, bins_remain_cap - item) / item\n    \n    # Give a clear preference to bins that can fit the item at all\n    can_fit_item_mask = bins_remain_cap >= item\n    priority[np.where(~can_fit_item_mask)] -= np.max(priority) + 1\n\n    return priority",
    "response_id": 14,
    "obj": 149.30195452732352,
    "SLOC": 12.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response15.txt_stdout.txt",
    "code_path": "problem_iter1_code15.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This implementation prioritizes bins that have the least remaining capacity that can still fit the item.\n    It avoids fragmenting bins by preferring to fill bins more densely.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remain_cap_after_add = bins_remain_cap - item\n    # Set negative infinity to those bins that cannot fit the item\n    priority_scores = np.where(remain_cap_after_add >= 0, remain_cap_after_add, -np.inf)\n    # We want to maximize the filled space, thus we invert the remaining capacity\n    priority_scores = -priority_scores\n    # Add a small penalty to bins that already have zero capacity left (i.e., are full)\n    priority_scores[bins_remain_cap == 0] += 1e9\n    return priority_scores",
    "response_id": 15,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response16.txt_stdout.txt",
    "code_path": "problem_iter1_code16.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This implementation considers both the remaining capacity and the number of\n    bins used strategically. The priority is high if there is enough remaining\n    capacity to add the item and if it would help keep the bins balanced.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priority scores\n    priority_scores = np.zeros_like(bins_remain_cap)\n\n    # Calculate how well each bin size minus item size aligns with the smallest remaining bin size\n    bins_remain_after_item = bins_remain_cap - item\n    valid_bins = bins_remain_after_item >= 0  # Only consider bins that can fit the item\n\n    if np.any(valid_bins):\n        # Smallest remaining capacity after item could be placed\n        min_remaining_capacity_after = np.min(bins_remain_after_item[valid_bins])\n        \n        # Percentage of bins that can fit the item well (with minimal disjoint with median)\n        median_remaining_capacity = np.median(bins_remain_cap)\n        normalized_discrepancy = np.abs(bins_remain_after_item - median_remaining_capacity)\n        small_discrepancy_threshold = median_remaining_capacity * 0.2\n        small_discrepancy_bins = normalized_discrepancy < small_discrepancy_threshold\n\n        # Prioritize bins that fit the item and have lower discrepancy to the median capacity\n        priority_scores = valid_bins.astype(float) * (\n            1 - (bins_remain_after_item - min_remaining_capacity_after) / median_remaining_capacity\n        ) + small_discrepancy_bins.astype(int) * 0.1  # Slightly increase priority for jetsam bins\n\n    return priority_scores",
    "response_id": 16,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response17.txt_stdout.txt",
    "code_path": "problem_iter1_code17.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Heuristic to encourage Items being placed in bins that are near full but have sufficient space.\n    # A combination of remaining capacity and bin fullness is used as a priority score.\n    return bins_remain_cap - (1 - (bins_remain_cap - item) / max(bins_remain_cap)) ** 2",
    "response_id": 17,
    "obj": 149.30195452732352,
    "SLOC": 12.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response18.txt_stdout.txt",
    "code_path": "problem_iter1_code18.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This implementation considers both the remaining capacity and the number of\n    bins used using a weighted score. Bins that are closer to being full get higher\n    priority, but the priority is slightly reduced for bins that have less remaining\n    capacity than the item to prevent unused bin scenarios.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Linear decreasing priority based on remaining capacity\n    # Use a max function to avoid negative priorities and ensure that bins\n    # with less capacity than the item get a priority of 0 or slightly adjusted value.\n    preference = np.maximum(bins_remain_cap - item, 0) / item * 10\n    \n    # Adjustment for bins which don't have enough space for the current item\n    # to make them slightly discouraged compared to those which could fully take it.\n    penalty = np.where(bins_remain_cap < 2*item, -0.1 * (item - bins_remain_cap), 0)\n    \n    # Encourage filling bins to avoid scattered small items\n    urgency = 1 / bins_remain_cap b\n    preference = preference + penalty + urgency\n\n    return preference",
    "response_id": 18,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 9, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 28\n    urgency = 1 / bins_remain_cap b\n                                  ^\nSyntaxError: invalid syntax\n12\n4\n"
  },
  {
    "stdout_filepath": "problem_iter1_response19.txt_stdout.txt",
    "code_path": "problem_iter1_code19.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This implementation considers both the remaining capacity and the number of\n    bins used using a weighted score. Bins that are closer to being full get higher\n    priority, but the priority is slightly reduced for bins that have less remaining\n    capacity than the item to prevent unused bin scenarios.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Apply a penalty to bins where the remaining capacity is less than the item size\n    penalty_mask = bins_remain_cap < item\n    # Higher priority to bins with less remaining capacity (lower values in abs diff)\n    priority_scores = 1 / (np.abs(bins_remain_cap - item) + 1)\n    # Penalize bins with too little capacity for the item\n    priority_scores[penalty_mask] *= 0.5\n    return priority_scores",
    "response_id": 19,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response20.txt_stdout.txt",
    "code_path": "problem_iter1_code20.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This implementation considers both the remaining capacity and the number of\n    bins used using a weighted score. Bins that are closer to being full get higher\n    priority, but the priority is slightly reduced for bins that have less remaining\n    capacity than the item to prevent unused bin scenarios.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Linear decreasing priority based on remaining capacity\n    # Use a max function to avoid negative priorities and penalize bins with less remaining capacity than the item\n    priority_scores = np.where(bins_remain_cap >= item, (bins_remain_cap - item) / bins_remain_cap, -1)\n    \n    # Add a bonus to bins that already have significant fill to maximize utilization\n    utilization_bonus = np.maximum(0, (bins_remain_cap.sum() - bins_remain_cap) / bins_remain_cap.sum())\n    \n    # Combine theSingleMonitoring dataSourceProvider: CCLogDataSource, tenantId: String = \"\") as MonitoringSession\n\nMonitor.keywords {\n    self.keywordArgs = [\"keywordMonitoring\", tenantId]\n}\n\nInitialize.activity PerformCCProtectionSetupCreatorbash(resources). keywords = [\n    \"installed\",\n    *Monitor.keywords()\n]",
    "response_id": 20,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 9, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 28\n    self.keywordArgs = [\"keywordMonitoring\", tenantId]\n    ^^^^^^^^^^^^^^^^\nSyntaxError: cannot assign to attribute here. Maybe you meant '==' instead of '='?\n12\n4\n"
  },
  {
    "stdout_filepath": "problem_iter1_response21.txt_stdout.txt",
    "code_path": "problem_iter1_code21.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This implementation considers both the remaining capacity and the number of\n    bins used using a weighted score. Bins that are closer to being full get higher\n    priority, but the priority is slightly reduced for bins that have less remaining\n    capacity than the item to prevent unused bin scenarios.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Find the maximum remaining capacity available in any of the bins\n    max_cap = np.max(bins_remain_cap)\n    \n    # Calculate how full each bin is\n    fullness = 1 - (bins_remain_cap / max_cap)\n    \n    # Penalize bins that cannot fit the current item\n    penalty = np.where(bins_remain_cap < item, -1, 0)\n    \n    # Combine fullness and penalization for priority score\n    priority = fullness + penalty\n    \n    return priority",
    "response_id": 21,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response22.txt_stdout.txt",
    "code_path": "problem_iter1_code22.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This implementation considers both the remaining capacity and the number of\n    bins used recently. It aims to reduce fragmentation by preferring bins that\n    are almost filled.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    new_remain_cap = bins_remain_cap - item\n    \n    # Calculate the priority score\n    # We give a higher score if the remaining capacity is small (i.e., almost full)\n    priority_scores = -np.where(new_remain_cap >= 0, new_remain_cap, -np.inf)\n    \n    # Penalize bins that are already more than half full to avoid them taking more small items\n    priority_scores = np.where(bins_remain_cap < 0.5 * np.max(bins_remain_cap + item), priority_scores, 0)\n    \n    return priority_scores",
    "response_id": 22,
    "obj": 2.183885121659363,
    "SLOC": 12.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response23.txt_stdout.txt",
    "code_path": "problem_iter1_code23.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This implementation considers both the remaining capacity and the number of\n    bins used using a weighted score. Bins that are closer to being full get higher\n    priority, but the priority is slightly reduced for bins that have less remaining\n    capacity than the item to prevent unused bin scenarios.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Linear decreasing priority based on remaining capacity\n    # Use a slight penalty for bins with less capacity than the item to avoid overflow\n    base_priority = (bins_remain_cap - item) ** 2\n    \n    # Record the number of bins available\n    num_bins = len(bins_remain_cap)\n\n    # Penalize bins that have no space\n    penalty_no_space = np.where(bins_remain_cap < item, -1.0e6, 0.0)\n\n    # Calculate priority score: Balance between base priority (#sii-fit) and no space\n    priority_scores = base_priority + penalty_no_space + np.random.uniform(0, 1e-5, num_bins)\n\n    return priority_scores",
    "response_id": 23,
    "obj": 149.30195452732352,
    "SLOC": 12.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response24.txt_stdout.txt",
    "code_path": "problem_iter1_code24.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This implementation considers both the remaining capacity and the number of\n    bins used using a weighted score. Bins that are closer to being full get higher\n    priority, but the priority is slightly reduced for bins that have less remaining\n    capacity than the item to prevent unused bin scenarios.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Linear decreasing priority based on remaining capacity\n    # Use a max function to avoid negative priorities and ensure feasibility\n    priority = np.maximum(0, bins_remain_cap - item) / item\n    \n    # Give a clear preference to bins that can fit the item at all\n    can_fit_item_mask = bins_remain_cap >= item\n    priority[np.where(~can_fit_item_mask)] -= 2\n    \n    # Encourage the second smallest gaps (fill bigger empty spots\u5c3d\u65e9 to encourage less fragmentation)\n    # Less penalty for bins pediatric returning subtle fragments after an insertion\n    if np.any(can_fit_item_mask):\n        priority_after_check = bins_remain_cap - item\n        highest_remaining_capacities = np.partition(priority_after_check[can_fit_item_mask], 1)[:2]\n        low = highest_remaining_capacities[0] if len(highest_remaining_capacities) > 1 else 0\n        low_idx = np.where(np.isclose(priority_after_check, low))[0]\n        if len(low_idx) == 1:\n            priority[can_fit_item_mask][low_idx] += 0.5\n\n    return priority",
    "response_id": 24,
    "obj": 149.30195452732352,
    "SLOC": 12.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response25.txt_stdout.txt",
    "code_path": "problem_iter1_code25.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This implementation considers both the remaining capacity and the number of\n    bins used using a weighted score. Bins that are closer to being full get higher\n    priority, but the priority is slightly reduced for bins that have less remaining\n    capacity than the item to prevent unused bin scenarios.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Linear decreasing priority based on remaining capacity\n    # Use a max function to avoid negative priorities and ensure feasibility\n    priority = np.maximum(0, bins_remain_cap - item) / item\n    \n    # Give a clear preference to bins that can fit the item at all\n    can_fit_item_mask = bins_remain_cap >= item\n    priority[np.where(~can_fit_item_mask)] -= 2\n    \n    # Encourage the second smallest gaps (fill bigger empty spots\u5c3d\u65e9 to encourage less fragmentation)\n    # Less penalty for bins pediatric returning subtle fragments after an insertion\n    if np.any(can_fit_item_mask):\n        priority_after_check = bins_remain_cap - item\n        highest_remaining_capacities = np.partition(priority_after_check[can_fit_item_mask], 1)[:2]\n        low = highest_remaining_capacities[0] if len(highest_remaining_capacities) > 1 else 0\n        low_idx = np.where(np.isclose(priority_after_check, low))[0]\n        if len(low_idx) == 1:\n            priority[low_idx[0]] += 1  # boost solitare other fragment accent withok followers much step-water pour toplant\u0131\n    \n    return priority",
    "response_id": 25,
    "obj": 145.26326286398086,
    "SLOC": 12.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response26.txt_stdout.txt",
    "code_path": "problem_iter1_code26.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This implementation considers both the remaining capacity and the number of\n    bins used using a weighted score. Bins that are closer to being full get higher\n    priority, but the priority is slightly reduced for bins that have less remaining\n    capacity than the item to prevent unused bin scenarios.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Linear decreasing priority based on remaining capacity\n    # Use a max function to avoid negative priorities and ensure feasibility\n    priority = np.maximum(0, bins_remain_cap - item) / item\n    \n    # Give a clear preference to bins that can fit the item at all\n    can_fit_item_mask = bins_remain_cap >= item\n    priority[np.where(~can_fit_item_mask)] -= 2\n    \n    # Encourage the second smallest gaps (fill bigger empty spots\u5c3d\u65e9 to encourage less fragmentation)\n    # Less penalty for bins pediatric returning subtle fragments after an insertion\n    if np.any(can_fit_item_mask):\n        priority_after_check = bins_remain_cap - item\n        highest_remaining_capacities = np.partition(priority_after_check[can_fit_item_mask], 1)[:2]\n        low = highest_remaining_capacities[0] if len(highest_remaining_capacities) > 1 else 0\n        low_idx = np.where(np.isclose(priority_after_check, low))[0]\n        if len(low_idx) == 1:\n            priority[low_idx[0]] += 1  # boost solitare other fragment accent withok followers much step-water pour toplant\u0131\n    \n    return priority",
    "response_id": 26,
    "obj": 145.26326286398086,
    "SLOC": 12.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response27.txt_stdout.txt",
    "code_path": "problem_iter1_code27.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This implementation considers both the remaining capacity and the number of\n    bins used using a weighted score. Bins that are closer to being full get higher\n    priority, but the priority is slightly reduced for bins that have less remaining\n    capacity than the item to prevent unused bin scenarios.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Linear decreasing priority based on remaining capacity\n    # Use a max function to avoid negative priorities and ensure feasibility\n    priority = np.maximum(0, bins_remain_cap - item) / item\n    \n    # Give a clear preference to bins that can fit the item at all\n    can_fit_item_mask = bins_remain_cap >= item\n    priority[np.where(~can_fit_item_mask)] -= 2\n    \n    # Encourage the second smallest gaps (fill bigger empty spots\u5c3d\u65e9 to encourage less fragmentation)\n    # Less penalty for bins pediatric returning subtle fragments after an insertion\n    if np.any(can_fit_item_mask):\n        priority_after_check = bins_remain_cap - item\n        highest_remaining_capacities = np.partition(priority_after_check[can_fit_item_mask], 1)[:2]\n        low = highest_remaining_capacities[0] if len(highest_remaining_capacities) > 1 else 0\n        low_idx = np.where(np.isclose(priority_after_check, low))[0]\n        if len(low_idx) == 1:\n            priority[low_idx[0]] += 1  # boost solitare other fragment accent withok followers much step-water pour toplant\u0131\n    \n    return priority",
    "response_id": 27,
    "obj": 145.26326286398086,
    "SLOC": 12.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response28.txt_stdout.txt",
    "code_path": "problem_iter1_code28.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This implementation considers both the remaining capacity and the number of\n    bins used using a weighted score. Bins that are closer to being full get higher\n    priority, but the priority is slightly reduced for bins that have less remaining\n    capacity than the item to prevent unused bin scenarios.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Linear decreasing priority based on remaining capacity\n    # Use a max function to avoid negative priorities and ensure feasibility\n    priority = np.maximum(0, bins_remain_cap - item) / item\n    \n    # Give a clear preference to bins that can fit the item at all\n    can_fit_item_mask = bins_remain_cap >= item\n    priority[np.where(~can_fit_item_mask)] -= 2\n    \n    # Encourage the second smallest gaps (fill bigger empty spots\u5c3d\u65e9 to encourage less fragmentation)\n    # Less penalty for bins pediatric returning subtle fragments after an insertion\n    if np.any(can_fit_item_mask):\n        priority_after_check = bins_remain_cap - item\n        highest_remaining_capacities = np.partition(priority_after_check[can_fit_item_mask], 1)[:2]\n        low = highest_remaining_capacities[0] if len(highest_remaining_capacities) > 1 else 0\n        low_idx = np.where(np.isclose(priority_after_check, low))[0]\n        if len(low_idx) == 1:\n            priority[low_idx[0]] += 1  # boost solitare other fragment accent withok followers much step-water pour toplant\u0131\n    \n    return priority",
    "response_id": 28,
    "obj": 145.26326286398086,
    "SLOC": 12.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response29.txt_stdout.txt",
    "code_path": "problem_iter1_code29.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This implementation considers both the remaining capacity and the number of\n    bins used using a weighted score. Bins that are closer to being full get higher\n    priority, but the priority is slightly reduced for bins that have less remaining\n    capacity than the item to prevent unused bin scenarios.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Linear decreasing priority based on remaining capacity\n    # Use a max function to avoid negative priorities and ensure feasibility\n    priority = np.maximum(0, bins_remain_cap - item) / item\n    \n    # Give a clear preference to bins that can fit the item at all\n    can_fit_item_mask = bins_remain_cap >= item\n    priority[np.where(~can_fit_item_mask)] -= 2\n    \n    # Encourage the second smallest gaps (fill bigger empty spots\u5c3d\u65e9 to encourage less fragmentation)\n    # Less penalty for bins pediatric returning subtle fragments after an insertion\n    if np.any(can_fit_item_mask):\n        priority_after_check = bins_remain_cap - item\n        highest_remaining_capacities = np.partition(priority_after_check[can_fit_item_mask], 1)[:2]\n        low = highest_remaining_capacities[0] if len(highest_remaining_capacities) > 1 else 0\n        low_idx = np.where(np.isclose(priority_after_check, low))[0]\n        if len(low_idx) == 1:\n            priority[low_idx[0]] += 1  # boost solitare other fragment accent withok followers much step-water pour toplant\u0131\n    \n    return priority",
    "response_id": 29,
    "obj": 145.26326286398086,
    "SLOC": 12.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  }
]