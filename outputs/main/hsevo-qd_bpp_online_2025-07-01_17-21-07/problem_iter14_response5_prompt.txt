{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Prioritizes bins considering fit and remaining space variance.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    for i, remaining_capacity in enumerate(bins_remain_cap):\n        if item <= remaining_capacity:\n            remaining_space = remaining_capacity - item\n            fit_score = 1.0 / (remaining_space + 0.01)\n\n            # Penalize extreme remaining space relative to item size.\n            size_ratio_penalty = np.abs(item / remaining_capacity - 0.5)\n\n            priorities[i] = fit_score - size_ratio_penalty\n        else:\n            priorities[i] = -np.inf\n\n    # Normalize priorities to improve numerical stability.  Prevents divergence\n    # and potential overflow issues, especially in complex sequences.\n    if np.any(np.isfinite(priorities)):\n        priorities = (priorities - np.min(priorities[np.isfinite(priorities)])) / \\\n                     (np.max(priorities[np.isfinite(priorities)]) - np.min(priorities[np.isfinite(priorities)]))\n    else:\n        priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n                  size_ratio_center: float = 0.5, size_ratio_weight: float = 0.1,\n                  frag_weight: float = 0.2) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin, considering fragmentation.\n\n    This priority function considers the remaining capacity, the fit of the item, and\n    a penalty for the fragmentation that would be caused by placing the item in the bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        fit_score_epsilon: Small constant for numerical stability.\n        size_ratio_center: Target ratio of item size to remaining capacity.\n        size_ratio_weight: Weight of the size ratio penalty.\n        frag_weight: Weight of the fragmentation penalty.\n\n    Return:\n        Array of priorities for each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    for i, remaining_capacity in enumerate(bins_remain_cap):\n        if item <= remaining_capacity:\n            remaining_space = remaining_capacity - item\n\n            # Fit score:  Smaller remaining space is better\n            fit_score = 1.0 / (remaining_space + fit_score_epsilon)\n\n            # Size ratio penalty: Penalize bins where item is too small or too large relative to capacity\n            size_ratio_penalty = size_ratio_weight * np.abs(item / remaining_capacity - size_ratio_center)\n\n            # Fragmentation penalty: Penalize bins that will have very small remaining space. This promotes\n            # filling bins more completely and discourages creating tiny fragments. The penalty is higher\n            # for smaller remaining spaces.  We use a reciprocal to achieve this.\n            frag_penalty = frag_weight / (remaining_space + fit_score_epsilon) if remaining_space > 0 else frag_weight * 1e6\n\n            priorities[i] = fit_score - size_ratio_penalty - frag_penalty\n        else:\n            priorities[i] = -np.inf  # Item doesn't fit\n\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see that the best heuristic incorporates a 'fit score' based on remaining space and a 'size ratio penalty' to avoid extreme fragmentation, while the worst simply uses the negative log of the item-to-capacity ratio. (2nd best) vs (second worst) doesn't exist because of the odd number of heuristics. Comparing (1st) vs (2nd), the best one adds configurability via parameters like `fit_score_epsilon`, `size_ratio_center`, and `size_ratio_weight`. (3rd) vs (4th), the 3rd one doesn't normalize priorities, the 4th one does. Comparing (19th) vs (20th), the functions are identical. Overall: The better heuristics consider both how well an item fits into a bin and the potential for fragmentation, often normalizing the priority scores and providing adjustable parameters to fine-tune the behavior. Simpler heuristics only focus on the ratio of item size to bin capacity. The best heuristics include a size ratio penalty and tunable parameters. Normalizing priorities also seems to help. A well-crafted docstring also seems important.\n- \nOkay, let's craft a refined definition of \"Current Self-Reflection\" for designing better heuristics, steering clear of the pitfalls described in \"Ineffective Self-Reflection.\" We'll focus on actionable insights and a balanced approach.\n\nHere's a redefined approach to self-reflection:\n\n*   **Keywords:** Multi-factor evaluation, Balanced optimization, Parameter tuning, Robustness, Documentation.\n\n*   **Advice:** Actively consider multiple, relevant factors contributing to solution quality (e.g., fit, fragmentation, cost) when devising heuristics. Design heuristics that enable balancing trade-offs between these factors. Prioritize strategies that maintain numerical stability and ensure solutions converge towards acceptable results. Thoroughly document heuristic design choices and parameter interpretations.\n\n*   **Avoid:** Over-reliance on simple ratios, excessive penalization of minor inefficiencies, unnecessary complexity through over-parameterization, and neglecting documentation.\n\n*   **Explanation:** Effective self-reflection involves a holistic assessment of the problem and solution landscape. This means considering multiple interacting factors, understanding the trade-offs between them, and designing heuristics that find a good balance. It also necessitates parameterization for fine-tuning, safeguards against numerical instability, and thorough documentation to facilitate understanding and maintenance. This thoughtful approach will result in more effective and robust heuristics.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}