```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    # Heuristic 1: Waste Minimization with a slight preference for filling up bins already started.
    waste = bins_remain_cap - item
    priorities = np.zeros_like(bins_remain_cap)

    # Assign large negative priority if item doesn't fit.
    priorities[waste < 0] = -np.inf

    # Smallest waste gets highest priority, inverse relationship (minimize waste)
    valid_indices = waste >= 0
    if np.any(valid_indices):
        priorities[valid_indices] = -waste[valid_indices] + 1e-6 * (bins_remain_cap[valid_indices] < 1)  # tie-breaker. Favour smaller capacity bins if all others equal

    # Heuristic 2: Consider near-full bins; high priority for near-full bins.  This helps close out bins.
    near_full_threshold = 0.1  #tune this parameter
    near_full_mask = (bins_remain_cap > 0) & (bins_remain_cap <= item + near_full_threshold)
    priorities[near_full_mask] += 10 # boost priority for near-full bin. Higher values increase aggression.


    # Heuristic 3: Apply a "quantum perturbation" to diversify bin selections.  Introduce some randomness!
    # This can help escape local optima. Scale by item size to perturb more for larger items
    random_noise = np.random.normal(0, 0.01 * item, size=bins_remain_cap.shape) # tune noise level.
    priorities += random_noise


    #Heuristic 4: Try to balance things, use variance as a negative score. Scale by the average
    variance = np.var(bins_remain_cap)
    priorities -= 0.0001 * variance * np.mean(bins_remain_cap)  # try and minimize the variance of usage. TUNE SCALE

    return priorities
```
