```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    My esteemed colleagues, let us prioritize judicious use of each bin, mindful of
    the heavens themselves! Bins with capacities only slightly exceeding our item's
    size should be preferred, leaving less wasted space and thus allowing
    for a more elegant, and efficient, distribution of future objects.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Penalize bins that are too small (cannot accommodate the item)
    priorities[bins_remain_cap < item] = -np.inf

    # Reward bins that fit the item, prioritizing those where the remaining
    # capacity *after* insertion would be small (but not zero). This ensures
    # we aim to fill bins more completely, avoiding large empty spaces.
    valid_bins = bins_remain_cap >= item
    remaining_after_fit = bins_remain_cap[valid_bins] - item
    #avoiding inf and nan
    remaining_after_fit = np.clip(remaining_after_fit, 1e-6, np.inf) # small positive number


    priorities[valid_bins] = -np.log(remaining_after_fit) # Negative log ensures smaller remainders get higher priorities
    #priorities[valid_bins] = 1.0 / remaining_after_fit #Another idea.

    #Consider the proportion of used space; smaller items get a preference
    #This might encourage finding nearly perfect matches
    #priorities[valid_bins]+= (item/bins_remain_cap[valid_bins]) *0.5


    return priorities
```
