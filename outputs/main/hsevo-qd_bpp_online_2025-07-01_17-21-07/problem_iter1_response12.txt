```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Inspired by my laws of motion and universal gravitation,
    this priority function aims to balance efficient space utilization
    with a preference for bins that are not too tightly packed.
    A touch of gravitational thinking: larger bins attract items more readily,
    but not excessively.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    # Eliminate bins that cannot fit the item
    eligible_bins = bins_remain_cap >= item
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    priorities[~eligible_bins] = -np.inf # Exclude bins that are too small

    # Calculate a score based on remaining capacity and item size for eligible bins
    remaining_space = bins_remain_cap[eligible_bins] - item
    # A measure of how well the item fits (higher is better, approaching zero indicates full bin)
    fit_score = np.exp(-10 * np.abs(remaining_space / bins_remain_cap[eligible_bins])) if np.any(eligible_bins) else np.array([])

    # Assign the computed scores
    priorities[eligible_bins] = (remaining_space + item)**0.5 + fit_score #Favor bins with a tighter fit
    priorities[eligible_bins] = np.nan_to_num(priorities[eligible_bins], nan=-np.inf)

    return priorities
```
