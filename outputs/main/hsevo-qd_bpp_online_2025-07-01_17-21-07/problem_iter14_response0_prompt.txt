{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Calculate bin priorities considering fit and fragmentation.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if item <= cap:\n            remaining_space = cap - item\n            fit_score = 1.0 / (remaining_space + 0.01)\n            size_ratio_penalty = np.abs(item / cap - 0.5)\n            priorities[i] = fit_score - size_ratio_penalty\n        else:\n            priorities[i] = -np.inf\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This priority function considers both the remaining capacity of the bin\n    and how well the item fits relative to that capacity. Bins with capacity\n    slightly larger than the item are preferred (best fit). It penalizes\n    bins where the item would result in very little space left or bins where\n    the item is too small relative to the available space.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        fit_score_epsilon: Small constant added to remaining space to avoid division by zero.\n        size_ratio_target: Target ratio of item size to remaining capacity (e.g., 0.5 for capacities close to 2x the item).\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Iterate through each bin and calculate its priority\n    for i, remaining_capacity in enumerate(bins_remain_cap):\n        if item <= remaining_capacity:\n            # Calculate the remaining space after placing the item\n            remaining_space = remaining_capacity - item\n\n            # Calculate a 'fit' score.  Smaller remaining space implies better fit, but we add a small\n            # constant to avoid division by zero problems or infinite penalties\n            fit_score = 1.0 / (remaining_space + fit_score_epsilon)\n\n            # Optionally, we can also incentivize the use of bins that aren't 'too full' to start,\n            # and/or penalize overly small item relative to the bins capacity.\n            # This part prevents extremely small items constantly getting stuffed into bins due to high `fit_score`\n            #  due to little `remaining_space` because an item of ~ 0 size was added to that bin.\n            size_ratio_penalty = np.abs(item/remaining_capacity - size_ratio_target) # Prefer capacities close to 2x the item.\n\n            priorities[i] = fit_score - size_ratio_penalty\n            #priorities[i] = fit_score # Removed size ratio penalty since it caused worse packing.\n        else:\n            # If the item doesn't fit, give a very low priority\n            priorities[i] = -np.inf\n\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see that the best heuristic incorporates a 'fit score' based on remaining space and a 'size ratio penalty' to avoid extreme fragmentation, while the worst simply uses the negative log of the item-to-capacity ratio. (2nd best) vs (second worst) doesn't exist because of the odd number of heuristics. Comparing (1st) vs (2nd), the best one adds configurability via parameters like `fit_score_epsilon`, `size_ratio_center`, and `size_ratio_weight`. (3rd) vs (4th), the 3rd one doesn't normalize priorities, the 4th one does. Comparing (19th) vs (20th), the functions are identical. Overall: The better heuristics consider both how well an item fits into a bin and the potential for fragmentation, often normalizing the priority scores and providing adjustable parameters to fine-tune the behavior. Simpler heuristics only focus on the ratio of item size to bin capacity. The best heuristics include a size ratio penalty and tunable parameters. Normalizing priorities also seems to help. A well-crafted docstring also seems important.\n- \nOkay, let's craft a refined definition of \"Current Self-Reflection\" for designing better heuristics, steering clear of the pitfalls described in \"Ineffective Self-Reflection.\" We'll focus on actionable insights and a balanced approach.\n\nHere's a redefined approach to self-reflection:\n\n*   **Keywords:** Multi-factor evaluation, Balanced optimization, Parameter tuning, Robustness, Documentation.\n\n*   **Advice:** Actively consider multiple, relevant factors contributing to solution quality (e.g., fit, fragmentation, cost) when devising heuristics. Design heuristics that enable balancing trade-offs between these factors. Prioritize strategies that maintain numerical stability and ensure solutions converge towards acceptable results. Thoroughly document heuristic design choices and parameter interpretations.\n\n*   **Avoid:** Over-reliance on simple ratios, excessive penalization of minor inefficiencies, unnecessary complexity through over-parameterization, and neglecting documentation.\n\n*   **Explanation:** Effective self-reflection involves a holistic assessment of the problem and solution landscape. This means considering multiple interacting factors, understanding the trade-offs between them, and designing heuristics that find a good balance. It also necessitates parameterization for fine-tuning, safeguards against numerical instability, and thorough documentation to facilitate understanding and maintenance. This thoughtful approach will result in more effective and robust heuristics.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}