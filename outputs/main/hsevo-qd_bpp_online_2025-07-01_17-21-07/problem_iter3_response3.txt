```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This priority function considers the remaining capacity, the item's fit,
    and a penalty based on how much the item fills the bin (to avoid tiny items
    filling up bins prematurely). It also adds a bonus for bins that, after
    packing the item, would have a remaining capacity close to the mean
    remaining capacity across all bins. This encourages a more balanced
    distribution of remaining space, which can improve overall packing efficiency.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Iterate through each bin and calculate its priority
    for i, remaining_capacity in enumerate(bins_remain_cap):
        if item <= remaining_capacity:
            # Calculate the remaining space after placing the item
            remaining_space = remaining_capacity - item

            # Calculate a 'fit' score. Smaller remaining space implies better fit.
            fit_score = 1.0 / (remaining_space + 0.01)

            # Penalty for how much of the bin the item fills.  We want to avoid
            # using up an entire bin with a tiny item.  This penalizes bins that
            # would be mostly empty *after* the item is placed.
            fill_penalty = np.abs(remaining_space / (remaining_capacity + 0.01) - 0.5)

            # Calculate bonus for remaining capacity close to the mean.
            # This encourages using bins so that their remaining capacities are similar,
            # leading to better distribution of items.
            potential_remain_caps = bins_remain_cap - item
            potential_remain_caps = potential_remain_caps[potential_remain_caps >= 0]
            if len(potential_remain_caps) > 0:
                mean_remaining = np.mean(potential_remain_caps)
                capacity_balance_bonus = -np.abs(remaining_space - mean_remaining) * 0.1
            else:
                capacity_balance_bonus = 0

            priorities[i] = fit_score - fill_penalty + capacity_balance_bonus

        else:
            # If the item doesn't fit, give a very low priority
            priorities[i] = -np.inf

    return priorities
```
