```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray, fit_score_epsilon: float = 1e-6, size_ratio_center: float = 0.5, size_ratio_weight: float = 0.1, frag_weight: float = 0.2) -> np.ndarray:
    """
    Calculates a priority score for adding an item to each bin, considering multiple factors:
    - Fit score: How well the item fits into the remaining capacity.
    - Size ratio penalty: Penalizes bins where the item's size is disproportionate to the remaining capacity.
    - Fragmentation cost: Penalizes bins that would result in a large amount of unused space (fragmentation).

    Args:
        item: Size of the item to be packed.
        bins_remain_cap: Array of remaining capacities for each bin.
        fit_score_epsilon: Small constant to avoid division by zero.
        size_ratio_center: Target ratio of item size to remaining capacity.
        size_ratio_weight: Weight of the size ratio penalty.
        frag_weight: Weight of the fragmentation penalty.

    Returns:
        Array of priority scores for each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    for i, remaining_capacity in enumerate(bins_remain_cap):
        if item <= remaining_capacity:
            remaining_space = remaining_capacity - item

            # Fit score (higher is better)
            fit_score = 1.0 / (remaining_space + fit_score_epsilon)

            # Size ratio penalty (lower is better)
            size_ratio_penalty = size_ratio_weight * np.abs(item / remaining_capacity - size_ratio_center)

            # Fragmentation cost (lower is better)
            # Penalize bins that would result in high percentage of unused space.
            frag_cost = frag_weight * (remaining_space / (remaining_capacity + fit_score_epsilon)) # normalized by initial capacity.

            priorities[i] = fit_score - size_ratio_penalty - frag_cost
        else:
            priorities[i] = -np.inf  # Item doesn't fit

    return priorities
```
