```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version prioritizes bins that have just enough space for the item,
    while also penalizing bins that are too full (leading to fragmentation)
    or too empty (inefficient use of bins).

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    for i, cap in enumerate(bins_remain_cap):
        if cap < item:
            priorities[i] = -np.inf  # Cannot fit, lowest priority
        else:
            # Reward bins that can fit the item reasonably well
            # and penalize bins that are too full (small remaining space after packing) or too empty
            remaining_space_after_packing = cap - item
            
            # Define a "sweet spot" for remaining space. We want bins that aren't overly fragmented, but also aren't being underutilized.  Let's target a remaining space that's 10-50% of bin capacity.

            target_range_low = 0.1 * item
            target_range_high = 0.5 * item

            if remaining_space_after_packing >= target_range_low and remaining_space_after_packing <= target_range_high:
                priorities[i] = 10 # Give high priority if it's within target range.
            else:
                #Otherwise, create a priority score based on the distance of the remaining_space_after_packing to the sweetspot
                distance_to_sweetspot = min(abs(remaining_space_after_packing - target_range_low), abs(remaining_space_after_packing - target_range_high))
                priorities[i] = max(0, 5 - distance_to_sweetspot) #Prioritize closer to the range, but ensure it is not lower than zero
            

            #Give a minor boost to bins close to being full (but still valid!)
            if 0 < remaining_space_after_packing < item * 0.05:
                priorities[i] += 2

            #Avoid cases with large residual space.
            if remaining_space_after_packing > item * 2:
                priorities[i] -= 1
    return priorities
```
