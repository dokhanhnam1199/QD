```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Initialize priorities to a very low value. This ensures that bins that cannot accommodate the item
    # will have the lowest priority.
    priorities = np.full_like(bins_remain_cap, -np.inf)

    # Find bins that can accommodate the item.
    valid_bins = bins_remain_cap >= item

    if np.any(valid_bins):
        # Calculate remaining capacity AFTER placing the item (positive values are desirable).
        remaining_capacity = bins_remain_cap[valid_bins] - item

        # Give higher priority to bins where the item fits snugly, i.e., the wasted space is minimized.
        # Use a combination of normalized remaining capacity (between 0 and 1) and a negative
        # exponential function to penalize larger remaining capacities. A small remaining capacity
        # receives higher priority than a much larger one, even if the latter can fit several more items
        # in future rounds.

        priority_scores = np.exp(-remaining_capacity)

        priorities[valid_bins] = priority_scores
    else:
        #if the item doesn't fit anywhere, prioritize based on minimum waste
        waste = item - bins_remain_cap
        min_waste = np.min(waste)
        priorities = -waste # priorize bins with smallest negative waste
    
    return priorities
```
