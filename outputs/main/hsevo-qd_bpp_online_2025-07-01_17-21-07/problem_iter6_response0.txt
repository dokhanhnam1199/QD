```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This priority function considers both the remaining capacity of the bin
    and how well the item fits relative to that capacity. Bins with capacity
    slightly larger than the item are preferred. It aims to reduce fragmentation
    by considering the absolute waste and a relative fullness score.  It avoids
    adding items to bins that will result in tiny remaining spaces.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    for i, remaining_capacity in enumerate(bins_remain_cap):
        if item <= remaining_capacity:
            remaining_space = remaining_capacity - item

            # Fragmentation control: Penalize bins that will have very small remaining space
            if remaining_space < 0.1:  # Adjust this threshold as needed
                fragmentation_penalty = -10  # High penalty for tiny remaining space
            else:
                fragmentation_penalty = 0

            # Fullness score: Encourage using bins that are relatively full after adding the item
            fullness_score = item / remaining_capacity # Closer to 1 is better

            # Waste penalty: Penalize large waste
            waste_penalty = remaining_space

            priorities[i] = fullness_score - waste_penalty + fragmentation_penalty
            #A little extra boost for almost full bins (reduces number of bins used)
            if remaining_space < 0.25:
                priorities[i] += 0.1
        else:
            priorities[i] = -np.inf

    return priorities
```
