```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Combines best-fit and ratio approaches with normalization."""

    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    fit_score_epsilon = 1e-6
    size_ratio_target = 0.5

    for i, remaining_capacity in enumerate(bins_remain_cap):
        if item <= remaining_capacity:
            remaining_space = remaining_capacity - item
            fit_score = 1.0 / (remaining_space + fit_score_epsilon)
            size_ratio_penalty = np.abs(item / remaining_capacity - size_ratio_target)
            priorities[i] = fit_score - size_ratio_penalty
        else:
            priorities[i] = -np.inf

    # Normalize priorities to [0, 1]
    if np.isinf(priorities).all():
        return priorities # Handles the case where all priorities are -inf, return directly

    priorities[priorities == -np.inf] = np.nan  # Convert -inf to NaN for normalization
    min_val = np.nanmin(priorities)
    max_val = np.nanmax(priorities)
    priorities[np.isnan(priorities)] = min_val  # Replace NaN with min_val after calculation, avoid modify original '-inf' values.

    if max_val > min_val:  # Avoid division by zero if all bins are full and inf
        priorities = (priorities - min_val) / (max_val - min_val)
    else:
        priorities = np.zeros_like(priorities) # If all bins have same priority

    return priorities
```
