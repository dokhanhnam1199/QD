{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Prioritizes bins based on fit and fragmentation, normalized.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    for i, remaining_capacity in enumerate(bins_remain_cap):\n        if item <= remaining_capacity:\n            remaining_space = remaining_capacity - item\n            fit_score = 1.0 / (remaining_space + 0.01)\n            size_ratio_penalty = np.abs(item / remaining_capacity - 0.5)\n            priorities[i] = fit_score - size_ratio_penalty\n        else:\n            priorities[i] = -np.inf\n\n    if np.any(np.isfinite(priorities)):\n        min_finite = np.min(priorities[np.isfinite(priorities)])\n        max_finite = np.max(priorities[np.isfinite(priorities)])\n        priorities = (priorities - min_finite) / (max_finite - min_finite)\n    else:\n        priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    ratios = item / bins_remain_cap\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see that the best heuristic incorporates a 'fit score' based on remaining space and a 'size ratio penalty' to avoid extreme fragmentation, while the worst simply uses the negative log of the item-to-capacity ratio. (2nd best) vs (second worst) doesn't exist because of the odd number of heuristics. Comparing (1st) vs (2nd), the best one adds configurability via parameters like `fit_score_epsilon`, `size_ratio_center`, and `size_ratio_weight`. (3rd) vs (4th), the 3rd one doesn't normalize priorities, the 4th one does. Comparing (19th) vs (20th), the functions are identical. Overall: The better heuristics consider both how well an item fits into a bin and the potential for fragmentation, often normalizing the priority scores and providing adjustable parameters to fine-tune the behavior. Simpler heuristics only focus on the ratio of item size to bin capacity. The best heuristics include a size ratio penalty and tunable parameters. Normalizing priorities also seems to help. A well-crafted docstring also seems important.\n- \nOkay, let's craft a refined definition of \"Current Self-Reflection\" for designing better heuristics, steering clear of the pitfalls described in \"Ineffective Self-Reflection.\" We'll focus on actionable insights and a balanced approach.\n\nHere's a redefined approach to self-reflection:\n\n*   **Keywords:** Multi-factor evaluation, Balanced optimization, Parameter tuning, Robustness, Documentation.\n\n*   **Advice:** Actively consider multiple, relevant factors contributing to solution quality (e.g., fit, fragmentation, cost) when devising heuristics. Design heuristics that enable balancing trade-offs between these factors. Prioritize strategies that maintain numerical stability and ensure solutions converge towards acceptable results. Thoroughly document heuristic design choices and parameter interpretations.\n\n*   **Avoid:** Over-reliance on simple ratios, excessive penalization of minor inefficiencies, unnecessary complexity through over-parameterization, and neglecting documentation.\n\n*   **Explanation:** Effective self-reflection involves a holistic assessment of the problem and solution landscape. This means considering multiple interacting factors, understanding the trade-offs between them, and designing heuristics that find a good balance. It also necessitates parameterization for fine-tuning, safeguards against numerical instability, and thorough documentation to facilitate understanding and maintenance. This thoughtful approach will result in more effective and robust heuristics.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}