```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray, fit_score_epsilon: float = 1e-6, size_ratio_center: float = 0.5, size_ratio_weight: float = 0.1, frag_weight: float = 0.2) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This priority function considers the remaining capacity, the fit of the item,
    and a fragmentation penalty. It aims to balance fitting items well with
    minimizing the creation of small, unusable spaces.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.
        fit_score_epsilon: Small constant for numerical stability.
        size_ratio_center: Target ratio of item size to remaining capacity.
        size_ratio_weight: Weight of the size ratio penalty.
        frag_weight: Weight of the fragmentation penalty.

    Return:
        Array of priorities for each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    for i, remaining_capacity in enumerate(bins_remain_cap):
        if item <= remaining_capacity:
            remaining_space = remaining_capacity - item
            
            # Fit score (higher is better)
            fit_score = 1.0 / (remaining_space + fit_score_epsilon)
            
            # Size ratio penalty (lower is better)
            size_ratio_penalty = size_ratio_weight * np.abs(item / remaining_capacity - size_ratio_center)
            
            # Fragmentation penalty (lower is better).  Penalizes bins where the remaining
            # space is very small, creating fragmentation.
            frag_penalty = 0.0
            if remaining_space > 0 and remaining_space < 0.1:  # e.g., penalize remaining space less than 10% of bin size. Can be tuned.
                frag_penalty = frag_weight * (0.1 - remaining_space) # Linear penalty.

            priorities[i] = fit_score - size_ratio_penalty - frag_penalty
        else:
            priorities[i] = -np.inf

    return priorities
```
