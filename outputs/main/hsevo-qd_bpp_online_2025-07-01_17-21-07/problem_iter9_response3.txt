```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray, fit_score_epsilon: float = 0.001, size_ratio_center: float = 0.5, size_ratio_weight: float = 0.5, capacity_usage_exponent: float = 2.0) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This priority function considers the remaining capacity, the fit of the item, and encourages filling bins.
    It prioritizes bins where the item fits well and the bin is already somewhat full, avoiding fragmentation.
    Also adds a capacity usage component to improve bin utilization.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.
        fit_score_epsilon: Small constant added to remaining_space to avoid division by zero.
        size_ratio_center: Target ratio of item size to remaining capacity (default 0.5, i.e., capacity is twice the item size).
        size_ratio_weight: Weight of the size ratio penalty in the overall priority score.
        capacity_usage_exponent: Controls the strength of the capacity usage bonus. Higher values favor fuller bins more strongly.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    bin_size = 1.0 # Assuming bin size is 1, modify if different

    for i, remaining_capacity in enumerate(bins_remain_cap):
        if item <= remaining_capacity:
            remaining_space = remaining_capacity - item

            # Fit score (smaller remaining space is better)
            fit_score = 1.0 / (remaining_space + fit_score_epsilon)

            # Size ratio penalty (penalize very small or large ratios)
            size_ratio_penalty = size_ratio_weight * np.abs(item / remaining_capacity - size_ratio_center)

            # Capacity Usage: Encourage filling partially filled bins. We calculate how much of the bin has already been used
            capacity_used = bin_size - remaining_capacity
            capacity_usage_bonus = (capacity_used / bin_size)**capacity_usage_exponent

            priorities[i] = fit_score - size_ratio_penalty + capacity_usage_bonus
        else:
            priorities[i] = -np.inf

    return priorities
```
