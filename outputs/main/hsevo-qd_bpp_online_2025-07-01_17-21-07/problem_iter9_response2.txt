```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray, fit_score_epsilon: float = 0.001, size_ratio_center: float = 0.5, size_ratio_weight: float = 0.5, capacity_threshold: float = 0.9) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This priority function considers the remaining capacity, fit, and bin fullness.
    It incorporates a bin selection strategy that favors bins that are already relatively full,
    but still have enough space for the current item.  This is to avoid creating many bins with
    very small amounts of wasted space. It also adds a direct penalty based on how full the bin will be *after* the item is added,
    to aggressively try and fill bins completely.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.
        fit_score_epsilon: Small constant added to remaining_space to avoid division by zero.
        size_ratio_center: Target ratio of item size to remaining capacity.
        size_ratio_weight: Weight of the size ratio penalty.
        capacity_threshold: Threshold to consider a bin "relatively full."

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    for i, remaining_capacity in enumerate(bins_remain_cap):
        if item <= remaining_capacity:
            remaining_space = remaining_capacity - item
            fit_score = 1.0 / (remaining_space + fit_score_epsilon)

            size_ratio_penalty = size_ratio_weight * np.abs(item / remaining_capacity - size_ratio_center)

            # Encourage filling bins that are already relatively full.
            fullness_bonus = 0.0
            if remaining_capacity / np.max(bins_remain_cap) < capacity_threshold:  # Dynamically normalized to max capacity.  Avoids bias with fixed thresholds
                fullness_bonus = (1 - remaining_capacity / np.max(bins_remain_cap))  # The fuller, the more bonus

            # Aggressively penalize bins that, after adding the item, are NOT nearly full
            post_fill_penalty = 0.0
            post_fill_ratio = (remaining_capacity - item) / np.max(bins_remain_cap) # Ratio AFTER the item is placed.
            post_fill_penalty =  5* post_fill_ratio # Significantly penalizes lower post-fill ratios

            priorities[i] = fit_score - size_ratio_penalty + fullness_bonus - post_fill_penalty
        else:
            priorities[i] = -np.inf

    return priorities
```
