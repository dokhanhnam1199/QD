```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Calculates bin priorities considering fit and target ratio."""

    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    fit_score_epsilon = 1e-6  # Avoid division by zero
    size_ratio_target = 0.75 # Target ratio of item size to remaining capacity

    for i, remaining_capacity in enumerate(bins_remain_cap):
        if item <= remaining_capacity:
            remaining_space = remaining_capacity - item
            fit_score = 1.0 / (remaining_space + fit_score_epsilon)
            size_ratio_penalty = np.abs(item / remaining_capacity - size_ratio_target)
            priorities[i] = fit_score - size_ratio_penalty
        else:
            priorities[i] = -np.inf

    # Normalize priorities to [0, 1] range to avoid bias
    if np.isinf(priorities).all(): # Handle the extreme case
        return priorities # If all bins can't hold the item, return -inf.
    else:
        valid_priorities = priorities[~np.isinf(priorities)]
        min_priority = valid_priorities.min()
        max_priority = valid_priorities.max()
        if max_priority > min_priority:
            priorities[~np.isinf(priorities)] = (priorities[~np.isinf(priorities)] - min_priority) / (max_priority - min_priority)
        else:
            priorities[~np.isinf(priorities)] = 0.5   #All bins has approximately same priority

    return priorities
```
