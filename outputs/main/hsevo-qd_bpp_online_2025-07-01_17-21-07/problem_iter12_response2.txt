```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray, fit_score_epsilon: float = 1e-6,
                  size_ratio_center: float = 0.5, size_ratio_weight: float = 0.1,
                  frag_penalty_power: float = 2.0, cap_weight: float = 1.0) -> np.ndarray:
    """Improved priority function for online bin packing.

    This function considers multiple factors to determine the priority of adding an item to a bin:
    1.  **Fit Score:**  How well the item fits (smaller remaining space is better).
    2.  **Size Ratio Penalty:** Penalizes bins where the item is too small or too large relative to capacity.
    3.  **Fragmentation Penalty:**  Penalizes bins that would result in small remaining fragments.
    4.  **Capacity Weight:** Incentivizes using bins with larger remaining capacity up to a point

    Args:
        item: Size of the item to be packed.
        bins_remain_cap: Remaining capacity of each bin.
        fit_score_epsilon: Small constant to avoid division by zero.
        size_ratio_center: Target ratio of item size to remaining capacity.
        size_ratio_weight: Weight of the size ratio penalty.
        frag_penalty_power:  Power to apply to the fragmentation penalty (higher = more aggressive).
        cap_weight: Weight to apply to bin capacity

    Returns:
        Priority score for each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    for i, remaining_capacity in enumerate(bins_remain_cap):
        if item <= remaining_capacity:
            remaining_space = remaining_capacity - item

            # Fit Score (higher is better)
            fit_score = 1.0 / (remaining_space + fit_score_epsilon)

            # Size Ratio Penalty (lower is better)
            size_ratio_penalty = size_ratio_weight * np.abs(item / remaining_capacity - size_ratio_center)

            # Fragmentation Penalty (lower is better).  Penalize creating small fragments
            frag_penalty = (remaining_space**frag_penalty_power) if remaining_space > 0 else 0.0  # Avoid negative values

            # capacity_score -> slightly favour larger capacity bins
            capacity_score = cap_weight * remaining_capacity

            # Combine the scores.  Here, we *subtract* the penalties because they represent "costs".
            priorities[i] = capacity_score + fit_score - size_ratio_penalty - frag_penalty # Include capacity score.
        else:
            priorities[i] = -np.inf  # Item doesn't fit

    return priorities
```
