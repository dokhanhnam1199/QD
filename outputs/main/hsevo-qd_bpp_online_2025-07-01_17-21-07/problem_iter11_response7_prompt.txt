{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Prioritizes bins considering fit and remaining space variance.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    for i, remaining_capacity in enumerate(bins_remain_cap):\n        if item <= remaining_capacity:\n            remaining_space = remaining_capacity - item\n            fit_score = 1.0 / (remaining_space + 0.01)\n\n            # Penalize extreme remaining space relative to item size.\n            size_ratio_penalty = np.abs(item / remaining_capacity - 0.5)\n\n            priorities[i] = fit_score - size_ratio_penalty\n        else:\n            priorities[i] = -np.inf\n\n    # Normalize priorities to improve numerical stability.  Prevents divergence\n    # and potential overflow issues, especially in complex sequences.\n    if np.any(np.isfinite(priorities)):\n        priorities = (priorities - np.min(priorities[np.isfinite(priorities)])) / \\\n                     (np.max(priorities[np.isfinite(priorities)]) - np.min(priorities[np.isfinite(priorities)]))\n    else:\n        priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    ratios = item / bins_remain_cap\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see the best heuristic incorporates a fit score based on remaining space and a size ratio penalty, while the worst only considers the log of the ratio of item size to remaining capacity. The best uses `1.0 / (remaining_space + fit_score_epsilon)` for `fit_score`, and `size_ratio_penalty = size_ratio_weight * np.abs(item/remaining_capacity - size_ratio_center)`, while the worst directly calculates `ratios = item / bins_remain_cap`, `log_ratios = np.log(ratios)` and returns `-log_ratios`.\n\nComparing (2nd best) vs (second worst), heuristics are almost identical.\n\nComparing (1st) vs (2nd), the code is identical, suggesting ranking is based on factors outside the scope of the code itself (e.g., hyperparameter tuning, experimental setup, dataset properties).\n\nComparing (3rd) vs (4th), heuristics are almost identical.\n\nComparing (second worst) vs (worst), the main difference lies in the use of logarithm. The second worst computes priorities as `-log_ratios` based on the ratio of item size to bin capacity, while the worst also does the same, so they are identical.\n\nOverall:\n\nThe better heuristics use a combination of \"fit score\" (based on remaining space) and a \"size ratio penalty,\" with the fit score incentivizing minimal remaining space, and the size ratio penalty discouraging the item from being either too small or too large relative to the bin's capacity. Normalization and careful handling of edge cases (e.g., preventing division by zero) also appear beneficial. Simpler approaches using only item-to-capacity ratios or their logarithms perform poorly. Parameter tuning (e.g., `fit_score_epsilon`, `size_ratio_center`, `size_ratio_weight`) seems crucial. The use of absolute difference in size ratio calculations is better than simple ratios or logarithmic ratios. Normalization appears to improve numerical stability.\n- \nOkay, let's refine \"Current Self-Reflection\" to be more actionable and less like the \"Ineffective\" example, focusing on design principles for better heuristics:\n\nHere's a breakdown:\n\n*   **Keywords:** Multi-factor evaluation, fragmentation cost, parameter tuning, numerical stability.\n\n*   **Advice:** Design heuristics that evaluate multiple aspects of a packing decision (fit, fragmentation impact). Quantify fragmentation cost to penalize bad space usage. Use parameters for fine-grained control. Normalize *when* it demonstrably improves stability.\n\n*   **Avoid:** Oversimplification based only on ratios, assuming normalization *always* helps, rigid parameter settings (allow instance-specific tuning).\n\n*   **Explanation:** Better heuristics look at multiple factors and parameterization is to make them robust to various bin-packing instances with varying properties. Normalization should only be applied when it is clearly improving numerical stability during evaluation and/or operation.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}